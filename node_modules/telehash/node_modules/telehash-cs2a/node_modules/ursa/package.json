{
  "name": "ursa",
  "version": "0.8.3",
  "keywords": [
    "crypto",
    "key",
    "openssl",
    "private",
    "public",
    "rsa",
    "sign",
    "signature",
    "verify",
    "verification",
    "hash",
    "digest"
  ],
  "description": "RSA public/private key OpenSSL bindings for node and io.js",
  "homepage": "https://github.com/quartzjer/ursa",
  "repository": {
    "type": "git",
    "url": "https://github.com/quartzjer/ursa.git"
  },
  "licenses": [
    {
      "type": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  ],
  "author": {
    "name": "Dan Bornstein",
    "email": "danfuzz@milk.com",
    "url": "http://www.milk.com/"
  },
  "maintainers": [
    {
      "name": "Jeremie Miller",
      "email": "jeremie@jabber.org",
      "url": "http://jeremie.com/"
    }
  ],
  "main": "lib/ursa.js",
  "engine": {
    "node": ">=0.6.0"
  },
  "scripts": {
    "test": "node test/test.js",
    "install": "node-gyp rebuild"
  },
  "dependencies": {
    "bindings": "^1.2.1",
    "nan": "~1.6.2"
  },
  "gypfile": true,
  "readme": "URSA - RSA public/private key OpenSSL bindings for Node.js\n====\n\n[![Build Status](https://travis-ci.org/quartzjer/ursa.svg?branch=master)](https://travis-ci.org/quartzjer/ursa)\n\n> NOTE: This package was transfered from [Medium](https://github.com/Medium) and [NodePrime](https://github.com/NodePrime) to [quartzjer](https://github.com/quartzjer) in February 2015. Pull requests are welcomed to help maintain it.\n\n--\n\nThis Node module provides a fairly complete set of wrappers for the\nRSA public/private key crypto functionality of OpenSSL.\n\nIt is being actively developed for node.js 0.8.* through 0.12.* and io.js. If you find it doesn't work for you, please file a bug (see below).\n\nIt has been tested on Windows by [SLaks](https://github.com/SLaks).  (see additional installation requirements)\n\n\nBuilding and Installing\n-----------------------\n\n```shell\nnpm install ursa\n```\n\nOr grab the source and\n\n```shell\nnpm install\n```\n\nSimple Encrypt / Decrypt Example\n--------------------------------\n\n```javascript\n// openssl genrsa -out certs/server/my-server.key.pem 2048\n// openssl rsa -in certs/server/my-server.key.pem -pubout -out certs/client/my-server.pub\n\n'use strict';\n\nvar fs = require('fs')\n  , ursa = require('ursa')\n  , crt\n  , key\n  , msg\n  ;\n\nkey = ursa.createPrivateKey(fs.readFileSync('./certs/server/my-server.key.pem'));\ncrt = ursa.createPublicKey(fs.readFileSync('./certs/client/my-server.pub'));\n\nconsole.log('Encrypt with Public');\nmsg = crt.encrypt(\"Everything is going to be 200 OK\", 'utf8', 'base64');\nconsole.log('encrypted', msg, '\\n');\n\nconsole.log('Decrypt with Private');\nmsg = key.decrypt(msg, 'base64', 'utf8');\nconsole.log('decrypted', msg, '\\n');\n\nconsole.log('############################################');\nconsole.log('Reverse Public -> Private, Private -> Public');\nconsole.log('############################################\\n');\n\ncrt = ursa.createPrivateKey(fs.readFileSync('./certs/server/my-server.key.pem'));\nkey = ursa.createPublicKey(fs.readFileSync('./certs/client/my-server.pub'));\n\nconsole.log('Encrypt with Private (called public)');\nmsg = key.encrypt(\"Everything is going to be 200 OK\", 'utf8', 'base64');\nconsole.log('encrypted', msg, '\\n');\n\nconsole.log('Decrypt with Public (called private)');\nmsg = crt.decrypt(msg, 'base64', 'utf8');\nconsole.log('decrypted', msg, '\\n');\n```\n\nTesting\n-------\n\n```shell\nnpm test\n```\n\nOr\n\n```shell\nnode ./test/test.js\n```\n\nOn Windows, you'll need to install some dependencies first:\n - [OpenSSL](http://slproweb.com/products/Win32OpenSSL.html) (normal, not light)\nin the same bitness as your Node.js installation.\n  - The build script looks for OpenSSL in the default install directory  \n  (`C:\\OpenSSL-Win32` or `C:\\OpenSSL-Win64`)\n  - If you get `Error: The specified module could not be found.`, copy `libeay32.dll` from the OpenSSL bin directory to this module's bin directory, or to Windows\\System3.\n - [node-gyp](https://github.com/TooTallNate/node-gyp/) (`npm install -g node-gyp`)\n   - [Python 2.7](http://www.python.org/download/releases/2.7.3#download) (not 3.3)\n   - Microsoft Visual Studio C++ _**(either of the two below but not both)**_\n        - `Microsoft Visual Studio C++ 2013 for Windows Desktop` ([Express](http://www.microsoft.com/en-au/download/details.aspx?id=40787) version works well)\n            - No extra patches should be needed, but requires a fully up-to-date machine including all of the latest service packs\n        - Older versions of Visual Studio\n            - Windows XP/Vista/7:\n                - `Microsoft Visual Studio C++ 2010` ([Express](http://go.microsoft.com/?linkid=9709949) version works well)\n                    - For 64-bit builds of node and native modules you will _**also**_ need the [Windows 7 64-bit SDK](http://www.microsoft.com/en-us/download/details.aspx?id=8279)\n                    - If you get errors that the 64-bit compilers are not installed you may also need the [compiler update for the Windows SDK 7.1](http://www.microsoft.com/en-us/download/details.aspx?id=4422)\n            - Windows 8:\n                - `Microsoft Visual Studio C++ 2012 for Windows Desktop` ([Express](http://go.microsoft.com/?linkid=9816758) version works well)\n\n\nUsage\n-----\n\nThis library aims to be convenient to use, allowing one to pass in and\nget back regular string objects. However, it is also meant to be reasonably\neasy to use efficiently, allowing one to pass in and get back Buffer\nobjects. Using Buffers is always the more efficient option.\n\nAll methods that can deal with strings take one or more arguments indicating\nthe encoding to use when interpreting an argument or generating a result.\nThese are limited to the usual encoding names that are valid for use with\nBuffers: `base64` `binary` `hex` and `utf8`. If an encoding is left undefined\nand the argument is a string, then the encoding is *always* assumed to be\n`utf8`. If an argument is a Buffer, then the encoding (if defined at all)\nis ignored. An undefined output encoding is *always* interpreted as a request\nfor a Buffer result.\n\nThe library knows how to read and output PEM format files for both\npublic and private keys, and it can generate new private keys (aka\nkeypairs).\n\nThe usual public-encryption / private-decryption operations by default\nuse padding mode `RSA_PKCS1_OAEP_PADDING`, which is the recommended\nmode for all new applications (as of this writing). Note that this mode\nbuilds-in a random element into every encryption operation, making it\nunnecessary to waste time or effort adding randomness in at a higher layer.\nThis default may be overridden to use the older mode `RSA_PKCS1_PADDING`\nif needed.\n\nThe less well-understood private-encryption / public-decryption operations\n(used for building signature mechanisms) by default use padding\nmode `RSA_PKCS1_PADDING`. This doesn't build in any randomness (but that's\nnot usually a problem for applications that use these operations).  This \ndefault may be overridden to use `RSA_NO_PADDING` if needed.\n\nSee the doc comments and tests for the excruciating details, but here's\na quick rundown of the available top-level exports and instance methods:\n\nTop-Level Exports\n-----------------\n\n### ursa.createPrivateKey(pem, password, encoding)\n\nCreate and return a private key (aka a keypair) read in from the given\nPEM-format file.  If defined, the given password is used to decrypt\nthe PEM file.\n\nThe encoding, if specified, applies to both other arguments.\n\nSee \"Public Key Methods\" below for more details.\n\n### ursa.createPrivateKeyFromComponents(modulus, exponent, p, q, dp, dq, inverseQ, d)\n\nCreate and return a private key from the given components.\n\n### ursa.createPublicKeyFromComponents(modulus, exponent)\n\nCreate and return a public key from the given components.\n\n### ursa.assertKey(obj)\n\nConvenient shorthand for `assert(ursa.isKey(obj))`.\n\n### ursa.assertPrivateKey(obj)\n\nConvenient shorthand for `assert(ursa.isPrivateKey(obj))`.\n\n### ursa.assertPublicKey(obj)\n\nConvenient shorthand for `assert(ursa.isPublicKey(obj))`.\n\n### ursa.coerceKey(orig)\n\nCoerce the given key value into a key object (either public or\nprivate), returning it. If given a private key object, this just\nreturns it as-is. If given a string or Buffer, it tries to parse it as\nPEM. Anything else will result in an error.\n\n### ursa.coercePrivateKey(orig)\n\nCoerce the given key value into a private key object, returning it. If\ngiven a private key object, this just returns it as-is. If given a\nstring or Buffer, it tries to parse it as PEM. Anything else will\nresult in an error.\n\n### ursa.coercePublicKey(orig)\n\nCoerce the given key value into a public key object, returning it. If\ngiven a private key object, this just returns it as-is. If given a\nstring or Buffer, it tries to parse it as PEM. Anything else will\nresult in an error.\n\n### ursa.createPublicKey(pem, encoding)\n\nCreate and return a public key read in from the given PEM-format file.\nSee \"Public Key Methods\" below for more details.\n\n### ursa.createSigner(algorithm)\n\nCreate and return a signer which can sign a hash generated with the named\nalgorithm (such as `\"sha256\"` or `\"md5\"`). See \"Signer Methods\" below\nfor more details.\n\nThis function is similar to `crypto.createSign()`, except this function\ntakes a hash algorithm name (e.g., `\"sha256\"`) and not a crypto+hash name\ncombination (e.g., `\"RSA-SHA256\"`).\n\n### ursa.createVerifier(algorithm)\n\nCreate and return a verifier which can verify a hash generated with the\nnamed algorithm (such as `\"sha256\"` or `\"md5\"`). See \"Verifier Methods\" below\nfor more details.\n\nThis function is similar to `crypto.createVerify()`, except this function\ntakes a hash algorithm name (e.g., `\"sha256\"`) and not a crypto+hash name\ncombination (e.g., `\"RSA-SHA256\"`).\n\n### ursa.equalKeys(key1, key2)\n\nThis returns `true` if and only if both arguments are key objects of\nthe same type (public or private) and their contents match.\n\n### ursa.generatePrivateKey(modulusBits, exponent)\n\nCreate and return a freshly-generated private key (aka a keypair).\nThe first argument indicates the number of bits in the modulus (1024\nor more is generally considered secure). The second argument indicates\nthe exponent value, which must be odd (65537 is the typical value; 3\nand 17 are also common).  Both arguments are optional and default to\n2048 and 65537 (respectively).\n\nThis method will throw if `modulusBits` is less than `512` (because\nit's pretty crazy to want a key with that few bits) or if `exponent`\nis even (because RSA only works for odd exponents).\n\nUsing the command-line `openssl` tool, this operation is\nequivalent to:\n\n```shell\nopenssl genrsa -out key-name.pem <modulusBits>\n```\n\nfor exponent 65537, or for exponent 3 with the additional option\n`-3`. (That tool doesn't support other exponents.)\n\n### ursa.isKey(obj)\n\nReturn `true` if the given object is a key object (public or private) that\nwas created by this module. Return `false` if not.\n\n### ursa.isPrivateKey(obj)\n\nReturn `true` if the given object is a private key object that\nwas created by this module. Return `false` if not.\n\n### ursa.isPublicKey(obj)\n\nReturn `true` if the given object is a public key object that\nwas created by this module. Return `false` if not.\n\nNote that, even though all the public key operations work on private\nkeys, this function only returns true if the given object is a\npublic key, per se.\n\n### ursa.matchingPublicKeys(key1, key2)\n\nThis returns `true` if and only if both arguments are key objects of\nsome sort (either can be public or private, and they don't have to\nbe the same) and their public aspects match each other.\n\n### ursa.openSshPublicKey(key, encoding)\n\nThis returns `publicKey` from ssh-rsa public key-string. First argument\nmust be a string like `ssh-rsa AAAAB3Nz.... user@localhost` or Buffer of pubKey bits.\n\n### ursa.sshFingerprint(sshKey, sshEncoding, outEncoding)\n\nReturn the SSH-style public key fingerprint of the given SSH-format\npublic key (which was, perhaps, the result of a call to\n`toPublicSsh()` on a key object).\n\nThis is no more and no less than an MD5 hash of the given SSH-format\npublic key. This function doesn't actually check to see if the given\nkey is valid (garbage in, garbage out).\n\nUsing the command-line `ssh-keygen` tool, this operation is\nequivalent to:\n\n```shell\nssh-keygen -l -f key-name.sshpub\n```\n\nThis operation is also equivalent to this:\n\n```shell\ncat key-name.sshpub | awk '{print $2}' | base64 --decode | md5\n```\n\nPublic Key Methods\n------------------\n\nThese are all the methods available on public keys. These methods are\n*also* available on private keys (since private keys have all the\nunderlying data necessary to perform the public-side operations).\n\n### encrypt(buf, bufEncoding, outEncoding, padding)\n\nThis performs the \"public encrypt\" operation on the given buffer. The\nresult is always a byte sequence that is the same size as the key\nassociated with the instance. (For example, if the key is 2048 bits,\nthen the result of this operation will be 2048 bits, aka 256 bytes.)\n\nThe input buffer is limited to be no larger than the key size\nminus 41 bytes.\n\nIf no padding mode is specified, the default, and recommended, mode\nis `ursa.RSA_PKCS1_OAEP_PADDING`. The mode\n`ursa.RSA_PKCS1_PADDING` is also supported.\n\n### getExponent(encoding)\n\nGet the public exponent as an unsigned big-endian byte sequence.\n\n### getModulus(encoding)\n\nGet the public modulus as an unsigned big-endian byte sequence.\n\n### hashAndVerify(algorithm, buf, sig, encoding, use\\_pss\\_padding, salt\\_len)\n\nThis is a friendly wrapper for verifying signatures. The given buffer\nis hashed using the named algorithm, and the result is verified\nagainst the given signature. This returns `true` if the hash and\nsignature match and the signature was produced by the appropriate\nprivate key. This returns `false` if the signature is a valid signature\n(structurally) but doesn't match. This throws an exception in other\ncases.\n\nThe encoding, if specified, applies to both buffer-like arguments. The\nalgorithm must always be a string.\n\nIf `use_pss_padding` is truthy then [RSASSA-PSS](http://tools.ietf.org/html/rfc3447#section-8.1)\npadding is used when verifying the signature. `salt_len`, if specified, is\nthe length of the PSS salt (in bytes) or one of the following:\n\n- `RSA_PKCS1_SALT_LEN_HLEN` (the same as the hash length, default).\n- `RSA_PKCS1_SALT_LEN_MAX` (maximum permissable value).\n\n### publicDecrypt(buf, bufEncoding, outEncoding)\n\nThis performs the \"public decrypt\" operation on the given buffer. The\nresult is always a byte sequence that is no more than the size of the\nkey associated with the instance. (For example, if the key is 2048\nbits, then the result of this operation will be no more than 2048\nbits, aka 256 bytes.)\n\nIf no padding mode is specified, the default, and recommended, mode\nis `ursa.RSA_PKCS1_PADDING`. The mode `ursa.RSA_NO_PADDING` is also supported.\n\n### toPublicPem(encoding)\n\nThis converts the public key data into a PEM-format file.\n\n### toPublicSsh(encoding)\n\nThis converts the public key data into an SSH-format file. This is the\nfile format one finds in SSH's `authorized_keys` and `known_hosts` files.\nWhen used in such files, the contents are base64-encoded and prefixed with\nthe label `ssh-rsa`. Depending on context, the line a key appears on may\nalso have a host name prefix (in `known_hosts`) or comment suffix\n(in `authorized_keys`).\n\nUsing the command-line `ssh-keygen` tool, this operation is equivalent to:\n\n```shell\nssh-keygen -y -f key-name.pem > key-name.sshpub\n```\n\n### toPublicSshFingerprint(encoding)\n\nReturn the SSH-style public key fingerprint of this key. See\n`ursa.sshFingerprint()`, above, for more details.\n\n### verify(algorithm, hash, sig, encoding)\n\nThis performs an RSA public-verify on the given hash buffer, which\nshould be the result of performing the hash operation named by\nthe algorithm (such as `\"sha256\"` or `\"md5\"`) on some data. The\nsignature buffer is checked to see if it contains a private-signed\nstatement of the algorithm and hash. The method returns `true` if\nthe signature and hash match, or `false` if the signature and hash\ndon't match but the signature is at least a valid signature of\nsome sort. In any other situation, this throws an exception.\n\nThe encoding, if specified, applies to both buffer-like arguments. The\nalgorithm must always be a string.\n\nThis method is the underlying one used as part of the implementation\nof the higher-level and much friendlier `ursa.createVerifier()` and\n`hashAndVerify()`.\n\n### ununseal(ununsealer)\n\nThis is an internal method that is used in the implementation of\n`ursa.isKey()` `ursa.isPrivateKey()` `ursa.isPublicKey()` and\nassociated assertion functions. When called externally, it will\nalways return `undefined`.\n\nPrivate Key Methods\n-------------------\n\nThese are the methods available on private keys, above and beyond\nwhat is available for public keys.\n\n### decrypt(buf, bufEncoding, outEncoding, padding)\n\nThis performs the \"private decrypt\" operation on the given buffer. The\nresult is always a byte sequence that is no more than the size of the\nkey associated with the instance. (For example, if the key is 2048\nbits, then the result of this operation will be no more than 2048\nbits, aka 256 bytes.)\n\nIf no padding mode is specified, the default, and recommended, mode\nis `ursa.RSA_PKCS1_OAEP_PADDING`. The mode\n`ursa.RSA_PKCS1_PADDING` is also supported.\n\n### getPrivateExponent(encoding)\n\nGet the private exponent as an unsigned big-endian byte sequence. The returned\nexponent is not encrypted in any way, so this method should be used with caution. \n\n### hashAndSign(algorithm, buf, bufEncoding, outEncoding, use\\_pss\\_padding, salt\\_len)\n\nThis is a friendly wrapper for producing signatures. The given buffer\nis hashed using the named algorithm, and the result is signed using\nthe private key held by this instance. The return value of this method\nis the signature.\n\nIf `use_pss_padding` is truthy then [RSASSA-PSS](http://tools.ietf.org/html/rfc3447#section-8.1)\npadding is used when generating the signature. The `salt_len`, if specified, is\nthe length of the PSS salt (in bytes) or one of the following:\n\n- `RSA_PKCS1_SALT_LEN_HLEN` (the same as the hash length, default).\n- `RSA_PKCS1_SALT_LEN_RECOVER` (assume `RSA_PKCS1_SALT_LEN_MAX` was used when the padding was added).\n\n### privateEncrypt(buf, bufEncoding, outEncoding)\n\nThis performs the \"private encrypt\" operation on the given buffer. The\nresult is always a byte sequence that is the same size as the key\nassociated with the instance. (For example, if the key is 2048 bits,\nthen the result of this operation will be 2048 bits, aka 256 bytes.)\n\nThe input buffer is limited to be no larger than the key size\nminus 12 bytes.\n\nIf no padding mode is specified, the default, and recommended, mode\nis `ursa.RSA_PKCS1_PADDING`. The mode `ursa.RSA_NO_PADDING` is also supported.\n\n### sign(algorithm, hash, hashEncoding, outEncoding)\n\nThis performs an RSA private-sign on the given hash buffer, which\nshould be the result of performing the hash operation named by\nthe algorithm (such as `\"sha256\"` or `\"md5\"`) on some data. The\nresult of this operation may later be passed to `verify()` on the\ncorresponding public key.\n\nThis method is the underlying one used as part of the implementation\nof the higher-level and much friendlier `ursa.createSigner()` and\n`hashAndSign()`.\n\n### toPrivatePem(encoding)\n\nThis converts the private key data into a PEM-format file. The result\nis not encrypted, so it behooves the user of this method to take care\nwith the result if the key is sensitive from a security standpoint,\nwhich is often the case with such things. (YMMV of course.)\n\n\nSigner Methods\n--------------\n\nThese are the methods available on signer objects, which are returned\nby `ursa.createSigner()`. These are similar to the objects returned\nfrom `crypto.createSign()`.\n\n### update(buf, bufEncoding)\n\nUpdate the hash in-progress with the given data.\n\n### sign(privateKey, outEncoding)\n\nGet the final hash of the data, and sign it using the private key. The\nreturn value is the signature, suitable for later verification.\n\n\nVerifier Methods\n----------------\n\nThese are the methods available on verifier objects, which are returned\nby `ursa.createVerifier()`. These are similar to the objects returned\nfrom `crypto.createVerify()`.\n\n### update(buf, bufEncoding)\n\nUpdate the hash in-progress with the given data.\n\n### verify(publicKey, sig, sigEncoding)\n\nGet the final hash of the data, and verify that the given signature\nboth matches it and was produced by the private key corresponding to\nthe given public key.\n\nThis returns `true` if the signature and hash match appropriately,\nor `false` if the signature appears to be generally valid (e.g.\nstructurally) yet doesn't match. This throws an exception in all\nother cases.\n\n\nConstants\n---------\n\nAllowed padding modes for public/private encryption/decryption:\n\n* `ursa.RSA_PKCS1_PADDING`\n* `ursa.RSA_NO_PADDING`\n* `ursa.RSA_PKCS1_OAEP_PADDING`\n\n\nContributing\n------------\n\nQuestions, comments, bug reports, and pull requests are all welcome.\nSubmit them at [the project on GitHub](https://github.com/quartzjer/ursa/).\n\nBug reports that include steps-to-reproduce (including code) are the\nbest. Even better, make them in the form of pull requests that update\nthe test suite. Thanks!\n\n\nAuthors\n-------\n\nCurrent (2015+) maintenance by [Jeremie Miller](https://github.com/quartzjer).\n\nPrevious (2014) maintenance sponsored by [NodePrime](http://nodeprime.com).\n\nOriginal Author (2012): [Dan Bornstein](https://github.com/danfuzz)\n([personal website](http://www.milk.com/)), supported by\n[The Obvious Corporation](http://obvious.com/) (now [Medium](https://medium.com/)).\n\nWith contribution from:\n\n* [C J Silverio](https://github.com/ceejbot)\n* [Tyler Neylon](https://github.com/tylerneylon)\n\nWith thanks to:\n\n* [node-rsa](https://github.com/chrisa/node-rsa) by Chris Andrews,\n  for inspiration\n\n\nLicense\n-------\n\nUpdates Copyright 2014 [NodePrime, Inc.](http://nodeprime.com/).\nOriginal Copyright 2012 [The Obvious Corporation](http://obvious.com/).\n\nLicensed under the Apache License, Version 2.0.\nSee the top-level file `[LICENSE.txt](LICENSE.txt)` and\n(http://www.apache.org/licenses/LICENSE-2.0).\n\nOther Repos that may be of Interest:\n-----------------------\n\n* https://github.com/mal/forsake\n* https://github.com/rzcoder/node-rsa\n* https://github.com/coolaj86/nodejs-self-signed-certificate-example\n* https://github.com/coolaj86/node-ssl-root-cas/wiki/Painless-Self-Signed-Certificates-in-node.js\n* https://github.com/coolaj86/node-ssl-root-cas\n* https://github.com/coolaj86/nodejs-ssl-trusted-peer-example\n* https://github.com/coolaj86/bitcrypt\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/quartzjer/ursa/issues"
  },
  "_id": "ursa@0.8.3",
  "_shasum": "37ebbb73b2d8a48f89487f81c10c2a253eec2c04",
  "_resolved": "git+https://github.com/quartzjer/ursa.git#b87eeec33fc74a493a01bf0b1d06ed1a73e85718",
  "_from": "ursa@git+https://github.com/quartzjer/ursa.git"
}
