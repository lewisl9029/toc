
System.registerDynamic("github:angular/bower-angular@1.4.1/angular.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.4.1/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
          return false;
        }
        var length = "length" in Object(obj) && obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
          return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === 'number' && length > 0 && (length - 1) in obj;
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (!isObject(dst[key]))
                dst[key] = isArray(src) ? [] : {};
              baseExtend(dst[key], [src], true);
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function() {
          return value;
        };
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;
      function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(","),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
          throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (isTypedArray(destination)) {
          throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
        }
        if (!destination) {
          destination = source;
          if (isObject(source)) {
            var index;
            if (stackSource && (index = stackSource.indexOf(source)) !== -1) {
              return stackDest[index];
            }
            if (isArray(source)) {
              return copy(source, [], stackSource, stackDest);
            } else if (isTypedArray(source)) {
              destination = new source.constructor(source);
            } else if (isDate(source)) {
              destination = new Date(source.getTime());
            } else if (isRegExp(source)) {
              destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              destination.lastIndex = source.lastIndex;
            } else {
              var emptyObject = Object.create(getPrototypeOf(source));
              return copy(source, emptyObject, stackSource, stackDest);
            }
            if (stackDest) {
              stackSource.push(source);
              stackDest.push(destination);
            }
          }
        } else {
          if (source === destination)
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          stackSource = stackSource || [];
          stackDest = stackDest || [];
          if (isObject(source)) {
            stackSource.push(source);
            stackDest.push(destination);
          }
          var result,
              key;
          if (isArray(source)) {
            destination.length = 0;
            for (var i = 0; i < source.length; i++) {
              destination.push(copy(source[i], null, stackSource, stackDest));
            }
          } else {
            var h = destination.$$hashKey;
            if (isArray(destination)) {
              destination.length = 0;
            } else {
              forEach(destination, function(value, key) {
                delete destination[key];
              });
            }
            if (isBlankObject(source)) {
              for (key in source) {
                destination[key] = copy(source[key], null, stackSource, stackDest);
              }
            } else if (source && typeof source.hasOwnProperty === 'function') {
              for (key in source) {
                if (source.hasOwnProperty(key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            } else {
              for (key in source) {
                if (hasOwnProperty.call(source, key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            }
            setHashKey(destination, h);
          }
        }
        return destination;
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2))
                return false;
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key]))
                    return false;
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2))
                return false;
              return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              return isRegExp(o2) ? o1.toString() == o2.toString() : false;
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                  continue;
                if (!equals(o1[key], o2[key]))
                  return false;
                keySet[key] = true;
              }
              for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        return false;
      }
      var csp = function() {
        if (isDefined(csp.isActive_))
          return csp.isActive_;
        var active = !!(document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
        if (!active) {
          try {
            new Function('');
          } catch (e) {
            active = true;
          }
        }
        return (csp.isActive_ = active);
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (typeof obj === 'undefined')
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {},
            key_value,
            key;
        forEach((keyValue || "").split('&'), function(keyValue) {
          if (keyValue) {
            key_value = keyValue.replace(/\+/g, '%20').split('=');
            key = tryDecodeURIComponent(key_value[0]);
            if (isDefined(key)) {
              var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      var skipDestroyOnNextJQueryCleanData;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = window.jQuery;
        if (isDefined(jqName)) {
          jQuery = jqName === null ? undefined : window[jqName];
        }
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            if (!skipDestroyOnNextJQueryCleanData) {
              for (var i = 0,
                  elem; (elem = elems[i]) != null; i++) {
                events = jQuery._data(elem, "events");
                if (events && events.$destroy) {
                  jQuery(elem).triggerHandler('$destroy');
                }
              }
            } else {
              skipDestroyOnNextJQueryCleanData = false;
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes = [node];
        do {
          node = node.nextSibling;
          if (!node)
            break;
          blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '<<already seen>>';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (typeof obj === 'undefined') {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.4.1',
        major: 1,
        minor: 4,
        dot: 1,
        codeName: 'hyperionic-illumination'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        try {
          angularModule('ngLocale');
        } catch (e) {
          angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
        }
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$CoreAnimateRunnerProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$asyncCallback: $$AsyncCallbackProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          forEach(type.split(' '), function(type) {
            if (isDefined(fn)) {
              var listenerFns = events[type];
              arrayRemove(listenerFns || [], fn);
              if (listenerFns && listenerFns.length > 0) {
                return;
              }
            }
            removeEventListenerFn(element, type, handle);
            delete events[type];
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if ((value = jqLite.data(element, names[i])) !== undefined)
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return (nodeName === 'INPUT' || nodeName === 'TEXTAREA') && ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              eventFns[i].call(element, event);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          while (i--) {
            type = types[i];
            var eventFns = events[type];
            if (!eventFns) {
              events[type] = [];
              if (type === 'mouseenter' || type === 'mouseleave') {
                jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                  var target = this,
                      related = event.relatedTarget;
                  if (!related || (related !== target && !target.contains(related))) {
                    handle(event, type);
                  }
                });
              } else {
                if (type !== '$destroy') {
                  addEventListenerFn(element, type, handle);
                }
              }
              eventFns = events[type];
            }
            eventFns.push(fn);
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          wrapNode = jqLite(wrapNode).eq(0).clone()[0];
          var parent = element.parentNode;
          if (parent) {
            parent.replaceChild(wrapNode, element);
          }
          wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(FN_ARGS);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            fnText,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              fnText = fn.toString().replace(STRIP_COMMENTS, '');
              argDecl = fnText.match(FN_ARGS);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }));
        forEach(loadModules(modulesToLoad), function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName),
                length,
                i,
                key;
            for (i = 0, length = $inject.length; i < length; i++) {
              key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            if (isArray(fn)) {
              fn = fn[length];
            }
            return fn.apply(self, args);
          }
          function instantiate(Type, locals, serviceName) {
            var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
            var returnedValue = invoke(Type, instance, locals, serviceName);
            return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateRunnerProvider = function() {
        this.$get = ['$q', '$$rAF', function($q, $$rAF) {
          function AnimateRunner() {}
          AnimateRunner.all = noop;
          AnimateRunner.chain = noop;
          AnimateRunner.prototype = {
            end: noop,
            cancel: noop,
            resume: noop,
            pause: noop,
            complete: noop,
            then: function(pass, fail) {
              return $q(function(resolve) {
                $$rAF(function() {
                  resolve();
                });
              }).then(pass, fail);
            }
          };
          return AnimateRunner;
        }];
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              return new $$AnimateRunner();
            }
          };
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element);
            var classVal;
            if (!data) {
              postDigestQueue.put(element, data = {});
              postDigestElements.push(element);
            }
            if (add) {
              forEach(add.split(' '), function(className) {
                if (className) {
                  data[className] = true;
                }
              });
            }
            if (remove) {
              forEach(remove.split(' '), function(className) {
                if (className) {
                  data[className] = false;
                }
              });
            }
            if (postDigestElements.length > 1)
              return;
            $rootScope.$$postDigest(function() {
              forEach(postDigestElements, function(element) {
                var data = postDigestQueue.get(element);
                if (data) {
                  var existing = splitClasses(element.attr('class'));
                  var toAdd = '';
                  var toRemove = '';
                  forEach(data, function(status, className) {
                    var hasClass = !!existing[className];
                    if (status !== hasClass) {
                      if (status) {
                        toAdd += (toAdd.length ? ' ' : '') + className;
                      } else {
                        toRemove += (toRemove.length ? ' ' : '') + className;
                      }
                    }
                  });
                  forEach(element, function(elm) {
                    toAdd && jqLiteAddClass(elm, toAdd);
                    toRemove && jqLiteRemoveClass(elm, toRemove);
                  });
                  postDigestQueue.remove(element);
                }
              });
              postDigestElements.length = 0;
            });
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      function $$AsyncCallbackProvider() {
        this.$get = ['$$rAF', '$timeout', function($$rAF, $timeout) {
          return $$rAF.supported ? function(fn) {
            return $$rAF(fn);
          } : function(fn) {
            return $timeout(fn, 0, false);
          };
        }];
      }
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index + 1);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            reloadLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || reloadLocation) {
                reloadLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
            }
            return self;
          } else {
            return reloadLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = {},
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = {},
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = {};
                size = 0;
                lruHash = {};
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
          var Attributes = function(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          };
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(node, key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && key === 'href') || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || value === undefined) {
                  this.$$element.removeAttr(attrName);
                } else {
                  this.$$element.attr(attrName, value);
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            forEach($compileNodes, function(node, index) {
              if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
              }
            });
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                    var destroyBindings = nodeLinkFn.$$destroyBindings;
                    if (destroyBindings) {
                      nodeLinkFn.$$destroyBindings = null;
                      childScope.$on('$destroyed', destroyBindings);
                    }
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            };
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
                  if (directiveIsMultiElement(directiveNName)) {
                    if (ngAttrName === directiveNName + 'Start') {
                      attrStartName = name;
                      attrEndName = name.substr(0, name.length - 5) + 'end';
                      name = name.substr(0, name.length - 6);
                    }
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  $compileNode.empty();
                  childTranscludeFn = compile($template, transcludeFn);
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective) {
                    markDirectivesAsIsolate(templateDirectives);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
              var value;
              if (isString(require)) {
                var match = require.match(REQUIRE_PREFIX_REGEXP);
                var name = require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                  $element = $element.parent();
                } else {
                  value = elementControllers && elementControllers[name];
                  value = value && value.instance;
                }
                if (!value) {
                  var dataName = '$' + name + 'Controller';
                  value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                  throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                }
              } else if (isArray(require)) {
                value = [];
                for (var i = 0,
                    ii = require.length; i < ii; i++) {
                  value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                }
              }
              return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
              var elementControllers = createMap();
              for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                  $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                  $element: $element,
                  $attrs: attrs,
                  $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                if (!hasElementTranscludeDirective) {
                  $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
              }
              return elementControllers;
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
              var i,
                  ii,
                  linkFn,
                  controller,
                  isolateScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope);
              }
              if (elementControllers) {
                var scopeDirective = newIsolateScopeDirective || newScopeDirective;
                var bindings;
                var controllerForBindings;
                if (scopeDirective && elementControllers[scopeDirective.name]) {
                  bindings = scopeDirective.$$bindings.bindToController;
                  controller = elementControllers[scopeDirective.name];
                  if (controller && controller.identifier && bindings) {
                    controllerForBindings = controller;
                    thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective);
                  }
                }
                for (i in elementControllers) {
                  controller = elementControllers[i];
                  var controllerResult = controller();
                  if (controllerResult !== controller.instance) {
                    controller.instance = controllerResult;
                    $element.data('$' + i + 'Controller', controllerResult);
                    if (controller === controllerForBindings) {
                      thisLinkFn.$$destroyBindings();
                      thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
                    }
                  }
                }
              }
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
          function markDirectivesAsIsolate(directives) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {$$isolateScope: true});
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest($sce.getTrustedResourceUrl(templateUrl)).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectivesAsIsolate(templateDirectives);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = {}));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            fragment.appendChild(firstElementToRemove);
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite(newNode).data(jqLite(firstElementToRemove).data());
              if (!jQuery) {
                delete jqLite.cache[firstElementToRemove[jqLite.expando]];
              } else {
                skipDestroyOnNextJQueryCleanData = true;
                jQuery.cleanData([firstElementToRemove]);
              }
            }
            for (var k = 1,
                kk = elementsToRemove.length; k < kk; k++) {
              var element = elementsToRemove[k];
              jqLite(element).remove();
              fragment.appendChild(element);
              delete elementsToRemove[k];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
            var onNewScopeDestroyed;
            forEach(bindings, function(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare;
              if (!hasOwnProperty.call(attrs, attrName)) {
                attrs[attrName] = undefined;
              }
              switch (mode) {
                case '@':
                  if (!attrs[attrName] && !optional) {
                    destination[scopeName] = undefined;
                  }
                  attrs.$observe(attrName, function(value) {
                    destination[scopeName] = value;
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  if (attrs[attrName]) {
                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                  }
                  break;
                case '=':
                  if (optional && !attrs[attrName]) {
                    return;
                  }
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  var unwatch;
                  if (definition.collection) {
                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  onNewScopeDestroyed = (onNewScopeDestroyed || []);
                  onNewScopeDestroyed.push(unwatch);
                  break;
                case '&':
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            var destroyBindings = onNewScopeDestroyed ? function destroyBindings() {
              for (var i = 0,
                  ii = onNewScopeDestroyed.length; i < ii; ++i) {
                onNewScopeDestroyed[i]();
              }
            } : noop;
            if (newScope && destroyBindings !== noop) {
              newScope.$on('$destroy', destroyBindings);
              return noop;
            }
            return destroyBindings;
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v, k) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value) {
                  serialize(value, prefix + '[]');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!angular.isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            promise.success = function(fn) {
              assertArgFn(fn, 'fn');
              promise.then(function(response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };
            promise.error = function(fn) {
              assertArgFn(fn, 'fn');
              promise.then(null, function(response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              if (!response.data) {
                resp.data = response.data;
              } else {
                resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              }
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = Math.max(status, 0);
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function createXhr() {
        return new window.XMLHttpRequest();
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
          return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr();
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (timeoutId !== undefined) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', function($rootScope, $window, $q, $$q) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = setInterval(function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      function $LocaleProvider() {
        this.$get = function() {
          return {
            id: 'en-us',
            NUMBER_FORMATS: {
              DECIMAL_SEP: '.',
              GROUP_SEP: ',',
              PATTERNS: [{
                minInt: 1,
                minFrac: 0,
                maxFrac: 3,
                posPre: '',
                posSuf: '',
                negPre: '-',
                negSuf: '',
                gSize: 3,
                lgSize: 3
              }, {
                minInt: 1,
                minFrac: 2,
                maxFrac: 2,
                posPre: '\u00A4',
                posSuf: '',
                negPre: '(\u00A4',
                negSuf: ')',
                gSize: 3,
                lgSize: 3
              }],
              CURRENCY_SYM: '$'
            },
            DATETIME_FORMATS: {
              MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
              SHORTMONTH: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
              DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
              SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
              AMPMS: ['AM', 'PM'],
              medium: 'MMM d, y h:mm:ss a',
              'short': 'M/d/yy h:mm a',
              fullDate: 'EEEE, MMMM d, y',
              longDate: 'MMMM d, y',
              mediumDate: 'MMM d, y',
              shortDate: 'M/d/yy',
              mediumTime: 'h:mm:ss a',
              shortTime: 'h:mm a',
              ERANAMES: ["Before Christ", "Anno Domini"],
              ERAS: ["BC", "AD"]
            },
            pluralCat: function(num) {
              if (num === 1) {
                return 'one';
              }
              return 'other';
            }
          };
        };
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if ((appUrl = beginsWith(appBase, url)) !== undefined) {
            prevAppUrl = appUrl;
            if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            withoutHashUrl = this.$$html5 ? withoutBaseUrl : '';
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          $location = new LocationMode(appBase, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.constants.hasOwnProperty(this.peek().text)) {
            primary = copy(this.constants[this.consume().text]);
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        constants: {
          'true': {
            type: AST.Literal,
            value: true
          },
          'false': {
            type: AST.Literal,
            value: false
          },
          'null': {
            type: AST.Literal,
            value: null
          },
          'undefined': {
            type: AST.Literal,
            value: undefined
          },
          'this': {type: AST.ThisExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign, inputs) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1 && lhs && !(lhs[rhs])) {
                lhs[rhs] = {};
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1 && lhs && !(lhs[right])) {
              lhs[right] = {};
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function setter(obj, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp);
        var element = path.split('.'),
            key;
        for (var i = 0; element.length > 1; i++) {
          key = ensureSafeMemberName(element.shift(), fullExp);
          var propertyObj = ensureSafeObject(obj[key], fullExp);
          if (!propertyObj) {
            propertyObj = {};
            obj[key] = propertyObj;
          }
          obj = propertyObj;
        }
        key = ensureSafeMemberName(element.shift(), fullExp);
        ensureSafeObject(obj[key], fullExp);
        obj[key] = setValue;
        return setValue;
      }
      var getterFnCacheDefault = createMap();
      var getterFnCacheExpensive = createMap();
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {
          var $parseOptions = {
            csp: $sniffer.csp,
            expensiveChecks: false
          },
              $parseOptionsExpensive = {
                csp: $sniffer.csp,
                expensiveChecks: true
              };
          return function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return noop;
            }
          };
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              return parsedExpression(scope);
            }, function constantListener(value, old, scope) {
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              unwatch();
            }, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        function callOnce(self, resolveFn, rejectFn) {
          var called = false;
          function wrap(fn) {
            return function(value) {
              if (called)
                return;
              called = true;
              fn.call(self, value);
            };
          }
          return [wrap(resolveFn), wrap(rejectFn)];
        }
        var defer = function() {
          return new Deferred();
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        Promise.prototype = {
          then: function(onFulfilled, onRejected, progressBack) {
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        };
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
          this.resolve = simpleBind(this, this.resolve);
          this.reject = simpleBind(this, this.reject);
          this.notify = simpleBind(this, this.notify);
        }
        Deferred.prototype = {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then,
                fns;
            fns = callOnce(this, this.$$resolve, this.$$reject);
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, fns[0], fns[1], this.notify);
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              fns[1](e);
              exceptionHandler(e);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        };
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          if (!(this instanceof Q)) {
            return new Q(resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var rafFn = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          queueFn.supported = rafSupported;
          var cancelLastRAF;
          var taskCount = 0;
          var taskQueue = [];
          return queueFn;
          function flush() {
            for (var i = 0; i < taskQueue.length; i++) {
              var task = taskQueue[i];
              if (task) {
                taskQueue[i] = null;
                task();
              }
            }
            taskCount = taskQueue.length = 0;
          }
          function queueFn(asyncFn) {
            var index = taskQueue.length;
            taskCount++;
            taskQueue.push(asyncFn);
            if (index === 0) {
              cancelLastRAF = rafFn(flush);
            }
            return function cancelQueueFn() {
              if (index >= 0) {
                taskQueue[index] = null;
                index = null;
                if (--taskCount === 0 && cancelLastRAF) {
                  cancelLastRAF();
                  cancelLastRAF = null;
                  taskQueue.length = 0;
                }
              }
            };
          }
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser', function($injector, $exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (newValue.hasOwnProperty(key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!newValue.hasOwnProperty(key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  logMsg,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            watch.fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: expr,
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                return this.$eval(expr);
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                clearPhase();
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $compileMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        this.$get = ['$templateCache', '$http', '$q', function($templateCache, $http, $q) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            var httpOptions = {
              cache: $templateCache,
              transformResponse: transformResponse
            };
            return $http.get(tpl, httpOptions)['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (lastCookies[name] === undefined) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      var DECIMAL_SEP = '.';
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number))
          return '';
        var isNegative = number < 0;
        number = Math.abs(number);
        var isInfinity = number === Infinity;
        if (!isInfinity && !isFinite(number))
          return '';
        var numStr = number + '',
            formatedText = '',
            hasExponent = false,
            parts = [];
        if (isInfinity)
          formatedText = '\u221e';
        if (!isInfinity && numStr.indexOf('e') !== -1) {
          var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
          if (match && match[2] == '-' && match[3] > fractionSize + 1) {
            number = 0;
          } else {
            formatedText = numStr;
            hasExponent = true;
          }
        }
        if (!isInfinity && !hasExponent) {
          var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
          if (isUndefined(fractionSize)) {
            fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
          }
          number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
          var fraction = ('' + number).split(DECIMAL_SEP);
          var whole = fraction[0];
          fraction = fraction[1] || '';
          var i,
              pos = 0,
              lgroup = pattern.lgSize,
              group = pattern.gSize;
          if (whole.length >= (lgroup + group)) {
            pos = whole.length - lgroup;
            for (i = 0; i < pos; i++) {
              if ((pos - i) % group === 0 && i !== 0) {
                formatedText += groupSep;
              }
              formatedText += whole.charAt(i);
            }
          }
          for (i = pos; i < whole.length; i++) {
            if ((whole.length - i) % lgroup === 0 && i !== 0) {
              formatedText += groupSep;
            }
            formatedText += whole.charAt(i);
          }
          while (fraction.length < fractionSize) {
            fraction += '0';
          }
          if (fractionSize && fractionSize !== "0")
            formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
          if (fractionSize > 0 && number < 1) {
            formatedText = number.toFixed(fractionSize);
            number = parseFloat(formatedText);
          }
        }
        if (number === 0) {
          isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim);
        };
      }
      function dateStrGetter(name, shortForm) {
        return function(date, formats) {
          var value = date['get' + name]();
          var get = uppercase(shortForm ? ('SHORT' + name) : name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (!(isArrayLike(array)))
            return array;
          sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          sortPredicate = sortPredicate.map(function(predicate) {
            var descending = false,
                get = predicate || identity;
            if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-';
                predicate = predicate.substring(1);
              }
              if (predicate === '') {
                return reverseComparator(compare, descending);
              }
              get = $parse(predicate);
              if (get.constant) {
                var key = get();
                return reverseComparator(function(a, b) {
                  return compare(a[key], b[key]);
                }, descending);
              }
            }
            return reverseComparator(function(a, b) {
              return compare(get(a), get(b));
            }, descending);
          });
          return slice.call(array).sort(reverseComparator(comparator, reverseOrder));
          function comparator(o1, o2) {
            for (var i = 0; i < sortPredicate.length; i++) {
              var comp = sortPredicate[i](o1, o2);
              if (comp !== 0)
                return comp;
            }
            return 0;
          }
          function reverseComparator(comp, descending) {
            return descending ? function(a, b) {
              return comp(b, a);
            } : comp;
          }
          function isPrimitive(value) {
            switch (typeof value) {
              case 'number':
              case 'boolean':
              case 'string':
                return true;
              default:
                return false;
            }
          }
          function objectToString(value) {
            if (value === null)
              return 'null';
            if (typeof value.valueOf === 'function') {
              value = value.valueOf();
              if (isPrimitive(value))
                return value;
            }
            if (typeof value.toString === 'function') {
              value = value.toString();
              if (isPrimitive(value))
                return value;
            }
            return '';
          }
          function compare(v1, v2) {
            var t1 = typeof v1;
            var t2 = typeof v2;
            if (t1 === t2 && t1 === "object") {
              v1 = objectToString(v1);
              v2 = objectToString(v2);
            }
            if (t1 === t2) {
              if (t1 === "string") {
                v1 = v1.toLowerCase();
                v2 = v2.toLowerCase();
              }
              if (v1 === v2)
                return 0;
              return v1 < v2 ? -1 : 1;
            } else {
              return t1 < t2 ? -1 : 1;
            }
          }
        };
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        var parentForm = form.$$parentForm = element.parent().controller('form') || nullFormCtrl;
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        parentForm.$addControl(form);
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          parentForm: parentForm,
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', function($timeout) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, controller) {
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = controller.$$parentForm;
                  if (nameAttr) {
                    setter(scope, controller.$name, controller, controller.$name);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, controller.$name, undefined, controller.$name);
                      parentFormCtrl.$$renameControl(controller, newValue);
                      setter(scope, controller.$name, controller, controller.$name);
                    });
                  }
                  formElement.on('$destroy', function() {
                    parentFormCtrl.$removeControl(controller);
                    if (nameAttr) {
                      setter(scope, attr[nameAttr], undefined, controller.$name);
                    }
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function(data) {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var timeout;
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        ctrl.$render = function() {
          element.val(ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw $ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw $ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw minErr('ngModel')('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = value === undefined ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = value === undefined ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', function($animate) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', '$sce', function($templateRequest, $anchorScroll, $animate, $sce) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (/SVG/.test($element[0].toString())) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending';
      var $ngModelMinErr = new minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
              } else {
                parsedNgModelAssign($scope, ctrl.$modelValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw $ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
            currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          parentForm: parentForm,
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (parserValid === undefined) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw $ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function(error) {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || nullFormCtrl;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    formCtrl.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  formCtrl.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function(ev) {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (this.$options.updateOn !== undefined) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            parentForm = context.parentForm,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (state === undefined) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(values) {
              var watchedArray = [];
              values = values || [];
              Object.keys(values).forEach(function getWatchable(key) {
                if (key.charAt(0) === '$')
                  return;
                var locals = getLocals(values[key], key);
                var selectValue = getTrackByValueFn(values[key], locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              });
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys;
              if (!keyName && isArrayLike(optionValues)) {
                optionValuesKeys = optionValues;
              } else {
                optionValuesKeys = [];
                for (var itemKey in optionValues) {
                  if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                    optionValuesKeys.push(itemKey);
                  }
                }
              }
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', '?ngModel'],
          link: function(scope, selectElement, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            var multiple = attr.multiple;
            var emptyOption;
            for (var i = 0,
                children = selectElement.children(),
                ii = children.length; i < ii; i++) {
              if (children[i].value === '') {
                emptyOption = children.eq(i);
                break;
              }
            }
            var providedEmptyOption = !!emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val('?');
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var renderEmptyOption = function() {
              if (!providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              selectElement.val('');
              emptyOption.prop('selected', true);
              emptyOption.attr('selected', true);
            };
            var removeEmptyOption = function() {
              if (!providedEmptyOption) {
                emptyOption.remove();
              }
            };
            var renderUnknownOption = function() {
              selectElement.prepend(unknownOption);
              selectElement.val('?');
              unknownOption.prop('selected', true);
              unknownOption.attr('selected', true);
            };
            var removeUnknownOption = function() {
              unknownOption.remove();
            };
            if (!multiple) {
              selectCtrl.writeValue = function writeNgOptionsValue(value) {
                var option = options.getOptionFromViewValue(value);
                if (option && !option.disabled) {
                  if (selectElement[0].value !== option.selectValue) {
                    removeUnknownOption();
                    removeEmptyOption();
                    selectElement[0].value = option.selectValue;
                    option.element.selected = true;
                    option.element.setAttribute('selected', 'selected');
                  }
                } else {
                  if (value === null || providedEmptyOption) {
                    removeUnknownOption();
                    renderEmptyOption();
                  } else {
                    removeEmptyOption();
                    renderUnknownOption();
                  }
                }
              };
              selectCtrl.readValue = function readNgOptionsValue() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                if (selectedOption && !selectedOption.disabled) {
                  removeEmptyOption();
                  removeUnknownOption();
                  return options.getViewValueFromOption(selectedOption);
                }
                return null;
              };
              if (ngOptions.trackBy) {
                scope.$watch(function() {
                  return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            } else {
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
              selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                options.items.forEach(function(option) {
                  option.element.selected = false;
                });
                if (value) {
                  value.forEach(function(item) {
                    var option = options.getOptionFromViewValue(item);
                    if (option && !option.disabled)
                      option.element.selected = true;
                  });
                }
              };
              selectCtrl.readValue = function readNgOptionsMultiple() {
                var selectedValues = selectElement.val() || [],
                    selections = [];
                forEach(selectedValues, function(value) {
                  var option = options.selectValueMap[value];
                  if (!option.disabled)
                    selections.push(options.getViewValueFromOption(option));
                });
                return selections;
              };
              if (ngOptions.trackBy) {
                scope.$watchCollection(function() {
                  if (isArray(ngModelCtrl.$viewValue)) {
                    return ngModelCtrl.$viewValue.map(function(value) {
                      return ngOptions.getTrackByValue(value);
                    });
                  }
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            }
            if (providedEmptyOption) {
              emptyOption.remove();
              $compile(emptyOption)(scope);
              emptyOption.removeClass('ng-scope');
            } else {
              emptyOption = jqLite(optionTemplate.cloneNode(false));
            }
            updateOptions();
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function updateOptionElement(option, element) {
              option.element = element;
              element.disabled = option.disabled;
              if (option.value !== element.value)
                element.value = option.selectValue;
              if (option.label !== element.label) {
                element.label = option.label;
                element.textContent = option.label;
              }
            }
            function addOrReuseElement(parent, current, type, templateElement) {
              var element;
              if (current && lowercase(current.nodeName) === type) {
                element = current;
              } else {
                element = templateElement.cloneNode(false);
                if (!current) {
                  parent.appendChild(element);
                } else {
                  parent.insertBefore(element, current);
                }
              }
              return element;
            }
            function removeExcessElements(current) {
              var next;
              while (current) {
                next = current.nextSibling;
                jqLiteRemove(current);
                current = next;
              }
            }
            function skipEmptyAndUnknownOptions(current) {
              var emptyOption_ = emptyOption && emptyOption[0];
              var unknownOption_ = unknownOption && unknownOption[0];
              if (emptyOption_ || unknownOption_) {
                while (current && (current === emptyOption_ || current === unknownOption_)) {
                  current = current.nextSibling;
                }
              }
              return current;
            }
            function updateOptions() {
              var previousValue = options && selectCtrl.readValue();
              options = ngOptions.getOptions();
              var groupMap = {};
              var currentElement = selectElement[0].firstChild;
              if (providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              currentElement = skipEmptyAndUnknownOptions(currentElement);
              options.items.forEach(function updateOption(option) {
                var group;
                var groupElement;
                var optionElement;
                if (option.group) {
                  group = groupMap[option.group];
                  if (!group) {
                    groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                    currentElement = groupElement.nextSibling;
                    groupElement.label = option.group;
                    group = groupMap[option.group] = {
                      groupElement: groupElement,
                      currentOptionElement: groupElement.firstChild
                    };
                  }
                  optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  group.currentOptionElement = optionElement.nextSibling;
                } else {
                  optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  currentElement = optionElement.nextSibling;
                }
              });
              Object.keys(groupMap).forEach(function(key) {
                removeExcessElements(groupMap[key].currentOptionElement);
              });
              removeExcessElements(currentElement);
              ngModelCtrl.$render();
              if (!ngModelCtrl.$isEmpty(previousValue)) {
                var nextValue = selectCtrl.readValue();
                if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                  ngModelCtrl.$setViewValue(nextValue);
                  ngModelCtrl.$render();
                }
              }
            }
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, jqLite(previousNode));
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', function($animate) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if (!$transclude) {
            throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          $transclude(function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          link: function(scope, element, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            selectCtrl.ngModelCtrl = ngModelCtrl;
            ngModelCtrl.$render = function() {
              selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
            element.on('change', function() {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(selectCtrl.readValue());
              });
            });
            if (attr.multiple) {
              selectCtrl.readValue = function readMultipleValue() {
                var array = [];
                forEach(element.find('option'), function(option) {
                  if (option.selected) {
                    array.push(option.value);
                  }
                });
                return array;
              };
              selectCtrl.writeValue = function writeMultipleValue(value) {
                var items = new HashMap(value);
                forEach(element.find('option'), function(option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              var lastView,
                  lastViewRef = NaN;
              scope.$watch(function selectMultipleWatch() {
                if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                  lastView = shallowCopy(ngModelCtrl.$viewValue);
                  ngModelCtrl.$render();
                }
                lastViewRef = ngModelCtrl.$viewValue;
              });
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
            }
          }
        };
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        function chromeHack(optionElement) {
          if (optionElement[0].hasAttribute('selected')) {
            optionElement[0].selected = true;
          }
        }
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isUndefined(attr.value)) {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl && selectCtrl.ngModelCtrl) {
                if (interpolateFn) {
                  scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                    attr.$set('value', newVal);
                    if (oldVal !== newVal) {
                      selectCtrl.removeOption(oldVal);
                    }
                    selectCtrl.addOption(newVal, element);
                    selectCtrl.ngModelCtrl.$render();
                    chromeHack(element);
                  });
                } else {
                  selectCtrl.addOption(attr.value, element);
                  selectCtrl.ngModelCtrl.$render();
                  chromeHack(element);
                }
                element.on('$destroy', function() {
                  selectCtrl.removeOption(attr.value);
                  selectCtrl.ngModelCtrl.$render();
                });
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(value) {
              return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        console.log('WARNING: Tried to load angular more than once.');
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp() && window.angular.element(document).find('head').prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:process@0.10.1/browser.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:remotestoragejs@0.11.2/release/0.11.2/remotestorage.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    var CHARS = this["CHARS"];
    "format global";
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Promise = e();
      }
    }(function() {
      var define,
          module,
          exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof require == "function" && require;
              if (!u && a)
                return a(o, !0);
              if (i)
                return i(o, !0);
              throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {exports: {}};
            t[o][0].call(f.exports, function(e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      })({
        1: [function(_dereq_, module, exports) {
          "use strict";
          var schedule = _dereq_("./schedule.js");
          var Queue = _dereq_("./queue.js");
          var errorObj = _dereq_("./util.js").errorObj;
          var tryCatch1 = _dereq_("./util.js").tryCatch1;
          var _process = typeof process !== "undefined" ? process : void 0;
          function Async() {
            this._isTickUsed = false;
            this._schedule = schedule;
            this._length = 0;
            this._lateBuffer = new Queue(16);
            this._functionBuffer = new Queue(65536);
            var self = this;
            this.consumeFunctionBuffer = function Async$consumeFunctionBuffer() {
              self._consumeFunctionBuffer();
            };
          }
          Async.prototype.haveItemsQueued = function Async$haveItemsQueued() {
            return this._length > 0;
          };
          Async.prototype.invokeLater = function Async$invokeLater(fn, receiver, arg) {
            if (_process !== void 0 && _process.domain != null && !fn.domain) {
              fn = _process.domain.bind(fn);
            }
            this._lateBuffer.push(fn, receiver, arg);
            this._queueTick();
          };
          Async.prototype.invoke = function Async$invoke(fn, receiver, arg) {
            if (_process !== void 0 && _process.domain != null && !fn.domain) {
              fn = _process.domain.bind(fn);
            }
            var functionBuffer = this._functionBuffer;
            functionBuffer.push(fn, receiver, arg);
            this._length = functionBuffer.length();
            this._queueTick();
          };
          Async.prototype._consumeFunctionBuffer = function Async$_consumeFunctionBuffer() {
            var functionBuffer = this._functionBuffer;
            while (functionBuffer.length() > 0) {
              var fn = functionBuffer.shift();
              var receiver = functionBuffer.shift();
              var arg = functionBuffer.shift();
              fn.call(receiver, arg);
            }
            this._reset();
            this._consumeLateBuffer();
          };
          Async.prototype._consumeLateBuffer = function Async$_consumeLateBuffer() {
            var buffer = this._lateBuffer;
            while (buffer.length() > 0) {
              var fn = buffer.shift();
              var receiver = buffer.shift();
              var arg = buffer.shift();
              var res = tryCatch1(fn, receiver, arg);
              if (res === errorObj) {
                this._queueTick();
                if (fn.domain != null) {
                  fn.domain.emit("error", res.e);
                } else {
                  throw res.e;
                }
              }
            }
          };
          Async.prototype._queueTick = function Async$_queue() {
            if (!this._isTickUsed) {
              this._schedule(this.consumeFunctionBuffer);
              this._isTickUsed = true;
            }
          };
          Async.prototype._reset = function Async$_reset() {
            this._isTickUsed = false;
            this._length = 0;
          };
          module.exports = new Async();
        }, {
          "./queue.js": 15,
          "./schedule.js": 16,
          "./util.js": 19
        }],
        2: [function(_dereq_, module, exports) {
          "use strict";
          var Promise = _dereq_("./promise.js")();
          module.exports = Promise;
        }, {"./promise.js": 12}],
        3: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function() {
            var inherits = _dereq_("./util.js").inherits;
            var defineProperty = _dereq_("./es5.js").defineProperty;
            var rignore = new RegExp("\\b(?:[a-zA-Z0-9.]+\\$_\\w+|" + "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|" + "\\w*PromiseArray\\.\\w*PromiseArray|" + "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|" + "process._tickCallback|nextTick|Async\\$\\w+)\\b");
            var rtraceline = null;
            var formatStack = null;
            function formatNonError(obj) {
              var str;
              if (typeof obj === "function") {
                str = "[function " + (obj.name || "anonymous") + "]";
              } else {
                str = obj.toString();
                var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
                if (ruselessToString.test(str)) {
                  try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                  } catch (e) {}
                }
                if (str.length === 0) {
                  str = "(empty array)";
                }
              }
              return ("(<" + snip(str) + ">, no stack trace)");
            }
            function snip(str) {
              var maxChars = 41;
              if (str.length < maxChars) {
                return str;
              }
              return str.substr(0, maxChars - 3) + "...";
            }
            function CapturedTrace(ignoreUntil, isTopLevel) {
              this.captureStackTrace(CapturedTrace, isTopLevel);
            }
            inherits(CapturedTrace, Error);
            CapturedTrace.prototype.captureStackTrace = function CapturedTrace$captureStackTrace(ignoreUntil, isTopLevel) {
              captureStackTrace(this, ignoreUntil, isTopLevel);
            };
            CapturedTrace.possiblyUnhandledRejection = function CapturedTrace$PossiblyUnhandledRejection(reason) {
              if (typeof console === "object") {
                var message;
                if (typeof reason === "object" || typeof reason === "function") {
                  var stack = reason.stack;
                  message = "Possibly unhandled " + formatStack(stack, reason);
                } else {
                  message = "Possibly unhandled " + String(reason);
                }
                if (typeof console.error === "function" || typeof console.error === "object") {
                  console.error(message);
                } else if (typeof console.log === "function" || typeof console.log === "object") {
                  console.log(message);
                }
              }
            };
            CapturedTrace.combine = function CapturedTrace$Combine(current, prev) {
              var curLast = current.length - 1;
              for (var i = prev.length - 1; i >= 0; --i) {
                var line = prev[i];
                if (current[curLast] === line) {
                  current.pop();
                  curLast--;
                } else {
                  break;
                }
              }
              current.push("From previous event:");
              var lines = current.concat(prev);
              var ret = [];
              for (var i = 0,
                  len = lines.length; i < len; ++i) {
                if (((rignore.test(lines[i]) && rtraceline.test(lines[i])) || (i > 0 && !rtraceline.test(lines[i])) && lines[i] !== "From previous event:")) {
                  continue;
                }
                ret.push(lines[i]);
              }
              return ret;
            };
            CapturedTrace.protectErrorMessageNewlines = function(stack) {
              for (var i = 0; i < stack.length; ++i) {
                if (rtraceline.test(stack[i])) {
                  break;
                }
              }
              if (i <= 1)
                return;
              var errorMessageLines = [];
              for (var j = 0; j < i; ++j) {
                errorMessageLines.push(stack.shift());
              }
              stack.unshift(errorMessageLines.join("\u0002\u0000\u0001"));
            };
            CapturedTrace.isSupported = function CapturedTrace$IsSupported() {
              return typeof captureStackTrace === "function";
            };
            var captureStackTrace = (function stackDetection() {
              if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
                rtraceline = /^\s*at\s*/;
                formatStack = function(stack, error) {
                  if (typeof stack === "string")
                    return stack;
                  if (error.name !== void 0 && error.message !== void 0) {
                    return error.name + ". " + error.message;
                  }
                  return formatNonError(error);
                };
                var captureStackTrace = Error.captureStackTrace;
                return function CapturedTrace$_captureStackTrace(receiver, ignoreUntil) {
                  captureStackTrace(receiver, ignoreUntil);
                };
              }
              var err = new Error();
              if (typeof err.stack === "string" && typeof"".startsWith === "function" && (err.stack.startsWith("stackDetection@")) && stackDetection.name === "stackDetection") {
                defineProperty(Error, "stackTraceLimit", {
                  writable: true,
                  enumerable: false,
                  configurable: false,
                  value: 25
                });
                rtraceline = /@/;
                var rline = /[@\n]/;
                formatStack = function(stack, error) {
                  if (typeof stack === "string") {
                    return (error.name + ". " + error.message + "\n" + stack);
                  }
                  if (error.name !== void 0 && error.message !== void 0) {
                    return error.name + ". " + error.message;
                  }
                  return formatNonError(error);
                };
                return function captureStackTrace(o) {
                  var stack = new Error().stack;
                  var split = stack.split(rline);
                  var len = split.length;
                  var ret = "";
                  for (var i = 0; i < len; i += 2) {
                    ret += split[i];
                    ret += "@";
                    ret += split[i + 1];
                    ret += "\n";
                  }
                  o.stack = ret;
                };
              } else {
                formatStack = function(stack, error) {
                  if (typeof stack === "string")
                    return stack;
                  if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                    return error.name + ". " + error.message;
                  }
                  return formatNonError(error);
                };
                return null;
              }
            })();
            return CapturedTrace;
          };
        }, {
          "./es5.js": 8,
          "./util.js": 19
        }],
        4: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(NEXT_FILTER) {
            var util = _dereq_("./util.js");
            var errors = _dereq_("./errors.js");
            var tryCatch1 = util.tryCatch1;
            var errorObj = util.errorObj;
            var keys = _dereq_("./es5.js").keys;
            var TypeError = errors.TypeError;
            function CatchFilter(instances, callback, promise) {
              this._instances = instances;
              this._callback = callback;
              this._promise = promise;
            }
            function CatchFilter$_safePredicate(predicate, e) {
              var safeObject = {};
              var retfilter = tryCatch1(predicate, safeObject, e);
              if (retfilter === errorObj)
                return retfilter;
              var safeKeys = keys(safeObject);
              if (safeKeys.length) {
                errorObj.e = new TypeError("Catch filter must inherit from Error " + "or be a simple predicate function");
                return errorObj;
              }
              return retfilter;
            }
            CatchFilter.prototype.doFilter = function CatchFilter$_doFilter(e) {
              var cb = this._callback;
              var promise = this._promise;
              var boundTo = promise._boundTo;
              for (var i = 0,
                  len = this._instances.length; i < len; ++i) {
                var item = this._instances[i];
                var itemIsErrorType = item === Error || (item != null && item.prototype instanceof Error);
                if (itemIsErrorType && e instanceof item) {
                  var ret = tryCatch1(cb, boundTo, e);
                  if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                  }
                  return ret;
                } else if (typeof item === "function" && !itemIsErrorType) {
                  var shouldHandle = CatchFilter$_safePredicate(item, e);
                  if (shouldHandle === errorObj) {
                    var trace = errors.canAttach(errorObj.e) ? errorObj.e : new Error(errorObj.e + "");
                    this._promise._attachExtraTrace(trace);
                    e = errorObj.e;
                    break;
                  } else if (shouldHandle) {
                    var ret = tryCatch1(cb, boundTo, e);
                    if (ret === errorObj) {
                      NEXT_FILTER.e = ret.e;
                      return NEXT_FILTER;
                    }
                    return ret;
                  }
                }
              }
              NEXT_FILTER.e = e;
              return NEXT_FILTER;
            };
            return CatchFilter;
          };
        }, {
          "./errors.js": 6,
          "./es5.js": 8,
          "./util.js": 19
        }],
        5: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util.js");
          var isPrimitive = util.isPrimitive;
          var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
          module.exports = function(Promise) {
            var returner = function Promise$_returner() {
              return this;
            };
            var thrower = function Promise$_thrower() {
              throw this;
            };
            var wrapper = function Promise$_wrapper(value, action) {
              if (action === 1) {
                return function Promise$_thrower() {
                  throw value;
                };
              } else if (action === 2) {
                return function Promise$_returner() {
                  return value;
                };
              }
            };
            Promise.prototype["return"] = Promise.prototype.thenReturn = function Promise$thenReturn(value) {
              if (wrapsPrimitiveReceiver && isPrimitive(value)) {
                return this._then(wrapper(value, 2), void 0, void 0, void 0, void 0);
              }
              return this._then(returner, void 0, void 0, value, void 0);
            };
            Promise.prototype["throw"] = Promise.prototype.thenThrow = function Promise$thenThrow(reason) {
              if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
                return this._then(wrapper(reason, 1), void 0, void 0, void 0, void 0);
              }
              return this._then(thrower, void 0, void 0, reason, void 0);
            };
          };
        }, {"./util.js": 19}],
        6: [function(_dereq_, module, exports) {
          "use strict";
          var Objectfreeze = _dereq_("./es5.js").freeze;
          var util = _dereq_("./util.js");
          var inherits = util.inherits;
          var notEnumerableProp = util.notEnumerableProp;
          function markAsOriginatingFromRejection(e) {
            try {
              notEnumerableProp(e, "isOperational", true);
            } catch (ignore) {}
          }
          function originatesFromRejection(e) {
            if (e == null)
              return false;
            return ((e instanceof OperationalError) || e["isOperational"] === true);
          }
          function isError(obj) {
            return obj instanceof Error;
          }
          function canAttach(obj) {
            return isError(obj);
          }
          function subError(nameProperty, defaultMessage) {
            function SubError(message) {
              if (!(this instanceof SubError))
                return new SubError(message);
              this.message = typeof message === "string" ? message : defaultMessage;
              this.name = nameProperty;
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              }
            }
            inherits(SubError, Error);
            return SubError;
          }
          var _TypeError,
              _RangeError;
          var CancellationError = subError("CancellationError", "cancellation error");
          var TimeoutError = subError("TimeoutError", "timeout error");
          var AggregateError = subError("AggregateError", "aggregate error");
          try {
            _TypeError = TypeError;
            _RangeError = RangeError;
          } catch (e) {
            _TypeError = subError("TypeError", "type error");
            _RangeError = subError("RangeError", "range error");
          }
          var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
          for (var i = 0; i < methods.length; ++i) {
            if (typeof Array.prototype[methods[i]] === "function") {
              AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
            }
          }
          AggregateError.prototype.length = 0;
          AggregateError.prototype["isOperational"] = true;
          var level = 0;
          AggregateError.prototype.toString = function() {
            var indent = Array(level * 4 + 1).join(" ");
            var ret = "\n" + indent + "AggregateError of:" + "\n";
            level++;
            indent = Array(level * 4 + 1).join(" ");
            for (var i = 0; i < this.length; ++i) {
              var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
              var lines = str.split("\n");
              for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
              }
              str = lines.join("\n");
              ret += str + "\n";
            }
            level--;
            return ret;
          };
          function OperationalError(message) {
            this.name = "OperationalError";
            this.message = message;
            this.cause = message;
            this["isOperational"] = true;
            if (message instanceof Error) {
              this.message = message.message;
              this.stack = message.stack;
            } else if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          }
          inherits(OperationalError, Error);
          var key = "__BluebirdErrorTypes__";
          var errorTypes = Error[key];
          if (!errorTypes) {
            errorTypes = Objectfreeze({
              CancellationError: CancellationError,
              TimeoutError: TimeoutError,
              OperationalError: OperationalError,
              RejectionError: OperationalError,
              AggregateError: AggregateError
            });
            notEnumerableProp(Error, key, errorTypes);
          }
          module.exports = {
            Error: Error,
            TypeError: _TypeError,
            RangeError: _RangeError,
            CancellationError: errorTypes.CancellationError,
            OperationalError: errorTypes.OperationalError,
            TimeoutError: errorTypes.TimeoutError,
            AggregateError: errorTypes.AggregateError,
            originatesFromRejection: originatesFromRejection,
            markAsOriginatingFromRejection: markAsOriginatingFromRejection,
            canAttach: canAttach
          };
        }, {
          "./es5.js": 8,
          "./util.js": 19
        }],
        7: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var TypeError = _dereq_('./errors.js').TypeError;
            function apiRejection(msg) {
              var error = new TypeError(msg);
              var ret = Promise.rejected(error);
              var parent = ret._peekContext();
              if (parent != null) {
                parent._attachExtraTrace(error);
              }
              return ret;
            }
            return apiRejection;
          };
        }, {"./errors.js": 6}],
        8: [function(_dereq_, module, exports) {
          var isES5 = (function() {
            "use strict";
            return this === void 0;
          })();
          if (isES5) {
            module.exports = {
              freeze: Object.freeze,
              defineProperty: Object.defineProperty,
              keys: Object.keys,
              getPrototypeOf: Object.getPrototypeOf,
              isArray: Array.isArray,
              isES5: isES5
            };
          } else {
            var has = {}.hasOwnProperty;
            var str = {}.toString;
            var proto = {}.constructor.prototype;
            var ObjectKeys = function ObjectKeys(o) {
              var ret = [];
              for (var key in o) {
                if (has.call(o, key)) {
                  ret.push(key);
                }
              }
              return ret;
            };
            var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {
              o[key] = desc.value;
              return o;
            };
            var ObjectFreeze = function ObjectFreeze(obj) {
              return obj;
            };
            var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {
              try {
                return Object(obj).constructor.prototype;
              } catch (e) {
                return proto;
              }
            };
            var ArrayIsArray = function ArrayIsArray(obj) {
              try {
                return str.call(obj) === "[object Array]";
              } catch (e) {
                return false;
              }
            };
            module.exports = {
              isArray: ArrayIsArray,
              keys: ObjectKeys,
              defineProperty: ObjectDefineProperty,
              freeze: ObjectFreeze,
              getPrototypeOf: ObjectGetPrototypeOf,
              isES5: isES5
            };
          }
        }, {}],
        9: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, NEXT_FILTER, cast) {
            var util = _dereq_("./util.js");
            var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
            var isPrimitive = util.isPrimitive;
            var thrower = util.thrower;
            function returnThis() {
              return this;
            }
            function throwThis() {
              throw this;
            }
            function return$(r) {
              return function Promise$_returner() {
                return r;
              };
            }
            function throw$(r) {
              return function Promise$_thrower() {
                throw r;
              };
            }
            function promisedFinally(ret, reasonOrValue, isFulfilled) {
              var then;
              if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
                then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
              } else {
                then = isFulfilled ? returnThis : throwThis;
              }
              return ret._then(then, thrower, void 0, reasonOrValue, void 0);
            }
            function finallyHandler(reasonOrValue) {
              var promise = this.promise;
              var handler = this.handler;
              var ret = promise._isBound() ? handler.call(promise._boundTo) : handler();
              if (ret !== void 0) {
                var maybePromise = cast(ret, void 0);
                if (maybePromise instanceof Promise) {
                  return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled());
                }
              }
              if (promise.isRejected()) {
                NEXT_FILTER.e = reasonOrValue;
                return NEXT_FILTER;
              } else {
                return reasonOrValue;
              }
            }
            function tapHandler(value) {
              var promise = this.promise;
              var handler = this.handler;
              var ret = promise._isBound() ? handler.call(promise._boundTo, value) : handler(value);
              if (ret !== void 0) {
                var maybePromise = cast(ret, void 0);
                if (maybePromise instanceof Promise) {
                  return promisedFinally(maybePromise, value, true);
                }
              }
              return value;
            }
            Promise.prototype._passThroughHandler = function Promise$_passThroughHandler(handler, isFinally) {
              if (typeof handler !== "function")
                return this.then();
              var promiseAndHandler = {
                promise: this,
                handler: handler
              };
              return this._then(isFinally ? finallyHandler : tapHandler, isFinally ? finallyHandler : void 0, void 0, promiseAndHandler, void 0);
            };
            Promise.prototype.lastly = Promise.prototype["finally"] = function Promise$finally(handler) {
              return this._passThroughHandler(handler, true);
            };
            Promise.prototype.tap = function Promise$tap(handler) {
              return this._passThroughHandler(handler, false);
            };
          };
        }, {"./util.js": 19}],
        10: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, cast, INTERNAL) {
            var util = _dereq_("./util.js");
            var canEvaluate = util.canEvaluate;
            var tryCatch1 = util.tryCatch1;
            var errorObj = util.errorObj;
            if (canEvaluate) {
              var thenCallback = function(i) {
                return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
              };
              var caller = function(count) {
                var values = [];
                for (var i = 1; i <= count; ++i)
                  values.push("holder.p" + i);
                return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
              };
              var thenCallbacks = [];
              var callers = [void 0];
              for (var i = 1; i <= 5; ++i) {
                thenCallbacks.push(thenCallback(i));
                callers.push(caller(i));
              }
              var Holder = function(total, fn) {
                this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                this.fn = fn;
                this.total = total;
                this.now = 0;
              };
              Holder.prototype.callers = callers;
              Holder.prototype.checkFulfillment = function(promise) {
                var now = this.now;
                now++;
                var total = this.total;
                if (now >= total) {
                  var handler = this.callers[total];
                  var ret = tryCatch1(handler, void 0, this);
                  if (ret === errorObj) {
                    promise._rejectUnchecked(ret.e);
                  } else if (!promise._tryFollow(ret)) {
                    promise._fulfillUnchecked(ret);
                  }
                } else {
                  this.now = now;
                }
              };
            }
            Promise.join = function Promise$Join() {
              var last = arguments.length - 1;
              var fn;
              if (last > 0 && typeof arguments[last] === "function") {
                fn = arguments[last];
                if (last < 6 && canEvaluate) {
                  var ret = new Promise(INTERNAL);
                  ret._setTrace(void 0);
                  var holder = new Holder(last, fn);
                  var reject = ret._reject;
                  var callbacks = thenCallbacks;
                  for (var i = 0; i < last; ++i) {
                    var maybePromise = cast(arguments[i], void 0);
                    if (maybePromise instanceof Promise) {
                      if (maybePromise.isPending()) {
                        maybePromise._then(callbacks[i], reject, void 0, ret, holder);
                      } else if (maybePromise.isFulfilled()) {
                        callbacks[i].call(ret, maybePromise._settledValue, holder);
                      } else {
                        ret._reject(maybePromise._settledValue);
                        maybePromise._unsetRejectionIsUnhandled();
                      }
                    } else {
                      callbacks[i].call(ret, maybePromise, holder);
                    }
                  }
                  return ret;
                }
              }
              var $_len = arguments.length;
              var args = new Array($_len);
              for (var $_i = 0; $_i < $_len; ++$_i) {
                args[$_i] = arguments[$_i];
              }
              var ret = new PromiseArray(args).promise();
              return fn !== void 0 ? ret.spread(fn) : ret;
            };
          };
        }, {"./util.js": 19}],
        11: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var util = _dereq_("./util.js");
            var async = _dereq_("./async.js");
            var tryCatch2 = util.tryCatch2;
            var tryCatch1 = util.tryCatch1;
            var errorObj = util.errorObj;
            function thrower(r) {
              throw r;
            }
            function Promise$_spreadAdapter(val, receiver) {
              if (!util.isArray(val))
                return Promise$_successAdapter(val, receiver);
              var ret = util.tryCatchApply(this, [null].concat(val), receiver);
              if (ret === errorObj) {
                async.invokeLater(thrower, void 0, ret.e);
              }
            }
            function Promise$_successAdapter(val, receiver) {
              var nodeback = this;
              var ret = val === void 0 ? tryCatch1(nodeback, receiver, null) : tryCatch2(nodeback, receiver, null, val);
              if (ret === errorObj) {
                async.invokeLater(thrower, void 0, ret.e);
              }
            }
            function Promise$_errorAdapter(reason, receiver) {
              var nodeback = this;
              var ret = tryCatch1(nodeback, receiver, reason);
              if (ret === errorObj) {
                async.invokeLater(thrower, void 0, ret.e);
              }
            }
            Promise.prototype.nodeify = function Promise$nodeify(nodeback, options) {
              if (typeof nodeback == "function") {
                var adapter = Promise$_successAdapter;
                if (options !== void 0 && Object(options).spread) {
                  adapter = Promise$_spreadAdapter;
                }
                this._then(adapter, Promise$_errorAdapter, void 0, nodeback, this._boundTo);
              }
              return this;
            };
          };
        }, {
          "./async.js": 1,
          "./util.js": 19
        }],
        12: [function(_dereq_, module, exports) {
          "use strict";
          var old;
          if (typeof Promise !== "undefined")
            old = Promise;
          function noConflict(bluebird) {
            try {
              if (Promise === bluebird)
                Promise = old;
            } catch (e) {}
            return bluebird;
          }
          module.exports = function() {
            var util = _dereq_("./util.js");
            var async = _dereq_("./async.js");
            var errors = _dereq_("./errors.js");
            var INTERNAL = function() {};
            var APPLY = {};
            var NEXT_FILTER = {e: null};
            var cast = _dereq_("./thenables.js")(Promise, INTERNAL);
            var PromiseArray = _dereq_("./promise_array.js")(Promise, INTERNAL, cast);
            var CapturedTrace = _dereq_("./captured_trace.js")();
            var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
            var PromiseResolver = _dereq_("./promise_resolver.js");
            var isArray = util.isArray;
            var errorObj = util.errorObj;
            var tryCatch1 = util.tryCatch1;
            var tryCatch2 = util.tryCatch2;
            var tryCatchApply = util.tryCatchApply;
            var RangeError = errors.RangeError;
            var TypeError = errors.TypeError;
            var CancellationError = errors.CancellationError;
            var TimeoutError = errors.TimeoutError;
            var OperationalError = errors.OperationalError;
            var originatesFromRejection = errors.originatesFromRejection;
            var markAsOriginatingFromRejection = errors.markAsOriginatingFromRejection;
            var canAttach = errors.canAttach;
            var thrower = util.thrower;
            var apiRejection = _dereq_("./errors_api_rejection")(Promise);
            var makeSelfResolutionError = function Promise$_makeSelfResolutionError() {
              return new TypeError("circular promise resolution chain");
            };
            function Promise(resolver) {
              if (typeof resolver !== "function") {
                throw new TypeError("the promise constructor requires a resolver function");
              }
              if (this.constructor !== Promise) {
                throw new TypeError("the promise constructor cannot be invoked directly");
              }
              this._bitField = 0;
              this._fulfillmentHandler0 = void 0;
              this._rejectionHandler0 = void 0;
              this._promise0 = void 0;
              this._receiver0 = void 0;
              this._settledValue = void 0;
              this._boundTo = void 0;
              if (resolver !== INTERNAL)
                this._resolveFromResolver(resolver);
            }
            function returnFirstElement(elements) {
              return elements[0];
            }
            Promise.prototype.bind = function Promise$bind(thisArg) {
              var maybePromise = cast(thisArg, void 0);
              var ret = new Promise(INTERNAL);
              if (maybePromise instanceof Promise) {
                var binder = maybePromise.then(function(thisArg) {
                  ret._setBoundTo(thisArg);
                });
                var p = Promise.all([this, binder]).then(returnFirstElement);
                ret._follow(p);
              } else {
                ret._follow(this);
                ret._setBoundTo(thisArg);
              }
              ret._propagateFrom(this, 2 | 1);
              return ret;
            };
            Promise.prototype.toString = function Promise$toString() {
              return "[object Promise]";
            };
            Promise.prototype.caught = Promise.prototype["catch"] = function Promise$catch(fn) {
              var len = arguments.length;
              if (len > 1) {
                var catchInstances = new Array(len - 1),
                    j = 0,
                    i;
                for (i = 0; i < len - 1; ++i) {
                  var item = arguments[i];
                  if (typeof item === "function") {
                    catchInstances[j++] = item;
                  } else {
                    var catchFilterTypeError = new TypeError("A catch filter must be an error constructor " + "or a filter function");
                    this._attachExtraTrace(catchFilterTypeError);
                    return Promise.reject(catchFilterTypeError);
                  }
                }
                catchInstances.length = j;
                fn = arguments[i];
                this._resetTrace();
                var catchFilter = new CatchFilter(catchInstances, fn, this);
                return this._then(void 0, catchFilter.doFilter, void 0, catchFilter, void 0);
              }
              return this._then(void 0, fn, void 0, void 0, void 0);
            };
            Promise.prototype.then = function Promise$then(didFulfill, didReject, didProgress) {
              return this._then(didFulfill, didReject, didProgress, void 0, void 0);
            };
            Promise.prototype.done = function Promise$done(didFulfill, didReject, didProgress) {
              var promise = this._then(didFulfill, didReject, didProgress, void 0, void 0);
              promise._setIsFinal();
            };
            Promise.prototype.spread = function Promise$spread(didFulfill, didReject) {
              return this._then(didFulfill, didReject, void 0, APPLY, void 0);
            };
            Promise.prototype.isCancellable = function Promise$isCancellable() {
              return !this.isResolved() && this._cancellable();
            };
            Promise.prototype.toJSON = function Promise$toJSON() {
              var ret = {
                isFulfilled: false,
                isRejected: false,
                fulfillmentValue: void 0,
                rejectionReason: void 0
              };
              if (this.isFulfilled()) {
                ret.fulfillmentValue = this._settledValue;
                ret.isFulfilled = true;
              } else if (this.isRejected()) {
                ret.rejectionReason = this._settledValue;
                ret.isRejected = true;
              }
              return ret;
            };
            Promise.prototype.all = function Promise$all() {
              return new PromiseArray(this).promise();
            };
            Promise.is = function Promise$Is(val) {
              return val instanceof Promise;
            };
            Promise.all = function Promise$All(promises) {
              return new PromiseArray(promises).promise();
            };
            Promise.prototype.error = function Promise$_error(fn) {
              return this.caught(originatesFromRejection, fn);
            };
            Promise.prototype._resolveFromSyncValue = function Promise$_resolveFromSyncValue(value) {
              if (value === errorObj) {
                this._cleanValues();
                this._setRejected();
                this._settledValue = value.e;
                this._ensurePossibleRejectionHandled();
              } else {
                var maybePromise = cast(value, void 0);
                if (maybePromise instanceof Promise) {
                  this._follow(maybePromise);
                } else {
                  this._cleanValues();
                  this._setFulfilled();
                  this._settledValue = value;
                }
              }
            };
            Promise.method = function Promise$_Method(fn) {
              if (typeof fn !== "function") {
                throw new TypeError("fn must be a function");
              }
              return function Promise$_method() {
                var value;
                switch (arguments.length) {
                  case 0:
                    value = tryCatch1(fn, this, void 0);
                    break;
                  case 1:
                    value = tryCatch1(fn, this, arguments[0]);
                    break;
                  case 2:
                    value = tryCatch2(fn, this, arguments[0], arguments[1]);
                    break;
                  default:
                    var $_len = arguments.length;
                    var args = new Array($_len);
                    for (var $_i = 0; $_i < $_len; ++$_i) {
                      args[$_i] = arguments[$_i];
                    }
                    value = tryCatchApply(fn, args, this);
                    break;
                }
                var ret = new Promise(INTERNAL);
                ret._setTrace(void 0);
                ret._resolveFromSyncValue(value);
                return ret;
              };
            };
            Promise.attempt = Promise["try"] = function Promise$_Try(fn, args, ctx) {
              if (typeof fn !== "function") {
                return apiRejection("fn must be a function");
              }
              var value = isArray(args) ? tryCatchApply(fn, args, ctx) : tryCatch1(fn, ctx, args);
              var ret = new Promise(INTERNAL);
              ret._setTrace(void 0);
              ret._resolveFromSyncValue(value);
              return ret;
            };
            Promise.defer = Promise.pending = function Promise$Defer() {
              var promise = new Promise(INTERNAL);
              promise._setTrace(void 0);
              return new PromiseResolver(promise);
            };
            Promise.bind = function Promise$Bind(thisArg) {
              var maybePromise = cast(thisArg, void 0);
              var ret = new Promise(INTERNAL);
              ret._setTrace(void 0);
              if (maybePromise instanceof Promise) {
                var p = maybePromise.then(function(thisArg) {
                  ret._setBoundTo(thisArg);
                });
                ret._follow(p);
              } else {
                ret._setBoundTo(thisArg);
                ret._setFulfilled();
              }
              return ret;
            };
            Promise.cast = function Promise$_Cast(obj) {
              var ret = cast(obj, void 0);
              if (!(ret instanceof Promise)) {
                var val = ret;
                ret = new Promise(INTERNAL);
                ret._setTrace(void 0);
                ret._setFulfilled();
                ret._cleanValues();
                ret._settledValue = val;
              }
              return ret;
            };
            Promise.resolve = Promise.fulfilled = Promise.cast;
            Promise.reject = Promise.rejected = function Promise$Reject(reason) {
              var ret = new Promise(INTERNAL);
              ret._setTrace(void 0);
              markAsOriginatingFromRejection(reason);
              ret._cleanValues();
              ret._setRejected();
              ret._settledValue = reason;
              if (!canAttach(reason)) {
                var trace = new Error(reason + "");
                ret._setCarriedStackTrace(trace);
              }
              ret._ensurePossibleRejectionHandled();
              return ret;
            };
            Promise.onPossiblyUnhandledRejection = function Promise$OnPossiblyUnhandledRejection(fn) {
              CapturedTrace.possiblyUnhandledRejection = typeof fn === "function" ? fn : void 0;
            };
            var unhandledRejectionHandled;
            Promise.onUnhandledRejectionHandled = function Promise$onUnhandledRejectionHandled(fn) {
              unhandledRejectionHandled = typeof fn === "function" ? fn : void 0;
            };
            var debugging = false || !!(typeof process !== "undefined" && typeof process.execPath === "string" && typeof process.env === "object" && (process.env["BLUEBIRD_DEBUG"] || process.env["NODE_ENV"] === "development"));
            Promise.longStackTraces = function Promise$LongStackTraces() {
              if (async.haveItemsQueued() && debugging === false) {
                throw new Error("cannot enable long stack traces after promises have been created");
              }
              debugging = CapturedTrace.isSupported();
            };
            Promise.hasLongStackTraces = function Promise$HasLongStackTraces() {
              return debugging && CapturedTrace.isSupported();
            };
            Promise.prototype._then = function Promise$_then(didFulfill, didReject, didProgress, receiver, internalData) {
              var haveInternalData = internalData !== void 0;
              var ret = haveInternalData ? internalData : new Promise(INTERNAL);
              if (!haveInternalData) {
                if (debugging) {
                  var haveSameContext = this._peekContext() === this._traceParent;
                  ret._traceParent = haveSameContext ? this._traceParent : this;
                }
                ret._propagateFrom(this, 7);
              }
              var callbackIndex = this._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);
              if (this.isResolved()) {
                async.invoke(this._queueSettleAt, this, callbackIndex);
              }
              return ret;
            };
            Promise.prototype._length = function Promise$_length() {
              return this._bitField & 262143;
            };
            Promise.prototype._isFollowingOrFulfilledOrRejected = function Promise$_isFollowingOrFulfilledOrRejected() {
              return (this._bitField & 939524096) > 0;
            };
            Promise.prototype._isFollowing = function Promise$_isFollowing() {
              return (this._bitField & 536870912) === 536870912;
            };
            Promise.prototype._setLength = function Promise$_setLength(len) {
              this._bitField = (this._bitField & -262144) | (len & 262143);
            };
            Promise.prototype._setFulfilled = function Promise$_setFulfilled() {
              this._bitField = this._bitField | 268435456;
            };
            Promise.prototype._setRejected = function Promise$_setRejected() {
              this._bitField = this._bitField | 134217728;
            };
            Promise.prototype._setFollowing = function Promise$_setFollowing() {
              this._bitField = this._bitField | 536870912;
            };
            Promise.prototype._setIsFinal = function Promise$_setIsFinal() {
              this._bitField = this._bitField | 33554432;
            };
            Promise.prototype._isFinal = function Promise$_isFinal() {
              return (this._bitField & 33554432) > 0;
            };
            Promise.prototype._cancellable = function Promise$_cancellable() {
              return (this._bitField & 67108864) > 0;
            };
            Promise.prototype._setCancellable = function Promise$_setCancellable() {
              this._bitField = this._bitField | 67108864;
            };
            Promise.prototype._unsetCancellable = function Promise$_unsetCancellable() {
              this._bitField = this._bitField & (~67108864);
            };
            Promise.prototype._setRejectionIsUnhandled = function Promise$_setRejectionIsUnhandled() {
              this._bitField = this._bitField | 2097152;
            };
            Promise.prototype._unsetRejectionIsUnhandled = function Promise$_unsetRejectionIsUnhandled() {
              this._bitField = this._bitField & (~2097152);
              if (this._isUnhandledRejectionNotified()) {
                this._unsetUnhandledRejectionIsNotified();
                this._notifyUnhandledRejectionIsHandled();
              }
            };
            Promise.prototype._isRejectionUnhandled = function Promise$_isRejectionUnhandled() {
              return (this._bitField & 2097152) > 0;
            };
            Promise.prototype._setUnhandledRejectionIsNotified = function Promise$_setUnhandledRejectionIsNotified() {
              this._bitField = this._bitField | 524288;
            };
            Promise.prototype._unsetUnhandledRejectionIsNotified = function Promise$_unsetUnhandledRejectionIsNotified() {
              this._bitField = this._bitField & (~524288);
            };
            Promise.prototype._isUnhandledRejectionNotified = function Promise$_isUnhandledRejectionNotified() {
              return (this._bitField & 524288) > 0;
            };
            Promise.prototype._setCarriedStackTrace = function Promise$_setCarriedStackTrace(capturedTrace) {
              this._bitField = this._bitField | 1048576;
              this._fulfillmentHandler0 = capturedTrace;
            };
            Promise.prototype._unsetCarriedStackTrace = function Promise$_unsetCarriedStackTrace() {
              this._bitField = this._bitField & (~1048576);
              this._fulfillmentHandler0 = void 0;
            };
            Promise.prototype._isCarryingStackTrace = function Promise$_isCarryingStackTrace() {
              return (this._bitField & 1048576) > 0;
            };
            Promise.prototype._getCarriedStackTrace = function Promise$_getCarriedStackTrace() {
              return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : void 0;
            };
            Promise.prototype._receiverAt = function Promise$_receiverAt(index) {
              var ret = index === 0 ? this._receiver0 : this[(index << 2) + index - 5 + 4];
              if (this._isBound() && ret === void 0) {
                return this._boundTo;
              }
              return ret;
            };
            Promise.prototype._promiseAt = function Promise$_promiseAt(index) {
              return index === 0 ? this._promise0 : this[(index << 2) + index - 5 + 3];
            };
            Promise.prototype._fulfillmentHandlerAt = function Promise$_fulfillmentHandlerAt(index) {
              return index === 0 ? this._fulfillmentHandler0 : this[(index << 2) + index - 5 + 0];
            };
            Promise.prototype._rejectionHandlerAt = function Promise$_rejectionHandlerAt(index) {
              return index === 0 ? this._rejectionHandler0 : this[(index << 2) + index - 5 + 1];
            };
            Promise.prototype._addCallbacks = function Promise$_addCallbacks(fulfill, reject, progress, promise, receiver) {
              var index = this._length();
              if (index >= 262143 - 5) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promise;
                if (receiver !== void 0)
                  this._receiver0 = receiver;
                if (typeof fulfill === "function" && !this._isCarryingStackTrace())
                  this._fulfillmentHandler0 = fulfill;
                if (typeof reject === "function")
                  this._rejectionHandler0 = reject;
                if (typeof progress === "function")
                  this._progressHandler0 = progress;
              } else {
                var base = (index << 2) + index - 5;
                this[base + 3] = promise;
                this[base + 4] = receiver;
                this[base + 0] = typeof fulfill === "function" ? fulfill : void 0;
                this[base + 1] = typeof reject === "function" ? reject : void 0;
                this[base + 2] = typeof progress === "function" ? progress : void 0;
              }
              this._setLength(index + 1);
              return index;
            };
            Promise.prototype._setProxyHandlers = function Promise$_setProxyHandlers(receiver, promiseSlotValue) {
              var index = this._length();
              if (index >= 262143 - 5) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promiseSlotValue;
                this._receiver0 = receiver;
              } else {
                var base = (index << 2) + index - 5;
                this[base + 3] = promiseSlotValue;
                this[base + 4] = receiver;
                this[base + 0] = this[base + 1] = this[base + 2] = void 0;
              }
              this._setLength(index + 1);
            };
            Promise.prototype._proxyPromiseArray = function Promise$_proxyPromiseArray(promiseArray, index) {
              this._setProxyHandlers(promiseArray, index);
            };
            Promise.prototype._proxyPromise = function Promise$_proxyPromise(promise) {
              promise._setProxied();
              this._setProxyHandlers(promise, -15);
            };
            Promise.prototype._setBoundTo = function Promise$_setBoundTo(obj) {
              if (obj !== void 0) {
                this._bitField = this._bitField | 8388608;
                this._boundTo = obj;
              } else {
                this._bitField = this._bitField & (~8388608);
              }
            };
            Promise.prototype._isBound = function Promise$_isBound() {
              return (this._bitField & 8388608) === 8388608;
            };
            Promise.prototype._resolveFromResolver = function Promise$_resolveFromResolver(resolver) {
              var promise = this;
              this._setTrace(void 0);
              this._pushContext();
              function Promise$_resolver(val) {
                if (promise._tryFollow(val)) {
                  return;
                }
                promise._fulfill(val);
              }
              function Promise$_rejecter(val) {
                var trace = canAttach(val) ? val : new Error(val + "");
                promise._attachExtraTrace(trace);
                markAsOriginatingFromRejection(val);
                promise._reject(val, trace === val ? void 0 : trace);
              }
              var r = tryCatch2(resolver, void 0, Promise$_resolver, Promise$_rejecter);
              this._popContext();
              if (r !== void 0 && r === errorObj) {
                var e = r.e;
                var trace = canAttach(e) ? e : new Error(e + "");
                promise._reject(e, trace);
              }
            };
            Promise.prototype._spreadSlowCase = function Promise$_spreadSlowCase(targetFn, promise, values, boundTo) {
              var promiseForAll = new PromiseArray(values).promise();
              var promise2 = promiseForAll._then(function() {
                return targetFn.apply(boundTo, arguments);
              }, void 0, void 0, APPLY, void 0);
              promise._follow(promise2);
            };
            Promise.prototype._callSpread = function Promise$_callSpread(handler, promise, value) {
              var boundTo = this._boundTo;
              if (isArray(value)) {
                for (var i = 0,
                    len = value.length; i < len; ++i) {
                  if (cast(value[i], void 0) instanceof Promise) {
                    this._spreadSlowCase(handler, promise, value, boundTo);
                    return;
                  }
                }
              }
              promise._pushContext();
              return tryCatchApply(handler, value, boundTo);
            };
            Promise.prototype._callHandler = function Promise$_callHandler(handler, receiver, promise, value) {
              var x;
              if (receiver === APPLY && !this.isRejected()) {
                x = this._callSpread(handler, promise, value);
              } else {
                promise._pushContext();
                x = tryCatch1(handler, receiver, value);
              }
              promise._popContext();
              return x;
            };
            Promise.prototype._settlePromiseFromHandler = function Promise$_settlePromiseFromHandler(handler, receiver, value, promise) {
              if (!(promise instanceof Promise)) {
                handler.call(receiver, value, promise);
                return;
              }
              var x = this._callHandler(handler, receiver, promise, value);
              if (promise._isFollowing())
                return;
              if (x === errorObj || x === promise || x === NEXT_FILTER) {
                var err = x === promise ? makeSelfResolutionError() : x.e;
                var trace = canAttach(err) ? err : new Error(err + "");
                if (x !== NEXT_FILTER)
                  promise._attachExtraTrace(trace);
                promise._rejectUnchecked(err, trace);
              } else {
                var castValue = cast(x, promise);
                if (castValue instanceof Promise) {
                  if (castValue.isRejected() && !castValue._isCarryingStackTrace() && !canAttach(castValue._settledValue)) {
                    var trace = new Error(castValue._settledValue + "");
                    promise._attachExtraTrace(trace);
                    castValue._setCarriedStackTrace(trace);
                  }
                  promise._follow(castValue);
                  promise._propagateFrom(castValue, 1);
                } else {
                  promise._fulfillUnchecked(x);
                }
              }
            };
            Promise.prototype._follow = function Promise$_follow(promise) {
              this._setFollowing();
              if (promise.isPending()) {
                this._propagateFrom(promise, 1);
                promise._proxyPromise(this);
              } else if (promise.isFulfilled()) {
                this._fulfillUnchecked(promise._settledValue);
              } else {
                this._rejectUnchecked(promise._settledValue, promise._getCarriedStackTrace());
              }
              if (promise._isRejectionUnhandled())
                promise._unsetRejectionIsUnhandled();
              if (debugging && promise._traceParent == null) {
                promise._traceParent = this;
              }
            };
            Promise.prototype._tryFollow = function Promise$_tryFollow(value) {
              if (this._isFollowingOrFulfilledOrRejected() || value === this) {
                return false;
              }
              var maybePromise = cast(value, void 0);
              if (!(maybePromise instanceof Promise)) {
                return false;
              }
              this._follow(maybePromise);
              return true;
            };
            Promise.prototype._resetTrace = function Promise$_resetTrace() {
              if (debugging) {
                this._trace = new CapturedTrace(this._peekContext() === void 0);
              }
            };
            Promise.prototype._setTrace = function Promise$_setTrace(parent) {
              if (debugging) {
                var context = this._peekContext();
                this._traceParent = context;
                var isTopLevel = context === void 0;
                if (parent !== void 0 && parent._traceParent === context) {
                  this._trace = parent._trace;
                } else {
                  this._trace = new CapturedTrace(isTopLevel);
                }
              }
              return this;
            };
            Promise.prototype._attachExtraTrace = function Promise$_attachExtraTrace(error) {
              if (debugging) {
                var promise = this;
                var stack = error.stack;
                stack = typeof stack === "string" ? stack.split("\n") : [];
                CapturedTrace.protectErrorMessageNewlines(stack);
                var headerLineCount = 1;
                var combinedTraces = 1;
                while (promise != null && promise._trace != null) {
                  stack = CapturedTrace.combine(stack, promise._trace.stack.split("\n"));
                  promise = promise._traceParent;
                  combinedTraces++;
                }
                var stackTraceLimit = Error.stackTraceLimit || 10;
                var max = (stackTraceLimit + headerLineCount) * combinedTraces;
                var len = stack.length;
                if (len > max) {
                  stack.length = max;
                }
                if (len > 0)
                  stack[0] = stack[0].split("\u0002\u0000\u0001").join("\n");
                if (stack.length <= headerLineCount) {
                  error.stack = "(No stack trace)";
                } else {
                  error.stack = stack.join("\n");
                }
              }
            };
            Promise.prototype._cleanValues = function Promise$_cleanValues() {
              if (this._cancellable()) {
                this._cancellationParent = void 0;
              }
            };
            Promise.prototype._propagateFrom = function Promise$_propagateFrom(parent, flags) {
              if ((flags & 1) > 0 && parent._cancellable()) {
                this._setCancellable();
                this._cancellationParent = parent;
              }
              if ((flags & 4) > 0) {
                this._setBoundTo(parent._boundTo);
              }
              if ((flags & 2) > 0) {
                this._setTrace(parent);
              }
            };
            Promise.prototype._fulfill = function Promise$_fulfill(value) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._fulfillUnchecked(value);
            };
            Promise.prototype._reject = function Promise$_reject(reason, carriedStackTrace) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._rejectUnchecked(reason, carriedStackTrace);
            };
            Promise.prototype._settlePromiseAt = function Promise$_settlePromiseAt(index) {
              var handler = this.isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
              var value = this._settledValue;
              var receiver = this._receiverAt(index);
              var promise = this._promiseAt(index);
              if (typeof handler === "function") {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
              } else {
                var done = false;
                var isFulfilled = this.isFulfilled();
                if (receiver !== void 0) {
                  if (receiver instanceof Promise && receiver._isProxied()) {
                    receiver._unsetProxied();
                    if (isFulfilled)
                      receiver._fulfillUnchecked(value);
                    else
                      receiver._rejectUnchecked(value, this._getCarriedStackTrace());
                    done = true;
                  } else if (receiver instanceof PromiseArray) {
                    if (isFulfilled)
                      receiver._promiseFulfilled(value, promise);
                    else
                      receiver._promiseRejected(value, promise);
                    done = true;
                  }
                }
                if (!done) {
                  if (isFulfilled)
                    promise._fulfill(value);
                  else
                    promise._reject(value, this._getCarriedStackTrace());
                }
              }
              if (index >= 4) {
                this._queueGC();
              }
            };
            Promise.prototype._isProxied = function Promise$_isProxied() {
              return (this._bitField & 4194304) === 4194304;
            };
            Promise.prototype._setProxied = function Promise$_setProxied() {
              this._bitField = this._bitField | 4194304;
            };
            Promise.prototype._unsetProxied = function Promise$_unsetProxied() {
              this._bitField = this._bitField & (~4194304);
            };
            Promise.prototype._isGcQueued = function Promise$_isGcQueued() {
              return (this._bitField & -1073741824) === -1073741824;
            };
            Promise.prototype._setGcQueued = function Promise$_setGcQueued() {
              this._bitField = this._bitField | -1073741824;
            };
            Promise.prototype._unsetGcQueued = function Promise$_unsetGcQueued() {
              this._bitField = this._bitField & (~-1073741824);
            };
            Promise.prototype._queueGC = function Promise$_queueGC() {
              if (this._isGcQueued())
                return;
              this._setGcQueued();
              async.invokeLater(this._gc, this, void 0);
            };
            Promise.prototype._gc = function Promise$gc() {
              var len = this._length() * 5 - 5;
              for (var i = 0; i < len; i++) {
                delete this[i];
              }
              this._clearFirstHandlerData();
              this._setLength(0);
              this._unsetGcQueued();
            };
            Promise.prototype._clearFirstHandlerData = function Promise$_clearFirstHandlerData() {
              this._fulfillmentHandler0 = void 0;
              this._rejectionHandler0 = void 0;
              this._promise0 = void 0;
              this._receiver0 = void 0;
            };
            Promise.prototype._queueSettleAt = function Promise$_queueSettleAt(index) {
              if (this._isRejectionUnhandled())
                this._unsetRejectionIsUnhandled();
              async.invoke(this._settlePromiseAt, this, index);
            };
            Promise.prototype._fulfillUnchecked = function Promise$_fulfillUnchecked(value) {
              if (!this.isPending())
                return;
              if (value === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._rejectUnchecked(err, void 0);
              }
              this._cleanValues();
              this._setFulfilled();
              this._settledValue = value;
              var len = this._length();
              if (len > 0) {
                async.invoke(this._settlePromises, this, len);
              }
            };
            Promise.prototype._rejectUncheckedCheckError = function Promise$_rejectUncheckedCheckError(reason) {
              var trace = canAttach(reason) ? reason : new Error(reason + "");
              this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
            };
            Promise.prototype._rejectUnchecked = function Promise$_rejectUnchecked(reason, trace) {
              if (!this.isPending())
                return;
              if (reason === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._rejectUnchecked(err);
              }
              this._cleanValues();
              this._setRejected();
              this._settledValue = reason;
              if (this._isFinal()) {
                async.invokeLater(thrower, void 0, trace === void 0 ? reason : trace);
                return;
              }
              var len = this._length();
              if (trace !== void 0)
                this._setCarriedStackTrace(trace);
              if (len > 0) {
                async.invoke(this._rejectPromises, this, null);
              } else {
                this._ensurePossibleRejectionHandled();
              }
            };
            Promise.prototype._rejectPromises = function Promise$_rejectPromises() {
              this._settlePromises();
              this._unsetCarriedStackTrace();
            };
            Promise.prototype._settlePromises = function Promise$_settlePromises() {
              var len = this._length();
              for (var i = 0; i < len; i++) {
                this._settlePromiseAt(i);
              }
            };
            Promise.prototype._ensurePossibleRejectionHandled = function Promise$_ensurePossibleRejectionHandled() {
              this._setRejectionIsUnhandled();
              if (CapturedTrace.possiblyUnhandledRejection !== void 0) {
                async.invokeLater(this._notifyUnhandledRejection, this, void 0);
              }
            };
            Promise.prototype._notifyUnhandledRejectionIsHandled = function Promise$_notifyUnhandledRejectionIsHandled() {
              if (typeof unhandledRejectionHandled === "function") {
                async.invokeLater(unhandledRejectionHandled, void 0, this);
              }
            };
            Promise.prototype._notifyUnhandledRejection = function Promise$_notifyUnhandledRejection() {
              if (this._isRejectionUnhandled()) {
                var reason = this._settledValue;
                var trace = this._getCarriedStackTrace();
                this._setUnhandledRejectionIsNotified();
                if (trace !== void 0) {
                  this._unsetCarriedStackTrace();
                  reason = trace;
                }
                if (typeof CapturedTrace.possiblyUnhandledRejection === "function") {
                  CapturedTrace.possiblyUnhandledRejection(reason, this);
                }
              }
            };
            var contextStack = [];
            Promise.prototype._peekContext = function Promise$_peekContext() {
              var lastIndex = contextStack.length - 1;
              if (lastIndex >= 0) {
                return contextStack[lastIndex];
              }
              return void 0;
            };
            Promise.prototype._pushContext = function Promise$_pushContext() {
              if (!debugging)
                return;
              contextStack.push(this);
            };
            Promise.prototype._popContext = function Promise$_popContext() {
              if (!debugging)
                return;
              contextStack.pop();
            };
            Promise.noConflict = function Promise$NoConflict() {
              return noConflict(Promise);
            };
            Promise.setScheduler = function(fn) {
              if (typeof fn !== "function")
                throw new TypeError("fn must be a function");
              async._schedule = fn;
            };
            if (!CapturedTrace.isSupported()) {
              Promise.longStackTraces = function() {};
              debugging = false;
            }
            Promise._makeSelfResolutionError = makeSelfResolutionError;
            _dereq_("./finally.js")(Promise, NEXT_FILTER, cast);
            _dereq_("./direct_resolve.js")(Promise);
            _dereq_("./synchronous_inspection.js")(Promise);
            _dereq_("./join.js")(Promise, PromiseArray, cast, INTERNAL);
            Promise.RangeError = RangeError;
            Promise.CancellationError = CancellationError;
            Promise.TimeoutError = TimeoutError;
            Promise.TypeError = TypeError;
            Promise.OperationalError = OperationalError;
            Promise.RejectionError = OperationalError;
            Promise.AggregateError = errors.AggregateError;
            util.toFastProperties(Promise);
            util.toFastProperties(Promise.prototype);
            Promise.Promise = Promise;
            _dereq_('./nodeify.js')(Promise);
            Promise.prototype = Promise.prototype;
            return Promise;
          };
        }, {
          "./async.js": 1,
          "./captured_trace.js": 3,
          "./catch_filter.js": 4,
          "./direct_resolve.js": 5,
          "./errors.js": 6,
          "./errors_api_rejection": 7,
          "./finally.js": 9,
          "./join.js": 10,
          "./nodeify.js": 11,
          "./promise_array.js": 13,
          "./promise_resolver.js": 14,
          "./synchronous_inspection.js": 17,
          "./thenables.js": 18,
          "./util.js": 19
        }],
        13: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, cast) {
            var canAttach = _dereq_("./errors.js").canAttach;
            var util = _dereq_("./util.js");
            var isArray = util.isArray;
            function toResolutionValue(val) {
              switch (val) {
                case -1:
                  return void 0;
                case -2:
                  return [];
                case -3:
                  return {};
              }
            }
            function PromiseArray(values) {
              var promise = this._promise = new Promise(INTERNAL);
              var parent = void 0;
              if (values instanceof Promise) {
                parent = values;
                promise._propagateFrom(parent, 1 | 4);
              }
              promise._setTrace(parent);
              this._values = values;
              this._length = 0;
              this._totalResolved = 0;
              this._init(void 0, -2);
            }
            PromiseArray.prototype.length = function PromiseArray$length() {
              return this._length;
            };
            PromiseArray.prototype.promise = function PromiseArray$promise() {
              return this._promise;
            };
            PromiseArray.prototype._init = function PromiseArray$_init(_, resolveValueIfEmpty) {
              var values = cast(this._values, void 0);
              if (values instanceof Promise) {
                this._values = values;
                values._setBoundTo(this._promise._boundTo);
                if (values.isFulfilled()) {
                  values = values._settledValue;
                  if (!isArray(values)) {
                    var err = new Promise.TypeError("expecting an array, a promise or a thenable");
                    this.__hardReject__(err);
                    return;
                  }
                } else if (values.isPending()) {
                  values._then(PromiseArray$_init, this._reject, void 0, this, resolveValueIfEmpty);
                  return;
                } else {
                  values._unsetRejectionIsUnhandled();
                  this._reject(values._settledValue);
                  return;
                }
              } else if (!isArray(values)) {
                var err = new Promise.TypeError("expecting an array, a promise or a thenable");
                this.__hardReject__(err);
                return;
              }
              if (values.length === 0) {
                if (resolveValueIfEmpty === -5) {
                  this._resolveEmptyArray();
                } else {
                  this._resolve(toResolutionValue(resolveValueIfEmpty));
                }
                return;
              }
              var len = this.getActualLength(values.length);
              var newLen = len;
              var newValues = this.shouldCopyValues() ? new Array(len) : this._values;
              var isDirectScanNeeded = false;
              for (var i = 0; i < len; ++i) {
                var maybePromise = cast(values[i], void 0);
                if (maybePromise instanceof Promise) {
                  if (maybePromise.isPending()) {
                    maybePromise._proxyPromiseArray(this, i);
                  } else {
                    maybePromise._unsetRejectionIsUnhandled();
                    isDirectScanNeeded = true;
                  }
                } else {
                  isDirectScanNeeded = true;
                }
                newValues[i] = maybePromise;
              }
              this._values = newValues;
              this._length = newLen;
              if (isDirectScanNeeded) {
                this._scanDirectValues(len);
              }
            };
            PromiseArray.prototype._settlePromiseAt = function PromiseArray$_settlePromiseAt(index) {
              var value = this._values[index];
              if (!(value instanceof Promise)) {
                this._promiseFulfilled(value, index);
              } else if (value.isFulfilled()) {
                this._promiseFulfilled(value._settledValue, index);
              } else if (value.isRejected()) {
                this._promiseRejected(value._settledValue, index);
              }
            };
            PromiseArray.prototype._scanDirectValues = function PromiseArray$_scanDirectValues(len) {
              for (var i = 0; i < len; ++i) {
                if (this._isResolved()) {
                  break;
                }
                this._settlePromiseAt(i);
              }
            };
            PromiseArray.prototype._isResolved = function PromiseArray$_isResolved() {
              return this._values === null;
            };
            PromiseArray.prototype._resolve = function PromiseArray$_resolve(value) {
              this._values = null;
              this._promise._fulfill(value);
            };
            PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function PromiseArray$_reject(reason) {
              this._values = null;
              var trace = canAttach(reason) ? reason : new Error(reason + "");
              this._promise._attachExtraTrace(trace);
              this._promise._reject(reason, trace);
            };
            PromiseArray.prototype._promiseProgressed = function PromiseArray$_promiseProgressed(progressValue, index) {
              if (this._isResolved())
                return;
              this._promise._progress({
                index: index,
                value: progressValue
              });
            };
            PromiseArray.prototype._promiseFulfilled = function PromiseArray$_promiseFulfilled(value, index) {
              if (this._isResolved())
                return;
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                this._resolve(this._values);
              }
            };
            PromiseArray.prototype._promiseRejected = function PromiseArray$_promiseRejected(reason, index) {
              if (this._isResolved())
                return;
              this._totalResolved++;
              this._reject(reason);
            };
            PromiseArray.prototype.shouldCopyValues = function PromiseArray$_shouldCopyValues() {
              return true;
            };
            PromiseArray.prototype.getActualLength = function PromiseArray$getActualLength(len) {
              return len;
            };
            return PromiseArray;
          };
        }, {
          "./errors.js": 6,
          "./util.js": 19
        }],
        14: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util.js");
          var maybeWrapAsError = util.maybeWrapAsError;
          var errors = _dereq_("./errors.js");
          var TimeoutError = errors.TimeoutError;
          var OperationalError = errors.OperationalError;
          var async = _dereq_("./async.js");
          var haveGetters = util.haveGetters;
          var es5 = _dereq_("./es5.js");
          function isUntypedError(obj) {
            return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
          }
          function wrapAsOperationalError(obj) {
            var ret;
            if (isUntypedError(obj)) {
              ret = new OperationalError(obj);
            } else {
              ret = obj;
            }
            errors.markAsOriginatingFromRejection(ret);
            return ret;
          }
          function nodebackForPromise(promise) {
            function PromiseResolver$_callback(err, value) {
              if (promise === null)
                return;
              if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
              } else if (arguments.length > 2) {
                var $_len = arguments.length;
                var args = new Array($_len - 1);
                for (var $_i = 1; $_i < $_len; ++$_i) {
                  args[$_i - 1] = arguments[$_i];
                }
                promise._fulfill(args);
              } else {
                promise._fulfill(value);
              }
              promise = null;
            }
            return PromiseResolver$_callback;
          }
          var PromiseResolver;
          if (!haveGetters) {
            PromiseResolver = function PromiseResolver(promise) {
              this.promise = promise;
              this.asCallback = nodebackForPromise(promise);
              this.callback = this.asCallback;
            };
          } else {
            PromiseResolver = function PromiseResolver(promise) {
              this.promise = promise;
            };
          }
          if (haveGetters) {
            var prop = {get: function() {
                return nodebackForPromise(this.promise);
              }};
            es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
            es5.defineProperty(PromiseResolver.prototype, "callback", prop);
          }
          PromiseResolver._nodebackForPromise = nodebackForPromise;
          PromiseResolver.prototype.toString = function PromiseResolver$toString() {
            return "[object PromiseResolver]";
          };
          PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function PromiseResolver$resolve(value) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
            }
            var promise = this.promise;
            if (promise._tryFollow(value)) {
              return;
            }
            async.invoke(promise._fulfill, promise, value);
          };
          PromiseResolver.prototype.reject = function PromiseResolver$reject(reason) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
            }
            var promise = this.promise;
            errors.markAsOriginatingFromRejection(reason);
            var trace = errors.canAttach(reason) ? reason : new Error(reason + "");
            promise._attachExtraTrace(trace);
            async.invoke(promise._reject, promise, reason);
            if (trace !== reason) {
              async.invoke(this._setCarriedStackTrace, this, trace);
            }
          };
          PromiseResolver.prototype.progress = function PromiseResolver$progress(value) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
            }
            async.invoke(this.promise._progress, this.promise, value);
          };
          PromiseResolver.prototype.cancel = function PromiseResolver$cancel() {
            async.invoke(this.promise.cancel, this.promise, void 0);
          };
          PromiseResolver.prototype.timeout = function PromiseResolver$timeout() {
            this.reject(new TimeoutError("timeout"));
          };
          PromiseResolver.prototype.isResolved = function PromiseResolver$isResolved() {
            return this.promise.isResolved();
          };
          PromiseResolver.prototype.toJSON = function PromiseResolver$toJSON() {
            return this.promise.toJSON();
          };
          PromiseResolver.prototype._setCarriedStackTrace = function PromiseResolver$_setCarriedStackTrace(trace) {
            if (this.promise.isRejected()) {
              this.promise._setCarriedStackTrace(trace);
            }
          };
          module.exports = PromiseResolver;
        }, {
          "./async.js": 1,
          "./errors.js": 6,
          "./es5.js": 8,
          "./util.js": 19
        }],
        15: [function(_dereq_, module, exports) {
          "use strict";
          function arrayCopy(src, srcIndex, dst, dstIndex, len) {
            for (var j = 0; j < len; ++j) {
              dst[j + dstIndex] = src[j + srcIndex];
            }
          }
          function Queue(capacity) {
            this._capacity = capacity;
            this._length = 0;
            this._front = 0;
            this._makeCapacity();
          }
          Queue.prototype._willBeOverCapacity = function Queue$_willBeOverCapacity(size) {
            return this._capacity < size;
          };
          Queue.prototype._pushOne = function Queue$_pushOne(arg) {
            var length = this.length();
            this._checkCapacity(length + 1);
            var i = (this._front + length) & (this._capacity - 1);
            this[i] = arg;
            this._length = length + 1;
          };
          Queue.prototype.push = function Queue$push(fn, receiver, arg) {
            var length = this.length() + 3;
            if (this._willBeOverCapacity(length)) {
              this._pushOne(fn);
              this._pushOne(receiver);
              this._pushOne(arg);
              return;
            }
            var j = this._front + length - 3;
            this._checkCapacity(length);
            var wrapMask = this._capacity - 1;
            this[(j + 0) & wrapMask] = fn;
            this[(j + 1) & wrapMask] = receiver;
            this[(j + 2) & wrapMask] = arg;
            this._length = length;
          };
          Queue.prototype.shift = function Queue$shift() {
            var front = this._front,
                ret = this[front];
            this[front] = void 0;
            this._front = (front + 1) & (this._capacity - 1);
            this._length--;
            return ret;
          };
          Queue.prototype.length = function Queue$length() {
            return this._length;
          };
          Queue.prototype._makeCapacity = function Queue$_makeCapacity() {
            var len = this._capacity;
            for (var i = 0; i < len; ++i) {
              this[i] = void 0;
            }
          };
          Queue.prototype._checkCapacity = function Queue$_checkCapacity(size) {
            if (this._capacity < size) {
              this._resizeTo(this._capacity << 3);
            }
          };
          Queue.prototype._resizeTo = function Queue$_resizeTo(capacity) {
            var oldFront = this._front;
            var oldCapacity = this._capacity;
            var oldQueue = new Array(oldCapacity);
            var length = this.length();
            arrayCopy(this, 0, oldQueue, 0, oldCapacity);
            this._capacity = capacity;
            this._makeCapacity();
            this._front = 0;
            if (oldFront + length <= oldCapacity) {
              arrayCopy(oldQueue, oldFront, this, 0, length);
            } else {
              var lengthBeforeWrapping = length - ((oldFront + length) & (oldCapacity - 1));
              arrayCopy(oldQueue, oldFront, this, 0, lengthBeforeWrapping);
              arrayCopy(oldQueue, 0, this, lengthBeforeWrapping, length - lengthBeforeWrapping);
            }
          };
          module.exports = Queue;
        }, {}],
        16: [function(_dereq_, module, exports) {
          "use strict";
          var schedule;
          var _MutationObserver;
          if (typeof process === "object" && typeof process.version === "string") {
            schedule = function Promise$_Scheduler(fn) {
              process.nextTick(fn);
            };
          } else if ((typeof MutationObserver !== "undefined" && (_MutationObserver = MutationObserver)) || (typeof WebKitMutationObserver !== "undefined" && (_MutationObserver = WebKitMutationObserver))) {
            schedule = (function() {
              var div = document.createElement("div");
              var queuedFn = void 0;
              var observer = new _MutationObserver(function Promise$_Scheduler() {
                var fn = queuedFn;
                queuedFn = void 0;
                fn();
              });
              observer.observe(div, {attributes: true});
              return function Promise$_Scheduler(fn) {
                queuedFn = fn;
                div.classList.toggle("foo");
              };
            })();
          } else if (typeof setTimeout !== "undefined") {
            schedule = function Promise$_Scheduler(fn) {
              setTimeout(fn, 0);
            };
          } else
            throw new Error("no async scheduler available");
          module.exports = schedule;
        }, {}],
        17: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            function PromiseInspection(promise) {
              if (promise !== void 0) {
                this._bitField = promise._bitField;
                this._settledValue = promise.isResolved() ? promise._settledValue : void 0;
              } else {
                this._bitField = 0;
                this._settledValue = void 0;
              }
            }
            PromiseInspection.prototype.isFulfilled = Promise.prototype.isFulfilled = function Promise$isFulfilled() {
              return (this._bitField & 268435456) > 0;
            };
            PromiseInspection.prototype.isRejected = Promise.prototype.isRejected = function Promise$isRejected() {
              return (this._bitField & 134217728) > 0;
            };
            PromiseInspection.prototype.isPending = Promise.prototype.isPending = function Promise$isPending() {
              return (this._bitField & 402653184) === 0;
            };
            PromiseInspection.prototype.value = Promise.prototype.value = function Promise$value() {
              if (!this.isFulfilled()) {
                throw new TypeError("cannot get fulfillment value of a non-fulfilled promise");
              }
              return this._settledValue;
            };
            PromiseInspection.prototype.error = PromiseInspection.prototype.reason = Promise.prototype.reason = function Promise$reason() {
              if (!this.isRejected()) {
                throw new TypeError("cannot get rejection reason of a non-rejected promise");
              }
              return this._settledValue;
            };
            PromiseInspection.prototype.isResolved = Promise.prototype.isResolved = function Promise$isResolved() {
              return (this._bitField & 402653184) > 0;
            };
            Promise.PromiseInspection = PromiseInspection;
          };
        }, {}],
        18: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var util = _dereq_("./util.js");
            var canAttach = _dereq_("./errors.js").canAttach;
            var errorObj = util.errorObj;
            var isObject = util.isObject;
            function getThen(obj) {
              try {
                return obj.then;
              } catch (e) {
                errorObj.e = e;
                return errorObj;
              }
            }
            function Promise$_Cast(obj, originalPromise) {
              if (isObject(obj)) {
                if (obj instanceof Promise) {
                  return obj;
                } else if (isAnyBluebirdPromise(obj)) {
                  var ret = new Promise(INTERNAL);
                  ret._setTrace(void 0);
                  obj._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null);
                  ret._setFollowing();
                  return ret;
                }
                var then = getThen(obj);
                if (then === errorObj) {
                  if (originalPromise !== void 0 && canAttach(then.e)) {
                    originalPromise._attachExtraTrace(then.e);
                  }
                  return Promise.reject(then.e);
                } else if (typeof then === "function") {
                  return Promise$_doThenable(obj, then, originalPromise);
                }
              }
              return obj;
            }
            var hasProp = {}.hasOwnProperty;
            function isAnyBluebirdPromise(obj) {
              return hasProp.call(obj, "_promise0");
            }
            function Promise$_doThenable(x, then, originalPromise) {
              var resolver = Promise.defer();
              var called = false;
              try {
                then.call(x, Promise$_resolveFromThenable, Promise$_rejectFromThenable, Promise$_progressFromThenable);
              } catch (e) {
                if (!called) {
                  called = true;
                  var trace = canAttach(e) ? e : new Error(e + "");
                  if (originalPromise !== void 0) {
                    originalPromise._attachExtraTrace(trace);
                  }
                  resolver.promise._reject(e, trace);
                }
              }
              return resolver.promise;
              function Promise$_resolveFromThenable(y) {
                if (called)
                  return;
                called = true;
                if (x === y) {
                  var e = Promise._makeSelfResolutionError();
                  if (originalPromise !== void 0) {
                    originalPromise._attachExtraTrace(e);
                  }
                  resolver.promise._reject(e, void 0);
                  return;
                }
                resolver.resolve(y);
              }
              function Promise$_rejectFromThenable(r) {
                if (called)
                  return;
                called = true;
                var trace = canAttach(r) ? r : new Error(r + "");
                if (originalPromise !== void 0) {
                  originalPromise._attachExtraTrace(trace);
                }
                resolver.promise._reject(r, trace);
              }
              function Promise$_progressFromThenable(v) {
                if (called)
                  return;
                var promise = resolver.promise;
                if (typeof promise._progress === "function") {
                  promise._progress(v);
                }
              }
            }
            return Promise$_Cast;
          };
        }, {
          "./errors.js": 6,
          "./util.js": 19
        }],
        19: [function(_dereq_, module, exports) {
          "use strict";
          var es5 = _dereq_("./es5.js");
          var haveGetters = (function() {
            try {
              var o = {};
              es5.defineProperty(o, "f", {get: function() {
                  return 3;
                }});
              return o.f === 3;
            } catch (e) {
              return false;
            }
          })();
          var canEvaluate = typeof navigator == "undefined";
          var errorObj = {e: {}};
          function tryCatch1(fn, receiver, arg) {
            try {
              return fn.call(receiver, arg);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch2(fn, receiver, arg, arg2) {
            try {
              return fn.call(receiver, arg, arg2);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch3(fn, receiver, arg, arg2, arg3) {
            try {
              return fn.call(receiver, arg, arg2, arg3);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch4(fn, receiver, arg, arg2, arg3, arg4) {
            try {
              return fn.call(receiver, arg, arg2, arg3, arg4);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatchApply(fn, args, receiver) {
            try {
              return fn.apply(receiver, args);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          var inherits = function(Child, Parent) {
            var hasProp = {}.hasOwnProperty;
            function T() {
              this.constructor = Child;
              this.constructor$ = Parent;
              for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                  this[propertyName + "$"] = Parent.prototype[propertyName];
                }
              }
            }
            T.prototype = Parent.prototype;
            Child.prototype = new T();
            return Child.prototype;
          };
          function asString(val) {
            return typeof val === "string" ? val : ("" + val);
          }
          function isPrimitive(val) {
            return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
          }
          function isObject(value) {
            return !isPrimitive(value);
          }
          function maybeWrapAsError(maybeError) {
            if (!isPrimitive(maybeError))
              return maybeError;
            return new Error(asString(maybeError));
          }
          function withAppended(target, appendee) {
            var len = target.length;
            var ret = new Array(len + 1);
            var i;
            for (i = 0; i < len; ++i) {
              ret[i] = target[i];
            }
            ret[i] = appendee;
            return ret;
          }
          function getDataPropertyOrDefault(obj, key, defaultValue) {
            if (es5.isES5) {
              var desc = Object.getOwnPropertyDescriptor(obj, key);
              if (desc != null) {
                return desc.get == null && desc.set == null ? desc.value : defaultValue;
              }
            } else {
              return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
            }
          }
          function notEnumerableProp(obj, name, value) {
            if (isPrimitive(obj))
              return obj;
            var descriptor = {
              value: value,
              configurable: true,
              enumerable: false,
              writable: true
            };
            es5.defineProperty(obj, name, descriptor);
            return obj;
          }
          var wrapsPrimitiveReceiver = (function() {
            return this !== "string";
          }).call("string");
          function thrower(r) {
            throw r;
          }
          var inheritedDataKeys = (function() {
            if (es5.isES5) {
              return function(obj, opts) {
                var ret = [];
                var visitedKeys = Object.create(null);
                var getKeys = Object(opts).includeHidden ? Object.getOwnPropertyNames : Object.keys;
                while (obj != null) {
                  var keys;
                  try {
                    keys = getKeys(obj);
                  } catch (e) {
                    return ret;
                  }
                  for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key])
                      continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                      ret.push(key);
                    }
                  }
                  obj = es5.getPrototypeOf(obj);
                }
                return ret;
              };
            } else {
              return function(obj) {
                var ret = [];
                for (var key in obj) {
                  ret.push(key);
                }
                return ret;
              };
            }
          })();
          function isClass(fn) {
            try {
              if (typeof fn === "function") {
                var keys = es5.keys(fn.prototype);
                return keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
              }
              return false;
            } catch (e) {
              return false;
            }
          }
          function toFastProperties(obj) {
            function f() {}
            f.prototype = obj;
            return f;
            eval(obj);
          }
          var rident = /^[a-z$_][a-z$_0-9]*$/i;
          function isIdentifier(str) {
            return rident.test(str);
          }
          function filledRange(count, prefix, suffix) {
            var ret = new Array(count);
            for (var i = 0; i < count; ++i) {
              ret[i] = prefix + i + suffix;
            }
            return ret;
          }
          var ret = {
            isClass: isClass,
            isIdentifier: isIdentifier,
            inheritedDataKeys: inheritedDataKeys,
            getDataPropertyOrDefault: getDataPropertyOrDefault,
            thrower: thrower,
            isArray: es5.isArray,
            haveGetters: haveGetters,
            notEnumerableProp: notEnumerableProp,
            isPrimitive: isPrimitive,
            isObject: isObject,
            canEvaluate: canEvaluate,
            errorObj: errorObj,
            tryCatch1: tryCatch1,
            tryCatch2: tryCatch2,
            tryCatch3: tryCatch3,
            tryCatch4: tryCatch4,
            tryCatchApply: tryCatchApply,
            inherits: inherits,
            withAppended: withAppended,
            asString: asString,
            maybeWrapAsError: maybeWrapAsError,
            wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
            toFastProperties: toFastProperties,
            filledRange: filledRange
          };
          module.exports = ret;
        }, {"./es5.js": 8}]
      }, {}, [2])(2);
    });
    ;
    if (typeof window !== 'undefined' && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== 'undefined' && self !== null) {
      self.P = self.Promise;
    }
    (function(global) {
      Promise.defer = function() {
        var resolve,
            reject;
        var promise = new Promise(function() {
          resolve = arguments[0];
          reject = arguments[1];
        });
        return {
          resolve: resolve,
          reject: reject,
          promise: promise
        };
      };
      function logError(error) {
        if (typeof(error) === 'string') {
          console.error(error);
        } else {
          console.error(error.message, error.stack);
        }
      }
      function emitUnauthorized(r) {
        if (r.statusCode === 403 || r.statusCode === 401) {
          this._emit('error', new RemoteStorage.Unauthorized());
        }
        return Promise.resolve(r);
      }
      function shareFirst(path) {
        return (this.backend === 'dropbox' && path.match(/^\/public\/.*[^\/]$/));
      }
      var SyncedGetPutDelete = {
        get: function(path, maxAge) {
          var self = this;
          if (this.local) {
            if (maxAge === undefined) {
              if (this.connected) {
                maxAge = 2 * this.getSyncInterval();
              } else {
                maxAge = false;
              }
            }
            var maxAgeInvalid = function(maxAge) {
              return maxAge !== false && typeof(maxAge) !== 'number';
            };
            if (maxAgeInvalid(maxAge)) {
              return Promise.reject('Argument \'maxAge\' must be false or a number');
            }
            return this.local.get(path, maxAge, this.sync.queueGetRequest.bind(this.sync));
          } else {
            return this.remote.get(path);
          }
        },
        put: function(path, body, contentType) {
          if (shareFirst.bind(this)(path)) {
            return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.put(path, body, contentType));
          } else if (this.local) {
            return this.local.put(path, body, contentType);
          } else {
            return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.put(path, body, contentType));
          }
        },
        'delete': function(path) {
          if (this.local) {
            return this.local.delete(path);
          } else {
            return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.delete(path));
          }
        },
        _wrapBusyDone: function(result) {
          var self = this;
          this._emit('wire-busy');
          return result.then(function(r) {
            self._emit('wire-done', {success: true});
            return Promise.resolve(r);
          }, function(err) {
            self._emit('wire-done', {success: false});
            return Promise.reject(err);
          });
        }
      };
      var RemoteStorage = function(cfg) {
        if (typeof cfg === 'object') {
          RemoteStorage.config.logging = !!cfg.logging;
        }
        RemoteStorage.eventHandling(this, 'ready', 'connected', 'disconnected', 'not-connected', 'conflict', 'error', 'features-loaded', 'connecting', 'authing', 'wire-busy', 'wire-done', 'sync-interval-change');
        this._pending = [];
        this._setGPD({
          get: this._pendingGPD('get'),
          put: this._pendingGPD('put'),
          delete: this._pendingGPD('delete')
        });
        this._cleanups = [];
        this._pathHandlers = {change: {}};
        this.apiKeys = {};
        if (this.localStorageAvailable()) {
          try {
            this.apiKeys = JSON.parse(localStorage['remotestorage:api-keys']);
          } catch (exc) {}
          this.setBackend(localStorage['remotestorage:backend'] || 'remotestorage');
        }
        var origOn = this.on;
        this.on = function(eventName, handler) {
          if (eventName === 'ready' && this.remote.connected && this._allLoaded) {
            setTimeout(handler, 0);
          } else if (eventName === 'features-loaded' && this._allLoaded) {
            setTimeout(handler, 0);
          }
          return origOn.call(this, eventName, handler);
        };
        this._init();
        this.fireInitial = function() {
          if (this.local) {
            setTimeout(this.local.fireInitial.bind(this.local), 0);
          }
        }.bind(this);
        this.on('ready', this.fireInitial.bind(this));
      };
      RemoteStorage.SyncedGetPutDelete = SyncedGetPutDelete;
      RemoteStorage.DiscoveryError = function(message) {
        Error.apply(this, arguments);
        this.message = message;
      };
      RemoteStorage.DiscoveryError.prototype = Object.create(Error.prototype);
      RemoteStorage.Unauthorized = function() {
        Error.apply(this, arguments);
      };
      RemoteStorage.Unauthorized.prototype = Object.create(Error.prototype);
      RemoteStorage.log = function() {
        if (RemoteStorage.config.logging) {
          console.log.apply(console, arguments);
        }
      };
      RemoteStorage.config = {
        logging: false,
        changeEvents: {
          local: true,
          window: false,
          remote: true,
          conflict: true
        },
        discoveryTimeout: 10000
      };
      RemoteStorage.prototype = {
        connect: function(userAddress) {
          this.setBackend('remotestorage');
          if (userAddress.indexOf('@') < 0) {
            this._emit('error', new RemoteStorage.DiscoveryError("User address doesn't contain an @."));
            return;
          }
          this.remote.configure({userAddress: userAddress});
          this._emit('connecting');
          var discoveryTimeout = setTimeout(function() {
            this._emit('error', new RemoteStorage.DiscoveryError("No storage information found at that user address."));
          }.bind(this), RemoteStorage.config.discoveryTimeout);
          RemoteStorage.Discover(userAddress).then(function(info) {
            clearTimeout(discoveryTimeout);
            this._emit('authing');
            info.userAddress = userAddress;
            this.remote.configure(info);
            if (!this.remote.connected) {
              if (info.authURL) {
                this.authorize(info.authURL);
              } else {
                this.impliedauth();
              }
            }
          }.bind(this), function(err) {
            this._emit('error', new RemoteStorage.DiscoveryError("Failed to contact storage server."));
          }.bind(this));
        },
        disconnect: function() {
          if (this.remote) {
            this.remote.configure({
              userAddress: null,
              href: null,
              storageApi: null,
              token: null,
              properties: null
            });
          }
          this._setGPD({
            get: this._pendingGPD('get'),
            put: this._pendingGPD('put'),
            delete: this._pendingGPD('delete')
          });
          var n = this._cleanups.length,
              i = 0;
          var oneDone = function() {
            i++;
            if (i >= n) {
              this._init();
              RemoteStorage.log('Done cleaning up, emitting disconnected and disconnect events');
              this._emit('disconnected');
            }
          }.bind(this);
          if (n > 0) {
            this._cleanups.forEach(function(cleanup) {
              var cleanupResult = cleanup(this);
              if (typeof(cleanup) === 'object' && typeof(cleanup.then) === 'function') {
                cleanupResult.then(oneDone);
              } else {
                oneDone();
              }
            }.bind(this));
          } else {
            oneDone();
          }
        },
        setBackend: function(what) {
          this.backend = what;
          if (this.localStorageAvailable()) {
            if (what) {
              localStorage['remotestorage:backend'] = what;
            } else {
              delete localStorage['remotestorage:backend'];
            }
          }
        },
        onChange: function(path, handler) {
          if (!this._pathHandlers.change[path]) {
            this._pathHandlers.change[path] = [];
          }
          this._pathHandlers.change[path].push(handler);
        },
        enableLog: function() {
          RemoteStorage.config.logging = true;
        },
        disableLog: function() {
          RemoteStorage.config.logging = false;
        },
        log: function() {
          RemoteStorage.log.apply(RemoteStorage, arguments);
        },
        setApiKeys: function(type, keys) {
          if (keys) {
            this.apiKeys[type] = keys;
          } else {
            delete this.apiKeys[type];
          }
          if (this.localStorageAvailable()) {
            localStorage['remotestorage:api-keys'] = JSON.stringify(this.apiKeys);
          }
        },
        _init: function() {
          var self = this,
              readyFired = false;
          function fireReady() {
            try {
              if (!readyFired) {
                self._emit('ready');
                readyFired = true;
              }
            } catch (e) {
              console.error("'ready' failed: ", e, e.stack);
              self._emit('error', e);
            }
          }
          this._loadFeatures(function(features) {
            this.log('[RemoteStorage] All features loaded');
            this.local = features.local && new features.local();
            if (this.local && this.remote) {
              this._setGPD(SyncedGetPutDelete, this);
              this._bindChange(this.local);
            } else if (this.remote) {
              this._setGPD(this.remote, this.remote);
            }
            if (this.remote) {
              this.remote.on('connected', function() {
                fireReady();
                self._emit('connected');
              });
              this.remote.on('not-connected', function() {
                fireReady();
                self._emit('not-connected');
              });
              if (this.remote.connected) {
                fireReady();
                self._emit('connected');
              }
              if (!this.hasFeature('Authorize')) {
                this.remote.stopWaitingForToken();
              }
            }
            this._collectCleanupFunctions();
            try {
              this._allLoaded = true;
              this._emit('features-loaded');
            } catch (exc) {
              logError(exc);
              this._emit('error', exc);
            }
            this._processPending();
          }.bind(this));
        },
        _collectCleanupFunctions: function() {
          for (var i = 0; i < this.features.length; i++) {
            var cleanup = this.features[i].cleanup;
            if (typeof(cleanup) === 'function') {
              this._cleanups.push(cleanup);
            }
          }
        },
        _loadFeatures: function(callback) {
          var featureList = ['WireClient', 'I18n', 'Dropbox', 'GoogleDrive', 'Access', 'Caching', 'Discover', 'Authorize', 'Widget', 'IndexedDB', 'LocalStorage', 'InMemoryStorage', 'Sync', 'BaseClient', 'Env'];
          var features = [];
          var featuresDone = 0;
          var self = this;
          function featureDone() {
            featuresDone++;
            if (featuresDone === featureList.length) {
              setTimeout(function() {
                features.caching = !!RemoteStorage.Caching;
                features.sync = !!RemoteStorage.Sync;
                ['IndexedDB', 'LocalStorage', 'InMemoryStorage'].some(function(cachingLayer) {
                  if (features.some(function(feature) {
                    return feature.name === cachingLayer;
                  })) {
                    features.local = RemoteStorage[cachingLayer];
                    return true;
                  }
                });
                self.features = features;
                callback(features);
              }, 0);
            }
          }
          function featureInitialized(name) {
            self.log("[RemoteStorage] [FEATURE " + name + "] initialized.");
            features.push({
              name: name,
              init: RemoteStorage[name]._rs_init,
              supported: true,
              cleanup: RemoteStorage[name]._rs_cleanup
            });
            featureDone();
          }
          function featureFailed(name, err) {
            self.log("[RemoteStorage] [FEATURE " + name + "] initialization failed ( " + err + ")");
            featureDone();
          }
          function featureSupported(name, success) {
            self.log("[RemoteStorage] [FEATURE " + name + "]" + success ? "" : " not" + " supported");
            if (!success) {
              featureDone();
            }
          }
          function initFeature(name) {
            var initResult;
            try {
              initResult = RemoteStorage[name]._rs_init(self);
            } catch (e) {
              featureFailed(name, e);
              return;
            }
            if (typeof(initResult) === 'object' && typeof(initResult.then) === 'function') {
              initResult.then(function() {
                featureInitialized(name);
              }, function(err) {
                featureFailed(name, err);
              });
            } else {
              featureInitialized(name);
            }
          }
          featureList.forEach(function(featureName) {
            self.log("[RemoteStorage] [FEATURE " + featureName + "] initializing...");
            var impl = RemoteStorage[featureName];
            var supported;
            if (impl) {
              supported = !impl._rs_supported || impl._rs_supported();
              if (typeof supported === 'object') {
                supported.then(function() {
                  featureSupported(featureName, true);
                  initFeature(featureName);
                }, function() {
                  featureSupported(featureName, false);
                });
              } else if (typeof supported === 'boolean') {
                featureSupported(featureName, supported);
                if (supported) {
                  initFeature(featureName);
                }
              }
            } else {
              featureSupported(featureName, false);
            }
          });
        },
        hasFeature: function(feature) {
          for (var i = this.features.length - 1; i >= 0; i--) {
            if (this.features[i].name === feature) {
              return this.features[i].supported;
            }
          }
          return false;
        },
        localStorageAvailable: function() {
          try {
            return !!global.localStorage;
          } catch (error) {
            return false;
          }
        },
        _setGPD: function(impl, context) {
          function wrap(func) {
            return function() {
              return func.apply(context, arguments).then(emitUnauthorized.bind(this));
            };
          }
          this.get = wrap(impl.get);
          this.put = wrap(impl.put);
          this.delete = wrap(impl.delete);
        },
        _pendingGPD: function(methodName) {
          return function() {
            var pending = Promise.defer();
            this._pending.push({
              method: methodName,
              args: Array.prototype.slice.call(arguments),
              promise: pending
            });
            return pending.promise;
          }.bind(this);
        },
        _processPending: function() {
          this._pending.forEach(function(pending) {
            try {
              this[pending.method].apply(this, pending.args).then(pending.promise.resolve, pending.promise.reject);
            } catch (e) {
              pending.promise.reject(e);
            }
          }.bind(this));
          this._pending = [];
        },
        _bindChange: function(object) {
          object.on('change', this._dispatchEvent.bind(this, 'change'));
        },
        _dispatchEvent: function(eventName, event) {
          var self = this;
          Object.keys(this._pathHandlers[eventName]).forEach(function(path) {
            var pl = path.length;
            if (event.path.substr(0, pl) === path) {
              self._pathHandlers[eventName][path].forEach(function(handler) {
                var ev = {};
                for (var key in event) {
                  ev[key] = event[key];
                }
                ev.relativePath = event.path.replace(new RegExp('^' + path), '');
                try {
                  handler(ev);
                } catch (e) {
                  console.error("'change' handler failed: ", e, e.stack);
                  self._emit('error', e);
                }
              });
            }
          });
        }
      };
      Object.defineProperty(RemoteStorage.prototype, 'connected', {get: function() {
          return this.remote.connected;
        }});
      if ((typeof module === 'object') && (typeof module.exports !== undefined)) {
        module.exports = RemoteStorage;
      } else {
        global.RemoteStorage = RemoteStorage;
      }
    })(typeof(window) !== 'undefined' ? window : global);
    (function() {
      function fixArrayBuffers(srcObj, dstObj) {
        var field,
            srcArr,
            dstArr;
        if (typeof(srcObj) !== 'object' || Array.isArray(srcObj) || srcObj === null) {
          return;
        }
        for (field in srcObj) {
          if (typeof(srcObj[field]) === 'object' && srcObj[field] !== null) {
            if (srcObj[field].toString() === '[object ArrayBuffer]') {
              dstObj[field] = new ArrayBuffer(srcObj[field].byteLength);
              srcArr = new Int8Array(srcObj[field]);
              dstArr = new Int8Array(dstObj[field]);
              dstArr.set(srcArr);
            } else {
              fixArrayBuffers(srcObj[field], dstObj[field]);
            }
          }
        }
      }
      RemoteStorage.util = {
        getEventEmitter: function() {
          var object = {};
          var args = Array.prototype.slice.call(arguments);
          args.unshift(object);
          RemoteStorage.eventHandling.apply(RemoteStorage, args);
          object.emit = object._emit;
          return object;
        },
        extend: function(target) {
          var sources = Array.prototype.slice.call(arguments, 1);
          sources.forEach(function(source) {
            for (var key in source) {
              target[key] = source[key];
            }
          });
          return target;
        },
        asyncEach: function(array, callback) {
          return this.asyncMap(array, callback).then(function() {
            return array;
          });
        },
        asyncMap: function(array, callback) {
          var pending = Promise.defer();
          var n = array.length,
              i = 0;
          var results = [],
              errors = [];
          function oneDone() {
            i++;
            if (i === n) {
              pending.resolve(results, errors);
            }
          }
          array.forEach(function(item, index) {
            var result;
            try {
              result = callback(item);
            } catch (exc) {
              oneDone();
              errors[index] = exc;
            }
            if (typeof(result) === 'object' && typeof(result.then) === 'function') {
              result.then(function(res) {
                results[index] = res;
                oneDone();
              }, function(error) {
                errors[index] = error;
                oneDone();
              });
            } else {
              oneDone();
              results[index] = result;
            }
          });
          return pending.promise;
        },
        containingFolder: function(path) {
          if (path === '') {
            return '/';
          }
          if (!path) {
            throw "Path not given!";
          }
          return path.replace(/\/+/g, '/').replace(/[^\/]+\/?$/, '');
        },
        isFolder: function(path) {
          return path.substr(-1) === '/';
        },
        isDocument: function(path) {
          return path.substr(-1) !== '/';
        },
        baseName: function(path) {
          var parts = path.split('/');
          if (this.isFolder(path)) {
            return parts[parts.length - 2] + '/';
          } else {
            return parts[parts.length - 1];
          }
        },
        cleanPath: function(path) {
          return path.replace(/\/+/g, '/').split('/').map(encodeURIComponent).join('/').replace(/'/g, '%27');
        },
        bindAll: function(object) {
          for (var key in this) {
            if (typeof(object[key]) === 'function') {
              object[key] = object[key].bind(object);
            }
          }
        },
        equal: function(a, b, seen) {
          var key;
          seen = seen || [];
          if (typeof(a) !== typeof(b)) {
            return false;
          }
          if (typeof(a) === 'number' || typeof(a) === 'boolean' || typeof(a) === 'string') {
            return a === b;
          }
          if (typeof(a) === 'function') {
            return a.toString() === b.toString();
          }
          if (a instanceof ArrayBuffer && b instanceof ArrayBuffer) {
            a = new Uint8Array(a);
            b = new Uint8Array(b);
          }
          if (a instanceof Array) {
            if (a.length !== b.length) {
              return false;
            }
            for (var i = 0,
                c = a.length; i < c; i++) {
              if (!RemoteStorage.util.equal(a[i], b[i], seen)) {
                return false;
              }
            }
          } else {
            for (key in a) {
              if (a.hasOwnProperty(key) && !(key in b)) {
                return false;
              }
            }
            for (key in b) {
              if (!b.hasOwnProperty(key)) {
                continue;
              }
              if (!(key in a)) {
                return false;
              }
              var seenArg;
              if (typeof(b[key]) === 'object') {
                if (seen.indexOf(b[key]) >= 0) {
                  continue;
                }
                seenArg = seen.slice();
                seenArg.push(b[key]);
              }
              if (!RemoteStorage.util.equal(a[key], b[key], seenArg)) {
                return false;
              }
            }
          }
          return true;
        },
        equalObj: function(obj1, obj2) {
          console.warn('DEPRECATION WARNING: RemoteStorage.util.equalObj has been replaced by RemoteStorage.util.equal.');
          return RemoteStorage.util.equal(obj1, obj2);
        },
        deepClone: function(obj) {
          var clone;
          if (obj === undefined) {
            return undefined;
          } else {
            clone = JSON.parse(JSON.stringify(obj));
            fixArrayBuffers(obj, clone);
            return clone;
          }
        },
        pathsFromRoot: function(path) {
          var paths = [path];
          var parts = path.replace(/\/$/, '').split('/');
          while (parts.length > 1) {
            parts.pop();
            paths.push(parts.join('/') + '/');
          }
          return paths;
        },
        md5sum: function(str) {
          function md5cycle(x, k) {
            var a = x[0],
                b = x[1],
                c = x[2],
                d = x[3];
            a = ff(a, b, c, d, k[0], 7, -680876936);
            d = ff(d, a, b, c, k[1], 12, -389564586);
            c = ff(c, d, a, b, k[2], 17, 606105819);
            b = ff(b, c, d, a, k[3], 22, -1044525330);
            a = ff(a, b, c, d, k[4], 7, -176418897);
            d = ff(d, a, b, c, k[5], 12, 1200080426);
            c = ff(c, d, a, b, k[6], 17, -1473231341);
            b = ff(b, c, d, a, k[7], 22, -45705983);
            a = ff(a, b, c, d, k[8], 7, 1770035416);
            d = ff(d, a, b, c, k[9], 12, -1958414417);
            c = ff(c, d, a, b, k[10], 17, -42063);
            b = ff(b, c, d, a, k[11], 22, -1990404162);
            a = ff(a, b, c, d, k[12], 7, 1804603682);
            d = ff(d, a, b, c, k[13], 12, -40341101);
            c = ff(c, d, a, b, k[14], 17, -1502002290);
            b = ff(b, c, d, a, k[15], 22, 1236535329);
            a = gg(a, b, c, d, k[1], 5, -165796510);
            d = gg(d, a, b, c, k[6], 9, -1069501632);
            c = gg(c, d, a, b, k[11], 14, 643717713);
            b = gg(b, c, d, a, k[0], 20, -373897302);
            a = gg(a, b, c, d, k[5], 5, -701558691);
            d = gg(d, a, b, c, k[10], 9, 38016083);
            c = gg(c, d, a, b, k[15], 14, -660478335);
            b = gg(b, c, d, a, k[4], 20, -405537848);
            a = gg(a, b, c, d, k[9], 5, 568446438);
            d = gg(d, a, b, c, k[14], 9, -1019803690);
            c = gg(c, d, a, b, k[3], 14, -187363961);
            b = gg(b, c, d, a, k[8], 20, 1163531501);
            a = gg(a, b, c, d, k[13], 5, -1444681467);
            d = gg(d, a, b, c, k[2], 9, -51403784);
            c = gg(c, d, a, b, k[7], 14, 1735328473);
            b = gg(b, c, d, a, k[12], 20, -1926607734);
            a = hh(a, b, c, d, k[5], 4, -378558);
            d = hh(d, a, b, c, k[8], 11, -2022574463);
            c = hh(c, d, a, b, k[11], 16, 1839030562);
            b = hh(b, c, d, a, k[14], 23, -35309556);
            a = hh(a, b, c, d, k[1], 4, -1530992060);
            d = hh(d, a, b, c, k[4], 11, 1272893353);
            c = hh(c, d, a, b, k[7], 16, -155497632);
            b = hh(b, c, d, a, k[10], 23, -1094730640);
            a = hh(a, b, c, d, k[13], 4, 681279174);
            d = hh(d, a, b, c, k[0], 11, -358537222);
            c = hh(c, d, a, b, k[3], 16, -722521979);
            b = hh(b, c, d, a, k[6], 23, 76029189);
            a = hh(a, b, c, d, k[9], 4, -640364487);
            d = hh(d, a, b, c, k[12], 11, -421815835);
            c = hh(c, d, a, b, k[15], 16, 530742520);
            b = hh(b, c, d, a, k[2], 23, -995338651);
            a = ii(a, b, c, d, k[0], 6, -198630844);
            d = ii(d, a, b, c, k[7], 10, 1126891415);
            c = ii(c, d, a, b, k[14], 15, -1416354905);
            b = ii(b, c, d, a, k[5], 21, -57434055);
            a = ii(a, b, c, d, k[12], 6, 1700485571);
            d = ii(d, a, b, c, k[3], 10, -1894986606);
            c = ii(c, d, a, b, k[10], 15, -1051523);
            b = ii(b, c, d, a, k[1], 21, -2054922799);
            a = ii(a, b, c, d, k[8], 6, 1873313359);
            d = ii(d, a, b, c, k[15], 10, -30611744);
            c = ii(c, d, a, b, k[6], 15, -1560198380);
            b = ii(b, c, d, a, k[13], 21, 1309151649);
            a = ii(a, b, c, d, k[4], 6, -145523070);
            d = ii(d, a, b, c, k[11], 10, -1120210379);
            c = ii(c, d, a, b, k[2], 15, 718787259);
            b = ii(b, c, d, a, k[9], 21, -343485551);
            x[0] = add32(a, x[0]);
            x[1] = add32(b, x[1]);
            x[2] = add32(c, x[2]);
            x[3] = add32(d, x[3]);
          }
          function cmn(q, a, b, x, s, t) {
            a = add32(add32(a, q), add32(x, t));
            return add32((a << s) | (a >>> (32 - s)), b);
          }
          function ff(a, b, c, d, x, s, t) {
            return cmn((b & c) | ((~b) & d), a, b, x, s, t);
          }
          function gg(a, b, c, d, x, s, t) {
            return cmn((b & d) | (c & (~d)), a, b, x, s, t);
          }
          function hh(a, b, c, d, x, s, t) {
            return cmn(b ^ c ^ d, a, b, x, s, t);
          }
          function ii(a, b, c, d, x, s, t) {
            return cmn(c ^ (b | (~d)), a, b, x, s, t);
          }
          function md51(s) {
            txt = '';
            var n = s.length,
                state = [1732584193, -271733879, -1732584194, 271733878],
                i;
            for (i = 64; i <= s.length; i += 64) {
              md5cycle(state, md5blk(s.substring(i - 64, i)));
            }
            s = s.substring(i - 64);
            var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (i = 0; i < s.length; i++)
              tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
            tail[i >> 2] |= 0x80 << ((i % 4) << 3);
            if (i > 55) {
              md5cycle(state, tail);
              for (i = 0; i < 16; i++)
                tail[i] = 0;
            }
            tail[14] = n * 8;
            md5cycle(state, tail);
            return state;
          }
          function md5blk(s) {
            var md5blks = [],
                i;
            for (i = 0; i < 64; i += 4) {
              md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
            }
            return md5blks;
          }
          var hex_chr = '0123456789abcdef'.split('');
          function rhex(n) {
            var s = '',
                j = 0;
            for (; j < 4; j++)
              s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
            return s;
          }
          function hex(x) {
            for (var i = 0; i < x.length; i++)
              x[i] = rhex(x[i]);
            return x.join('');
          }
          function md5(s) {
            return hex(md51(s));
          }
          var add32 = function(a, b) {
            return (a + b) & 0xFFFFFFFF;
          };
          if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {
            add32 = function(x, y) {
              var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                  msw = (x >> 16) + (y >> 16) + (lsw >> 16);
              return (msw << 16) | (lsw & 0xFFFF);
            };
          }
          return md5(str);
        }
      };
      if (!RemoteStorage.prototype.util) {
        Object.defineProperty(RemoteStorage.prototype, 'util', {get: function() {
            console.log('DEPRECATION WARNING: remoteStorage.util was moved to RemoteStorage.util');
            return RemoteStorage.util;
          }});
      }
    })();
    (function(global) {
      var methods = {
        addEventListener: function(eventName, handler) {
          if (typeof(eventName) !== 'string') {
            throw new Error('Argument eventName should be a string');
          }
          if (typeof(handler) !== 'function') {
            throw new Error('Argument handler should be a function');
          }
          RemoteStorage.log('[Eventhandling] Adding event listener', eventName, handler);
          this._validateEvent(eventName);
          this._handlers[eventName].push(handler);
        },
        removeEventListener: function(eventName, handler) {
          this._validateEvent(eventName);
          var hl = this._handlers[eventName].length;
          for (var i = 0; i < hl; i++) {
            if (this._handlers[eventName][i] === handler) {
              this._handlers[eventName].splice(i, 1);
              return;
            }
          }
        },
        _emit: function(eventName) {
          this._validateEvent(eventName);
          var args = Array.prototype.slice.call(arguments, 1);
          this._handlers[eventName].forEach(function(handler) {
            handler.apply(this, args);
          });
        },
        _validateEvent: function(eventName) {
          if (!(eventName in this._handlers)) {
            throw new Error("Unknown event: " + eventName);
          }
        },
        _delegateEvent: function(eventName, target) {
          target.on(eventName, function(event) {
            this._emit(eventName, event);
          }.bind(this));
        },
        _addEvent: function(eventName) {
          this._handlers[eventName] = [];
        }
      };
      methods.on = methods.addEventListener;
      RemoteStorage.eventHandling = function(object) {
        var eventNames = Array.prototype.slice.call(arguments, 1);
        for (var key in methods) {
          object[key] = methods[key];
        }
        object._handlers = {};
        eventNames.forEach(function(eventName) {
          object._addEvent(eventName);
        });
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var RS = RemoteStorage;
      var hasLocalStorage;
      var SETTINGS_KEY = 'remotestorage:wireclient';
      var API_2012 = 1,
          API_00 = 2,
          API_01 = 3,
          API_02 = 4,
          API_HEAD = 5;
      var STORAGE_APIS = {
        'draft-dejong-remotestorage-00': API_00,
        'draft-dejong-remotestorage-01': API_01,
        'draft-dejong-remotestorage-02': API_02,
        'https://www.w3.org/community/rww/wiki/read-write-web-00#simple': API_2012
      };
      var isArrayBufferView;
      if (typeof(ArrayBufferView) === 'function') {
        isArrayBufferView = function(object) {
          return object && (object instanceof ArrayBufferView);
        };
      } else {
        var arrayBufferViews = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        isArrayBufferView = function(object) {
          for (var i = 0; i < 8; i++) {
            if (object instanceof arrayBufferViews[i]) {
              return true;
            }
          }
          return false;
        };
      }
      var isFolder = RemoteStorage.util.isFolder;
      var cleanPath = RemoteStorage.util.cleanPath;
      function addQuotes(str) {
        if (typeof(str) !== 'string') {
          return str;
        }
        if (str === '*') {
          return '*';
        }
        return '"' + str + '"';
      }
      function stripQuotes(str) {
        if (typeof(str) !== 'string') {
          return str;
        }
        return str.replace(/^["']|["']$/g, '');
      }
      function readBinaryData(content, mimeType, callback) {
        var blob;
        global.BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder;
        if (typeof global.BlobBuilder !== 'undefined') {
          var bb = new global.BlobBuilder();
          bb.append(content);
          blob = bb.getBlob(mimeType);
        } else {
          blob = new Blob([content], {type: mimeType});
        }
        var reader = new FileReader();
        if (typeof reader.addEventListener === 'function') {
          reader.addEventListener('loadend', function() {
            callback(reader.result);
          });
        } else {
          reader.onloadend = function() {
            callback(reader.result);
          };
        }
        reader.readAsArrayBuffer(blob);
      }
      function getTextFromArrayBuffer(arrayBuffer, encoding) {
        var pending = Promise.defer();
        if (typeof Blob === 'undefined') {
          var buffer = new Buffer(new Uint8Array(arrayBuffer));
          pending.resolve(buffer.toString(encoding));
        } else {
          var blob;
          global.BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder;
          if (typeof global.BlobBuilder !== 'undefined') {
            var bb = new global.BlobBuilder();
            bb.append(arrayBuffer);
            blob = bb.getBlob();
          } else {
            blob = new Blob([arrayBuffer]);
          }
          var fileReader = new FileReader();
          if (typeof fileReader.addEventListener === 'function') {
            fileReader.addEventListener('loadend', function(evt) {
              pending.resolve(evt.target.result);
            });
          } else {
            fileReader.onloadend = function(evt) {
              pending.resolve(evt.target.result);
            };
          }
          fileReader.readAsText(blob, encoding);
        }
        return pending.promise;
      }
      function determineCharset(mimeType) {
        var charset = 'UTF-8';
        var charsetMatch;
        if (mimeType) {
          charsetMatch = mimeType.match(/charset=(.+)$/);
          if (charsetMatch) {
            charset = charsetMatch[1];
          }
        }
        return charset;
      }
      function isFolderDescription(body) {
        return ((body['@context'] === 'http://remotestorage.io/spec/folder-description') && (typeof(body['items']) === 'object'));
      }
      function isSuccessStatus(status) {
        return [201, 204, 304].indexOf(status) >= 0;
      }
      function isErrorStatus(status) {
        return [401, 403, 404, 412].indexOf(status) >= 0;
      }
      var onErrorCb;
      RS.WireClient = function(rs) {
        this.connected = false;
        RS.eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');
        onErrorCb = function(error) {
          if (error instanceof RemoteStorage.Unauthorized) {
            this.configure({token: null});
          }
        }.bind(this);
        rs.on('error', onErrorCb);
        if (hasLocalStorage) {
          var settings;
          try {
            settings = JSON.parse(localStorage[SETTINGS_KEY]);
          } catch (e) {}
          if (settings) {
            setTimeout(function() {
              this.configure(settings);
            }.bind(this), 0);
          }
        }
        this._revisionCache = {};
        if (this.connected) {
          setTimeout(this._emit.bind(this), 0, 'connected');
        }
      };
      RS.WireClient.REQUEST_TIMEOUT = 30000;
      RS.WireClient.prototype = {
        _request: function(method, uri, token, headers, body, getEtag, fakeRevision) {
          if ((method === 'PUT' || method === 'DELETE') && uri[uri.length - 1] === '/') {
            return Promise.reject('Don\'t ' + method + ' on directories!');
          }
          var revision;
          var reqType;
          var self = this;
          if (token !== RemoteStorage.Authorize.IMPLIED_FAKE_TOKEN) {
            headers['Authorization'] = 'Bearer ' + token;
          }
          this._emit('wire-busy', {
            method: method,
            isFolder: isFolder(uri)
          });
          return RS.WireClient.request(method, uri, {
            body: body,
            headers: headers,
            responseType: 'arraybuffer'
          }).then(function(response) {
            self._emit('wire-done', {
              method: method,
              isFolder: isFolder(uri),
              success: true
            });
            self.online = true;
            if (isErrorStatus(response.status)) {
              RemoteStorage.log('[WireClient] Error response status', response.status);
              if (getEtag) {
                revision = stripQuotes(response.getResponseHeader('ETag'));
              } else {
                revision = undefined;
              }
              return Promise.resolve({
                statusCode: response.status,
                revision: revision
              });
            } else if (isSuccessStatus(response.status) || (response.status === 200 && method !== 'GET')) {
              revision = stripQuotes(response.getResponseHeader('ETag'));
              RemoteStorage.log('[WireClient] Successful request', revision);
              return Promise.resolve({
                statusCode: response.status,
                revision: revision
              });
            } else {
              var mimeType = response.getResponseHeader('Content-Type');
              var body;
              if (getEtag) {
                revision = stripQuotes(response.getResponseHeader('ETag'));
              } else {
                revision = response.status === 200 ? fakeRevision : undefined;
              }
              var charset = determineCharset(mimeType);
              if ((!mimeType) || charset === 'binary') {
                RemoteStorage.log('[WireClient] Successful request with unknown or binary mime-type', revision);
                return Promise.resolve({
                  statusCode: response.status,
                  body: response.response,
                  contentType: mimeType,
                  revision: revision
                });
              } else {
                return getTextFromArrayBuffer(response.response, charset).then(function(body) {
                  RemoteStorage.log('[WireClient] Successful request', revision);
                  return Promise.resolve({
                    statusCode: response.status,
                    body: body,
                    contentType: mimeType,
                    revision: revision
                  });
                });
              }
            }
          }, function(error) {
            self._emit('wire-done', {
              method: method,
              isFolder: isFolder(uri),
              success: false
            });
            return Promise.reject(error);
          });
        },
        configure: function(settings) {
          if (typeof settings !== 'object') {
            throw new Error('WireClient configure settings parameter should be an object');
          }
          if (typeof settings.userAddress !== 'undefined') {
            this.userAddress = settings.userAddress;
          }
          if (typeof settings.href !== 'undefined') {
            this.href = settings.href;
          }
          if (typeof settings.storageApi !== 'undefined') {
            this.storageApi = settings.storageApi;
          }
          if (typeof settings.token !== 'undefined') {
            this.token = settings.token;
          }
          if (typeof settings.properties !== 'undefined') {
            this.properties = settings.properties;
          }
          if (typeof this.storageApi !== 'undefined') {
            this._storageApi = STORAGE_APIS[this.storageApi] || API_HEAD;
            this.supportsRevs = this._storageApi >= API_00;
          }
          if (this.href && this.token) {
            this.connected = true;
            this.online = true;
            this._emit('connected');
          } else {
            this.connected = false;
          }
          if (hasLocalStorage) {
            localStorage[SETTINGS_KEY] = JSON.stringify({
              userAddress: this.userAddress,
              href: this.href,
              storageApi: this.storageApi,
              token: this.token,
              properties: this.properties
            });
          }
        },
        stopWaitingForToken: function() {
          if (!this.connected) {
            this._emit('not-connected');
          }
        },
        get: function(path, options) {
          var self = this;
          if (!this.connected) {
            return Promise.reject('not connected (path: ' + path + ')');
          }
          if (!options) {
            options = {};
          }
          var headers = {};
          if (this.supportsRevs) {
            if (options.ifNoneMatch) {
              headers['If-None-Match'] = addQuotes(options.ifNoneMatch);
            }
          } else if (options.ifNoneMatch) {
            var oldRev = this._revisionCache[path];
          }
          return this._request('GET', this.href + cleanPath(path), this.token, headers, undefined, this.supportsRevs, this._revisionCache[path]).then(function(r) {
            if (!isFolder(path)) {
              return Promise.resolve(r);
            }
            var itemsMap = {};
            if (typeof(r.body) !== 'undefined') {
              try {
                r.body = JSON.parse(r.body);
              } catch (e) {
                return Promise.reject('Folder description at ' + self.href + cleanPath(path) + ' is not JSON');
              }
            }
            if (r.statusCode === 200 && typeof(r.body) === 'object') {
              if (Object.keys(r.body).length === 0) {
                r.statusCode = 404;
              } else if (isFolderDescription(r.body)) {
                for (var item in r.body.items) {
                  self._revisionCache[path + item] = r.body.items[item].ETag;
                }
                itemsMap = r.body.items;
              } else {
                Object.keys(r.body).forEach(function(key) {
                  self._revisionCache[path + key] = r.body[key];
                  itemsMap[key] = {'ETag': r.body[key]};
                });
              }
              r.body = itemsMap;
              return Promise.resolve(r);
            } else {
              return Promise.resolve(r);
            }
          });
        },
        put: function(path, body, contentType, options) {
          if (!this.connected) {
            return Promise.reject('not connected (path: ' + path + ')');
          }
          if (!options) {
            options = {};
          }
          if ((!contentType.match(/charset=/)) && (body instanceof ArrayBuffer || isArrayBufferView(body))) {
            contentType += '; charset=binary';
          }
          var headers = {'Content-Type': contentType};
          if (this.supportsRevs) {
            if (options.ifMatch) {
              headers['If-Match'] = addQuotes(options.ifMatch);
            }
            if (options.ifNoneMatch) {
              headers['If-None-Match'] = addQuotes(options.ifNoneMatch);
            }
          }
          return this._request('PUT', this.href + cleanPath(path), this.token, headers, body, this.supportsRevs);
        },
        'delete': function(path, options) {
          if (!this.connected) {
            throw new Error('not connected (path: ' + path + ')');
          }
          if (!options) {
            options = {};
          }
          var headers = {};
          if (this.supportsRevs) {
            if (options.ifMatch) {
              headers['If-Match'] = addQuotes(options.ifMatch);
            }
          }
          return this._request('DELETE', this.href + cleanPath(path), this.token, headers, undefined, this.supportsRevs);
        }
      };
      RS.WireClient.cleanPath = cleanPath;
      RS.WireClient.isArrayBufferView = isArrayBufferView;
      RS.WireClient.readBinaryData = readBinaryData;
      RS.WireClient.request = function(method, url, options) {
        var pending = Promise.defer();
        RemoteStorage.log('[WireClient]', method, url);
        var timedOut = false;
        var timer = setTimeout(function() {
          timedOut = true;
          pending.reject('timeout');
        }, RS.WireClient.REQUEST_TIMEOUT);
        var xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        if (options.headers) {
          for (var key in options.headers) {
            xhr.setRequestHeader(key, options.headers[key]);
          }
        }
        xhr.onload = function() {
          if (timedOut) {
            return;
          }
          clearTimeout(timer);
          pending.resolve(xhr);
        };
        xhr.onerror = function(error) {
          if (timedOut) {
            return;
          }
          clearTimeout(timer);
          pending.reject(error);
        };
        var body = options.body;
        if (typeof(body) === 'object' && !isArrayBufferView(body) && body instanceof ArrayBuffer) {
          body = new Uint8Array(body);
        }
        xhr.send(body);
        return pending.promise;
      };
      Object.defineProperty(RemoteStorage.WireClient.prototype, 'storageType', {get: function() {
          if (this.storageApi) {
            var spec = this.storageApi.match(/draft-dejong-(remotestorage-\d\d)/);
            return spec ? spec[1] : '2012.04';
          }
        }});
      RS.WireClient._rs_init = function(remoteStorage) {
        hasLocalStorage = remoteStorage.localStorageAvailable();
        remoteStorage.remote = new RS.WireClient(remoteStorage);
        this.online = true;
      };
      RS.WireClient._rs_supported = function() {
        return !!global.XMLHttpRequest;
      };
      RS.WireClient._rs_cleanup = function(remoteStorage) {
        if (hasLocalStorage) {
          delete localStorage[SETTINGS_KEY];
        }
        remoteStorage.removeEventListener('error', onErrorCb);
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var haveXMLHttpRequest,
          hasLocalStorage;
      var SETTINGS_KEY = 'remotestorage:discover';
      var cachedInfo = {};
      RemoteStorage.Discover = function(userAddress) {
        if (userAddress in cachedInfo) {
          return Promise.resolve(cachedInfo[userAddress]);
        }
        var webFinger = new WebFinger({
          tls_only: false,
          uri_fallback: true,
          request_timeout: 5000
        });
        var pending = Promise.defer();
        webFinger.lookup(userAddress, function(err, response) {
          if (err) {
            return pending.reject(err.message);
          } else if ((typeof response.idx.links.remotestorage !== 'object') || (typeof response.idx.links.remotestorage.length !== 'number') || (response.idx.links.remotestorage.length <= 0)) {
            RemoteStorage.log("[Discover] WebFinger record for " + userAddress + " does not have remotestorage defined in the links section ", JSON.stringify(response.json));
            return pending.reject("WebFinger record for " + userAddress + " does not have remotestorage defined in the links section.");
          }
          var rs = response.idx.links.remotestorage[0];
          var authURL = rs.properties['http://tools.ietf.org/html/rfc6749#section-4.2'] || rs.properties['auth-endpoint'];
          var storageType = rs.properties['http://remotestorage.io/spec/version'] || rs.type;
          cachedInfo[userAddress] = {
            href: rs.href,
            storageType: storageType,
            authURL: authURL,
            properties: rs.properties
          };
          if (hasLocalStorage) {
            localStorage[SETTINGS_KEY] = JSON.stringify({cache: cachedInfo});
          }
          return pending.resolve(cachedInfo[userAddress]);
        });
        return pending.promise;
      };
      RemoteStorage.Discover._rs_init = function(remoteStorage) {
        hasLocalStorage = remoteStorage.localStorageAvailable();
        if (hasLocalStorage) {
          var settings;
          try {
            settings = JSON.parse(localStorage[SETTINGS_KEY]);
          } catch (e) {}
          if (settings) {
            cachedInfo = settings.cache;
          }
        }
      };
      RemoteStorage.Discover._rs_supported = function() {
        haveXMLHttpRequest = !!global.XMLHttpRequest;
        return haveXMLHttpRequest;
      };
      RemoteStorage.Discover._rs_cleanup = function() {
        if (hasLocalStorage) {
          delete localStorage[SETTINGS_KEY];
        }
      };
    })(typeof(window) !== 'undefined' ? window : global);
    if (typeof XMLHttpRequest === 'undefined') {
      XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
    }
    (function(undefined) {
      var LINK_URI_MAPS = {
        'http://webfist.org/spec/rel': 'webfist',
        'http://webfinger.net/rel/avatar': 'avatar',
        'remotestorage': 'remotestorage',
        'remoteStorage': 'remotestorage',
        'http://www.packetizer.com/rel/share': 'share',
        'http://webfinger.net/rel/profile-page': 'profile',
        'me': 'profile',
        'vcard': 'vcard',
        'blog': 'blog',
        'http://packetizer.com/rel/blog': 'blog',
        'http://schemas.google.com/g/2010#updates-from': 'updates',
        'https://camlistore.org/rel/server': 'camilstore'
      };
      var LINK_PROPERTIES = {
        'avatar': [],
        'remotestorage': [],
        'blog': [],
        'vcard': [],
        'updates': [],
        'share': [],
        'profile': [],
        'webfist': [],
        'camilstore': []
      };
      var URIS = ['webfinger', 'host-meta', 'host-meta.json'];
      function _err(obj) {
        obj.toString = function() {
          return this.message;
        };
        return obj;
      }
      function WebFinger(config) {
        if (typeof config !== 'object') {
          config = {};
        }
        this.config = {
          tls_only: (typeof config.tls_only !== 'undefined') ? config.tls_only : true,
          webfist_fallback: (typeof config.webfist_fallback !== 'undefined') ? config.webfist_fallback : false,
          uri_fallback: (typeof config.uri_fallback !== 'undefined') ? config.uri_fallback : false,
          request_timeout: (typeof config.request_timeout !== 'undefined') ? config.request_timeout : 10000
        };
      }
      WebFinger.prototype._fetchJRD = function(url, cb) {
        var self = this;
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              if (self._isValidJSON(xhr.responseText)) {
                cb(null, xhr.responseText);
              } else {
                cb(_err({
                  message: 'invalid json',
                  url: url,
                  status: xhr.status
                }));
              }
            } else if (xhr.status === 404) {
              cb(_err({
                message: 'endpoint unreachable',
                url: url,
                status: xhr.status
              }));
            } else {
              cb(_err({
                message: 'error during request',
                url: url,
                status: xhr.status
              }));
            }
          }
        };
        xhr.open('GET', url, true);
        xhr.setRequestHeader('Accept', 'application/jrd+json, application/json');
        xhr.send();
      };
      WebFinger.prototype._isValidJSON = function(str) {
        try {
          JSON.parse(str);
        } catch (e) {
          return false;
        }
        return true;
      };
      WebFinger.prototype._isLocalhost = function(host) {
        var local = /^localhost(\.localdomain)?(\:[0-9]+)?$/;
        return local.test(host);
      };
      WebFinger.prototype._processJRD = function(JRD, cb) {
        var self = this;
        var parsedJRD = JSON.parse(JRD);
        if ((typeof parsedJRD !== 'object') || (typeof parsedJRD.links !== 'object')) {
          if (typeof parsedJRD.error !== 'undefined') {
            cb(_err({message: parsedJRD.error}));
          } else {
            cb(_err({message: 'unknown response from server'}));
          }
          return false;
        }
        var links = parsedJRD.links;
        var result = {
          object: parsedJRD,
          json: JRD,
          idx: {}
        };
        result.idx.properties = {'name': undefined};
        result.idx.links = JSON.parse(JSON.stringify(LINK_PROPERTIES));
        links.map(function(link, i) {
          if (LINK_URI_MAPS.hasOwnProperty(link.rel)) {
            if (result.idx.links[LINK_URI_MAPS[link.rel]]) {
              var entry = {};
              Object.keys(link).map(function(item, n) {
                entry[item] = link[item];
              });
              result.idx.links[LINK_URI_MAPS[link.rel]].push(entry);
            }
          }
        });
        var props = JSON.parse(JRD).properties;
        for (var key in props) {
          if (props.hasOwnProperty(key)) {
            if (key === 'http://packetizer.com/ns/name') {
              result.idx.properties.name = props[key];
            }
          }
        }
        cb(null, result);
      };
      WebFinger.prototype.lookup = function(address, cb) {
        if (typeof address !== 'string') {
          throw new Error('first parameter must be a user address');
        } else if (typeof cb !== 'function') {
          throw new Error('second parameter must be a callback');
        }
        var self = this;
        var parts = address.replace(/ /g, '').split('@');
        var host = parts[1];
        var uri_index = 0;
        var protocol = 'https';
        if (parts.length !== 2) {
          cb(_err({message: 'invalid user address ' + address + ' ( expected format: user@host.com )'}));
          return false;
        } else if (self._isLocalhost(host)) {
          protocol = 'http';
        }
        function _buildURL() {
          return protocol + '://' + host + '/.well-known/' + URIS[uri_index] + '?resource=acct:' + address;
        }
        function _fallbackChecks(err) {
          if ((self.config.uri_fallback) && (host !== 'webfist.org') && (uri_index !== URIS.length - 1)) {
            uri_index = uri_index + 1;
            _call();
          } else if ((!self.config.tls_only) && (protocol === 'https')) {
            uri_index = 0;
            protocol = 'http';
            _call();
          } else if ((self.config.webfist_fallback) && (host !== 'webfist.org')) {
            uri_index = 0;
            protocol = 'http';
            host = 'webfist.org';
            self._fetchJRD(_buildURL(), function(err, data) {
              if (err) {
                cb(err);
                return false;
              }
              self._processJRD(data, function(err, result) {
                if ((typeof result.idx.links.webfist === 'object') && (typeof result.idx.links.webfist[0].href === 'string')) {
                  self._fetchJRD(result.idx.links.webfist[0].href, function(err, JRD) {
                    if (err) {
                      cb(err);
                    } else {
                      self._processJRD(JRD, cb);
                    }
                  });
                }
              });
            });
          } else {
            cb(err);
            return false;
          }
        }
        function _call() {
          self._fetchJRD(_buildURL(), function(err, JRD) {
            if (err) {
              _fallbackChecks(err);
            } else {
              self._processJRD(JRD, cb);
            }
          });
        }
        setTimeout(_call, 0);
      };
      if (typeof window === 'object') {
        window.WebFinger = WebFinger;
      } else if (typeof(define) === 'function' && define.amd) {
        define([], function() {
          return WebFinger;
        });
      } else {
        try {
          module.exports = WebFinger;
        } catch (e) {}
      }
    })();
    (function(global) {
      function extractParams() {
        var location = RemoteStorage.Authorize.getLocation(),
            hashPos = location.href.indexOf('#'),
            hash;
        if (hashPos === -1) {
          return;
        }
        hash = location.href.substring(hashPos + 1);
        if (hash.indexOf('=') === -1) {
          return;
        }
        return hash.split('&').reduce(function(m, kvs) {
          var kv = kvs.split('=');
          m[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
          return m;
        }, {});
      }
      RemoteStorage.ImpliedAuth = function(storageApi, redirectUri) {
        RemoteStorage.log('ImpliedAuth proceeding due to absent authURL; storageApi = ' + storageApi + ' redirectUri = ' + redirectUri);
        remoteStorage.remote.configure({token: RemoteStorage.Authorize.IMPLIED_FAKE_TOKEN});
        document.location = redirectUri;
      };
      RemoteStorage.Authorize = function(authURL, scope, redirectUri, clientId) {
        RemoteStorage.log('[Authorize] authURL = ', authURL, 'scope = ', scope, 'redirectUri = ', redirectUri, 'clientId = ', clientId);
        var url = authURL,
            hashPos = redirectUri.indexOf('#');
        url += authURL.indexOf('?') > 0 ? '&' : '?';
        url += 'redirect_uri=' + encodeURIComponent(redirectUri.replace(/#.*$/, ''));
        url += '&scope=' + encodeURIComponent(scope);
        url += '&client_id=' + encodeURIComponent(clientId);
        if (hashPos !== -1) {
          url += '&state=' + encodeURIComponent(redirectUri.substring(hashPos + 1));
        }
        url += '&response_type=token';
        RemoteStorage.Authorize.setLocation(url);
      };
      RemoteStorage.Authorize.IMPLIED_FAKE_TOKEN = false;
      RemoteStorage.prototype.authorize = function(authURL) {
        this.access.setStorageType(this.remote.storageType);
        var scope = this.access.scopeParameter;
        var redirectUri = String(RemoteStorage.Authorize.getLocation());
        var clientId = redirectUri.match(/^(https?:\/\/[^\/]+)/)[0];
        RemoteStorage.Authorize(authURL, scope, redirectUri, clientId);
      };
      RemoteStorage.Authorize.getLocation = function() {
        return global.document.location;
      };
      RemoteStorage.Authorize.setLocation = function(location) {
        if (typeof location === 'string') {
          global.document.location.href = location;
        } else if (typeof location === 'object') {
          global.document.location = location;
        } else {
          throw "Invalid location " + location;
        }
      };
      RemoteStorage.prototype.impliedauth = function() {
        RemoteStorage.ImpliedAuth(this.remote.storageApi, String(document.location));
      };
      RemoteStorage.Authorize._rs_supported = function() {
        return typeof(document) !== 'undefined';
      };
      var onFeaturesLoaded;
      RemoteStorage.Authorize._rs_init = function(remoteStorage) {
        onFeaturesLoaded = function() {
          var authParamsUsed = false;
          if (params) {
            if (params.error) {
              throw "Authorization server errored: " + params.error;
            }
            if (params.access_token) {
              remoteStorage.remote.configure({token: params.access_token});
              authParamsUsed = true;
            }
            if (params.remotestorage) {
              remoteStorage.connect(params.remotestorage);
              authParamsUsed = true;
            }
            if (params.state) {
              RemoteStorage.Authorize.setLocation('#' + params.state);
            }
          }
          if (!authParamsUsed) {
            remoteStorage.remote.stopWaitingForToken();
          }
        };
        var params = extractParams(),
            location;
        if (params) {
          location = RemoteStorage.Authorize.getLocation();
          location.hash = '';
        }
        remoteStorage.on('features-loaded', onFeaturesLoaded);
      };
      RemoteStorage.Authorize._rs_cleanup = function(remoteStorage) {
        remoteStorage.removeEventListener('features-loaded', onFeaturesLoaded);
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var SETTINGS_KEY = "remotestorage:access";
      RemoteStorage.Access = function() {
        this.reset();
      };
      RemoteStorage.Access.prototype = {
        claim: function(scope, mode) {
          if (typeof(scope) !== 'string' || scope.indexOf('/') !== -1 || scope.length === 0) {
            throw new Error('Scope should be a non-empty string without forward slashes');
          }
          if (!mode.match(/^rw?$/)) {
            throw new Error('Mode should be either \'r\' or \'rw\'');
          }
          this._adjustRootPaths(scope);
          this.scopeModeMap[scope] = mode;
        },
        get: function(scope) {
          return this.scopeModeMap[scope];
        },
        remove: function(scope) {
          var savedMap = {};
          var name;
          for (name in this.scopeModeMap) {
            savedMap[name] = this.scopeModeMap[name];
          }
          this.reset();
          delete savedMap[scope];
          for (name in savedMap) {
            this.set(name, savedMap[name]);
          }
        },
        checkPermission: function(scope, mode) {
          var actualMode = this.get(scope);
          return actualMode && (mode === 'r' || actualMode === 'rw');
        },
        checkPathPermission: function(path, mode) {
          if (this.checkPermission('*', mode)) {
            return true;
          }
          return !!this.checkPermission(this._getModuleName(path), mode);
        },
        reset: function() {
          this.rootPaths = [];
          this.scopeModeMap = {};
        },
        _getModuleName: function(path) {
          if (path[0] !== '/') {
            throw new Error('Path should start with a slash');
          }
          var moduleMatch = path.replace(/^\/public/, '').match(/^\/([^\/]*)\//);
          return moduleMatch ? moduleMatch[1] : '*';
        },
        _adjustRootPaths: function(newScope) {
          if ('*' in this.scopeModeMap || newScope === '*') {
            this.rootPaths = ['/'];
          } else if (!(newScope in this.scopeModeMap)) {
            this.rootPaths.push('/' + newScope + '/');
            this.rootPaths.push('/public/' + newScope + '/');
          }
        },
        _scopeNameForParameter: function(scope) {
          if (scope.name === '*' && this.storageType) {
            if (this.storageType === '2012.04') {
              return '';
            } else if (this.storageType.match(/remotestorage-0[01]/)) {
              return 'root';
            }
          }
          return scope.name;
        },
        setStorageType: function(type) {
          this.storageType = type;
        }
      };
      Object.defineProperty(RemoteStorage.Access.prototype, 'scopes', {get: function() {
          return Object.keys(this.scopeModeMap).map(function(key) {
            return {
              name: key,
              mode: this.scopeModeMap[key]
            };
          }.bind(this));
        }});
      Object.defineProperty(RemoteStorage.Access.prototype, 'scopeParameter', {get: function() {
          return this.scopes.map(function(scope) {
            return this._scopeNameForParameter(scope) + ':' + scope.mode;
          }.bind(this)).join(' ');
        }});
      Object.defineProperty(RemoteStorage.prototype, 'access', {
        get: function() {
          var access = new RemoteStorage.Access();
          Object.defineProperty(this, 'access', {value: access});
          return access;
        },
        configurable: true
      });
      RemoteStorage.Access._rs_init = function() {};
    })(typeof(window) !== 'undefined' ? window : global);
    (function(pMode) {
      var mode = pMode,
          env = {},
          isBackground = false;
      RemoteStorage.Env = function() {
        return env;
      };
      RemoteStorage.Env.isBrowser = function() {
        return mode === "browser";
      };
      RemoteStorage.Env.isNode = function() {
        return mode === "node";
      };
      RemoteStorage.Env.goBackground = function() {
        isBackground = true;
        RemoteStorage.Env._emit("background");
      };
      RemoteStorage.Env.goForeground = function() {
        isBackground = false;
        RemoteStorage.Env._emit("foreground");
      };
      RemoteStorage.Env._rs_init = function(remoteStorage) {
        RemoteStorage.eventHandling(RemoteStorage.Env, "background", "foreground");
        function visibility() {
          if (document[env.hiddenProperty]) {
            RemoteStorage.Env.goBackground();
          } else {
            RemoteStorage.Env.goForeground();
          }
        }
        if (mode === 'browser') {
          if (typeof(document.hidden) !== "undefined") {
            env.hiddenProperty = "hidden";
            env.visibilityChangeEvent = "visibilitychange";
          } else if (typeof(document.mozHidden) !== "undefined") {
            env.hiddenProperty = "mozHidden";
            env.visibilityChangeEvent = "mozvisibilitychange";
          } else if (typeof(document.msHidden) !== "undefined") {
            env.hiddenProperty = "msHidden";
            env.visibilityChangeEvent = "msvisibilitychange";
          } else if (typeof(document.webkitHidden) !== "undefined") {
            env.hiddenProperty = "webkitHidden";
            env.visibilityChangeEvent = "webkitvisibilitychange";
          }
          document.addEventListener(env.visibilityChangeEvent, visibility, false);
          visibility();
        }
      };
      RemoteStorage.Env._rs_cleanup = function(remoteStorage) {};
    })(typeof(window) !== 'undefined' ? 'browser' : 'node');
    (function() {
      "use strict";
      var dictionary = {
        "view_info": 'This app allows you to use your own storage. <a href="http://remotestorage.io/" target="_blank">Learn more!</a>',
        "view_connect": "<strong>Connect</strong> remote storage",
        "view_connecting": "Connecting <strong>%s</strong>",
        "view_offline": "Offline",
        "view_error_occured": "Sorry! An error occured.",
        "view_invalid_key": "Wrong key!",
        "view_confirm_reset": "Are you sure you want to reset everything? This will clear your local data and reload the page.",
        "view_get_me_out": "Get me out of here!",
        "view_error_plz_report": 'If this problem persists, please <a href="http://remotestorage.io/community/" target="_blank">let us know</a>!',
        "view_unauthorized": "Unauthorized! Click here to reconnect."
      };
      RemoteStorage.I18n = {
        translate: function() {
          var str = arguments[0],
              params = Array.prototype.splice.call(arguments, 1);
          if (typeof dictionary[str] !== "string") {
            throw "Unknown translation string: " + str;
          } else {
            str = dictionary[str];
          }
          return (str.replace(/%s/g, function() {
            return params.shift();
          }));
        },
        getDictionary: function() {
          return dictionary;
        },
        setDictionary: function(newDictionary) {
          dictionary = newDictionary;
        }
      };
    })();
    RemoteStorage.Assets = {
      cipherIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTQiIHdpZHRoPSIyNS4xNzciIHZlcnNpb249IjEuMSIgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxwYXRoIGQ9Im0yNS4xNzcgNS41MzIzYy0wLjA1NjQtMC4xMTI5MS0wLjA1NjQtMC4yMjU4MS0wLjE2OTM2LTAuMzM4NzEtMC4xMTI5LTAuMTEyOS0wLjI4MjI1LTAuMTY5MzYtMC4zOTUxNi0wLjE2OTM2aC0xMS40MDNjLTAuNzMzLTIuODc5LTMuMzg2NC01LjAyNDItNi40OTEzLTUuMDI0Mi0zLjY2OTMgMC02LjcxNzcgMy4wNDg0LTYuNzE3NyA2LjcxNzcgMCAzLjcyNjMgMy4wNDg0IDYuNzE3MyA2LjcxNzcgNi43MTczIDMuMzMwNyAwIDYuMDQwMy0yLjQyNzQgNi42MDQ4LTUuNTg4N2gyLjU0MDN2My42Njk0YzAgMC4yODIyNiAwLjI4MjI2IDAuNTA4MDYgMC41NjQ1MiAwLjUwODA2aDEuNzVjMC4yODIyNiAwIDAuNTY0NTItMC4yMjU4IDAuNTY0NTItMC41MDgwNnYtMy42Njk0aDEuNDY3N3Y1LjY0NTJjMCAwLjI4MjI1IDAuMjI1OCAwLjUwODA2IDAuNTA4MDYgMC41MDgwNmgxLjgwNjRjMC4yODIyNiAwIDAuNTA4MDctMC4yMjU4MSAwLjU2NDUyLTAuNTA4MDZ2LTUuNjQ1MmgxLjUyNDJjMC4xMTI5MSAwIDAuMjgyMjYgMCAwLjM5NTE2LTAuMTEyOSAwLjExMjkxLTAuMTEyOSAwLjE2OTM2LTAuMjgyMjYgMC4xNjkzNi0wLjM5NTE2di0xLjgwNjR6bS0xOC40NTkgNS4wODA3Yy0yLjA4ODcgMC0zLjgzODctMS42OTM2LTMuODM4Ny0zLjgzODcgMC0yLjE0NTIgMS43NS0zLjgzODcgMy44Mzg3LTMuODM4NyAyLjE0NTIgMCAzLjgzODcgMS42OTM2IDMuODM4NyAzLjgzODcgMCAyLjE0NTItMS42OTM2IDMuODM4Ny0zLjgzODcgMy44Mzg3eiIgZmlsbD0iI2ZmZiIvPgo8L3N2Zz4K',
      connectIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAtMTAzNi40KSI+CiAgPHBhdGggZD0ibTEgMTA0Ny40di02aDd2LTRsNyA3LTcgN3YtNHoiIGZpbGw9IiNmZmYiLz4KIDwvZz4KPC9zdmc+Cg==',
      disconnectIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgdmVyc2lvbj0iMS4wIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxwYXRoIHN0eWxlPSJibG9jay1wcm9ncmVzc2lvbjp0Yjt0ZXh0LWluZGVudDowO2NvbG9yOiMwMDAwMDA7dGV4dC10cmFuc2Zvcm06bm9uZSIgZD0ibTguMDAwMSAwYy0wLjQ3MTQgMC0wLjk2MTAzIDAuNTQxOS0wLjk1IDF2NmMtMC4wMDc0NyAwLjUyODMxIDAuNDIxNjMgMSAwLjk1IDFzMC45NTc0Ny0wLjQ3MTY5IDAuOTUtMXYtNmMwLjAxNDYyMi0wLjYwNTEtMC40Nzg2LTEtMC45NS0xem0tMy4zNDM4IDIuNWMtMC4wODcxODYgMC4wMTkyOTQtMC4xNzE2MyAwLjA1MDk1OS0wLjI1IDAuMDkzNzUtMi45OTk1IDEuNTcxNS0zLjkxODQgNC43OTc5LTMuMTI1IDcuNDY4OCAwLjc5MzQgMi42NyAzLjI3OTkgNC45MzcgNi42ODc1IDQuOTM3IDMuMzU5MiAwIDUuODc3Mi0yLjE0OSA2LjcxOTItNC43ODEgMC44NDEtMi42MzIxLTAuMDU4LTUuODIzNC0zLjEyNS03LjU5NC0wLjQzNC0wLjI1MzYtMS4wNTktMC4wODk5LTEuMzEzIDAuMzQzNy0wLjI1MzYgMC40MzM2LTAuMDkgMS4wNTg5IDAuMzQ0IDEuMzEyNSAyLjM5MDggMS4zNzk4IDIuODgyNSAzLjQ5NDQgMi4yODEyIDUuMzc1LTAuNjAxMiAxLjg4MDYtMi4zNDQgMy40Mzc1LTQuOTA2MiAzLjQzNzUtMi41NzU5IDAtNC4yOTc2LTEuNjUwMi00Ljg3NS0zLjU5MzgtMC41Nzc2LTEuOTQzNS0wLjA0Ny00LjA0OCAyLjE4NzMtNS4yMTg3IDAuMzc4Ny0wLjIwNjMgMC41NzkxLTAuNjkyNSAwLjQ1NTgtMS4xMDU3LTAuMTIzMi0wLjQxMzMtMC41NTcyLTAuNzEwMy0wLjk4Ny0wLjY3NTUtMC4wMzEzLTAuMDAxNS0wLjA2MjYtMC4wMDE1LTAuMDkzOCAweiIgZmlsbD0iI2ZmZiIvPgo8L3N2Zz4K',
      dropbox: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QgPEBAhEOpfuQAABhZJREFUWMPVl31snVUdxz+/5/2577e3b7QbHaOD0nXshW4ZZkpGQmJYZkJUDAaZzCBGAxGd+pdZQsJIjCaKgFu09GWybIggm8yhMCsY92rcOkPHunbdtKOUbX36svX23uc+xz+eDsrWlztiNJzk5D7JPS+fc8739/2dA5+EsqJtyK18ZlCKbX9Lk6fd1uo5xbTVZmtwa4v35Np5Mry4TLYXCzAnyhsry2SwrmnokdnaTruq6i3e0lXl0tqQlkURCxwdDp9Th5p3+p9iS8afqk/VZq9kaZoDN8apdU3B1KFnmLde7AkezH0n3V0UQOJpz2hIsqEhLU+WOeAagmtCxISYBe1nVf4vfWrByYdSpyf3W9ziLapy6JgbAduAiBn2S1rCQBYODAQP7H01/zxby4JpAW5s8mproxypiRKNGIJrQNT8EMA1wTGEU8MBP/q7umPw0dSbAA3N3n3zI2yLG2oScPgbNYWICY4Be86o/le6g0W576bPXQWwcqvXdJ2t1idMsA1hJoCoCRfGYdOhwsa4TUWFrr7pGmDrzAiQCHfD//Xxwk/33Z/6HoA0tnhLXZ3XMoYqsy4PYs4M4Ohg6pB2ddqO+vR6BWL27AARXbBNiBjwh9Oqs+O8ukcT4eaopjLqGsJSCdSX29SX23x/lctXlzgE1zBAANxWIQuGxlWNACxr8WozJp0lljKsGXbA0qGu1GRBxsTUQRAGLgboIuQVvHI8S+f7eeK2TLsDSQd296rhPaeDm09+PdX/gQYqN3uZ+jh7ro+oRusKDdgmVEY1GqstSiOhdegCmoQAIoImIWTPYIHdXVlyBYhaVwLA70+rPz7fllvLi2W5KcPw9q3eS/VJ7kmYgm1A3BIWV5osq7IIlMLUQJOrAXQBXQtr1BR2d2XpOu8TtULR+gq2nQh+vv8rqUdnNaKGZm/9qnJpmp/U+fxCB5lYsaGFdTYAY9L3jmNj9F9S7OgKVh9/KNVelBVf8untv8TYSS8gbsrHyh8C2LqQtGE0z9CJYfVuUblgRZv3WGOJvJG0cF8/lWPNdo+O93xsHYoVuqkL/xzIs/HPHt2DPg0Zko+v0I8vbfHun9aKE5sH9YaobJsf5V4mRLXv33kSlmAYwspqgw23R7A1EJlahKYOSsHTB0cZHQ9IOBA3NSrjGo4hWAY82xH8rH1b/jF2laoPAOb80jPqYtKTMdRcTQNd+xAgbgmuJbiGELfh3lsc7q41KQSTABBcC1qPjLH/XzniNqScsP1kgMsm9nJ34e2mNcmFAMby1qFPZyz1WlxXrprhuEUgUPDbd8Y59n6edbe61KZ1TF14vSfPLw5dYjhXIOMIM6lGAV+u0+tv+ttI/2+6/LsMQVXpUFCAqJkS9MT5anB2NGDjWxf5Yp3DvjN5th/LUhETolaRTqigxMGIWVKtHVyX2tGTJd2X5agUIfi8CmvUFOKGT++gT8wqLlKUgnwATxwq7P32m35Z+32pPQZA54MpH1iSb/XWZmx2VthTD1AATCBlCZ+dpwNg6EJjlUH3hQIKRaCujhZFaOPtfUH+8HvBnQceSP11yjA8vC616+A5FevL8jt/YiCR0HiQcAUVrnDHHO0jHTUNllXrpC0NRXiefjAxM4rhHLzQpZqf+eFFd/LkM17JGlu9p+xC8IgPhGlaqE1rNJZrxOzQok0dnjviY+nhbSntCH3DAWN+QMIWEhYsqTD4wYHChrPfSP9kqnmM6QAMkYtz4xqmDqeGA+rLNObGZVozkglx1ZfqZAvC2ZGAz9RYlEbAlsLoNd+Kx5RqO5/njKXDsnKdhCXFOaFAZUzjznlhyt5xIjiSLbBz2oVO98fRdalOoGZ5m/dUQ4pvJZ3Zr/CXlS5A74gabzlYePztr6U2faxr+eRy/RYvtjgjHauvkxvi9oTDXaGBuAUJWyh1hb3vqsOvfiG5/L/yMAE483BqdNeuXO3LvcGX3vEUhsZVsaYL9IzACz3BXcVOXvQOfKRsupBZv8R4bnW19rmqGPzqHz4BcMGn5U/Hgod5oiT3P3kvVj7rrfnx/pHBu7d7Azc1eY3/l0drzWbPXNjsGXySy38AbtMqneWU7BkAAAAASUVORK5CYII=',
      googledrive: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QgPEA85ztzJcQAABZVJREFUWMPtl1uoXVcVhr8x5tprn7M1NG1i0pQqSG2jLcXipYJXjPogqFgpaHMSFUkpIjU+leKbDxIQSiHgjZgmrfXgQ6SKj5Ji7YVS05aUUqKQlNLQeDnN5Zzk9Jy99xy/D3OttU/StDlV33TBZM3FXmuMf/5jjv+fG/7XL1vti9tnv3Dtnnf+87JY8YmZNxEMM1sZ7tWpjz764mriVqvKvmfb1ONLy3+dGyWu6EWbvQwoydv5BMSqFuereakmfnls1GP25IDaBGYYjplhljDz5tk7YMtPfurAf6UE9Z6tNwDPAPXwtcxL1x9n4zRgDjjm1gCyC6JpCLoW/OX65of1nzCwG6gNo3aYeXF981mTvK2/WWFiMmoj7X+z5JcE0N87c4e7b3EvyTwZT5/r8ezZHu6GuWGpSegJ8/ZeBu6fHv35s1/7t0rQv29mjWF/ATZ1L4bQwohrpkYc/sBpwhJYAVdKYECzYAESIk4Am3sf+sPCW2LAzb9jbpvMDXfD3fEqkRIcGdbsevlt9LylPYG1K6/K3QzK75uAr78lBgb3b7sc2cl2Uaa21sDiGMvB2iQeu/EMm6bKHjD3SUsCEChnpEAKiLisd/PB+UsyMPjZNwzzh1ixcnOfsFCX51NU/PTvA6pkTUdYw4R3zyu1ArMDqyvBQB82+FiJUQJ4C8YgVT1SSvSTs+vEmkcwe7qEsUnt233Aij0BW4ZPbfngKpRQs7hXpYQNvRiuEtATWOW4bLi+z04pJbCnBAkBJggBQlIBIZCUJM0Cm9+QgcED2+/G7BprdMZaAFZExm1FWcz+NLdj32G/6XfPCB5GoJKp7H5FARHRtgRI1y0/+cm7Lwpg+v7t64DvNd5S2mqirKXHy6RoArp1Ykrc2hKtKCtXlNEyoQ6Ydi498fF1F2FAdwEbV9UnZne+8q19Z7o63vTb+TPnRneeWxwxHGdyziii6wApQNEydKUUd5wHYGrftvci7tKKLSME5bvCaruynI9rNL7vdZgiHhiP898Wl8bMnxty+uyIhcURo1FgjSg1DCDph4uPfuR9AFbvvS25p2cxbiyKVuh2o1O44n2lLLacb5v75v5fX6yl5h753IwUD+YcRAQ5B6FMMhj0jboSRhnAE258wvp7Z7aYcbCYCeCGt97ubfICLDP/q4WZ32x7M20fPfb+hxbH9ZdjHOQIIoR74EDywA3coa6MqtJnrP+LmRmcB63ob8dA1wllRm95LVc//22S16TGeKqqpqoHk10ESGJj/zjjgIhAISKCyJmcY6Uu8Pbq7C0V6ABh35dzvYWQG0QAhmSYCaUlNhzdCrlX2jpE6tV4b9DYcGFKEgG8svQucoicC4CsII8zeTxutAEQzx1duPL3vrxjdlnou0SDLdTulxJQmalXNzN98jpEJiSo+qTeoEnsnWC5lVZNRhkOZiq0G8XCmz1gpp3j/ZYdYLhj9qCkn3fJQ4QKeh9OccWxz6O0hGKM9wakeoBEZ1BmqfOMyYFk4gXS+edG4J4ju6/644VK+AOJhSIYpVRBpn/qPVRL65A51dRavJoG2UQkOqf0hgVrGG7u6syoJDObB+55nRANb589Afy40W0UwkY91h39CiLweg1UU+W3ohLNvC2VurJ1htR6A3QaYPCjI7uvOvGGOlfv2XoSuBzEhmNfZXDqBrweUPVqUlWodneSG+6J1NTevThfDpEjmnsmzuuCPPfCvRvfcakT0S2Aeq9tYPr0ZryeBvOOlZBKUIEiCAVZwTgy41x6v6hm0LFZ4o7N7IuXPA+EDx+XjQ+tP/4lUrW2vCI1ydR0iYgmWdtu4yzG7bOiAdn8iYlA0iFJh1Z1JJv+ye2b3n1419XRH2riP0aqqlKClABIjUMW+rtSlw5qmCpgsynnl56/d+M/+P91wfUvQjDgTzx9h9AAAAAASUVORK5CYII=',
      nocipherIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPgogPHBhdGggZD0ibSAxMy4yMDMxMjQsMTEuNzczNDM4IGMgMC4yODEyNSwwLjI4MTI1IDAuNDIxODc1LDAuNjA5Mzc1IDAuNDIxODc1LDEuMDMxMjUgMCwwLjM3NSAtMC4xNDA2MjUsMC43NSAtMC40MjE4NzUsMS4wMzEyNSAtMC4yODEyNSwwLjIzNDM3NSAtMC42MDkzNzUsMC4zNzUgLTEuMDMxMjUsMC4zNzUgLTAuMzc1LDAgLTAuNzUsLTAuMTQwNjI1IC0xLjAzMTI1LC0wLjM3NSAwLDAgLTMuMTg3NDk4MSwtMy42NTYyNSAtMy4xODc0OTgxLC0zLjY1NjI1IDAsMCAtMy4xNDA2MjUsMy42NTYyNSAtMy4xNDA2MjUsMy42NTYyNSAtMC4yODEyNSwwLjIzNDM3NSAtMC42NTYyNSwwLjM3NSAtMS4wMzEyNSwwLjM3NSAtMC40MjE4NzUsMCAtMC43NSwtMC4xNDA2MjUgLTEuMDMxMjUsLTAuMzc1IC0wLjI4MTI1LC0wLjI4MTI1IC0wLjM3NSwtMC42NTYyNSAtMC4zNzUsLTEuMDMxMjUgMCwtMC40MjE4NzUgMC4wOTM3NSwtMC43NSAwLjM3NSwtMS4wMzEyNSAwLDAgMy4zMjgxMjUsLTMuNzUwMDAwNSAzLjMyODEyNSwtMy43NTAwMDA1IDAsMCAtMy4zMjgxMjUsLTMuNzk2ODc1IC0zLjMyODEyNSwtMy43OTY4NzUgLTAuMjgxMjUsLTAuMjgxMjUgLTAuMzc1LC0wLjYwOTM3NSAtMC4zNzUsLTEuMDMxMjUgMCwtMC4zNzUgMC4wOTM3NSwtMC43NSAwLjM3NSwtMS4wMzEyNSAwLjI4MTI1LC0wLjIzNDM3NSAwLjYwOTM3NSwtMC4zNzUgMS4wMzEyNSwtMC4zNzUgMC4zNzUsMCAwLjc1LDAuMTQwNjI1IDEuMDMxMjUsMC4zNzUgMCwwIDMuMTQwNjI1LDMuNjU2MjUgMy4xNDA2MjUsMy42NTYyNSAwLDAgMy4xODc0OTgxLC0zLjY1NjI1IDMuMTg3NDk4MSwtMy42NTYyNSAwLjI4MTI1LC0wLjIzNDM3NSAwLjY1NjI1LC0wLjM3NSAxLjAzMTI1LC0wLjM3NSAwLjQyMTg3NSwwIDAuNzUsMC4xNDA2MjUgMS4wMzEyNSwwLjM3NSAwLjI4MTI1LDAuMjgxMjUgMC40MjE4NzUsMC42NTYyNSAwLjQyMTg3NSwxLjAzMTI1IDAsMC40MjE4NzUgLTAuMTQwNjI1LDAuNzUgLTAuNDIxODc1LDEuMDMxMjUgMCwwIC0zLjMyODEyMzEsMy43OTY4NzUgLTMuMzI4MTIzMSwzLjc5Njg3NSAwLDAgMy4zMjgxMjMxLDMuNzUwMDAwNSAzLjMyODEyMzEsMy43NTAwMDA1IiBmaWxsPSIjZmZmIi8+Cjwvc3ZnPgo=',
      remoteStorageIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMzIiIHdpZHRoPSIzMiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxkZWZzPgogIDxyYWRpYWxHcmFkaWVudCBpZD0iYSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGN5PSI1NzEuNDIiIGN4PSIxMDQ2LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE0NDMzIDAgMCAuMTY2NjcgMTIwMS41IDg3Ny4xMSkiIHI9Ijk2Ij4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2ZmNGEwNCIgc3RvcC1vcGFjaXR5PSIuNzYxNTQiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjZmY0YTA0IiBvZmZzZXQ9IjEiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogPC9kZWZzPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzMzYuNiAtOTU2LjM1KSI+CiAgPHBhdGggc3R5bGU9ImNvbG9yOiMwMDAwMDAiIGQ9Im0xMzUyLjYgOTU2LjM1IDAuMjg4NiAxNS4xMzYgMTMuNTY3LTcuMTM1Mi0xMy44NTUtOC4wMDExemwtMTMuODU1IDguMDAxMSAxMy41NjcgNy4xMzUyIDAuMjg4Ny0xNS4xMzZ6bS0xMy44NTUgOC4wMDExdjE1Ljk5OGwxMi45NTgtNy44MTYyLTEyLjk1OC04LjE4MTV6bTAgMTUuOTk4IDEzLjg1NSA4LjAwMTEtMC42MDg5LTE1LjMxNy0xMy4yNDYgNy4zMTU2em0xMy44NTUgOC4wMDExIDEzLjg1NS04LjAwMTEtMTMuMjUxLTcuMzE1Ni0wLjYwNDQgMTUuMzE3em0xMy44NTUtOC4wMDExdi0xNS45OThsLTEyLjk2MiA4LjE4MTUgMTIuOTYyIDcuODE2MnoiIGZpbGw9InVybCgjYSkiLz4KIDwvZz4KPC9zdmc+Cg==',
      remoteStorageIconCiphered: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMzIiIHdpZHRoPSIzMiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxkZWZzPgogIDxyYWRpYWxHcmFkaWVudCBpZD0iYSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGN5PSI1NzEuNDIiIGN4PSIxMDQ2LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE0NDMzIDAgMCAuMTY2NjcgMTIwMS41IDg3Ny4xMSkiIHI9Ijk2Ij4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2ZmNGEwNCIgc3RvcC1vcGFjaXR5PSIuNzYxNTQiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjZmY0YTA0IiBvZmZzZXQ9IjEiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogPC9kZWZzPgogPHBhdGggc3R5bGU9ImNvbG9yOiMwMDAwMDAiIGQ9Im0xNiAwbDAuMTI1IDYuMzc1YzIuMDk4IDAuMDY3IDMuNzUgMS43NTk1IDMuNzUgMy44NzV2MS45NjloMS45MzcgMC4wMzJsOC00LjIxOS0xMy44NDQtOHpsLTEzLjg0NCA4IDggNC4yMTloMC4wMzIgMS45MDZ2LTEuOTY5YzAtMi4xMTU1IDEuNjgzLTMuODA4IDMuNzgxLTMuODc1bDAuMTI1LTYuMzc1em0tMTMuODQ0IDh2MTZsNy45OTk4LTQuODQ0di02LjA5NGwtNy45OTk4LTUuMDYyem0wIDE2bDEzLjg0NCA4LTAuMzc1LTEwLjA2MmgtNS40Njl2LTIuMzQ0bC03Ljk5OTggNC40MDZ6bTEzLjg0NCA4bDEzLjg0NC04LTgtNC40MDZ2Mi4zNDRoLTUuNDY5bC0wLjM3NSAxMC4wNjJ6bTEzLjg0NC04di0xNmwtOCA1LjA2MnY2LjA5NGw4IDQuODQ0em0tMTMuOTY5LTE3Yy0xLjczNSAwLjA2NjYtMy4xMjUgMS40OTg3LTMuMTI1IDMuMjV2MS45NjloMy4wMzFsMC4wOTQtNS4yMTl6bTAuMjUgMGwwLjA5NCA1LjIxOWgzLjAzMXYtMS45NjljMC0xLjc1MTMtMS4zOS0zLjE4MzQtMy4xMjUtMy4yNXptLTQuNzUgNS44NDRsNC4zNDQgMi4yODEgMC4wMzEtMi4yODFoLTQuMzc1em00Ljg3NSAwbDAuMDMxIDIuMjgxIDQuMzQ0LTIuMjgxaC00LjM3NXptLTUuNDM4IDAuNjI1djUuMzEybDQuMjgyLTIuNTkzLTQuMjgyLTIuNzE5em0xMC4zNzYgMGwtNC4yODIgMi43MTkgNC4yODIgMi41OTN2LTUuMzEyem0tNS43ODIgMy4yMTlsLTQuNTk0IDIuNTMxdjIuMDYyaDQuNzgybC0wLjE4OC00LjU5M3ptMS4xODggMGwtMC4xODggNC41OTNoNC43ODJ2LTIuMDYybC00LjU5NC0yLjUzMXoiIGZpbGw9InVybCgjYSkiLz4KPC9zdmc+Cg==',
      remoteStorageIconError: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMzIiIHdpZHRoPSIzMiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxkZWZzPgogIDxyYWRpYWxHcmFkaWVudCBpZD0iYSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGN5PSI1NzEuNDIiIGN4PSIxMDQ2LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE0NDMzIDAgMCAuMTY2NjcgMTIwMS41IDg3Ny4xMSkiIHI9Ijk2Ij4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2U5MDAwMCIgc3RvcC1vcGFjaXR5PSIuNzYwNzgiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjZTkwMDAwIiBvZmZzZXQ9IjEiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogPC9kZWZzPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzMzYuNiAtOTU2LjM1KSI+CiAgPHBhdGggc3R5bGU9ImNvbG9yOiMwMDAwMDAiIGQ9Im0xMzUyLjYgOTU2LjM1IDAuMjg4NiAxNS4xMzYgMTMuNTY3LTcuMTM1Mi0xMy44NTUtOC4wMDExemwtMTMuODU1IDguMDAxMSAxMy41NjcgNy4xMzUyIDAuMjg4Ny0xNS4xMzZ6bS0xMy44NTUgOC4wMDExdjE1Ljk5OGwxMi45NTgtNy44MTYyLTEyLjk1OC04LjE4MTV6bTAgMTUuOTk4IDEzLjg1NSA4LjAwMTEtMC42MDg5LTE1LjMxNy0xMy4yNDYgNy4zMTU2em0xMy44NTUgOC4wMDExIDEzLjg1NS04LjAwMTEtMTMuMjUxLTcuMzE1Ni0wLjYwNDQgMTUuMzE3em0xMy44NTUtOC4wMDExdi0xNS45OThsLTEyLjk2MiA4LjE4MTUgMTIuOTYyIDcuODE2MnoiIGZpbGw9InVybCgjYSkiLz4KIDwvZz4KPC9zdmc+Cg==',
      remoteStorageIconOffline: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMzIiIHdpZHRoPSIzMiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxkZWZzPgogIDxyYWRpYWxHcmFkaWVudCBpZD0iYSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGN5PSI1NzEuNDIiIGN4PSIxMDQ2LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE0NDMzIDAgMCAuMTY2NjcgMTIwMS41IDg3Ny4xMSkiIHI9Ijk2Ij4KICAgPHN0b3Agc3RvcC1jb2xvcj0iIzY5Njk2OSIgc3RvcC1vcGFjaXR5PSIuNzYxNTQiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjNjc2NzY3IiBvZmZzZXQ9IjEiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogPC9kZWZzPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzMzYuNiAtOTU2LjM1KSI+CiAgPHBhdGggc3R5bGU9ImNvbG9yOiMwMDAwMDAiIGQ9Im0xMzUyLjYgOTU2LjM1IDAuMjg4NiAxNS4xMzYgMTMuNTY3LTcuMTM1Mi0xMy44NTUtOC4wMDExemwtMTMuODU1IDguMDAxMSAxMy41NjcgNy4xMzUyIDAuMjg4Ny0xNS4xMzZ6bS0xMy44NTUgOC4wMDExdjE1Ljk5OGwxMi45NTgtNy44MTYyLTEyLjk1OC04LjE4MTV6bTAgMTUuOTk4IDEzLjg1NSA4LjAwMTEtMC42MDg5LTE1LjMxNy0xMy4yNDYgNy4zMTU2em0xMy44NTUgOC4wMDExIDEzLjg1NS04LjAwMTEtMTMuMjUxLTcuMzE1Ni0wLjYwNDQgMTUuMzE3em0xMy44NTUtOC4wMDExdi0xNS45OThsLTEyLjk2MiA4LjE4MTUgMTIuOTYyIDcuODE2MnoiIGZpbGw9InVybCgjYSkiLz4KIDwvZz4KPC9zdmc+Cg==',
      syncIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDg3LjUgMTAwIiB4bWw6c3BhY2U9InByZXNlcnZlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTUuOTk5OTk5IDE2IiB3aWR0aD0iMTYiIHZlcnNpb249IjEuMSIgeT0iMHB4IiB4PSIwcHgiIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01LjUxMTIgLTc2LjUyNSkiIGRpc3BsYXk9Im5vbmUiPgoJPHBhdGggZGlzcGxheT0iaW5saW5lIiBkPSJtNTEuNDczIDQyLjI1NS0yLjIwNSAyLjIxMmMxLjQ3OCAxLjQ3NyAyLjI5NSAzLjQ0MiAyLjI5NSA1LjUzMyAwIDQuMzA5LTMuNTA0IDcuODEyLTcuODEyIDcuODEydi0xLjU2MmwtMy4xMjUgMy4xMjUgMy4xMjQgMy4xMjV2LTEuNTYyYzYuMDI5IDAgMTAuOTM4LTQuOTA2IDEwLjkzOC0xMC45MzggMC0yLjkyNy0xLjE0MS01LjY3Ni0zLjIxNS03Ljc0NXoiLz4KCTxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0ibTQ2Ljg3NSA0MC42MjUtMy4xMjUtMy4xMjV2MS41NjJjLTYuMDMgMC0xMC45MzggNC45MDctMTAuOTM4IDEwLjkzOCAwIDIuOTI3IDEuMTQxIDUuNjc2IDMuMjE3IDcuNzQ1bDIuMjAzLTIuMjEyYy0xLjQ3Ny0xLjQ3OS0yLjI5NC0zLjQ0Mi0yLjI5NC01LjUzMyAwLTQuMzA5IDMuNTA0LTcuODEyIDcuODEyLTcuODEydjEuNTYybDMuMTI1LTMuMTI1eiIvPgo8L2c+CjxwYXRoIGZpbGw9IiNmZmYiIGQ9Im0xMCAwbC0wLjc1IDEuOTA2MmMtMS4wMDc4LTAuMjk0Mi0zLjQ1ODYtMC43NzA4LTUuNjU2MiAwLjkzNzYgMC0wLjAwMDItMy45MzAyIDIuNTk0MS0yLjA5MzggNy41OTQybDEuNjU2Mi0wLjcxOTJzLTEuNTM5OS0zLjExMjIgMS42ODc2LTUuNTMxM2MwIDAgMS42OTU3LTEuMTMzOSAzLjY4NzQtMC41OTM3bC0wLjcxODcgMS44MTI0IDMuODEyNS0xLjYyNS0xLjYyNS0zLjc4MTJ6Ii8+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTE0IDUuNTYyNWwtMS42NTYgMC43MTg3czEuNTQxIDMuMTEzNS0xLjY4OCA1LjUzMDhjMCAwLTEuNzI3MiAxLjEzNS0zLjcxODUgMC41OTRsMC43NS0xLjgxMi0zLjgxMjUgMS41OTQgMS41OTM4IDMuODEyIDAuNzgxMi0xLjkwNmMxLjAxMTMgMC4yOTUgMy40NjE1IDAuNzY2IDUuNjU2LTAuOTM4IDAgMCAzLjkyOC0yLjU5NCAyLjA5NC03LjU5MzV6Ii8+Cjwvc3ZnPgo=',
      widget: '<div class="rs-bubble rs-hidden">   <div class="rs-bubble-text remotestorage-initial remotestorage-error remotestorage-authing remotestorage-offline">     <span class="rs-status-text">{{view_connect}}</span>   </div>   <div class="rs-bubble-expandable">     <!-- error -->     <div class="remotestorage-error">       <pre class="rs-status-text rs-error-msg">{{ERROR_MSG}}</pre>       <button class="remotestorage-reset">{{view_get_me_out}}</button>       <p class="rs-centered-text rs-error-plz-report">{{view_error_plz_report}}</p>     </div>     <!-- connected -->     <div class="rs-bubble-text remotestorage-connected">       <strong class="userAddress">{{USER_ADDRESS}}</strong>       <p class="remotestorage-unauthorized">{{view_unauthorized}}</p>       <p class="remotestorage-invalid-key">{{view_invalid_key}}</p>       <form novalidate class="remotestorage-cipher-form">         <input placeholder="Secret key" name="userSecretKey" novalidate>         <button class="rs-cipher" name="rs-cipher" title="cipher" disabled="disabled">           <img>         </button>         <button class="rs-nocipher" name="rs-nocipher" title="no cipher">           <img>         </button>       </form>     </div>     <div class="rs-content remotestorage-connected">       <button class="rs-sync" title="sync"><img></button>       <button class="rs-disconnect" title="disconnect"><img></button>     </div>     <!-- initial -->     <form novalidate class="remotestorage-initial">       <input type="email" placeholder="user@provider.com" name="userAddress" novalidate>       <button class="connect" name="connect" title="connect" disabled="disabled">         <img>       </button>     </form>     <div class="rs-info-msg remotestorage-initial">{{view_info}}</div>   </div> </div> <img class="rs-dropbox rs-backends rs-action" alt="Connect to Dropbox"> <img class="rs-googledrive rs-backends rs-action" alt="Connect to Google Drive"> <img class="rs-cube rs-action"> ',
      widgetCss: '/** encoding:utf-8 **/ /* RESET */ #remotestorage-widget{text-align:left;}#remotestorage-widget input, #remotestorage-widget button{font-size:11px;}#remotestorage-widget form input[type=email]{margin-bottom:0;/* HTML5 Boilerplate */}#remotestorage-widget form input[type=submit]{margin-top:0;/* HTML5 Boilerplate */}/* /RESET */ #remotestorage-widget, #remotestorage-widget *{-moz-box-sizing:border-box;box-sizing:border-box;}#remotestorage-widget{position:absolute;right:10px;top:10px;font:normal 16px/100% sans-serif !important;user-select:none;-webkit-user-select:none;-moz-user-select:-moz-none;cursor:default;z-index:10000;}#remotestorage-widget .rs-bubble{background:rgba(80, 80, 80, .7);border-radius:5px 15px 5px 5px;color:white;font-size:0.8em;padding:5px;position:absolute;right:3px;top:9px;min-height:24px;white-space:nowrap;text-decoration:none;}.rs-bubble .rs-bubble-text{padding-right:32px;/* make sure the bubble doesn\'t "jump" when initially opening. */ min-width:182px;}#remotestorage-widget .rs-action{cursor:pointer;}/* less obtrusive cube when connected */ #remotestorage-widget.remotestorage-state-connected .rs-cube, #remotestorage-widget.remotestorage-state-busy .rs-cube{opacity:.3;-webkit-transition:opacity .3s ease;-moz-transition:opacity .3s ease;-ms-transition:opacity .3s ease;-o-transition:opacity .3s ease;transition:opacity .3s ease;}#remotestorage-widget.remotestorage-state-connected:hover .rs-cube, #remotestorage-widget.remotestorage-state-busy:hover .rs-cube, #remotestorage-widget.remotestorage-state-connected .rs-bubble:not(.rs-hidden) + .rs-cube{opacity:1 !important;}#remotestorage-widget .rs-backends{position:relative;top:5px;right:0;}#remotestorage-widget .rs-cube{position:relative;top:5px;right:0;}/* pulsing animation for cube when loading */ #remotestorage-widget .rs-cube.remotestorage-loading{-webkit-animation:remotestorage-loading .5s ease-in-out infinite alternate;-moz-animation:remotestorage-loading .5s ease-in-out infinite alternate;-o-animation:remotestorage-loading .5s ease-in-out infinite alternate;-ms-animation:remotestorage-loading .5s ease-in-out infinite alternate;animation:remotestorage-loading .5s ease-in-out infinite alternate;}@-webkit-keyframes remotestorage-loading{to{opacity:.7}}@-moz-keyframes remotestorage-loading{to{opacity:.7}}@-o-keyframes remotestorage-loading{to{opacity:.7}}@-ms-keyframes remotestorage-loading{to{opacity:.7}}@keyframes remotestorage-loading{to{opacity:.7}}#remotestorage-widget a{text-decoration:underline;color:inherit;}#remotestorage-widget form{margin-top:.7em;position:relative;}#remotestorage-widget form input{display:table-cell;vertical-align:top;border:none;border-radius:6px;font-weight:bold;color:white;outline:none;line-height:1.5em;height:2em;}#remotestorage-widget form input:disabled{color:#999;background:#444 !important;cursor:default !important;}#remotestorage-widget form input[type=email]:focus, #remotestorage-widget form input[type=password]:focus{background:#223;}#remotestorage-widget form input[type=email], #remotestorage-widget form input[type=password]{background:#000;width:100%;height:26px;padding:0 30px 0 5px;border-top:1px solid #111;border-bottom:1px solid #999;}#remotestorage-widget form input[type=email]:focus, #remotestorage-widget form input[type=password]:focus{background:#223;}#remotestorage-widget button:focus, #remotestorage-widget input:focus{box-shadow:0 0 4px #ccc;}#remotestorage-widget form input[type=email]::-webkit-input-placeholder, #remotestorage-widget form input[type=password]::-webkit-input-placeholder{color:#999;}#remotestorage-widget form input[type=email]:-moz-placeholder, #remotestorage-widget form input[type=password]:-moz-placeholder{color:#999;}#remotestorage-widget form input[type=email]::-moz-placeholder, #remotestorage-widget form input[type=password]::-moz-placeholder{color:#999;}#remotestorage-widget form input[type=email]:-ms-input-placeholder, #remotestorage-widget form input[type=password]:-ms-input-placeholder{color:#999;}#remotestorage-widget form input[type=submit]{background:#000;cursor:pointer;padding:0 5px;}#remotestorage-widget form input[type=submit]:hover{background:#333;}#remotestorage-widget .rs-info-msg{font-size:10px;color:#eee;margin-top:0.7em;white-space:normal;}#remotestorage-widget .rs-info-msg.last-synced-message{display:inline;white-space:nowrap;margin-bottom:.7em}#remotestorage-widget .rs-info-msg a:hover, #remotestorage-widget .rs-info-msg a:active{color:#fff;}#remotestorage-widget button img{vertical-align:baseline;}#remotestorage-widget button{border:none;border-radius:6px;font-weight:bold;color:white;outline:none;line-height:1.5em;height:26px;width:26px;background:#000;cursor:pointer;margin:0;padding:5px;}#remotestorage-widget button:hover{background:#333;}#remotestorage-widget .rs-bubble button.connect, #remotestorage-widget .rs-bubble button.rs-cipher, #remotestorage-widget .rs-bubble button.rs-nocipher{display:block;background:none;position:absolute;right:0;top:0;opacity:1;/* increase clickable area of connect, rs-cipher & rs-nocipher buttons */ margin:-5px;padding:10px;width:36px;height:36px;}#remotestorage-widget .rs-bubble button.rs-cipher{width:46px;}#remotestorage-widget .rs-bubble button.rs-nocipher{height:26px;margin:0;padding:4px 5px 5px;right:-32px;width:26px;}#remotestorage-widget .rs-bubble button.connect:not([disabled]):hover, #remotestorage-widget .rs-bubble button.rs-cipher:not([disabled]):hover, #remotestorage-widget .rs-bubble button.rs-nocipher:not([disabled]):hover{background:rgba(150,150,150,.5);}#remotestorage-widget .rs-bubble button.connect[disabled], #remotestorage-widget .rs-bubble button.rs-cipher[disabled]{opacity:.5;cursor:default !important;}#remotestorage-widget .rs-bubble button.rs-sync{position:relative;left:-5px;bottom:-5px;padding:4px 4px 0 4px;background:#555;}#remotestorage-widget .rs-bubble button.rs-sync:hover{background:#444;}#remotestorage-widget .rs-bubble button.rs-disconnect{background:#721;position:absolute;right:0;bottom:0;padding:4px 4px 0 4px;}#remotestorage-widget .rs-bubble button.rs-disconnect:hover{background:#921;}#remotestorage-widget .remotestorage-error-info{color:#f92;}#remotestorage-widget .remotestorage-reset{width:100%;background:#721;}#remotestorage-widget .remotestorage-reset:hover{background:#921;}#remotestorage-widget .rs-bubble .rs-content{margin-top:7px;}#remotestorage-widget pre{user-select:initial;-webkit-user-select:initial;-moz-user-select:text;max-width:27em;margin-top:1em;overflow:auto;}#remotestorage-widget .rs-centered-text{text-align:center;}#remotestorage-widget .rs-bubble.rs-hidden{padding-bottom:2px;border-radius:5px 15px 15px 5px;}#remotestorage-widget .rs-error-msg{min-height:5em;}.rs-bubble.rs-hidden .rs-bubble-expandable{display:none;}.remotestorage-state-connected .rs-bubble.rs-hidden{display:none;}.remotestorage-connected{display:none;}.remotestorage-state-connected .remotestorage-connected{display:block;}.remotestorage-cipher-form{display:none;}.remotestorage-cipher .remotestorage-cipher-form{display:block;}.remotestorage-invalid-key{display:none;}.remotestorage-invalid-key.remotestorage-cipher-error{display:block;}.remotestorage-initial{display:none;}.remotestorage-state-initial .remotestorage-initial{display:block;}.remotestorage-error{display:none;}.remotestorage-state-error .remotestorage-error{display:block;}.remotestorage-state-authing .remotestorage-authing{display:block;}.remotestorage-state-offline .remotestorage-connected, .remotestorage-state-offline .remotestorage-offline{display:block;}.remotestorage-unauthorized{display:none;}.remotestorage-state-unauthorized .rs-bubble.rs-hidden{display:none;}.remotestorage-state-unauthorized .remotestorage-connected, .remotestorage-state-unauthorized .remotestorage-unauthorized{display:block;}.remotestorage-state-unauthorized .rs-sync{display:none;}.remotestorage-state-busy .rs-bubble.rs-hidden{display:none;}.remotestorage-state-busy .rs-bubble{display:block;}.remotestorage-state-busy .remotestorage-connected{display:block;}.remotestorage-state-authing .rs-bubble-expandable{display:none;}'
    };
    (function(window) {
      var hasLocalStorage;
      var LS_STATE_KEY = 'remotestorage:widget:state';
      var VALID_ENTRY_STATES = {
        initial: true,
        connected: true,
        offline: true
      };
      RemoteStorage.Widget = function(remoteStorage) {
        var self = this;
        var requestsToFlashFor = 0;
        this.rs = remoteStorage;
        this.rs.remote.on('connected', stateSetter(this, 'connected'));
        this.rs.on('disconnected', stateSetter(this, 'initial'));
        this.rs.on('connecting', stateSetter(this, 'authing'));
        this.rs.on('authing', stateSetter(this, 'authing'));
        this.rs.on('error', errorsHandler(this));
        if (this.rs.remote) {
          this.rs.remote.on('wire-busy', function(evt) {
            if (flashFor(evt)) {
              requestsToFlashFor++;
              stateSetter(self, 'busy')();
            }
          });
          this.rs.remote.on('wire-done', function(evt) {
            if (flashFor(evt)) {
              requestsToFlashFor--;
            }
            if (requestsToFlashFor <= 0 && evt.success) {
              stateSetter(self, 'connected')();
            }
          });
        }
        if (hasLocalStorage) {
          var state = localStorage[LS_STATE_KEY];
          if (state && VALID_ENTRY_STATES[state]) {
            this._rememberedState = state;
          }
        }
      };
      RemoteStorage.Widget.prototype = {
        display: function(options) {
          if (typeof(options) === 'string') {
            options = {domID: options};
          } else if (typeof(options) === 'undefined') {
            options = {};
          }
          if (!this.view) {
            this.setView(new RemoteStorage.Widget.View(this.rs));
          }
          this.view.display(options);
          return this;
        },
        linkWidgetToSync: function() {
          if (typeof(this.rs.sync) === 'object' && typeof(this.rs.sync.sync) === 'function') {
            this.view.on('sync', this.rs.sync.sync.bind(this.rs.sync));
          } else {
            RemoteStorage.log('[Widget] typeof this.rs.sync check fail', this.rs.sync);
            setTimeout(this.linkWidgetToSync.bind(this), 1000);
          }
        },
        setView: function(view) {
          this.view = view;
          this.view.on('connect', function(options) {
            if (typeof(options) === 'string') {
              this.rs.connect(options);
            } else if (options.special) {
              this.rs[options.special].connect(options);
            }
          }.bind(this));
          this.view.on('secret-entered', function(secretKey) {
            this.view.setUserSecretKey(secretKey);
            stateSetter(this, 'ciphered')();
          }.bind(this));
          this.view.on('secret-cancelled', function() {
            stateSetter(this, 'notciphered')();
          }.bind(this));
          this.view.on('disconnect', this.rs.disconnect.bind(this.rs));
          this.linkWidgetToSync();
          try {
            this.view.on('reset', function() {
              var location = RemoteStorage.Authorize.getLocation();
              this.rs.on('disconnected', location.reload.bind(location));
              this.rs.disconnect();
            }.bind(this));
          } catch (e) {
            if (!(e.message && e.message.match(/Unknown event/))) {
              throw e;
            }
          }
          if (this._rememberedState) {
            setTimeout(stateSetter(this, this._rememberedState), 0);
            delete this._rememberedState;
          }
        }
      };
      RemoteStorage.prototype.displayWidget = function(options) {
        return this.widget.display(options);
      };
      RemoteStorage.Widget._rs_init = function(remoteStorage) {
        hasLocalStorage = remoteStorage.localStorageAvailable();
        if (!remoteStorage.widget) {
          remoteStorage.widget = new RemoteStorage.Widget(remoteStorage);
        }
      };
      RemoteStorage.Widget._rs_supported = function(remoteStorage) {
        return typeof(document) !== 'undefined';
      };
      function stateSetter(widget, state) {
        RemoteStorage.log('[Widget] Producing stateSetter for', state);
        return function() {
          RemoteStorage.log('[Widget] Setting state', state, arguments);
          if (hasLocalStorage) {
            localStorage[LS_STATE_KEY] = state;
          }
          if (widget.view) {
            if (widget.rs.remote) {
              widget.view.setUserAddress(widget.rs.remote.userAddress);
            }
            widget.view.setState(state, arguments);
          } else {
            widget._rememberedState = state;
          }
        };
      }
      function errorsHandler(widget) {
        return function(error) {
          var s;
          if (error instanceof RemoteStorage.DiscoveryError) {
            console.error('Discovery failed', error, '"' + error.message + '"');
            s = stateSetter(widget, 'initial', [error.message]);
          } else if (error instanceof RemoteStorage.SyncError) {
            s = stateSetter(widget, 'offline', []);
          } else if (error instanceof RemoteStorage.Unauthorized) {
            s = stateSetter(widget, 'unauthorized');
          } else {
            RemoteStorage.log('[Widget] Unknown error');
            s = stateSetter(widget, 'error', [error]);
          }
          s.apply();
        };
      }
      function flashFor(evt) {
        if (evt.method === 'GET' && evt.isFolder) {
          return false;
        }
        return true;
      }
    })(typeof(window) !== 'undefined' ? window : global);
    (function(window) {
      var t = RemoteStorage.I18n.translate;
      RemoteStorage.Widget.View = function(remoteStorage) {
        this.rs = remoteStorage;
        if (typeof(document) === 'undefined') {
          throw "Widget not supported";
        }
        RemoteStorage.eventHandling(this, 'connect', 'secret-entered', 'secret-cancelled', 'disconnect', 'sync', 'display', 'reset');
        for (var event in this.events) {
          this.events[event] = this.events[event].bind(this);
        }
        this.hideBubbleOnBodyClick = function(event) {
          for (var p = event.target; p !== document.body; p = p.parentElement) {
            if (p.id === 'remotestorage-widget') {
              return;
            }
          }
          this.hideBubble();
        }.bind(this);
      };
      RemoteStorage.Widget.View.prototype = {
        connectGdrive: function() {
          this._emit('connect', {special: 'googledrive'});
        },
        connectDropbox: function() {
          this._emit('connect', {special: 'dropbox'});
        },
        setState: function(state, args) {
          RemoteStorage.log('[View] widget.view.setState(', state, ',', args, ');');
          var s = this.states[state];
          if (typeof(s) === 'undefined') {
            throw new Error("Bad State assigned to view: " + state);
          }
          s.apply(this, args);
        },
        setUserAddress: function(addr) {
          this.userAddress = addr || '';
          var el;
          if (this.div && (el = this.div.querySelector('form.remotestorage-initial').userAddress)) {
            el.value = this.userAddress;
          }
        },
        setUserSecretKey: function(secretKey) {
          this.userSecretKey = secretKey;
        },
        toggleBubble: function(event) {
          if (this.bubble.className.search('rs-hidden') < 0) {
            this.hideBubble(event);
          } else {
            this.showBubble(event);
          }
        },
        hideBubble: function() {
          addClass(this.bubble, 'rs-hidden');
          document.body.removeEventListener('click', this.hideBubbleOnBodyClick);
        },
        showBubble: function(event) {
          removeClass(this.bubble, 'rs-hidden');
          if (typeof(event) !== 'undefined') {
            stopPropagation(event);
          }
          document.body.addEventListener('click', this.hideBubbleOnBodyClick);
          if (this.div.querySelector('.remotestorage-connected').classList.contains('remotestorage-cipher') && !this.userSecretKey) {
            this.bubble.querySelector('form.remotestorage-cipher-form').userSecretKey.focus();
          } else {
            this.bubble.querySelector('form.remotestorage-initial').userAddress.focus();
          }
        },
        display: function(options) {
          if (typeof this.div !== 'undefined') {
            return this.div;
          }
          var element = document.createElement('div');
          var style = document.createElement('style');
          style.innerHTML = RemoteStorage.Assets.widgetCss;
          element.id = "remotestorage-widget";
          element.innerHTML = RemoteStorage.Assets.widget;
          element.appendChild(style);
          if (options.domID) {
            var parent = document.getElementById(options.domID);
            if (!parent) {
              throw "Failed to find target DOM element with id=\"" + options.domID + "\"";
            }
            parent.appendChild(element);
          } else {
            document.body.appendChild(element);
          }
          setupButton(element, 'rs-sync', 'syncIcon', this.events.sync);
          setupButton(element, 'rs-disconnect', 'disconnectIcon', this.events.disconnect);
          setupButton(element, 'remotestorage-reset', undefined, this.events.reset);
          var connectButton = setupButton(element, 'connect', 'connectIcon', this.events.connect);
          this.form = element.querySelector('form.remotestorage-initial');
          var el = this.form.userAddress;
          el.addEventListener('load', handleButtonState);
          el.addEventListener('keyup', handleButtonState);
          if (this.userAddress) {
            el.value = this.userAddress;
          }
          if (options.encryption) {
            this.cipher = true;
            var secretKeyInput = element.querySelector('form.remotestorage-cipher-form').userSecretKey;
            secretKeyInput.type = 'password';
            var cipherButton = setupButton(element, 'rs-cipher', 'cipherIcon', this.events['secret-entered']);
            secretKeyInput.addEventListener('load', handleButtonState);
            secretKeyInput.addEventListener('keyup', handleButtonState);
            setupButton(element, 'rs-nocipher', 'nocipherIcon', this.events['secret-cancelled']);
          }
          this.cube = setupButton(element, 'rs-cube', 'remoteStorageIcon', this.toggleBubble.bind(this));
          setupButton(element, 'rs-dropbox', 'dropbox', this.connectDropbox.bind(this));
          setupButton(element, 'rs-googledrive', 'googledrive', this.connectGdrive.bind(this));
          var bubbleDontCatch = {
            INPUT: true,
            BUTTON: true,
            IMG: true
          };
          var eventListener = function(event) {
            if (!bubbleDontCatch[event.target.tagName] && !(this.div.classList.contains('remotestorage-state-unauthorized'))) {
              this.showBubble(event);
            }
          }.bind(this);
          this.bubble = setupButton(element, 'rs-bubble', undefined, eventListener);
          this.hideBubble();
          this.div = element;
          this.states.initial.call(this);
          this.events.display.call(this);
          return this.div;
        },
        states: {
          initial: function(message) {
            var cube = this.cube;
            var info = message || t("view_info");
            cube.src = RemoteStorage.Assets.remoteStorageIcon;
            this._renderTranslatedInitialContent();
            if (message) {
              cube.src = RemoteStorage.Assets.remoteStorageIconError;
              removeClass(this.cube, 'remotestorage-loading');
              this.showBubble();
              setTimeout(function() {
                cube.src = RemoteStorage.Assets.remoteStorageIcon;
              }, 2000);
            } else {
              this.hideBubble();
            }
            this.div.className = "remotestorage-state-initial";
            if (this.userSecretKey) {
              delete this.userSecretKey;
            }
            var backends = 1;
            if (this._activateBackend('dropbox')) {
              backends += 1;
            }
            if (this._activateBackend('googledrive')) {
              backends += 1;
            }
            this.div.querySelector('.rs-bubble-text').style.paddingRight = backends * 32 + 8 + 'px';
            var cb = this.div.querySelector('.connect');
            if (this.form.userAddress.value) {
              cb.removeAttribute('disabled');
            }
            var infoEl = this.div.querySelector('.rs-info-msg');
            infoEl.innerHTML = info;
            if (message) {
              infoEl.classList.add('remotestorage-error-info');
            } else {
              infoEl.classList.remove('remotestorage-error-info');
            }
          },
          authing: function() {
            this.div.removeEventListener('click', this.events.connect);
            this.div.className = "remotestorage-state-authing";
            this.div.querySelector('.rs-status-text').innerHTML = t("view_connecting", this.userAddress);
            addClass(this.cube, 'remotestorage-loading');
          },
          connected: function() {
            var cube = this.cube;
            this.div.className = "remotestorage-state-connected";
            this.div.querySelector('.userAddress').innerHTML = this.userAddress;
            cube.src = RemoteStorage.Assets.remoteStorageIcon;
            removeClass(cube, 'remotestorage-loading');
            if (this.cipher) {
              if (this.userSecretKey) {
                if (this.userSecretKeyError) {
                  cube.src = RemoteStorage.Assets.remoteStorageIconError;
                  addClass(this.div.querySelector('.remotestorage-connected'), 'remotestorage-cipher');
                  addClass(this.div.querySelector('.remotestorage-invalid-key'), 'remotestorage-cipher-error');
                  this.showBubble();
                  setTimeout(function() {
                    cube.src = RemoteStorage.Assets.remoteStorageIcon;
                  }, 5000);
                } else {
                  removeClass(this.div.querySelector('.remotestorage-invalid-key'), 'remotestorage-cipher-error');
                  cube.src = RemoteStorage.Assets.remoteStorageIconCiphered;
                }
              } else {
                addClass(this.div.querySelector('.remotestorage-connected'), 'remotestorage-cipher');
                this.showBubble();
              }
            }
            var icons = {
              googledrive: this.div.querySelector('.rs-googledrive'),
              dropbox: this.div.querySelector('.rs-dropbox')
            };
            icons.googledrive.style.display = icons.dropbox.style.display = 'none';
            if (icons[this.rs.backend]) {
              icons[this.rs.backend].style.display = 'inline-block';
              this.div.querySelector('.rs-bubble-text').style.paddingRight = 2 * 32 + 8 + 'px';
            } else {
              this.div.querySelector('.rs-bubble-text').style.paddingRight = 32 + 8 + 'px';
            }
          },
          ciphered: function() {
            this.div.querySelector('form.remotestorage-cipher-form').userSecretKey.value = '';
            removeClass(this.div.querySelector('.remotestorage-invalid-key'), 'remotestorage-cipher-error');
            removeClass(this.div.querySelector('.remotestorage-connected'), 'remotestorage-cipher');
            this.cube.src = RemoteStorage.Assets.remoteStorageIconCiphered;
            this.hideBubble();
          },
          notciphered: function() {
            this.cipher = false;
            removeClass(this.div.querySelector('.remotestorage-invalid-key'), 'remotestorage-cipher-error');
            removeClass(this.div.querySelector('.remotestorage-connected'), 'remotestorage-cipher');
            this.hideBubble();
          },
          busy: function() {
            this.div.className = "remotestorage-state-busy";
            addClass(this.cube, 'remotestorage-loading');
          },
          offline: function() {
            this.div.className = "remotestorage-state-offline";
            this.cube.src = RemoteStorage.Assets.remoteStorageIconOffline;
            this.div.querySelector('.rs-status-text').innerHTML = t("view_offline");
          },
          error: function(err) {
            var errorMsg = err;
            this.div.className = "remotestorage-state-error";
            this.div.querySelector('.rs-bubble-text').innerHTML = '<strong>' + t('view_error_occured') + '</strong>';
            if (err instanceof Error) {
              errorMsg = err.message + '\n\n' + err.stack;
            }
            this.div.querySelector('.rs-error-msg').textContent = errorMsg;
            this.cube.src = RemoteStorage.Assets.remoteStorageIconError;
            this.showBubble();
          },
          unauthorized: function() {
            this.div.className = "remotestorage-state-unauthorized";
            this.cube.src = RemoteStorage.Assets.remoteStorageIconError;
            this.showBubble();
            this.div.addEventListener('click', this.events.connect);
          }
        },
        events: {
          connect: function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('connect', this.div.querySelector('form.remotestorage-initial').userAddress.value);
          },
          'secret-entered': function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('secret-entered', this.div.querySelector('form.remotestorage-cipher-form').userSecretKey.value);
          },
          'secret-cancelled': function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('secret-cancelled');
          },
          sync: function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('sync');
          },
          disconnect: function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('disconnect');
          },
          reset: function(event) {
            event.preventDefault();
            var result = window.confirm(t('view_confirm_reset'));
            if (result) {
              this._emit('reset');
            }
          },
          display: function(event) {
            if (event) {
              event.preventDefault();
            }
            this._emit('display');
          }
        },
        _renderTranslatedInitialContent: function() {
          this.div.querySelector('.rs-status-text').innerHTML = t("view_connect");
          this.div.querySelector('.remotestorage-reset').innerHTML = t("view_get_me_out");
          this.div.querySelector('.rs-error-plz-report').innerHTML = t("view_error_plz_report");
          this.div.querySelector('.remotestorage-unauthorized').innerHTML = t("view_unauthorized");
          this.div.querySelector('.remotestorage-invalid-key').innerHTML = t("view_invalid_key");
        },
        _activateBackend: function activateBackend(backendName) {
          var className = 'rs-' + backendName;
          if (this.rs.apiKeys[backendName]) {
            this.div.querySelector('.' + className).style.display = 'inline-block';
            return true;
          } else {
            this.div.querySelector('.' + className).style.display = 'none';
            return false;
          }
        }
      };
      function removeClass(el, className) {
        return el.classList.remove(className);
      }
      function addClass(el, className) {
        return el.classList.add(className);
      }
      function stopPropagation(event) {
        if (typeof(event.stopPropagation) === 'function') {
          event.stopPropagation();
        } else {
          event.cancelBubble = true;
        }
      }
      function setupButton(parent, className, iconName, eventListener) {
        var element = parent.querySelector('.' + className);
        if (typeof iconName !== 'undefined') {
          var img = element.querySelector('img');
          (img || element).src = RemoteStorage.Assets[iconName];
        }
        element.addEventListener('click', eventListener);
        return element;
      }
      function handleButtonState(event) {
        if (event.target.value) {
          event.target.nextElementSibling.removeAttribute('disabled');
        } else {
          event.target.nextElementSibling.setAttribute('disabled', 'disabled');
        }
      }
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global, factory) {
      if (typeof define === 'function' && define.amd) {
        define([], factory);
      } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
      } else {
        global.tv4 = factory();
      }
    }(this, function() {
      if (!Object.keys) {
        Object.keys = (function() {
          var hasOwnProperty = Object.prototype.hasOwnProperty,
              hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
              dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
              dontEnumsLength = dontEnums.length;
          return function(obj) {
            if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
              throw new TypeError('Object.keys called on non-object');
            }
            var result = [];
            for (var prop in obj) {
              if (hasOwnProperty.call(obj, prop)) {
                result.push(prop);
              }
            }
            if (hasDontEnumBug) {
              for (var i = 0; i < dontEnumsLength; i++) {
                if (hasOwnProperty.call(obj, dontEnums[i])) {
                  result.push(dontEnums[i]);
                }
              }
            }
            return result;
          };
        })();
      }
      if (!Object.create) {
        Object.create = (function() {
          function F() {}
          return function(o) {
            if (arguments.length !== 1) {
              throw new Error('Object.create implementation only accepts one parameter.');
            }
            F.prototype = o;
            return new F();
          };
        })();
      }
      if (!Array.isArray) {
        Array.isArray = function(vArg) {
          return Object.prototype.toString.call(vArg) === "[object Array]";
        };
      }
      if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(searchElement) {
          if (this === null) {
            throw new TypeError();
          }
          var t = Object(this);
          var len = t.length >>> 0;
          if (len === 0) {
            return -1;
          }
          var n = 0;
          if (arguments.length > 1) {
            n = Number(arguments[1]);
            if (n !== n) {
              n = 0;
            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
              n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
          }
          if (n >= len) {
            return -1;
          }
          var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
          for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
              return k;
            }
          }
          return -1;
        };
      }
      if (!Object.isFrozen) {
        Object.isFrozen = function(obj) {
          var key = "tv4_test_frozen_key";
          while (obj.hasOwnProperty(key)) {
            key += Math.random();
          }
          try {
            obj[key] = true;
            delete obj[key];
            return false;
          } catch (e) {
            return true;
          }
        };
      }
      var uriTemplateGlobalModifiers = {
        "+": true,
        "#": true,
        ".": true,
        "/": true,
        ";": true,
        "?": true,
        "&": true
      };
      var uriTemplateSuffices = {"*": true};
      function notReallyPercentEncode(string) {
        return encodeURI(string).replace(/%25[0-9][0-9]/g, function(doubleEncoded) {
          return "%" + doubleEncoded.substring(3);
        });
      }
      function uriTemplateSubstitution(spec) {
        var modifier = "";
        if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
          modifier = spec.charAt(0);
          spec = spec.substring(1);
        }
        var separator = "";
        var prefix = "";
        var shouldEscape = true;
        var showVariables = false;
        var trimEmptyString = false;
        if (modifier === '+') {
          shouldEscape = false;
        } else if (modifier === ".") {
          prefix = ".";
          separator = ".";
        } else if (modifier === "/") {
          prefix = "/";
          separator = "/";
        } else if (modifier === '#') {
          prefix = "#";
          shouldEscape = false;
        } else if (modifier === ';') {
          prefix = ";";
          separator = ";";
          showVariables = true;
          trimEmptyString = true;
        } else if (modifier === '?') {
          prefix = "?";
          separator = "&";
          showVariables = true;
        } else if (modifier === '&') {
          prefix = "&";
          separator = "&";
          showVariables = true;
        }
        var varNames = [];
        var varList = spec.split(",");
        var varSpecs = [];
        var varSpecMap = {};
        for (var i = 0; i < varList.length; i++) {
          var varName = varList[i];
          var truncate = null;
          if (varName.indexOf(":") !== -1) {
            var parts = varName.split(":");
            varName = parts[0];
            truncate = parseInt(parts[1], 10);
          }
          var suffices = {};
          while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
            suffices[varName.charAt(varName.length - 1)] = true;
            varName = varName.substring(0, varName.length - 1);
          }
          var varSpec = {
            truncate: truncate,
            name: varName,
            suffices: suffices
          };
          varSpecs.push(varSpec);
          varSpecMap[varName] = varSpec;
          varNames.push(varName);
        }
        var subFunction = function(valueFunction) {
          var result = "";
          var startIndex = 0;
          for (var i = 0; i < varSpecs.length; i++) {
            var varSpec = varSpecs[i];
            var value = valueFunction(varSpec.name);
            if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
              startIndex++;
              continue;
            }
            if (i === startIndex) {
              result += prefix;
            } else {
              result += (separator || ",");
            }
            if (Array.isArray(value)) {
              if (showVariables) {
                result += varSpec.name + "=";
              }
              for (var j = 0; j < value.length; j++) {
                if (j > 0) {
                  result += varSpec.suffices['*'] ? (separator || ",") : ",";
                  if (varSpec.suffices['*'] && showVariables) {
                    result += varSpec.name + "=";
                  }
                }
                result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
              }
            } else if (typeof value === "object") {
              if (showVariables && !varSpec.suffices['*']) {
                result += varSpec.name + "=";
              }
              var first = true;
              for (var key in value) {
                if (!first) {
                  result += varSpec.suffices['*'] ? (separator || ",") : ",";
                }
                first = false;
                result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
                result += varSpec.suffices['*'] ? '=' : ",";
                result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
              }
            } else {
              if (showVariables) {
                result += varSpec.name;
                if (!trimEmptyString || value !== "") {
                  result += "=";
                }
              }
              if (varSpec.truncate != null) {
                value = value.substring(0, varSpec.truncate);
              }
              result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21") : notReallyPercentEncode(value);
            }
          }
          return result;
        };
        subFunction.varNames = varNames;
        return {
          prefix: prefix,
          substitution: subFunction
        };
      }
      function UriTemplate(template) {
        if (!(this instanceof UriTemplate)) {
          return new UriTemplate(template);
        }
        var parts = template.split("{");
        var textParts = [parts.shift()];
        var prefixes = [];
        var substitutions = [];
        var varNames = [];
        while (parts.length > 0) {
          var part = parts.shift();
          var spec = part.split("}")[0];
          var remainder = part.substring(spec.length + 1);
          var funcs = uriTemplateSubstitution(spec);
          substitutions.push(funcs.substitution);
          prefixes.push(funcs.prefix);
          textParts.push(remainder);
          varNames = varNames.concat(funcs.substitution.varNames);
        }
        this.fill = function(valueFunction) {
          var result = textParts[0];
          for (var i = 0; i < substitutions.length; i++) {
            var substitution = substitutions[i];
            result += substitution(valueFunction);
            result += textParts[i + 1];
          }
          return result;
        };
        this.varNames = varNames;
        this.template = template;
      }
      UriTemplate.prototype = {
        toString: function() {
          return this.template;
        },
        fillFromObject: function(obj) {
          return this.fill(function(varName) {
            return obj[varName];
          });
        }
      };
      var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorMessages, checkRecursive, trackUnknownProperties) {
        this.missing = [];
        this.missingMap = {};
        this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
        this.schemas = parent ? Object.create(parent.schemas) : {};
        this.collectMultiple = collectMultiple;
        this.errors = [];
        this.handleError = collectMultiple ? this.collectError : this.returnError;
        if (checkRecursive) {
          this.checkRecursive = true;
          this.scanned = [];
          this.scannedFrozen = [];
          this.scannedFrozenSchemas = [];
          this.scannedFrozenValidationErrors = [];
          this.validatedSchemasKey = 'tv4_validation_id';
          this.validationErrorsKey = 'tv4_validation_errors_id';
        }
        if (trackUnknownProperties) {
          this.trackUnknownProperties = true;
          this.knownPropertyPaths = {};
          this.unknownPropertyPaths = {};
        }
        this.errorMessages = errorMessages;
        this.definedKeywords = {};
        if (parent) {
          for (var key in parent.definedKeywords) {
            this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
          }
        }
      };
      ValidatorContext.prototype.defineKeyword = function(keyword, keywordFunction) {
        this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
        this.definedKeywords[keyword].push(keywordFunction);
      };
      ValidatorContext.prototype.createError = function(code, messageParams, dataPath, schemaPath, subErrors) {
        var messageTemplate = this.errorMessages[code] || ErrorMessagesDefault[code];
        if (typeof messageTemplate !== 'string') {
          return new ValidationError(code, "Unknown error code " + code + ": " + JSON.stringify(messageParams), messageParams, dataPath, schemaPath, subErrors);
        }
        var message = messageTemplate.replace(/\{([^{}]*)\}/g, function(whole, varName) {
          var subValue = messageParams[varName];
          return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
        });
        return new ValidationError(code, message, messageParams, dataPath, schemaPath, subErrors);
      };
      ValidatorContext.prototype.returnError = function(error) {
        return error;
      };
      ValidatorContext.prototype.collectError = function(error) {
        if (error) {
          this.errors.push(error);
        }
        return null;
      };
      ValidatorContext.prototype.prefixErrors = function(startIndex, dataPath, schemaPath) {
        for (var i = startIndex; i < this.errors.length; i++) {
          this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
        }
        return this;
      };
      ValidatorContext.prototype.banUnknownProperties = function() {
        for (var unknownPath in this.unknownPropertyPaths) {
          var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "");
          var result = this.handleError(error);
          if (result) {
            return result;
          }
        }
        return null;
      };
      ValidatorContext.prototype.addFormat = function(format, validator) {
        if (typeof format === 'object') {
          for (var key in format) {
            this.addFormat(key, format[key]);
          }
          return this;
        }
        this.formatValidators[format] = validator;
      };
      ValidatorContext.prototype.resolveRefs = function(schema, urlHistory) {
        if (schema['$ref'] !== undefined) {
          urlHistory = urlHistory || {};
          if (urlHistory[schema['$ref']]) {
            return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '');
          }
          urlHistory[schema['$ref']] = true;
          schema = this.getSchema(schema['$ref'], urlHistory);
        }
        return schema;
      };
      ValidatorContext.prototype.getSchema = function(url, urlHistory) {
        var schema;
        if (this.schemas[url] !== undefined) {
          schema = this.schemas[url];
          return this.resolveRefs(schema, urlHistory);
        }
        var baseUrl = url;
        var fragment = "";
        if (url.indexOf('#') !== -1) {
          fragment = url.substring(url.indexOf("#") + 1);
          baseUrl = url.substring(0, url.indexOf("#"));
        }
        if (typeof this.schemas[baseUrl] === 'object') {
          schema = this.schemas[baseUrl];
          var pointerPath = decodeURIComponent(fragment);
          if (pointerPath === "") {
            return this.resolveRefs(schema, urlHistory);
          } else if (pointerPath.charAt(0) !== "/") {
            return undefined;
          }
          var parts = pointerPath.split("/").slice(1);
          for (var i = 0; i < parts.length; i++) {
            var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
            if (schema[component] === undefined) {
              schema = undefined;
              break;
            }
            schema = schema[component];
          }
          if (schema !== undefined) {
            return this.resolveRefs(schema, urlHistory);
          }
        }
        if (this.missing[baseUrl] === undefined) {
          this.missing.push(baseUrl);
          this.missing[baseUrl] = baseUrl;
          this.missingMap[baseUrl] = baseUrl;
        }
      };
      ValidatorContext.prototype.searchSchemas = function(schema, url) {
        if (Array.isArray(schema)) {
          for (var i = 0; i < schema.length; i++) {
            this.searchSchemas(schema[i], url);
          }
        } else if (schema && typeof schema === "object") {
          if (typeof schema.id === "string") {
            if (isTrustedUrl(url, schema.id)) {
              if (this.schemas[schema.id] === undefined) {
                this.schemas[schema.id] = schema;
              }
            }
          }
          for (var key in schema) {
            if (key !== "enum") {
              if (typeof schema[key] === "object") {
                this.searchSchemas(schema[key], url);
              } else if (key === "$ref") {
                var uri = getDocumentUri(schema[key]);
                if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
                  this.missingMap[uri] = uri;
                }
              }
            }
          }
        }
      };
      ValidatorContext.prototype.addSchema = function(url, schema) {
        if (typeof url !== 'string' || typeof schema === 'undefined') {
          if (typeof url === 'object' && typeof url.id === 'string') {
            schema = url;
            url = schema.id;
          } else {
            return;
          }
        }
        if (url === getDocumentUri(url) + "#") {
          url = getDocumentUri(url);
        }
        this.schemas[url] = schema;
        delete this.missingMap[url];
        normSchema(schema, url);
        this.searchSchemas(schema, url);
      };
      ValidatorContext.prototype.getSchemaMap = function() {
        var map = {};
        for (var key in this.schemas) {
          map[key] = this.schemas[key];
        }
        return map;
      };
      ValidatorContext.prototype.getSchemaUris = function(filterRegExp) {
        var list = [];
        for (var key in this.schemas) {
          if (!filterRegExp || filterRegExp.test(key)) {
            list.push(key);
          }
        }
        return list;
      };
      ValidatorContext.prototype.getMissingUris = function(filterRegExp) {
        var list = [];
        for (var key in this.missingMap) {
          if (!filterRegExp || filterRegExp.test(key)) {
            list.push(key);
          }
        }
        return list;
      };
      ValidatorContext.prototype.dropSchemas = function() {
        this.schemas = {};
        this.reset();
      };
      ValidatorContext.prototype.reset = function() {
        this.missing = [];
        this.missingMap = {};
        this.errors = [];
      };
      ValidatorContext.prototype.validateAll = function(data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
        var topLevel;
        schema = this.resolveRefs(schema);
        if (!schema) {
          return null;
        } else if (schema instanceof ValidationError) {
          this.errors.push(schema);
          return schema;
        }
        var startErrorCount = this.errors.length;
        var frozenIndex,
            scannedFrozenSchemaIndex = null,
            scannedSchemasIndex = null;
        if (this.checkRecursive && data && typeof data === 'object') {
          topLevel = !this.scanned.length;
          if (data[this.validatedSchemasKey]) {
            var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
            if (schemaIndex !== -1) {
              this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
              return null;
            }
          }
          if (Object.isFrozen(data)) {
            frozenIndex = this.scannedFrozen.indexOf(data);
            if (frozenIndex !== -1) {
              var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
              if (frozenSchemaIndex !== -1) {
                this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
                return null;
              }
            }
          }
          this.scanned.push(data);
          if (Object.isFrozen(data)) {
            if (frozenIndex === -1) {
              frozenIndex = this.scannedFrozen.length;
              this.scannedFrozen.push(data);
              this.scannedFrozenSchemas.push([]);
            }
            scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
            this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
            this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
          } else {
            if (!data[this.validatedSchemasKey]) {
              try {
                Object.defineProperty(data, this.validatedSchemasKey, {
                  value: [],
                  configurable: true
                });
                Object.defineProperty(data, this.validationErrorsKey, {
                  value: [],
                  configurable: true
                });
              } catch (e) {
                data[this.validatedSchemasKey] = [];
                data[this.validationErrorsKey] = [];
              }
            }
            scannedSchemasIndex = data[this.validatedSchemasKey].length;
            data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
            data[this.validationErrorsKey][scannedSchemasIndex] = [];
          }
        }
        var errorCount = this.errors.length;
        var error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateHypermedia(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;
        if (topLevel) {
          while (this.scanned.length) {
            var item = this.scanned.pop();
            delete item[this.validatedSchemasKey];
          }
          this.scannedFrozen = [];
          this.scannedFrozenSchemas = [];
        }
        if (error || errorCount !== this.errors.length) {
          while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
            var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
            var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
            if (error) {
              error = error.prefixWith(dataPart, schemaPart);
            }
            this.prefixErrors(errorCount, dataPart, schemaPart);
          }
        }
        if (scannedFrozenSchemaIndex !== null) {
          this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
        } else if (scannedSchemasIndex !== null) {
          data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
        }
        return this.handleError(error);
      };
      ValidatorContext.prototype.validateFormat = function(data, schema) {
        if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
          return null;
        }
        var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
        if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
          return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}).prefixWith(null, "format");
        } else if (errorMessage && typeof errorMessage === 'object') {
          return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || null, errorMessage.schemaPath || "/format");
        }
        return null;
      };
      ValidatorContext.prototype.validateDefinedKeywords = function(data, schema) {
        for (var key in this.definedKeywords) {
          if (typeof schema[key] === 'undefined') {
            continue;
          }
          var validationFunctions = this.definedKeywords[key];
          for (var i = 0; i < validationFunctions.length; i++) {
            var func = validationFunctions[i];
            var result = func(data, schema[key], schema);
            if (typeof result === 'string' || typeof result === 'number') {
              return this.createError(ErrorCodes.KEYWORD_CUSTOM, {
                key: key,
                message: result
              }).prefixWith(null, "format");
            } else if (result && typeof result === 'object') {
              var code = result.code || ErrorCodes.KEYWORD_CUSTOM;
              if (typeof code === 'string') {
                if (!ErrorCodes[code]) {
                  throw new Error('Undefined error code (use defineError): ' + code);
                }
                code = ErrorCodes[code];
              }
              var messageParams = (typeof result.message === 'object') ? result.message : {
                key: key,
                message: result.message || "?"
              };
              var schemaPath = result.schemaPath || ("/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
              return this.createError(code, messageParams, result.dataPath || null, schemaPath);
            }
          }
        }
        return null;
      };
      function recursiveCompare(A, B) {
        if (A === B) {
          return true;
        }
        if (typeof A === "object" && typeof B === "object") {
          if (Array.isArray(A) !== Array.isArray(B)) {
            return false;
          } else if (Array.isArray(A)) {
            if (A.length !== B.length) {
              return false;
            }
            for (var i = 0; i < A.length; i++) {
              if (!recursiveCompare(A[i], B[i])) {
                return false;
              }
            }
          } else {
            var key;
            for (key in A) {
              if (B[key] === undefined && A[key] !== undefined) {
                return false;
              }
            }
            for (key in B) {
              if (A[key] === undefined && B[key] !== undefined) {
                return false;
              }
            }
            for (key in A) {
              if (!recursiveCompare(A[key], B[key])) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
        var error;
        if (error = this.validateType(data, schema, dataPointerPath)) {
          return error.prefixWith(null, "type");
        }
        if (error = this.validateEnum(data, schema, dataPointerPath)) {
          return error.prefixWith(null, "type");
        }
        return null;
      };
      ValidatorContext.prototype.validateType = function validateType(data, schema) {
        if (schema.type === undefined) {
          return null;
        }
        var dataType = typeof data;
        if (data === null) {
          dataType = "null";
        } else if (Array.isArray(data)) {
          dataType = "array";
        }
        var allowedTypes = schema.type;
        if (typeof allowedTypes !== "object") {
          allowedTypes = [allowedTypes];
        }
        for (var i = 0; i < allowedTypes.length; i++) {
          var type = allowedTypes[i];
          if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
            return null;
          }
        }
        return this.createError(ErrorCodes.INVALID_TYPE, {
          type: dataType,
          expected: allowedTypes.join("/")
        });
      };
      ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
        if (schema["enum"] === undefined) {
          return null;
        }
        for (var i = 0; i < schema["enum"].length; i++) {
          var enumVal = schema["enum"][i];
          if (recursiveCompare(data, enumVal)) {
            return null;
          }
        }
        return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data});
      };
      ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
        return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || this.validateNaN(data, schema, dataPointerPath) || null;
      };
      var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
      var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
      ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
        var multipleOf = schema.multipleOf || schema.divisibleBy;
        if (multipleOf === undefined) {
          return null;
        }
        if (typeof data === "number") {
          var remainder = (data / multipleOf) % 1;
          if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
            return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {
              value: data,
              multipleOf: multipleOf
            });
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
        if (typeof data !== "number") {
          return null;
        }
        if (schema.minimum !== undefined) {
          if (data < schema.minimum) {
            return this.createError(ErrorCodes.NUMBER_MINIMUM, {
              value: data,
              minimum: schema.minimum
            }).prefixWith(null, "minimum");
          }
          if (schema.exclusiveMinimum && data === schema.minimum) {
            return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {
              value: data,
              minimum: schema.minimum
            }).prefixWith(null, "exclusiveMinimum");
          }
        }
        if (schema.maximum !== undefined) {
          if (data > schema.maximum) {
            return this.createError(ErrorCodes.NUMBER_MAXIMUM, {
              value: data,
              maximum: schema.maximum
            }).prefixWith(null, "maximum");
          }
          if (schema.exclusiveMaximum && data === schema.maximum) {
            return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {
              value: data,
              maximum: schema.maximum
            }).prefixWith(null, "exclusiveMaximum");
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateNaN = function validateNaN(data) {
        if (typeof data !== "number") {
          return null;
        }
        if (isNaN(data) === true || data === Infinity || data === -Infinity) {
          return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}).prefixWith(null, "type");
        }
        return null;
      };
      ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
        return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;
      };
      ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
        if (typeof data !== "string") {
          return null;
        }
        if (schema.minLength !== undefined) {
          if (data.length < schema.minLength) {
            return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {
              length: data.length,
              minimum: schema.minLength
            }).prefixWith(null, "minLength");
          }
        }
        if (schema.maxLength !== undefined) {
          if (data.length > schema.maxLength) {
            return this.createError(ErrorCodes.STRING_LENGTH_LONG, {
              length: data.length,
              maximum: schema.maxLength
            }).prefixWith(null, "maxLength");
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
        if (typeof data !== "string" || schema.pattern === undefined) {
          return null;
        }
        var regexp = new RegExp(schema.pattern);
        if (!regexp.test(data)) {
          return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}).prefixWith(null, "pattern");
        }
        return null;
      };
      ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
        if (!Array.isArray(data)) {
          return null;
        }
        return this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null;
      };
      ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
        var error;
        if (schema.minItems !== undefined) {
          if (data.length < schema.minItems) {
            error = (this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {
              length: data.length,
              minimum: schema.minItems
            })).prefixWith(null, "minItems");
            if (this.handleError(error)) {
              return error;
            }
          }
        }
        if (schema.maxItems !== undefined) {
          if (data.length > schema.maxItems) {
            error = (this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {
              length: data.length,
              maximum: schema.maxItems
            })).prefixWith(null, "maxItems");
            if (this.handleError(error)) {
              return error;
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
        if (schema.uniqueItems) {
          for (var i = 0; i < data.length; i++) {
            for (var j = i + 1; j < data.length; j++) {
              if (recursiveCompare(data[i], data[j])) {
                var error = (this.createError(ErrorCodes.ARRAY_UNIQUE, {
                  match1: i,
                  match2: j
                })).prefixWith(null, "uniqueItems");
                if (this.handleError(error)) {
                  return error;
                }
              }
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
        if (schema.items === undefined) {
          return null;
        }
        var error,
            i;
        if (Array.isArray(schema.items)) {
          for (i = 0; i < data.length; i++) {
            if (i < schema.items.length) {
              if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
                return error;
              }
            } else if (schema.additionalItems !== undefined) {
              if (typeof schema.additionalItems === "boolean") {
                if (!schema.additionalItems) {
                  error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {})).prefixWith("" + i, "additionalItems");
                  if (this.handleError(error)) {
                    return error;
                  }
                }
              } else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
                return error;
              }
            }
          }
        } else {
          for (i = 0; i < data.length; i++) {
            if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
              return error;
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
        if (typeof data !== "object" || data === null || Array.isArray(data)) {
          return null;
        }
        return this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;
      };
      ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
        var keys = Object.keys(data);
        var error;
        if (schema.minProperties !== undefined) {
          if (keys.length < schema.minProperties) {
            error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {
              propertyCount: keys.length,
              minimum: schema.minProperties
            }).prefixWith(null, "minProperties");
            if (this.handleError(error)) {
              return error;
            }
          }
        }
        if (schema.maxProperties !== undefined) {
          if (keys.length > schema.maxProperties) {
            error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {
              propertyCount: keys.length,
              maximum: schema.maxProperties
            }).prefixWith(null, "maxProperties");
            if (this.handleError(error)) {
              return error;
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
        if (schema.required !== undefined) {
          for (var i = 0; i < schema.required.length; i++) {
            var key = schema.required[i];
            if (data[key] === undefined) {
              var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}).prefixWith(null, "" + i).prefixWith(null, "required");
              if (this.handleError(error)) {
                return error;
              }
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
        var error;
        for (var key in data) {
          var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
          var foundMatch = false;
          if (schema.properties !== undefined && schema.properties[key] !== undefined) {
            foundMatch = true;
            if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
              return error;
            }
          }
          if (schema.patternProperties !== undefined) {
            for (var patternKey in schema.patternProperties) {
              var regexp = new RegExp(patternKey);
              if (regexp.test(key)) {
                foundMatch = true;
                if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
                  return error;
                }
              }
            }
          }
          if (!foundMatch) {
            if (schema.additionalProperties !== undefined) {
              if (this.trackUnknownProperties) {
                this.knownPropertyPaths[keyPointerPath] = true;
                delete this.unknownPropertyPaths[keyPointerPath];
              }
              if (typeof schema.additionalProperties === "boolean") {
                if (!schema.additionalProperties) {
                  error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {}).prefixWith(key, "additionalProperties");
                  if (this.handleError(error)) {
                    return error;
                  }
                }
              } else {
                if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
                  return error;
                }
              }
            } else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
              this.unknownPropertyPaths[keyPointerPath] = true;
            }
          } else if (this.trackUnknownProperties) {
            this.knownPropertyPaths[keyPointerPath] = true;
            delete this.unknownPropertyPaths[keyPointerPath];
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
        var error;
        if (schema.dependencies !== undefined) {
          for (var depKey in schema.dependencies) {
            if (data[depKey] !== undefined) {
              var dep = schema.dependencies[depKey];
              if (typeof dep === "string") {
                if (data[dep] === undefined) {
                  error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {
                    key: depKey,
                    missing: dep
                  }).prefixWith(null, depKey).prefixWith(null, "dependencies");
                  if (this.handleError(error)) {
                    return error;
                  }
                }
              } else if (Array.isArray(dep)) {
                for (var i = 0; i < dep.length; i++) {
                  var requiredKey = dep[i];
                  if (data[requiredKey] === undefined) {
                    error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {
                      key: depKey,
                      missing: requiredKey
                    }).prefixWith(null, "" + i).prefixWith(null, depKey).prefixWith(null, "dependencies");
                    if (this.handleError(error)) {
                      return error;
                    }
                  }
                }
              } else {
                if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
                  return error;
                }
              }
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
        return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;
      };
      ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
        if (schema.allOf === undefined) {
          return null;
        }
        var error;
        for (var i = 0; i < schema.allOf.length; i++) {
          var subSchema = schema.allOf[i];
          if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
            return error;
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
        if (schema.anyOf === undefined) {
          return null;
        }
        var errors = [];
        var startErrorCount = this.errors.length;
        var oldUnknownPropertyPaths,
            oldKnownPropertyPaths;
        if (this.trackUnknownProperties) {
          oldUnknownPropertyPaths = this.unknownPropertyPaths;
          oldKnownPropertyPaths = this.knownPropertyPaths;
        }
        var errorAtEnd = true;
        for (var i = 0; i < schema.anyOf.length; i++) {
          if (this.trackUnknownProperties) {
            this.unknownPropertyPaths = {};
            this.knownPropertyPaths = {};
          }
          var subSchema = schema.anyOf[i];
          var errorCount = this.errors.length;
          var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);
          if (error === null && errorCount === this.errors.length) {
            this.errors = this.errors.slice(0, startErrorCount);
            if (this.trackUnknownProperties) {
              for (var knownKey in this.knownPropertyPaths) {
                oldKnownPropertyPaths[knownKey] = true;
                delete oldUnknownPropertyPaths[knownKey];
              }
              for (var unknownKey in this.unknownPropertyPaths) {
                if (!oldKnownPropertyPaths[unknownKey]) {
                  oldUnknownPropertyPaths[unknownKey] = true;
                }
              }
              errorAtEnd = false;
              continue;
            }
            return null;
          }
          if (error) {
            errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
          }
        }
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = oldUnknownPropertyPaths;
          this.knownPropertyPaths = oldKnownPropertyPaths;
        }
        if (errorAtEnd) {
          errors = errors.concat(this.errors.slice(startErrorCount));
          this.errors = this.errors.slice(0, startErrorCount);
          return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors);
        }
      };
      ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
        if (schema.oneOf === undefined) {
          return null;
        }
        var validIndex = null;
        var errors = [];
        var startErrorCount = this.errors.length;
        var oldUnknownPropertyPaths,
            oldKnownPropertyPaths;
        if (this.trackUnknownProperties) {
          oldUnknownPropertyPaths = this.unknownPropertyPaths;
          oldKnownPropertyPaths = this.knownPropertyPaths;
        }
        for (var i = 0; i < schema.oneOf.length; i++) {
          if (this.trackUnknownProperties) {
            this.unknownPropertyPaths = {};
            this.knownPropertyPaths = {};
          }
          var subSchema = schema.oneOf[i];
          var errorCount = this.errors.length;
          var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);
          if (error === null && errorCount === this.errors.length) {
            if (validIndex === null) {
              validIndex = i;
            } else {
              this.errors = this.errors.slice(0, startErrorCount);
              return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {
                index1: validIndex,
                index2: i
              }, "", "/oneOf");
            }
            if (this.trackUnknownProperties) {
              for (var knownKey in this.knownPropertyPaths) {
                oldKnownPropertyPaths[knownKey] = true;
                delete oldUnknownPropertyPaths[knownKey];
              }
              for (var unknownKey in this.unknownPropertyPaths) {
                if (!oldKnownPropertyPaths[unknownKey]) {
                  oldUnknownPropertyPaths[unknownKey] = true;
                }
              }
            }
          } else if (error) {
            errors.push(error);
          }
        }
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = oldUnknownPropertyPaths;
          this.knownPropertyPaths = oldKnownPropertyPaths;
        }
        if (validIndex === null) {
          errors = errors.concat(this.errors.slice(startErrorCount));
          this.errors = this.errors.slice(0, startErrorCount);
          return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors);
        } else {
          this.errors = this.errors.slice(0, startErrorCount);
        }
        return null;
      };
      ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
        if (schema.not === undefined) {
          return null;
        }
        var oldErrorCount = this.errors.length;
        var oldUnknownPropertyPaths,
            oldKnownPropertyPaths;
        if (this.trackUnknownProperties) {
          oldUnknownPropertyPaths = this.unknownPropertyPaths;
          oldKnownPropertyPaths = this.knownPropertyPaths;
          this.unknownPropertyPaths = {};
          this.knownPropertyPaths = {};
        }
        var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
        var notErrors = this.errors.slice(oldErrorCount);
        this.errors = this.errors.slice(0, oldErrorCount);
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = oldUnknownPropertyPaths;
          this.knownPropertyPaths = oldKnownPropertyPaths;
        }
        if (error === null && notErrors.length === 0) {
          return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not");
        }
        return null;
      };
      ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
        if (!schema.links) {
          return null;
        }
        var error;
        for (var i = 0; i < schema.links.length; i++) {
          var ldo = schema.links[i];
          if (ldo.rel === "describedby") {
            var template = new UriTemplate(ldo.href);
            var allPresent = true;
            for (var j = 0; j < template.varNames.length; j++) {
              if (!(template.varNames[j] in data)) {
                allPresent = false;
                break;
              }
            }
            if (allPresent) {
              var schemaUrl = template.fillFromObject(data);
              var subSchema = {"$ref": schemaUrl};
              if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
                return error;
              }
            }
          }
        }
      };
      function parseURI(url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return (m ? {
          href: m[0] || '',
          protocol: m[1] || '',
          authority: m[2] || '',
          host: m[3] || '',
          hostname: m[4] || '',
          port: m[5] || '',
          pathname: m[6] || '',
          search: m[7] || '',
          hash: m[8] || ''
        } : null);
      }
      function resolveUrl(base, href) {
        function removeDotSegments(input) {
          var output = [];
          input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function(p) {
            if (p === '/..') {
              output.pop();
            } else {
              output.push(p);
            }
          });
          return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) + (href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) + href.hash;
      }
      function getDocumentUri(uri) {
        return uri.split('#')[0];
      }
      function normSchema(schema, baseUri) {
        if (schema && typeof schema === "object") {
          if (baseUri === undefined) {
            baseUri = schema.id;
          } else if (typeof schema.id === "string") {
            baseUri = resolveUrl(baseUri, schema.id);
            schema.id = baseUri;
          }
          if (Array.isArray(schema)) {
            for (var i = 0; i < schema.length; i++) {
              normSchema(schema[i], baseUri);
            }
          } else {
            if (typeof schema['$ref'] === "string") {
              schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
            }
            for (var key in schema) {
              if (key !== "enum") {
                normSchema(schema[key], baseUri);
              }
            }
          }
        }
      }
      var ErrorCodes = {
        INVALID_TYPE: 0,
        ENUM_MISMATCH: 1,
        ANY_OF_MISSING: 10,
        ONE_OF_MISSING: 11,
        ONE_OF_MULTIPLE: 12,
        NOT_PASSED: 13,
        NUMBER_MULTIPLE_OF: 100,
        NUMBER_MINIMUM: 101,
        NUMBER_MINIMUM_EXCLUSIVE: 102,
        NUMBER_MAXIMUM: 103,
        NUMBER_MAXIMUM_EXCLUSIVE: 104,
        NUMBER_NOT_A_NUMBER: 105,
        STRING_LENGTH_SHORT: 200,
        STRING_LENGTH_LONG: 201,
        STRING_PATTERN: 202,
        OBJECT_PROPERTIES_MINIMUM: 300,
        OBJECT_PROPERTIES_MAXIMUM: 301,
        OBJECT_REQUIRED: 302,
        OBJECT_ADDITIONAL_PROPERTIES: 303,
        OBJECT_DEPENDENCY_KEY: 304,
        ARRAY_LENGTH_SHORT: 400,
        ARRAY_LENGTH_LONG: 401,
        ARRAY_UNIQUE: 402,
        ARRAY_ADDITIONAL_ITEMS: 403,
        FORMAT_CUSTOM: 500,
        KEYWORD_CUSTOM: 501,
        CIRCULAR_REFERENCE: 600,
        UNKNOWN_PROPERTY: 1000
      };
      var ErrorCodeLookup = {};
      for (var key in ErrorCodes) {
        ErrorCodeLookup[ErrorCodes[key]] = key;
      }
      var ErrorMessagesDefault = {
        INVALID_TYPE: "Invalid type: {type} (expected {expected})",
        ENUM_MISMATCH: "No enum match for: {value}",
        ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
        ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
        ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
        NOT_PASSED: "Data matches schema from \"not\"",
        NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
        NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
        NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
        NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
        NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
        NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
        STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
        STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
        STRING_PATTERN: "String does not match pattern: {pattern}",
        OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
        OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
        OBJECT_REQUIRED: "Missing required property: {key}",
        OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
        OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
        ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
        ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
        ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
        ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
        FORMAT_CUSTOM: "Format validation failed ({message})",
        KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
        CIRCULAR_REFERENCE: "Circular $refs: {urls}",
        UNKNOWN_PROPERTY: "Unknown property (not in schema)"
      };
      function ValidationError(code, message, params, dataPath, schemaPath, subErrors) {
        Error.call(this);
        if (code === undefined) {
          throw new Error("No code supplied for error: " + message);
        }
        this.message = message;
        this.params = params;
        this.code = code;
        this.dataPath = dataPath || "";
        this.schemaPath = schemaPath || "";
        this.subErrors = subErrors || null;
        var err = new Error(this.message);
        this.stack = err.stack || err.stacktrace;
        if (!this.stack) {
          try {
            throw err;
          } catch (err) {
            this.stack = err.stack || err.stacktrace;
          }
        }
      }
      ValidationError.prototype = Object.create(Error.prototype);
      ValidationError.prototype.constructor = ValidationError;
      ValidationError.prototype.name = 'ValidationError';
      ValidationError.prototype.prefixWith = function(dataPrefix, schemaPrefix) {
        if (dataPrefix !== null) {
          dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
          this.dataPath = "/" + dataPrefix + this.dataPath;
        }
        if (schemaPrefix !== null) {
          schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
          this.schemaPath = "/" + schemaPrefix + this.schemaPath;
        }
        if (this.subErrors !== null) {
          for (var i = 0; i < this.subErrors.length; i++) {
            this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
          }
        }
        return this;
      };
      function isTrustedUrl(baseUrl, testUrl) {
        if (testUrl.substring(0, baseUrl.length) === baseUrl) {
          var remainder = testUrl.substring(baseUrl.length);
          if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/") || remainder.charAt(0) === "#" || remainder.charAt(0) === "?") {
            return true;
          }
        }
        return false;
      }
      var languages = {};
      function createApi(language) {
        var globalContext = new ValidatorContext();
        var currentLanguage = language || 'en';
        var api = {
          addFormat: function() {
            globalContext.addFormat.apply(globalContext, arguments);
          },
          language: function(code) {
            if (!code) {
              return currentLanguage;
            }
            if (!languages[code]) {
              code = code.split('-')[0];
            }
            if (languages[code]) {
              currentLanguage = code;
              return code;
            }
            return false;
          },
          addLanguage: function(code, messageMap) {
            var key;
            for (key in ErrorCodes) {
              if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
                messageMap[ErrorCodes[key]] = messageMap[key];
              }
            }
            var rootCode = code.split('-')[0];
            if (!languages[rootCode]) {
              languages[code] = messageMap;
              languages[rootCode] = messageMap;
            } else {
              languages[code] = Object.create(languages[rootCode]);
              for (key in messageMap) {
                if (typeof languages[rootCode][key] === 'undefined') {
                  languages[rootCode][key] = messageMap[key];
                }
                languages[code][key] = messageMap[key];
              }
            }
            return this;
          },
          freshApi: function(language) {
            var result = createApi();
            if (language) {
              result.language(language);
            }
            return result;
          },
          validate: function(data, schema, checkRecursive, banUnknownProperties) {
            var context = new ValidatorContext(globalContext, false, languages[currentLanguage], checkRecursive, banUnknownProperties);
            if (typeof schema === "string") {
              schema = {"$ref": schema};
            }
            context.addSchema("", schema);
            var error = context.validateAll(data, schema, null, null, "");
            if (!error && banUnknownProperties) {
              error = context.banUnknownProperties();
            }
            this.error = error;
            this.missing = context.missing;
            this.valid = (error === null);
            return this.valid;
          },
          validateResult: function() {
            var result = {};
            this.validate.apply(result, arguments);
            return result;
          },
          validateMultiple: function(data, schema, checkRecursive, banUnknownProperties) {
            var context = new ValidatorContext(globalContext, true, languages[currentLanguage], checkRecursive, banUnknownProperties);
            if (typeof schema === "string") {
              schema = {"$ref": schema};
            }
            context.addSchema("", schema);
            context.validateAll(data, schema, null, null, "");
            if (banUnknownProperties) {
              context.banUnknownProperties();
            }
            var result = {};
            result.errors = context.errors;
            result.missing = context.missing;
            result.valid = (result.errors.length === 0);
            return result;
          },
          addSchema: function() {
            return globalContext.addSchema.apply(globalContext, arguments);
          },
          getSchema: function() {
            return globalContext.getSchema.apply(globalContext, arguments);
          },
          getSchemaMap: function() {
            return globalContext.getSchemaMap.apply(globalContext, arguments);
          },
          getSchemaUris: function() {
            return globalContext.getSchemaUris.apply(globalContext, arguments);
          },
          getMissingUris: function() {
            return globalContext.getMissingUris.apply(globalContext, arguments);
          },
          dropSchemas: function() {
            globalContext.dropSchemas.apply(globalContext, arguments);
          },
          defineKeyword: function() {
            globalContext.defineKeyword.apply(globalContext, arguments);
          },
          defineError: function(codeName, codeNumber, defaultMessage) {
            if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
              throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
            }
            if (typeof codeNumber !== 'number' || codeNumber % 1 !== 0 || codeNumber < 10000) {
              throw new Error('Code number must be an integer > 10000');
            }
            if (typeof ErrorCodes[codeName] !== 'undefined') {
              throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
            }
            if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
              throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
            }
            ErrorCodes[codeName] = codeNumber;
            ErrorCodeLookup[codeNumber] = codeName;
            ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
            for (var langCode in languages) {
              var language = languages[langCode];
              if (language[codeName]) {
                language[codeNumber] = language[codeNumber] || language[codeName];
              }
            }
          },
          reset: function() {
            globalContext.reset();
            this.error = null;
            this.missing = [];
            this.valid = true;
          },
          missing: [],
          error: null,
          valid: true,
          normSchema: normSchema,
          resolveUrl: resolveUrl,
          getDocumentUri: getDocumentUri,
          errorCodes: ErrorCodes
        };
        return api;
      }
      var tv4 = createApi();
      tv4.addLanguage('en-gb', ErrorMessagesDefault);
      tv4.tv4 = tv4;
      return tv4;
    }));
    var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    Math.uuid = function(len, radix) {
      var chars = CHARS,
          uuid = [],
          i;
      radix = radix || chars.length;
      if (len) {
        for (i = 0; i < len; i++)
          uuid[i] = chars[0 | Math.random() * radix];
      } else {
        var r;
        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
        uuid[14] = '4';
        for (i = 0; i < 36; i++) {
          if (!uuid[i]) {
            r = 0 | Math.random() * 16;
            uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
          }
        }
      }
      return uuid.join('');
    };
    (function(global) {
      function deprecate(thing, replacement) {
        console.log('WARNING: ' + thing + ' is deprecated. Use ' + replacement + ' instead.');
      }
      var RS = RemoteStorage;
      RS.BaseClient = function(storage, base) {
        if (base[base.length - 1] !== '/') {
          throw "Not a folder: " + base;
        }
        if (base === '/') {
          this.makePath = function(path) {
            return (path[0] === '/' ? '' : '/') + path;
          };
        }
        this.storage = storage;
        this.base = base;
        var parts = this.base.split('/');
        if (parts.length > 2) {
          this.moduleName = parts[1];
        } else {
          this.moduleName = 'root';
        }
        RS.eventHandling(this, 'change');
        this.on = this.on.bind(this);
        storage.onChange(this.base, this._fireChange.bind(this));
      };
      RS.BaseClient.prototype = {
        extend: function(object) {
          for (var key in object) {
            this[key] = object[key];
          }
          return this;
        },
        scope: function(path) {
          return new RS.BaseClient(this.storage, this.makePath(path));
        },
        getListing: function(path, maxAge) {
          if (typeof(path) !== 'string') {
            path = '';
          } else if (path.length > 0 && path[path.length - 1] !== '/') {
            Promise.reject("Not a folder: " + path);
          }
          return this.storage.get(this.makePath(path), maxAge).then(function(r) {
            return (r.statusCode === 404) ? {} : r.body;
          });
        },
        getAll: function(path, maxAge) {
          if (typeof(path) !== 'string') {
            path = '';
          } else if (path.length > 0 && path[path.length - 1] !== '/') {
            return Promise.reject("Not a folder: " + path);
          }
          return this.storage.get(this.makePath(path), maxAge).then(function(r) {
            if (r.statusCode === 404) {
              return {};
            }
            if (typeof(r.body) === 'object') {
              var keys = Object.keys(r.body);
              if (keys.length === 0) {
                return {};
              }
              var calls = keys.map(function(key) {
                return this.storage.get(this.makePath(path + key), maxAge).then(function(o) {
                  if (typeof(o.body) === 'string') {
                    try {
                      o.body = JSON.parse(o.body);
                    } catch (e) {}
                  }
                  if (typeof(o.body) === 'object') {
                    r.body[key] = o.body;
                  }
                });
              }.bind(this));
              return Promise.all(calls).then(function() {
                return r.body;
              });
            }
          }.bind(this));
        },
        getFile: function(path, maxAge) {
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.getFile must be a string');
          }
          return this.storage.get(this.makePath(path), maxAge).then(function(r) {
            return {
              data: r.body,
              contentType: r.contentType,
              revision: r.revision
            };
          });
        },
        storeFile: function(mimeType, path, body) {
          if (typeof(mimeType) !== 'string') {
            return Promise.reject('Argument \'mimeType\' of baseClient.storeFile must be a string');
          }
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.storeFile must be a string');
          }
          if (typeof(body) !== 'string' && typeof(body) !== 'object') {
            return Promise.reject('Argument \'body\' of baseClient.storeFile must be a string, ArrayBuffer, or ArrayBufferView');
          }
          if (!this.storage.access.checkPathPermission(this.makePath(path), 'rw')) {
            console.warn('WARNING: Editing a document to which only read access (\'r\') was claimed');
          }
          return this.storage.put(this.makePath(path), body, mimeType).then(function(r) {
            if (r.statusCode === 200 || r.statusCode === 201) {
              return r.revision;
            } else {
              return Promise.reject("Request (PUT " + this.makePath(path) + ") failed with status: " + r.statusCode);
            }
          }.bind(this));
        },
        getObject: function(path, maxAge) {
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.getObject must be a string');
          }
          return this.storage.get(this.makePath(path), maxAge).then(function(r) {
            if (typeof(r.body) === 'object') {
              return r.body;
            } else if (typeof(r.body) === 'string') {
              try {
                return JSON.parse(r.body);
              } catch (e) {
                throw "Not valid JSON: " + this.makePath(path);
              }
            } else if (typeof(r.body) !== 'undefined' && r.statusCode === 200) {
              return Promise.reject("Not an object: " + this.makePath(path));
            }
          }.bind(this));
        },
        storeObject: function(typeAlias, path, object) {
          if (typeof(typeAlias) !== 'string') {
            return Promise.reject('Argument \'typeAlias\' of baseClient.storeObject must be a string');
          }
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.storeObject must be a string');
          }
          if (typeof(object) !== 'object') {
            return Promise.reject('Argument \'object\' of baseClient.storeObject must be an object');
          }
          this._attachType(object, typeAlias);
          try {
            var validationResult = this.validate(object);
            if (!validationResult.valid) {
              return Promise.reject(validationResult);
            }
          } catch (exc) {
            return Promise.reject(exc);
          }
          return this.storage.put(this.makePath(path), JSON.stringify(object), 'application/json; charset=UTF-8').then(function(r) {
            if (r.statusCode === 200 || r.statusCode === 201) {
              return r.revision;
            } else {
              return Promise.reject("Request (PUT " + this.makePath(path) + ") failed with status: " + r.statusCode);
            }
          }.bind(this));
        },
        remove: function(path) {
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.remove must be a string');
          }
          if (!this.storage.access.checkPathPermission(this.makePath(path), 'rw')) {
            console.warn('WARNING: Removing a document to which only read access (\'r\') was claimed');
          }
          return this.storage.delete(this.makePath(path));
        },
        cache: function(path, strategy) {
          if (typeof(path) !== 'string') {
            throw 'Argument \'path\' of baseClient.cache must be a string';
          }
          if (strategy === false) {
            deprecate('caching strategy <false>', '<"FLUSH">');
            strategy = 'FLUSH';
          } else if (strategy === undefined) {
            strategy = 'ALL';
          } else if (typeof(strategy) !== 'string') {
            deprecate('that caching strategy', '<"ALL">');
            strategy = 'ALL';
          }
          if (strategy !== 'FLUSH' && strategy !== 'SEEN' && strategy !== 'ALL') {
            throw 'Argument \'strategy\' of baseclient.cache must be one of ' + '["FLUSH", "SEEN", "ALL"]';
          }
          this.storage.caching.set(this.makePath(path), strategy);
          return this;
        },
        flush: function(path) {
          return this.storage.local.flush(path);
        },
        makePath: function(path) {
          return this.base + (path || '');
        },
        _fireChange: function(event) {
          if (RemoteStorage.config.changeEvents[event.origin]) {
            ['new', 'old', 'lastCommon'].forEach(function(fieldNamePrefix) {
              if ((!event[fieldNamePrefix + 'ContentType']) || (/^application\/(.*)json(.*)/.exec(event[fieldNamePrefix + 'ContentType']))) {
                if (typeof(event[fieldNamePrefix + 'Value']) === 'string') {
                  try {
                    event[fieldNamePrefix + 'Value'] = JSON.parse(event[fieldNamePrefix + 'Value']);
                  } catch (e) {}
                }
              }
            });
            this._emit('change', event);
          }
        },
        _cleanPath: RemoteStorage.util.cleanPath,
        getItemURL: function(path) {
          if (typeof(path) !== 'string') {
            throw 'Argument \'path\' of baseClient.getItemURL must be a string';
          }
          if (this.storage.connected) {
            path = this._cleanPath(this.makePath(path));
            return this.storage.remote.href + path;
          } else {
            return undefined;
          }
        },
        uuid: function() {
          return Math.uuid();
        }
      };
      RS.BaseClient._rs_init = function() {
        RS.prototype.scope = function(path) {
          if (typeof(path) !== 'string') {
            throw 'Argument \'path\' of baseClient.scope must be a string';
          }
          if (!this.access.checkPathPermission(path, 'r')) {
            var escapedPath = path.replace(/(['\\])/g, '\\$1');
            console.warn('WARNING: please call remoteStorage.access.claim(\'' + escapedPath + '\', \'r\') (read only) or remoteStorage.access.claim(\'' + escapedPath + '\', \'rw\') (read/write) first');
          }
          return new RS.BaseClient(this, path);
        };
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      RemoteStorage.BaseClient.Types = {
        uris: {},
        schemas: {},
        aliases: {},
        declare: function(moduleName, alias, uri, schema) {
          var fullAlias = moduleName + '/' + alias;
          if (schema.extends) {
            var extendedAlias;
            var parts = schema.extends.split('/');
            if (parts.length === 1) {
              extendedAlias = moduleName + '/' + parts.shift();
            } else {
              extendedAlias = parts.join('/');
            }
            var extendedUri = this.uris[extendedAlias];
            if (!extendedUri) {
              throw "Type '" + fullAlias + "' tries to extend unknown schema '" + extendedAlias + "'";
            }
            schema.extends = this.schemas[extendedUri];
          }
          this.uris[fullAlias] = uri;
          this.aliases[uri] = fullAlias;
          this.schemas[uri] = schema;
        },
        resolveAlias: function(alias) {
          return this.uris[alias];
        },
        getSchema: function(uri) {
          return this.schemas[uri];
        },
        inScope: function(moduleName) {
          var ml = moduleName.length;
          var schemas = {};
          for (var alias in this.uris) {
            if (alias.substr(0, ml + 1) === moduleName + '/') {
              var uri = this.uris[alias];
              schemas[uri] = this.schemas[uri];
            }
          }
          return schemas;
        }
      };
      var SchemaNotFound = function(uri) {
        var error = new Error("Schema not found: " + uri);
        error.name = "SchemaNotFound";
        return error;
      };
      SchemaNotFound.prototype = Error.prototype;
      RemoteStorage.BaseClient.Types.SchemaNotFound = SchemaNotFound;
      RemoteStorage.BaseClient.prototype.extend({
        declareType: function(alias, uri, schema) {
          if (!schema) {
            schema = uri;
            uri = this._defaultTypeURI(alias);
          }
          RemoteStorage.BaseClient.Types.declare(this.moduleName, alias, uri, schema);
        },
        validate: function(object) {
          var schema = RemoteStorage.BaseClient.Types.getSchema(object['@context']);
          if (schema) {
            return tv4.validateResult(object, schema);
          } else {
            throw new SchemaNotFound(object['@context']);
          }
        },
        _defaultTypeURI: function(alias) {
          return 'http://remotestorage.io/spec/modules/' + encodeURIComponent(this.moduleName) + '/' + encodeURIComponent(alias);
        },
        _attachType: function(object, alias) {
          object['@context'] = RemoteStorage.BaseClient.Types.resolveAlias(this.moduleName + '/' + alias) || this._defaultTypeURI(alias);
        }
      });
      Object.defineProperty(RemoteStorage.BaseClient.prototype, 'schemas', {
        configurable: true,
        get: function() {
          return RemoteStorage.BaseClient.Types.inScope(this.moduleName);
        }
      });
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var SETTINGS_KEY = "remotestorage:caching";
      var containingFolder = RemoteStorage.util.containingFolder;
      RemoteStorage.Caching = function() {
        this.reset();
      };
      RemoteStorage.Caching.prototype = {
        pendingActivations: [],
        set: function(path, value) {
          if (typeof(path) !== 'string') {
            throw new Error('path should be a string');
          }
          if (typeof(value) === 'undefined') {
            throw new Error("value should be 'FLUSH', 'SEEN', or 'ALL'");
          }
          this._rootPaths[path] = value;
          if (value === 'ALL') {
            if (this.activateHandler) {
              this.activateHandler(path);
            } else {
              this.pendingActivations.push(path);
            }
          }
        },
        enable: function(path) {
          this.set(path, 'ALL');
        },
        disable: function(path) {
          this.set(path, 'FLUSH');
        },
        onActivate: function(cb) {
          var i;
          RemoteStorage.log('[Caching] Setting activate handler', cb, this.pendingActivations);
          this.activateHandler = cb;
          for (i = 0; i < this.pendingActivations.length; i++) {
            cb(this.pendingActivations[i]);
          }
          delete this.pendingActivations;
        },
        checkPath: function(path) {
          if (this._rootPaths[path] !== undefined) {
            return this._rootPaths[path];
          } else if (path === '/') {
            return 'SEEN';
          } else {
            return this.checkPath(containingFolder(path));
          }
        },
        reset: function() {
          this._rootPaths = {};
        }
      };
      Object.defineProperty(RemoteStorage.prototype, 'caching', {
        configurable: true,
        get: function() {
          var caching = new RemoteStorage.Caching();
          Object.defineProperty(this, 'caching', {value: caching});
          return caching;
        }
      });
      RemoteStorage.Caching._rs_init = function() {};
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var syncInterval = 10000,
          backgroundSyncInterval = 60000,
          isBackground = false;
      var isFolder = RemoteStorage.util.isFolder;
      var isDocument = RemoteStorage.util.isDocument;
      var equal = RemoteStorage.util.equal;
      var deepClone = RemoteStorage.util.deepClone;
      var pathsFromRoot = RemoteStorage.util.pathsFromRoot;
      function taskFor(action, path, promise) {
        return {
          action: action,
          path: path,
          promise: promise
        };
      }
      function isStaleChild(node) {
        return node.remote && node.remote.revision && !node.remote.itemsMap && !node.remote.body;
      }
      function hasCommonRevision(node) {
        return node.common && node.common.revision;
      }
      function handleVisibility() {
        var hidden,
            visibilityChange,
            rs = this;
        function handleVisibilityChange(fg) {
          var oldValue,
              newValue;
          oldValue = rs.getCurrentSyncInterval();
          isBackground = !fg;
          newValue = rs.getCurrentSyncInterval();
          rs._emit('sync-interval-change', {
            oldValue: oldValue,
            newValue: newValue
          });
        }
        RemoteStorage.Env.on("background", function() {
          handleVisibilityChange(false);
        });
        RemoteStorage.Env.on("foreground", function() {
          handleVisibilityChange(true);
        });
      }
      function isValidInterval(interval) {
        return (typeof interval === 'number' && interval > 1000 && interval < 3600000);
      }
      RemoteStorage.Sync = function(setLocal, setRemote, setAccess, setCaching) {
        this.local = setLocal;
        this.local.onDiff(function(path) {
          this.addTask(path);
          this.doTasks();
        }.bind(this));
        this.remote = setRemote;
        this.access = setAccess;
        this.caching = setCaching;
        this._tasks = {};
        this._running = {};
        this._timeStarted = {};
        RemoteStorage.eventHandling(this, 'done', 'req-done');
        this.caching.onActivate(function(path) {
          this.addTask(path);
          this.doTasks();
        }.bind(this));
      };
      RemoteStorage.Sync.prototype = {
        now: function() {
          return new Date().getTime();
        },
        queueGetRequest: function(path) {
          var pending = Promise.defer();
          if (!this.remote.connected) {
            pending.reject('cannot fulfill maxAge requirement - remote is not connected');
          } else if (!this.remote.online) {
            pending.reject('cannot fulfill maxAge requirement - remote is not online');
          } else {
            this.addTask(path, function() {
              this.local.get(path).then(function(r) {
                return pending.resolve(r);
              });
            }.bind(this));
            this.doTasks();
          }
          return pending.promise;
        },
        corruptServerItemsMap: function(itemsMap, force02) {
          if ((typeof(itemsMap) !== 'object') || (Array.isArray(itemsMap))) {
            return true;
          }
          for (var itemName in itemsMap) {
            var item = itemsMap[itemName];
            if (typeof(item) !== 'object') {
              return true;
            }
            if (typeof(item.ETag) !== 'string') {
              return true;
            }
            if (isFolder(itemName)) {
              if (itemName.substring(0, itemName.length - 1).indexOf('/') !== -1) {
                return true;
              }
            } else {
              if (itemName.indexOf('/') !== -1) {
                return true;
              }
              if (force02) {
                if (typeof(item['Content-Type']) !== 'string') {
                  return true;
                }
                if (typeof(item['Content-Length']) !== 'number') {
                  return true;
                }
              }
            }
          }
          return false;
        },
        corruptItemsMap: function(itemsMap) {
          if ((typeof(itemsMap) !== 'object') || (Array.isArray(itemsMap))) {
            return true;
          }
          for (var itemName in itemsMap) {
            if (typeof(itemsMap[itemName]) !== 'boolean') {
              return true;
            }
          }
          return false;
        },
        corruptRevision: function(rev) {
          return ((typeof(rev) !== 'object') || (Array.isArray(rev)) || (rev.revision && typeof(rev.revision) !== 'string') || (rev.body && typeof(rev.body) !== 'string' && typeof(rev.body) !== 'object') || (rev.contentType && typeof(rev.contentType) !== 'string') || (rev.contentLength && typeof(rev.contentLength) !== 'number') || (rev.timestamp && typeof(rev.timestamp) !== 'number') || (rev.itemsMap && this.corruptItemsMap(rev.itemsMap)));
        },
        isCorrupt: function(node) {
          return ((typeof(node) !== 'object') || (Array.isArray(node)) || (typeof(node.path) !== 'string') || (this.corruptRevision(node.common)) || (node.local && this.corruptRevision(node.local)) || (node.remote && this.corruptRevision(node.remote)) || (node.push && this.corruptRevision(node.push)));
        },
        hasTasks: function() {
          return Object.getOwnPropertyNames(this._tasks).length > 0;
        },
        collectDiffTasks: function() {
          var num = 0;
          return this.local.forAllNodes(function(node) {
            if (num > 100) {
              return;
            }
            if (this.isCorrupt(node)) {
              RemoteStorage.log('[Sync] WARNING: corrupt node in local cache', node);
              if (typeof(node) === 'object' && node.path) {
                this.addTask(node.path);
                num++;
              }
            } else if (this.needsFetch(node) && this.access.checkPathPermission(node.path, 'r')) {
              this.addTask(node.path);
              num++;
            } else if (isDocument(node.path) && this.needsPush(node) && this.access.checkPathPermission(node.path, 'rw')) {
              this.addTask(node.path);
              num++;
            }
          }.bind(this)).then(function() {
            return num;
          }, function(err) {
            throw err;
          });
        },
        inConflict: function(node) {
          return (node.local && node.remote && (node.remote.body !== undefined || node.remote.itemsMap));
        },
        needsRefresh: function(node) {
          if (node.common) {
            if (!node.common.timestamp) {
              return true;
            }
            return (this.now() - node.common.timestamp > syncInterval);
          }
          return false;
        },
        needsFetch: function(node) {
          if (this.inConflict(node)) {
            return true;
          }
          if (node.common && node.common.itemsMap === undefined && node.common.body === undefined) {
            return true;
          }
          if (node.remote && node.remote.itemsMap === undefined && node.remote.body === undefined) {
            return true;
          }
          return false;
        },
        needsPush: function(node) {
          if (this.inConflict(node)) {
            return false;
          }
          if (node.local && !node.push) {
            return true;
          }
        },
        needsRemotePut: function(node) {
          return node.local && node.local.body;
        },
        needsRemoteDelete: function(node) {
          return node.local && node.local.body === false;
        },
        getParentPath: function(path) {
          var parts = path.match(/^(.*\/)([^\/]+\/?)$/);
          if (parts) {
            return parts[1];
          } else {
            throw new Error('Not a valid path: "' + path + '"');
          }
        },
        deleteChildPathsFromTasks: function() {
          for (var path in this._tasks) {
            paths = pathsFromRoot(path);
            for (var i = 1; i < paths.length; i++) {
              if (this._tasks[paths[i]]) {
                delete this._tasks[path];
              }
            }
          }
        },
        collectRefreshTasks: function() {
          return this.local.forAllNodes(function(node) {
            var parentPath;
            if (this.needsRefresh(node)) {
              try {
                parentPath = this.getParentPath(node.path);
              } catch (e) {}
              if (parentPath && this.access.checkPathPermission(parentPath, 'r')) {
                this.addTask(parentPath);
              } else if (this.access.checkPathPermission(node.path, 'r')) {
                this.addTask(node.path);
              }
            }
          }.bind(this)).then(function() {
            this.deleteChildPathsFromTasks();
          }.bind(this), function(err) {
            throw err;
          });
        },
        flush: function(nodes) {
          for (var path in nodes) {
            if (this.caching.checkPath(path) === 'FLUSH' && nodes[path] && !nodes[path].local) {
              RemoteStorage.log('[Sync] Flushing', path);
              nodes[path] = undefined;
            }
          }
          return nodes;
        },
        doTask: function(path) {
          return this.local.getNodes([path]).then(function(nodes) {
            var node = nodes[path];
            if (typeof(node) === 'undefined') {
              return taskFor('get', path, this.remote.get(path));
            } else if (isStaleChild(node)) {
              return taskFor('get', path, this.remote.get(path));
            } else if (this.needsRemotePut(node)) {
              node.push = deepClone(node.local);
              node.push.timestamp = this.now();
              return this.local.setNodes(this.flush(nodes)).then(function() {
                var options;
                if (hasCommonRevision(node)) {
                  options = {ifMatch: node.common.revision};
                } else {
                  options = {ifNoneMatch: '*'};
                }
                return taskFor('put', path, this.remote.put(path, node.push.body, node.push.contentType, options));
              }.bind(this));
            } else if (this.needsRemoteDelete(node)) {
              node.push = {
                body: false,
                timestamp: this.now()
              };
              return this.local.setNodes(this.flush(nodes)).then(function() {
                if (hasCommonRevision(node)) {
                  return taskFor('delete', path, this.remote.delete(path, {ifMatch: node.common.revision}));
                } else {
                  return taskFor('get', path, this.remote.get(path));
                }
              }.bind(this));
            } else if (hasCommonRevision(node)) {
              return taskFor('get', path, this.remote.get(path, {ifNoneMatch: node.common.revision}));
            } else {
              return taskFor('get', path, this.remote.get(path));
            }
          }.bind(this));
        },
        autoMergeFolder: function(node) {
          if (node.remote.itemsMap) {
            node.common = node.remote;
            delete node.remote;
            if (node.common.itemsMap) {
              for (var itemName in node.common.itemsMap) {
                if (!node.local.itemsMap[itemName]) {
                  node.local.itemsMap[itemName] = false;
                }
              }
              if (equal(node.local.itemsMap, node.common.itemsMap)) {
                delete node.local;
              }
            }
          }
          return node;
        },
        autoMergeDocument: function(node) {
          hasNoRemoteChanges = function(node) {
            if (node.remote && node.remote.revision && node.remote.revision !== node.common.revision) {
              return false;
            }
            return (node.common.body === undefined && node.remote.body === false) || (node.remote.body === node.common.body && node.remote.contentType === node.common.contentType);
          };
          mergeMutualDeletion = function(node) {
            if (node.remote && node.remote.body === false && node.local && node.local.body === false) {
              delete node.local;
            }
            return node;
          };
          if (hasNoRemoteChanges(node)) {
            node = mergeMutualDeletion(node);
            delete node.remote;
          } else if (node.remote.body !== undefined) {
            RemoteStorage.log('[Sync] Emitting keep/revert');
            this.local._emitChange({
              origin: 'conflict',
              path: node.path,
              oldValue: node.local.body,
              newValue: node.remote.body,
              lastCommonValue: node.common.body,
              oldContentType: node.local.contentType,
              newContentType: node.remote.contentType,
              lastCommonContentType: node.common.contentType
            });
            if (node.remote.body) {
              node.common = node.remote;
            } else {
              node.common = {};
            }
            delete node.remote;
            delete node.local;
          }
          return node;
        },
        autoMerge: function(node) {
          if (node.remote) {
            if (node.local) {
              if (isFolder(node.path)) {
                return this.autoMergeFolder(node);
              } else {
                return this.autoMergeDocument(node);
              }
            } else {
              if (isFolder(node.path)) {
                if (node.remote.itemsMap !== undefined) {
                  node.common = node.remote;
                  delete node.remote;
                }
              } else {
                if (node.remote.body !== undefined) {
                  var change = {
                    origin: 'remote',
                    path: node.path,
                    oldValue: (node.common.body === false ? undefined : node.common.body),
                    newValue: (node.remote.body === false ? undefined : node.remote.body),
                    oldContentType: node.common.contentType,
                    newContentType: node.remote.contentType
                  };
                  if (change.oldValue || change.newValue) {
                    this.local._emitChange(change);
                  }
                  if (!node.remote.body) {
                    return;
                  }
                  node.common = node.remote;
                  delete node.remote;
                }
              }
            }
          } else {
            if (node.common.body) {
              this.local._emitChange({
                origin: 'remote',
                path: node.path,
                oldValue: node.common.body,
                newValue: undefined,
                oldContentType: node.common.contentType,
                newContentType: undefined
              });
            }
            return undefined;
          }
          return node;
        },
        updateCommonTimestamp: function(path, revision) {
          return this.local.getNodes([path]).then(function(nodes) {
            if (nodes[path] && nodes[path].common && nodes[path].common.revision === revision) {
              nodes[path].common.timestamp = this.now();
            }
            return this.local.setNodes(this.flush(nodes));
          }.bind(this));
        },
        markChildren: function(path, itemsMap, changedNodes, missingChildren) {
          var paths = [];
          var meta = {};
          var recurse = {};
          for (var item in itemsMap) {
            paths.push(path + item);
            meta[path + item] = itemsMap[item];
          }
          for (var childName in missingChildren) {
            paths.push(path + childName);
          }
          return this.local.getNodes(paths).then(function(nodes) {
            var cachingStrategy;
            var node;
            nodeChanged = function(node, etag) {
              return node.common.revision !== etag && (!node.remote || node.remote.revision !== etag);
            };
            for (var nodePath in nodes) {
              node = nodes[nodePath];
              if (meta[nodePath]) {
                if (node && node.common) {
                  if (nodeChanged(node, meta[nodePath].ETag)) {
                    changedNodes[nodePath] = deepClone(node);
                    changedNodes[nodePath].remote = {
                      revision: meta[nodePath].ETag,
                      timestamp: this.now()
                    };
                    changedNodes[nodePath] = this.autoMerge(changedNodes[nodePath]);
                  }
                } else {
                  cachingStrategy = this.caching.checkPath(nodePath);
                  if (cachingStrategy === 'ALL') {
                    changedNodes[nodePath] = {
                      path: nodePath,
                      common: {timestamp: this.now()},
                      remote: {
                        revision: meta[nodePath].ETag,
                        timestamp: this.now()
                      }
                    };
                  }
                }
                if (changedNodes[nodePath] && meta[nodePath]['Content-Type']) {
                  changedNodes[nodePath].remote.contentType = meta[nodePath]['Content-Type'];
                }
                if (changedNodes[nodePath] && meta[nodePath]['Content-Length']) {
                  changedNodes[nodePath].remote.contentLength = meta[nodePath]['Content-Length'];
                }
              } else if (missingChildren[nodePath.substring(path.length)] && node && node.common) {
                if (node.common.itemsMap) {
                  for (var commonItem in node.common.itemsMap) {
                    recurse[nodePath + commonItem] = true;
                  }
                }
                if (node.local && node.local.itemsMap) {
                  for (var localItem in node.local.itemsMap) {
                    recurse[nodePath + localItem] = true;
                  }
                }
                if (node.remote || isFolder(nodePath)) {
                  changedNodes[nodePath] = undefined;
                } else {
                  changedNodes[nodePath] = this.autoMerge(node);
                  if (typeof changedNodes[nodePath] === 'undefined') {
                    var parentPath = this.getParentPath(nodePath);
                    var parentNode = changedNodes[parentPath];
                    var itemName = nodePath.substring(path.length);
                    if (parentNode && parentNode.local) {
                      delete parentNode.local.itemsMap[itemName];
                      if (equal(parentNode.local.itemsMap, parentNode.common.itemsMap)) {
                        delete parentNode.local;
                      }
                    }
                  }
                }
              }
            }
            return this.deleteRemoteTrees(Object.keys(recurse), changedNodes).then(function(changedObjs2) {
              return this.local.setNodes(this.flush(changedObjs2));
            }.bind(this));
          }.bind(this));
        },
        deleteRemoteTrees: function(paths, changedNodes) {
          if (paths.length === 0) {
            return Promise.resolve(changedNodes);
          }
          return this.local.getNodes(paths).then(function(nodes) {
            var subPaths = {};
            collectSubPaths = function(folder, path) {
              if (folder && folder.itemsMap) {
                for (var itemName in folder.itemsMap) {
                  subPaths[path + itemName] = true;
                }
              }
            };
            for (var path in nodes) {
              var node = nodes[path];
              if (!node) {
                continue;
              }
              if (isFolder(path)) {
                collectSubPaths(node.common, path);
                collectSubPaths(node.local, path);
              } else {
                if (node.common && typeof(node.common.body) !== undefined) {
                  changedNodes[path] = deepClone(node);
                  changedNodes[path].remote = {
                    body: false,
                    timestamp: this.now()
                  };
                  changedNodes[path] = this.autoMerge(changedNodes[path]);
                }
              }
            }
            return this.deleteRemoteTrees(Object.keys(subPaths), changedNodes).then(function(changedNodes2) {
              return this.local.setNodes(this.flush(changedNodes2));
            }.bind(this));
          }.bind(this));
        },
        completeFetch: function(path, bodyOrItemsMap, contentType, revision) {
          var paths;
          var parentPath;
          var pathsFromRootArr = pathsFromRoot(path);
          if (isFolder(path)) {
            paths = [path];
          } else {
            parentPath = pathsFromRootArr[1];
            paths = [path, parentPath];
          }
          return this.local.getNodes(paths).then(function(nodes) {
            var itemName;
            var missingChildren = {};
            var node = nodes[path];
            var parentNode;
            collectMissingChildren = function(folder) {
              if (folder && folder.itemsMap) {
                for (var itemName in folder.itemsMap) {
                  if (!bodyOrItemsMap[itemName]) {
                    missingChildren[itemName] = true;
                  }
                }
              }
            };
            if (typeof(node) !== 'object' || node.path !== path || typeof(node.common) !== 'object') {
              node = {
                path: path,
                common: {}
              };
              nodes[path] = node;
            }
            node.remote = {
              revision: revision,
              timestamp: this.now()
            };
            if (isFolder(path)) {
              collectMissingChildren(node.common);
              collectMissingChildren(node.remote);
              node.remote.itemsMap = {};
              for (itemName in bodyOrItemsMap) {
                node.remote.itemsMap[itemName] = true;
              }
            } else {
              node.remote.body = bodyOrItemsMap;
              node.remote.contentType = contentType;
              parentNode = nodes[parentPath];
              if (parentNode && parentNode.local && parentNode.local.itemsMap) {
                itemName = path.substring(parentPath.length);
                parentNode.local.itemsMap[itemName] = true;
                if (equal(parentNode.local.itemsMap, parentNode.common.itemsMap)) {
                  delete parentNode.local;
                }
              }
            }
            nodes[path] = this.autoMerge(node);
            return {
              toBeSaved: nodes,
              missingChildren: missingChildren
            };
          }.bind(this));
        },
        completePush: function(path, action, conflict, revision) {
          return this.local.getNodes([path]).then(function(nodes) {
            var node = nodes[path];
            if (!node.push) {
              this.stopped = true;
              throw new Error('completePush called but no push version!');
            }
            if (conflict) {
              RemoteStorage.log('[Sync] We have a conflict');
              if (!node.remote || node.remote.revision !== revision) {
                node.remote = {
                  revision: revision || 'conflict',
                  timestamp: this.now()
                };
                delete node.push;
              }
              nodes[path] = this.autoMerge(node);
            } else {
              node.common = {
                revision: revision,
                timestamp: this.now()
              };
              if (action === 'put') {
                node.common.body = node.push.body;
                node.common.contentType = node.push.contentType;
                if (equal(node.local.body, node.push.body) && node.local.contentType === node.push.contentType) {
                  delete node.local;
                }
                delete node.push;
              } else if (action === 'delete') {
                if (node.local.body === false) {
                  nodes[path] = undefined;
                } else {
                  delete node.push;
                }
              }
            }
            return this.local.setNodes(this.flush(nodes));
          }.bind(this));
        },
        dealWithFailure: function(path, action, statusMeaning) {
          return this.local.getNodes([path]).then(function(nodes) {
            if (nodes[path]) {
              delete nodes[path].push;
              return this.local.setNodes(this.flush(nodes));
            }
          }.bind(this));
        },
        interpretStatus: function(statusCode) {
          if (statusCode === 'offline' || statusCode === 'timeout') {
            return {
              successful: false,
              networkProblems: true,
              statusCode: statusCode
            };
          }
          var series = Math.floor(statusCode / 100);
          return {
            successful: (series === 2 || statusCode === 304 || statusCode === 412 || statusCode === 404),
            conflict: (statusCode === 412),
            unAuth: ((statusCode === 401 && this.remote.token !== RemoteStorage.Authorize.IMPLIED_FAKE_TOKEN) || statusCode === 402 || statusCode === 403),
            notFound: (statusCode === 404),
            changed: (statusCode !== 304),
            statusCode: statusCode
          };
        },
        handleGetResponse: function(path, status, bodyOrItemsMap, contentType, revision) {
          if (status.notFound) {
            if (isFolder(path)) {
              bodyOrItemsMap = {};
            } else {
              bodyOrItemsMap = false;
            }
          }
          if (status.changed) {
            return this.completeFetch(path, bodyOrItemsMap, contentType, revision).then(function(dataFromFetch) {
              if (isFolder(path)) {
                if (this.corruptServerItemsMap(bodyOrItemsMap)) {
                  RemoteStorage.log('[Sync] WARNING: Discarding corrupt folder description from server for ' + path);
                  return false;
                } else {
                  return this.markChildren(path, bodyOrItemsMap, dataFromFetch.toBeSaved, dataFromFetch.missingChildren).then(function() {
                    return true;
                  });
                }
              } else {
                return this.local.setNodes(this.flush(dataFromFetch.toBeSaved)).then(function() {
                  return true;
                });
              }
            }.bind(this));
          } else {
            return this.updateCommonTimestamp(path, revision).then(function() {
              return true;
            });
          }
        },
        handleResponse: function(path, action, r) {
          var status = this.interpretStatus(r.statusCode);
          if (status.successful) {
            if (action === 'get') {
              return this.handleGetResponse(path, status, r.body, r.contentType, r.revision);
            } else if (action === 'put' || action === 'delete') {
              return this.completePush(path, action, status.conflict, r.revision).then(function() {
                return true;
              });
            } else {
              throw new Error('cannot handle response for unknown action', action);
            }
          } else {
            var error;
            if (status.unAuth) {
              error = new RemoteStorage.Unauthorized();
            } else if (status.networkProblems) {
              error = new RemoteStorage.SyncError('Network request failed.');
              this.remote.online = false;
            } else {
              error = new Error('HTTP response code ' + status.statusCode + ' received.');
            }
            return this.dealWithFailure(path, action, status).then(function() {
              remoteStorage._emit('error', error);
              throw error;
            });
          }
        },
        numThreads: 10,
        finishTask: function(task) {
          if (task.action === undefined) {
            delete this._running[task.path];
            return;
          }
          var self = this;
          return task.promise.then(function(r) {
            return self.handleResponse(task.path, task.action, r);
          }, function(err) {
            RemoteStorage.log('[Sync] wireclient rejects its promise!', task.path, task.action, err);
            return self.handleResponse(task.path, task.action, {statusCode: 'offline'});
          }).then(function(completed) {
            delete self._timeStarted[task.path];
            delete self._running[task.path];
            self.remote.online = true;
            if (completed) {
              if (self._tasks[task.path]) {
                for (i = 0; i < self._tasks[task.path].length; i++) {
                  self._tasks[task.path][i]();
                }
                delete self._tasks[task.path];
              }
            }
            self._emit('req-done');
            self.collectTasks(false).then(function() {
              if (!self.hasTasks() || self.stopped) {
                RemoteStorage.log('[Sync] Sync is done! Reschedule?', Object.getOwnPropertyNames(self._tasks).length, self.stopped);
                if (!self.done) {
                  self.done = true;
                  self._emit('done');
                }
              } else {
                setTimeout(function() {
                  self.doTasks();
                }, 10);
              }
            });
          }, function(err) {
            console.error('[Sync] Error', err);
            delete self._timeStarted[task.path];
            delete self._running[task.path];
            self._emit('req-done');
            if (!self.done) {
              self.done = true;
              self._emit('done');
            }
          });
        },
        doTasks: function() {
          var numToHave,
              numAdded = 0,
              numToAdd,
              path;
          if (this.remote.connected) {
            if (this.remote.online) {
              numToHave = this.numThreads;
            } else {
              numToHave = 1;
            }
          } else {
            numToHave = 0;
          }
          numToAdd = numToHave - Object.getOwnPropertyNames(this._running).length;
          if (numToAdd <= 0) {
            return true;
          }
          for (path in this._tasks) {
            if (!this._running[path]) {
              this._timeStarted = this.now();
              this._running[path] = this.doTask(path);
              this._running[path].then(this.finishTask.bind(this));
              numAdded++;
              if (numAdded >= numToAdd) {
                return true;
              }
            }
          }
          return (numAdded >= numToAdd);
        },
        collectTasks: function(alsoCheckRefresh) {
          if (this.hasTasks() || this.stopped) {
            return Promise.resolve();
          }
          return this.collectDiffTasks().then(function(numDiffs) {
            if (numDiffs || alsoCheckRefresh === false) {
              return Promise.resolve();
            } else {
              return this.collectRefreshTasks();
            }
          }.bind(this), function(err) {
            throw err;
          });
        },
        addTask: function(path, cb) {
          if (!this._tasks[path]) {
            this._tasks[path] = [];
          }
          if (typeof(cb) === 'function') {
            this._tasks[path].push(cb);
          }
        },
        sync: function() {
          this.done = false;
          if (!this.doTasks()) {
            return this.collectTasks().then(function() {
              try {
                this.doTasks();
              } catch (e) {
                console.error('[Sync] doTasks error', e);
              }
            }.bind(this), function(e) {
              console.error('[Sync] Sync error', e);
              throw new Error('Local cache unavailable');
            });
          } else {
            return Promise.resolve();
          }
        }
      };
      RemoteStorage.prototype.getSyncInterval = function() {
        return syncInterval;
      };
      RemoteStorage.prototype.setSyncInterval = function(interval) {
        if (!isValidInterval(interval)) {
          throw interval + " is not a valid sync interval";
        }
        var oldValue = syncInterval;
        syncInterval = parseInt(interval, 10);
        this._emit('sync-interval-change', {
          oldValue: oldValue,
          newValue: interval
        });
      };
      RemoteStorage.prototype.getBackgroundSyncInterval = function() {
        return backgroundSyncInterval;
      };
      RemoteStorage.prototype.setBackgroundSyncInterval = function(interval) {
        if (!isValidInterval(interval)) {
          throw interval + " is not a valid sync interval";
        }
        var oldValue = backgroundSyncInterval;
        backgroundSyncInterval = parseInt(interval, 10);
        this._emit('sync-interval-change', {
          oldValue: oldValue,
          newValue: interval
        });
      };
      RemoteStorage.prototype.getCurrentSyncInterval = function() {
        return isBackground ? backgroundSyncInterval : syncInterval;
      };
      var SyncError = function(originalError) {
        var msg = 'Sync failed: ';
        if (typeof(originalError) === 'object' && 'message' in originalError) {
          msg += originalError.message;
        } else {
          msg += originalError;
        }
        this.originalError = originalError;
        this.message = msg;
      };
      SyncError.prototype = new Error();
      SyncError.prototype.constructor = SyncError;
      RemoteStorage.SyncError = SyncError;
      RemoteStorage.prototype.syncCycle = function() {
        if (this.sync.stopped) {
          return;
        }
        this.sync.on('done', function() {
          RemoteStorage.log('[Sync] Sync done. Setting timer to', this.getCurrentSyncInterval());
          if (!this.sync.stopped) {
            if (this._syncTimer) {
              clearTimeout(this._syncTimer);
            }
            this._syncTimer = setTimeout(this.sync.sync.bind(this.sync), this.getCurrentSyncInterval());
          }
        }.bind(this));
        this.sync.sync();
      };
      RemoteStorage.prototype.stopSync = function() {
        if (this.sync) {
          RemoteStorage.log('[Sync] Stopping sync');
          this.sync.stopped = true;
        } else {
          RemoteStorage.log('[Sync] Will instantiate sync stopped');
          this.syncStopped = true;
        }
      };
      RemoteStorage.prototype.startSync = function() {
        this.sync.stopped = false;
        this.syncStopped = false;
        this.sync.sync();
      };
      var syncCycleCb;
      RemoteStorage.Sync._rs_init = function(remoteStorage) {
        syncCycleCb = function() {
          RemoteStorage.log('[Sync] syncCycleCb calling syncCycle');
          if (RemoteStorage.Env.isBrowser()) {
            handleVisibility.bind(remoteStorage)();
          }
          if (!remoteStorage.sync) {
            remoteStorage.sync = new RemoteStorage.Sync(remoteStorage.local, remoteStorage.remote, remoteStorage.access, remoteStorage.caching);
            if (remoteStorage.syncStopped) {
              RemoteStorage.log('[Sync] Instantiating sync stopped');
              remoteStorage.sync.stopped = true;
              delete remoteStorage.syncStopped;
            }
          }
          RemoteStorage.log('[Sync] syncCycleCb calling syncCycle');
          remoteStorage.syncCycle();
        };
        remoteStorage.on('ready', syncCycleCb);
      };
      RemoteStorage.Sync._rs_cleanup = function(remoteStorage) {
        remoteStorage.stopSync();
        remoteStorage.removeEventListener('ready', syncCycleCb);
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function() {
      var isFolder = RemoteStorage.util.isFolder;
      var isDocument = RemoteStorage.util.isDocument;
      var deepClone = RemoteStorage.util.deepClone;
      var equal = RemoteStorage.util.equal;
      function getLatest(node) {
        if (typeof(node) !== 'object' || typeof(node.path) !== 'string') {
          return;
        }
        if (isFolder(node.path)) {
          if (node.local && node.local.itemsMap) {
            return node.local;
          }
          if (node.common && node.common.itemsMap) {
            return node.common;
          }
        } else {
          if (node.local && node.local.body && node.local.contentType) {
            return node.local;
          }
          if (node.common && node.common.body && node.common.contentType) {
            return node.common;
          }
          if (node.body && node.contentType) {
            return {
              body: node.body,
              contentType: node.contentType
            };
          }
        }
      }
      function isOutdated(nodes, maxAge) {
        var path,
            node;
        for (path in nodes) {
          if (nodes[path] && nodes[path].remote) {
            return true;
          }
          nodeVersion = getLatest(nodes[path]);
          if (nodeVersion && nodeVersion.timestamp && (new Date().getTime()) - nodeVersion.timestamp <= maxAge) {
            return false;
          } else if (!nodeVersion) {
            return true;
          }
        }
        return true;
      }
      var pathsFromRoot = RemoteStorage.util.pathsFromRoot;
      function makeNode(path) {
        var node = {
          path: path,
          common: {}
        };
        if (isFolder(path)) {
          node.common.itemsMap = {};
        }
        return node;
      }
      function updateFolderNodeWithItemName(node, itemName) {
        if (!node.common) {
          node.common = {itemsMap: {}};
        }
        if (!node.common.itemsMap) {
          node.common.itemsMap = {};
        }
        if (!node.local) {
          node.local = deepClone(node.common);
        }
        if (!node.local.itemsMap) {
          node.local.itemsMap = node.common.itemsMap;
        }
        node.local.itemsMap[itemName] = true;
        return node;
      }
      var methods = {
        get: function(path, maxAge, queueGetRequest) {
          var self = this;
          if (typeof(maxAge) === 'number') {
            return self.getNodes(pathsFromRoot(path)).then(function(objs) {
              var node = getLatest(objs[path]);
              if (isOutdated(objs, maxAge)) {
                return queueGetRequest(path);
              } else if (node) {
                return {
                  statusCode: 200,
                  body: node.body || node.itemsMap,
                  contentType: node.contentType
                };
              } else {
                return {statusCode: 404};
              }
            });
          } else {
            return self.getNodes([path]).then(function(objs) {
              var node = getLatest(objs[path]);
              if (node) {
                if (isFolder(path)) {
                  for (var i in node.itemsMap) {
                    if (node.itemsMap.hasOwnProperty(i) && node.itemsMap[i] === false) {
                      delete node.itemsMap[i];
                    }
                  }
                }
                return {
                  statusCode: 200,
                  body: node.body || node.itemsMap,
                  contentType: node.contentType
                };
              } else {
                return {statusCode: 404};
              }
            });
          }
        },
        put: function(path, body, contentType) {
          var paths = pathsFromRoot(path);
          var self = this;
          function _processNodes(paths, nodes) {
            try {
              for (var i = 0,
                  len = paths.length; i < len; i++) {
                var path = paths[i];
                var node = nodes[path];
                var previous;
                if (!node) {
                  nodes[path] = node = makeNode(path);
                }
                if (i === 0) {
                  previous = getLatest(node);
                  node.local = {
                    body: body,
                    contentType: contentType,
                    previousBody: (previous ? previous.body : undefined),
                    previousContentType: (previous ? previous.contentType : undefined)
                  };
                } else {
                  var itemName = paths[i - 1].substring(path.length);
                  node = updateFolderNodeWithItemName(node, itemName);
                }
              }
              return nodes;
            } catch (e) {
              RemoteStorage.log('[Cachinglayer] Error during PUT', nodes, i, e);
              throw e;
            }
          }
          return this._updateNodes(paths, _processNodes);
        },
        delete: function(path) {
          var paths = pathsFromRoot(path);
          return this._updateNodes(paths, function(paths, nodes) {
            for (var i = 0,
                len = paths.length; i < len; i++) {
              var path = paths[i];
              var node = nodes[path];
              if (!node) {
                throw new Error('Cannot delete non-existing node ' + path);
              }
              if (i === 0) {
                previous = getLatest(node);
                node.local = {
                  body: false,
                  previousBody: (previous ? previous.body : undefined),
                  previousContentType: (previous ? previous.contentType : undefined)
                };
              } else {
                if (!node.local) {
                  node.local = deepClone(node.common);
                }
                var itemName = paths[i - 1].substring(path.length);
                delete node.local.itemsMap[itemName];
                if (Object.getOwnPropertyNames(node.local.itemsMap).length > 0) {
                  break;
                }
              }
            }
            return nodes;
          });
        },
        flush: function(path) {
          var self = this;
          return self._getAllDescendentPaths(path).then(function(paths) {
            return self.getNodes(paths);
          }).then(function(nodes) {
            for (var path in nodes) {
              var node = nodes[path];
              if (node && node.common && node.local) {
                self._emitChange({
                  path: node.path,
                  origin: 'local',
                  oldValue: (node.local.body === false ? undefined : node.local.body),
                  newValue: (node.common.body === false ? undefined : node.common.body)
                });
              }
              nodes[path] = undefined;
            }
            return self.setNodes(nodes);
          });
        },
        _emitChange: function(obj) {
          if (RemoteStorage.config.changeEvents[obj.origin]) {
            this._emit('change', obj);
          }
        },
        fireInitial: function() {
          if (!RemoteStorage.config.changeEvents.local) {
            return;
          }
          var self = this;
          self.forAllNodes(function(node) {
            var latest;
            if (isDocument(node.path)) {
              latest = getLatest(node);
              if (latest) {
                self._emitChange({
                  path: node.path,
                  origin: 'local',
                  oldValue: undefined,
                  oldContentType: undefined,
                  newValue: latest.body,
                  newContentType: latest.contentType
                });
              }
            }
          }).then(function() {
            self._emit('local-events-done');
          });
        },
        onDiff: function(diffHandler) {
          this.diffHandler = diffHandler;
        },
        migrate: function(node) {
          if (typeof(node) === 'object' && !node.common) {
            node.common = {};
            if (typeof(node.path) === 'string') {
              if (node.path.substr(-1) === '/' && typeof(node.body) === 'object') {
                node.common.itemsMap = node.body;
              }
            } else {
              if (!node.local) {
                node.local = {};
              }
              node.local.body = node.body;
              node.local.contentType = node.contentType;
            }
          }
          return node;
        },
        _updateNodesRunning: false,
        _updateNodesQueued: [],
        _updateNodes: function(paths, _processNodes) {
          var pending = Promise.defer();
          this._doUpdateNodes(paths, _processNodes, pending);
          return pending.promise;
        },
        _doUpdateNodes: function(paths, _processNodes, promise) {
          var self = this;
          if (self._updateNodesRunning) {
            self._updateNodesQueued.push({
              paths: paths,
              cb: _processNodes,
              promise: promise
            });
            return;
          } else {
            self._updateNodesRunning = true;
          }
          self.getNodes(paths).then(function(nodes) {
            var existingNodes = deepClone(nodes);
            var changeEvents = [];
            var node;
            nodes = _processNodes(paths, nodes);
            for (var path in nodes) {
              node = nodes[path];
              if (equal(node, existingNodes[path])) {
                delete nodes[path];
              } else if (isDocument(path)) {
                changeEvents.push({
                  path: path,
                  origin: 'window',
                  oldValue: node.local.previousBody,
                  newValue: node.local.body === false ? undefined : node.local.body,
                  oldContentType: node.local.previousContentType,
                  newContentType: node.local.contentType
                });
                delete node.local.previousBody;
                delete node.local.previousContentType;
              }
            }
            self.setNodes(nodes).then(function() {
              self._emitChangeEvents(changeEvents);
              promise.resolve({statusCode: 200});
            });
          }).then(function() {
            return Promise.resolve();
          }, function(err) {
            promise.reject(err);
          }).then(function() {
            self._updateNodesRunning = false;
            var nextJob = self._updateNodesQueued.shift();
            if (nextJob) {
              self._doUpdateNodes(nextJob.paths, nextJob.cb, nextJob.promise);
            }
          });
        },
        _emitChangeEvents: function(events) {
          for (var i = 0,
              len = events.length; i < len; i++) {
            this._emitChange(events[i]);
            if (this.diffHandler) {
              this.diffHandler(events[i].path);
            }
          }
        },
        _getAllDescendentPaths: function(path) {
          var self = this;
          if (isFolder(path)) {
            return self.getNodes([path]).then(function(nodes) {
              var allPaths = [path];
              var latest = getLatest(nodes[path]);
              var itemNames = Object.keys(latest.itemsMap);
              var calls = itemNames.map(function(itemName) {
                return self._getAllDescendentPaths(path + itemName).then(function(paths) {
                  for (var i = 0,
                      len = paths.length; i < len; i++) {
                    allPaths.push(paths[i]);
                  }
                });
              });
              return Promise.all(calls).then(function() {
                return allPaths;
              });
            });
          } else {
            return Promise.resolve([path]);
          }
        },
        _getInternals: function() {
          return {
            getLatest: getLatest,
            makeNode: makeNode,
            isOutdated: isOutdated
          };
        }
      };
      RemoteStorage.cachingLayer = function(object) {
        for (var key in methods) {
          object[key] = methods[key];
        }
      };
    })();
    (function(global) {
      var RS = RemoteStorage;
      var DB_VERSION = 2;
      var DEFAULT_DB_NAME = 'remotestorage';
      var DEFAULT_DB;
      RS.IndexedDB = function(database) {
        this.db = database || DEFAULT_DB;
        if (!this.db) {
          RemoteStorage.log("[IndexedDB] Failed to open DB");
          return undefined;
        }
        RS.cachingLayer(this);
        RS.eventHandling(this, 'change', 'local-events-done');
        this.getsRunning = 0;
        this.putsRunning = 0;
        this.changesQueued = {};
        this.changesRunning = {};
      };
      RS.IndexedDB.prototype = {
        getNodes: function(paths) {
          var misses = [],
              fromCache = {};
          for (var i = 0,
              len = paths.length; i < len; i++) {
            if (this.changesQueued[paths[i]] !== undefined) {
              fromCache[paths[i]] = RemoteStorage.util.deepClone(this.changesQueued[paths[i]] || undefined);
            } else if (this.changesRunning[paths[i]] !== undefined) {
              fromCache[paths[i]] = RemoteStorage.util.deepClone(this.changesRunning[paths[i]] || undefined);
            } else {
              misses.push(paths[i]);
            }
          }
          if (misses.length > 0) {
            return this.getNodesFromDb(misses).then(function(nodes) {
              for (var i in fromCache) {
                nodes[i] = fromCache[i];
              }
              return nodes;
            });
          } else {
            return Promise.resolve(fromCache);
          }
        },
        setNodes: function(nodes) {
          for (var i in nodes) {
            this.changesQueued[i] = nodes[i] || false;
          }
          this.maybeFlush();
          return Promise.resolve();
        },
        maybeFlush: function() {
          if (this.putsRunning === 0) {
            this.flushChangesQueued();
          } else {
            if (!this.commitSlownessWarning) {
              this.commitSlownessWarning = setInterval(function() {
                console.log('WARNING: waited more than 10 seconds for previous commit to finish');
              }, 10000);
            }
          }
        },
        flushChangesQueued: function() {
          if (this.commitSlownessWarning) {
            clearInterval(this.commitSlownessWarning);
            this.commitSlownessWarning = null;
          }
          if (Object.keys(this.changesQueued).length > 0) {
            this.changesRunning = this.changesQueued;
            this.changesQueued = {};
            this.setNodesInDb(this.changesRunning).then(this.flushChangesQueued.bind(this));
          }
        },
        getNodesFromDb: function(paths) {
          var pending = Promise.defer();
          var transaction = this.db.transaction(['nodes'], 'readonly');
          var nodes = transaction.objectStore('nodes');
          var retrievedNodes = {};
          var startTime = new Date().getTime();
          this.getsRunning++;
          paths.map(function(path, i) {
            nodes.get(path).onsuccess = function(evt) {
              retrievedNodes[path] = evt.target.result;
            };
          });
          transaction.oncomplete = function() {
            pending.resolve(retrievedNodes);
            this.getsRunning--;
          }.bind(this);
          transaction.onerror = transaction.onabort = function() {
            pending.reject('get transaction error/abort');
            this.getsRunning--;
          }.bind(this);
          return pending.promise;
        },
        setNodesInDb: function(nodes) {
          var pending = Promise.defer();
          var transaction = this.db.transaction(['nodes'], 'readwrite');
          var nodesStore = transaction.objectStore('nodes');
          var startTime = new Date().getTime();
          this.putsRunning++;
          RemoteStorage.log('[IndexedDB] Starting put', nodes, this.putsRunning);
          for (var path in nodes) {
            var node = nodes[path];
            if (typeof(node) === 'object') {
              try {
                nodesStore.put(node);
              } catch (e) {
                RemoteStorage.log('[IndexedDB] Error while putting', node, e);
                throw e;
              }
            } else {
              try {
                nodesStore.delete(path);
              } catch (e) {
                RemoteStorage.log('[IndexedDB] Error while removing', nodesStore, node, e);
                throw e;
              }
            }
          }
          transaction.oncomplete = function() {
            this.putsRunning--;
            RemoteStorage.log('[IndexedDB] Finished put', nodes, this.putsRunning, (new Date().getTime() - startTime) + 'ms');
            pending.resolve();
          }.bind(this);
          transaction.onerror = function() {
            this.putsRunning--;
            pending.reject('transaction error');
          }.bind(this);
          transaction.onabort = function() {
            pending.reject('transaction abort');
            this.putsRunning--;
          }.bind(this);
          return pending.promise;
        },
        reset: function(callback) {
          var dbName = this.db.name;
          var self = this;
          this.db.close();
          RS.IndexedDB.clean(this.db.name, function() {
            RS.IndexedDB.open(dbName, function(err, other) {
              if (err) {
                RemoteStorage.log('[IndexedDB] Error while resetting local storage', err);
              } else {
                self.db = other;
              }
              if (typeof callback === 'function') {
                callback(self);
              }
            });
          });
        },
        forAllNodes: function(cb) {
          var pending = Promise.defer();
          var transaction = this.db.transaction(['nodes'], 'readonly');
          var cursorReq = transaction.objectStore('nodes').openCursor();
          cursorReq.onsuccess = function(evt) {
            var cursor = evt.target.result;
            if (cursor) {
              cb(this.migrate(cursor.value));
              cursor.continue();
            } else {
              pending.resolve();
            }
          }.bind(this);
          return pending.promise;
        },
        closeDB: function() {
          this.db.close();
        }
      };
      RS.IndexedDB.open = function(name, callback) {
        var timer = setTimeout(function() {
          callback("timeout trying to open db");
        }, 10000);
        var req = indexedDB.open(name, DB_VERSION);
        req.onerror = function() {
          RemoteStorage.log('[IndexedDB] Opening DB failed', req);
          clearTimeout(timer);
          callback(req.error);
        };
        req.onupgradeneeded = function(event) {
          var db = req.result;
          RemoteStorage.log("[IndexedDB] Upgrade: from ", event.oldVersion, " to ", event.newVersion);
          if (event.oldVersion !== 1) {
            RemoteStorage.log("[IndexedDB] Creating object store: nodes");
            db.createObjectStore('nodes', {keyPath: 'path'});
          }
          RemoteStorage.log("[IndexedDB] Creating object store: changes");
          db.createObjectStore('changes', {keyPath: 'path'});
        };
        req.onsuccess = function() {
          clearTimeout(timer);
          callback(null, req.result);
        };
      };
      RS.IndexedDB.clean = function(databaseName, callback) {
        var req = indexedDB.deleteDatabase(databaseName);
        req.onsuccess = function() {
          RemoteStorage.log('[IndexedDB] Done removing DB');
          callback();
        };
        req.onerror = req.onabort = function(evt) {
          console.error('Failed to remove database "' + databaseName + '"', evt);
        };
      };
      RS.IndexedDB._rs_init = function(remoteStorage) {
        var pending = Promise.defer();
        RS.IndexedDB.open(DEFAULT_DB_NAME, function(err, db) {
          if (err) {
            pending.reject(err);
          } else {
            DEFAULT_DB = db;
            db.onerror = function() {
              remoteStorage._emit('error', err);
            };
            pending.resolve();
          }
        });
        return pending.promise;
      };
      RS.IndexedDB._rs_supported = function() {
        var pending = Promise.defer();
        global.indexedDB = global.indexedDB || global.webkitIndexedDB || global.mozIndexedDB || global.oIndexedDB || global.msIndexedDB;
        var poorIndexedDbSupport = false;
        if (typeof global.navigator !== 'undefined' && global.navigator.userAgent.match(/Android (2|3|4\.[0-3])/)) {
          if (!navigator.userAgent.match(/Chrome|Firefox/)) {
            poorIndexedDbSupport = true;
          }
        }
        if ('indexedDB' in global && !poorIndexedDbSupport) {
          try {
            var check = indexedDB.open("rs-check");
            check.onerror = function(event) {
              pending.reject();
            };
            check.onsuccess = function(event) {
              indexedDB.deleteDatabase("rs-check");
              pending.resolve();
            };
          } catch (e) {
            pending.reject();
          }
        } else {
          pending.reject();
        }
        return pending.promise;
      };
      RS.IndexedDB._rs_cleanup = function(remoteStorage) {
        var pending = Promise.defer();
        if (remoteStorage.local) {
          remoteStorage.local.closeDB();
        }
        RS.IndexedDB.clean(DEFAULT_DB_NAME, function() {
          pending.resolve();
        });
        return pending.promise;
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var NODES_PREFIX = "remotestorage:cache:nodes:";
      var CHANGES_PREFIX = "remotestorage:cache:changes:";
      RemoteStorage.LocalStorage = function() {
        RemoteStorage.cachingLayer(this);
        RemoteStorage.log('[LocalStorage] Registering events');
        RemoteStorage.eventHandling(this, 'change', 'local-events-done');
      };
      function b64ToUint6(nChr) {
        return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
      }
      function isBinary(node) {
        return node.match(/charset=binary/);
      }
      function isRemoteStorageKey(key) {
        return key.substr(0, NODES_PREFIX.length) === NODES_PREFIX || key.substr(0, CHANGES_PREFIX.length) === CHANGES_PREFIX;
      }
      function isNodeKey(key) {
        return key.substr(0, NODES_PREFIX.length) === NODES_PREFIX;
      }
      RemoteStorage.LocalStorage.prototype = {
        getNodes: function(paths) {
          var nodes = {};
          for (var i = 0,
              len = paths.length; i < len; i++) {
            try {
              nodes[paths[i]] = JSON.parse(localStorage[NODES_PREFIX + paths[i]]);
            } catch (e) {
              nodes[paths[i]] = undefined;
            }
          }
          return Promise.resolve(nodes);
        },
        setNodes: function(nodes) {
          for (var path in nodes) {
            localStorage[NODES_PREFIX + path] = JSON.stringify(nodes[path]);
          }
          return Promise.resolve();
        },
        forAllNodes: function(cb) {
          var node;
          for (var i = 0,
              len = localStorage.length; i < len; i++) {
            if (isNodeKey(localStorage.key(i))) {
              try {
                node = this.migrate(JSON.parse(localStorage[localStorage.key(i)]));
              } catch (e) {
                node = undefined;
              }
              if (node) {
                cb(node);
              }
            }
          }
          return Promise.resolve();
        }
      };
      RemoteStorage.LocalStorage._rs_init = function() {};
      RemoteStorage.LocalStorage._rs_supported = function() {
        return 'localStorage' in global;
      };
      RemoteStorage.LocalStorage._rs_cleanup = function() {
        var keys = [];
        for (var i = 0,
            len = localStorage.length; i < len; i++) {
          var key = localStorage.key(i);
          if (isRemoteStorageKey(key)) {
            keys.push(key);
          }
        }
        keys.forEach(function(key) {
          RemoteStorage.log('[LocalStorage] Removing', key);
          delete localStorage[key];
        });
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      RemoteStorage.InMemoryStorage = function() {
        RemoteStorage.cachingLayer(this);
        RemoteStorage.log('[InMemoryStorage] Registering events');
        RemoteStorage.eventHandling(this, 'change', 'local-events-done');
        this._storage = {};
      };
      RemoteStorage.InMemoryStorage.prototype = {
        getNodes: function(paths) {
          var nodes = {};
          for (var i = 0,
              len = paths.length; i < len; i++) {
            nodes[paths[i]] = this._storage[paths[i]];
          }
          return Promise.resolve(nodes);
        },
        setNodes: function(nodes) {
          for (var path in nodes) {
            if (nodes[path] === undefined) {
              delete this._storage[path];
            } else {
              this._storage[path] = nodes[path];
            }
          }
          return Promise.resolve();
        },
        forAllNodes: function(cb) {
          for (var path in this._storage) {
            cb(this.migrate(this._storage[path]));
          }
          return Promise.resolve();
        }
      };
      RemoteStorage.InMemoryStorage._rs_init = function() {};
      RemoteStorage.InMemoryStorage._rs_supported = function() {
        return true;
      };
      RemoteStorage.InMemoryStorage._rs_cleanup = function() {};
    })(typeof(window) !== 'undefined' ? window : global);
    (function() {
      RemoteStorage.MODULES = {};
      RemoteStorage.defineModule = function(moduleName, builder) {
        RemoteStorage.MODULES[moduleName] = builder;
        Object.defineProperty(RemoteStorage.prototype, moduleName, {
          configurable: true,
          get: function() {
            var instance = this._loadModule(moduleName);
            Object.defineProperty(this, moduleName, {value: instance});
            return instance;
          }
        });
        if (moduleName.indexOf('-') !== -1) {
          var camelizedName = moduleName.replace(/\-[a-z]/g, function(s) {
            return s[1].toUpperCase();
          });
          Object.defineProperty(RemoteStorage.prototype, camelizedName, {get: function() {
              return this[moduleName];
            }});
        }
      };
      RemoteStorage.prototype._loadModule = function(moduleName) {
        var builder = RemoteStorage.MODULES[moduleName];
        if (builder) {
          var module = builder(new RemoteStorage.BaseClient(this, '/' + moduleName + '/'), new RemoteStorage.BaseClient(this, '/public/' + moduleName + '/'));
          return module.exports;
        } else {
          throw "Unknown module: " + moduleName;
        }
      };
      RemoteStorage.prototype.defineModule = function(moduleName) {
        console.log("remoteStorage.defineModule is deprecated, use RemoteStorage.defineModule instead!");
        RemoteStorage.defineModule.apply(RemoteStorage, arguments);
      };
    })();
    (function() {
      function loadTable(table, storage, paths) {
        table.setAttribute('border', '1');
        table.style.margin = '8px';
        table.style.color = 'white';
        table.innerHTML = '';
        var thead = document.createElement('thead');
        table.appendChild(thead);
        var titleRow = document.createElement('tr');
        thead.appendChild(titleRow);
        ['Path', 'Content-Type', 'Revision'].forEach(function(label) {
          var th = document.createElement('th');
          th.textContent = label;
          thead.appendChild(th);
        });
        var tbody = document.createElement('tbody');
        table.appendChild(tbody);
        function renderRow(tr, path, contentType, revision) {
          [path, contentType, revision].forEach(function(value) {
            var td = document.createElement('td');
            td.textContent = value || '';
            tr.appendChild(td);
          });
        }
        function loadRow(path) {
          if (storage.connected === false) {
            return;
          }
          function processRow(status, body, contentType, revision) {
            if (status === 200) {
              var tr = document.createElement('tr');
              tbody.appendChild(tr);
              renderRow(tr, path, contentType, revision);
              if (path[path.length - 1] === '/') {
                for (var key in body) {
                  loadRow(path + key);
                }
              }
            }
          }
          storage.get(path).then(processRow);
        }
        paths.forEach(loadRow);
      }
      function renderWrapper(title, table, storage, paths) {
        var wrapper = document.createElement('div');
        var heading = document.createElement('h2');
        heading.textContent = title;
        wrapper.appendChild(heading);
        var updateButton = document.createElement('button');
        updateButton.textContent = "Refresh";
        updateButton.onclick = function() {
          loadTable(table, storage, paths);
        };
        wrapper.appendChild(updateButton);
        if (storage.reset) {
          var resetButton = document.createElement('button');
          resetButton.textContent = "Reset";
          resetButton.onclick = function() {
            storage.reset(function(newStorage) {
              storage = newStorage;
              loadTable(table, storage, paths);
            });
          };
          wrapper.appendChild(resetButton);
        }
        wrapper.appendChild(table);
        loadTable(table, storage, paths);
        return wrapper;
      }
      function renderLocalChanges(local) {
        var wrapper = document.createElement('div');
        var heading = document.createElement('h2');
        heading.textContent = "Outgoing changes";
        wrapper.appendChild(heading);
        var updateButton = document.createElement('button');
        updateButton.textContent = "Refresh";
        wrapper.appendChild(updateButton);
        var list = document.createElement('ul');
        list.style.fontFamily = 'courier';
        wrapper.appendChild(list);
        function updateList() {
          list.innerHTML = '';
          local.forAllNodes(function(node) {
            if (node.local && node.local.body) {
              var el = document.createElement('li');
              el.textContent = JSON.stringify(node.local);
              list.appendChild(el);
            }
          });
        }
        updateButton.onclick = updateList;
        updateList();
        return wrapper;
      }
      RemoteStorage.prototype.inspect = function() {
        var widget = document.createElement('div');
        widget.id = 'remotestorage-inspect';
        widget.style.position = 'absolute';
        widget.style.top = 0;
        widget.style.left = 0;
        widget.style.background = 'black';
        widget.style.color = 'white';
        widget.style.border = 'groove 5px #ccc';
        var controls = document.createElement('div');
        controls.style.position = 'absolute';
        controls.style.top = 0;
        controls.style.left = 0;
        var heading = document.createElement('strong');
        heading.textContent = " remotestorage.js inspector ";
        controls.appendChild(heading);
        var syncButton;
        if (this.local) {
          syncButton = document.createElement('button');
          syncButton.textContent = "Synchronize";
          controls.appendChild(syncButton);
        }
        var closeButton = document.createElement('button');
        closeButton.textContent = "Close";
        closeButton.onclick = function() {
          document.body.removeChild(widget);
        };
        controls.appendChild(closeButton);
        widget.appendChild(controls);
        var remoteRootPaths = [];
        for (var path in this.caching._rootPaths) {
          if (this.caching._rootPaths.hasOwnProperty(path)) {
            remoteRootPaths.push(path);
          }
        }
        var remoteTable = document.createElement('table');
        var localTable = document.createElement('table');
        widget.appendChild(renderWrapper("Remote", remoteTable, this.remote, remoteRootPaths));
        if (this.local) {
          widget.appendChild(renderWrapper("Local", localTable, this.local, ['/']));
          widget.appendChild(renderLocalChanges(this.local));
          syncButton.onclick = function() {
            this.log('sync clicked');
            this.sync.sync().then(function() {
              this.log('SYNC FINISHED');
              loadTable(localTable, this.local, ['/']);
            }.bind(this), function(err) {
              console.error("SYNC FAILED", err, err.stack);
            });
          }.bind(this);
        }
        document.body.appendChild(widget);
      };
    })();
    (function(global) {
      var RS = RemoteStorage;
      var BASE_URL = 'https://www.googleapis.com';
      var AUTH_URL = 'https://accounts.google.com/o/oauth2/auth';
      var AUTH_SCOPE = 'https://www.googleapis.com/auth/drive';
      var GD_DIR_MIME_TYPE = 'application/vnd.google-apps.folder';
      var RS_DIR_MIME_TYPE = 'application/json; charset=UTF-8';
      function buildQueryString(params) {
        return Object.keys(params).map(function(key) {
          return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
        }).join('&');
      }
      function fileNameFromMeta(meta) {
        return encodeURIComponent(meta.title) + (meta.mimeType === GD_DIR_MIME_TYPE ? '/' : '');
      }
      function metaTitleFromFileName(filename) {
        if (filename.substr(-1) === '/') {
          filename = filename.substr(0, filename.length - 1);
        }
        return decodeURIComponent(filename);
      }
      function parentPath(path) {
        return path.replace(/[^\/]+\/?$/, '');
      }
      function baseName(path) {
        var parts = path.split('/');
        if (path.substr(-1) === '/') {
          return parts[parts.length - 2] + '/';
        } else {
          return parts[parts.length - 1];
        }
      }
      var Cache = function(maxAge) {
        this.maxAge = maxAge;
        this._items = {};
      };
      Cache.prototype = {
        get: function(key) {
          var item = this._items[key];
          var now = new Date().getTime();
          return (item && item.t >= (now - this.maxAge)) ? item.v : undefined;
        },
        set: function(key, value) {
          this._items[key] = {
            v: value,
            t: new Date().getTime()
          };
        }
      };
      RS.GoogleDrive = function(remoteStorage, clientId) {
        RS.eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');
        this.rs = remoteStorage;
        this.clientId = clientId;
        this._fileIdCache = new Cache(60 * 5);
      };
      RS.GoogleDrive.prototype = {
        connected: false,
        online: true,
        configure: function(settings) {
          if (settings.token) {
            localStorage['remotestorage:googledrive:token'] = settings.token;
            this.token = settings.token;
            this.connected = true;
            this._emit('connected');
          } else {
            this.connected = false;
            delete this.token;
            delete localStorage['remotestorage:googledrive:token'];
          }
        },
        connect: function() {
          this.rs.setBackend('googledrive');
          RS.Authorize(AUTH_URL, AUTH_SCOPE, String(RS.Authorize.getLocation()), this.clientId);
        },
        stopWaitingForToken: function() {
          if (!this.connected) {
            this._emit('not-connected');
          }
        },
        get: function(path, options) {
          if (path.substr(-1) === '/') {
            return this._getFolder(path, options);
          } else {
            return this._getFile(path, options);
          }
        },
        put: function(path, body, contentType, options) {
          var self = this;
          function putDone(response) {
            if (response.status >= 200 && response.status < 300) {
              var meta = JSON.parse(response.responseText);
              var etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);
              return Promise.resolve({
                statusCode: 200,
                contentType: meta.mimeType,
                revision: etagWithoutQuotes
              });
            } else if (response.status === 412) {
              return Promise.resolve({
                statusCode: 412,
                revision: 'conflict'
              });
            } else {
              return Promise.reject("PUT failed with status " + response.status + " (" + response.responseText + ")");
            }
          }
          return self._getFileId(path).then(function(id) {
            if (id) {
              if (options && (options.ifNoneMatch === '*')) {
                return putDone({status: 412});
              }
              return self._updateFile(id, path, body, contentType, options).then(putDone);
            } else {
              return self._createFile(path, body, contentType, options).then(putDone);
            }
          });
        },
        'delete': function(path, options) {
          var self = this;
          return self._getFileId(path).then(function(id) {
            if (!id) {
              return Promise.resolve({statusCode: 200});
            }
            return self._getMeta(id).then(function(meta) {
              var etagWithoutQuotes;
              if ((typeof meta === 'object') && (typeof meta.etag === 'string')) {
                etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);
              }
              if (options && options.ifMatch && (options.ifMatch !== etagWithoutQuotes)) {
                return {
                  statusCode: 412,
                  revision: etagWithoutQuotes
                };
              }
              return self._request('DELETE', BASE_URL + '/drive/v2/files/' + id, {}).then(function(response) {
                if (response.status === 200 || response.status === 204) {
                  return {statusCode: 200};
                } else {
                  return Promise.reject("Delete failed: " + response.status + " (" + response.responseText + ")");
                }
              });
            });
          });
        },
        _updateFile: function(id, path, body, contentType, options) {
          var self = this;
          var metadata = {mimeType: contentType};
          var headers = {'Content-Type': 'application/json; charset=UTF-8'};
          if (options && options.ifMatch) {
            headers['If-Match'] = '"' + options.ifMatch + '"';
          }
          return self._request('PUT', BASE_URL + '/upload/drive/v2/files/' + id + '?uploadType=resumable', {
            body: JSON.stringify(metadata),
            headers: headers
          }).then(function(response) {
            if (response.status === 412) {
              return (response);
            } else {
              return self._request('PUT', response.getResponseHeader('Location'), {body: contentType.match(/^application\/json/) ? JSON.stringify(body) : body});
            }
          });
        },
        _createFile: function(path, body, contentType, options) {
          var self = this;
          return self._getParentId(path).then(function(parentId) {
            var fileName = baseName(path);
            var metadata = {
              title: metaTitleFromFileName(fileName),
              mimeType: contentType,
              parents: [{
                kind: "drive#fileLink",
                id: parentId
              }]
            };
            return self._request('POST', BASE_URL + '/upload/drive/v2/files?uploadType=resumable', {
              body: JSON.stringify(metadata),
              headers: {'Content-Type': 'application/json; charset=UTF-8'}
            }).then(function(response) {
              return self._request('POST', response.getResponseHeader('Location'), {body: contentType.match(/^application\/json/) ? JSON.stringify(body) : body});
            });
          });
        },
        _getFile: function(path, options) {
          var self = this;
          return self._getFileId(path).then(function(id) {
            return self._getMeta(id).then(function(meta) {
              var etagWithoutQuotes;
              if (typeof(meta) === 'object' && typeof(meta.etag) === 'string') {
                etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);
              }
              if (options && options.ifNoneMatch && (etagWithoutQuotes === options.ifNoneMatch)) {
                return Promise.resolve({statusCode: 304});
              }
              var options2 = {};
              if (!meta.downloadUrl) {
                if (meta.exportLinks && meta.exportLinks['text/html']) {
                  meta.mimeType += ';export=text/html';
                  meta.downloadUrl = meta.exportLinks['text/html'];
                } else {
                  return Promise.resolve({
                    statusCode: 200,
                    body: '',
                    contentType: meta.mimeType,
                    revision: etagWithoutQuotes
                  });
                }
              }
              if (meta.mimeType.match(/charset=binary/)) {
                options2.responseType = 'blob';
              }
              return self._request('GET', meta.downloadUrl, options2).then(function(response) {
                var body = response.response;
                if (meta.mimeType.match(/^application\/json/)) {
                  try {
                    body = JSON.parse(body);
                  } catch (e) {}
                }
                return Promise.resolve({
                  statusCode: 200,
                  body: body,
                  contentType: meta.mimeType,
                  revision: etagWithoutQuotes
                });
              });
            });
          });
        },
        _getFolder: function(path, options) {
          var self = this;
          return self._getFileId(path).then(function(id) {
            var query,
                fields,
                data,
                i,
                etagWithoutQuotes,
                itemsMap;
            if (!id) {
              return Promise.resolve({statusCode: 404});
            }
            query = '\'' + id + '\' in parents';
            fields = 'items(downloadUrl,etag,fileSize,id,mimeType,title)';
            return self._request('GET', BASE_URL + '/drive/v2/files?' + 'q=' + encodeURIComponent(query) + '&fields=' + encodeURIComponent(fields) + '&maxResults=1000', {}).then(function(response) {
              if (response.status !== 200) {
                return Promise.reject('request failed or something: ' + response.status);
              }
              try {
                data = JSON.parse(response.responseText);
              } catch (e) {
                return Promise.reject('non-JSON response from GoogleDrive');
              }
              itemsMap = {};
              for (var i = 0,
                  len = data.items.length; i < len; i++) {
                etagWithoutQuotes = data.items[i].etag.substring(1, data.items[i].etag.length - 1);
                if (data.items[i].mimeType === GD_DIR_MIME_TYPE) {
                  self._fileIdCache.set(path + data.items[i].title + '/', data.items[i].id);
                  itemsMap[data.items[i].title + '/'] = {ETag: etagWithoutQuotes};
                } else {
                  self._fileIdCache.set(path + data.items[i].title, data.items[i].id);
                  itemsMap[data.items[i].title] = {
                    ETag: etagWithoutQuotes,
                    'Content-Type': data.items[i].mimeType,
                    'Content-Length': data.items[i].fileSize
                  };
                }
              }
              return Promise.resolve({
                statusCode: 200,
                body: itemsMap,
                contentType: RS_DIR_MIME_TYPE,
                revision: undefined
              });
            });
          });
        },
        _getParentId: function(path) {
          var foldername = parentPath(path);
          var self = this;
          return self._getFileId(foldername).then(function(parentId) {
            if (parentId) {
              return Promise.resolve(parentId);
            } else {
              return self._createFolder(foldername);
            }
          });
        },
        _createFolder: function(path) {
          var self = this;
          return self._getParentId(path).then(function(parentId) {
            return self._request('POST', BASE_URL + '/drive/v2/files', {
              body: JSON.stringify({
                title: metaTitleFromFileName(baseName(path)),
                mimeType: GD_DIR_MIME_TYPE,
                parents: [{id: parentId}]
              }),
              headers: {'Content-Type': 'application/json; charset=UTF-8'}
            }).then(function(response) {
              var meta = JSON.parse(response.responseText);
              return Promise.resolve(meta.id);
            });
          });
        },
        _getFileId: function(path) {
          var self = this;
          var id;
          if (path === '/') {
            return Promise.resolve('root');
          } else if ((id = this._fileIdCache.get(path))) {
            return Promise.resolve(id);
          }
          return self._getFolder(parentPath(path)).then(function() {
            id = self._fileIdCache.get(path);
            if (!id) {
              if (path.substr(-1) === '/') {
                return self._createFolder(path).then(function() {
                  return self._getFileId(path);
                });
              } else {
                return Promise.resolve();
              }
              return;
            }
            return Promise.resolve(id);
          });
        },
        _getMeta: function(id) {
          return this._request('GET', BASE_URL + '/drive/v2/files/' + id, {}).then(function(response) {
            if (response.status === 200) {
              return Promise.resolve(JSON.parse(response.responseText));
            } else {
              return Promise.reject("request (getting metadata for " + id + ") failed with status: " + response.status);
            }
          });
        },
        _request: function(method, url, options) {
          var self = this;
          if (!options.headers) {
            options.headers = {};
          }
          options.headers['Authorization'] = 'Bearer ' + self.token;
          return RS.WireClient.request(method, url, options).then(function(xhr) {
            if (xhr && xhr.status === 401) {
              self.connect();
              return;
            }
            return xhr;
          });
        }
      };
      RS.GoogleDrive._rs_init = function(remoteStorage) {
        var config = remoteStorage.apiKeys.googledrive;
        if (config) {
          remoteStorage.googledrive = new RS.GoogleDrive(remoteStorage, config.client_id);
          if (remoteStorage.backend === 'googledrive') {
            remoteStorage._origRemote = remoteStorage.remote;
            remoteStorage.remote = remoteStorage.googledrive;
          }
        }
      };
      RS.GoogleDrive._rs_supported = function(rs) {
        return true;
      };
      RS.GoogleDrive._rs_cleanup = function(remoteStorage) {
        remoteStorage.setBackend(undefined);
        if (remoteStorage._origRemote) {
          remoteStorage.remote = remoteStorage._origRemote;
          delete remoteStorage._origRemote;
        }
      };
    })(this);
    (function(global) {
      var RS = RemoteStorage;
      var hasLocalStorage;
      var AUTH_URL = 'https://www.dropbox.com/1/oauth2/authorize';
      var SETTINGS_KEY = 'remotestorage:dropbox';
      var cleanPath = RS.WireClient.cleanPath;
      function LowerCaseCache(defaultValue) {
        this.defaultValue = defaultValue;
        this._storage = {};
        this.set = this.justSet;
        this.delete = this.justDelete;
      }
      LowerCaseCache.prototype = {
        get: function(key) {
          key = key.toLowerCase();
          var stored = this._storage[key];
          if (typeof stored === 'undefined') {
            stored = this.defaultValue;
            this._storage[key] = stored;
          }
          return stored;
        },
        propagateSet: function(key, value) {
          key = key.toLowerCase();
          if (this._storage[key] === value) {
            return value;
          }
          this._propagate(key, value);
          this._storage[key] = value;
          return value;
        },
        propagateDelete: function(key) {
          key = key.toLowerCase();
          this._propagate(key, this._storage[key]);
          return delete this._storage[key];
        },
        _activatePropagation: function() {
          this.set = this.propagateSet;
          this.delete = this.propagateDelete;
          return true;
        },
        justSet: function(key, value) {
          key = key.toLowerCase();
          this._storage[key] = value;
          return value;
        },
        justDelete: function(key, value) {
          key = key.toLowerCase();
          return delete this._storage[key];
        },
        _propagate: function(key, rev) {
          var folders = key.split('/').slice(0, -1);
          var path = '';
          for (var i = 0,
              len = folders.length; i < len; i++) {
            path += folders[i] + '/';
            if (!rev) {
              rev = this._storage[path] + 1;
            }
            this._storage[path] = rev;
          }
        }
      };
      var onErrorCb;
      RS.Dropbox = function(rs) {
        this.rs = rs;
        this.connected = false;
        this.rs = rs;
        var self = this;
        onErrorCb = function(error) {
          if (error instanceof RemoteStorage.Unauthorized) {
            self.configure({
              userAddress: null,
              href: null,
              storageApi: null,
              token: null,
              options: null
            });
          }
        };
        RS.eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');
        rs.on('error', onErrorCb);
        this.clientId = rs.apiKeys.dropbox.api_key;
        this._revCache = new LowerCaseCache('rev');
        this._itemRefs = {};
        this._metadataCache = {};
        if (hasLocalStorage) {
          var settings;
          try {
            settings = JSON.parse(localStorage[SETTINGS_KEY]);
          } catch (e) {}
          if (settings) {
            this.configure(settings);
          }
          try {
            this._itemRefs = JSON.parse(localStorage[SETTINGS_KEY + ':shares']);
          } catch (e) {}
        }
        if (this.connected) {
          setTimeout(this._emit.bind(this), 0, 'connected');
        }
      };
      RS.Dropbox.prototype = {
        online: true,
        connect: function() {
          this.rs.setBackend('dropbox');
          if (this.token) {
            hookIt(this.rs);
          } else {
            RS.Authorize(AUTH_URL, '', String(RS.Authorize.getLocation()), this.clientId);
          }
        },
        configure: function(settings) {
          if (typeof settings.userAddress !== 'undefined') {
            this.userAddress = settings.userAddress;
          }
          if (typeof settings.token !== 'undefined') {
            this.token = settings.token;
          }
          if (this.token) {
            this.connected = true;
            if (!this.userAddress) {
              this.info().then(function(info) {
                this.userAddress = info.display_name;
                this.rs.widget.view.setUserAddress(this.userAddress);
                this._emit('connected');
              }.bind(this));
            }
          } else {
            this.connected = false;
          }
          if (hasLocalStorage) {
            localStorage[SETTINGS_KEY] = JSON.stringify({
              userAddress: this.userAddress,
              token: this.token
            });
          }
        },
        stopWaitingForToken: function() {
          if (!this.connected) {
            this._emit('not-connected');
          }
        },
        _getFolder: function(path, options) {
          var url = 'https://api.dropbox.com/1/metadata/auto' + cleanPath(path);
          var revCache = this._revCache;
          var self = this;
          return this._request('GET', url, {}).then(function(resp) {
            var status = resp.status;
            if (status === 304) {
              return Promise.resolve({statusCode: status});
            }
            var listing,
                body,
                mime,
                rev;
            try {
              body = JSON.parse(resp.responseText);
            } catch (e) {
              return Promise.reject(e);
            }
            rev = self._revCache.get(path);
            mime = 'application/json; charset=UTF-8';
            if (body.contents) {
              listing = body.contents.reduce(function(m, item) {
                var itemName = item.path.split('/').slice(-1)[0] + (item.is_dir ? '/' : '');
                if (item.is_dir) {
                  m[itemName] = {ETag: revCache.get(path + itemName)};
                } else {
                  m[itemName] = {ETag: item.rev};
                }
                return m;
              }, {});
            }
            return Promise.resolve({
              statusCode: status,
              body: listing,
              contentType: mime,
              revision: rev
            });
          });
        },
        get: function(path, options) {
          if (!this.connected) {
            return Promise.reject("not connected (path: " + path + ")");
          }
          var url = 'https://api-content.dropbox.com/1/files/auto' + cleanPath(path);
          var self = this;
          var savedRev = this._revCache.get(path);
          if (savedRev === null) {
            return Promise.resolve({statusCode: 404});
          }
          if (options && options.ifNoneMatch && savedRev && (savedRev === options.ifNoneMatch)) {
            return Promise.resolve({statusCode: 304});
          }
          if (path.substr(-1) === '/') {
            return this._getFolder(path, options);
          }
          return this._request('GET', url, {}).then(function(resp) {
            var status = resp.status;
            var meta,
                body,
                mime,
                rev;
            if (status !== 200) {
              return Promise.resolve({statusCode: status});
            }
            body = resp.responseText;
            try {
              meta = JSON.parse(resp.getResponseHeader('x-dropbox-metadata'));
            } catch (e) {
              return Promise.reject(e);
            }
            mime = meta.mime_type;
            rev = meta.rev;
            self._revCache.set(path, rev);
            self._shareIfNeeded(path);
            if (!resp.getResponseHeader('Content-Type') || resp.getResponseHeader('Content-Type').match(/charset=binary/)) {
              var pending = Promise.defer();
              RS.WireClient.readBinaryData(resp.response, mime, function(result) {
                pending.resolve({
                  statusCode: status,
                  body: result,
                  contentType: mime,
                  revision: rev
                });
              });
              return pending.promise;
            }
            if (mime && mime.search('application/json') >= 0 || true) {
              try {
                body = JSON.parse(body);
                mime = 'application/json; charset=UTF-8';
              } catch (e) {}
            }
            return Promise.resolve({
              statusCode: status,
              body: body,
              contentType: mime,
              revision: rev
            });
          });
        },
        put: function(path, body, contentType, options) {
          var self = this;
          if (!this.connected) {
            throw new Error("not connected (path: " + path + ")");
          }
          var savedRev = this._revCache.get(path);
          if (options && options.ifMatch && savedRev && (savedRev !== options.ifMatch)) {
            return Promise.resolve({
              statusCode: 412,
              revision: savedRev
            });
          }
          if (options && (options.ifNoneMatch === '*') && savedRev && (savedRev !== 'rev')) {
            return Promise.resolve({
              statusCode: 412,
              revision: savedRev
            });
          }
          if ((!contentType.match(/charset=/)) && (body instanceof ArrayBuffer || RS.WireClient.isArrayBufferView(body))) {
            contentType += '; charset=binary';
          }
          if (body.length > 150 * 1024 * 1024) {
            return Promise.reject(new Error("Cannot upload file larger than 150MB"));
          }
          var result;
          var needsMetadata = options && (options.ifMatch || (options.ifNoneMatch === '*'));
          var uploadParams = {
            body: body,
            contentType: contentType,
            path: path
          };
          if (needsMetadata) {
            result = this._getMetadata(path).then(function(metadata) {
              if (options && (options.ifNoneMatch === '*') && metadata) {
                return Promise.resolve({
                  statusCode: 412,
                  revision: metadata.rev
                });
              }
              if (options && options.ifMatch && metadata && (metadata.rev !== options.ifMatch)) {
                return Promise.resolve({
                  statusCode: 412,
                  revision: metadata.rev
                });
              }
              return self._uploadSimple(uploadParams);
            });
          } else {
            result = self._uploadSimple(uploadParams);
          }
          return result.then(function(ret) {
            self._shareIfNeeded(path);
            return ret;
          });
        },
        'delete': function(path, options) {
          var self = this;
          if (!this.connected) {
            throw new Error("not connected (path: " + path + ")");
          }
          var savedRev = this._revCache.get(path);
          if (options && options.ifMatch && savedRev && (options.ifMatch !== savedRev)) {
            return Promise.resolve({
              statusCode: 412,
              revision: savedRev
            });
          }
          if (options && options.ifMatch) {
            return this._getMetadata(path).then(function(metadata) {
              if (options && options.ifMatch && metadata && (metadata.rev !== options.ifMatch)) {
                return Promise.resolve({
                  statusCode: 412,
                  revision: metadata.rev
                });
              }
              return self._deleteSimple(path);
            });
          }
          return self._deleteSimple(path);
        },
        _shareIfNeeded: function(path) {
          if (path.match(/^\/public\/.*[^\/]$/) && this._itemRefs[path] === undefined) {
            this.share(path);
          }
        },
        share: function(path) {
          var self = this;
          var url = 'https://api.dropbox.com/1/media/auto/' + cleanPath(path);
          return this._request('POST', url, {}).then(function(response) {
            if (response.status !== 200) {
              return Promise.reject(new Error('Invalid DropBox API response status when sharing "' + path + '":' + response.status));
            }
            try {
              response = JSON.parse(response.responseText);
            } catch (e) {
              return Promise.reject(new Error('Invalid DropBox API response when sharing "' + path + '": ' + response.responseText));
            }
            self._itemRefs[path] = response.url;
            if (hasLocalStorage) {
              localStorage[SETTINGS_KEY + ':shares'] = JSON.stringify(self._itemRefs);
            }
            return Promise.resolve(url);
          }, function(error) {
            err.message = 'Sharing DropBox file or folder ("' + path + '") failed.' + err.message;
            return Promise.reject(error);
          });
        },
        info: function() {
          var url = 'https://api.dropbox.com/1/account/info';
          return this._request('GET', url, {}).then(function(resp) {
            try {
              var info = JSON.parse(resp.responseText);
              return Promise.resolve(info);
            } catch (e) {
              return Promise.reject(e);
            }
          });
        },
        _request: function(method, url, options) {
          var self = this;
          if (!options.headers) {
            options.headers = {};
          }
          options.headers['Authorization'] = 'Bearer ' + this.token;
          return RS.WireClient.request.call(this, method, url, options).then(function(xhr) {
            if (xhr && xhr.status === 503) {
              return global.setTimeout(self._request(method, url, options), 3210);
            } else {
              return Promise.resolve(xhr);
            }
          });
        },
        fetchDelta: function() {
          var args = Array.prototype.slice.call(arguments);
          var self = this;
          return self._request('POST', 'https://api.dropbox.com/1/delta', {
            body: self._deltaCursor ? ('cursor=' + encodeURIComponent(self._deltaCursor)) : '',
            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
          }).then(function(response) {
            if (response.status !== 200) {
              if (response.status === 400) {
                self.rs._emit('error', new RemoteStorage.Unauthorized());
                return Promise.resolve(args);
              } else {
                return Promise.reject("dropbox.fetchDelta returned " + response.status + response.responseText);
              }
              return;
            }
            var delta;
            try {
              delta = JSON.parse(response.responseText);
            } catch (error) {
              RS.log('fetchDeltas can not parse response', error);
              return Promise.reject("can not parse response of fetchDelta : " + error.message);
            }
            if (!delta.entries) {
              return Promise.reject('dropbox.fetchDeltas failed, no entries found');
            }
            if (delta.reset) {
              self._revCache = new LowerCaseCache('rev');
            }
            if (delta.cursor) {
              self._deltaCursor = delta.cursor;
            }
            RemoteStorage.log("Delta : ", delta.entries);
            delta.entries.forEach(function(entry) {
              var path = entry[0];
              var rev;
              if (!entry[1]) {
                rev = null;
              } else {
                if (entry[1].is_dir) {
                  return;
                }
                rev = entry[1].rev;
              }
              self._revCache.set(path, rev);
            });
            return Promise.resolve(args);
          }, function(err) {
            this.rs.log('fetchDeltas', err);
            this.rs._emit('error', new RemoteStorage.SyncError('fetchDeltas failed.' + err));
            promise.reject(err);
          }).then(function() {
            if (self._revCache) {
              var args = Array.prototype.slice.call(arguments);
              self._revCache._activatePropagation();
              return Promise.resolve(args);
            }
          });
        },
        _getMetadata: function(path, options) {
          var self = this;
          var cached = this._metadataCache[path];
          var url = 'https://api.dropbox.com/1/metadata/auto' + cleanPath(path);
          url += '?list=' + ((options && options.list) ? 'true' : 'false');
          if (cached && cached.hash) {
            url += '&hash=' + encodeURIComponent(cached.hash);
          }
          return this._request('GET', url, {}).then(function(resp) {
            if (resp.status === 304) {
              return Promise.resolve(cached);
            } else if (resp.status === 200) {
              var response = JSON.parse(resp.responseText);
              self._metadataCache[path] = response;
              return Promise.resolve(response);
            } else {
              return Promise.resolve();
            }
          });
        },
        _uploadSimple: function(params) {
          var self = this;
          var url = 'https://api-content.dropbox.com/1/files_put/auto' + cleanPath(params.path) + '?';
          if (params && params.ifMatch) {
            url += "parent_rev=" + encodeURIComponent(params.ifMatch);
          }
          return self._request('PUT', url, {
            body: params.body,
            headers: {'Content-Type': params.contentType}
          }).then(function(resp) {
            if (resp.status !== 200) {
              return Promise.resolve({statusCode: resp.status});
            }
            var response;
            try {
              response = JSON.parse(resp.responseText);
            } catch (e) {
              return Promise.reject(e);
            }
            if (response.path !== params.path) {
              var deleteUrl = 'https://api.dropbox.com/1/fileops/delete?root=auto&path=' + encodeURIComponent(response.path);
              self._request('POST', deleteUrl, {});
              return self._getMetadata(params.path).then(function(metadata) {
                return Promise.resolve({
                  statusCode: 412,
                  revision: metadata.rev
                });
              });
            }
            self._revCache.propagateSet(params.path, response.rev);
            return Promise.resolve({statusCode: resp.status});
          });
        },
        _deleteSimple: function(path) {
          var self = this;
          var url = 'https://api.dropbox.com/1/fileops/delete?root=auto&path=' + encodeURIComponent(path);
          return self._request('POST', url, {}).then(function(resp) {
            if (resp.status === 406) {
              return Promise.reject(new Error("Cannot delete '" + path + "': too many files involved"));
            }
            if (resp.status === 200) {
              self._revCache.delete(path);
              delete self._itemRefs[path];
            }
            return Promise.resolve({statusCode: resp.status});
          });
        }
      };
      function hookSync(rs) {
        if (rs._dropboxOrigSync) {
          return;
        }
        rs._dropboxOrigSync = rs.sync.bind(rs);
        rs.sync = function() {
          return this.dropbox.fetchDelta.apply(this.dropbox, arguments).then(rs._dropboxOrigSync, function(err) {
            rs._emit('error', new rs.SyncError(err));
          });
        };
      }
      function unHookSync(rs) {
        if (!rs._dropboxOrigSync) {
          return;
        }
        rs.sync = rs._dropboxOrigSync;
        delete rs._dropboxOrigSync;
      }
      function hookGetItemURL(rs) {
        if (rs._origBaseClientGetItemURL) {
          return;
        }
        rs._origBaseClientGetItemURL = RS.BaseClient.prototype.getItemURL;
        RS.BaseClient.prototype.getItemURL = function(path) {
          var ret = rs.dropbox._itemRefs[path];
          return ret ? ret : '';
        };
      }
      function unHookGetItemURL(rs) {
        if (!rs._origBaseClieNtGetItemURL) {
          return;
        }
        RS.BaseClient.prototype.getItemURL = rs._origBaseClietGetItemURL;
        delete rs._origBaseClietGetItemURL;
      }
      function hookRemote(rs) {
        if (rs._origRemote) {
          return;
        }
        rs._origRemote = rs.remote;
        rs.remote = rs.dropbox;
      }
      function unHookRemote(rs) {
        if (rs._origRemote) {
          rs.remote = rs._origRemote;
          delete rs._origRemote;
        }
      }
      function hookIt(rs) {
        hookRemote(rs);
        if (rs.sync) {
          hookSync(rs);
        }
        hookGetItemURL(rs);
      }
      function unHookIt(rs) {
        unHookRemote(rs);
        unHookSync(rs);
        unHookGetItemURL(rs);
      }
      RS.Dropbox._rs_init = function(rs) {
        hasLocalStorage = rs.localStorageAvailable();
        if (rs.apiKeys.dropbox) {
          rs.dropbox = new RS.Dropbox(rs);
        }
        if (rs.backend === 'dropbox') {
          hookIt(rs);
        }
      };
      RS.Dropbox._rs_supported = function() {
        return true;
      };
      RS.Dropbox._rs_cleanup = function(rs) {
        unHookIt(rs);
        if (hasLocalStorage) {
          delete localStorage[SETTINGS_KEY];
        }
        rs.removeEventListener('error', onErrorCb);
        rs.setBackend(undefined);
      };
    })(this);
    remoteStorage = new RemoteStorage();
    this["CHARS"] = CHARS;
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:core-js@0.9.17/library/modules/$.fw.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function($) {
    $.FW = false;
    $.path = $.core;
    return $;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@0.9.17/library/modules/$.enum-keys.js", ["npm:core-js@0.9.17/library/modules/$.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.17/library/modules/$.js");
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getDesc = $.getDesc,
        getSymbols = $.getSymbols;
    if (getSymbols)
      $.each.call(getSymbols(it), function(key) {
        if (getDesc(it, key).enumerable)
          keys.push(key);
      });
    return keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("libraries/telehash/telehash-library.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "telehash", null);
  (function() {
    "format global";
    "exports telehash";
    (function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == "function" && require;
            if (!u && a)
              return a(o, !0);
            if (i)
              return i(o, !0);
            throw new Error("Cannot find module '" + o + "'");
          }
          var f = n[o] = {exports: {}};
          t[o][0].call(f.exports, function(e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == "function" && require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    })({
      1: [function(require, module, exports) {
        if (typeof window !== "undefined") {
          window.telehash = require('telehash');
        }
      }, {"telehash": 2}],
      2: [function(require, module, exports) {
        var thjs = require("telehash-js");
        exports.debug = thjs.debug;
        exports.info = thjs.info;
        exports.init = function(args, cbDone) {
          if (!args)
            args = {};
          var self = new thjs.switch();
          require("telehash-cs1a").install(self, args);
          if (args.cs2a)
            require("telehash-cs2a").install(self, args);
          require("telehash-http").install(self, args);
          require("telehash-webrtc").install(self, args);
          require("telehash-stream").install(self, args);
          require("telehash-telesocket").install(self, args);
          require("telehash-thtp").install(self, args);
          require("telehash-token").install(self, args);
          function seed() {
            require("telehash-seeds").install(self, args);
            self.online(function(err) {
              cbDone(err, self);
            });
            return self;
          }
          if (args.id) {
            if (typeof args.id == "string" && localStorage && localStorage.getItem(args.id))
              args.id = JSON.parse(localStorage.getItem(args.id));
            if (typeof args.id == "object") {
              var err;
              if ((err = self.load(args.id)))
                return cbDone("error loading id, " + err + ": " + JSON.stringify(args.id));
              return seed();
            }
          }
          self.make(function(err, id) {
            if (err)
              return cbDone("error creating id, " + err);
            if (typeof args.id == "string" && localStorage)
              localStorage.setItem(args.id, JSON.stringify(id));
            args.id = id;
            self.load(id);
            return seed();
          });
          return self;
        };
      }, {
        "telehash-cs1a": 3,
        "telehash-cs2a": 10,
        "telehash-http": 18,
        "telehash-js": 20,
        "telehash-seeds": 21,
        "telehash-stream": 23,
        "telehash-telesocket": 24,
        "telehash-thtp": 25,
        "telehash-token": 26,
        "telehash-webrtc": 27
      }],
      3: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var cs1a = require("./cs1a.js");
          var ecc = require("ecc-jsbn");
          require("./forge.min.js");
          cs1a.crypt(ecc, function(enc, key, iv, body) {
            var cipher = enc ? forge.aes.createEncryptionCipher(key.toString("binary"), "CTR") : forge.aes.createDecryptionCipher(key.toString("binary"), "CTR");
            cipher.start(iv.toString("binary"));
            cipher.update(forge.util.createBuffer(body.toString('binary')));
            cipher.finish();
            return new Buffer(cipher.output.getBytes(), "binary");
          });
          Object.keys(cs1a).forEach(function(f) {
            exports[f] = cs1a[f];
          });
        }).call(this, require("buffer").Buffer);
      }, {
        "./cs1a.js": 4,
        "./forge.min.js": 5,
        "buffer": 29,
        "crypto": 35,
        "ecc-jsbn": 6
      }],
      4: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var self;
          exports.install = function(telehash) {
            self = telehash;
            telehash.CSets["1a"] = exports;
          };
          exports.crypt = function(ecc, aes) {
            crypto.ecc = ecc;
            crypto.aes = aes;
          };
          function fold(count, buf) {
            if (!count || buf.length % 2)
              return buf;
            var ret = buf.slice(0, buf.length / 2);
            for (i = 0; i < ret.length; i++)
              ret[i] = ret[i] ^ buf[i + ret.length];
            return fold(count - 1, ret);
          }
          exports.genkey = function(ret, cbDone, cbStep) {
            var k = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1);
            ret["1a"] = k.PublicKey.slice(1).toString("base64");
            ret["1a_secret"] = k.PrivateKey.toString("base64");
            cbDone();
          };
          exports.loadkey = function(id, pub, priv) {
            if (typeof pub == "string")
              pub = new Buffer(pub, "base64");
            if (!Buffer.isBuffer(pub) || pub.length != 40)
              return "invalid public key";
            id.key = pub;
            id.public = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04", "hex"), id.key]), true);
            if (!id.public)
              return "public key load failed";
            if (priv) {
              if (typeof priv == "string")
                priv = new Buffer(priv, "base64");
              if (!Buffer.isBuffer(priv) || priv.length != 20)
                return "invalid private key";
              id.private = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, priv);
              if (!id.private)
                return "private key load failed";
            }
            return false;
          };
          exports.openize = function(id, to, inner) {
            if (!to.ecc)
              to.ecc = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1);
            var eccpub = to.ecc.PublicKey.slice(1);
            var secret = to.ecc.deriveSharedSecret(to.public);
            var key = fold(1, crypto.createHash("sha256").update(secret).digest());
            var iv = new Buffer("00000000000000000000000000000001", "hex");
            var body = (!Buffer.isBuffer(inner)) ? self.pencode(inner, id.cs["1a"].key) : inner;
            var cbody = crypto.aes(true, key, iv, body);
            var secret = id.cs["1a"].private.deriveSharedSecret(to.public);
            var macd = Buffer.concat([eccpub, cbody]);
            var hmac = fold(3, crypto.createHmac("sha256", secret).update(macd).digest());
            var body = Buffer.concat([hmac, macd]);
            return self.pencode(0x1a, body);
          }, exports.deopenize = function(id, open) {
            var ret = {verify: false};
            if (!open.body)
              return ret;
            var mac1 = open.body.slice(0, 4).toString("hex");
            var pub = open.body.slice(4, 44);
            var cbody = open.body.slice(44);
            try {
              ret.linepub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04", "hex"), pub]), true);
            } catch (E) {
              console.log("ecc err", E);
            }
            if (!ret.linepub)
              return ret;
            var secret = id.cs["1a"].private.deriveSharedSecret(ret.linepub);
            var key = fold(1, crypto.createHash("sha256").update(secret).digest());
            var iv = new Buffer("00000000000000000000000000000001", "hex");
            var body = crypto.aes(false, key, iv, cbody);
            var inner = self.pdecode(body);
            if (!inner)
              return ret;
            ret.inner = inner;
            var epub;
            if (!open.from) {
              epub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04", "hex"), inner.body]), true);
              if (!epub)
                return ret;
              ret.key = inner.body;
            } else {
              epub = open.from.public;
            }
            var secret = id.cs["1a"].private.deriveSharedSecret(epub);
            var mac2 = fold(3, crypto.createHmac("sha256", secret).update(open.body.slice(4)).digest()).toString("hex");
            if (mac2 != mac1)
              return ret;
            ret.verify = true;
            ret.js = inner.js;
            return ret;
          }, exports.openline = function(from, open) {
            from.lineIV = crypto.randomBytes(4).readUInt32LE(0);
            from.lineInB = new Buffer(from.lineIn, "hex");
            var ecdhe = from.ecc.deriveSharedSecret(open.linepub);
            from.encKey = fold(1, crypto.createHash("sha256").update(ecdhe).update(new Buffer(from.lineOut, "hex")).update(from.lineInB).digest());
            from.decKey = fold(1, crypto.createHash("sha256").update(ecdhe).update(from.lineInB).update(new Buffer(from.lineOut, "hex")).digest());
            return true;
          }, exports.lineize = function(to, packet) {
            var iv = new Buffer(16);
            iv.fill(0);
            iv.writeUInt32LE(to.lineIV++, 12);
            var cbody = crypto.aes(true, to.encKey, iv, self.pencode(packet.js, packet.body));
            var mac = fold(3, crypto.createHmac("sha256", to.encKey).update(Buffer.concat([iv.slice(12), cbody])).digest());
            var body = Buffer.concat([to.lineInB, mac, iv.slice(12), cbody]);
            return self.pencode(null, body);
          }, exports.delineize = function(from, packet) {
            if (!packet.body)
              return "no body";
            packet.body = packet.body.slice(16);
            var mac1 = packet.body.slice(0, 4).toString("hex");
            var mac2 = fold(3, crypto.createHmac("sha256", from.decKey).update(packet.body.slice(4)).digest()).toString("hex");
            if (mac1 != mac2)
              return "invalid hmac";
            var iv = packet.body.slice(4, 8);
            var ivz = new Buffer(12);
            ivz.fill(0);
            var body = packet.body.slice(8);
            var deciphered = self.pdecode(crypto.aes(false, from.decKey, Buffer.concat([ivz, iv]), body));
            if (!deciphered)
              return "invalid decrypted packet";
            packet.js = deciphered.js;
            packet.body = deciphered.body;
            return false;
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "crypto": 35
      }],
      5: [function(require, module, exports) {
        (function(process) {
          (function() {
            var e,
                t,
                n;
            (function(r) {
              function d(e, t) {
                return h.call(e, t);
              }
              function v(e, t) {
                var n,
                    r,
                    i,
                    s,
                    o,
                    u,
                    a,
                    f,
                    c,
                    h,
                    p,
                    v = t && t.split("/"),
                    m = l.map,
                    g = /\.js$/,
                    y = m && m["*"] || {};
                if (e && e.charAt(0) === ".")
                  if (t) {
                    v = v.slice(0, v.length - 1), e = e.split("/"), o = e.length - 1, l.pkgs && d(l.pkgs, v[0]) && g.test(e[o]) && (e[o] = e[o].replace(g, "")), e = v.concat(e);
                    for (c = 0; c < e.length; c += 1) {
                      p = e[c];
                      if (p === ".")
                        e.splice(c, 1), c -= 1;
                      else if (p === "..") {
                        if (c === 1 && (e[2] === ".." || e[0] === ".."))
                          break;
                        c > 0 && (e.splice(c - 1, 2), c -= 2);
                      }
                    }
                    e = e.join("/");
                  } else
                    e.indexOf("./") === 0 && (e = e.substring(2));
                if ((v || y) && m) {
                  n = e.split("/");
                  for (c = n.length; c > 0; c -= 1) {
                    r = n.slice(0, c).join("/");
                    if (v)
                      for (h = v.length; h > 0; h -= 1) {
                        i = m[v.slice(0, h).join("/")];
                        if (i) {
                          i = i[r];
                          if (i) {
                            s = i, u = c;
                            break;
                          }
                        }
                      }
                    if (s)
                      break;
                    !a && y && y[r] && (a = y[r], f = c);
                  }
                  !s && a && (s = a, u = f), s && (n.splice(0, u, s), e = n.join("/"));
                }
                return e;
              }
              function m(e, t) {
                return function() {
                  return s.apply(r, p.call(arguments, 0).concat([e, t]));
                };
              }
              function g(e) {
                return function(t) {
                  return v(t, e);
                };
              }
              function y(e) {
                return function(t) {
                  a[e] = t;
                };
              }
              function b(e) {
                if (d(f, e)) {
                  var t = f[e];
                  delete f[e], c[e] = !0, i.apply(r, t);
                }
                if (!d(a, e) && !d(c, e))
                  throw new Error("No " + e);
                return a[e];
              }
              function w(e) {
                var t,
                    n = e ? e.indexOf("!") : -1;
                return n > -1 && (t = e.substring(0, n), e = e.substring(n + 1, e.length)), [t, e];
              }
              function E(e) {
                return function() {
                  return l && l.config && l.config[e] || {};
                };
              }
              var i,
                  s,
                  o,
                  u,
                  a = {},
                  f = {},
                  l = {},
                  c = {},
                  h = Object.prototype.hasOwnProperty,
                  p = [].slice;
              o = function(e, t) {
                var n,
                    r = w(e),
                    i = r[0];
                return e = r[1], i && (i = v(i, t), n = b(i)), i ? n && n.normalize ? e = n.normalize(e, g(t)) : e = v(e, t) : (e = v(e, t), r = w(e), i = r[0], e = r[1], i && (n = b(i))), {
                  f: i ? i + "!" + e : e,
                  n: e,
                  pr: i,
                  p: n
                };
              }, u = {
                require: function(e) {
                  return m(e);
                },
                exports: function(e) {
                  var t = a[e];
                  return typeof t != "undefined" ? t : a[e] = {};
                },
                module: function(e) {
                  return {
                    id: e,
                    uri: "",
                    exports: a[e],
                    config: E(e)
                  };
                }
              }, i = function(e, t, n, i) {
                var s,
                    l,
                    h,
                    p,
                    v,
                    g = [],
                    w = typeof n,
                    E;
                i = i || e;
                if (w === "undefined" || w === "function") {
                  t = !t.length && n.length ? ["require", "exports", "module"] : t;
                  for (v = 0; v < t.length; v += 1) {
                    p = o(t[v], i), l = p.f;
                    if (l === "require")
                      g[v] = u.require(e);
                    else if (l === "exports")
                      g[v] = u.exports(e), E = !0;
                    else if (l === "module")
                      s = g[v] = u.module(e);
                    else if (d(a, l) || d(f, l) || d(c, l))
                      g[v] = b(l);
                    else {
                      if (!p.p)
                        throw new Error(e + " missing " + l);
                      p.p.load(p.n, m(i, !0), y(l), {}), g[v] = a[l];
                    }
                  }
                  h = n ? n.apply(a[e], g) : undefined;
                  if (e)
                    if (s && s.exports !== r && s.exports !== a[e])
                      a[e] = s.exports;
                    else if (h !== r || !E)
                      a[e] = h;
                } else
                  e && (a[e] = n);
              }, e = t = s = function(e, t, n, a, f) {
                var c,
                    h;
                if (typeof e == "string")
                  return u[e] ? u[e](t) : b(o(e, t).f);
                if (!e.splice) {
                  l = e, l.deps && s(l.deps, l.callback), h = l.packages;
                  if (l.packages) {
                    l.pkgs = {};
                    for (c = 0; c < h.length; c++)
                      l.pkgs[h[c].name || h[c]] = !0;
                  }
                  if (!t)
                    return;
                  t.splice ? (e = t, t = n, n = null) : e = r;
                }
                return t = t || function() {}, typeof n == "function" && (n = a, a = f), a ? i(r, e, t, n) : setTimeout(function() {
                  i(r, e, t, n);
                }, 4), s;
              }, s.config = function(e) {
                return s(e);
              }, e._defined = a, n = function(e, t, n) {
                t.splice || (n = t, t = []), !d(a, e) && !d(f, e) && (f[e] = [e, t, n]);
              }, n.amd = {jQuery: !0};
            })(), n("node_modules/almond/almond", function() {}), function() {
              function e(e) {
                var t = e.util = e.util || {};
                typeof process == "undefined" || !process.nextTick ? typeof setImmediate == "function" ? (t.setImmediate = setImmediate, t.nextTick = function(e) {
                  return setImmediate(e);
                }) : (t.setImmediate = function(e) {
                  setTimeout(e, 0);
                }, t.nextTick = t.setImmediate) : (t.nextTick = process.nextTick, typeof setImmediate == "function" ? t.setImmediate = setImmediate : t.setImmediate = t.nextTick), t.isArray = Array.isArray || function(e) {
                  return Object.prototype.toString.call(e) === "[object Array]";
                }, t.isArrayBuffer = function(e) {
                  return typeof ArrayBuffer != "undefined" && e instanceof ArrayBuffer;
                };
                var n = [];
                typeof Int8Array != "undefined" && n.push(Int8Array), typeof Uint8Array != "undefined" && n.push(Uint8Array), typeof Uint8ClampedArray != "undefined" && n.push(Uint8ClampedArray), typeof Int16Array != "undefined" && n.push(Int16Array), typeof Uint16Array != "undefined" && n.push(Uint16Array), typeof Int32Array != "undefined" && n.push(Int32Array), typeof Uint32Array != "undefined" && n.push(Uint32Array), typeof Float32Array != "undefined" && n.push(Float32Array), typeof Float64Array != "undefined" && n.push(Float64Array), t.isArrayBufferView = function(e) {
                  for (var t = 0; t < n.length; ++t)
                    if (e instanceof n[t])
                      return !0;
                  return !1;
                }, t.ByteBuffer = function(e) {
                  this.data = "", this.read = 0;
                  if (typeof e == "string")
                    this.data = e;
                  else if (t.isArrayBuffer(e) || t.isArrayBufferView(e)) {
                    var n = new Uint8Array(e);
                    try {
                      this.data = String.fromCharCode.apply(null, n);
                    } catch (r) {
                      for (var i = 0; i < n.length; ++i)
                        this.putByte(n[i]);
                    }
                  }
                }, t.ByteBuffer.prototype.length = function() {
                  return this.data.length - this.read;
                }, t.ByteBuffer.prototype.isEmpty = function() {
                  return this.length() <= 0;
                }, t.ByteBuffer.prototype.putByte = function(e) {
                  return this.data += String.fromCharCode(e), this;
                }, t.ByteBuffer.prototype.fillWithByte = function(e, t) {
                  e = String.fromCharCode(e);
                  var n = this.data;
                  while (t > 0)
                    t & 1 && (n += e), t >>>= 1, t > 0 && (e += e);
                  return this.data = n, this;
                }, t.ByteBuffer.prototype.putBytes = function(e) {
                  return this.data += e, this;
                }, t.ByteBuffer.prototype.putString = function(e) {
                  return this.data += t.encodeUtf8(e), this;
                }, t.ByteBuffer.prototype.putInt16 = function(e) {
                  return this.data += String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255), this;
                }, t.ByteBuffer.prototype.putInt24 = function(e) {
                  return this.data += String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255), this;
                }, t.ByteBuffer.prototype.putInt32 = function(e) {
                  return this.data += String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255), this;
                }, t.ByteBuffer.prototype.putInt16Le = function(e) {
                  return this.data += String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255), this;
                }, t.ByteBuffer.prototype.putInt24Le = function(e) {
                  return this.data += String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255), this;
                }, t.ByteBuffer.prototype.putInt32Le = function(e) {
                  return this.data += String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 24 & 255), this;
                }, t.ByteBuffer.prototype.putInt = function(e, t) {
                  do
                    t -= 8, this.data += String.fromCharCode(e >> t & 255);
 while (t > 0);
                  return this;
                }, t.ByteBuffer.prototype.putSignedInt = function(e, t) {
                  return e < 0 && (e += 2 << t - 1), this.putInt(e, t);
                }, t.ByteBuffer.prototype.putBuffer = function(e) {
                  return this.data += e.getBytes(), this;
                }, t.ByteBuffer.prototype.getByte = function() {
                  return this.data.charCodeAt(this.read++);
                }, t.ByteBuffer.prototype.getInt16 = function() {
                  var e = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
                  return this.read += 2, e;
                }, t.ByteBuffer.prototype.getInt24 = function() {
                  var e = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
                  return this.read += 3, e;
                }, t.ByteBuffer.prototype.getInt32 = function() {
                  var e = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
                  return this.read += 4, e;
                }, t.ByteBuffer.prototype.getInt16Le = function() {
                  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
                  return this.read += 2, e;
                }, t.ByteBuffer.prototype.getInt24Le = function() {
                  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
                  return this.read += 3, e;
                }, t.ByteBuffer.prototype.getInt32Le = function() {
                  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
                  return this.read += 4, e;
                }, t.ByteBuffer.prototype.getInt = function(e) {
                  var t = 0;
                  do
                    t = (t << 8) + this.data.charCodeAt(this.read++), e -= 8;
 while (e > 0);
                  return t;
                }, t.ByteBuffer.prototype.getSignedInt = function(e) {
                  var t = this.getInt(e),
                      n = 2 << e - 2;
                  return t >= n && (t -= n << 1), t;
                }, t.ByteBuffer.prototype.getBytes = function(e) {
                  var t;
                  return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : e === 0 ? t = "" : (t = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), t;
                }, t.ByteBuffer.prototype.bytes = function(e) {
                  return typeof e == "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e);
                }, t.ByteBuffer.prototype.at = function(e) {
                  return this.data.charCodeAt(this.read + e);
                }, t.ByteBuffer.prototype.setAt = function(e, t) {
                  return this.data = this.data.substr(0, this.read + e) + String.fromCharCode(t) + this.data.substr(this.read + e + 1), this;
                }, t.ByteBuffer.prototype.last = function() {
                  return this.data.charCodeAt(this.data.length - 1);
                }, t.ByteBuffer.prototype.copy = function() {
                  var e = t.createBuffer(this.data);
                  return e.read = this.read, e;
                }, t.ByteBuffer.prototype.compact = function() {
                  return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
                }, t.ByteBuffer.prototype.clear = function() {
                  return this.data = "", this.read = 0, this;
                }, t.ByteBuffer.prototype.truncate = function(e) {
                  var t = Math.max(0, this.length() - e);
                  return this.data = this.data.substr(this.read, t), this.read = 0, this;
                }, t.ByteBuffer.prototype.toHex = function() {
                  var e = "";
                  for (var t = this.read; t < this.data.length; ++t) {
                    var n = this.data.charCodeAt(t);
                    n < 16 && (e += "0"), e += n.toString(16);
                  }
                  return e;
                }, t.ByteBuffer.prototype.toString = function() {
                  return t.decodeUtf8(this.bytes());
                }, t.createBuffer = function(e, n) {
                  return n = n || "raw", e !== undefined && n === "utf8" && (e = t.encodeUtf8(e)), new t.ByteBuffer(e);
                }, t.fillString = function(e, t) {
                  var n = "";
                  while (t > 0)
                    t & 1 && (n += e), t >>>= 1, t > 0 && (e += e);
                  return n;
                }, t.xorBytes = function(e, t, n) {
                  var r = "",
                      i = "",
                      s = "",
                      o = 0,
                      u = 0;
                  for (; n > 0; --n, ++o)
                    i = e.charCodeAt(o) ^ t.charCodeAt(o), u >= 10 && (r += s, s = "", u = 0), s += String.fromCharCode(i), ++u;
                  return r += s, r;
                }, t.hexToBytes = function(e) {
                  var t = "",
                      n = 0;
                  e.length & !0 && (n = 1, t += String.fromCharCode(parseInt(e[0], 16)));
                  for (; n < e.length; n += 2)
                    t += String.fromCharCode(parseInt(e.substr(n, 2), 16));
                  return t;
                }, t.bytesToHex = function(e) {
                  return t.createBuffer(e).toHex();
                }, t.int32ToBytes = function(e) {
                  return String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255);
                };
                var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    i = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
                t.encode64 = function(e, t) {
                  var n = "",
                      i = "",
                      s,
                      o,
                      u,
                      a = 0;
                  while (a < e.length)
                    s = e.charCodeAt(a++), o = e.charCodeAt(a++), u = e.charCodeAt(a++), n += r.charAt(s >> 2), n += r.charAt((s & 3) << 4 | o >> 4), isNaN(o) ? n += "==" : (n += r.charAt((o & 15) << 2 | u >> 6), n += isNaN(u) ? "=" : r.charAt(u & 63)), t && n.length > t && (i += n.substr(0, t) + "\r\n", n = n.substr(t));
                  return i += n, i;
                }, t.decode64 = function(e) {
                  e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                  var t = "",
                      n,
                      r,
                      s,
                      o,
                      u = 0;
                  while (u < e.length)
                    n = i[e.charCodeAt(u++) - 43], r = i[e.charCodeAt(u++) - 43], s = i[e.charCodeAt(u++) - 43], o = i[e.charCodeAt(u++) - 43], t += String.fromCharCode(n << 2 | r >> 4), s !== 64 && (t += String.fromCharCode((r & 15) << 4 | s >> 2), o !== 64 && (t += String.fromCharCode((s & 3) << 6 | o)));
                  return t;
                }, t.encodeUtf8 = function(e) {
                  return unescape(encodeURIComponent(e));
                }, t.decodeUtf8 = function(e) {
                  return decodeURIComponent(escape(e));
                }, t.deflate = function(e, n, r) {
                  n = t.decode64(e.deflate(t.encode64(n)).rval);
                  if (r) {
                    var i = 2,
                        s = n.charCodeAt(1);
                    s & 32 && (i = 6), n = n.substring(i, n.length - 4);
                  }
                  return n;
                }, t.inflate = function(e, n, r) {
                  var i = e.inflate(t.encode64(n)).rval;
                  return i === null ? null : t.decode64(i);
                };
                var s = function(e, n, r) {
                  if (!e)
                    throw {message: "WebStorage not available."};
                  var i;
                  r === null ? i = e.removeItem(n) : (r = t.encode64(JSON.stringify(r)), i = e.setItem(n, r));
                  if (typeof i != "undefined" && i.rval !== !0)
                    throw i.error;
                },
                    o = function(e, n) {
                      if (!e)
                        throw {message: "WebStorage not available."};
                      var r = e.getItem(n);
                      if (e.init)
                        if (r.rval === null) {
                          if (r.error)
                            throw r.error;
                          r = null;
                        } else
                          r = r.rval;
                      return r !== null && (r = JSON.parse(t.decode64(r))), r;
                    },
                    u = function(e, t, n, r) {
                      var i = o(e, t);
                      i === null && (i = {}), i[n] = r, s(e, t, i);
                    },
                    a = function(e, t, n) {
                      var r = o(e, t);
                      return r !== null && (r = n in r ? r[n] : null), r;
                    },
                    f = function(e, t, n) {
                      var r = o(e, t);
                      if (r !== null && n in r) {
                        delete r[n];
                        var i = !0;
                        for (var u in r) {
                          i = !1;
                          break;
                        }
                        i && (r = null), s(e, t, r);
                      }
                    },
                    l = function(e, t) {
                      s(e, t, null);
                    },
                    c = function(e, t, n) {
                      var r = null;
                      typeof n == "undefined" && (n = ["web", "flash"]);
                      var i,
                          s = !1,
                          o = null;
                      for (var u in n) {
                        i = n[u];
                        try {
                          if (i === "flash" || i === "both") {
                            if (t[0] === null)
                              throw {message: "Flash local storage not available."};
                            r = e.apply(this, t), s = i === "flash";
                          }
                          if (i === "web" || i === "both")
                            t[0] = localStorage, r = e.apply(this, t), s = !0;
                        } catch (a) {
                          o = a;
                        }
                        if (s)
                          break;
                      }
                      if (!s)
                        throw o;
                      return r;
                    };
                t.setItem = function(e, t, n, r, i) {
                  c(u, arguments, i);
                }, t.getItem = function(e, t, n, r) {
                  return c(a, arguments, r);
                }, t.removeItem = function(e, t, n, r) {
                  c(f, arguments, r);
                }, t.clearItems = function(e, t, n) {
                  c(l, arguments, n);
                }, t.parseUrl = function(e) {
                  var t = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
                  t.lastIndex = 0;
                  var n = t.exec(e),
                      r = n === null ? null : {
                        full: e,
                        scheme: n[1],
                        host: n[2],
                        port: n[3],
                        path: n[4]
                      };
                  return r && (r.fullHost = r.host, r.port ? r.port !== 80 && r.scheme === "http" ? r.fullHost += ":" + r.port : r.port !== 443 && r.scheme === "https" && (r.fullHost += ":" + r.port) : r.scheme === "http" ? r.port = 80 : r.scheme === "https" && (r.port = 443), r.full = r.scheme + "://" + r.fullHost), r;
                };
                var h = null;
                t.getQueryVariables = function(e) {
                  var t = function(e) {
                    var t = {},
                        n = e.split("&");
                    for (var r = 0; r < n.length; r++) {
                      var i = n[r].indexOf("="),
                          s,
                          o;
                      i > 0 ? (s = n[r].substring(0, i), o = n[r].substring(i + 1)) : (s = n[r], o = null), s in t || (t[s] = []), !(s in Object.prototype) && o !== null && t[s].push(unescape(o));
                    }
                    return t;
                  },
                      n;
                  return typeof e == "undefined" ? (h === null && (typeof window == "undefined" ? h = {} : h = t(window.location.search.substring(1))), n = h) : n = t(e), n;
                }, t.parseFragment = function(e) {
                  var n = e,
                      r = "",
                      i = e.indexOf("?");
                  i > 0 && (n = e.substring(0, i), r = e.substring(i + 1));
                  var s = n.split("/");
                  s.length > 0 && s[0] === "" && s.shift();
                  var o = r === "" ? {} : t.getQueryVariables(r);
                  return {
                    pathString: n,
                    queryString: r,
                    path: s,
                    query: o
                  };
                }, t.makeRequest = function(e) {
                  var n = t.parseFragment(e),
                      r = {
                        path: n.pathString,
                        query: n.queryString,
                        getPath: function(e) {
                          return typeof e == "undefined" ? n.path : n.path[e];
                        },
                        getQuery: function(e, t) {
                          var r;
                          return typeof e == "undefined" ? r = n.query : (r = n.query[e], r && typeof t != "undefined" && (r = r[t])), r;
                        },
                        getQueryLast: function(e, t) {
                          var n,
                              i = r.getQuery(e);
                          return i ? n = i[i.length - 1] : n = t, n;
                        }
                      };
                  return r;
                }, t.makeLink = function(e, t, n) {
                  e = jQuery.isArray(e) ? e.join("/") : e;
                  var r = jQuery.param(t || {});
                  return n = n || "", e + (r.length > 0 ? "?" + r : "") + (n.length > 0 ? "#" + n : "");
                }, t.setPath = function(e, t, n) {
                  if (typeof e == "object" && e !== null) {
                    var r = 0,
                        i = t.length;
                    while (r < i) {
                      var s = t[r++];
                      if (r == i)
                        e[s] = n;
                      else {
                        var o = s in e;
                        if (!o || o && typeof e[s] != "object" || o && e[s] === null)
                          e[s] = {};
                        e = e[s];
                      }
                    }
                  }
                }, t.getPath = function(e, t, n) {
                  var r = 0,
                      i = t.length,
                      s = !0;
                  while (s && r < i && typeof e == "object" && e !== null) {
                    var o = t[r++];
                    s = o in e, s && (e = e[o]);
                  }
                  return s ? e : n;
                }, t.deletePath = function(e, t) {
                  if (typeof e == "object" && e !== null) {
                    var n = 0,
                        r = t.length;
                    while (n < r) {
                      var i = t[n++];
                      if (n == r)
                        delete e[i];
                      else {
                        if (!(i in e && typeof e[i] == "object" && e[i] !== null))
                          break;
                        e = e[i];
                      }
                    }
                  }
                }, t.isEmpty = function(e) {
                  for (var t in e)
                    if (e.hasOwnProperty(t))
                      return !1;
                  return !0;
                }, t.format = function(e) {
                  var t = /%./g,
                      n,
                      r,
                      i = 0,
                      s = [],
                      o = 0;
                  while (n = t.exec(e)) {
                    r = e.substring(o, t.lastIndex - 2), r.length > 0 && s.push(r), o = t.lastIndex;
                    var u = n[0][1];
                    switch (u) {
                      case "s":
                      case "o":
                        i < arguments.length ? s.push(arguments[i++ + 1]) : s.push("<?>");
                        break;
                      case "%":
                        s.push("%");
                        break;
                      default:
                        s.push("<%" + u + "?>");
                    }
                  }
                  return s.push(e.substring(o)), s.join("");
                }, t.formatNumber = function(e, t, n, r) {
                  var i = e,
                      s = isNaN(t = Math.abs(t)) ? 2 : t,
                      o = n === undefined ? "," : n,
                      u = r === undefined ? "." : r,
                      a = i < 0 ? "-" : "",
                      f = parseInt(i = Math.abs(+i || 0).toFixed(s), 10) + "",
                      l = f.length > 3 ? f.length % 3 : 0;
                  return a + (l ? f.substr(0, l) + u : "") + f.substr(l).replace(/(\d{3})(?=\d)/g, "$1" + u) + (s ? o + Math.abs(i - f).toFixed(s).slice(2) : "");
                }, t.formatSize = function(e) {
                  return e >= 1073741824 ? e = t.formatNumber(e / 1073741824, 2, ".", "") + " GiB" : e >= 1048576 ? e = t.formatNumber(e / 1048576, 2, ".", "") + " MiB" : e >= 1024 ? e = t.formatNumber(e / 1024, 0) + " KiB" : e = t.formatNumber(e, 0) + " bytes", e;
                }, t.bytesFromIP = function(e) {
                  return e.indexOf(".") !== -1 ? t.bytesFromIPv4(e) : e.indexOf(":") !== -1 ? t.bytesFromIPv6(e) : null;
                }, t.bytesFromIPv4 = function(e) {
                  e = e.split(".");
                  if (e.length !== 4)
                    return null;
                  var n = t.createBuffer();
                  for (var r = 0; r < e.length; ++r) {
                    var i = parseInt(e[r], 10);
                    if (isNaN(i))
                      return null;
                    n.putByte(i);
                  }
                  return n.getBytes();
                }, t.bytesFromIPv6 = function(e) {
                  var n = 0;
                  e = e.split(":").filter(function(e) {
                    return e.length === 0 && ++n, !0;
                  });
                  var r = (8 - e.length + n) * 2,
                      i = t.createBuffer();
                  for (var s = 0; s < 8; ++s) {
                    if (!e[s] || e[s].length === 0) {
                      i.fillWithByte(0, r), r = 0;
                      continue;
                    }
                    var o = t.hexToBytes(e[s]);
                    o.length < 2 && i.putByte(0), i.putBytes(o);
                  }
                  return i.getBytes();
                }, t.bytesToIP = function(e) {
                  return e.length === 4 ? t.bytesToIPv4(e) : e.length === 16 ? t.bytesToIPv6(e) : null;
                }, t.bytesToIPv4 = function(e) {
                  if (e.length !== 4)
                    return null;
                  var t = [];
                  for (var n = 0; n < e.length; ++n)
                    t.push(e.charCodeAt(n));
                  return t.join(".");
                }, t.bytesToIPv6 = function(e) {
                  if (e.length !== 16)
                    return null;
                  var n = [],
                      r = [],
                      i = 0;
                  for (var s = 0; s < e.length; s += 2) {
                    var o = t.bytesToHex(e[s] + e[s + 1]);
                    while (o[0] === "0" && o !== "0")
                      o = o.substr(1);
                    if (o === "0") {
                      var u = r[r.length - 1],
                          a = n.length;
                      !u || a !== u.end + 1 ? r.push({
                        start: a,
                        end: a
                      }) : (u.end = a, u.end - u.start > r[i].end - r[i].start && (i = r.length - 1));
                    }
                    n.push(o);
                  }
                  if (r.length > 0) {
                    var f = r[i];
                    f.end - f.start > 0 && (n.splice(f.start, f.end - f.start + 1, ""), f.start === 0 && n.unshift(""), f.end === 7 && n.push(""));
                  }
                  return n.join(":");
                };
              }
              var r = "util";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/util", ["require", "module"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = !1,
                    n = 4,
                    r,
                    i,
                    s,
                    o,
                    u,
                    a = function() {
                      t = !0, s = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                      var e = new Array(256);
                      for (var n = 0; n < 128; ++n)
                        e[n] = n << 1, e[n + 128] = n + 128 << 1 ^ 283;
                      r = new Array(256), i = new Array(256), o = new Array(4), u = new Array(4);
                      for (var n = 0; n < 4; ++n)
                        o[n] = new Array(256), u[n] = new Array(256);
                      var a = 0,
                          f = 0,
                          l,
                          c,
                          h,
                          p,
                          d,
                          v,
                          m;
                      for (var n = 0; n < 256; ++n) {
                        p = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4, p = p >> 8 ^ p & 255 ^ 99, r[a] = p, i[p] = a, d = e[p], l = e[a], c = e[l], h = e[c], v = d << 24 ^ p << 16 ^ p << 8 ^ (p ^ d), m = (l ^ c ^ h) << 24 ^ (a ^ h) << 16 ^ (a ^ c ^ h) << 8 ^ (a ^ l ^ h);
                        for (var g = 0; g < 4; ++g)
                          o[g][a] = v, u[g][p] = m, v = v << 24 | v >>> 8, m = m << 24 | m >>> 8;
                        a === 0 ? a = f = 1 : (a = l ^ e[e[e[l ^ h]]], f ^= e[e[f]]);
                      }
                    },
                    f = function(e, t) {
                      var i = e.slice(0),
                          o,
                          a = 1,
                          f = i.length,
                          l = f + 6 + 1,
                          c = n * l;
                      for (var h = f; h < c; ++h)
                        o = i[h - 1], h % f === 0 ? (o = r[o >>> 16 & 255] << 24 ^ r[o >>> 8 & 255] << 16 ^ r[o & 255] << 8 ^ r[o >>> 24] ^ s[a] << 24, a++) : f > 6 && h % f === 4 && (o = r[o >>> 24] << 24 ^ r[o >>> 16 & 255] << 16 ^ r[o >>> 8 & 255] << 8 ^ r[o & 255]), i[h] = i[h - f] ^ o;
                      if (t) {
                        var p,
                            d = u[0],
                            v = u[1],
                            m = u[2],
                            g = u[3],
                            y = i.slice(0),
                            c = i.length;
                        for (var h = 0,
                            b = c - n; h < c; h += n, b -= n)
                          if (h === 0 || h === c - n)
                            y[h] = i[b], y[h + 1] = i[b + 3], y[h + 2] = i[b + 2], y[h + 3] = i[b + 1];
                          else
                            for (var w = 0; w < n; ++w)
                              p = i[b + w], y[h + (3 & -w)] = d[r[p >>> 24]] ^ v[r[p >>> 16 & 255]] ^ m[r[p >>> 8 & 255]] ^ g[r[p & 255]];
                        i = y;
                      }
                      return i;
                    },
                    l = function(e, t, n, s) {
                      var a = e.length / 4 - 1,
                          f,
                          l,
                          c,
                          h,
                          p;
                      s ? (f = u[0], l = u[1], c = u[2], h = u[3], p = i) : (f = o[0], l = o[1], c = o[2], h = o[3], p = r);
                      var d,
                          v,
                          m,
                          g,
                          y,
                          b,
                          w;
                      d = t[0] ^ e[0], v = t[s ? 3 : 1] ^ e[1], m = t[2] ^ e[2], g = t[s ? 1 : 3] ^ e[3];
                      var E = 3;
                      for (var S = 1; S < a; ++S)
                        y = f[d >>> 24] ^ l[v >>> 16 & 255] ^ c[m >>> 8 & 255] ^ h[g & 255] ^ e[++E], b = f[v >>> 24] ^ l[m >>> 16 & 255] ^ c[g >>> 8 & 255] ^ h[d & 255] ^ e[++E], w = f[m >>> 24] ^ l[g >>> 16 & 255] ^ c[d >>> 8 & 255] ^ h[v & 255] ^ e[++E], g = f[g >>> 24] ^ l[d >>> 16 & 255] ^ c[v >>> 8 & 255] ^ h[m & 255] ^ e[++E], d = y, v = b, m = w;
                      n[0] = p[d >>> 24] << 24 ^ p[v >>> 16 & 255] << 16 ^ p[m >>> 8 & 255] << 8 ^ p[g & 255] ^ e[++E], n[s ? 3 : 1] = p[v >>> 24] << 24 ^ p[m >>> 16 & 255] << 16 ^ p[g >>> 8 & 255] << 8 ^ p[d & 255] ^ e[++E], n[2] = p[m >>> 24] << 24 ^ p[g >>> 16 & 255] << 16 ^ p[d >>> 8 & 255] << 8 ^ p[v & 255] ^ e[++E], n[s ? 1 : 3] = p[g >>> 24] << 24 ^ p[d >>> 16 & 255] << 16 ^ p[v >>> 8 & 255] << 8 ^ p[m & 255] ^ e[++E];
                    },
                    c = function(r, i, s, o, u) {
                      function C() {
                        if (o)
                          for (var e = 0; e < n; ++e)
                            E[e] = b.getInt32();
                        else
                          for (var e = 0; e < n; ++e)
                            E[e] = x[e] ^ b.getInt32();
                        l(g, E, S, o);
                        if (o) {
                          for (var e = 0; e < n; ++e)
                            w.putInt32(x[e] ^ S[e]);
                          x = E.slice(0);
                        } else {
                          for (var e = 0; e < n; ++e)
                            w.putInt32(S[e]);
                          x = S;
                        }
                      }
                      function k() {
                        l(g, E, S, !1);
                        for (var e = 0; e < n; ++e)
                          E[e] = b.getInt32();
                        for (var e = 0; e < n; ++e) {
                          var t = E[e] ^ S[e];
                          o || (E[e] = t), w.putInt32(t);
                        }
                      }
                      function L() {
                        l(g, E, S, !1);
                        for (var e = 0; e < n; ++e)
                          E[e] = b.getInt32();
                        for (var e = 0; e < n; ++e)
                          w.putInt32(E[e] ^ S[e]), E[e] = S[e];
                      }
                      function A() {
                        l(g, E, S, !1);
                        for (var e = n - 1; e >= 0; --e) {
                          if (E[e] !== 4294967295) {
                            ++E[e];
                            break;
                          }
                          E[e] = 0;
                        }
                        for (var e = 0; e < n; ++e)
                          w.putInt32(b.getInt32() ^ S[e]);
                      }
                      var c = null;
                      t || a(), u = (u || "CBC").toUpperCase();
                      if (typeof r != "string" || r.length !== 16 && r.length !== 24 && r.length !== 32) {
                        if (e.util.isArray(r) && (r.length === 16 || r.length === 24 || r.length === 32)) {
                          var h = r,
                              r = e.util.createBuffer();
                          for (var p = 0; p < h.length; ++p)
                            r.putByte(h[p]);
                        }
                      } else
                        r = e.util.createBuffer(r);
                      if (!e.util.isArray(r)) {
                        var h = r;
                        r = [];
                        var d = h.length();
                        if (d === 16 || d === 24 || d === 32) {
                          d >>>= 2;
                          for (var p = 0; p < d; ++p)
                            r.push(h.getInt32());
                        }
                      }
                      if (!e.util.isArray(r) || r.length !== 4 && r.length !== 6 && r.length !== 8)
                        return c;
                      var v = ["CFB", "OFB", "CTR"].indexOf(u) !== -1,
                          m = u === "CBC",
                          g = f(r, o && !v),
                          y = n << 2,
                          b,
                          w,
                          E,
                          S,
                          x,
                          T,
                          N;
                      c = {output: null};
                      if (u === "CBC")
                        N = C;
                      else if (u === "CFB")
                        N = k;
                      else if (u === "OFB")
                        N = L;
                      else {
                        if (u !== "CTR")
                          throw {message: 'Unsupported block cipher mode of operation: "' + u + '"'};
                        N = A;
                      }
                      return c.update = function(e) {
                        T || b.putBuffer(e);
                        while (b.length() >= y || b.length() > 0 && T)
                          N();
                      }, c.finish = function(e) {
                        var t = !0,
                            r = b.length() % y;
                        if (!o)
                          if (e)
                            t = e(y, b, o);
                          else if (m) {
                            var i = b.length() === y ? y : y - b.length();
                            b.fillWithByte(i, i);
                          }
                        t && (T = !0, c.update());
                        if (o) {
                          m && (t = r === 0);
                          if (t)
                            if (e)
                              t = e(y, w, o);
                            else if (m) {
                              var s = w.length(),
                                  u = w.at(s - 1);
                              u > n << 2 ? t = !1 : w.truncate(u);
                            }
                        }
                        return !m && !e && r > 0 && w.truncate(y - r), t;
                      }, c.start = function(t, r) {
                        t === null && (t = x.slice(0));
                        if (typeof t == "string" && t.length === 16)
                          t = e.util.createBuffer(t);
                        else if (e.util.isArray(t) && t.length === 16) {
                          var i = t,
                              t = e.util.createBuffer();
                          for (var s = 0; s < 16; ++s)
                            t.putByte(i[s]);
                        }
                        if (!e.util.isArray(t)) {
                          var i = t;
                          t = new Array(4), t[0] = i.getInt32(), t[1] = i.getInt32(), t[2] = i.getInt32(), t[3] = i.getInt32();
                        }
                        b = e.util.createBuffer(), w = r || e.util.createBuffer(), x = t.slice(0), E = new Array(n), S = new Array(n), T = !1, c.output = w;
                        if (["CFB", "OFB", "CTR"].indexOf(u) !== -1) {
                          for (var s = 0; s < n; ++s)
                            E[s] = x[s];
                          x = null;
                        }
                      }, i !== null && c.start(i, s), c;
                    };
                e.aes = e.aes || {}, e.aes.startEncrypting = function(e, t, n, r) {
                  return c(e, t, n, !1, r);
                }, e.aes.createEncryptionCipher = function(e, t) {
                  return c(e, null, null, !1, t);
                }, e.aes.startDecrypting = function(e, t, n, r) {
                  return c(e, t, n, !0, r);
                }, e.aes.createDecryptionCipher = function(e, t) {
                  return c(e, null, null, !0, t);
                }, e.aes._expandKey = function(e, n) {
                  return t || a(), f(e, n);
                }, e.aes._updateBlock = l;
              }
              var r = "aes";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/aes", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.pki = e.pki || {};
                var t = e.pki.oids = e.oids = e.oids || {};
                t["1.2.840.113549.1.1.1"] = "rsaEncryption", t.rsaEncryption = "1.2.840.113549.1.1.1", t["1.2.840.113549.1.1.4"] = "md5WithRSAEncryption", t.md5WithRSAEncryption = "1.2.840.113549.1.1.4", t["1.2.840.113549.1.1.5"] = "sha1WithRSAEncryption", t.sha1WithRSAEncryption = "1.2.840.113549.1.1.5", t["1.2.840.113549.1.1.7"] = "RSAES-OAEP", t["RSAES-OAEP"] = "1.2.840.113549.1.1.7", t["1.2.840.113549.1.1.8"] = "mgf1", t.mgf1 = "1.2.840.113549.1.1.8", t["1.2.840.113549.1.1.9"] = "pSpecified", t.pSpecified = "1.2.840.113549.1.1.9", t["1.2.840.113549.1.1.10"] = "RSASSA-PSS", t["RSASSA-PSS"] = "1.2.840.113549.1.1.10", t["1.2.840.113549.1.1.11"] = "sha256WithRSAEncryption", t.sha256WithRSAEncryption = "1.2.840.113549.1.1.11", t["1.2.840.113549.1.1.12"] = "sha384WithRSAEncryption", t.sha384WithRSAEncryption = "1.2.840.113549.1.1.12", t["1.2.840.113549.1.1.13"] = "sha512WithRSAEncryption", t.sha512WithRSAEncryption = "1.2.840.113549.1.1.13", t["1.3.14.3.2.7"] = "desCBC", t.desCBC = "1.3.14.3.2.7", t["1.3.14.3.2.26"] = "sha1", t.sha1 = "1.3.14.3.2.26", t["2.16.840.1.101.3.4.2.1"] = "sha256", t.sha256 = "2.16.840.1.101.3.4.2.1", t["2.16.840.1.101.3.4.2.2"] = "sha384", t.sha384 = "2.16.840.1.101.3.4.2.2", t["2.16.840.1.101.3.4.2.3"] = "sha512", t.sha512 = "2.16.840.1.101.3.4.2.3", t["1.2.840.113549.2.5"] = "md5", t.md5 = "1.2.840.113549.2.5", t["1.2.840.113549.1.7.1"] = "data", t.data = "1.2.840.113549.1.7.1", t["1.2.840.113549.1.7.2"] = "signedData", t.signedData = "1.2.840.113549.1.7.2", t["1.2.840.113549.1.7.3"] = "envelopedData", t.envelopedData = "1.2.840.113549.1.7.3", t["1.2.840.113549.1.7.4"] = "signedAndEnvelopedData", t.signedAndEnvelopedData = "1.2.840.113549.1.7.4", t["1.2.840.113549.1.7.5"] = "digestedData", t.digestedData = "1.2.840.113549.1.7.5", t["1.2.840.113549.1.7.6"] = "encryptedData", t.encryptedData = "1.2.840.113549.1.7.6", t["1.2.840.113549.1.9.1"] = "emailAddress", t.emailAddress = "1.2.840.113549.1.9.1", t["1.2.840.113549.1.9.2"] = "unstructuredName", t.unstructuredName = "1.2.840.113549.1.9.2", t["1.2.840.113549.1.9.3"] = "contentType", t.contentType = "1.2.840.113549.1.9.3", t["1.2.840.113549.1.9.4"] = "messageDigest", t.messageDigest = "1.2.840.113549.1.9.4", t["1.2.840.113549.1.9.5"] = "signingTime", t.signingTime = "1.2.840.113549.1.9.5", t["1.2.840.113549.1.9.6"] = "counterSignature", t.counterSignature = "1.2.840.113549.1.9.6", t["1.2.840.113549.1.9.7"] = "challengePassword", t.challengePassword = "1.2.840.113549.1.9.7", t["1.2.840.113549.1.9.8"] = "unstructuredAddress", t.unstructuredAddress = "1.2.840.113549.1.9.8", t["1.2.840.113549.1.9.20"] = "friendlyName", t.friendlyName = "1.2.840.113549.1.9.20", t["1.2.840.113549.1.9.21"] = "localKeyId", t.localKeyId = "1.2.840.113549.1.9.21", t["1.2.840.113549.1.9.22.1"] = "x509Certificate", t.x509Certificate = "1.2.840.113549.1.9.22.1", t["1.2.840.113549.1.12.10.1.1"] = "keyBag", t.keyBag = "1.2.840.113549.1.12.10.1.1", t["1.2.840.113549.1.12.10.1.2"] = "pkcs8ShroudedKeyBag", t.pkcs8ShroudedKeyBag = "1.2.840.113549.1.12.10.1.2", t["1.2.840.113549.1.12.10.1.3"] = "certBag", t.certBag = "1.2.840.113549.1.12.10.1.3", t["1.2.840.113549.1.12.10.1.4"] = "crlBag", t.crlBag = "1.2.840.113549.1.12.10.1.4", t["1.2.840.113549.1.12.10.1.5"] = "secretBag", t.secretBag = "1.2.840.113549.1.12.10.1.5", t["1.2.840.113549.1.12.10.1.6"] = "safeContentsBag", t.safeContentsBag = "1.2.840.113549.1.12.10.1.6", t["1.2.840.113549.1.5.13"] = "pkcs5PBES2", t.pkcs5PBES2 = "1.2.840.113549.1.5.13", t["1.2.840.113549.1.5.12"] = "pkcs5PBKDF2", t.pkcs5PBKDF2 = "1.2.840.113549.1.5.12", t["1.2.840.113549.1.12.1.1"] = "pbeWithSHAAnd128BitRC4", t.pbeWithSHAAnd128BitRC4 = "1.2.840.113549.1.12.1.1", t["1.2.840.113549.1.12.1.2"] = "pbeWithSHAAnd40BitRC4", t.pbeWithSHAAnd40BitRC4 = "1.2.840.113549.1.12.1.2", t["1.2.840.113549.1.12.1.3"] = "pbeWithSHAAnd3-KeyTripleDES-CBC", t["pbeWithSHAAnd3-KeyTripleDES-CBC"] = "1.2.840.113549.1.12.1.3", t["1.2.840.113549.1.12.1.4"] = "pbeWithSHAAnd2-KeyTripleDES-CBC", t["pbeWithSHAAnd2-KeyTripleDES-CBC"] = "1.2.840.113549.1.12.1.4", t["1.2.840.113549.1.12.1.5"] = "pbeWithSHAAnd128BitRC2-CBC", t["pbeWithSHAAnd128BitRC2-CBC"] = "1.2.840.113549.1.12.1.5", t["1.2.840.113549.1.12.1.6"] = "pbewithSHAAnd40BitRC2-CBC", t["pbewithSHAAnd40BitRC2-CBC"] = "1.2.840.113549.1.12.1.6", t["1.2.840.113549.3.7"] = "des-EDE3-CBC", t["des-EDE3-CBC"] = "1.2.840.113549.3.7", t["2.16.840.1.101.3.4.1.2"] = "aes128-CBC", t["aes128-CBC"] = "2.16.840.1.101.3.4.1.2", t["2.16.840.1.101.3.4.1.22"] = "aes192-CBC", t["aes192-CBC"] = "2.16.840.1.101.3.4.1.22", t["2.16.840.1.101.3.4.1.42"] = "aes256-CBC", t["aes256-CBC"] = "2.16.840.1.101.3.4.1.42", t["2.5.4.3"] = "commonName", t.commonName = "2.5.4.3", t["2.5.4.5"] = "serialName", t.serialName = "2.5.4.5", t["2.5.4.6"] = "countryName", t.countryName = "2.5.4.6", t["2.5.4.7"] = "localityName", t.localityName = "2.5.4.7", t["2.5.4.8"] = "stateOrProvinceName", t.stateOrProvinceName = "2.5.4.8", t["2.5.4.10"] = "organizationName", t.organizationName = "2.5.4.10", t["2.5.4.11"] = "organizationalUnitName", t.organizationalUnitName = "2.5.4.11", t["2.16.840.1.113730.1.1"] = "nsCertType", t.nsCertType = "2.16.840.1.113730.1.1", t["2.5.29.1"] = "authorityKeyIdentifier", t["2.5.29.2"] = "keyAttributes", t["2.5.29.3"] = "certificatePolicies", t["2.5.29.4"] = "keyUsageRestriction", t["2.5.29.5"] = "policyMapping", t["2.5.29.6"] = "subtreesConstraint", t["2.5.29.7"] = "subjectAltName", t["2.5.29.8"] = "issuerAltName", t["2.5.29.9"] = "subjectDirectoryAttributes", t["2.5.29.10"] = "basicConstraints", t["2.5.29.11"] = "nameConstraints", t["2.5.29.12"] = "policyConstraints", t["2.5.29.13"] = "basicConstraints", t["2.5.29.14"] = "subjectKeyIdentifier", t.subjectKeyIdentifier = "2.5.29.14", t["2.5.29.15"] = "keyUsage", t.keyUsage = "2.5.29.15", t["2.5.29.16"] = "privateKeyUsagePeriod", t["2.5.29.17"] = "subjectAltName", t.subjectAltName = "2.5.29.17", t["2.5.29.18"] = "issuerAltName", t.issuerAltName = "2.5.29.18", t["2.5.29.19"] = "basicConstraints", t.basicConstraints = "2.5.29.19", t["2.5.29.20"] = "cRLNumber", t["2.5.29.21"] = "cRLReason", t["2.5.29.22"] = "expirationDate", t["2.5.29.23"] = "instructionCode", t["2.5.29.24"] = "invalidityDate", t["2.5.29.25"] = "cRLDistributionPoints", t["2.5.29.26"] = "issuingDistributionPoint", t["2.5.29.27"] = "deltaCRLIndicator", t["2.5.29.28"] = "issuingDistributionPoint", t["2.5.29.29"] = "certificateIssuer", t["2.5.29.30"] = "nameConstraints", t["2.5.29.31"] = "cRLDistributionPoints", t["2.5.29.32"] = "certificatePolicies", t["2.5.29.33"] = "policyMappings", t["2.5.29.34"] = "policyConstraints", t["2.5.29.35"] = "authorityKeyIdentifier", t["2.5.29.36"] = "policyConstraints", t["2.5.29.37"] = "extKeyUsage", t.extKeyUsage = "2.5.29.37", t["2.5.29.46"] = "freshestCRL", t["2.5.29.54"] = "inhibitAnyPolicy", t["1.3.6.1.5.5.7.3.1"] = "serverAuth", t.serverAuth = "1.3.6.1.5.5.7.3.1", t["1.3.6.1.5.5.7.3.2"] = "clientAuth", t.clientAuth = "1.3.6.1.5.5.7.3.2", t["1.3.6.1.5.5.7.3.3"] = "codeSigning", t.codeSigning = "1.3.6.1.5.5.7.3.3", t["1.3.6.1.5.5.7.3.4"] = "emailProtection", t.emailProtection = "1.3.6.1.5.5.7.3.4", t["1.3.6.1.5.5.7.3.8"] = "timeStamping", t.timeStamping = "1.3.6.1.5.5.7.3.8";
              }
              var r = "oids";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/oids", ["require", "module"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.asn1 = e.asn1 || {};
                t.Class = {
                  UNIVERSAL: 0,
                  APPLICATION: 64,
                  CONTEXT_SPECIFIC: 128,
                  PRIVATE: 192
                }, t.Type = {
                  NONE: 0,
                  BOOLEAN: 1,
                  INTEGER: 2,
                  BITSTRING: 3,
                  OCTETSTRING: 4,
                  NULL: 5,
                  OID: 6,
                  ODESC: 7,
                  EXTERNAL: 8,
                  REAL: 9,
                  ENUMERATED: 10,
                  EMBEDDED: 11,
                  UTF8: 12,
                  ROID: 13,
                  SEQUENCE: 16,
                  SET: 17,
                  PRINTABLESTRING: 19,
                  IA5STRING: 22,
                  UTCTIME: 23,
                  GENERALIZEDTIME: 24,
                  BMPSTRING: 30
                }, t.create = function(t, n, r, i) {
                  if (e.util.isArray(i)) {
                    var s = [];
                    for (var o = 0; o < i.length; ++o)
                      i[o] !== undefined && s.push(i[o]);
                    i = s;
                  }
                  return {
                    tagClass: t,
                    type: n,
                    constructed: r,
                    composed: r || e.util.isArray(i),
                    value: i
                  };
                };
                var n = function(e) {
                  var t = e.getByte();
                  if (t === 128)
                    return undefined;
                  var n,
                      r = t & 128;
                  return r ? n = e.getInt((t & 127) << 3) : n = t, n;
                };
                t.fromDer = function(r, i) {
                  i === undefined && (i = !0), typeof r == "string" && (r = e.util.createBuffer(r));
                  if (r.length() < 2)
                    throw {
                      message: "Too few bytes to parse DER.",
                      bytes: r.length()
                    };
                  var s = r.getByte(),
                      o = s & 192,
                      u = s & 31,
                      a = n(r);
                  if (r.length() < a) {
                    if (i)
                      throw {
                        message: "Too few bytes to read ASN.1 value.",
                        detail: r.length() + " < " + a
                      };
                    a = r.length();
                  }
                  var f,
                      l = (s & 32) === 32,
                      c = l;
                  if (!c && o === t.Class.UNIVERSAL && u === t.Type.BITSTRING && a > 1) {
                    var h = r.read,
                        p = r.getByte();
                    if (p === 0) {
                      s = r.getByte();
                      var d = s & 192;
                      if (d === t.Class.UNIVERSAL || d === t.Class.CONTEXT_SPECIFIC)
                        try {
                          var v = n(r);
                          c = v === a - (r.read - h), c && (++h, --a);
                        } catch (m) {}
                    }
                    r.read = h;
                  }
                  if (c) {
                    f = [];
                    if (a === undefined)
                      for (; ; ) {
                        if (r.bytes(2) === String.fromCharCode(0, 0)) {
                          r.getBytes(2);
                          break;
                        }
                        f.push(t.fromDer(r, i));
                      }
                    else {
                      var g = r.length();
                      while (a > 0)
                        f.push(t.fromDer(r, i)), a -= g - r.length(), g = r.length();
                    }
                  } else {
                    if (a === undefined) {
                      if (i)
                        throw {message: "Non-constructed ASN.1 object of indefinite length."};
                      a = r.length();
                    }
                    if (u === t.Type.BMPSTRING) {
                      f = "";
                      for (var y = 0; y < a; y += 2)
                        f += String.fromCharCode(r.getInt16());
                    } else
                      f = r.getBytes(a);
                  }
                  return t.create(o, u, l, f);
                }, t.toDer = function(n) {
                  var r = e.util.createBuffer(),
                      i = n.tagClass | n.type,
                      s = e.util.createBuffer();
                  if (n.composed) {
                    n.constructed ? i |= 32 : s.putByte(0);
                    for (var o = 0; o < n.value.length; ++o)
                      n.value[o] !== undefined && s.putBuffer(t.toDer(n.value[o]));
                  } else if (n.type === t.Type.BMPSTRING)
                    for (var o = 0; o < n.value.length; ++o)
                      s.putInt16(n.value.charCodeAt(o));
                  else
                    s.putBytes(n.value);
                  r.putByte(i);
                  if (s.length() <= 127)
                    r.putByte(s.length() & 127);
                  else {
                    var u = s.length(),
                        a = "";
                    do
                      a += String.fromCharCode(u & 255), u >>>= 8;
 while (u > 0);
                    r.putByte(a.length | 128);
                    for (var o = a.length - 1; o >= 0; --o)
                      r.putByte(a.charCodeAt(o));
                  }
                  return r.putBuffer(s), r;
                }, t.oidToDer = function(t) {
                  var n = t.split("."),
                      r = e.util.createBuffer();
                  r.putByte(40 * parseInt(n[0], 10) + parseInt(n[1], 10));
                  var i,
                      s,
                      o,
                      u;
                  for (var a = 2; a < n.length; ++a) {
                    i = !0, s = [], o = parseInt(n[a], 10);
                    do
                      u = o & 127, o >>>= 7, i || (u |= 128), s.push(u), i = !1;
 while (o > 0);
                    for (var f = s.length - 1; f >= 0; --f)
                      r.putByte(s[f]);
                  }
                  return r;
                }, t.derToOid = function(t) {
                  var n;
                  typeof t == "string" && (t = e.util.createBuffer(t));
                  var r = t.getByte();
                  n = Math.floor(r / 40) + "." + r % 40;
                  var i = 0;
                  while (t.length() > 0)
                    r = t.getByte(), i <<= 7, r & 128 ? i += r & 127 : (n += "." + (i + r), i = 0);
                  return n;
                }, t.utcTimeToDate = function(e) {
                  var t = new Date,
                      n = parseInt(e.substr(0, 2), 10);
                  n = n >= 50 ? 1900 + n : 2e3 + n;
                  var r = parseInt(e.substr(2, 2), 10) - 1,
                      i = parseInt(e.substr(4, 2), 10),
                      s = parseInt(e.substr(6, 2), 10),
                      o = parseInt(e.substr(8, 2), 10),
                      u = 0;
                  if (e.length > 11) {
                    var a = e.charAt(10),
                        f = 10;
                    a !== "+" && a !== "-" && (u = parseInt(e.substr(10, 2), 10), f += 2);
                  }
                  t.setUTCFullYear(n, r, i), t.setUTCHours(s, o, u, 0);
                  if (f) {
                    a = e.charAt(f);
                    if (a === "+" || a === "-") {
                      var l = parseInt(e.substr(f + 1, 2), 10),
                          c = parseInt(e.substr(f + 4, 2), 10),
                          h = l * 60 + c;
                      h *= 6e4, a === "+" ? t.setTime(+t - h) : t.setTime(+t + h);
                    }
                  }
                  return t;
                }, t.generalizedTimeToDate = function(e) {
                  var t = new Date,
                      n = parseInt(e.substr(0, 4), 10),
                      r = parseInt(e.substr(4, 2), 10) - 1,
                      i = parseInt(e.substr(6, 2), 10),
                      s = parseInt(e.substr(8, 2), 10),
                      o = parseInt(e.substr(10, 2), 10),
                      u = parseInt(e.substr(12, 2), 10),
                      a = 0,
                      f = 0,
                      l = !1;
                  e.charAt(e.length - 1) === "Z" && (l = !0);
                  var c = e.length - 5,
                      h = e.charAt(c);
                  if (h === "+" || h === "-") {
                    var p = parseInt(e.substr(c + 1, 2), 10),
                        d = parseInt(e.substr(c + 4, 2), 10);
                    f = p * 60 + d, f *= 6e4, h === "+" && (f *= -1), l = !0;
                  }
                  return e.charAt(14) === "." && (a = parseFloat(e.substr(14), 10) * 1e3), l ? (t.setUTCFullYear(n, r, i), t.setUTCHours(s, o, u, a), t.setTime(+t + f)) : (t.setFullYear(n, r, i), t.setHours(s, o, u, a)), t;
                }, t.dateToUtcTime = function(e) {
                  var t = "",
                      n = [];
                  n.push(("" + e.getUTCFullYear()).substr(2)), n.push("" + (e.getUTCMonth() + 1)), n.push("" + e.getUTCDate()), n.push("" + e.getUTCHours()), n.push("" + e.getUTCMinutes()), n.push("" + e.getUTCSeconds());
                  for (var r = 0; r < n.length; ++r)
                    n[r].length < 2 && (t += "0"), t += n[r];
                  return t += "Z", t;
                }, t.integerToDer = function(t) {
                  var n = e.util.createBuffer();
                  if (t >= -128 && t < 128)
                    return n.putSignedInt(t, 8);
                  if (t >= -32768 && t < 32768)
                    return n.putSignedInt(t, 16);
                  if (t >= -8388608 && t < 8388608)
                    return n.putSignedInt(t, 24);
                  if (t >= -2147483648 && t < 2147483648)
                    return n.putSignedInt(t, 32);
                  throw {
                    message: "Integer too large; max is 32-bits.",
                    integer: t
                  };
                }, t.derToInteger = function(t) {
                  typeof t == "string" && (t = e.util.createBuffer(t));
                  var n = t.length() * 8;
                  if (n > 32)
                    throw {message: "Integer too large; max is 32-bits."};
                  return t.getSignedInt(n);
                }, t.validate = function(n, r, i, s) {
                  var o = !1;
                  if (n.tagClass !== r.tagClass && typeof r.tagClass != "undefined" || n.type !== r.type && typeof r.type != "undefined")
                    s && (n.tagClass !== r.tagClass && s.push("[" + r.name + "] " + 'Expected tag class "' + r.tagClass + '", got "' + n.tagClass + '"'), n.type !== r.type && s.push("[" + r.name + "] " + 'Expected type "' + r.type + '", got "' + n.type + '"'));
                  else if (n.constructed === r.constructed || typeof r.constructed == "undefined") {
                    o = !0;
                    if (r.value && e.util.isArray(r.value)) {
                      var u = 0;
                      for (var a = 0; o && a < r.value.length; ++a)
                        o = r.value[a].optional || !1, n.value[u] && (o = t.validate(n.value[u], r.value[a], i, s), o ? ++u : r.value[a].optional && (o = !0)), !o && s && s.push("[" + r.name + "] " + 'Tag class "' + r.tagClass + '", type "' + r.type + '" expected value length "' + r.value.length + '", got "' + n.value.length + '"');
                    }
                    o && i && (r.capture && (i[r.capture] = n.value), r.captureAsn1 && (i[r.captureAsn1] = n));
                  } else
                    s && s.push("[" + r.name + "] " + 'Expected constructed "' + r.constructed + '", got "' + n.constructed + '"');
                  return o;
                };
                var r = /[^\\u0000-\\u00ff]/;
                t.prettyPrint = function(n, i, s) {
                  var o = "";
                  i = i || 0, s = s || 2, i > 0 && (o += "\n");
                  var u = "";
                  for (var a = 0; a < i * s; ++a)
                    u += " ";
                  o += u + "Tag: ";
                  switch (n.tagClass) {
                    case t.Class.UNIVERSAL:
                      o += "Universal:";
                      break;
                    case t.Class.APPLICATION:
                      o += "Application:";
                      break;
                    case t.Class.CONTEXT_SPECIFIC:
                      o += "Context-Specific:";
                      break;
                    case t.Class.PRIVATE:
                      o += "Private:";
                  }
                  if (n.tagClass === t.Class.UNIVERSAL) {
                    o += n.type;
                    switch (n.type) {
                      case t.Type.NONE:
                        o += " (None)";
                        break;
                      case t.Type.BOOLEAN:
                        o += " (Boolean)";
                        break;
                      case t.Type.BITSTRING:
                        o += " (Bit string)";
                        break;
                      case t.Type.INTEGER:
                        o += " (Integer)";
                        break;
                      case t.Type.OCTETSTRING:
                        o += " (Octet string)";
                        break;
                      case t.Type.NULL:
                        o += " (Null)";
                        break;
                      case t.Type.OID:
                        o += " (Object Identifier)";
                        break;
                      case t.Type.ODESC:
                        o += " (Object Descriptor)";
                        break;
                      case t.Type.EXTERNAL:
                        o += " (External or Instance of)";
                        break;
                      case t.Type.REAL:
                        o += " (Real)";
                        break;
                      case t.Type.ENUMERATED:
                        o += " (Enumerated)";
                        break;
                      case t.Type.EMBEDDED:
                        o += " (Embedded PDV)";
                        break;
                      case t.Type.UTF8:
                        o += " (UTF8)";
                        break;
                      case t.Type.ROID:
                        o += " (Relative Object Identifier)";
                        break;
                      case t.Type.SEQUENCE:
                        o += " (Sequence)";
                        break;
                      case t.Type.SET:
                        o += " (Set)";
                        break;
                      case t.Type.PRINTABLESTRING:
                        o += " (Printable String)";
                        break;
                      case t.Type.IA5String:
                        o += " (IA5String (ASCII))";
                        break;
                      case t.Type.UTCTIME:
                        o += " (UTC time)";
                        break;
                      case t.Type.GENERALIZEDTIME:
                        o += " (Generalized time)";
                        break;
                      case t.Type.BMPSTRING:
                        o += " (BMP String)";
                    }
                  } else
                    o += n.type;
                  o += "\n", o += u + "Constructed: " + n.constructed + "\n";
                  if (n.composed) {
                    var f = 0,
                        l = "";
                    for (var a = 0; a < n.value.length; ++a)
                      n.value[a] !== undefined && (f += 1, l += t.prettyPrint(n.value[a], i + 1, s), a + 1 < n.value.length && (l += ","));
                    o += u + "Sub values: " + f + l;
                  } else {
                    o += u + "Value: ";
                    if (n.type === t.Type.OID) {
                      var c = t.derToOid(n.value);
                      o += c, e.pki && e.pki.oids && c in e.pki.oids && (o += " (" + e.pki.oids[c] + ")");
                    }
                    if (n.type === t.Type.INTEGER)
                      try {
                        o += t.derToInteger(n.value);
                      } catch (h) {
                        o += "0x" + e.util.bytesToHex(n.value);
                      }
                    else
                      r.test(n.value) ? o += "0x" + e.util.createBuffer(n.value, "utf8").toHex() : n.value.length === 0 ? o += "[null]" : o += n.value;
                  }
                  return o;
                };
              }
              var r = "asn1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/asn1", ["require", "module", "./util", "./oids"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.md5 = e.md5 || {};
                e.md = e.md || {}, e.md.algorithms = e.md.algorithms || {}, e.md.md5 = e.md.algorithms.md5 = t;
                var n = null,
                    r = null,
                    i = null,
                    s = null,
                    o = !1,
                    u = function() {
                      n = String.fromCharCode(128), n += e.util.fillString(String.fromCharCode(0), 64), r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9], i = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], s = new Array(64);
                      for (var t = 0; t < 64; ++t)
                        s[t] = Math.floor(Math.abs(Math.sin(t + 1)) * 4294967296);
                      o = !0;
                    },
                    a = function(e, t, n) {
                      var o,
                          u,
                          a,
                          f,
                          l,
                          c,
                          h,
                          p,
                          d = n.length();
                      while (d >= 64) {
                        u = e.h0, a = e.h1, f = e.h2, l = e.h3;
                        for (p = 0; p < 16; ++p)
                          t[p] = n.getInt32Le(), c = l ^ a & (f ^ l), o = u + c + s[p] + t[p], h = i[p], u = l, l = f, f = a, a += o << h | o >>> 32 - h;
                        for (; p < 32; ++p)
                          c = f ^ l & (a ^ f), o = u + c + s[p] + t[r[p]], h = i[p], u = l, l = f, f = a, a += o << h | o >>> 32 - h;
                        for (; p < 48; ++p)
                          c = a ^ f ^ l, o = u + c + s[p] + t[r[p]], h = i[p], u = l, l = f, f = a, a += o << h | o >>> 32 - h;
                        for (; p < 64; ++p)
                          c = f ^ (a | ~l), o = u + c + s[p] + t[r[p]], h = i[p], u = l, l = f, f = a, a += o << h | o >>> 32 - h;
                        e.h0 = e.h0 + u & 4294967295, e.h1 = e.h1 + a & 4294967295, e.h2 = e.h2 + f & 4294967295, e.h3 = e.h3 + l & 4294967295, d -= 64;
                      }
                    };
                t.create = function() {
                  o || u();
                  var t = null,
                      r = e.util.createBuffer(),
                      i = new Array(16),
                      s = {
                        algorithm: "md5",
                        blockLength: 64,
                        digestLength: 16,
                        messageLength: 0
                      };
                  return s.start = function() {
                    return s.messageLength = 0, r = e.util.createBuffer(), t = {
                      h0: 1732584193,
                      h1: 4023233417,
                      h2: 2562383102,
                      h3: 271733878
                    }, s;
                  }, s.start(), s.update = function(n, o) {
                    return o === "utf8" && (n = e.util.encodeUtf8(n)), s.messageLength += n.length, r.putBytes(n), a(t, i, r), (r.read > 2048 || r.length() === 0) && r.compact(), s;
                  }, s.digest = function() {
                    var o = s.messageLength,
                        u = e.util.createBuffer();
                    u.putBytes(r.bytes()), u.putBytes(n.substr(0, 64 - (o + 8) % 64)), u.putInt32Le(o << 3 & 4294967295), u.putInt32Le(o >>> 29 & 255);
                    var f = {
                      h0: t.h0,
                      h1: t.h1,
                      h2: t.h2,
                      h3: t.h3
                    };
                    a(f, i, u);
                    var l = e.util.createBuffer();
                    return l.putInt32Le(f.h0), l.putInt32Le(f.h1), l.putInt32Le(f.h2), l.putInt32Le(f.h3), l;
                  }, s;
                };
              }
              var r = "md5";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/md5", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.sha1 = e.sha1 || {};
                e.md = e.md || {}, e.md.algorithms = e.md.algorithms || {}, e.md.sha1 = e.md.algorithms.sha1 = t;
                var n = null,
                    r = !1,
                    i = function() {
                      n = String.fromCharCode(128), n += e.util.fillString(String.fromCharCode(0), 64), r = !0;
                    },
                    s = function(e, t, n) {
                      var r,
                          i,
                          s,
                          o,
                          u,
                          a,
                          f,
                          l,
                          c = n.length();
                      while (c >= 64) {
                        i = e.h0, s = e.h1, o = e.h2, u = e.h3, a = e.h4;
                        for (l = 0; l < 16; ++l)
                          r = n.getInt32(), t[l] = r, f = u ^ s & (o ^ u), r = (i << 5 | i >>> 27) + f + a + 1518500249 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 20; ++l)
                          r = t[l - 3] ^ t[l - 8] ^ t[l - 14] ^ t[l - 16], r = r << 1 | r >>> 31, t[l] = r, f = u ^ s & (o ^ u), r = (i << 5 | i >>> 27) + f + a + 1518500249 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 32; ++l)
                          r = t[l - 3] ^ t[l - 8] ^ t[l - 14] ^ t[l - 16], r = r << 1 | r >>> 31, t[l] = r, f = s ^ o ^ u, r = (i << 5 | i >>> 27) + f + a + 1859775393 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 40; ++l)
                          r = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], r = r << 2 | r >>> 30, t[l] = r, f = s ^ o ^ u, r = (i << 5 | i >>> 27) + f + a + 1859775393 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 60; ++l)
                          r = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], r = r << 2 | r >>> 30, t[l] = r, f = s & o | u & (s ^ o), r = (i << 5 | i >>> 27) + f + a + 2400959708 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 80; ++l)
                          r = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], r = r << 2 | r >>> 30, t[l] = r, f = s ^ o ^ u, r = (i << 5 | i >>> 27) + f + a + 3395469782 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        e.h0 += i, e.h1 += s, e.h2 += o, e.h3 += u, e.h4 += a, c -= 64;
                      }
                    };
                t.create = function() {
                  r || i();
                  var t = null,
                      o = e.util.createBuffer(),
                      u = new Array(80),
                      a = {
                        algorithm: "sha1",
                        blockLength: 64,
                        digestLength: 20,
                        messageLength: 0
                      };
                  return a.start = function() {
                    return a.messageLength = 0, o = e.util.createBuffer(), t = {
                      h0: 1732584193,
                      h1: 4023233417,
                      h2: 2562383102,
                      h3: 271733878,
                      h4: 3285377520
                    }, a;
                  }, a.start(), a.update = function(n, r) {
                    return r === "utf8" && (n = e.util.encodeUtf8(n)), a.messageLength += n.length, o.putBytes(n), s(t, u, o), (o.read > 2048 || o.length() === 0) && o.compact(), a;
                  }, a.digest = function() {
                    var r = a.messageLength,
                        i = e.util.createBuffer();
                    i.putBytes(o.bytes()), i.putBytes(n.substr(0, 64 - (r + 8) % 64)), i.putInt32(r >>> 29 & 255), i.putInt32(r << 3 & 4294967295);
                    var f = {
                      h0: t.h0,
                      h1: t.h1,
                      h2: t.h2,
                      h3: t.h3,
                      h4: t.h4
                    };
                    s(f, u, i);
                    var l = e.util.createBuffer();
                    return l.putInt32(f.h0), l.putInt32(f.h1), l.putInt32(f.h2), l.putInt32(f.h3), l.putInt32(f.h4), l;
                  }, a;
                };
              }
              var r = "sha1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/sha1", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.sha256 = e.sha256 || {};
                e.md = e.md || {}, e.md.algorithms = e.md.algorithms || {}, e.md.sha256 = e.md.algorithms.sha256 = t;
                var n = null,
                    r = !1,
                    i = null,
                    s = function() {
                      n = String.fromCharCode(128), n += e.util.fillString(String.fromCharCode(0), 64), i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], r = !0;
                    },
                    o = function(e, t, n) {
                      var r,
                          s,
                          o,
                          u,
                          a,
                          f,
                          l,
                          c,
                          h,
                          p,
                          d,
                          v,
                          m,
                          g,
                          y,
                          b = n.length();
                      while (b >= 64) {
                        for (l = 0; l < 16; ++l)
                          t[l] = n.getInt32();
                        for (; l < 64; ++l)
                          r = t[l - 2], r = (r >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10, s = t[l - 15], s = (s >>> 7 | s << 25) ^ (s >>> 18 | s << 14) ^ s >>> 3, t[l] = r + t[l - 7] + s + t[l - 16] & 4294967295;
                        c = e.h0, h = e.h1, p = e.h2, d = e.h3, v = e.h4, m = e.h5, g = e.h6, y = e.h7;
                        for (l = 0; l < 64; ++l)
                          u = (v >>> 6 | v << 26) ^ (v >>> 11 | v << 21) ^ (v >>> 25 | v << 7), a = g ^ v & (m ^ g), o = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), f = c & h | p & (c ^ h), r = y + u + a + i[l] + t[l], s = o + f, y = g, g = m, m = v, v = d + r & 4294967295, d = p, p = h, h = c, c = r + s & 4294967295;
                        e.h0 = e.h0 + c & 4294967295, e.h1 = e.h1 + h & 4294967295, e.h2 = e.h2 + p & 4294967295, e.h3 = e.h3 + d & 4294967295, e.h4 = e.h4 + v & 4294967295, e.h5 = e.h5 + m & 4294967295, e.h6 = e.h6 + g & 4294967295, e.h7 = e.h7 + y & 4294967295, b -= 64;
                      }
                    };
                t.create = function() {
                  r || s();
                  var t = null,
                      i = e.util.createBuffer(),
                      u = new Array(64),
                      a = {
                        algorithm: "sha256",
                        blockLength: 64,
                        digestLength: 32,
                        messageLength: 0
                      };
                  return a.start = function() {
                    return a.messageLength = 0, i = e.util.createBuffer(), t = {
                      h0: 1779033703,
                      h1: 3144134277,
                      h2: 1013904242,
                      h3: 2773480762,
                      h4: 1359893119,
                      h5: 2600822924,
                      h6: 528734635,
                      h7: 1541459225
                    }, a;
                  }, a.start(), a.update = function(n, r) {
                    return r === "utf8" && (n = e.util.encodeUtf8(n)), a.messageLength += n.length, i.putBytes(n), o(t, u, i), (i.read > 2048 || i.length() === 0) && i.compact(), a;
                  }, a.digest = function() {
                    var r = a.messageLength,
                        s = e.util.createBuffer();
                    s.putBytes(i.bytes()), s.putBytes(n.substr(0, 64 - (r + 8) % 64)), s.putInt32(r >>> 29 & 255), s.putInt32(r << 3 & 4294967295);
                    var f = {
                      h0: t.h0,
                      h1: t.h1,
                      h2: t.h2,
                      h3: t.h3,
                      h4: t.h4,
                      h5: t.h5,
                      h6: t.h6,
                      h7: t.h7
                    };
                    o(f, u, s);
                    var l = e.util.createBuffer();
                    return l.putInt32(f.h0), l.putInt32(f.h1), l.putInt32(f.h2), l.putInt32(f.h3), l.putInt32(f.h4), l.putInt32(f.h5), l.putInt32(f.h6), l.putInt32(f.h7), l;
                  }, a;
                };
              }
              var r = "sha256";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/sha256", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.md = e.md || {}, e.md.algorithms = {
                  md5: e.md5,
                  sha1: e.sha1,
                  sha256: e.sha256
                }, e.md.md5 = e.md5, e.md.sha1 = e.sha1, e.md.sha256 = e.sha256;
              }
              var r = "md";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/md", ["require", "module", "./md5", "./sha1", "./sha256"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.hmac = e.hmac || {};
                t.create = function() {
                  var t = null,
                      n = null,
                      r = null,
                      i = null,
                      s = {};
                  return s.start = function(s, o) {
                    if (s !== null)
                      if (typeof s == "string") {
                        s = s.toLowerCase();
                        if (!(s in e.md.algorithms))
                          throw 'Unknown hash algorithm "' + s + '"';
                        n = e.md.algorithms[s].create();
                      } else
                        n = s;
                    if (o === null)
                      o = t;
                    else {
                      if (typeof o == "string")
                        o = e.util.createBuffer(o);
                      else if (e.util.isArray(o)) {
                        var u = o;
                        o = e.util.createBuffer();
                        for (var a = 0; a < u.length; ++a)
                          o.putByte(u[a]);
                      }
                      var f = o.length();
                      f > n.blockLength && (n.start(), n.update(o.bytes()), o = n.digest()), r = e.util.createBuffer(), i = e.util.createBuffer(), f = o.length();
                      for (var a = 0; a < f; ++a) {
                        var u = o.at(a);
                        r.putByte(54 ^ u), i.putByte(92 ^ u);
                      }
                      if (f < n.blockLength) {
                        var u = n.blockLength - f;
                        for (var a = 0; a < u; ++a)
                          r.putByte(54), i.putByte(92);
                      }
                      t = o, r = r.bytes(), i = i.bytes();
                    }
                    n.start(), n.update(r);
                  }, s.update = function(e) {
                    n.update(e);
                  }, s.getMac = function() {
                    var e = n.digest().bytes();
                    return n.start(), n.update(i), n.update(e), n.digest();
                  }, s.digest = s.getMac, s;
                };
              }
              var r = "hmac";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/hmac", ["require", "module", "./md", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function n(e) {
                  var t = e.name + ": ",
                      n = [];
                  for (var r = 0; r < e.values.length; ++r)
                    n.push(e.values[r].replace(/^(\S+\r\n)/, function(e, t) {
                      return " " + t;
                    }));
                  t += n.join(",") + "\r\n";
                  var i = 0,
                      s = -1;
                  for (var r = 0; r < t.length; ++r, ++i)
                    if (i > 65 && s !== -1) {
                      var o = t[s];
                      o === "," ? (++s, t = t.substr(0, s) + "\r\n " + t.substr(s)) : t = t.substr(0, s) + "\r\n" + o + t.substr(s + 1), i = r - s - 1, s = -1, ++r;
                    } else if (t[r] === " " || t[r] === "	" || t[r] === ",")
                      s = r;
                  return t;
                }
                function r(e) {
                  return e.replace(/^\s+/, "");
                }
                var t = e.pem = e.pem || {};
                t.encode = function(t, r) {
                  r = r || {};
                  var i = "-----BEGIN " + t.type + "-----\r\n",
                      s;
                  t.procType && (s = {
                    name: "Proc-Type",
                    values: [String(t.procType.version), t.procType.type]
                  }, i += n(s)), t.contentDomain && (s = {
                    name: "Content-Domain",
                    values: [t.contentDomain]
                  }, i += n(s)), t.dekInfo && (s = {
                    name: "DEK-Info",
                    values: [t.dekInfo.algorithm]
                  }, t.dekInfo.parameters && s.values.push(t.dekInfo.parameters), i += n(s));
                  if (t.headers)
                    for (var o = 0; o < t.headers.length; ++o)
                      i += n(t.headers[o]);
                  return t.procType && (i += "\r\n"), i += e.util.encode64(t.body, r.maxline || 64) + "\r\n", i += "-----END " + t.type + "-----\r\n", i;
                }, t.decode = function(t) {
                  var n = [],
                      i = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,
                      s = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,
                      o = /\r?\n/,
                      u;
                  for (; ; ) {
                    u = i.exec(t);
                    if (!u)
                      break;
                    var a = {
                      type: u[1],
                      procType: null,
                      contentDomain: null,
                      dekInfo: null,
                      headers: [],
                      body: e.util.decode64(u[3])
                    };
                    n.push(a);
                    if (!u[2])
                      continue;
                    var f = u[2].split(o),
                        l = 0;
                    while (u && l < f.length) {
                      var c = f[l].replace(/\s+$/, "");
                      for (var h = l + 1; h < f.length; ++h) {
                        var p = f[h];
                        if (!/\s/.test(p[0]))
                          break;
                        c += p, l = h;
                      }
                      u = c.match(s);
                      if (u) {
                        var d = {
                          name: u[1],
                          values: []
                        },
                            v = u[2].split(",");
                        for (var m = 0; m < v.length; ++m)
                          d.values.push(r(v[m]));
                        if (!a.procType) {
                          if (d.name !== "Proc-Type")
                            throw {message: 'Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".'};
                          if (d.values.length !== 2)
                            throw {message: 'Invalid PEM formatted message. The "Proc-Type" header must have two subfields.'};
                          a.procType = {
                            version: v[0],
                            type: v[1]
                          };
                        } else if (!a.contentDomain && d.name === "Content-Domain")
                          a.contentDomain = v[0] || "";
                        else if (!a.dekInfo && d.name === "DEK-Info") {
                          if (d.values.length === 0)
                            throw {message: 'Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.'};
                          a.dekInfo = {
                            algorithm: v[0],
                            parameters: v[1] || null
                          };
                        } else
                          a.headers.push(d);
                      }
                      ++l;
                    }
                    if (a.procType === "ENCRYPTED" && !a.dekInfo)
                      throw {message: 'Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".'};
                  }
                  if (n.length === 0)
                    throw {message: "Invalid PEM formatted message."};
                  return n;
                };
              }
              var r = "pem";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pem", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function f(e) {
                  var t = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964],
                      n = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697],
                      r = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272],
                      i = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144],
                      s = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256],
                      o = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488],
                      u = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746],
                      a = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568],
                      f = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578],
                      l = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488],
                      c = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800],
                      h = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744],
                      p = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128],
                      d = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261],
                      v = e.length() > 8 ? 3 : 1,
                      m = [],
                      g = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
                      y = 0,
                      b;
                  for (var w = 0; w < v; w++) {
                    var E = e.getInt32(),
                        S = e.getInt32();
                    b = (E >>> 4 ^ S) & 252645135, S ^= b, E ^= b << 4, b = (S >>> -16 ^ E) & 65535, E ^= b, S ^= b << -16, b = (E >>> 2 ^ S) & 858993459, S ^= b, E ^= b << 2, b = (S >>> -16 ^ E) & 65535, E ^= b, S ^= b << -16, b = (E >>> 1 ^ S) & 1431655765, S ^= b, E ^= b << 1, b = (S >>> 8 ^ E) & 16711935, E ^= b, S ^= b << 8, b = (E >>> 1 ^ S) & 1431655765, S ^= b, E ^= b << 1, b = E << 8 | S >>> 20 & 240, E = S << 24 | S << 8 & 16711680 | S >>> 8 & 65280 | S >>> 24 & 240, S = b;
                    for (var x = 0; x < g.length; x++) {
                      g[x] ? (E = E << 2 | E >>> 26, S = S << 2 | S >>> 26) : (E = E << 1 | E >>> 27, S = S << 1 | S >>> 27), E &= -15, S &= -15;
                      var T = t[E >>> 28] | n[E >>> 24 & 15] | r[E >>> 20 & 15] | i[E >>> 16 & 15] | s[E >>> 12 & 15] | o[E >>> 8 & 15] | u[E >>> 4 & 15],
                          N = a[S >>> 28] | f[S >>> 24 & 15] | l[S >>> 20 & 15] | c[S >>> 16 & 15] | h[S >>> 12 & 15] | p[S >>> 8 & 15] | d[S >>> 4 & 15];
                      b = (N >>> 16 ^ T) & 65535, m[y++] = T ^ b, m[y++] = N ^ b << 16;
                    }
                  }
                  return m;
                }
                var t = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756],
                    n = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344],
                    r = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584],
                    i = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928],
                    s = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080],
                    o = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312],
                    u = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154],
                    a = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696],
                    l = function(l, c) {
                      typeof l == "string" && (l.length === 8 || l.length === 24) && (l = e.util.createBuffer(l));
                      var h = f(l),
                          p = 1,
                          d = 0,
                          v = 0,
                          m = 0,
                          g = 0,
                          y = !1,
                          b = null,
                          w = null,
                          E = h.length === 32 ? 3 : 9,
                          S;
                      E === 3 ? S = c ? [0, 32, 2] : [30, -2, -2] : S = c ? [0, 32, 2, 62, 30, -2, 64, 96, 2] : [94, 62, -2, 32, 64, 2, 30, -2, -2];
                      var x = null;
                      return x = {
                        start: function(t, n) {
                          t ? (typeof t == "string" && t.length === 8 && (t = e.util.createBuffer(t)), p = 1, d = t.getInt32(), m = t.getInt32()) : p = 0, y = !1, b = e.util.createBuffer(), w = n || e.util.createBuffer(), x.output = w;
                        },
                        update: function(e) {
                          y || b.putBuffer(e);
                          while (b.length() >= 8) {
                            var f,
                                l = b.getInt32(),
                                x = b.getInt32();
                            p === 1 && (c ? (l ^= d, x ^= m) : (v = d, g = m, d = l, m = x)), f = (l >>> 4 ^ x) & 252645135, x ^= f, l ^= f << 4, f = (l >>> 16 ^ x) & 65535, x ^= f, l ^= f << 16, f = (x >>> 2 ^ l) & 858993459, l ^= f, x ^= f << 2, f = (x >>> 8 ^ l) & 16711935, l ^= f, x ^= f << 8, f = (l >>> 1 ^ x) & 1431655765, x ^= f, l ^= f << 1, l = l << 1 | l >>> 31, x = x << 1 | x >>> 31;
                            for (var T = 0; T < E; T += 3) {
                              var N = S[T + 1],
                                  C = S[T + 2];
                              for (var k = S[T]; k != N; k += C) {
                                var L = x ^ h[k],
                                    A = (x >>> 4 | x << 28) ^ h[k + 1];
                                f = l, l = x, x = f ^ (n[L >>> 24 & 63] | i[L >>> 16 & 63] | o[L >>> 8 & 63] | a[L & 63] | t[A >>> 24 & 63] | r[A >>> 16 & 63] | s[A >>> 8 & 63] | u[A & 63]);
                              }
                              f = l, l = x, x = f;
                            }
                            l = l >>> 1 | l << 31, x = x >>> 1 | x << 31, f = (l >>> 1 ^ x) & 1431655765, x ^= f, l ^= f << 1, f = (x >>> 8 ^ l) & 16711935, l ^= f, x ^= f << 8, f = (x >>> 2 ^ l) & 858993459, l ^= f, x ^= f << 2, f = (l >>> 16 ^ x) & 65535, x ^= f, l ^= f << 16, f = (l >>> 4 ^ x) & 252645135, x ^= f, l ^= f << 4, p === 1 && (c ? (d = l, m = x) : (l ^= v, x ^= g)), w.putInt32(l), w.putInt32(x);
                          }
                        },
                        finish: function(e) {
                          var t = !0;
                          if (c)
                            if (e)
                              t = e(8, b, !c);
                            else {
                              var n = b.length() === 8 ? 8 : 8 - b.length();
                              b.fillWithByte(n, n);
                            }
                          t && (y = !0, x.update());
                          if (!c) {
                            t = b.length() === 0;
                            if (t)
                              if (e)
                                t = e(8, w, !c);
                              else {
                                var r = w.length(),
                                    i = w.at(r - 1);
                                i > r ? t = !1 : w.truncate(i);
                              }
                          }
                          return t;
                        }
                      }, x;
                    };
                e.des = e.des || {}, e.des.startEncrypting = function(e, t, n) {
                  var r = l(e, !0);
                  return r.start(t, n), r;
                }, e.des.createEncryptionCipher = function(e) {
                  return l(e, !0);
                }, e.des.startDecrypting = function(e, t, n) {
                  var r = l(e, !1);
                  return r.start(t, n), r;
                }, e.des.createDecryptionCipher = function(e) {
                  return l(e, !1);
                };
              }
              var r = "des";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/des", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.pkcs5 = e.pkcs5 || {};
                e.pbkdf2 = t.pbkdf2 = function(t, n, r, i, s) {
                  if (typeof s == "undefined" || s === null)
                    s = e.md.sha1.create();
                  var o = s.digestLength;
                  if (i > 4294967295 * o)
                    throw {message: "Derived key is too long."};
                  var u = Math.ceil(i / o),
                      a = i - (u - 1) * o,
                      f = e.hmac.create();
                  f.start(s, t);
                  var l = "",
                      c,
                      h,
                      p;
                  for (var d = 1; d <= u; ++d) {
                    f.start(null, null), f.update(n), f.update(e.util.int32ToBytes(d)), c = p = f.digest().getBytes();
                    for (var v = 2; v <= r; ++v)
                      f.start(null, null), f.update(p), h = f.digest().getBytes(), c = e.util.xorBytes(c, h, o), p = h;
                    l += d < u ? c : c.substr(0, a);
                  }
                  return l;
                };
              }
              var r = "pbkdf2";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pbkdf2", ["require", "module", "./hmac", "./md", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var n = typeof process != "undefined" && process.versions && process.versions.node,
                    r = null;
                !e.disableNativeCode && n && (r = t("crypto"));
                var i = e.prng = e.prng || {};
                i.create = function(t) {
                  function u(e) {
                    if (n.pools[0].messageLength >= 32)
                      return f(), e();
                    var t = 32 - n.pools[0].messageLength << 5;
                    n.seedFile(t, function(t, r) {
                      if (t)
                        return e(t);
                      n.collect(r), f(), e();
                    });
                  }
                  function a() {
                    if (n.pools[0].messageLength >= 32)
                      return f();
                    var e = 32 - n.pools[0].messageLength << 5;
                    n.collect(n.seedFileSync(e)), f();
                  }
                  function f() {
                    var t = e.md.sha1.create();
                    t.update(n.pools[0].digest().getBytes()), n.pools[0].start();
                    var r = 1;
                    for (var i = 1; i < 32; ++i)
                      r = r === 31 ? 2147483648 : r << 2, r % n.reseeds === 0 && (t.update(n.pools[i].digest().getBytes()), n.pools[i].start());
                    var s = t.digest().getBytes();
                    t.start(), t.update(s);
                    var o = t.digest().getBytes();
                    n.key = n.plugin.formatKey(s), n.seed = n.plugin.formatSeed(o), ++n.reseeds, n.generated = 0, n.time = +(new Date);
                  }
                  function l(t) {
                    var n = null;
                    if (typeof window != "undefined") {
                      var r = window.crypto || window.msCrypto;
                      r && r.getRandomValues && (n = function(e) {
                        return r.getRandomValues(e);
                      });
                    }
                    var i = e.util.createBuffer();
                    if (n)
                      while (i.length() < t) {
                        var s = Math.max(1, Math.min(t - i.length(), 65536) / 4),
                            o = new Uint32Array(Math.floor(s));
                        try {
                          n(o);
                          for (var u = 0; u < o.length; ++u)
                            i.putInt32(o[u]);
                        } catch (a) {
                          if (!(typeof QuotaExceededError != "undefined" && a instanceof QuotaExceededError))
                            throw a;
                        }
                      }
                    if (i.length() < t) {
                      var f,
                          l,
                          c,
                          h = Math.floor(Math.random() * 65536);
                      while (i.length() < t) {
                        l = 16807 * (h & 65535), f = 16807 * (h >> 16), l += (f & 32767) << 16, l += f >> 15, l = (l & 2147483647) + (l >> 31), h = l & 4294967295;
                        for (var u = 0; u < 3; ++u)
                          c = h >>> (u << 3), c ^= Math.floor(Math.random() * 256), i.putByte(String.fromCharCode(c & 255));
                      }
                    }
                    return i.getBytes(t);
                  }
                  var n = {
                    plugin: t,
                    key: null,
                    seed: null,
                    time: null,
                    reseeds: 0,
                    generated: 0
                  },
                      i = t.md,
                      s = new Array(32);
                  for (var o = 0; o < 32; ++o)
                    s[o] = i.create();
                  return n.pools = s, n.pool = 0, n.generate = function(t, r) {
                    function l(c) {
                      if (c)
                        return r(c);
                      if (f.length() >= t)
                        return r(null, f.getBytes(t));
                      if (n.generated >= 1048576) {
                        var h = +(new Date);
                        if (n.time === null || h - n.time > 100)
                          n.key = null;
                      }
                      if (n.key === null)
                        return u(l);
                      var p = i(n.key, n.seed);
                      n.generated += p.length, f.putBytes(p), n.key = o(i(n.key, s(n.seed))), n.seed = a(i(n.key, n.seed)), e.util.setImmediate(l);
                    }
                    if (!r)
                      return n.generateSync(t);
                    var i = n.plugin.cipher,
                        s = n.plugin.increment,
                        o = n.plugin.formatKey,
                        a = n.plugin.formatSeed,
                        f = e.util.createBuffer();
                    l();
                  }, n.generateSync = function(t) {
                    var r = n.plugin.cipher,
                        i = n.plugin.increment,
                        s = n.plugin.formatKey,
                        o = n.plugin.formatSeed,
                        u = e.util.createBuffer();
                    while (u.length() < t) {
                      if (n.generated >= 1048576) {
                        var f = +(new Date);
                        if (n.time === null || f - n.time > 100)
                          n.key = null;
                      }
                      n.key === null && a();
                      var l = r(n.key, n.seed);
                      n.generated += l.length, u.putBytes(l), n.key = s(r(n.key, i(n.seed))), n.seed = o(r(n.key, n.seed));
                    }
                    return u.getBytes(t);
                  }, r ? (n.seedFile = function(e, t) {
                    r.randomBytes(e, function(e, n) {
                      if (e)
                        return t(e);
                      t(null, n.toString());
                    });
                  }, n.seedFileSync = function(e) {
                    return r.randomBytes(e).toString();
                  }) : (n.seedFile = function(e, t) {
                    try {
                      t(null, l(e));
                    } catch (n) {
                      t(n);
                    }
                  }, n.seedFileSync = l), n.collect = function(e) {
                    var t = e.length;
                    for (var r = 0; r < t; ++r)
                      n.pools[n.pool].update(e.substr(r, 1)), n.pool = n.pool === 31 ? 0 : n.pool + 1;
                  }, n.collectInt = function(e, t) {
                    var r = "";
                    for (var i = 0; i < t; i += 8)
                      r += String.fromCharCode(e >> i & 255);
                    n.collect(r);
                  }, n.registerWorker = function(e) {
                    if (e === self)
                      n.seedFile = function(e, t) {
                        function n(e) {
                          var r = e.data;
                          r.forge && r.forge.prng && (self.removeEventListener("message", n), t(r.forge.prng.err, r.forge.prng.bytes));
                        }
                        self.addEventListener("message", n), self.postMessage({forge: {prng: {needed: e}}});
                      };
                    else {
                      function t(t) {
                        var r = t.data;
                        r.forge && r.forge.prng && n.seedFile(r.forge.prng.needed, function(t, n) {
                          e.postMessage({forge: {prng: {
                                err: t,
                                bytes: n
                              }}});
                        });
                      }
                      e.addEventListener("message", t);
                    }
                  }, n;
                };
              }
              var r = "prng";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/prng", ["require", "module", "./md", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                if (e.random && e.random.getBytes)
                  return;
                (function(t) {
                  var n = {},
                      r = new Array(4),
                      i = e.util.createBuffer();
                  n.formatKey = function(t) {
                    var n = e.util.createBuffer(t);
                    return t = new Array(4), t[0] = n.getInt32(), t[1] = n.getInt32(), t[2] = n.getInt32(), t[3] = n.getInt32(), e.aes._expandKey(t, !1);
                  }, n.formatSeed = function(t) {
                    var n = e.util.createBuffer(t);
                    return t = new Array(4), t[0] = n.getInt32(), t[1] = n.getInt32(), t[2] = n.getInt32(), t[3] = n.getInt32(), t;
                  }, n.cipher = function(t, n) {
                    return e.aes._updateBlock(t, n, r, !1), i.putInt32(r[0]), i.putInt32(r[1]), i.putInt32(r[2]), i.putInt32(r[3]), i.getBytes();
                  }, n.increment = function(e) {
                    return ++e[3], e;
                  }, n.md = e.md.sha1;
                  var s = e.prng.create(n),
                      o = typeof process != "undefined" && process.versions && process.versions.node,
                      u = null;
                  if (typeof window != "undefined") {
                    var a = window.crypto || window.msCrypto;
                    a && a.getRandomValues && (u = function(e) {
                      return a.getRandomValues(e);
                    });
                  }
                  if (e.disableNativeCode || !o && !u) {
                    typeof window == "undefined" || window.document === undefined, s.collectInt(+(new Date), 32);
                    if (typeof navigator != "undefined") {
                      var f = "";
                      for (var l in navigator)
                        try {
                          typeof navigator[l] == "string" && (f += navigator[l]);
                        } catch (c) {}
                      s.collect(f), f = null;
                    }
                    t && (t().mousemove(function(e) {
                      s.collectInt(e.clientX, 16), s.collectInt(e.clientY, 16);
                    }), t().keypress(function(e) {
                      s.collectInt(e.charCode, 8);
                    }));
                  }
                  if (!e.random)
                    e.random = s;
                  else
                    for (var l in s)
                      e.random[l] = s[l];
                  e.random.getBytes = function(t, n) {
                    return e.random.generate(t, n);
                  }, e.random.getBytesSync = function(t) {
                    return e.random.generate(t);
                  };
                })(typeof jQuery != "undefined" ? jQuery : null);
              }
              var r = "random";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/random", ["require", "module", "./aes", "./md", "./prng", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173],
                    n = [1, 2, 3, 5],
                    r = function(e, t) {
                      return e << t & 65535 | (e & 65535) >> 16 - t;
                    },
                    i = function(e, t) {
                      return (e & 65535) >> t | e << 16 - t & 65535;
                    };
                e.rc2 = e.rc2 || {}, e.rc2.expandKey = function(n, r) {
                  typeof n == "string" && (n = e.util.createBuffer(n)), r = r || 128;
                  var i = n,
                      s = n.length(),
                      o = r,
                      u = Math.ceil(o / 8),
                      a = 255 >> (o & 7),
                      f;
                  for (f = s; f < 128; f++)
                    i.putByte(t[i.at(f - 1) + i.at(f - s) & 255]);
                  i.setAt(128 - u, t[i.at(128 - u) & a]);
                  for (f = 127 - u; f >= 0; f--)
                    i.setAt(f, t[i.at(f + 1) ^ i.at(f + u)]);
                  return i;
                };
                var s = function(t, s, o) {
                  var u = !1,
                      a = null,
                      f = null,
                      l = null,
                      c,
                      h,
                      p,
                      d,
                      v = [];
                  t = e.rc2.expandKey(t, s);
                  for (p = 0; p < 64; p++)
                    v.push(t.getInt16Le());
                  o ? (c = function(e) {
                    for (p = 0; p < 4; p++)
                      e[p] += v[d] + (e[(p + 3) % 4] & e[(p + 2) % 4]) + (~e[(p + 3) % 4] & e[(p + 1) % 4]), e[p] = r(e[p], n[p]), d++;
                  }, h = function(e) {
                    for (p = 0; p < 4; p++)
                      e[p] += v[e[(p + 3) % 4] & 63];
                  }) : (c = function(e) {
                    for (p = 3; p >= 0; p--)
                      e[p] = i(e[p], n[p]), e[p] -= v[d] + (e[(p + 3) % 4] & e[(p + 2) % 4]) + (~e[(p + 3) % 4] & e[(p + 1) % 4]), d--;
                  }, h = function(e) {
                    for (p = 3; p >= 0; p--)
                      e[p] -= v[e[(p + 3) % 4] & 63];
                  });
                  var m = function(e) {
                    var t = [];
                    for (p = 0; p < 4; p++) {
                      var n = a.getInt16Le();
                      l !== null && (o ? n ^= l.getInt16Le() : l.putInt16Le(n)), t.push(n & 65535);
                    }
                    d = o ? 0 : 63;
                    for (var r = 0; r < e.length; r++)
                      for (var i = 0; i < e[r][0]; i++)
                        e[r][1](t);
                    for (p = 0; p < 4; p++)
                      l !== null && (o ? l.putInt16Le(t[p]) : t[p] ^= l.getInt16Le()), f.putInt16Le(t[p]);
                  },
                      g = null;
                  return g = {
                    start: function(t, n) {
                      t && typeof t == "string" && (t = e.util.createBuffer(t)), u = !1, a = e.util.createBuffer(), f = n || new e.util.createBuffer, l = t, g.output = f;
                    },
                    update: function(e) {
                      u || a.putBuffer(e);
                      while (a.length() >= 8)
                        m([[5, c], [1, h], [6, c], [1, h], [5, c]]);
                    },
                    finish: function(e) {
                      var t = !0;
                      if (o)
                        if (e)
                          t = e(8, a, !o);
                        else {
                          var n = a.length() === 8 ? 8 : 8 - a.length();
                          a.fillWithByte(n, n);
                        }
                      t && (u = !0, g.update());
                      if (!o) {
                        t = a.length() === 0;
                        if (t)
                          if (e)
                            t = e(8, f, !o);
                          else {
                            var r = f.length(),
                                i = f.at(r - 1);
                            i > r ? t = !1 : f.truncate(i);
                          }
                      }
                      return t;
                    }
                  }, g;
                };
                e.rc2.startEncrypting = function(t, n, r) {
                  var i = e.rc2.createEncryptionCipher(t, 128);
                  return i.start(n, r), i;
                }, e.rc2.createEncryptionCipher = function(e, t) {
                  return s(e, t, !0);
                }, e.rc2.startDecrypting = function(t, n, r) {
                  var i = e.rc2.createDecryptionCipher(t, 128);
                  return i.start(n, r), i;
                }, e.rc2.createDecryptionCipher = function(e, t) {
                  return s(e, t, !1);
                };
              }
              var r = "rc2";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/rc2", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function i(e, t, n) {
                  this.data = [], e != null && ("number" == typeof e ? this.fromNumber(e, t, n) : t == null && "string" != typeof e ? this.fromString(e, 256) : this.fromString(e, t));
                }
                function s() {
                  return new i(null);
                }
                function o(e, t, n, r, i, s) {
                  while (--s >= 0) {
                    var o = t * this.data[e++] + n.data[r] + i;
                    i = Math.floor(o / 67108864), n.data[r++] = o & 67108863;
                  }
                  return i;
                }
                function u(e, t, n, r, i, s) {
                  var o = t & 32767,
                      u = t >> 15;
                  while (--s >= 0) {
                    var a = this.data[e] & 32767,
                        f = this.data[e++] >> 15,
                        l = u * a + f * o;
                    a = o * a + ((l & 32767) << 15) + n.data[r] + (i & 1073741823), i = (a >>> 30) + (l >>> 15) + u * f + (i >>> 30), n.data[r++] = a & 1073741823;
                  }
                  return i;
                }
                function a(e, t, n, r, i, s) {
                  var o = t & 16383,
                      u = t >> 14;
                  while (--s >= 0) {
                    var a = this.data[e] & 16383,
                        f = this.data[e++] >> 14,
                        l = u * a + f * o;
                    a = o * a + ((l & 16383) << 14) + n.data[r] + i, i = (a >> 28) + (l >> 14) + u * f, n.data[r++] = a & 268435455;
                  }
                  return i;
                }
                function d(e) {
                  return l.charAt(e);
                }
                function v(e, t) {
                  var n = c[e.charCodeAt(t)];
                  return n == null ? -1 : n;
                }
                function m(e) {
                  for (var t = this.t - 1; t >= 0; --t)
                    e.data[t] = this.data[t];
                  e.t = this.t, e.s = this.s;
                }
                function g(e) {
                  this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this.data[0] = e : e < -1 ? this.data[0] = e + this.DV : this.t = 0;
                }
                function y(e) {
                  var t = s();
                  return t.fromInt(e), t;
                }
                function b(e, t) {
                  var n;
                  if (t == 16)
                    n = 4;
                  else if (t == 8)
                    n = 3;
                  else if (t == 256)
                    n = 8;
                  else if (t == 2)
                    n = 1;
                  else if (t == 32)
                    n = 5;
                  else {
                    if (t != 4) {
                      this.fromRadix(e, t);
                      return;
                    }
                    n = 2;
                  }
                  this.t = 0, this.s = 0;
                  var r = e.length,
                      s = !1,
                      o = 0;
                  while (--r >= 0) {
                    var u = n == 8 ? e[r] & 255 : v(e, r);
                    if (u < 0) {
                      e.charAt(r) == "-" && (s = !0);
                      continue;
                    }
                    s = !1, o == 0 ? this.data[this.t++] = u : o + n > this.DB ? (this.data[this.t - 1] |= (u & (1 << this.DB - o) - 1) << o, this.data[this.t++] = u >> this.DB - o) : this.data[this.t - 1] |= u << o, o += n, o >= this.DB && (o -= this.DB);
                  }
                  n == 8 && (e[0] & 128) != 0 && (this.s = -1, o > 0 && (this.data[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), s && i.ZERO.subTo(this, this);
                }
                function w() {
                  var e = this.s & this.DM;
                  while (this.t > 0 && this.data[this.t - 1] == e)
                    --this.t;
                }
                function E(e) {
                  if (this.s < 0)
                    return "-" + this.negate().toString(e);
                  var t;
                  if (e == 16)
                    t = 4;
                  else if (e == 8)
                    t = 3;
                  else if (e == 2)
                    t = 1;
                  else if (e == 32)
                    t = 5;
                  else {
                    if (e != 4)
                      return this.toRadix(e);
                    t = 2;
                  }
                  var n = (1 << t) - 1,
                      r,
                      i = !1,
                      s = "",
                      o = this.t,
                      u = this.DB - o * this.DB % t;
                  if (o-- > 0) {
                    u < this.DB && (r = this.data[o] >> u) > 0 && (i = !0, s = d(r));
                    while (o >= 0)
                      u < t ? (r = (this.data[o] & (1 << u) - 1) << t - u, r |= this.data[--o] >> (u += this.DB - t)) : (r = this.data[o] >> (u -= t) & n, u <= 0 && (u += this.DB, --o)), r > 0 && (i = !0), i && (s += d(r));
                  }
                  return i ? s : "0";
                }
                function S() {
                  var e = s();
                  return i.ZERO.subTo(this, e), e;
                }
                function x() {
                  return this.s < 0 ? this.negate() : this;
                }
                function T(e) {
                  var t = this.s - e.s;
                  if (t != 0)
                    return t;
                  var n = this.t;
                  t = n - e.t;
                  if (t != 0)
                    return this.s < 0 ? -t : t;
                  while (--n >= 0)
                    if ((t = this.data[n] - e.data[n]) != 0)
                      return t;
                  return 0;
                }
                function N(e) {
                  var t = 1,
                      n;
                  return (n = e >>> 16) != 0 && (e = n, t += 16), (n = e >> 8) != 0 && (e = n, t += 8), (n = e >> 4) != 0 && (e = n, t += 4), (n = e >> 2) != 0 && (e = n, t += 2), (n = e >> 1) != 0 && (e = n, t += 1), t;
                }
                function C() {
                  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + N(this.data[this.t - 1] ^ this.s & this.DM);
                }
                function k(e, t) {
                  var n;
                  for (n = this.t - 1; n >= 0; --n)
                    t.data[n + e] = this.data[n];
                  for (n = e - 1; n >= 0; --n)
                    t.data[n] = 0;
                  t.t = this.t + e, t.s = this.s;
                }
                function L(e, t) {
                  for (var n = e; n < this.t; ++n)
                    t.data[n - e] = this.data[n];
                  t.t = Math.max(this.t - e, 0), t.s = this.s;
                }
                function A(e, t) {
                  var n = e % this.DB,
                      r = this.DB - n,
                      i = (1 << r) - 1,
                      s = Math.floor(e / this.DB),
                      o = this.s << n & this.DM,
                      u;
                  for (u = this.t - 1; u >= 0; --u)
                    t.data[u + s + 1] = this.data[u] >> r | o, o = (this.data[u] & i) << n;
                  for (u = s - 1; u >= 0; --u)
                    t.data[u] = 0;
                  t.data[s] = o, t.t = this.t + s + 1, t.s = this.s, t.clamp();
                }
                function O(e, t) {
                  t.s = this.s;
                  var n = Math.floor(e / this.DB);
                  if (n >= this.t) {
                    t.t = 0;
                    return;
                  }
                  var r = e % this.DB,
                      i = this.DB - r,
                      s = (1 << r) - 1;
                  t.data[0] = this.data[n] >> r;
                  for (var o = n + 1; o < this.t; ++o)
                    t.data[o - n - 1] |= (this.data[o] & s) << i, t.data[o - n] = this.data[o] >> r;
                  r > 0 && (t.data[this.t - n - 1] |= (this.s & s) << i), t.t = this.t - n, t.clamp();
                }
                function M(e, t) {
                  var n = 0,
                      r = 0,
                      i = Math.min(e.t, this.t);
                  while (n < i)
                    r += this.data[n] - e.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                  if (e.t < this.t) {
                    r -= e.s;
                    while (n < this.t)
                      r += this.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                    r += this.s;
                  } else {
                    r += this.s;
                    while (n < e.t)
                      r -= e.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                    r -= e.s;
                  }
                  t.s = r < 0 ? -1 : 0, r < -1 ? t.data[n++] = this.DV + r : r > 0 && (t.data[n++] = r), t.t = n, t.clamp();
                }
                function _(e, t) {
                  var n = this.abs(),
                      r = e.abs(),
                      s = n.t;
                  t.t = s + r.t;
                  while (--s >= 0)
                    t.data[s] = 0;
                  for (s = 0; s < r.t; ++s)
                    t.data[s + n.t] = n.am(0, r.data[s], t, s, 0, n.t);
                  t.s = 0, t.clamp(), this.s != e.s && i.ZERO.subTo(t, t);
                }
                function D(e) {
                  var t = this.abs(),
                      n = e.t = 2 * t.t;
                  while (--n >= 0)
                    e.data[n] = 0;
                  for (n = 0; n < t.t - 1; ++n) {
                    var r = t.am(n, t.data[n], e, 2 * n, 0, 1);
                    (e.data[n + t.t] += t.am(n + 1, 2 * t.data[n], e, 2 * n + 1, r, t.t - n - 1)) >= t.DV && (e.data[n + t.t] -= t.DV, e.data[n + t.t + 1] = 1);
                  }
                  e.t > 0 && (e.data[e.t - 1] += t.am(n, t.data[n], e, 2 * n, 0, 1)), e.s = 0, e.clamp();
                }
                function P(e, t, n) {
                  var r = e.abs();
                  if (r.t <= 0)
                    return;
                  var o = this.abs();
                  if (o.t < r.t) {
                    t != null && t.fromInt(0), n != null && this.copyTo(n);
                    return;
                  }
                  n == null && (n = s());
                  var u = s(),
                      a = this.s,
                      f = e.s,
                      l = this.DB - N(r.data[r.t - 1]);
                  l > 0 ? (r.lShiftTo(l, u), o.lShiftTo(l, n)) : (r.copyTo(u), o.copyTo(n));
                  var c = u.t,
                      h = u.data[c - 1];
                  if (h == 0)
                    return;
                  var p = h * (1 << this.F1) + (c > 1 ? u.data[c - 2] >> this.F2 : 0),
                      d = this.FV / p,
                      v = (1 << this.F1) / p,
                      m = 1 << this.F2,
                      g = n.t,
                      y = g - c,
                      b = t == null ? s() : t;
                  u.dlShiftTo(y, b), n.compareTo(b) >= 0 && (n.data[n.t++] = 1, n.subTo(b, n)), i.ONE.dlShiftTo(c, b), b.subTo(u, u);
                  while (u.t < c)
                    u.data[u.t++] = 0;
                  while (--y >= 0) {
                    var w = n.data[--g] == h ? this.DM : Math.floor(n.data[g] * d + (n.data[g - 1] + m) * v);
                    if ((n.data[g] += u.am(0, w, n, y, 0, c)) < w) {
                      u.dlShiftTo(y, b), n.subTo(b, n);
                      while (n.data[g] < --w)
                        n.subTo(b, n);
                    }
                  }
                  t != null && (n.drShiftTo(c, t), a != f && i.ZERO.subTo(t, t)), n.t = c, n.clamp(), l > 0 && n.rShiftTo(l, n), a < 0 && i.ZERO.subTo(n, n);
                }
                function H(e) {
                  var t = s();
                  return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(i.ZERO) > 0 && e.subTo(t, t), t;
                }
                function B(e) {
                  this.m = e;
                }
                function j(e) {
                  return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e;
                }
                function F(e) {
                  return e;
                }
                function I(e) {
                  e.divRemTo(this.m, null, e);
                }
                function q(e, t, n) {
                  e.multiplyTo(t, n), this.reduce(n);
                }
                function R(e, t) {
                  e.squareTo(t), this.reduce(t);
                }
                function U() {
                  if (this.t < 1)
                    return 0;
                  var e = this.data[0];
                  if ((e & 1) == 0)
                    return 0;
                  var t = e & 3;
                  return t = t * (2 - (e & 15) * t) & 15, t = t * (2 - (e & 255) * t) & 255, t = t * (2 - ((e & 65535) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
                }
                function z(e) {
                  this.m = e, this.mp = e.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t;
                }
                function W(e) {
                  var t = s();
                  return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(i.ZERO) > 0 && this.m.subTo(t, t), t;
                }
                function X(e) {
                  var t = s();
                  return e.copyTo(t), this.reduce(t), t;
                }
                function V(e) {
                  while (e.t <= this.mt2)
                    e.data[e.t++] = 0;
                  for (var t = 0; t < this.m.t; ++t) {
                    var n = e.data[t] & 32767,
                        r = n * this.mpl + ((n * this.mph + (e.data[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
                    n = t + this.m.t, e.data[n] += this.m.am(0, r, e, t, 0, this.m.t);
                    while (e.data[n] >= e.DV)
                      e.data[n] -= e.DV, e.data[++n]++;
                  }
                  e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e);
                }
                function $(e, t) {
                  e.squareTo(t), this.reduce(t);
                }
                function J(e, t, n) {
                  e.multiplyTo(t, n), this.reduce(n);
                }
                function K() {
                  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
                }
                function Q(e, t) {
                  if (e > 4294967295 || e < 1)
                    return i.ONE;
                  var n = s(),
                      r = s(),
                      o = t.convert(this),
                      u = N(e) - 1;
                  o.copyTo(n);
                  while (--u >= 0) {
                    t.sqrTo(n, r);
                    if ((e & 1 << u) > 0)
                      t.mulTo(r, o, n);
                    else {
                      var a = n;
                      n = r, r = a;
                    }
                  }
                  return t.revert(n);
                }
                function G(e, t) {
                  var n;
                  return e < 256 || t.isEven() ? n = new B(t) : n = new z(t), this.exp(e, n);
                }
                function Y() {
                  var e = s();
                  return this.copyTo(e), e;
                }
                function Z() {
                  if (this.s < 0) {
                    if (this.t == 1)
                      return this.data[0] - this.DV;
                    if (this.t == 0)
                      return -1;
                  } else {
                    if (this.t == 1)
                      return this.data[0];
                    if (this.t == 0)
                      return 0;
                  }
                  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
                }
                function et() {
                  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
                }
                function tt() {
                  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
                }
                function nt(e) {
                  return Math.floor(Math.LN2 * this.DB / Math.log(e));
                }
                function rt() {
                  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
                }
                function it(e) {
                  e == null && (e = 10);
                  if (this.signum() == 0 || e < 2 || e > 36)
                    return "0";
                  var t = this.chunkSize(e),
                      n = Math.pow(e, t),
                      r = y(n),
                      i = s(),
                      o = s(),
                      u = "";
                  this.divRemTo(r, i, o);
                  while (i.signum() > 0)
                    u = (n + o.intValue()).toString(e).substr(1) + u, i.divRemTo(r, i, o);
                  return o.intValue().toString(e) + u;
                }
                function st(e, t) {
                  this.fromInt(0), t == null && (t = 10);
                  var n = this.chunkSize(t),
                      r = Math.pow(t, n),
                      s = !1,
                      o = 0,
                      u = 0;
                  for (var a = 0; a < e.length; ++a) {
                    var f = v(e, a);
                    if (f < 0) {
                      e.charAt(a) == "-" && this.signum() == 0 && (s = !0);
                      continue;
                    }
                    u = t * u + f, ++o >= n && (this.dMultiply(r), this.dAddOffset(u, 0), o = 0, u = 0);
                  }
                  o > 0 && (this.dMultiply(Math.pow(t, o)), this.dAddOffset(u, 0)), s && i.ZERO.subTo(this, this);
                }
                function ot(e, t, n) {
                  if ("number" == typeof t)
                    if (e < 2)
                      this.fromInt(1);
                    else {
                      this.fromNumber(e, n), this.testBit(e - 1) || this.bitwiseTo(i.ONE.shiftLeft(e - 1), dt, this), this.isEven() && this.dAddOffset(1, 0);
                      while (!this.isProbablePrime(t))
                        this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(i.ONE.shiftLeft(e - 1), this);
                    }
                  else {
                    var r = new Array,
                        s = e & 7;
                    r.length = (e >> 3) + 1, t.nextBytes(r), s > 0 ? r[0] &= (1 << s) - 1 : r[0] = 0, this.fromString(r, 256);
                  }
                }
                function ut() {
                  var e = this.t,
                      t = new Array;
                  t[0] = this.s;
                  var n = this.DB - e * this.DB % 8,
                      r,
                      i = 0;
                  if (e-- > 0) {
                    n < this.DB && (r = this.data[e] >> n) != (this.s & this.DM) >> n && (t[i++] = r | this.s << this.DB - n);
                    while (e >= 0) {
                      n < 8 ? (r = (this.data[e] & (1 << n) - 1) << 8 - n, r |= this.data[--e] >> (n += this.DB - 8)) : (r = this.data[e] >> (n -= 8) & 255, n <= 0 && (n += this.DB, --e)), (r & 128) != 0 && (r |= -256), i == 0 && (this.s & 128) != (r & 128) && ++i;
                      if (i > 0 || r != this.s)
                        t[i++] = r;
                    }
                  }
                  return t;
                }
                function at(e) {
                  return this.compareTo(e) == 0;
                }
                function ft(e) {
                  return this.compareTo(e) < 0 ? this : e;
                }
                function lt(e) {
                  return this.compareTo(e) > 0 ? this : e;
                }
                function ct(e, t, n) {
                  var r,
                      i,
                      s = Math.min(e.t, this.t);
                  for (r = 0; r < s; ++r)
                    n.data[r] = t(this.data[r], e.data[r]);
                  if (e.t < this.t) {
                    i = e.s & this.DM;
                    for (r = s; r < this.t; ++r)
                      n.data[r] = t(this.data[r], i);
                    n.t = this.t;
                  } else {
                    i = this.s & this.DM;
                    for (r = s; r < e.t; ++r)
                      n.data[r] = t(i, e.data[r]);
                    n.t = e.t;
                  }
                  n.s = t(this.s, e.s), n.clamp();
                }
                function ht(e, t) {
                  return e & t;
                }
                function pt(e) {
                  var t = s();
                  return this.bitwiseTo(e, ht, t), t;
                }
                function dt(e, t) {
                  return e | t;
                }
                function vt(e) {
                  var t = s();
                  return this.bitwiseTo(e, dt, t), t;
                }
                function mt(e, t) {
                  return e ^ t;
                }
                function gt(e) {
                  var t = s();
                  return this.bitwiseTo(e, mt, t), t;
                }
                function yt(e, t) {
                  return e & ~t;
                }
                function bt(e) {
                  var t = s();
                  return this.bitwiseTo(e, yt, t), t;
                }
                function wt() {
                  var e = s();
                  for (var t = 0; t < this.t; ++t)
                    e.data[t] = this.DM & ~this.data[t];
                  return e.t = this.t, e.s = ~this.s, e;
                }
                function Et(e) {
                  var t = s();
                  return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t;
                }
                function St(e) {
                  var t = s();
                  return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t;
                }
                function xt(e) {
                  if (e == 0)
                    return -1;
                  var t = 0;
                  return (e & 65535) == 0 && (e >>= 16, t += 16), (e & 255) == 0 && (e >>= 8, t += 8), (e & 15) == 0 && (e >>= 4, t += 4), (e & 3) == 0 && (e >>= 2, t += 2), (e & 1) == 0 && ++t, t;
                }
                function Tt() {
                  for (var e = 0; e < this.t; ++e)
                    if (this.data[e] != 0)
                      return e * this.DB + xt(this.data[e]);
                  return this.s < 0 ? this.t * this.DB : -1;
                }
                function Nt(e) {
                  var t = 0;
                  while (e != 0)
                    e &= e - 1, ++t;
                  return t;
                }
                function Ct() {
                  var e = 0,
                      t = this.s & this.DM;
                  for (var n = 0; n < this.t; ++n)
                    e += Nt(this.data[n] ^ t);
                  return e;
                }
                function kt(e) {
                  var t = Math.floor(e / this.DB);
                  return t >= this.t ? this.s != 0 : (this.data[t] & 1 << e % this.DB) != 0;
                }
                function Lt(e, t) {
                  var n = i.ONE.shiftLeft(e);
                  return this.bitwiseTo(n, t, n), n;
                }
                function At(e) {
                  return this.changeBit(e, dt);
                }
                function Ot(e) {
                  return this.changeBit(e, yt);
                }
                function Mt(e) {
                  return this.changeBit(e, mt);
                }
                function _t(e, t) {
                  var n = 0,
                      r = 0,
                      i = Math.min(e.t, this.t);
                  while (n < i)
                    r += this.data[n] + e.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                  if (e.t < this.t) {
                    r += e.s;
                    while (n < this.t)
                      r += this.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                    r += this.s;
                  } else {
                    r += this.s;
                    while (n < e.t)
                      r += e.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                    r += e.s;
                  }
                  t.s = r < 0 ? -1 : 0, r > 0 ? t.data[n++] = r : r < -1 && (t.data[n++] = this.DV + r), t.t = n, t.clamp();
                }
                function Dt(e) {
                  var t = s();
                  return this.addTo(e, t), t;
                }
                function Pt(e) {
                  var t = s();
                  return this.subTo(e, t), t;
                }
                function Ht(e) {
                  var t = s();
                  return this.multiplyTo(e, t), t;
                }
                function Bt(e) {
                  var t = s();
                  return this.divRemTo(e, t, null), t;
                }
                function jt(e) {
                  var t = s();
                  return this.divRemTo(e, null, t), t;
                }
                function Ft(e) {
                  var t = s(),
                      n = s();
                  return this.divRemTo(e, t, n), new Array(t, n);
                }
                function It(e) {
                  this.data[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp();
                }
                function qt(e, t) {
                  if (e == 0)
                    return;
                  while (this.t <= t)
                    this.data[this.t++] = 0;
                  this.data[t] += e;
                  while (this.data[t] >= this.DV)
                    this.data[t] -= this.DV, ++t >= this.t && (this.data[this.t++] = 0), ++this.data[t];
                }
                function Rt() {}
                function Ut(e) {
                  return e;
                }
                function zt(e, t, n) {
                  e.multiplyTo(t, n);
                }
                function Wt(e, t) {
                  e.squareTo(t);
                }
                function Xt(e) {
                  return this.exp(e, new Rt);
                }
                function Vt(e, t, n) {
                  var r = Math.min(this.t + e.t, t);
                  n.s = 0, n.t = r;
                  while (r > 0)
                    n.data[--r] = 0;
                  var i;
                  for (i = n.t - this.t; r < i; ++r)
                    n.data[r + this.t] = this.am(0, e.data[r], n, r, 0, this.t);
                  for (i = Math.min(e.t, t); r < i; ++r)
                    this.am(0, e.data[r], n, r, 0, t - r);
                  n.clamp();
                }
                function $t(e, t, n) {
                  --t;
                  var r = n.t = this.t + e.t - t;
                  n.s = 0;
                  while (--r >= 0)
                    n.data[r] = 0;
                  for (r = Math.max(t - this.t, 0); r < e.t; ++r)
                    n.data[this.t + r - t] = this.am(t - r, e.data[r], n, 0, 0, this.t + r - t);
                  n.clamp(), n.drShiftTo(1, n);
                }
                function Jt(e) {
                  this.r2 = s(), this.q3 = s(), i.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e;
                }
                function Kt(e) {
                  if (e.s < 0 || e.t > 2 * this.m.t)
                    return e.mod(this.m);
                  if (e.compareTo(this.m) < 0)
                    return e;
                  var t = s();
                  return e.copyTo(t), this.reduce(t), t;
                }
                function Qt(e) {
                  return e;
                }
                function Gt(e) {
                  e.drShiftTo(this.m.t - 1, this.r2), e.t > this.m.t + 1 && (e.t = this.m.t + 1, e.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
                  while (e.compareTo(this.r2) < 0)
                    e.dAddOffset(1, this.m.t + 1);
                  e.subTo(this.r2, e);
                  while (e.compareTo(this.m) >= 0)
                    e.subTo(this.m, e);
                }
                function Yt(e, t) {
                  e.squareTo(t), this.reduce(t);
                }
                function Zt(e, t, n) {
                  e.multiplyTo(t, n), this.reduce(n);
                }
                function en(e, t) {
                  var n = e.bitLength(),
                      r,
                      i = y(1),
                      o;
                  if (n <= 0)
                    return i;
                  n < 18 ? r = 1 : n < 48 ? r = 3 : n < 144 ? r = 4 : n < 768 ? r = 5 : r = 6, n < 8 ? o = new B(t) : t.isEven() ? o = new Jt(t) : o = new z(t);
                  var u = new Array,
                      a = 3,
                      f = r - 1,
                      l = (1 << r) - 1;
                  u[1] = o.convert(this);
                  if (r > 1) {
                    var c = s();
                    o.sqrTo(u[1], c);
                    while (a <= l)
                      u[a] = s(), o.mulTo(c, u[a - 2], u[a]), a += 2;
                  }
                  var h = e.t - 1,
                      p,
                      d = !0,
                      v = s(),
                      m;
                  n = N(e.data[h]) - 1;
                  while (h >= 0) {
                    n >= f ? p = e.data[h] >> n - f & l : (p = (e.data[h] & (1 << n + 1) - 1) << f - n, h > 0 && (p |= e.data[h - 1] >> this.DB + n - f)), a = r;
                    while ((p & 1) == 0)
                      p >>= 1, --a;
                    (n -= a) < 0 && (n += this.DB, --h);
                    if (d)
                      u[p].copyTo(i), d = !1;
                    else {
                      while (a > 1)
                        o.sqrTo(i, v), o.sqrTo(v, i), a -= 2;
                      a > 0 ? o.sqrTo(i, v) : (m = i, i = v, v = m), o.mulTo(v, u[p], i);
                    }
                    while (h >= 0 && (e.data[h] & 1 << n) == 0)
                      o.sqrTo(i, v), m = i, i = v, v = m, --n < 0 && (n = this.DB - 1, --h);
                  }
                  return o.revert(i);
                }
                function tn(e) {
                  var t = this.s < 0 ? this.negate() : this.clone(),
                      n = e.s < 0 ? e.negate() : e.clone();
                  if (t.compareTo(n) < 0) {
                    var r = t;
                    t = n, n = r;
                  }
                  var i = t.getLowestSetBit(),
                      s = n.getLowestSetBit();
                  if (s < 0)
                    return t;
                  i < s && (s = i), s > 0 && (t.rShiftTo(s, t), n.rShiftTo(s, n));
                  while (t.signum() > 0)
                    (i = t.getLowestSetBit()) > 0 && t.rShiftTo(i, t), (i = n.getLowestSetBit()) > 0 && n.rShiftTo(i, n), t.compareTo(n) >= 0 ? (t.subTo(n, t), t.rShiftTo(1, t)) : (n.subTo(t, n), n.rShiftTo(1, n));
                  return s > 0 && n.lShiftTo(s, n), n;
                }
                function nn(e) {
                  if (e <= 0)
                    return 0;
                  var t = this.DV % e,
                      n = this.s < 0 ? e - 1 : 0;
                  if (this.t > 0)
                    if (t == 0)
                      n = this.data[0] % e;
                    else
                      for (var r = this.t - 1; r >= 0; --r)
                        n = (t * n + this.data[r]) % e;
                  return n;
                }
                function rn(e) {
                  var t = e.isEven();
                  if (this.isEven() && t || e.signum() == 0)
                    return i.ZERO;
                  var n = e.clone(),
                      r = this.clone(),
                      s = y(1),
                      o = y(0),
                      u = y(0),
                      a = y(1);
                  while (n.signum() != 0) {
                    while (n.isEven()) {
                      n.rShiftTo(1, n);
                      if (t) {
                        if (!s.isEven() || !o.isEven())
                          s.addTo(this, s), o.subTo(e, o);
                        s.rShiftTo(1, s);
                      } else
                        o.isEven() || o.subTo(e, o);
                      o.rShiftTo(1, o);
                    }
                    while (r.isEven()) {
                      r.rShiftTo(1, r);
                      if (t) {
                        if (!u.isEven() || !a.isEven())
                          u.addTo(this, u), a.subTo(e, a);
                        u.rShiftTo(1, u);
                      } else
                        a.isEven() || a.subTo(e, a);
                      a.rShiftTo(1, a);
                    }
                    n.compareTo(r) >= 0 ? (n.subTo(r, n), t && s.subTo(u, s), o.subTo(a, o)) : (r.subTo(n, r), t && u.subTo(s, u), a.subTo(o, a));
                  }
                  return r.compareTo(i.ONE) != 0 ? i.ZERO : a.compareTo(e) >= 0 ? a.subtract(e) : a.signum() < 0 ? (a.addTo(e, a), a.signum() < 0 ? a.add(e) : a) : a;
                }
                function un(e) {
                  var t,
                      n = this.abs();
                  if (n.t == 1 && n.data[0] <= sn[sn.length - 1]) {
                    for (t = 0; t < sn.length; ++t)
                      if (n.data[0] == sn[t])
                        return !0;
                    return !1;
                  }
                  if (n.isEven())
                    return !1;
                  t = 1;
                  while (t < sn.length) {
                    var r = sn[t],
                        i = t + 1;
                    while (i < sn.length && r < on)
                      r *= sn[i++];
                    r = n.modInt(r);
                    while (t < i)
                      if (r % sn[t++] == 0)
                        return !1;
                  }
                  return n.millerRabin(e);
                }
                function an(e) {
                  var t = this.subtract(i.ONE),
                      n = t.getLowestSetBit();
                  if (n <= 0)
                    return !1;
                  var r = t.shiftRight(n),
                      s = fn(),
                      o;
                  for (var u = 0; u < e; ++u) {
                    do
                      o = new i(this.bitLength(), s);
 while (o.compareTo(i.ONE) <= 0 || o.compareTo(t) >= 0);
                    var a = o.modPow(r, this);
                    if (a.compareTo(i.ONE) != 0 && a.compareTo(t) != 0) {
                      var f = 1;
                      while (f++ < n && a.compareTo(t) != 0) {
                        a = a.modPowInt(2, this);
                        if (a.compareTo(i.ONE) == 0)
                          return !1;
                      }
                      if (a.compareTo(t) != 0)
                        return !1;
                    }
                  }
                  return !0;
                }
                function fn() {
                  return {nextBytes: function(e) {
                      for (var t = 0; t < e.length; ++t)
                        e[t] = Math.floor(Math.random() * 255);
                    }};
                }
                var t,
                    n = 0xdeadbeefcafe,
                    r = (n & 16777215) == 15715070;
                typeof navigator == "undefined" ? (i.prototype.am = a, t = 28) : r && navigator.appName == "Microsoft Internet Explorer" ? (i.prototype.am = u, t = 30) : r && navigator.appName != "Netscape" ? (i.prototype.am = o, t = 26) : (i.prototype.am = a, t = 28), i.prototype.DB = t, i.prototype.DM = (1 << t) - 1, i.prototype.DV = 1 << t;
                var f = 52;
                i.prototype.FV = Math.pow(2, f), i.prototype.F1 = f - t, i.prototype.F2 = 2 * t - f;
                var l = "0123456789abcdefghijklmnopqrstuvwxyz",
                    c = new Array,
                    h,
                    p;
                h = "0".charCodeAt(0);
                for (p = 0; p <= 9; ++p)
                  c[h++] = p;
                h = "a".charCodeAt(0);
                for (p = 10; p < 36; ++p)
                  c[h++] = p;
                h = "A".charCodeAt(0);
                for (p = 10; p < 36; ++p)
                  c[h++] = p;
                B.prototype.convert = j, B.prototype.revert = F, B.prototype.reduce = I, B.prototype.mulTo = q, B.prototype.sqrTo = R, z.prototype.convert = W, z.prototype.revert = X, z.prototype.reduce = V, z.prototype.mulTo = J, z.prototype.sqrTo = $, i.prototype.copyTo = m, i.prototype.fromInt = g, i.prototype.fromString = b, i.prototype.clamp = w, i.prototype.dlShiftTo = k, i.prototype.drShiftTo = L, i.prototype.lShiftTo = A, i.prototype.rShiftTo = O, i.prototype.subTo = M, i.prototype.multiplyTo = _, i.prototype.squareTo = D, i.prototype.divRemTo = P, i.prototype.invDigit = U, i.prototype.isEven = K, i.prototype.exp = Q, i.prototype.toString = E, i.prototype.negate = S, i.prototype.abs = x, i.prototype.compareTo = T, i.prototype.bitLength = C, i.prototype.mod = H, i.prototype.modPowInt = G, i.ZERO = y(0), i.ONE = y(1), Rt.prototype.convert = Ut, Rt.prototype.revert = Ut, Rt.prototype.mulTo = zt, Rt.prototype.sqrTo = Wt, Jt.prototype.convert = Kt, Jt.prototype.revert = Qt, Jt.prototype.reduce = Gt, Jt.prototype.mulTo = Zt, Jt.prototype.sqrTo = Yt;
                var sn = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509],
                    on = (1 << 26) / sn[sn.length - 1];
                i.prototype.chunkSize = nt, i.prototype.toRadix = it, i.prototype.fromRadix = st, i.prototype.fromNumber = ot, i.prototype.bitwiseTo = ct, i.prototype.changeBit = Lt, i.prototype.addTo = _t, i.prototype.dMultiply = It, i.prototype.dAddOffset = qt, i.prototype.multiplyLowerTo = Vt, i.prototype.multiplyUpperTo = $t, i.prototype.modInt = nn, i.prototype.millerRabin = an, i.prototype.clone = Y, i.prototype.intValue = Z, i.prototype.byteValue = et, i.prototype.shortValue = tt, i.prototype.signum = rt, i.prototype.toByteArray = ut, i.prototype.equals = at, i.prototype.min = ft, i.prototype.max = lt, i.prototype.and = pt, i.prototype.or = vt, i.prototype.xor = gt, i.prototype.andNot = bt, i.prototype.not = wt, i.prototype.shiftLeft = Et, i.prototype.shiftRight = St, i.prototype.getLowestSetBit = Tt, i.prototype.bitCount = Ct, i.prototype.testBit = kt, i.prototype.setBit = At, i.prototype.clearBit = Ot, i.prototype.flipBit = Mt, i.prototype.add = Dt, i.prototype.subtract = Pt, i.prototype.multiply = Ht, i.prototype.divide = Bt, i.prototype.remainder = jt, i.prototype.divideAndRemainder = Ft, i.prototype.modPow = en, i.prototype.modInverse = rn, i.prototype.pow = Xt, i.prototype.gcd = tn, i.prototype.isProbablePrime = un, e.jsbn = e.jsbn || {}, e.jsbn.BigInteger = i;
              }
              var r = "jsbn";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/jsbn", ["require", "module"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function n(e, t, n) {
                  var r = "",
                      i = Math.ceil(t / n.digestLength);
                  for (var s = 0; s < i; ++s) {
                    var o = String.fromCharCode(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, s & 255);
                    n.start(), n.update(e + o), r += n.digest().getBytes();
                  }
                  return r.substring(0, t);
                }
                var t = e.pkcs1 = e.pkcs1 || {};
                t.encode_rsa_oaep = function(t, r, i) {
                  var s = undefined,
                      o = undefined,
                      u = undefined;
                  typeof i == "string" ? (s = i, o = arguments[3] || undefined, u = arguments[4] || undefined) : i && (s = i.label || undefined, o = i.seed || undefined, u = i.md || undefined), u ? u.start() : u = e.md.sha1.create();
                  var a = Math.ceil(t.n.bitLength() / 8),
                      f = a - 2 * u.digestLength - 2;
                  if (r.length > f)
                    throw {
                      message: "RSAES-OAEP input message length is too long.",
                      length: r.length,
                      maxLength: f
                    };
                  s || (s = ""), u.update(s, "raw");
                  var l = u.digest(),
                      c = "",
                      h = f - r.length;
                  for (var p = 0; p < h; p++)
                    c += "\0";
                  var d = l.getBytes() + c + "" + r;
                  if (!o)
                    o = e.random.getBytes(u.digestLength);
                  else if (o.length !== u.digestLength)
                    throw {
                      message: "Invalid RSAES-OAEP seed. The seed length must match the digest length.",
                      seedLength: o.length,
                      digestLength: u.digestLength
                    };
                  var v = n(o, a - u.digestLength - 1, u),
                      m = e.util.xorBytes(d, v, d.length),
                      g = n(m, u.digestLength, u),
                      y = e.util.xorBytes(o, g, o.length);
                  return "\0" + y + m;
                }, t.decode_rsa_oaep = function(t, r, i) {
                  var s = undefined,
                      o = undefined;
                  typeof i == "string" ? (s = i, o = arguments[3] || undefined) : i && (s = i.label || undefined, o = i.md || undefined);
                  var u = Math.ceil(t.n.bitLength() / 8);
                  if (r.length !== u)
                    throw {
                      message: "RSAES-OAEP encoded message length is invalid.",
                      length: r.length,
                      expectedLength: u
                    };
                  o === undefined ? o = e.md.sha1.create() : o.start();
                  if (u < 2 * o.digestLength + 2)
                    throw {message: "RSAES-OAEP key is too short for the hash function."};
                  s || (s = ""), o.update(s, "raw");
                  var a = o.digest().getBytes(),
                      f = r.charAt(0),
                      l = r.substring(1, o.digestLength + 1),
                      c = r.substring(1 + o.digestLength),
                      h = n(c, o.digestLength, o),
                      p = e.util.xorBytes(l, h, l.length),
                      d = n(p, u - o.digestLength - 1, o),
                      v = e.util.xorBytes(c, d, c.length),
                      m = v.substring(0, o.digestLength),
                      g = f !== "\0";
                  for (var y = 0; y < o.digestLength; ++y)
                    g |= a.charAt(y) !== m.charAt(y);
                  var b = 1,
                      w = o.digestLength;
                  for (var E = o.digestLength; E < v.length; E++) {
                    var S = v.charCodeAt(E),
                        x = S & 1 ^ 1,
                        T = b ? 65534 : 0;
                    g |= S & T, b &= x, w += b;
                  }
                  if (g || v.charCodeAt(w) !== 1)
                    throw {message: "Invalid RSAES-OAEP padding."};
                  return v.substring(w + 1);
                };
              }
              var r = "pkcs1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pkcs1", ["require", "module", "./util", "./random", "./sha1"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function c(t, n, r) {
                  var i = e.util.createBuffer(),
                      s = Math.ceil(n.n.bitLength() / 8);
                  if (t.length > s - 11)
                    throw {
                      message: "Message is too long for PKCS#1 v1.5 padding.",
                      length: t.length,
                      max: s - 11
                    };
                  i.putByte(0), i.putByte(r);
                  var o = s - 3 - t.length,
                      u;
                  if (r === 0 || r === 1) {
                    u = r === 0 ? 0 : 255;
                    for (var a = 0; a < o; ++a)
                      i.putByte(u);
                  } else
                    while (o > 0) {
                      var f = 0,
                          l = e.random.getBytes(o);
                      for (var a = 0; a < o; ++a)
                        u = l.charCodeAt(a), u === 0 ? ++f : i.putByte(u);
                      o = f;
                    }
                  return i.putByte(0), i.putBytes(t), i;
                }
                function h(t, n, r, i) {
                  var s = Math.ceil(n.n.bitLength() / 8),
                      o = e.util.createBuffer(t),
                      u = o.getByte(),
                      a = o.getByte();
                  if (u !== 0 || r && a !== 0 && a !== 1 || !r && a != 2 || r && a === 0 && typeof i == "undefined")
                    throw {message: "Encryption block is invalid."};
                  var f = 0;
                  if (a === 0) {
                    f = s - 3 - i;
                    for (var l = 0; l < f; ++l)
                      if (o.getByte() !== 0)
                        throw {message: "Encryption block is invalid."};
                  } else if (a === 1) {
                    f = 0;
                    while (o.length() > 1) {
                      if (o.getByte() !== 255) {
                        --o.read;
                        break;
                      }
                      ++f;
                    }
                  } else if (a === 2) {
                    f = 0;
                    while (o.length() > 1) {
                      if (o.getByte() === 0) {
                        --o.read;
                        break;
                      }
                      ++f;
                    }
                  }
                  var c = o.getByte();
                  if (c !== 0 || f !== s - 3 - o.length())
                    throw {message: "Encryption block is invalid."};
                  return o.getBytes();
                }
                function p(n, i, s) {
                  function p() {
                    d(n.pBits, function(e, t) {
                      if (e)
                        return s(e);
                      n.p = t, d(n.qBits, v);
                    });
                  }
                  function d(e, r) {
                    function p() {
                      var r = e - 1,
                          i = new t(e, n.rng);
                      return i.testBit(r) || i.bitwiseTo(t.ONE.shiftLeft(r), h, i), i.dAddOffset(31 - i.mod(c).byteValue(), 0), i;
                    }
                    function v(s) {
                      if (d)
                        return;
                      --o;
                      var u = s.data;
                      if (u.found) {
                        for (var c = 0; c < i.length; ++c)
                          i[c].terminate();
                        return d = !0, r(null, new t(u.prime, 16));
                      }
                      l.bitLength() > e && (l = p());
                      var h = l.toString(16);
                      s.target.postMessage({
                        e: n.eInt,
                        hex: h,
                        workLoad: a
                      }), l.dAddOffset(f, 0);
                    }
                    var i = [];
                    for (var s = 0; s < u; ++s)
                      i[s] = new Worker("./forge/prime.worker.js");
                    var o = u,
                        l = p();
                    for (var s = 0; s < u; ++s)
                      i[s].addEventListener("message", v);
                    var d = !1;
                  }
                  function v(e, i) {
                    n.q = i;
                    if (n.p.compareTo(n.q) < 0) {
                      var o = n.p;
                      n.p = n.q, n.q = o;
                    }
                    n.p1 = n.p.subtract(t.ONE), n.q1 = n.q.subtract(t.ONE), n.phi = n.p1.multiply(n.q1);
                    if (n.phi.gcd(n.e).compareTo(t.ONE) !== 0) {
                      n.p = n.q = null, p();
                      return;
                    }
                    n.n = n.p.multiply(n.q);
                    if (n.n.bitLength() !== n.bits) {
                      n.q = null, d(n.qBits, v);
                      return;
                    }
                    var u = n.e.modInverse(n.phi);
                    n.keys = {
                      privateKey: r.rsa.setPrivateKey(n.n, n.e, u, n.p, n.q, u.mod(n.p1), u.mod(n.q1), n.q.modInverse(n.p)),
                      publicKey: r.rsa.setPublicKey(n.n, n.e)
                    }, s(null, n.keys);
                  }
                  typeof i == "function" && (s = i, i = {});
                  if (typeof Worker == "undefined") {
                    function o() {
                      if (r.rsa.stepKeyPairGenerationState(n, 10))
                        return s(null, n.keys);
                      e.util.setImmediate(o);
                    }
                    return o();
                  }
                  var u = i.workers || 2,
                      a = i.workLoad || 100,
                      f = a * 30 / 8,
                      l = i.workerScript || "forge/prime.worker.js",
                      c = new t(null);
                  c.fromInt(30);
                  var h = function(e, t) {
                    return e | t;
                  };
                  p();
                }
                function d(t) {
                  var n = t.toString(16);
                  return n[0] >= "8" && (n = "00" + n), e.util.hexToBytes(n);
                }
                function v(e) {
                  return e <= 100 ? 27 : e <= 150 ? 18 : e <= 200 ? 15 : e <= 250 ? 12 : e <= 300 ? 9 : e <= 350 ? 8 : e <= 400 ? 7 : e <= 500 ? 6 : e <= 600 ? 5 : e <= 800 ? 4 : e <= 1250 ? 3 : 2;
                }
                if (typeof t == "undefined")
                  var t = e.jsbn.BigInteger;
                var n = e.asn1;
                e.pki = e.pki || {}, e.pki.rsa = e.rsa = e.rsa || {};
                var r = e.pki,
                    i = [6, 4, 2, 4, 2, 4, 6, 2],
                    s = {
                      name: "PrivateKeyInfo",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "PrivateKeyInfo.version",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyVersion"
                      }, {
                        name: "PrivateKeyInfo.privateKeyAlgorithm",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "AlgorithmIdentifier.algorithm",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "privateKeyOid"
                        }]
                      }, {
                        name: "PrivateKeyInfo",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.OCTETSTRING,
                        constructed: !1,
                        capture: "privateKey"
                      }]
                    },
                    o = {
                      name: "RSAPrivateKey",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "RSAPrivateKey.version",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyVersion"
                      }, {
                        name: "RSAPrivateKey.modulus",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyModulus"
                      }, {
                        name: "RSAPrivateKey.publicExponent",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyPublicExponent"
                      }, {
                        name: "RSAPrivateKey.privateExponent",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyPrivateExponent"
                      }, {
                        name: "RSAPrivateKey.prime1",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyPrime1"
                      }, {
                        name: "RSAPrivateKey.prime2",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyPrime2"
                      }, {
                        name: "RSAPrivateKey.exponent1",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyExponent1"
                      }, {
                        name: "RSAPrivateKey.exponent2",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyExponent2"
                      }, {
                        name: "RSAPrivateKey.coefficient",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyCoefficient"
                      }]
                    },
                    u = {
                      name: "RSAPublicKey",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "RSAPublicKey.modulus",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "publicKeyModulus"
                      }, {
                        name: "RSAPublicKey.exponent",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "publicKeyExponent"
                      }]
                    },
                    a = e.pki.rsa.publicKeyValidator = {
                      name: "SubjectPublicKeyInfo",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      captureAsn1: "subjectPublicKeyInfo",
                      value: [{
                        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "AlgorithmIdentifier.algorithm",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "publicKeyOid"
                        }]
                      }, {
                        name: "SubjectPublicKeyInfo.subjectPublicKey",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.BITSTRING,
                        constructed: !1,
                        value: [{
                          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.SEQUENCE,
                          constructed: !0,
                          optional: !0,
                          captureAsn1: "rsaPublicKey"
                        }]
                      }]
                    },
                    f = function(e) {
                      var t;
                      if (e.algorithm in r.oids) {
                        t = r.oids[e.algorithm];
                        var i = n.oidToDer(t).getBytes(),
                            s = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, []),
                            o = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, []);
                        o.value.push(n.create(n.Class.UNIVERSAL, n.Type.OID, !1, i)), o.value.push(n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, ""));
                        var u = n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, e.digest().getBytes());
                        return s.value.push(o), s.value.push(u), n.toDer(s).getBytes();
                      }
                      throw {
                        message: "Unknown message digest algorithm.",
                        algorithm: e.algorithm
                      };
                    },
                    l = function(e, n, r) {
                      var i;
                      if (r)
                        i = e.modPow(n.e, n.n);
                      else if (!n.p || !n.q)
                        i = e.modPow(n.d, n.n);
                      else {
                        n.dP || (n.dP = n.d.mod(n.p.subtract(t.ONE))), n.dQ || (n.dQ = n.d.mod(n.q.subtract(t.ONE))), n.qInv || (n.qInv = n.q.modInverse(n.p));
                        var s = e.mod(n.p).modPow(n.dP, n.p),
                            o = e.mod(n.q).modPow(n.dQ, n.q);
                        while (s.compareTo(o) < 0)
                          s = s.add(n.p);
                        i = s.subtract(o).multiply(n.qInv).mod(n.p).multiply(n.q).add(o);
                      }
                      return i;
                    };
                r.rsa.encrypt = function(n, r, i) {
                  var s = i,
                      o,
                      u = Math.ceil(r.n.bitLength() / 8);
                  i !== !1 && i !== !0 ? (s = i === 2, o = c(n, r, i)) : (o = e.util.createBuffer(), o.putBytes(n));
                  var a = new t(o.toHex(), 16),
                      f = l(a, r, s),
                      h = f.toString(16),
                      p = e.util.createBuffer(),
                      d = u - Math.ceil(h.length / 2);
                  while (d > 0)
                    p.putByte(0), --d;
                  return p.putBytes(e.util.hexToBytes(h)), p.getBytes();
                }, r.rsa.decrypt = function(n, r, i, s) {
                  var o = Math.ceil(r.n.bitLength() / 8);
                  if (n.length !== o)
                    throw {
                      message: "Encrypted message length is invalid.",
                      length: n.length,
                      expected: o
                    };
                  var u = new t(e.util.createBuffer(n).toHex(), 16);
                  if (u.compareTo(r.n) >= 0)
                    throw {message: "Encrypted message is invalid."};
                  var a = l(u, r, i),
                      f = a.toString(16),
                      c = e.util.createBuffer(),
                      p = o - Math.ceil(f.length / 2);
                  while (p > 0)
                    c.putByte(0), --p;
                  return c.putBytes(e.util.hexToBytes(f)), s !== !1 ? h(c.getBytes(), r, i) : c.getBytes();
                }, r.rsa.createKeyPairGenerationState = function(n, r) {
                  typeof n == "string" && (n = parseInt(n, 10)), n = n || 2048;
                  var i = {nextBytes: function(t) {
                      var n = e.random.getBytes(t.length);
                      for (var r = 0; r < t.length; ++r)
                        t[r] = n.charCodeAt(r);
                    }},
                      s = {
                        state: 0,
                        bits: n,
                        rng: i,
                        eInt: r || 65537,
                        e: new t(null),
                        p: null,
                        q: null,
                        qBits: n >> 1,
                        pBits: n - (n >> 1),
                        pqState: 0,
                        num: null,
                        keys: null
                      };
                  return s.e.fromInt(s.eInt), s;
                }, r.rsa.stepKeyPairGenerationState = function(e, n) {
                  var s = new t(null);
                  s.fromInt(30);
                  var o = 0,
                      u = function(e, t) {
                        return e | t;
                      },
                      a = +(new Date),
                      f,
                      l = 0;
                  while (e.keys === null && (n <= 0 || l < n)) {
                    if (e.state === 0) {
                      var c = e.p === null ? e.pBits : e.qBits,
                          h = c - 1;
                      e.pqState === 0 ? (e.num = new t(c, e.rng), e.num.testBit(h) || e.num.bitwiseTo(t.ONE.shiftLeft(h), u, e.num), e.num.dAddOffset(31 - e.num.mod(s).byteValue(), 0), o = 0, ++e.pqState) : e.pqState === 1 ? e.num.bitLength() > c ? e.pqState = 0 : e.num.isProbablePrime(v(e.num.bitLength())) ? ++e.pqState : e.num.dAddOffset(i[o++ % 8], 0) : e.pqState === 2 ? e.pqState = e.num.subtract(t.ONE).gcd(e.e).compareTo(t.ONE) === 0 ? 3 : 0 : e.pqState === 3 && (e.pqState = 0, e.p === null ? e.p = e.num : e.q = e.num, e.p !== null && e.q !== null && ++e.state, e.num = null);
                    } else if (e.state === 1)
                      e.p.compareTo(e.q) < 0 && (e.num = e.p, e.p = e.q, e.q = e.num), ++e.state;
                    else if (e.state === 2)
                      e.p1 = e.p.subtract(t.ONE), e.q1 = e.q.subtract(t.ONE), e.phi = e.p1.multiply(e.q1), ++e.state;
                    else if (e.state === 3)
                      e.phi.gcd(e.e).compareTo(t.ONE) === 0 ? ++e.state : (e.p = null, e.q = null, e.state = 0);
                    else if (e.state === 4)
                      e.n = e.p.multiply(e.q), e.n.bitLength() === e.bits ? ++e.state : (e.q = null, e.state = 0);
                    else if (e.state === 5) {
                      var p = e.e.modInverse(e.phi);
                      e.keys = {
                        privateKey: r.rsa.setPrivateKey(e.n, e.e, p, e.p, e.q, p.mod(e.p1), p.mod(e.q1), e.q.modInverse(e.p)),
                        publicKey: r.rsa.setPublicKey(e.n, e.e)
                      };
                    }
                    f = +(new Date), l += f - a, a = f;
                  }
                  return e.keys !== null;
                }, r.rsa.generateKeyPair = function(e, t, n, i) {
                  arguments.length === 1 ? typeof e == "object" ? (n = e, e = undefined) : typeof e == "function" && (i = e, e = undefined) : arguments.length === 2 ? (typeof e == "number" ? typeof t == "function" ? i = t : n = t : (n = e, i = t, e = undefined), t = undefined) : arguments.length === 3 && (typeof t == "number" ? typeof n == "function" && (i = n, n = undefined) : (i = n, n = t, t = undefined)), n = n || {}, e === undefined && (e = n.bits || 2048), t === undefined && (t = n.e || 65537);
                  var s = r.rsa.createKeyPairGenerationState(e, t);
                  if (!i)
                    return r.rsa.stepKeyPairGenerationState(s, 0), s.keys;
                  p(s, n, i);
                }, r.setRsaPublicKey = r.rsa.setPublicKey = function(t, i) {
                  var s = {
                    n: t,
                    e: i
                  };
                  return s.encrypt = function(t, n, i) {
                    typeof n == "string" ? n = n.toUpperCase() : n === undefined && (n = "RSAES-PKCS1-V1_5");
                    if (n === "RSAES-PKCS1-V1_5")
                      n = {encode: function(e, t, n) {
                          return c(e, t, 2).getBytes();
                        }};
                    else if (n === "RSA-OAEP" || n === "RSAES-OAEP")
                      n = {encode: function(t, n) {
                          return e.pkcs1.encode_rsa_oaep(n, t, i);
                        }};
                    else {
                      if (["RAW", "NONE", "NULL", null].indexOf(n) === -1)
                        throw {message: 'Unsupported encryption scheme: "' + n + '".'};
                      n = {encode: function(e) {
                          return e;
                        }};
                    }
                    var o = n.encode(t, s, !0);
                    return r.rsa.encrypt(o, s, !0);
                  }, s.verify = function(e, t, i) {
                    typeof i == "string" ? i = i.toUpperCase() : i === undefined && (i = "RSASSA-PKCS1-V1_5");
                    if (i === "RSASSA-PKCS1-V1_5")
                      i = {verify: function(e, t) {
                          t = h(t, s, !0);
                          var r = n.fromDer(t);
                          return e === r.value[1].value;
                        }};
                    else if (i === "NONE" || i === "NULL" || i === null)
                      i = {verify: function(e, t) {
                          return t = h(t, s, !0), e === t;
                        }};
                    var o = r.rsa.decrypt(t, s, !0, !1);
                    return i.verify(e, o, s.n.bitLength());
                  }, s;
                }, r.setRsaPrivateKey = r.rsa.setPrivateKey = function(t, n, i, s, o, u, a, l) {
                  var c = {
                    n: t,
                    e: n,
                    d: i,
                    p: s,
                    q: o,
                    dP: u,
                    dQ: a,
                    qInv: l
                  };
                  return c.decrypt = function(t, n, i) {
                    typeof n == "string" ? n = n.toUpperCase() : n === undefined && (n = "RSAES-PKCS1-V1_5");
                    var s = r.rsa.decrypt(t, c, !1, !1);
                    if (n === "RSAES-PKCS1-V1_5")
                      n = {decode: h};
                    else if (n === "RSA-OAEP" || n === "RSAES-OAEP")
                      n = {decode: function(t, n) {
                          return e.pkcs1.decode_rsa_oaep(n, t, i);
                        }};
                    else {
                      if (["RAW", "NONE", "NULL", null].indexOf(n) === -1)
                        throw {message: 'Unsupported encryption scheme: "' + n + '".'};
                      n = {decode: function(e) {
                          return e;
                        }};
                    }
                    return n.decode(s, c, !1);
                  }, c.sign = function(e, t) {
                    var n = !1;
                    typeof t == "string" && (t = t.toUpperCase());
                    if (t === undefined || t === "RSASSA-PKCS1-V1_5")
                      t = {encode: f}, n = 1;
                    else if (t === "NONE" || t === "NULL" || t === null)
                      t = {encode: function() {
                          return e;
                        }}, n = 1;
                    var i = t.encode(e, c.n.bitLength());
                    return r.rsa.encrypt(i, c, n);
                  }, c;
                }, r.wrapRsaPrivateKey = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(0).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(r.oids.rsaEncryption).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, "")]), n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, n.toDer(e).getBytes())]);
                }, r.wrapRsaPrivateKey = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(0).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(r.oids.rsaEncryption).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, "")]), n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, n.toDer(e).getBytes())]);
                }, r.privateKeyFromAsn1 = function(i) {
                  var u = {},
                      a = [];
                  n.validate(i, s, u, a) && (i = n.fromDer(e.util.createBuffer(u.privateKey))), u = {}, a = [];
                  if (!n.validate(i, o, u, a))
                    throw {
                      message: "Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.",
                      errors: a
                    };
                  var f,
                      l,
                      c,
                      h,
                      p,
                      d,
                      v,
                      m;
                  return f = e.util.createBuffer(u.privateKeyModulus).toHex(), l = e.util.createBuffer(u.privateKeyPublicExponent).toHex(), c = e.util.createBuffer(u.privateKeyPrivateExponent).toHex(), h = e.util.createBuffer(u.privateKeyPrime1).toHex(), p = e.util.createBuffer(u.privateKeyPrime2).toHex(), d = e.util.createBuffer(u.privateKeyExponent1).toHex(), v = e.util.createBuffer(u.privateKeyExponent2).toHex(), m = e.util.createBuffer(u.privateKeyCoefficient).toHex(), r.setRsaPrivateKey(new t(f, 16), new t(l, 16), new t(c, 16), new t(h, 16), new t(p, 16), new t(d, 16), new t(v, 16), new t(m, 16));
                }, r.privateKeyToAsn1 = r.privateKeyToRSAPrivateKey = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(0).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.n)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.e)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.d)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.p)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.q)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.dP)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.dQ)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.qInv))]);
                }, r.publicKeyFromAsn1 = function(i) {
                  var s = {},
                      o = [];
                  if (n.validate(i, a, s, o)) {
                    var f = n.derToOid(s.publicKeyOid);
                    if (f !== r.oids.rsaEncryption)
                      throw {
                        message: "Cannot read public key. Unknown OID.",
                        oid: f
                      };
                    i = s.rsaPublicKey;
                  }
                  o = [];
                  if (!n.validate(i, u, s, o))
                    throw {
                      message: "Cannot read public key. ASN.1 object does not contain an RSAPublicKey.",
                      errors: o
                    };
                  var l = e.util.createBuffer(s.publicKeyModulus).toHex(),
                      c = e.util.createBuffer(s.publicKeyExponent).toHex();
                  return r.setRsaPublicKey(new t(l, 16), new t(c, 16));
                }, r.publicKeyToAsn1 = r.publicKeyToSubjectPublicKeyInfo = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(r.oids.rsaEncryption).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, "")]), n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, [r.publicKeyToRSAPublicKey(e)])]);
                }, r.publicKeyToRSAPublicKey = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.n)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.e))]);
                };
              }
              var r = "rsa";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/rsa", ["require", "module", "./asn1", "./oids", "./random", "./util", "./jsbn", "./pkcs1"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function a(e, t, n) {
                  var r = [f(e + t)];
                  for (var i = 16,
                      s = 1; i < n; ++s, i += 16)
                    r.push(f(r[s - 1] + e + t));
                  return r.join("").substr(0, n);
                }
                function f(t) {
                  return e.md.md5.create().update(t).digest().getBytes();
                }
                if (typeof t == "undefined")
                  var t = e.jsbn.BigInteger;
                var n = e.asn1,
                    r = e.pki = e.pki || {};
                r.pbe = e.pbe = e.pbe || {};
                var i = r.oids,
                    s = {
                      name: "EncryptedPrivateKeyInfo",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "AlgorithmIdentifier.algorithm",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "encryptionOid"
                        }, {
                          name: "AlgorithmIdentifier.parameters",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.SEQUENCE,
                          constructed: !0,
                          captureAsn1: "encryptionParams"
                        }]
                      }, {
                        name: "EncryptedPrivateKeyInfo.encryptedData",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.OCTETSTRING,
                        constructed: !1,
                        capture: "encryptedData"
                      }]
                    },
                    o = {
                      name: "PBES2Algorithms",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "PBES2Algorithms.keyDerivationFunc",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "PBES2Algorithms.keyDerivationFunc.oid",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "kdfOid"
                        }, {
                          name: "PBES2Algorithms.params",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "PBES2Algorithms.params.salt",
                            tagClass: n.Class.UNIVERSAL,
                            type: n.Type.OCTETSTRING,
                            constructed: !1,
                            capture: "kdfSalt"
                          }, {
                            name: "PBES2Algorithms.params.iterationCount",
                            tagClass: n.Class.UNIVERSAL,
                            type: n.Type.INTEGER,
                            onstructed: !0,
                            capture: "kdfIterationCount"
                          }]
                        }]
                      }, {
                        name: "PBES2Algorithms.encryptionScheme",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "PBES2Algorithms.encryptionScheme.oid",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "encOid"
                        }, {
                          name: "PBES2Algorithms.encryptionScheme.iv",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OCTETSTRING,
                          constructed: !1,
                          capture: "encIv"
                        }]
                      }]
                    },
                    u = {
                      name: "pkcs-12PbeParams",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "pkcs-12PbeParams.salt",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.OCTETSTRING,
                        constructed: !1,
                        capture: "salt"
                      }, {
                        name: "pkcs-12PbeParams.iterations",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "iterations"
                      }]
                    };
                r.encryptPrivateKeyInfo = function(t, s, o) {
                  o = o || {}, o.saltSize = o.saltSize || 8, o.count = o.count || 2048, o.algorithm = o.algorithm || "aes128";
                  var u = e.random.getBytes(o.saltSize),
                      a = o.count,
                      f = n.integerToDer(a),
                      l,
                      c,
                      h;
                  if (o.algorithm.indexOf("aes") === 0) {
                    var p;
                    if (o.algorithm === "aes128")
                      l = 16, p = i["aes128-CBC"];
                    else if (o.algorithm === "aes192")
                      l = 24, p = i["aes192-CBC"];
                    else {
                      if (o.algorithm !== "aes256")
                        throw {
                          message: "Cannot encrypt private key. Unknown encryption algorithm.",
                          algorithm: o.algorithm
                        };
                      l = 32, p = i["aes256-CBC"];
                    }
                    var d = e.pkcs5.pbkdf2(s, u, a, l),
                        v = e.random.getBytes(16),
                        m = e.aes.createEncryptionCipher(d);
                    m.start(v), m.update(n.toDer(t)), m.finish(), h = m.output.getBytes(), c = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(i.pkcs5PBES2).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(i.pkcs5PBKDF2).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, u), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, f.getBytes())])]), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(p).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, v)])])]);
                  } else {
                    if (o.algorithm !== "3des")
                      throw {
                        message: "Cannot encrypt private key. Unknown encryption algorithm.",
                        algorithm: o.algorithm
                      };
                    l = 24;
                    var g = new e.util.ByteBuffer(u),
                        d = r.pbe.generatePkcs12Key(s, g, 1, a, l),
                        v = r.pbe.generatePkcs12Key(s, g, 2, a, l),
                        m = e.des.createEncryptionCipher(d);
                    m.start(v), m.update(n.toDer(t)), m.finish(), h = m.output.getBytes(), c = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(i["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, u), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, f.getBytes())])]);
                  }
                  var y = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [c, n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, h)]);
                  return y;
                }, r.decryptPrivateKeyInfo = function(t, i) {
                  var o = null,
                      u = {},
                      a = [];
                  if (!n.validate(t, s, u, a))
                    throw {
                      message: "Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
                      errors: a
                    };
                  var f = n.derToOid(u.encryptionOid),
                      l = r.pbe.getCipher(f, u.encryptionParams, i),
                      c = e.util.createBuffer(u.encryptedData);
                  return l.update(c), l.finish() && (o = n.fromDer(l.output)), o;
                }, r.encryptedPrivateKeyToPem = function(t, r) {
                  var i = {
                    type: "ENCRYPTED PRIVATE KEY",
                    body: n.toDer(t).getBytes()
                  };
                  return e.pem.encode(i, {maxline: r});
                }, r.encryptedPrivateKeyFromPem = function(t) {
                  var r = e.pem.decode(t)[0];
                  if (r.type !== "ENCRYPTED PRIVATE KEY")
                    throw {
                      message: 'Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".',
                      headerType: r.type
                    };
                  if (r.procType && r.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert encrypted private key from PEM; PEM is encrypted."};
                  return n.fromDer(r.body);
                }, r.encryptRsaPrivateKey = function(t, i, s) {
                  s = s || {};
                  if (!s.legacy) {
                    var o = r.wrapRsaPrivateKey(r.privateKeyToAsn1(t));
                    return o = r.encryptPrivateKeyInfo(o, i, s), r.encryptedPrivateKeyToPem(o);
                  }
                  var u,
                      f,
                      l,
                      c;
                  switch (s.algorithm) {
                    case "aes128":
                      u = "AES-128-CBC", l = 16, f = e.random.getBytes(16), c = e.aes.createEncryptionCipher;
                      break;
                    case "aes192":
                      u = "AES-192-CBC", l = 24, f = e.random.getBytes(16), c = e.aes.createEncryptionCipher;
                      break;
                    case "aes256":
                      u = "AES-256-CBC", l = 32, f = e.random.getBytes(16), c = e.aes.createEncryptionCipher;
                      break;
                    case "3des":
                      u = "DES-EDE3-CBC", l = 24, f = e.random.getBytes(8), c = e.des.createEncryptionCipher;
                      break;
                    default:
                      throw {
                        message: 'Could not encrypt RSA private key; unsupported encryption algorithm "' + s.algorithm + '".',
                        algorithm: s.algorithm
                      };
                  }
                  var h = a(i, f.substr(0, 8), l),
                      p = c(h);
                  p.start(f), p.update(n.toDer(r.privateKeyToAsn1(t))), p.finish();
                  var d = {
                    type: "RSA PRIVATE KEY",
                    procType: {
                      version: "4",
                      type: "ENCRYPTED"
                    },
                    dekInfo: {
                      algorithm: u,
                      parameters: e.util.bytesToHex(f).toUpperCase()
                    },
                    body: p.output.getBytes()
                  };
                  return e.pem.encode(d);
                }, r.decryptRsaPrivateKey = function(t, i) {
                  var s = null,
                      o = e.pem.decode(t)[0];
                  if (o.type !== "ENCRYPTED PRIVATE KEY" && o.type !== "PRIVATE KEY" && o.type !== "RSA PRIVATE KEY")
                    throw {
                      message: 'Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".',
                      headerType: o.type
                    };
                  if (o.procType && o.procType.type === "ENCRYPTED") {
                    var u,
                        f;
                    switch (o.dekInfo.algorithm) {
                      case "DES-EDE3-CBC":
                        u = 24, f = e.des.createDecryptionCipher;
                        break;
                      case "AES-128-CBC":
                        u = 16, f = e.aes.createDecryptionCipher;
                        break;
                      case "AES-192-CBC":
                        u = 24, f = e.aes.createDecryptionCipher;
                        break;
                      case "AES-256-CBC":
                        u = 32, f = e.aes.createDecryptionCipher;
                        break;
                      case "RC2-40-CBC":
                        u = 5, f = function(t) {
                          return e.rc2.createDecryptionCipher(t, 40);
                        };
                        break;
                      case "RC2-64-CBC":
                        u = 8, f = function(t) {
                          return e.rc2.createDecryptionCipher(t, 64);
                        };
                        break;
                      case "RC2-128-CBC":
                        u = 16, f = function(t) {
                          return e.rc2.createDecryptionCipher(t, 128);
                        };
                        break;
                      default:
                        throw {
                          message: 'Could not decrypt private key; unsupported encryption algorithm "' + o.dekInfo.algorithm + '".',
                          algorithm: o.dekInfo.algorithm
                        };
                    }
                    var l = e.util.hexToBytes(o.dekInfo.parameters),
                        c = a(i, l.substr(0, 8), u),
                        h = f(c);
                    h.start(l), h.update(e.util.createBuffer(o.body));
                    if (!h.finish())
                      return s;
                    s = h.output.getBytes();
                  } else
                    s = o.body;
                  return o.type === "ENCRYPTED PRIVATE KEY" ? s = r.decryptPrivateKeyInfo(n.fromDer(s), i) : s = n.fromDer(s), s !== null && (s = r.privateKeyFromAsn1(s)), s;
                }, r.pbe.generatePkcs12Key = function(t, n, r, i, s, o) {
                  var u,
                      a;
                  if (typeof o == "undefined" || o === null)
                    o = e.md.sha1.create();
                  var f = o.digestLength,
                      l = o.blockLength,
                      c = new e.util.ByteBuffer,
                      h = new e.util.ByteBuffer;
                  for (a = 0; a < t.length; a++)
                    h.putInt16(t.charCodeAt(a));
                  h.putInt16(0);
                  var p = h.length(),
                      d = n.length(),
                      v = new e.util.ByteBuffer;
                  v.fillWithByte(r, l);
                  var m = l * Math.ceil(d / l),
                      g = new e.util.ByteBuffer;
                  for (a = 0; a < m; a++)
                    g.putByte(n.at(a % d));
                  var y = l * Math.ceil(p / l),
                      b = new e.util.ByteBuffer;
                  for (a = 0; a < y; a++)
                    b.putByte(h.at(a % p));
                  var w = g;
                  w.putBuffer(b);
                  var E = Math.ceil(s / f);
                  for (var S = 1; S <= E; S++) {
                    var x = new e.util.ByteBuffer;
                    x.putBytes(v.bytes()), x.putBytes(w.bytes());
                    for (var T = 0; T < i; T++)
                      o.start(), o.update(x.getBytes()), x = o.digest();
                    var N = new e.util.ByteBuffer;
                    for (a = 0; a < l; a++)
                      N.putByte(x.at(a % f));
                    var C = Math.ceil(d / l) + Math.ceil(p / l),
                        k = new e.util.ByteBuffer;
                    for (u = 0; u < C; u++) {
                      var L = new e.util.ByteBuffer(w.getBytes(l)),
                          A = 511;
                      for (a = N.length() - 1; a >= 0; a--)
                        A >>= 8, A += N.at(a) + L.at(a), L.setAt(a, A & 255);
                      k.putBuffer(L);
                    }
                    w = k, c.putBuffer(x);
                  }
                  return c.truncate(c.length() - s), c;
                }, r.pbe.getCipher = function(e, t, n) {
                  switch (e) {
                    case r.oids.pkcs5PBES2:
                      return r.pbe.getCipherForPBES2(e, t, n);
                    case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                    case r.oids["pbewithSHAAnd40BitRC2-CBC"]:
                      return r.pbe.getCipherForPKCS12PBE(e, t, n);
                    default:
                      throw {
                        message: "Cannot read encrypted PBE data block. Unsupported OID.",
                        oid: e,
                        supportedOids: ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"]
                      };
                  }
                }, r.pbe.getCipherForPBES2 = function(t, i, s) {
                  var u = {},
                      a = [];
                  if (!n.validate(i, o, u, a))
                    throw {
                      message: "Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
                      errors: a
                    };
                  t = n.derToOid(u.kdfOid);
                  if (t !== r.oids.pkcs5PBKDF2)
                    throw {
                      message: "Cannot read encrypted private key. Unsupported key derivation function OID.",
                      oid: t,
                      supportedOids: ["pkcs5PBKDF2"]
                    };
                  t = n.derToOid(u.encOid);
                  if (t !== r.oids["aes128-CBC"] && t !== r.oids["aes192-CBC"] && t !== r.oids["aes256-CBC"])
                    throw {
                      message: "Cannot read encrypted private key. Unsupported encryption scheme OID.",
                      oid: t,
                      supportedOids: ["aes128-CBC", "aes192-CBC", "aes256-CBC"]
                    };
                  var f = u.kdfSalt,
                      l = e.util.createBuffer(u.kdfIterationCount);
                  l = l.getInt(l.length() << 3);
                  var c;
                  t === r.oids["aes128-CBC"] ? c = 16 : t === r.oids["aes192-CBC"] ? c = 24 : t === r.oids["aes256-CBC"] && (c = 32);
                  var h = e.pkcs5.pbkdf2(s, f, l, c),
                      p = u.encIv,
                      d = e.aes.createDecryptionCipher(h);
                  return d.start(p), d;
                }, r.pbe.getCipherForPKCS12PBE = function(t, i, s) {
                  var o = {},
                      a = [];
                  if (!n.validate(i, u, o, a))
                    throw {
                      message: "Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
                      errors: a
                    };
                  var f = e.util.createBuffer(o.salt),
                      l = e.util.createBuffer(o.iterations);
                  l = l.getInt(l.length() << 3);
                  var c,
                      h,
                      p;
                  switch (t) {
                    case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                      c = 24, h = 8, p = e.des.startDecrypting;
                      break;
                    case r.oids["pbewithSHAAnd40BitRC2-CBC"]:
                      c = 5, h = 8, p = function(t, n) {
                        var r = e.rc2.createDecryptionCipher(t, 40);
                        return r.start(n, null), r;
                      };
                      break;
                    default:
                      throw {
                        message: "Cannot read PKCS #12 PBE data block. Unsupported OID.",
                        oid: t
                      };
                  }
                  var d = r.pbe.generatePkcs12Key(s, f, 1, l, c),
                      v = r.pbe.generatePkcs12Key(s, f, 2, l, h);
                  return p(d, v);
                };
              }
              var r = "pbe";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pbe", ["require", "module", "./aes", "./asn1", "./des", "./md", "./oids", "./pem", "./pbkdf2", "./random", "./rc2", "./rsa", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.asn1,
                    n = e.pkcs7asn1 = e.pkcs7asn1 || {};
                e.pkcs7 = e.pkcs7 || {}, e.pkcs7.asn1 = n;
                var r = {
                  name: "ContentInfo",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "ContentInfo.ContentType",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.OID,
                    constructed: !1,
                    capture: "contentType"
                  }, {
                    name: "ContentInfo.content",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 0,
                    constructed: !0,
                    optional: !0,
                    captureAsn1: "content"
                  }]
                };
                n.contentInfoValidator = r;
                var i = {
                  name: "EncryptedContentInfo",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "EncryptedContentInfo.contentType",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.OID,
                    constructed: !1,
                    capture: "contentType"
                  }, {
                    name: "EncryptedContentInfo.contentEncryptionAlgorithm",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0,
                    value: [{
                      name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OID,
                      constructed: !1,
                      capture: "encAlgorithm"
                    }, {
                      name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
                      tagClass: t.Class.UNIVERSAL,
                      captureAsn1: "encParameter"
                    }]
                  }, {
                    name: "EncryptedContentInfo.encryptedContent",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 0,
                    capture: "encryptedContent"
                  }]
                };
                n.envelopedDataValidator = {
                  name: "EnvelopedData",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "EnvelopedData.Version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1,
                    capture: "version"
                  }, {
                    name: "EnvelopedData.RecipientInfos",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SET,
                    constructed: !0,
                    captureAsn1: "recipientInfos"
                  }].concat(i)
                }, n.encryptedDataValidator = {
                  name: "EncryptedData",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "EncryptedData.Version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1,
                    capture: "version"
                  }].concat(i)
                };
                var s = {
                  name: "SignerInfo",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "SignerInfo.Version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1
                  }, {
                    name: "SignerInfo.IssuerAndSerialNumber",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0
                  }, {
                    name: "SignerInfo.DigestAlgorithm",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0
                  }, {
                    name: "SignerInfo.AuthenticatedAttributes",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 0,
                    constructed: !0,
                    optional: !0,
                    capture: "authenticatedAttributes"
                  }, {
                    name: "SignerInfo.DigestEncryptionAlgorithm",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0
                  }, {
                    name: "SignerInfo.EncryptedDigest",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.OCTETSTRING,
                    constructed: !1,
                    capture: "signature"
                  }, {
                    name: "SignerInfo.UnauthenticatedAttributes",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 1,
                    constructed: !0,
                    optional: !0
                  }]
                };
                n.signedDataValidator = {
                  name: "SignedData",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "SignedData.Version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1,
                    capture: "version"
                  }, {
                    name: "SignedData.DigestAlgorithms",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SET,
                    constructed: !0,
                    captureAsn1: "digestAlgorithms"
                  }, r, {
                    name: "SignedData.Certificates",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 0,
                    optional: !0,
                    captureAsn1: "certificates"
                  }, {
                    name: "SignedData.CertificateRevocationLists",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 1,
                    optional: !0,
                    captureAsn1: "crls"
                  }, {
                    name: "SignedData.SignerInfos",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SET,
                    capture: "signerInfos",
                    optional: !0,
                    value: [s]
                  }]
                }, n.recipientInfoValidator = {
                  name: "RecipientInfo",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "RecipientInfo.version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1,
                    capture: "version"
                  }, {
                    name: "RecipientInfo.issuerAndSerial",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0,
                    value: [{
                      name: "RecipientInfo.issuerAndSerial.issuer",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      captureAsn1: "issuer"
                    }, {
                      name: "RecipientInfo.issuerAndSerial.serialNumber",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.INTEGER,
                      constructed: !1,
                      capture: "serial"
                    }]
                  }, {
                    name: "RecipientInfo.keyEncryptionAlgorithm",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0,
                    value: [{
                      name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OID,
                      constructed: !1,
                      capture: "encAlgorithm"
                    }, {
                      name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
                      tagClass: t.Class.UNIVERSAL,
                      constructed: !1,
                      captureAsn1: "encParameter"
                    }]
                  }, {
                    name: "RecipientInfo.encryptedKey",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.OCTETSTRING,
                    constructed: !1,
                    capture: "encKey"
                  }]
                };
              }
              var r = "pkcs7asn1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pkcs7asn1", ["require", "module", "./asn1", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.mgf = e.mgf || {};
                var t = e.mgf.mgf1 = e.mgf1 = e.mgf1 || {};
                t.create = function(t) {
                  var n = {generate: function(n, r) {
                      var i = new e.util.ByteBuffer,
                          s = Math.ceil(r / t.digestLength);
                      for (var o = 0; o < s; o++) {
                        var u = new e.util.ByteBuffer;
                        u.putInt32(o), t.start(), t.update(n + u.getBytes()), i.putBuffer(t.digest());
                      }
                      return i.truncate(i.length() - r), i.getBytes();
                    }};
                  return n;
                };
              }
              var r = "mgf1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/mgf1", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.mgf = e.mgf || {}, e.mgf.mgf1 = e.mgf1;
              }
              var r = "mgf";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/mgf", ["require", "module", "./mgf1"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.pss = e.pss || {};
                t.create = function(t, n, r) {
                  var i = t.digestLength,
                      s = {};
                  return s.verify = function(s, o, u) {
                    var a,
                        f = u - 1,
                        l = Math.ceil(f / 8);
                    o = o.substr(-l);
                    if (l < i + r + 2)
                      throw {message: "Inconsistent parameters to PSS signature verification."};
                    if (o.charCodeAt(l - 1) !== 188)
                      throw {message: "Encoded message does not end in 0xBC."};
                    var c = l - i - 1,
                        h = o.substr(0, c),
                        p = o.substr(c, i),
                        d = 65280 >> 8 * l - f & 255;
                    if ((h.charCodeAt(0) & d) !== 0)
                      throw {message: "Bits beyond keysize not zero as expected."};
                    var v = n.generate(p, c),
                        m = "";
                    for (a = 0; a < c; a++)
                      m += String.fromCharCode(h.charCodeAt(a) ^ v.charCodeAt(a));
                    m = String.fromCharCode(m.charCodeAt(0) & ~d) + m.substr(1);
                    var g = l - i - r - 2;
                    for (a = 0; a < g; a++)
                      if (m.charCodeAt(a) !== 0)
                        throw {message: "Leftmost octets not zero as expected"};
                    if (m.charCodeAt(g) !== 1)
                      throw {message: "Inconsistent PSS signature, 0x01 marker not found"};
                    var y = m.substr(-r),
                        b = new e.util.ByteBuffer;
                    b.fillWithByte(0, 8), b.putBytes(s), b.putBytes(y), t.start(), t.update(b.getBytes());
                    var w = t.digest().getBytes();
                    return p === w;
                  }, s.encode = function(s, o) {
                    var u,
                        a = o - 1,
                        f = Math.ceil(a / 8),
                        l = s.digest().getBytes();
                    if (f < i + r + 2)
                      throw {message: "Message is too long to encrypt"};
                    var c = e.random.getBytes(r),
                        h = new e.util.ByteBuffer;
                    h.fillWithByte(0, 8), h.putBytes(l), h.putBytes(c), t.start(), t.update(h.getBytes());
                    var p = t.digest().getBytes(),
                        d = new e.util.ByteBuffer;
                    d.fillWithByte(0, f - r - i - 2), d.putByte(1), d.putBytes(c);
                    var v = d.getBytes(),
                        m = f - i - 1,
                        g = n.generate(p, m),
                        y = "";
                    for (u = 0; u < m; u++)
                      y += String.fromCharCode(v.charCodeAt(u) ^ g.charCodeAt(u));
                    var b = 65280 >> 8 * f - a & 255;
                    return y = String.fromCharCode(y.charCodeAt(0) & ~b) + y.substr(1), y + p + String.fromCharCode(188);
                  }, s;
                };
              }
              var r = "pss";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pss", ["require", "module", "./random", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function l(e, t) {
                  typeof t == "string" && (t = {shortName: t});
                  var n = null,
                      r;
                  for (var i = 0; n === null && i < e.attributes.length; ++i)
                    r = e.attributes[i], t.type && t.type === r.type ? n = r : t.name && t.name === r.name ? n = r : t.shortName && t.shortName === r.shortName && (n = r);
                  return n;
                }
                function p(n) {
                  var r = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []),
                      i,
                      s,
                      o = n.attributes;
                  for (var u = 0; u < o.length; ++u) {
                    i = o[u];
                    var a = i.value,
                        f = t.Type.PRINTABLESTRING;
                    "valueTagClass" in i && (f = i.valueTagClass, f === t.Type.UTF8 && (a = e.util.encodeUtf8(a))), s = t.create(t.Class.UNIVERSAL, t.Type.SET, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(i.type).getBytes()), t.create(t.Class.UNIVERSAL, f, !1, a)])]), r.value.push(s);
                  }
                  return r;
                }
                function d(e) {
                  var n = t.create(t.Class.CONTEXT_SPECIFIC, 3, !0, []),
                      r = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []);
                  n.value.push(r);
                  var i,
                      s;
                  for (var o = 0; o < e.length; ++o) {
                    i = e[o], s = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []), r.value.push(s), s.value.push(t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(i.id).getBytes())), i.critical && s.value.push(t.create(t.Class.UNIVERSAL, t.Type.BOOLEAN, !1, String.fromCharCode(255)));
                    var u = i.value;
                    typeof i.value != "string" && (u = t.toDer(u).getBytes()), s.value.push(t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, u));
                  }
                  return n;
                }
                function v(n) {
                  var r = {};
                  for (var i = 0; i < n.length; ++i) {
                    var s = n[i];
                    console.log("attr", s);
                    if (s.shortName && (s.valueTagClass === t.Type.UTF8 || s.valueTagClass === t.Type.PRINTABLESTRING || s.valueTagClass === t.Type.IA5String)) {
                      var o = s.value;
                      s.valueTagClass === t.Type.UTF8 && (o = e.util.encodeUtf8(s.value)), s.shortName in r ? e.util.isArray(r[s.shortName]) ? r[s.shortName].push(o) : r[s.shortName] = [r[s.shortName], o] : r[s.shortName] = o;
                    }
                  }
                  return r;
                }
                function m(e) {
                  var t;
                  for (var r = 0; r < e.length; ++r) {
                    t = e[r], typeof t.name == "undefined" && (t.type && t.type in n.oids ? t.name = n.oids[t.type] : t.shortName && t.shortName in i && (t.name = n.oids[i[t.shortName]]));
                    if (typeof t.type == "undefined") {
                      if (!(t.name && t.name in n.oids))
                        throw {
                          message: "Attribute type not specified.",
                          attribute: t
                        };
                      t.type = n.oids[t.name];
                    }
                    typeof t.shortName == "undefined" && t.name && t.name in i && (t.shortName = i[t.name]);
                    if (typeof t.value == "undefined")
                      throw {
                        message: "Attribute value not specified.",
                        attribute: t
                      };
                  }
                }
                function g(e, n) {
                  switch (e) {
                    case r["RSASSA-PSS"]:
                      var i = [];
                      return n.hash.algorithmOid !== undefined && i.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.hash.algorithmOid).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "")])])), n.mgf.algorithmOid !== undefined && i.push(t.create(t.Class.CONTEXT_SPECIFIC, 1, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.mgf.algorithmOid).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.mgf.hash.algorithmOid).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "")])])])), n.saltLength !== undefined && i.push(t.create(t.Class.CONTEXT_SPECIFIC, 2, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(n.saltLength).getBytes())])), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, i);
                    default:
                      return t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "");
                  }
                }
                function y(n) {
                  var r = t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, []);
                  if (n.attributes.length === 0)
                    return r;
                  var i = n.attributes;
                  for (var s = 0; s < i.length; ++s) {
                    var o = i[s],
                        u = o.value,
                        a = t.Type.UTF8;
                    "valueTagClass" in o && (a = o.valueTagClass), a === t.Type.UTF8 && (u = e.util.encodeUtf8(u));
                    var f = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(o.type).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, [t.create(t.Class.UNIVERSAL, a, !1, u)])]);
                    r.value.push(f);
                  }
                  return r;
                }
                var t = e.asn1,
                    n = e.pki = e.pki || {},
                    r = n.oids,
                    i = {};
                i.CN = r.commonName, i.commonName = "CN", i.C = r.countryName, i.countryName = "C", i.L = r.localityName, i.localityName = "L", i.ST = r.stateOrProvinceName, i.stateOrProvinceName = "ST", i.O = r.organizationName, i.organizationName = "O", i.OU = r.organizationalUnitName, i.organizationalUnitName = "OU", i.E = r.emailAddress, i.emailAddress = "E";
                var s = e.pki.rsa.publicKeyValidator,
                    o = {
                      name: "Certificate",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "Certificate.TBSCertificate",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        captureAsn1: "tbsCertificate",
                        value: [{
                          name: "Certificate.TBSCertificate.version",
                          tagClass: t.Class.CONTEXT_SPECIFIC,
                          type: 0,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.version.integer",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.INTEGER,
                            constructed: !1,
                            capture: "certVersion"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.serialNumber",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.INTEGER,
                          constructed: !1,
                          capture: "certSerialNumber"
                        }, {
                          name: "Certificate.TBSCertificate.signature",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.signature.algorithm",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OID,
                            constructed: !1,
                            capture: "certinfoSignatureOid"
                          }, {
                            name: "Certificate.TBSCertificate.signature.parameters",
                            tagClass: t.Class.UNIVERSAL,
                            optional: !0,
                            captureAsn1: "certinfoSignatureParams"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.issuer",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          captureAsn1: "certIssuer"
                        }, {
                          name: "Certificate.TBSCertificate.validity",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.UTCTIME,
                            constructed: !1,
                            optional: !0,
                            capture: "certValidity1UTCTime"
                          }, {
                            name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.GENERALIZEDTIME,
                            constructed: !1,
                            optional: !0,
                            capture: "certValidity2GeneralizedTime"
                          }, {
                            name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.UTCTIME,
                            constructed: !1,
                            optional: !0,
                            capture: "certValidity3UTCTime"
                          }, {
                            name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.GENERALIZEDTIME,
                            constructed: !1,
                            optional: !0,
                            capture: "certValidity4GeneralizedTime"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.subject",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          captureAsn1: "certSubject"
                        }, s, {
                          name: "Certificate.TBSCertificate.issuerUniqueID",
                          tagClass: t.Class.CONTEXT_SPECIFIC,
                          type: 1,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.issuerUniqueID.id",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.BITSTRING,
                            constructed: !1,
                            capture: "certIssuerUniqueId"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.subjectUniqueID",
                          tagClass: t.Class.CONTEXT_SPECIFIC,
                          type: 2,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.subjectUniqueID.id",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.BITSTRING,
                            constructed: !1,
                            capture: "certSubjectUniqueId"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.extensions",
                          tagClass: t.Class.CONTEXT_SPECIFIC,
                          type: 3,
                          constructed: !0,
                          captureAsn1: "certExtensions",
                          optional: !0
                        }]
                      }, {
                        name: "Certificate.signatureAlgorithm",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "Certificate.signatureAlgorithm.algorithm",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.OID,
                          constructed: !1,
                          capture: "certSignatureOid"
                        }, {
                          name: "Certificate.TBSCertificate.signature.parameters",
                          tagClass: t.Class.UNIVERSAL,
                          optional: !0,
                          captureAsn1: "certSignatureParams"
                        }]
                      }, {
                        name: "Certificate.signatureValue",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.BITSTRING,
                        constructed: !1,
                        capture: "certSignature"
                      }]
                    },
                    u = {
                      name: "rsapss",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "rsapss.hashAlgorithm",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 0,
                        constructed: !0,
                        value: [{
                          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.SEQUENCE,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OID,
                            constructed: !1,
                            capture: "hashOid"
                          }]
                        }]
                      }, {
                        name: "rsapss.maskGenAlgorithm",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 1,
                        constructed: !0,
                        value: [{
                          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.SEQUENCE,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OID,
                            constructed: !1,
                            capture: "maskGenOid"
                          }, {
                            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                              tagClass: t.Class.UNIVERSAL,
                              type: t.Type.OID,
                              constructed: !1,
                              capture: "maskGenHashOid"
                            }]
                          }]
                        }]
                      }, {
                        name: "rsapss.saltLength",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 2,
                        optional: !0,
                        value: [{
                          name: "rsapss.saltLength.saltLength",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.INTEGER,
                          constructed: !1,
                          capture: "saltLength"
                        }]
                      }, {
                        name: "rsapss.trailerField",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 3,
                        optional: !0,
                        value: [{
                          name: "rsapss.trailer.trailer",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.INTEGER,
                          constructed: !1,
                          capture: "trailer"
                        }]
                      }]
                    },
                    a = {
                      name: "CertificationRequestInfo",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      captureAsn1: "certificationRequestInfo",
                      value: [{
                        name: "CertificationRequestInfo.integer",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.INTEGER,
                        constructed: !1,
                        capture: "certificationRequestInfoVersion"
                      }, {
                        name: "CertificationRequestInfo.subject",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        captureAsn1: "certificationRequestInfoSubject"
                      }, s, {
                        name: "CertificationRequestInfo.attributes",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 0,
                        constructed: !0,
                        optional: !0,
                        capture: "certificationRequestInfoAttributes",
                        value: [{
                          name: "CertificationRequestInfo.attributes",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "CertificationRequestInfo.attributes.type",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OID,
                            constructed: !1
                          }, {
                            name: "CertificationRequestInfo.attributes.value",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.SET,
                            constructed: !0
                          }]
                        }]
                      }]
                    },
                    f = {
                      name: "CertificationRequest",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      captureAsn1: "csr",
                      value: [a, {
                        name: "CertificationRequest.signatureAlgorithm",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "CertificationRequest.signatureAlgorithm.algorithm",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.OID,
                          constructed: !1,
                          capture: "csrSignatureOid"
                        }, {
                          name: "CertificationRequest.signatureAlgorithm.parameters",
                          tagClass: t.Class.UNIVERSAL,
                          optional: !0,
                          captureAsn1: "csrSignatureParams"
                        }]
                      }, {
                        name: "CertificationRequest.signature",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.BITSTRING,
                        constructed: !1,
                        capture: "csrSignature"
                      }]
                    };
                n.RDNAttributesAsArray = function(e, n) {
                  var s = [],
                      o,
                      u,
                      a;
                  for (var f = 0; f < e.value.length; ++f) {
                    o = e.value[f];
                    for (var l = 0; l < o.value.length; ++l)
                      a = {}, u = o.value[l], a.type = t.derToOid(u.value[0].value), a.value = u.value[1].value, a.valueTagClass = u.value[1].type, a.type in r && (a.name = r[a.type], a.name in i && (a.shortName = i[a.name])), n && (n.update(a.type), n.update(a.value)), s.push(a);
                  }
                  return s;
                }, n.CRIAttributesAsArray = function(e) {
                  var n = [];
                  for (var s = 0; s < e.length; ++s) {
                    var o = e[s],
                        u = t.derToOid(o.value[0].value),
                        a = o.value[1].value;
                    for (var f = 0; f < a.length; ++f) {
                      var l = {};
                      l.type = u, l.value = a[f].value, l.valueTagClass = a[f].type, l.type in r && (l.name = r[l.type], l.name in i && (l.shortName = i[l.name])), n.push(l);
                    }
                  }
                  return n;
                };
                var c = function(n) {
                  var i = [],
                      s,
                      o,
                      u;
                  for (var a = 0; a < n.value.length; ++a) {
                    u = n.value[a];
                    for (var f = 0; f < u.value.length; ++f) {
                      o = u.value[f], s = {}, s.id = t.derToOid(o.value[0].value), s.critical = !1, o.value[1].type === t.Type.BOOLEAN ? (s.critical = o.value[1].value.charCodeAt(0) !== 0, s.value = o.value[2].value) : s.value = o.value[1].value;
                      if (s.id in r) {
                        s.name = r[s.id];
                        if (s.name === "keyUsage") {
                          var l = t.fromDer(s.value),
                              c = 0,
                              h = 0;
                          l.value.length > 1 && (c = l.value.charCodeAt(1), h = l.value.length > 2 ? l.value.charCodeAt(2) : 0), s.digitalSignature = (c & 128) === 128, s.nonRepudiation = (c & 64) === 64, s.keyEncipherment = (c & 32) === 32, s.dataEncipherment = (c & 16) === 16, s.keyAgreement = (c & 8) === 8, s.keyCertSign = (c & 4) === 4, s.cRLSign = (c & 2) === 2, s.encipherOnly = (c & 1) === 1, s.decipherOnly = (h & 128) === 128;
                        } else if (s.name === "basicConstraints") {
                          var l = t.fromDer(s.value);
                          l.value.length > 0 && l.value[0].type === t.Type.BOOLEAN ? s.cA = l.value[0].value.charCodeAt(0) !== 0 : s.cA = !1;
                          var p = null;
                          l.value.length > 0 && l.value[0].type === t.Type.INTEGER ? p = l.value[0].value : l.value.length > 1 && (p = l.value[1].value), p !== null && (s.pathLenConstraint = t.derToInteger(p));
                        } else if (s.name === "extKeyUsage") {
                          var l = t.fromDer(s.value);
                          for (var d = 0; d < l.value.length; ++d) {
                            var v = t.derToOid(l.value[d].value);
                            v in r ? s[r[v]] = !0 : s[v] = !0;
                          }
                        } else if (s.name === "nsCertType") {
                          var l = t.fromDer(s.value),
                              c = 0;
                          l.value.length > 1 && (c = l.value.charCodeAt(1)), s.client = (c & 128) === 128, s.server = (c & 64) === 64, s.email = (c & 32) === 32, s.objsign = (c & 16) === 16, s.reserved = (c & 8) === 8, s.sslCA = (c & 4) === 4, s.emailCA = (c & 2) === 2, s.objCA = (c & 1) === 1;
                        } else if (s.name === "subjectAltName" || s.name === "issuerAltName") {
                          s.altNames = [];
                          var m,
                              l = t.fromDer(s.value);
                          for (var g = 0; g < l.value.length; ++g) {
                            m = l.value[g];
                            var y = {
                              type: m.type,
                              value: m.value
                            };
                            s.altNames.push(y);
                            switch (m.type) {
                              case 1:
                              case 2:
                              case 6:
                                break;
                              case 7:
                                y.ip = e.util.bytesToIP(m.value);
                                break;
                              case 8:
                                y.oid = t.derToOid(m.value);
                                break;
                              default:
                            }
                          }
                        } else if (s.name === "subjectKeyIdentifier") {
                          var l = t.fromDer(s.value);
                          s.subjectKeyIdentifier = e.util.bytesToHex(l.value);
                        }
                      }
                      i.push(s);
                    }
                  }
                  return i;
                },
                    h = function(e, n, i) {
                      var s = {};
                      if (e !== r["RSASSA-PSS"])
                        return s;
                      i && (s = {
                        hash: {algorithmOid: r.sha1},
                        mgf: {
                          algorithmOid: r.mgf1,
                          hash: {algorithmOid: r.sha1}
                        },
                        saltLength: 20
                      });
                      var o = {},
                          a = [];
                      if (!t.validate(n, u, o, a))
                        throw {
                          message: "Cannot read RSASSA-PSS parameter block.",
                          errors: a
                        };
                      return o.hashOid !== undefined && (s.hash = s.hash || {}, s.hash.algorithmOid = t.derToOid(o.hashOid)), o.maskGenOid !== undefined && (s.mgf = s.mgf || {}, s.mgf.algorithmOid = t.derToOid(o.maskGenOid), s.mgf.hash = s.mgf.hash || {}, s.mgf.hash.algorithmOid = t.derToOid(o.maskGenHashOid)), o.saltLength !== undefined && (s.saltLength = o.saltLength.charCodeAt(0)), s;
                    };
                n.certificateFromPem = function(r, i, s) {
                  var o = e.pem.decode(r)[0];
                  if (o.type !== "CERTIFICATE" && o.type !== "X509 CERTIFICATE" && o.type !== "TRUSTED CERTIFICATE")
                    throw {
                      message: 'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',
                      headerType: o.type
                    };
                  if (o.procType && o.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert certificate from PEM; PEM is encrypted."};
                  var u = t.fromDer(o.body, s);
                  return n.certificateFromAsn1(u, i);
                }, n.certificateToPem = function(r, i) {
                  var s = {
                    type: "CERTIFICATE",
                    body: t.toDer(n.certificateToAsn1(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                }, n.publicKeyFromPem = function(r) {
                  var i = e.pem.decode(r)[0];
                  if (i.type !== "PUBLIC KEY" && i.type !== "RSA PUBLIC KEY")
                    throw {
                      message: 'Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".',
                      headerType: i.type
                    };
                  if (i.procType && i.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert public key from PEM; PEM is encrypted."};
                  var s = t.fromDer(i.body);
                  return n.publicKeyFromAsn1(s);
                }, n.publicKeyToPem = function(r, i) {
                  var s = {
                    type: "PUBLIC KEY",
                    body: t.toDer(n.publicKeyToAsn1(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                }, n.publicKeyToRSAPublicKeyPem = function(r, i) {
                  var s = {
                    type: "RSA PUBLIC KEY",
                    body: t.toDer(n.publicKeyToRSAPublicKey(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                }, n.certificationRequestFromPem = function(r, i, s) {
                  var o = e.pem.decode(r)[0];
                  if (o.type !== "CERTIFICATE REQUEST")
                    throw {
                      message: 'Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".',
                      headerType: o.type
                    };
                  if (o.procType && o.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert certification request from PEM; PEM is encrypted."};
                  var u = t.fromDer(o.body, s);
                  return n.certificationRequestFromAsn1(u, i);
                }, n.certificationRequestToPem = function(r, i) {
                  var s = {
                    type: "CERTIFICATE REQUEST",
                    body: t.toDer(n.certificationRequestToAsn1(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                }, n.createCertificate = function() {
                  var i = {};
                  return i.version = 2, i.serialNumber = "00", i.signatureOid = null, i.signature = null, i.siginfo = {}, i.siginfo.algorithmOid = null, i.validity = {}, i.validity.notBefore = new Date, i.validity.notAfter = new Date, i.issuer = {}, i.issuer.getField = function(e) {
                    return l(i.issuer, e);
                  }, i.issuer.addField = function(e) {
                    m([e]), i.issuer.attributes.push(e);
                  }, i.issuer.attributes = [], i.issuer.hash = null, i.subject = {}, i.subject.getField = function(e) {
                    return l(i.subject, e);
                  }, i.subject.addField = function(e) {
                    m([e]), i.subject.attributes.push(e);
                  }, i.subject.attributes = [], i.subject.hash = null, i.extensions = [], i.publicKey = null, i.md = null, i.setSubject = function(e, t) {
                    m(e), i.subject.attributes = e, delete i.subject.uniqueId, t && (i.subject.uniqueId = t), i.subject.hash = null;
                  }, i.setIssuer = function(e, t) {
                    m(e), i.issuer.attributes = e, delete i.issuer.uniqueId, t && (i.issuer.uniqueId = t), i.issuer.hash = null;
                  }, i.setExtensions = function(s) {
                    var o;
                    for (var u = 0; u < s.length; ++u) {
                      o = s[u], typeof o.name == "undefined" && o.id && o.id in n.oids && (o.name = n.oids[o.id]);
                      if (typeof o.id == "undefined") {
                        if (!(o.name && o.name in n.oids))
                          throw {
                            message: "Extension ID not specified.",
                            extension: o
                          };
                        o.id = n.oids[o.name];
                      }
                      if (typeof o.value == "undefined") {
                        if (o.name === "keyUsage") {
                          var a = 0,
                              f = 0,
                              l = 0;
                          o.digitalSignature && (f |= 128, a = 7), o.nonRepudiation && (f |= 64, a = 6), o.keyEncipherment && (f |= 32, a = 5), o.dataEncipherment && (f |= 16, a = 4), o.keyAgreement && (f |= 8, a = 3), o.keyCertSign && (f |= 4, a = 2), o.cRLSign && (f |= 2, a = 1), o.encipherOnly && (f |= 1, a = 0), o.decipherOnly && (l |= 128, a = 7);
                          var c = String.fromCharCode(a);
                          l !== 0 ? c += String.fromCharCode(f) + String.fromCharCode(l) : f !== 0 && (c += String.fromCharCode(f)), o.value = t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, c);
                        } else if (o.name === "basicConstraints")
                          o.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []), o.cA && o.value.value.push(t.create(t.Class.UNIVERSAL, t.Type.BOOLEAN, !1, String.fromCharCode(255))), "pathLenConstraint" in o && o.value.value.push(t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(o.pathLenConstraint).getBytes()));
                        else if (o.name === "extKeyUsage") {
                          o.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []);
                          var h = o.value.value;
                          for (var p in o) {
                            if (o[p] !== !0)
                              continue;
                            p in r ? h.push(t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(r[p]).getBytes())) : p.indexOf(".") !== -1 && h.push(t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(p).getBytes()));
                          }
                        } else if (o.name === "nsCertType") {
                          var a = 0,
                              f = 0;
                          o.client && (f |= 128, a = 7), o.server && (f |= 64, a = 6), o.email && (f |= 32, a = 5), o.objsign && (f |= 16, a = 4), o.reserved && (f |= 8, a = 3), o.sslCA && (f |= 4, a = 2), o.emailCA && (f |= 2, a = 1), o.objCA && (f |= 1, a = 0);
                          var c = String.fromCharCode(a);
                          f !== 0 && (c += String.fromCharCode(f)), o.value = t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, c);
                        } else if (o.name === "subjectAltName" || o.name === "issuerAltName") {
                          o.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []);
                          var d;
                          for (var v = 0; v < o.altNames.length; ++v) {
                            d = o.altNames[v];
                            var c = d.value;
                            if (d.type === 7 && d.ip) {
                              c = e.util.bytesFromIP(d.ip);
                              if (c === null)
                                throw {
                                  message: 'Extension "ip" value is not a valid IPv4 or IPv6 address.',
                                  extension: o
                                };
                            } else
                              d.type === 8 && (d.oid ? c = t.oidToDer(t.oidToDer(d.oid)) : c = t.oidToDer(c));
                            o.value.value.push(t.create(t.Class.CONTEXT_SPECIFIC, d.type, !1, c));
                          }
                        } else if (o.name === "subjectKeyIdentifier") {
                          var m = i.generateSubjectKeyIdentifier();
                          o.subjectKeyIdentifier = m.toHex(), o.value = t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, m.getBytes());
                        }
                        if (typeof o.value == "undefined")
                          throw {
                            message: "Extension value not specified.",
                            extension: o
                          };
                      }
                    }
                    i.extensions = s;
                  }, i.getExtension = function(e) {
                    typeof e == "string" && (e = {name: e});
                    var t = null,
                        n;
                    for (var r = 0; t === null && r < i.extensions.length; ++r)
                      n = i.extensions[r], e.id && n.id === e.id ? t = n : e.name && n.name === e.name && (t = n);
                    return t;
                  }, i.sign = function(s, o) {
                    i.md = o || e.md.sha1.create();
                    var u = r[i.md.algorithm + "WithRSAEncryption"];
                    if (!u)
                      throw {
                        message: "Could not compute certificate digest. Unknown message digest algorithm OID.",
                        algorithm: i.md.algorithm
                      };
                    i.signatureOid = i.siginfo.algorithmOid = u, i.tbsCertificate = n.getTBSCertificate(i);
                    var a = t.toDer(i.tbsCertificate);
                    i.md.update(a.getBytes()), i.signature = s.sign(i.md);
                  }, i.verify = function(s) {
                    var o = !1;
                    if (!i.issued(s)) {
                      var u = s.issuer,
                          a = i.subject;
                      throw {
                        message: "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.",
                        expectedIssuer: u.attributes,
                        actualIssuer: a.attributes
                      };
                    }
                    var f = s.md;
                    if (f === null) {
                      if (s.signatureOid in r) {
                        var l = r[s.signatureOid];
                        switch (l) {
                          case "sha1WithRSAEncryption":
                            f = e.md.sha1.create();
                            break;
                          case "md5WithRSAEncryption":
                            f = e.md.md5.create();
                            break;
                          case "sha256WithRSAEncryption":
                            f = e.md.sha256.create();
                            break;
                          case "RSASSA-PSS":
                            f = e.md.sha256.create();
                        }
                      }
                      if (f === null)
                        throw {
                          message: "Could not compute certificate digest. Unknown signature OID.",
                          signatureOid: s.signatureOid
                        };
                      var c = s.tbsCertificate || n.getTBSCertificate(s),
                          h = t.toDer(c);
                      f.update(h.getBytes());
                    }
                    if (f !== null) {
                      var p = undefined;
                      switch (s.signatureOid) {
                        case r.sha1WithRSAEncryption:
                          p = undefined;
                          break;
                        case r["RSASSA-PSS"]:
                          var d,
                              v;
                          d = r[s.signatureParameters.mgf.hash.algorithmOid];
                          if (d === undefined || e.md[d] === undefined)
                            throw {
                              message: "Unsupported MGF hash function.",
                              oid: s.signatureParameters.mgf.hash.algorithmOid,
                              name: d
                            };
                          v = r[s.signatureParameters.mgf.algorithmOid];
                          if (v === undefined || e.mgf[v] === undefined)
                            throw {
                              message: "Unsupported MGF function.",
                              oid: s.signatureParameters.mgf.algorithmOid,
                              name: v
                            };
                          v = e.mgf[v].create(e.md[d].create()), d = r[s.signatureParameters.hash.algorithmOid];
                          if (d === undefined || e.md[d] === undefined)
                            throw {
                              message: "Unsupported RSASSA-PSS hash function.",
                              oid: s.signatureParameters.hash.algorithmOid,
                              name: d
                            };
                          p = e.pss.create(e.md[d].create(), v, s.signatureParameters.saltLength);
                      }
                      o = i.publicKey.verify(f.digest().getBytes(), s.signature, p);
                    }
                    return o;
                  }, i.isIssuer = function(e) {
                    var t = !1,
                        n = i.issuer,
                        r = e.subject;
                    if (n.hash && r.hash)
                      t = n.hash === r.hash;
                    else if (n.attributes.length === r.attributes.length) {
                      t = !0;
                      var s,
                          o;
                      for (var u = 0; t && u < n.attributes.length; ++u) {
                        s = n.attributes[u], o = r.attributes[u];
                        if (s.type !== o.type || s.value !== o.value)
                          t = !1;
                      }
                    }
                    return t;
                  }, i.issued = function(e) {
                    return e.isIssuer(i);
                  }, i.generateSubjectKeyIdentifier = function() {
                    var r = t.toDer(n.publicKeyToRSAPublicKey(i.publicKey)),
                        s = e.md.sha1.create();
                    return s.update(r.getBytes()), s.digest();
                  }, i.verifySubjectKeyIdentifier = function() {
                    var t = r.subjectKeyIdentifier;
                    for (var n = 0; n < i.extensions.length; ++n) {
                      var s = i.extensions[n];
                      if (s.id === t) {
                        var o = i.generateSubjectKeyIdentifier().getBytes();
                        return e.util.hexToBytes(s.subjectKeyIdentifier) === o;
                      }
                    }
                    return !1;
                  }, i;
                }, n.certificateFromAsn1 = function(i, s) {
                  var u = {},
                      a = [];
                  if (!t.validate(i, o, u, a))
                    throw {
                      message: "Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.",
                      errors: a
                    };
                  if (typeof u.certSignature != "string") {
                    var f = "\0";
                    for (var p = 0; p < u.certSignature.length; ++p)
                      f += t.toDer(u.certSignature[p]).getBytes();
                    u.certSignature = f;
                  }
                  var d = t.derToOid(u.publicKeyOid);
                  if (d !== n.oids.rsaEncryption)
                    throw {message: "Cannot read public key. OID is not RSA."};
                  var v = n.createCertificate();
                  v.version = u.certVersion ? u.certVersion.charCodeAt(0) : 0;
                  var g = e.util.createBuffer(u.certSerialNumber);
                  v.serialNumber = g.toHex(), v.signatureOid = e.asn1.derToOid(u.certSignatureOid), v.signatureParameters = h(v.signatureOid, u.certSignatureParams, !0), v.siginfo.algorithmOid = e.asn1.derToOid(u.certinfoSignatureOid), v.siginfo.parameters = h(v.siginfo.algorithmOid, u.certinfoSignatureParams, !1);
                  var y = e.util.createBuffer(u.certSignature);
                  ++y.read, v.signature = y.getBytes();
                  var b = [];
                  u.certValidity1UTCTime !== undefined && b.push(t.utcTimeToDate(u.certValidity1UTCTime)), u.certValidity2GeneralizedTime !== undefined && b.push(t.generalizedTimeToDate(u.certValidity2GeneralizedTime)), u.certValidity3UTCTime !== undefined && b.push(t.utcTimeToDate(u.certValidity3UTCTime)), u.certValidity4GeneralizedTime !== undefined && b.push(t.generalizedTimeToDate(u.certValidity4GeneralizedTime));
                  if (b.length > 2)
                    throw {message: "Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate."};
                  if (b.length < 2)
                    throw {message: "Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime."};
                  v.validity.notBefore = b[0], v.validity.notAfter = b[1], v.tbsCertificate = u.tbsCertificate;
                  if (s) {
                    v.md = null;
                    if (v.signatureOid in r) {
                      var d = r[v.signatureOid];
                      switch (d) {
                        case "sha1WithRSAEncryption":
                          v.md = e.md.sha1.create();
                          break;
                        case "md5WithRSAEncryption":
                          v.md = e.md.md5.create();
                          break;
                        case "sha256WithRSAEncryption":
                          v.md = e.md.sha256.create();
                          break;
                        case "RSASSA-PSS":
                          v.md = e.md.sha256.create();
                      }
                    }
                    if (v.md === null)
                      throw {
                        message: "Could not compute certificate digest. Unknown signature OID.",
                        signatureOid: v.signatureOid
                      };
                    var w = t.toDer(v.tbsCertificate);
                    v.md.update(w.getBytes());
                  }
                  var E = e.md.sha1.create();
                  v.issuer.getField = function(e) {
                    return l(v.issuer, e);
                  }, v.issuer.addField = function(e) {
                    m([e]), v.issuer.attributes.push(e);
                  }, v.issuer.attributes = n.RDNAttributesAsArray(u.certIssuer, E), u.certIssuerUniqueId && (v.issuer.uniqueId = u.certIssuerUniqueId), v.issuer.hash = E.digest().toHex();
                  var S = e.md.sha1.create();
                  return v.subject.getField = function(e) {
                    return l(v.subject, e);
                  }, v.subject.addField = function(e) {
                    m([e]), v.subject.attributes.push(e);
                  }, v.subject.attributes = n.RDNAttributesAsArray(u.certSubject, S), u.certSubjectUniqueId && (v.subject.uniqueId = u.certSubjectUniqueId), v.subject.hash = S.digest().toHex(), u.certExtensions ? v.extensions = c(u.certExtensions) : v.extensions = [], v.publicKey = n.publicKeyFromAsn1(u.subjectPublicKeyInfo), v;
                }, n.certificationRequestFromAsn1 = function(i, s) {
                  var o = {},
                      u = [];
                  if (!t.validate(i, f, o, u))
                    throw {
                      message: "Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.",
                      errors: u
                    };
                  if (typeof o.csrSignature != "string") {
                    var a = "\0";
                    for (var c = 0; c < o.csrSignature.length; ++c)
                      a += t.toDer(o.csrSignature[c]).getBytes();
                    o.csrSignature = a;
                  }
                  var p = t.derToOid(o.publicKeyOid);
                  if (p !== n.oids.rsaEncryption)
                    throw {message: "Cannot read public key. OID is not RSA."};
                  var d = n.createCertificationRequest();
                  d.version = o.csrVersion ? o.csrVersion.charCodeAt(0) : 0, d.signatureOid = e.asn1.derToOid(o.csrSignatureOid), d.signatureParameters = h(d.signatureOid, o.csrSignatureParams, !0), d.siginfo.algorithmOid = e.asn1.derToOid(o.csrSignatureOid), d.siginfo.parameters = h(d.siginfo.algorithmOid, o.csrSignatureParams, !1);
                  var v = e.util.createBuffer(o.csrSignature);
                  ++v.read, d.signature = v.getBytes(), d.certificationRequestInfo = o.certificationRequestInfo;
                  if (s) {
                    d.md = null;
                    if (d.signatureOid in r) {
                      var p = r[d.signatureOid];
                      switch (p) {
                        case "sha1WithRSAEncryption":
                          d.md = e.md.sha1.create();
                          break;
                        case "md5WithRSAEncryption":
                          d.md = e.md.md5.create();
                          break;
                        case "sha256WithRSAEncryption":
                          d.md = e.md.sha256.create();
                          break;
                        case "RSASSA-PSS":
                          d.md = e.md.sha256.create();
                      }
                    }
                    if (d.md === null)
                      throw {
                        message: "Could not compute certification request digest. Unknown signature OID.",
                        signatureOid: d.signatureOid
                      };
                    var g = t.toDer(d.certificationRequestInfo);
                    d.md.update(g.getBytes());
                  }
                  var y = e.md.sha1.create();
                  return d.subject.getField = function(e) {
                    return l(d.subject, e);
                  }, d.subject.addField = function(e) {
                    m([e]), d.subject.attributes.push(e);
                  }, d.subject.attributes = n.RDNAttributesAsArray(o.certificationRequestInfoSubject, y), d.subject.hash = y.digest().toHex(), d.publicKey = n.publicKeyFromAsn1(o.subjectPublicKeyInfo), d.getAttribute = function(e) {
                    return l(d.attributes, e);
                  }, d.addAttribute = function(e) {
                    m([e]), d.attributes.push(e);
                  }, d.attributes = n.CRIAttributesAsArray(o.certificationRequestInfoAttributes), d;
                }, n.createCertificationRequest = function() {
                  var i = {};
                  return i.version = 0, i.signatureOid = null, i.signature = null, i.siginfo = {}, i.siginfo.algorithmOid = null, i.subject = {}, i.subject.getField = function(e) {
                    return l(i.subject, e);
                  }, i.subject.addField = function(e) {
                    m([e]), i.subject.attributes.push(e);
                  }, i.subject.attributes = [], i.subject.hash = null, i.publicKey = null, i.attributes = [], i.getAttribute = function(e) {
                    return l(i.attributes, e);
                  }, i.addAttribute = function(e) {
                    m([e]), i.attributes.push(e);
                  }, i.md = null, i.setSubject = function(e) {
                    m(e), i.subject.attributes = e, i.subject.hash = null;
                  }, i.setAttributes = function(e) {
                    m(e), i.attributes = e;
                  }, i.sign = function(s, o) {
                    i.md = o || e.md.sha1.create();
                    var u = r[i.md.algorithm + "WithRSAEncryption"];
                    if (!u)
                      throw {
                        message: "Could not compute certification request digest. Unknown message digest algorithm OID.",
                        algorithm: i.md.algorithm
                      };
                    i.signatureOid = i.siginfo.algorithmOid = u, i.certificationRequestInfo = n.getCertificationRequestInfo(i);
                    var a = t.toDer(i.certificationRequestInfo);
                    i.md.update(a.getBytes()), i.signature = s.sign(i.md);
                  }, i.verify = function() {
                    var s = !1,
                        o = i.md;
                    if (o === null) {
                      if (i.signatureOid in r) {
                        var u = r[i.signatureOid];
                        switch (u) {
                          case "sha1WithRSAEncryption":
                            o = e.md.sha1.create();
                            break;
                          case "md5WithRSAEncryption":
                            o = e.md.md5.create();
                            break;
                          case "sha256WithRSAEncryption":
                            o = e.md.sha256.create();
                            break;
                          case "RSASSA-PSS":
                            o = e.md.sha256.create();
                        }
                      }
                      if (o === null)
                        throw {
                          message: "Could not compute certification request digest. Unknown signature OID.",
                          signatureOid: i.signatureOid
                        };
                      var a = i.certificationRequestInfo || n.getCertificationRequestInfo(i),
                          f = t.toDer(a);
                      o.update(f.getBytes());
                    }
                    if (o !== null) {
                      var l;
                      switch (i.signatureOid) {
                        case r.sha1WithRSAEncryption:
                          break;
                        case r["RSASSA-PSS"]:
                          var c,
                              h;
                          c = r[i.signatureParameters.mgf.hash.algorithmOid];
                          if (c === undefined || e.md[c] === undefined)
                            throw {
                              message: "Unsupported MGF hash function.",
                              oid: i.signatureParameters.mgf.hash.algorithmOid,
                              name: c
                            };
                          h = r[i.signatureParameters.mgf.algorithmOid];
                          if (h === undefined || e.mgf[h] === undefined)
                            throw {
                              message: "Unsupported MGF function.",
                              oid: i.signatureParameters.mgf.algorithmOid,
                              name: h
                            };
                          h = e.mgf[h].create(e.md[c].create()), c = r[i.signatureParameters.hash.algorithmOid];
                          if (c === undefined || e.md[c] === undefined)
                            throw {
                              message: "Unsupported RSASSA-PSS hash function.",
                              oid: i.signatureParameters.hash.algorithmOid,
                              name: c
                            };
                          l = e.pss.create(e.md[c].create(), h, i.signatureParameters.saltLength);
                      }
                      s = i.publicKey.verify(o.digest().getBytes(), i.signature, l);
                    }
                    return s;
                  }, i;
                }, n.getTBSCertificate = function(r) {
                  var i = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(r.version).getBytes())]), t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, e.util.hexToBytes(r.serialNumber)), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(r.siginfo.algorithmOid).getBytes()), g(r.siginfo.algorithmOid, r.siginfo.parameters)]), p(r.issuer), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.UTCTIME, !1, t.dateToUtcTime(r.validity.notBefore)), t.create(t.Class.UNIVERSAL, t.Type.UTCTIME, !1, t.dateToUtcTime(r.validity.notAfter))]), p(r.subject), n.publicKeyToAsn1(r.publicKey)]);
                  return r.issuer.uniqueId && i.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 1, !0, [t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, String.fromCharCode(0) + r.issuer.uniqueId)])), r.subject.uniqueId && i.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 2, !0, [t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, String.fromCharCode(0) + r.subject.uniqueId)])), r.extensions.length > 0 && i.value.push(d(r.extensions)), i;
                }, n.getCertificationRequestInfo = function(e) {
                  var r = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(e.version).getBytes()), p(e.subject), n.publicKeyToAsn1(e.publicKey), y(e)]);
                  return r;
                }, n.distinguishedNameToAsn1 = function(e) {
                  return p(e);
                }, n.certificateToAsn1 = function(e) {
                  var r = e.tbsCertificate || n.getTBSCertificate(e);
                  return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [r, t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(e.signatureOid).getBytes()), g(e.signatureOid, e.signatureParameters)]), t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, String.fromCharCode(0) + e.signature)]);
                }, n.certificationRequestToAsn1 = function(e) {
                  var r = e.certificationRequestInfo || n.getCertificationRequestInfo(e);
                  return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [r, t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(e.signatureOid).getBytes()), g(e.signatureOid, e.signatureParameters)]), t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, String.fromCharCode(0) + e.signature)]);
                }, n.createCaStore = function(t) {
                  var r = {certs: {}};
                  r.getIssuer = function(t) {
                    var i = null;
                    if (!t.issuer.hash) {
                      var s = e.md.sha1.create();
                      t.issuer.attributes = n.RDNAttributesAsArray(p(t.issuer), s), t.issuer.hash = s.digest().toHex();
                    }
                    if (t.issuer.hash in r.certs) {
                      i = r.certs[t.issuer.hash];
                      if (e.util.isArray(i))
                        throw {message: "Resolving multiple issuer matches not implemented yet."};
                    }
                    return i;
                  }, r.addCertificate = function(t) {
                    typeof t == "string" && (t = e.pki.certificateFromPem(t));
                    if (!t.subject.hash) {
                      var i = e.md.sha1.create();
                      t.subject.attributes = n.RDNAttributesAsArray(p(t.subject), i), t.subject.hash = i.digest().toHex();
                    }
                    if (t.subject.hash in r.certs) {
                      var s = r.certs[t.subject.hash];
                      e.util.isArray(s) || (s = [s]), s.push(t);
                    } else
                      r.certs[t.subject.hash] = t;
                  };
                  if (t)
                    for (var i = 0; i < t.length; ++i) {
                      var s = t[i];
                      r.addCertificate(s);
                    }
                  return r;
                }, n.certificateError = {
                  bad_certificate: "forge.pki.BadCertificate",
                  unsupported_certificate: "forge.pki.UnsupportedCertificate",
                  certificate_revoked: "forge.pki.CertificateRevoked",
                  certificate_expired: "forge.pki.CertificateExpired",
                  certificate_unknown: "forge.pki.CertificateUnknown",
                  unknown_ca: "forge.pki.UnknownCertificateAuthority"
                }, n.verifyCertificateChain = function(t, r, i) {
                  r = r.slice(0);
                  var s = r.slice(0),
                      o = new Date,
                      u = !0,
                      a = null,
                      f = 0,
                      l = null;
                  do {
                    var c = r.shift();
                    if (o < c.validity.notBefore || o > c.validity.notAfter)
                      a = {
                        message: "Certificate is not valid yet or has expired.",
                        error: n.certificateError.certificate_expired,
                        notBefore: c.validity.notBefore,
                        notAfter: c.validity.notAfter,
                        now: o
                      };
                    else {
                      var h = !1;
                      if (r.length > 0) {
                        l = r[0];
                        try {
                          h = l.verify(c);
                        } catch (p) {}
                      } else {
                        var d = t.getIssuer(c);
                        if (d === null)
                          a = {
                            message: "Certificate is not trusted.",
                            error: n.certificateError.unknown_ca
                          };
                        else {
                          e.util.isArray(d) || (d = [d]);
                          while (!h && d.length > 0) {
                            l = d.shift();
                            try {
                              h = l.verify(c);
                            } catch (p) {}
                          }
                        }
                      }
                      a === null && !h && (a = {
                        message: "Certificate signature is invalid.",
                        error: n.certificateError.bad_certificate
                      });
                    }
                    a === null && !c.isIssuer(l) && (a = {
                      message: "Certificate issuer is invalid.",
                      error: n.certificateError.bad_certificate
                    });
                    if (a === null) {
                      var v = {
                        keyUsage: !0,
                        basicConstraints: !0
                      };
                      for (var m = 0; a === null && m < c.extensions.length; ++m) {
                        var g = c.extensions[m];
                        g.critical && !(g.name in v) && (a = {
                          message: "Certificate has an unsupported critical extension.",
                          error: n.certificateError.unsupported_certificate
                        });
                      }
                    }
                    if (!u || r.length === 0 && !l) {
                      var y = c.getExtension("basicConstraints"),
                          b = c.getExtension("keyUsage");
                      b !== null && (!b.keyCertSign || y === null) && (a = {
                        message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                        error: n.certificateError.bad_certificate
                      }), a === null && y !== null && !y.cA && (a = {
                        message: "Certificate basicConstraints indicates the certificate is not a CA.",
                        error: n.certificateError.bad_certificate
                      });
                      if (a === null && b !== null && "pathLenConstraint" in y) {
                        var w = 0;
                        for (var m = 1; m < r.length - 1; ++m)
                          r[m].isIssuer(r[m]) && ++w;
                        var E = y.pathLenConstraint + 1;
                        r.length - w > E && (a = {
                          message: "Certificate basicConstraints pathLenConstraint violated.",
                          error: n.certificateError.bad_certificate
                        });
                      }
                    }
                    var S = a === null ? !0 : a.error,
                        x = i ? i(S, f, s) : S;
                    if (x !== !0) {
                      S === !0 && (a = {
                        message: "The application rejected the certificate.",
                        error: n.certificateError.bad_certificate
                      });
                      if (x || x === 0)
                        typeof x == "object" && !e.util.isArray(x) ? (x.message && (a.message = x.message), x.error && (a.error = x.error)) : typeof x == "string" && (a.error = x);
                      throw a;
                    }
                    a = null, u = !1, ++f;
                  } while (r.length > 0);
                  return !0;
                };
              }
              var r = "x509";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n.pki;
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/x509", ["require", "module", "./aes", "./asn1", "./des", "./md", "./mgf", "./oids", "./pem", "./pss", "./rsa", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function f(e, t, n, r) {
                  var i = [];
                  for (var s = 0; s < e.length; s++)
                    for (var o = 0; o < e[s].safeBags.length; o++) {
                      var u = e[s].safeBags[o];
                      if (r !== undefined && u.type !== r)
                        continue;
                      u.attributes[t] !== undefined && u.attributes[t].indexOf(n) >= 0 && i.push(u);
                    }
                  return i;
                }
                function l(e, r, s, o) {
                  r = t.fromDer(r, s);
                  if (r.tagClass !== t.Class.UNIVERSAL || r.type !== t.Type.SEQUENCE || r.constructed !== !0)
                    throw {message: "PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo"};
                  for (var u = 0; u < r.value.length; u++) {
                    var a = r.value[u],
                        f = {},
                        l = [];
                    if (!t.validate(a, i, f, l))
                      throw {
                        message: "Cannot read ContentInfo.",
                        errors: l
                      };
                    var p = {encrypted: !1},
                        d = null,
                        v = f.content.value[0];
                    switch (t.derToOid(f.contentType)) {
                      case n.oids.data:
                        if (v.tagClass !== t.Class.UNIVERSAL || v.type !== t.Type.OCTETSTRING)
                          throw {message: "PKCS#12 SafeContents Data is not an OCTET STRING."};
                        d = v.value;
                        break;
                      case n.oids.encryptedData:
                        if (o === undefined)
                          throw {message: "Found PKCS#12 Encrypted SafeContents Data but no password available."};
                        d = c(v, o), p.encrypted = !0;
                        break;
                      default:
                        throw {
                          message: "Unsupported PKCS#12 contentType.",
                          contentType: t.derToOid(f.contentType)
                        };
                    }
                    p.safeBags = h(d, s, o), e.safeContents.push(p);
                  }
                }
                function c(r, i) {
                  var s = {},
                      o = [];
                  if (!t.validate(r, e.pkcs7.asn1.encryptedDataValidator, s, o))
                    throw {
                      message: "Cannot read EncryptedContentInfo. ",
                      errors: o
                    };
                  var u = t.derToOid(s.contentType);
                  if (u !== n.oids.data)
                    throw {
                      message: "PKCS#12 EncryptedContentInfo ContentType is not Data.",
                      oid: u
                    };
                  u = t.derToOid(s.encAlgorithm);
                  var a = n.pbe.getCipher(u, s.encParameter, i),
                      f = e.util.createBuffer(s.encryptedContent);
                  a.update(f);
                  if (!a.finish())
                    throw {message: "Failed to decrypt PKCS#12 SafeContents."};
                  return a.output.getBytes();
                }
                function h(e, r, i) {
                  e = t.fromDer(e, r);
                  if (e.tagClass !== t.Class.UNIVERSAL || e.type !== t.Type.SEQUENCE || e.constructed !== !0)
                    throw {message: "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag"};
                  var s = [];
                  for (var u = 0; u < e.value.length; u++) {
                    var f = e.value[u],
                        l = {},
                        c = [];
                    if (!t.validate(f, o, l, c))
                      throw {
                        message: "Cannot read SafeBag.",
                        errors: c
                      };
                    var h = {
                      type: t.derToOid(l.bagId),
                      attributes: p(l.bagAttributes)
                    };
                    s.push(h);
                    var d,
                        v,
                        m = l.bagValue.value[0];
                    switch (h.type) {
                      case n.oids.pkcs8ShroudedKeyBag:
                        if (i === undefined)
                          throw {message: "Found PKCS#8 ShroudedKeyBag but no password available."};
                        m = n.decryptPrivateKeyInfo(m, i);
                        if (m === null)
                          throw {message: "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"};
                      case n.oids.keyBag:
                        h.key = n.privateKeyFromAsn1(m);
                        continue;
                      case n.oids.certBag:
                        d = a, v = function() {
                          if (t.derToOid(l.certId) !== n.oids.x509Certificate)
                            throw {
                              message: "Unsupported certificate type, only X.509 supported.",
                              oid: t.derToOid(l.certId)
                            };
                          h.cert = n.certificateFromAsn1(t.fromDer(l.cert, r), !0);
                        };
                        break;
                      default:
                        throw {
                          message: "Unsupported PKCS#12 SafeBag type.",
                          oid: h.type
                        };
                    }
                    if (d !== undefined && !t.validate(m, d, l, c))
                      throw {
                        message: "Cannot read PKCS#12 " + d.name,
                        errors: c
                      };
                    v();
                  }
                  return s;
                }
                function p(e) {
                  var r = {};
                  if (e !== undefined)
                    for (var i = 0; i < e.length; ++i) {
                      var s = {},
                          o = [];
                      if (!t.validate(e[i], u, s, o))
                        throw {
                          message: "Cannot read PKCS#12 BagAttribute.",
                          errors: o
                        };
                      var a = t.derToOid(s.oid);
                      if (n.oids[a] === undefined)
                        continue;
                      r[n.oids[a]] = [];
                      for (var f = 0; f < s.values.length; ++f)
                        r[n.oids[a]].push(s.values[f].value);
                    }
                  return r;
                }
                var t = e.asn1,
                    n = e.pki,
                    r = e.pkcs12 = e.pkcs12 || {},
                    i = {
                      name: "ContentInfo",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "ContentInfo.contentType",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.OID,
                        constructed: !1,
                        capture: "contentType"
                      }, {
                        name: "ContentInfo.content",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        constructed: !0,
                        captureAsn1: "content"
                      }]
                    },
                    s = {
                      name: "PFX",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "PFX.version",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.INTEGER,
                        constructed: !1,
                        capture: "version"
                      }, i, {
                        name: "PFX.macData",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        optional: !0,
                        captureAsn1: "mac",
                        value: [{
                          name: "PFX.macData.mac",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "PFX.macData.mac.digestAlgorithm",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                              name: "PFX.macData.mac.digestAlgorithm.algorithm",
                              tagClass: t.Class.UNIVERSAL,
                              type: t.Type.OID,
                              constructed: !1,
                              capture: "macAlgorithm"
                            }, {
                              name: "PFX.macData.mac.digestAlgorithm.parameters",
                              tagClass: t.Class.UNIVERSAL,
                              captureAsn1: "macAlgorithmParameters"
                            }]
                          }, {
                            name: "PFX.macData.mac.digest",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OCTETSTRING,
                            constructed: !1,
                            capture: "macDigest"
                          }]
                        }, {
                          name: "PFX.macData.macSalt",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.OCTETSTRING,
                          constructed: !1,
                          capture: "macSalt"
                        }, {
                          name: "PFX.macData.iterations",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.INTEGER,
                          constructed: !1,
                          optional: !0,
                          capture: "macIterations"
                        }]
                      }]
                    },
                    o = {
                      name: "SafeBag",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "SafeBag.bagId",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.OID,
                        constructed: !1,
                        capture: "bagId"
                      }, {
                        name: "SafeBag.bagValue",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        constructed: !0,
                        captureAsn1: "bagValue"
                      }, {
                        name: "SafeBag.bagAttributes",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SET,
                        constructed: !0,
                        optional: !0,
                        capture: "bagAttributes"
                      }]
                    },
                    u = {
                      name: "Attribute",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "Attribute.attrId",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.OID,
                        constructed: !1,
                        capture: "oid"
                      }, {
                        name: "Attribute.attrValues",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SET,
                        constructed: !0,
                        capture: "values"
                      }]
                    },
                    a = {
                      name: "CertBag",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "CertBag.certId",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.OID,
                        constructed: !1,
                        capture: "certId"
                      }, {
                        name: "CertBag.certValue",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        constructed: !0,
                        value: [{
                          name: "CertBag.certValue[0]",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.OCTETSTRING,
                          constructed: !1,
                          capture: "cert"
                        }]
                      }]
                    };
                r.pkcs12FromAsn1 = function(i, o, u) {
                  typeof o == "string" ? (u = o, o = !0) : o === undefined && (o = !0);
                  var a = {},
                      c = [];
                  if (!t.validate(i, s, a, c))
                    throw {
                      message: "Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.",
                      errors: c
                    };
                  var h = {
                    version: a.version.charCodeAt(0),
                    safeContents: [],
                    getBags: function(t) {
                      var n = {},
                          r;
                      return "localKeyId" in t ? r = t.localKeyId : "localKeyIdHex" in t && (r = e.util.hexToBytes(t.localKeyIdHex)), r !== undefined && (n.localKeyId = f(h.safeContents, "localKeyId", r, t.bagType)), "friendlyName" in t && (n.friendlyName = f(h.safeContents, "friendlyName", t.friendlyName, t.bagType)), n;
                    },
                    getBagsByFriendlyName: function(e, t) {
                      return f(h.safeContents, "friendlyName", e, t);
                    },
                    getBagsByLocalKeyId: function(e, t) {
                      return f(h.safeContents, "localKeyId", e, t);
                    }
                  };
                  if (a.version.charCodeAt(0) !== 3)
                    throw {
                      message: "PKCS#12 PFX of version other than 3 not supported.",
                      version: a.version.charCodeAt(0)
                    };
                  if (t.derToOid(a.contentType) !== n.oids.data)
                    throw {
                      message: "Only PKCS#12 PFX in password integrity mode supported.",
                      oid: t.derToOid(a.contentType)
                    };
                  var p = a.content.value[0];
                  if (p.tagClass !== t.Class.UNIVERSAL || p.type !== t.Type.OCTETSTRING)
                    throw {message: "PKCS#12 authSafe content data is not an OCTET STRING."};
                  if (a.mac) {
                    var d = null,
                        v = 0,
                        m = t.derToOid(a.macAlgorithm);
                    switch (m) {
                      case n.oids.sha1:
                        d = e.md.sha1.create(), v = 20;
                        break;
                      case n.oids.sha256:
                        d = e.md.sha256.create(), v = 32;
                        break;
                      case n.oids.sha384:
                        d = e.md.sha384.create(), v = 48;
                        break;
                      case n.oids.sha512:
                        d = e.md.sha512.create(), v = 64;
                        break;
                      case n.oids.md5:
                        d = e.md.md5.create(), v = 16;
                    }
                    if (d === null)
                      throw {message: "PKCS#12 uses unsupported MAC algorithm: " + m};
                    var g = new e.util.ByteBuffer(a.macSalt),
                        y = "macIterations" in a ? parseInt(e.util.bytesToHex(a.macIterations), 16) : 1,
                        b = r.generateKey(u || "", g, 3, y, v, d),
                        w = e.hmac.create();
                    w.start(d, b), w.update(p.value);
                    var E = w.getMac();
                    if (E.getBytes() !== a.macDigest)
                      throw {message: "PKCS#12 MAC could not be verified. Invalid password?"};
                  }
                  return l(h, p.value, o, u), h;
                }, r.toPkcs12Asn1 = function(i, s, o, u) {
                  u = u || {}, u.saltSize = u.saltSize || 8, u.count = u.count || 2048, u.algorithm = u.algorithm || u.encAlgorithm || "aes128", "useMac" in u || (u.useMac = !0), "localKeyId" in u || (u.localKeyId = null), "generateLocalKeyId" in u || (u.generateLocalKeyId = !0);
                  var a = u.localKeyId,
                      f;
                  if (a !== null)
                    a = e.util.hexToBytes(a);
                  else if (u.generateLocalKeyId)
                    if (s) {
                      var l = e.util.isArray(s) ? s[0] : s;
                      typeof l == "string" && (l = n.certificateFromPem(l));
                      var c = e.md.sha1.create();
                      c.update(t.toDer(n.certificateToAsn1(l)).getBytes()), a = c.digest().getBytes();
                    } else
                      a = e.random.getBytes(20);
                  var h = [];
                  a !== null && h.push(t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.localKeyId).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, a)])])), "friendlyName" in u && h.push(t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.friendlyName).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, [t.create(t.Class.UNIVERSAL, t.Type.BMPSTRING, !1, u.friendlyName)])])), h.length > 0 && (f = t.create(t.Class.UNIVERSAL, t.Type.SET, !0, h));
                  var p = [],
                      d = [];
                  s !== null && (e.util.isArray(s) ? d = s : d = [s]);
                  var v = [];
                  for (var m = 0; m < d.length; ++m) {
                    s = d[m], typeof s == "string" && (s = n.certificateFromPem(s));
                    var g = m === 0 ? f : undefined,
                        y = n.certificateToAsn1(s),
                        b = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.certBag).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.x509Certificate).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, t.toDer(y).getBytes())])])]), g]);
                    v.push(b);
                  }
                  if (v.length > 0) {
                    var w = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, v),
                        E = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.data).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, t.toDer(w).getBytes())])]);
                    p.push(E);
                  }
                  var S = null;
                  if (i !== null) {
                    var x = n.wrapRsaPrivateKey(n.privateKeyToAsn1(i));
                    o === null ? S = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.keyBag).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [x]), f]) : S = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.pkcs8ShroudedKeyBag).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [n.encryptPrivateKeyInfo(x, o, u)]), f]);
                    var T = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [S]),
                        N = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.data).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, t.toDer(T).getBytes())])]);
                    p.push(N);
                  }
                  var C = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, p),
                      k;
                  if (u.useMac) {
                    var c = e.md.sha1.create(),
                        L = new e.util.ByteBuffer(e.random.getBytes(u.saltSize)),
                        A = u.count,
                        i = r.generateKey(o || "", L, 3, A, 20),
                        O = e.hmac.create();
                    O.start(c, i), O.update(t.toDer(C).getBytes());
                    var M = O.getMac();
                    k = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.sha1).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "")]), t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, M.getBytes())]), t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, L.getBytes()), t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(A).getBytes())]);
                  }
                  return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(3).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.data).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, t.toDer(C).getBytes())])]), k]);
                }, r.generateKey = e.pbe.generatePkcs12Key;
              }
              var r = "pkcs12";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pkcs12", ["require", "module", "./asn1", "./hmac", "./oids", "./pkcs7asn1", "./pbe", "./random", "./rsa", "./sha1", "./util", "./x509"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.asn1,
                    n = e.pki = e.pki || {};
                n.pemToDer = function(t) {
                  var n = e.pem.decode(t)[0];
                  if (n.procType && n.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert PEM to DER; PEM is encrypted."};
                  return e.util.createBuffer(n.body);
                }, n.privateKeyFromPem = function(r) {
                  var i = e.pem.decode(r)[0];
                  if (i.type !== "PRIVATE KEY" && i.type !== "RSA PRIVATE KEY")
                    throw {
                      message: 'Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".',
                      headerType: i.type
                    };
                  if (i.procType && i.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert private key from PEM; PEM is encrypted."};
                  var s = t.fromDer(i.body);
                  return n.privateKeyFromAsn1(s);
                }, n.privateKeyToPem = function(r, i) {
                  var s = {
                    type: "RSA PRIVATE KEY",
                    body: t.toDer(n.privateKeyToAsn1(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                };
              }
              var r = "pki";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pki", ["require", "module", "./asn1", "./oids", "./pbe", "./pem", "./pbkdf2", "./pkcs12", "./pss", "./rsa", "./util", "./x509"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = function(t, n, r, i) {
                  var s = e.util.createBuffer(),
                      o = t.length >> 1,
                      u = o + (t.length & 1),
                      a = t.substr(0, u),
                      f = t.substr(o, u),
                      l = e.util.createBuffer(),
                      c = e.hmac.create();
                  r = n + r;
                  var h = Math.ceil(i / 16),
                      p = Math.ceil(i / 20);
                  c.start("MD5", a);
                  var d = e.util.createBuffer();
                  l.putBytes(r);
                  for (var v = 0; v < h; ++v)
                    c.start(null, null), c.update(l.getBytes()), l.putBuffer(c.digest()), c.start(null, null), c.update(l.bytes() + r), d.putBuffer(c.digest());
                  c.start("SHA1", f);
                  var m = e.util.createBuffer();
                  l.clear(), l.putBytes(r);
                  for (var v = 0; v < p; ++v)
                    c.start(null, null), c.update(l.getBytes()), l.putBuffer(c.digest()), c.start(null, null), c.update(l.bytes() + r), m.putBuffer(c.digest());
                  return s.putBytes(e.util.xorBytes(d.getBytes(), m.getBytes(), i)), s;
                },
                    n = function(e, t, n, r) {},
                    r = function(t, n, r) {
                      var i = e.hmac.create();
                      i.start("SHA1", t);
                      var s = e.util.createBuffer();
                      return s.putInt32(n[0]), s.putInt32(n[1]), s.putByte(r.type), s.putByte(r.version.major), s.putByte(r.version.minor), s.putInt16(r.length), s.putBytes(r.fragment.bytes()), i.update(s.getBytes()), i.digest().getBytes();
                    },
                    i = function(t, n, r) {
                      var i = !1;
                      try {
                        var s = t.deflate(n.fragment.getBytes());
                        n.fragment = e.util.createBuffer(s), n.length = s.length, i = !0;
                      } catch (o) {}
                      return i;
                    },
                    s = function(t, n, r) {
                      var i = !1;
                      try {
                        var s = t.inflate(n.fragment.getBytes());
                        n.fragment = e.util.createBuffer(s), n.length = s.length, i = !0;
                      } catch (o) {}
                      return i;
                    },
                    o = function(t, n) {
                      var r = 0;
                      switch (n) {
                        case 1:
                          r = t.getByte();
                          break;
                        case 2:
                          r = t.getInt16();
                          break;
                        case 3:
                          r = t.getInt24();
                          break;
                        case 4:
                          r = t.getInt32();
                      }
                      return e.util.createBuffer(t.getBytes(r));
                    },
                    u = function(e, t, n) {
                      e.putInt(n.length(), t << 3), e.putBuffer(n);
                    },
                    a = {};
                a.Version = {
                  major: 3,
                  minor: 1
                }, a.MaxFragment = 15360, a.ConnectionEnd = {
                  server: 0,
                  client: 1
                }, a.PRFAlgorithm = {tls_prf_sha256: 0}, a.BulkCipherAlgorithm = {
                  none: null,
                  rc4: 0,
                  des3: 1,
                  aes: 2
                }, a.CipherType = {
                  stream: 0,
                  block: 1,
                  aead: 2
                }, a.MACAlgorithm = {
                  none: null,
                  hmac_md5: 0,
                  hmac_sha1: 1,
                  hmac_sha256: 2,
                  hmac_sha384: 3,
                  hmac_sha512: 4
                }, a.CompressionMethod = {
                  none: 0,
                  deflate: 1
                }, a.ContentType = {
                  change_cipher_spec: 20,
                  alert: 21,
                  handshake: 22,
                  application_data: 23
                }, a.HandshakeType = {
                  hello_request: 0,
                  client_hello: 1,
                  server_hello: 2,
                  certificate: 11,
                  server_key_exchange: 12,
                  certificate_request: 13,
                  server_hello_done: 14,
                  certificate_verify: 15,
                  client_key_exchange: 16,
                  finished: 20
                }, a.Alert = {}, a.Alert.Level = {
                  warning: 1,
                  fatal: 2
                }, a.Alert.Description = {
                  close_notify: 0,
                  unexpected_message: 10,
                  bad_record_mac: 20,
                  decryption_failed: 21,
                  record_overflow: 22,
                  decompression_failure: 30,
                  handshake_failure: 40,
                  bad_certificate: 42,
                  unsupported_certificate: 43,
                  certificate_revoked: 44,
                  certificate_expired: 45,
                  certificate_unknown: 46,
                  illegal_parameter: 47,
                  unknown_ca: 48,
                  access_denied: 49,
                  decode_error: 50,
                  decrypt_error: 51,
                  export_restriction: 60,
                  protocol_version: 70,
                  insufficient_security: 71,
                  internal_error: 80,
                  user_canceled: 90,
                  no_renegotiation: 100
                }, a.CipherSuites = {}, a.getCipherSuite = function(e) {
                  var t = null;
                  for (var n in a.CipherSuites) {
                    var r = a.CipherSuites[n];
                    if (r.id[0] === e.charCodeAt(0) && r.id[1] === e.charCodeAt(1)) {
                      t = r;
                      break;
                    }
                  }
                  return t;
                }, a.handleUnexpected = function(e, t) {
                  var n = !e.open && e.entity === a.ConnectionEnd.client;
                  n || e.error(e, {
                    message: "Unexpected message. Received TLS record out of order.",
                    send: !0,
                    alert: {
                      level: a.Alert.Level.fatal,
                      description: a.Alert.Description.unexpected_message
                    }
                  });
                }, a.handleHelloRequest = function(e, t, n) {
                  !e.handshaking && e.handshakes > 0 && (a.queue(e, a.createAlert({
                    level: a.Alert.Level.warning,
                    description: a.Alert.Description.no_renegotiation
                  })), a.flush(e)), e.process();
                }, a.parseHelloMessage = function(t, n, r) {
                  var i = null,
                      s = t.entity === a.ConnectionEnd.client;
                  if (r < 38)
                    t.error(t, {
                      message: s ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var u = n.fragment,
                        f = u.length();
                    i = {
                      version: {
                        major: u.getByte(),
                        minor: u.getByte()
                      },
                      random: e.util.createBuffer(u.getBytes(32)),
                      session_id: o(u, 1),
                      extensions: []
                    }, s ? (i.cipher_suite = u.getBytes(2), i.compression_method = u.getByte()) : (i.cipher_suites = o(u, 2), i.compression_methods = o(u, 1)), f = r - (f - u.length());
                    if (f > 0) {
                      var l = o(u, 2);
                      while (l.length() > 0)
                        i.extensions.push({
                          type: [l.getByte(), l.getByte()],
                          data: o(l, 2)
                        });
                      if (!s)
                        for (var c = 0; c < i.extensions.length; ++c) {
                          var h = i.extensions[c];
                          if (h.type[0] === 0 && h.type[1] === 0) {
                            var p = o(h.data, 2);
                            while (p.length() > 0) {
                              var d = p.getByte();
                              if (d !== 0)
                                break;
                              t.session.serverNameList.push(o(p, 2).getBytes());
                            }
                          }
                        }
                    }
                    (i.version.major !== a.Version.major || i.version.minor !== a.Version.minor) && t.error(t, {
                      message: "Incompatible TLS version.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.protocol_version
                      }
                    });
                    if (s)
                      t.session.cipherSuite = a.getCipherSuite(i.cipher_suite);
                    else {
                      var v = e.util.createBuffer(i.cipher_suites.bytes());
                      while (v.length() > 0) {
                        t.session.cipherSuite = a.getCipherSuite(v.getBytes(2));
                        if (t.session.cipherSuite !== null)
                          break;
                      }
                    }
                    if (t.session.cipherSuite === null)
                      return t.error(t, {
                        message: "No cipher suites in common.",
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.handshake_failure
                        },
                        cipherSuite: e.util.bytesToHex(i.cipher_suite)
                      });
                    s ? t.session.compressionMethod = i.compression_method : t.session.compressionMethod = a.CompressionMethod.none;
                  }
                  return i;
                }, a.createSecurityParameters = function(e, t) {
                  var n = e.entity === a.ConnectionEnd.client,
                      r = t.random.bytes(),
                      i = n ? e.session.sp.client_random : r,
                      s = n ? r : a.createRandom().getBytes();
                  e.session.sp = {
                    entity: e.entity,
                    prf_algorithm: a.PRFAlgorithm.tls_prf_sha256,
                    bulk_cipher_algorithm: null,
                    cipher_type: null,
                    enc_key_length: null,
                    block_length: null,
                    fixed_iv_length: null,
                    record_iv_length: null,
                    mac_algorithm: null,
                    mac_length: null,
                    mac_key_length: null,
                    compression_algorithm: e.session.compressionMethod,
                    pre_master_secret: null,
                    master_secret: null,
                    client_random: i,
                    server_random: s
                  };
                }, a.handleServerHello = function(e, t, n) {
                  var r = a.parseHelloMessage(e, t, n);
                  if (!e.fail) {
                    var i = r.session_id.bytes();
                    i.length > 0 && i === e.session.id ? (e.expect = d, e.session.resuming = !0, e.session.sp.server_random = r.random.bytes()) : (e.expect = l, e.session.resuming = !1, a.createSecurityParameters(e, r)), e.session.id = i, e.process();
                  }
                }, a.handleClientHello = function(t, n, r) {
                  var i = a.parseHelloMessage(t, n, r);
                  if (!t.fail) {
                    var s = i.session_id.bytes(),
                        o = null;
                    t.sessionCache && (o = t.sessionCache.getSession(s), o === null && (s = "")), s.length === 0 && (s = e.random.getBytes(32)), t.session.id = s, t.session.clientHelloVersion = i.version, t.session.sp = o ? o.sp : {}, o !== null ? (t.expect = S, t.session.resuming = !0, t.session.sp.client_random = i.random.bytes()) : (t.expect = t.verifyClient !== !1 ? b : w, t.session.resuming = !1, a.createSecurityParameters(t, i)), t.open = !0, a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createServerHello(t)
                    })), t.session.resuming ? (a.queue(t, a.createRecord({
                      type: a.ContentType.change_cipher_spec,
                      data: a.createChangeCipherSpec()
                    })), t.state.pending = a.createConnectionState(t), t.state.current.write = t.state.pending.write, a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createFinished(t)
                    }))) : (a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createCertificate(t)
                    })), t.fail || (a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createServerKeyExchange(t)
                    })), t.verifyClient !== !1 && a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createCertificateRequest(t)
                    })), a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createServerHelloDone(t)
                    })))), a.flush(t), t.process();
                  }
                }, a.handleCertificate = function(t, n, r) {
                  if (r < 3)
                    t.error(t, {
                      message: "Invalid Certificate message. Message too short.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var i = n.fragment,
                        s = {certificate_list: o(i, 3)},
                        u,
                        f,
                        l = [];
                    try {
                      while (s.certificate_list.length() > 0)
                        u = o(s.certificate_list, 3), f = e.asn1.fromDer(u), u = e.pki.certificateFromAsn1(f, !0), l.push(u);
                    } catch (h) {
                      t.error(t, {
                        message: "Could not parse certificate list.",
                        cause: h,
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.bad_certificate
                        }
                      });
                    }
                    if (!t.fail) {
                      var p = t.entity === a.ConnectionEnd.client;
                      !p && t.verifyClient !== !0 || l.length !== 0 ? l.length === 0 ? t.expect = p ? c : w : (p ? t.session.serverCertificate = l[0] : t.session.clientCertificate = l[0], a.verifyCertificateChain(t, l) && (t.expect = p ? c : w)) : t.error(t, {
                        message: p ? "No server certificate provided." : "No client certificate provided.",
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.illegal_parameter
                        }
                      }), t.process();
                    }
                  }
                }, a.handleServerKeyExchange = function(e, t, n) {
                  n > 0 ? e.error(e, {
                    message: "Invalid key parameters. Only RSA is supported.",
                    send: !0,
                    alert: {
                      level: a.Alert.Level.fatal,
                      description: a.Alert.Description.unsupported_certificate
                    }
                  }) : (e.expect = h, e.process());
                }, a.handleClientKeyExchange = function(t, n, r) {
                  if (r < 48)
                    t.error(t, {
                      message: "Invalid key parameters. Only RSA is supported.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.unsupported_certificate
                      }
                    });
                  else {
                    var i = n.fragment,
                        s = {enc_pre_master_secret: o(i, 2).getBytes()},
                        u = null;
                    if (t.getPrivateKey)
                      try {
                        u = t.getPrivateKey(t, t.session.serverCertificate), u = e.pki.privateKeyFromPem(u);
                      } catch (f) {
                        t.error(t, {
                          message: "Could not get private key.",
                          cause: f,
                          send: !0,
                          alert: {
                            level: a.Alert.Level.fatal,
                            description: a.Alert.Description.internal_error
                          }
                        });
                      }
                    if (u === null)
                      t.error(t, {
                        message: "No private key set.",
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.internal_error
                        }
                      });
                    else
                      try {
                        var l = t.session.sp;
                        l.pre_master_secret = u.decrypt(s.enc_pre_master_secret);
                        var c = t.session.clientHelloVersion;
                        if (c.major !== l.pre_master_secret.charCodeAt(0) || c.minor !== l.pre_master_secret.charCodeAt(1))
                          throw {message: "TLS version rollback attack detected."};
                      } catch (f) {
                        l.pre_master_secret = e.random.getBytes(48);
                      }
                  }
                  t.fail || (t.expect = S, t.session.clientCertificate !== null && (t.expect = E), t.process());
                }, a.handleCertificateRequest = function(e, t, n) {
                  if (n < 3)
                    e.error(e, {
                      message: "Invalid CertificateRequest. Message too short.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var r = t.fragment,
                        i = {
                          certificate_types: o(r, 1),
                          certificate_authorities: o(r, 2)
                        };
                    e.session.certificateRequest = i, e.expect = p, e.process();
                  }
                }, a.handleCertificateVerify = function(t, n, r) {
                  if (r < 2)
                    t.error(t, {
                      message: "Invalid CertificateVerify. Message too short.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var i = n.fragment;
                    i.read -= 4;
                    var s = i.bytes();
                    i.read += 4;
                    var u = {signature: o(i, 2).getBytes()},
                        f = e.util.createBuffer();
                    f.putBuffer(t.session.md5.digest()), f.putBuffer(t.session.sha1.digest()), f = f.getBytes();
                    try {
                      var l = t.session.clientCertificate;
                      if (!l.publicKey.verify(f, u.signature, "NONE"))
                        throw {message: "CertificateVerify signature does not match."};
                      t.session.md5.update(s), t.session.sha1.update(s);
                    } catch (c) {
                      t.error(t, {
                        message: "Bad signature in CertificateVerify.",
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.handshake_failure
                        }
                      });
                    }
                    t.fail || (t.expect = S, t.process());
                  }
                }, a.handleServerHelloDone = function(t, n, r) {
                  if (r > 0)
                    t.error(t, {
                      message: "Invalid ServerHelloDone message. Invalid length.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.record_overflow
                      }
                    });
                  else if (t.serverCertificate === null) {
                    var i = {
                      message: "No server certificate provided. Not enough security.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.insufficient_security
                      }
                    },
                        s = t.verify(t, i.alert.description, depth, []);
                    if (s === !0)
                      i = null;
                    else {
                      if (s || s === 0)
                        typeof s == "object" && !e.util.isArray(s) ? (s.message && (i.message = s.message), s.alert && (i.alert.description = s.alert)) : typeof s == "number" && (i.alert.description = s);
                      t.error(t, i);
                    }
                  }
                  !t.fail && t.session.certificateRequest !== null && (n = a.createRecord({
                    type: a.ContentType.handshake,
                    data: a.createCertificate(t)
                  }), a.queue(t, n));
                  if (!t.fail) {
                    n = a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createClientKeyExchange(t)
                    }), a.queue(t, n), t.expect = g;
                    var o = function(e, t) {
                      e.session.certificateRequest !== null && e.session.clientCertificate !== null && a.queue(e, a.createRecord({
                        type: a.ContentType.handshake,
                        data: a.createCertificateVerify(e, t)
                      })), a.queue(e, a.createRecord({
                        type: a.ContentType.change_cipher_spec,
                        data: a.createChangeCipherSpec()
                      })), e.state.pending = a.createConnectionState(e), e.state.current.write = e.state.pending.write, a.queue(e, a.createRecord({
                        type: a.ContentType.handshake,
                        data: a.createFinished(e)
                      })), e.expect = d, a.flush(e), e.process();
                    };
                    t.session.certificateRequest === null || t.session.clientCertificate === null ? o(t, null) : a.getClientSignature(t, o);
                  }
                }, a.handleChangeCipherSpec = function(e, t) {
                  if (t.fragment.getByte() !== 1)
                    e.error(e, {
                      message: "Invalid ChangeCipherSpec message received.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var n = e.entity === a.ConnectionEnd.client;
                    if (e.session.resuming && n || !e.session.resuming && !n)
                      e.state.pending = a.createConnectionState(e);
                    e.state.current.read = e.state.pending.read;
                    if (!e.session.resuming && n || e.session.resuming && !n)
                      e.state.pending = null;
                    e.expect = n ? v : x, e.process();
                  }
                }, a.handleFinished = function(n, r, i) {
                  var s = r.fragment;
                  s.read -= 4;
                  var o = s.bytes();
                  s.read += 4;
                  var u = r.fragment.getBytes();
                  s = e.util.createBuffer(), s.putBuffer(n.session.md5.digest()), s.putBuffer(n.session.sha1.digest());
                  var f = n.entity === a.ConnectionEnd.client,
                      l = f ? "server finished" : "client finished",
                      c = n.session.sp,
                      h = 12,
                      p = t;
                  s = p(c.master_secret, l, s.getBytes(), h);
                  if (s.getBytes() !== u)
                    n.error(n, {
                      message: "Invalid verify_data in Finished message.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.decrypt_error
                      }
                    });
                  else {
                    n.session.md5.update(o), n.session.sha1.update(o);
                    if (n.session.resuming && f || !n.session.resuming && !f)
                      a.queue(n, a.createRecord({
                        type: a.ContentType.change_cipher_spec,
                        data: a.createChangeCipherSpec()
                      })), n.state.current.write = n.state.pending.write, n.state.pending = null, a.queue(n, a.createRecord({
                        type: a.ContentType.handshake,
                        data: a.createFinished(n)
                      }));
                    n.expect = f ? m : T, n.handshaking = !1, ++n.handshakes, n.peerCertificate = f ? n.session.serverCertificate : n.session.clientCertificate, n.sessionCache ? (n.session = {
                      id: n.session.id,
                      sp: n.session.sp
                    }, n.session.sp.keys = null) : n.session = null, a.flush(n), n.isConnected = !0, n.connected(n), n.process();
                  }
                }, a.handleAlert = function(e, t) {
                  var n = t.fragment,
                      r = {
                        level: n.getByte(),
                        description: n.getByte()
                      },
                      i;
                  switch (r.description) {
                    case a.Alert.Description.close_notify:
                      i = "Connection closed.";
                      break;
                    case a.Alert.Description.unexpected_message:
                      i = "Unexpected message.";
                      break;
                    case a.Alert.Description.bad_record_mac:
                      i = "Bad record MAC.";
                      break;
                    case a.Alert.Description.decryption_failed:
                      i = "Decryption failed.";
                      break;
                    case a.Alert.Description.record_overflow:
                      i = "Record overflow.";
                      break;
                    case a.Alert.Description.decompression_failure:
                      i = "Decompression failed.";
                      break;
                    case a.Alert.Description.handshake_failure:
                      i = "Handshake failure.";
                      break;
                    case a.Alert.Description.bad_certificate:
                      i = "Bad certificate.";
                      break;
                    case a.Alert.Description.unsupported_certificate:
                      i = "Unsupported certificate.";
                      break;
                    case a.Alert.Description.certificate_revoked:
                      i = "Certificate revoked.";
                      break;
                    case a.Alert.Description.certificate_expired:
                      i = "Certificate expired.";
                      break;
                    case a.Alert.Description.certificate_unknown:
                      i = "Certificate unknown.";
                      break;
                    case a.Alert.Description.illegal_parameter:
                      i = "Illegal parameter.";
                      break;
                    case a.Alert.Description.unknown_ca:
                      i = "Unknown certificate authority.";
                      break;
                    case a.Alert.Description.access_denied:
                      i = "Access denied.";
                      break;
                    case a.Alert.Description.decode_error:
                      i = "Decode error.";
                      break;
                    case a.Alert.Description.decrypt_error:
                      i = "Decrypt error.";
                      break;
                    case a.Alert.Description.export_restriction:
                      i = "Export restriction.";
                      break;
                    case a.Alert.Description.protocol_version:
                      i = "Unsupported protocol version.";
                      break;
                    case a.Alert.Description.insufficient_security:
                      i = "Insufficient security.";
                      break;
                    case a.Alert.Description.internal_error:
                      i = "Internal error.";
                      break;
                    case a.Alert.Description.user_canceled:
                      i = "User canceled.";
                      break;
                    case a.Alert.Description.no_renegotiation:
                      i = "Renegotiation not supported.";
                      break;
                    default:
                      i = "Unknown error.";
                  }
                  r.description === a.Alert.Description.close_notify ? e.close() : (e.error(e, {
                    message: i,
                    send: !1,
                    origin: e.entity === a.ConnectionEnd.client ? "server" : "client",
                    alert: r
                  }), e.process());
                }, a.handleHandshake = function(t, n) {
                  var r = n.fragment,
                      i = r.getByte(),
                      s = r.getInt24();
                  if (s > r.length())
                    t.fragmented = n, n.fragment = e.util.createBuffer(), r.read -= 4, t.process();
                  else {
                    t.fragmented = null, r.read -= 4;
                    var o = r.bytes(s + 4);
                    r.read += 4, i in I[t.entity][t.expect] ? (t.entity === a.ConnectionEnd.server && !t.open && !t.fail && (t.handshaking = !0, t.session = {
                      serverNameList: [],
                      cipherSuite: null,
                      compressionMethod: null,
                      serverCertificate: null,
                      clientCertificate: null,
                      md5: e.md.md5.create(),
                      sha1: e.md.sha1.create()
                    }), i !== a.HandshakeType.hello_request && i !== a.HandshakeType.certificate_verify && i !== a.HandshakeType.finished && (t.session.md5.update(o), t.session.sha1.update(o)), I[t.entity][t.expect][i](t, n, s)) : a.handleUnexpected(t, n);
                  }
                }, a.handleApplicationData = function(e, t) {
                  e.data.putBuffer(t.fragment), e.dataReady(e), e.process();
                };
                var f = 0,
                    l = 1,
                    c = 2,
                    h = 3,
                    p = 4,
                    d = 5,
                    v = 6,
                    m = 7,
                    g = 8,
                    y = 0,
                    b = 1,
                    w = 2,
                    E = 3,
                    S = 4,
                    x = 5,
                    T = 6,
                    N = 7,
                    C = a.handleUnexpected,
                    k = a.handleChangeCipherSpec,
                    L = a.handleAlert,
                    A = a.handleHandshake,
                    O = a.handleApplicationData,
                    M = [];
                M[a.ConnectionEnd.client] = [[C, L, A, C], [C, L, A, C], [C, L, A, C], [C, L, A, C], [C, L, A, C], [k, L, C, C], [C, L, A, C], [C, L, A, O], [C, L, A, C]], M[a.ConnectionEnd.server] = [[C, L, A, C], [C, L, A, C], [C, L, A, C], [C, L, A, C], [k, L, C, C], [C, L, A, C], [C, L, A, O], [C, L, A, C]];
                var _ = a.handleHelloRequest,
                    D = a.handleServerHello,
                    P = a.handleCertificate,
                    H = a.handleServerKeyExchange,
                    B = a.handleCertificateRequest,
                    j = a.handleServerHelloDone,
                    F = a.handleFinished,
                    I = [];
                I[a.ConnectionEnd.client] = [[C, C, D, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, P, H, B, j, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, H, B, j, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, B, j, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, j, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, F], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C]];
                var q = a.handleClientHello,
                    R = a.handleClientKeyExchange,
                    U = a.handleCertificateVerify;
                I[a.ConnectionEnd.server] = [[C, q, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, P, C, C, C, C, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, R, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, U, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, F], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C]], a.generateKeys = function(e, n) {
                  var r = t,
                      i = n.client_random + n.server_random;
                  e.session.resuming || (n.master_secret = r(n.pre_master_secret, "master secret", i, 48).bytes(), n.pre_master_secret = null), i = n.server_random + n.client_random;
                  var s = 2 * n.mac_key_length + 2 * n.enc_key_length + 2 * n.fixed_iv_length,
                      o = r(n.master_secret, "key expansion", i, s);
                  return {
                    client_write_MAC_key: o.getBytes(n.mac_key_length),
                    server_write_MAC_key: o.getBytes(n.mac_key_length),
                    client_write_key: o.getBytes(n.enc_key_length),
                    server_write_key: o.getBytes(n.enc_key_length),
                    client_write_IV: o.getBytes(n.fixed_iv_length),
                    server_write_IV: o.getBytes(n.fixed_iv_length)
                  };
                }, a.createConnectionState = function(e) {
                  var t = e.entity === a.ConnectionEnd.client,
                      n = function() {
                        var e = {
                          sequenceNumber: [0, 0],
                          macKey: null,
                          macLength: 0,
                          macFunction: null,
                          cipherState: null,
                          cipherFunction: function(e) {
                            return !0;
                          },
                          compressionState: null,
                          compressFunction: function(e) {
                            return !0;
                          },
                          updateSequenceNumber: function() {
                            e.sequenceNumber[1] === 4294967295 ? (e.sequenceNumber[1] = 0, ++e.sequenceNumber[0]) : ++e.sequenceNumber[1];
                          }
                        };
                        return e;
                      },
                      r = {
                        read: n(),
                        write: n()
                      };
                  r.read.update = function(e, t) {
                    return r.read.cipherFunction(t, r.read) ? r.read.compressFunction(e, t, r.read) || e.error(e, {
                      message: "Could not decompress record.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.decompression_failure
                      }
                    }) : e.error(e, {
                      message: "Could not decrypt record or bad MAC.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.bad_record_mac
                      }
                    }), !e.fail;
                  }, r.write.update = function(e, t) {
                    return r.write.compressFunction(e, t, r.write) ? r.write.cipherFunction(t, r.write) || e.error(e, {
                      message: "Could not encrypt record.",
                      send: !1,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.internal_error
                      }
                    }) : e.error(e, {
                      message: "Could not compress record.",
                      send: !1,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.internal_error
                      }
                    }), !e.fail;
                  };
                  if (e.session) {
                    var o = e.session.sp;
                    e.session.cipherSuite.initSecurityParameters(o), o.keys = a.generateKeys(e, o), r.read.macKey = t ? o.keys.server_write_MAC_key : o.keys.client_write_MAC_key, r.write.macKey = t ? o.keys.client_write_MAC_key : o.keys.server_write_MAC_key, e.session.cipherSuite.initConnectionState(r, e, o);
                    switch (o.compression_algorithm) {
                      case a.CompressionMethod.none:
                        break;
                      case a.CompressionMethod.deflate:
                        r.read.compressFunction = s, r.write.compressFunction = i;
                        break;
                      default:
                        throw {message: "Unsupported compression algorithm."};
                    }
                  }
                  return r;
                }, a.createRandom = function() {
                  var t = new Date,
                      n = +t + t.getTimezoneOffset() * 6e4,
                      r = e.util.createBuffer();
                  return r.putInt32(n), r.putBytes(e.random.getBytes(28)), r;
                }, a.createRecord = function(e) {
                  if (!e.data)
                    return null;
                  var t = {
                    type: e.type,
                    version: {
                      major: a.Version.major,
                      minor: a.Version.minor
                    },
                    length: e.data.length(),
                    fragment: e.data
                  };
                  return t;
                }, a.createAlert = function(t) {
                  var n = e.util.createBuffer();
                  return n.putByte(t.level), n.putByte(t.description), a.createRecord({
                    type: a.ContentType.alert,
                    data: n
                  });
                }, a.createClientHello = function(t) {
                  var n = e.util.createBuffer();
                  for (var r = 0; r < t.cipherSuites.length; ++r) {
                    var i = t.cipherSuites[r];
                    n.putByte(i.id[0]), n.putByte(i.id[1]);
                  }
                  var s = n.length(),
                      o = e.util.createBuffer();
                  o.putByte(a.CompressionMethod.none);
                  var f = o.length(),
                      l = e.util.createBuffer();
                  if (t.virtualHost) {
                    var c = e.util.createBuffer();
                    c.putByte(0), c.putByte(0);
                    var h = e.util.createBuffer();
                    h.putByte(0), u(h, 2, e.util.createBuffer(t.virtualHost));
                    var p = e.util.createBuffer();
                    u(p, 2, h), u(c, 2, p), l.putBuffer(c);
                  }
                  var d = l.length();
                  d > 0 && (d += 2);
                  var v = t.session.id,
                      m = v.length + 1 + 2 + 4 + 28 + 2 + s + 1 + f + d,
                      g = e.util.createBuffer();
                  return g.putByte(a.HandshakeType.client_hello), g.putInt24(m), g.putByte(a.Version.major), g.putByte(a.Version.minor), g.putBytes(t.session.sp.client_random), u(g, 1, e.util.createBuffer(v)), u(g, 2, n), u(g, 1, o), d > 0 && u(g, 2, l), g;
                }, a.createServerHello = function(t) {
                  var n = t.session.id,
                      r = n.length + 1 + 2 + 4 + 28 + 2 + 1,
                      i = e.util.createBuffer();
                  return i.putByte(a.HandshakeType.server_hello), i.putInt24(r), i.putByte(a.Version.major), i.putByte(a.Version.minor), i.putBytes(t.session.sp.server_random), u(i, 1, e.util.createBuffer(n)), i.putByte(t.session.cipherSuite.id[0]), i.putByte(t.session.cipherSuite.id[1]), i.putByte(t.session.compressionMethod), i;
                }, a.createCertificate = function(t) {
                  var n = t.entity === a.ConnectionEnd.client,
                      r = null;
                  t.getCertificate && (r = t.getCertificate(t, n ? t.session.certificateRequest : t.session.serverNameList));
                  var i = e.util.createBuffer();
                  if (r !== null)
                    try {
                      e.util.isArray(r) || (r = [r]);
                      var s = null;
                      for (var o = 0; o < r.length; ++o) {
                        var f = e.pem.decode(r[o])[0];
                        if (f.type !== "CERTIFICATE" && f.type !== "X509 CERTIFICATE" && f.type !== "TRUSTED CERTIFICATE")
                          throw {
                            message: 'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',
                            headerType: f.type
                          };
                        if (f.procType && f.procType.type === "ENCRYPTED")
                          throw {message: "Could not convert certificate from PEM; PEM is encrypted."};
                        var l = e.util.createBuffer(f.body);
                        s === null && (s = e.asn1.fromDer(l.bytes(), !1));
                        var c = e.util.createBuffer();
                        u(c, 3, l), i.putBuffer(c);
                      }
                      r = e.pki.certificateFromAsn1(s), n ? t.session.clientCertificate = r : t.session.serverCertificate = r;
                    } catch (h) {
                      return t.error(t, {
                        message: "Could not send certificate list.",
                        cause: h,
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.bad_certificate
                        }
                      });
                    }
                  var p = 3 + i.length(),
                      d = e.util.createBuffer();
                  return d.putByte(a.HandshakeType.certificate), d.putInt24(p), u(d, 3, i), d;
                }, a.createClientKeyExchange = function(t) {
                  var n = e.util.createBuffer();
                  n.putByte(a.Version.major), n.putByte(a.Version.minor), n.putBytes(e.random.getBytes(46));
                  var r = t.session.sp;
                  r.pre_master_secret = n.getBytes();
                  var i = t.session.serverCertificate.publicKey;
                  n = i.encrypt(r.pre_master_secret);
                  var s = n.length + 2,
                      o = e.util.createBuffer();
                  return o.putByte(a.HandshakeType.client_key_exchange), o.putInt24(s), o.putInt16(n.length), o.putBytes(n), o;
                }, a.createServerKeyExchange = function(t) {
                  var n = 0,
                      r = e.util.createBuffer();
                  return n > 0 && (r.putByte(a.HandshakeType.server_key_exchange), r.putInt24(n)), r;
                }, a.getClientSignature = function(t, n) {
                  var r = e.util.createBuffer();
                  r.putBuffer(t.session.md5.digest()), r.putBuffer(t.session.sha1.digest()), r = r.getBytes(), t.getSignature = t.getSignature || function(t, n, r) {
                    var i = null;
                    if (t.getPrivateKey)
                      try {
                        i = t.getPrivateKey(t, t.session.clientCertificate), i = e.pki.privateKeyFromPem(i);
                      } catch (s) {
                        t.error(t, {
                          message: "Could not get private key.",
                          cause: s,
                          send: !0,
                          alert: {
                            level: a.Alert.Level.fatal,
                            description: a.Alert.Description.internal_error
                          }
                        });
                      }
                    i === null ? t.error(t, {
                      message: "No private key set.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.internal_error
                      }
                    }) : n = i.sign(n, null), r(t, n);
                  }, t.getSignature(t, r, n);
                }, a.createCertificateVerify = function(t, n) {
                  var r = n.length + 2,
                      i = e.util.createBuffer();
                  return i.putByte(a.HandshakeType.certificate_verify), i.putInt24(r), i.putInt16(n.length), i.putBytes(n), i;
                }, a.createCertificateRequest = function(t) {
                  var n = e.util.createBuffer();
                  n.putByte(1);
                  var r = e.util.createBuffer();
                  for (var i in t.caStore.certs) {
                    var s = t.caStore.certs[i],
                        o = e.pki.distinguishedNameToAsn1(s.subject);
                    r.putBuffer(e.asn1.toDer(o));
                  }
                  var f = 1 + n.length() + 2 + r.length(),
                      l = e.util.createBuffer();
                  return l.putByte(a.HandshakeType.certificate_request), l.putInt24(f), u(l, 1, n), u(l, 2, r), l;
                }, a.createServerHelloDone = function(t) {
                  var n = e.util.createBuffer();
                  return n.putByte(a.HandshakeType.server_hello_done), n.putInt24(0), n;
                }, a.createChangeCipherSpec = function() {
                  var t = e.util.createBuffer();
                  return t.putByte(1), t;
                }, a.createFinished = function(n) {
                  var r = e.util.createBuffer();
                  r.putBuffer(n.session.md5.digest()), r.putBuffer(n.session.sha1.digest());
                  var i = n.entity === a.ConnectionEnd.client,
                      s = n.session.sp,
                      o = 12,
                      u = t,
                      f = i ? "client finished" : "server finished";
                  r = u(s.master_secret, f, r.getBytes(), o);
                  var l = e.util.createBuffer();
                  return l.putByte(a.HandshakeType.finished), l.putInt24(r.length()), l.putBuffer(r), l;
                }, a.queue = function(t, n) {
                  if (!n)
                    return;
                  if (n.type === a.ContentType.handshake) {
                    var r = n.fragment.bytes();
                    t.session.md5.update(r), t.session.sha1.update(r), r = null;
                  }
                  var i;
                  if (n.fragment.length() <= a.MaxFragment)
                    i = [n];
                  else {
                    i = [];
                    var s = n.fragment.bytes();
                    while (s.length > a.MaxFragment)
                      i.push(a.createRecord({
                        type: n.type,
                        data: e.util.createBuffer(s.slice(0, a.MaxFragment))
                      })), s = s.slice(a.MaxFragment);
                    s.length > 0 && i.push(a.createRecord({
                      type: n.type,
                      data: e.util.createBuffer(s)
                    }));
                  }
                  for (var o = 0; o < i.length && !t.fail; ++o) {
                    var u = i[o],
                        f = t.state.current.write;
                    f.update(t, u) && t.records.push(u);
                  }
                }, a.flush = function(e) {
                  for (var t = 0; t < e.records.length; ++t) {
                    var n = e.records[t];
                    e.tlsData.putByte(n.type), e.tlsData.putByte(n.version.major), e.tlsData.putByte(n.version.minor), e.tlsData.putInt16(n.fragment.length()), e.tlsData.putBuffer(e.records[t].fragment);
                  }
                  return e.records = [], e.tlsDataReady(e);
                };
                var z = function(t) {
                  switch (t) {
                    case !0:
                      return !0;
                    case e.pki.certificateError.bad_certificate:
                      return a.Alert.Description.bad_certificate;
                    case e.pki.certificateError.unsupported_certificate:
                      return a.Alert.Description.unsupported_certificate;
                    case e.pki.certificateError.certificate_revoked:
                      return a.Alert.Description.certificate_revoked;
                    case e.pki.certificateError.certificate_expired:
                      return a.Alert.Description.certificate_expired;
                    case e.pki.certificateError.certificate_unknown:
                      return a.Alert.Description.certificate_unknown;
                    case e.pki.certificateError.unknown_ca:
                      return a.Alert.Description.unknown_ca;
                    default:
                      return a.Alert.Description.bad_certificate;
                  }
                },
                    W = function(t) {
                      switch (t) {
                        case !0:
                          return !0;
                        case a.Alert.Description.bad_certificate:
                          return e.pki.certificateError.bad_certificate;
                        case a.Alert.Description.unsupported_certificate:
                          return e.pki.certificateError.unsupported_certificate;
                        case a.Alert.Description.certificate_revoked:
                          return e.pki.certificateError.certificate_revoked;
                        case a.Alert.Description.certificate_expired:
                          return e.pki.certificateError.certificate_expired;
                        case a.Alert.Description.certificate_unknown:
                          return e.pki.certificateError.certificate_unknown;
                        case a.Alert.Description.unknown_ca:
                          return e.pki.certificateError.unknown_ca;
                        default:
                          return e.pki.certificateError.bad_certificate;
                      }
                    };
                a.verifyCertificateChain = function(t, n) {
                  try {
                    e.pki.verifyCertificateChain(t.caStore, n, function(r, i, s) {
                      var o = z(r),
                          u = t.verify(t, r, i, s);
                      if (u !== !0) {
                        if (typeof u == "object" && !e.util.isArray(u)) {
                          var f = {
                            message: "The application rejected the certificate.",
                            send: !0,
                            alert: {
                              level: a.Alert.Level.fatal,
                              description: a.Alert.Description.bad_certificate
                            }
                          };
                          throw u.message && (f.message = u.message), u.alert && (f.alert.description = u.alert), f;
                        }
                        u !== r && (u = W(u));
                      }
                      return u;
                    });
                  } catch (r) {
                    if (typeof r != "object" || e.util.isArray(r))
                      r = {
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: z(r)
                        }
                      };
                    "send" in r || (r.send = !0), "alert" in r || (r.alert = {
                      level: a.Alert.Level.fatal,
                      description: z(r.error)
                    }), t.error(t, r);
                  }
                  return !t.fail;
                }, a.createSessionCache = function(t, n) {
                  var r = null;
                  if (t && t.getSession && t.setSession && t.order)
                    r = t;
                  else {
                    r = {}, r.cache = t || {}, r.capacity = Math.max(n || 100, 1), r.order = [];
                    for (var i in t)
                      r.order.length <= n ? r.order.push(i) : delete t[i];
                    r.getSession = function(t) {
                      var n = null,
                          i = null;
                      t ? i = e.util.bytesToHex(t) : r.order.length > 0 && (i = r.order[0]);
                      if (i !== null && i in r.cache) {
                        n = r.cache[i], delete r.cache[i];
                        for (var s in r.order)
                          if (r.order[s] === i) {
                            r.order.splice(s, 1);
                            break;
                          }
                      }
                      return n;
                    }, r.setSession = function(t, n) {
                      if (r.order.length === r.capacity) {
                        var i = r.order.shift();
                        delete r.cache[i];
                      }
                      var i = e.util.bytesToHex(t);
                      r.order.push(i), r.cache[i] = n;
                    };
                  }
                  return r;
                }, a.createConnection = function(t) {
                  var n = null;
                  t.caStore ? e.util.isArray(t.caStore) ? n = e.pki.createCaStore(t.caStore) : n = t.caStore : n = e.pki.createCaStore();
                  var r = t.cipherSuites || null;
                  if (r === null) {
                    r = [];
                    for (var i in a.CipherSuites)
                      r.push(a.CipherSuites[i]);
                  }
                  var s = t.server || !1 ? a.ConnectionEnd.server : a.ConnectionEnd.client,
                      o = t.sessionCache ? a.createSessionCache(t.sessionCache) : null,
                      u = {
                        entity: s,
                        sessionId: t.sessionId,
                        caStore: n,
                        sessionCache: o,
                        cipherSuites: r,
                        connected: t.connected,
                        virtualHost: t.virtualHost || null,
                        verifyClient: t.verifyClient || !1,
                        verify: t.verify || function(e, t, n, r) {
                          return t;
                        },
                        getCertificate: t.getCertificate || null,
                        getPrivateKey: t.getPrivateKey || null,
                        getSignature: t.getSignature || null,
                        input: e.util.createBuffer(),
                        tlsData: e.util.createBuffer(),
                        data: e.util.createBuffer(),
                        tlsDataReady: t.tlsDataReady,
                        dataReady: t.dataReady,
                        closed: t.closed,
                        error: function(e, n) {
                          n.origin = n.origin || (e.entity === a.ConnectionEnd.client ? "client" : "server"), n.send && (a.queue(e, a.createAlert(n.alert)), a.flush(e));
                          var r = n.fatal !== !1;
                          r && (e.fail = !0), t.error(e, n), r && e.close(!1);
                        },
                        deflate: t.deflate || null,
                        inflate: t.inflate || null
                      };
                  u.reset = function(e) {
                    u.record = null, u.session = null, u.peerCertificate = null, u.state = {
                      pending: null,
                      current: null
                    }, u.expect = u.entity === a.ConnectionEnd.client ? f : y, u.fragmented = null, u.records = [], u.open = !1, u.handshakes = 0, u.handshaking = !1, u.isConnected = !1, u.fail = !e && typeof e != "undefined", u.input.clear(), u.tlsData.clear(), u.data.clear(), u.state.current = a.createConnectionState(u);
                  }, u.reset();
                  var l = function(e, t) {
                    var n = t.type - a.ContentType.change_cipher_spec,
                        r = M[e.entity][e.expect];
                    n in r ? r[n](e, t) : a.handleUnexpected(e, t);
                  },
                      c = function(t) {
                        var n = 0,
                            r = t.input,
                            i = r.length();
                        return i < 5 ? n = 5 - i : (t.record = {
                          type: r.getByte(),
                          version: {
                            major: r.getByte(),
                            minor: r.getByte()
                          },
                          length: r.getInt16(),
                          fragment: e.util.createBuffer(),
                          ready: !1
                        }, (t.record.version.major !== a.Version.major || t.record.version.minor !== a.Version.minor) && t.error(t, {
                          message: "Incompatible TLS version.",
                          send: !0,
                          alert: {
                            level: a.Alert.Level.fatal,
                            description: a.Alert.Description.protocol_version
                          }
                        })), n;
                      },
                      h = function(e) {
                        var t = 0,
                            n = e.input,
                            r = n.length();
                        if (r < e.record.length)
                          t = e.record.length - r;
                        else {
                          e.record.fragment.putBytes(n.getBytes(e.record.length)), n.compact();
                          var i = e.state.current.read;
                          i.update(e, e.record) && (e.fragmented !== null && (e.fragmented.type === e.record.type ? (e.fragmented.fragment.putBuffer(e.record.fragment), e.record = e.fragmented) : e.error(e, {
                            message: "Invalid fragmented record.",
                            send: !0,
                            alert: {
                              level: a.Alert.Level.fatal,
                              description: a.Alert.Description.unexpected_message
                            }
                          })), e.record.ready = !0);
                        }
                        return t;
                      };
                  return u.handshake = function(t) {
                    if (u.entity !== a.ConnectionEnd.client)
                      u.error(u, {
                        message: "Cannot initiate handshake as a server.",
                        fatal: !1
                      });
                    else if (u.handshaking)
                      u.error(u, {
                        message: "Handshake already in progress.",
                        fatal: !1
                      });
                    else {
                      u.fail && !u.open && u.handshakes === 0 && (u.fail = !1), u.handshaking = !0, t = t || "";
                      var n = null;
                      t.length > 0 && (u.sessionCache && (n = u.sessionCache.getSession(t)), n === null && (t = "")), t.length === 0 && u.sessionCache && (n = u.sessionCache.getSession(), n !== null && (t = n.id)), u.session = {
                        id: t,
                        cipherSuite: null,
                        compressionMethod: null,
                        serverCertificate: null,
                        certificateRequest: null,
                        clientCertificate: null,
                        sp: n ? n.sp : {},
                        md5: e.md.md5.create(),
                        sha1: e.md.sha1.create()
                      }, u.session.sp.client_random = a.createRandom().getBytes(), u.open = !0, a.queue(u, a.createRecord({
                        type: a.ContentType.handshake,
                        data: a.createClientHello(u)
                      })), a.flush(u);
                    }
                  }, u.process = function(e) {
                    var t = 0;
                    return e && u.input.putBytes(e), u.fail || (u.record !== null && u.record.ready && u.record.fragment.isEmpty() && (u.record = null), u.record === null && (t = c(u)), !u.fail && u.record !== null && !u.record.ready && (t = h(u)), !u.fail && u.record !== null && u.record.ready && l(u, u.record)), t;
                  }, u.prepare = function(t) {
                    return a.queue(u, a.createRecord({
                      type: a.ContentType.application_data,
                      data: e.util.createBuffer(t)
                    })), a.flush(u);
                  }, u.close = function(e) {
                    !u.fail && u.sessionCache && u.session && u.sessionCache.setSession(u.session.id, u.session);
                    if (u.open) {
                      u.open = !1, u.input.clear();
                      if (u.isConnected || u.handshaking)
                        u.isConnected = u.handshaking = !1, a.queue(u, a.createAlert({
                          level: a.Alert.Level.warning,
                          description: a.Alert.Description.close_notify
                        })), a.flush(u);
                      u.closed(u);
                    }
                    u.reset(e);
                  }, u;
                }, e.tls = e.tls || {};
                for (var X in a)
                  typeof a[X] != "function" && (e.tls[X] = a[X]);
                e.tls.prf_tls1 = t, e.tls.hmac_sha1 = r, e.tls.createSessionCache = a.createSessionCache, e.tls.createConnection = a.createConnection;
              }
              var r = "tls";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/tls", ["require", "module", "./asn1", "./hmac", "./md", "./pem", "./pki", "./random", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function n(n, i, s) {
                  var u = i.entity === e.tls.ConnectionEnd.client;
                  n.read.cipherState = {
                    init: !1,
                    cipher: e.aes.createDecryptionCipher(u ? s.keys.server_write_key : s.keys.client_write_key),
                    iv: u ? s.keys.server_write_IV : s.keys.client_write_IV
                  }, n.write.cipherState = {
                    init: !1,
                    cipher: e.aes.createEncryptionCipher(u ? s.keys.client_write_key : s.keys.server_write_key),
                    iv: u ? s.keys.client_write_IV : s.keys.server_write_IV
                  }, n.read.cipherFunction = o, n.write.cipherFunction = r, n.read.macLength = n.write.macLength = s.mac_length, n.read.macFunction = n.write.macFunction = t.hmac_sha1;
                }
                function r(t, n) {
                  var r = !1,
                      s = n.macFunction(n.macKey, n.sequenceNumber, t);
                  t.fragment.putBytes(s), n.updateSequenceNumber();
                  var o;
                  t.version.minor > 1 ? o = e.random.getBytes(16) : o = n.cipherState.init ? null : n.cipherState.iv, n.cipherState.init = !0;
                  var u = n.cipherState.cipher;
                  return u.start(o), t.version.minor > 1 && u.output.putBytes(o), u.update(t.fragment), u.finish(i) && (t.fragment = u.output, t.length = t.fragment.length(), r = !0), r;
                }
                function i(e, t, n) {
                  if (!n) {
                    var r = e - t.length() % e;
                    t.fillWithByte(r - 1, r);
                  }
                  return !0;
                }
                function s(e, t, n) {
                  var r = !0;
                  if (n) {
                    var i = t.length(),
                        s = t.last();
                    for (var o = i - 1 - s; o < i - 1; ++o)
                      r = r && t.at(o) == s;
                    r && t.truncate(s + 1);
                  }
                  return r;
                }
                function o(t, n) {
                  var r = !1,
                      i = n.cipherState.init ? null : n.cipherState.iv;
                  n.cipherState.init = !0;
                  var o = n.cipherState.cipher;
                  o.start(i), o.update(t.fragment), r = o.finish(s);
                  var u = n.macLength,
                      a = "";
                  for (var f = 0; f < u; ++f)
                    a += String.fromCharCode(0);
                  var l = o.output.length();
                  l >= u ? (t.fragment = o.output.getBytes(l - u), a = o.output.getBytes(u)) : t.fragment = o.output.getBytes(), t.fragment = e.util.createBuffer(t.fragment), t.length = t.fragment.length();
                  var c = n.macFunction(n.macKey, n.sequenceNumber, t);
                  return n.updateSequenceNumber(), r = c === a && r, r;
                }
                var t = e.tls;
                t.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
                  id: [0, 47],
                  name: "TLS_RSA_WITH_AES_128_CBC_SHA",
                  initSecurityParameters: function(e) {
                    e.bulk_cipher_algorithm = t.BulkCipherAlgorithm.aes, e.cipher_type = t.CipherType.block, e.enc_key_length = 16, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = t.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
                  },
                  initConnectionState: n
                }, t.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
                  id: [0, 53],
                  name: "TLS_RSA_WITH_AES_256_CBC_SHA",
                  initSecurityParameters: function(e) {
                    e.bulk_cipher_algorithm = t.BulkCipherAlgorithm.aes, e.cipher_type = t.CipherType.block, e.enc_key_length = 32, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = t.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
                  },
                  initConnectionState: n
                };
              }
              var r = "aesCipherSuites";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/aesCipherSuites", ["require", "module", "./aes", "./tls"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.debug = e.debug || {}, e.debug.storage = {}, e.debug.get = function(t, n) {
                  var r;
                  return typeof t == "undefined" ? r = e.debug.storage : t in e.debug.storage && (typeof n == "undefined" ? r = e.debug.storage[t] : r = e.debug.storage[t][n]), r;
                }, e.debug.set = function(t, n, r) {
                  t in e.debug.storage || (e.debug.storage[t] = {}), e.debug.storage[t][n] = r;
                }, e.debug.clear = function(t, n) {
                  typeof t == "undefined" ? e.debug.storage = {} : t in e.debug.storage && (typeof n == "undefined" ? delete e.debug.storage[t] : delete e.debug.storage[t][n]);
                };
              }
              var r = "debug";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/debug", ["require", "module"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.log = e.log || {}, e.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"];
                var t = {},
                    n = [],
                    r = null;
                e.log.LEVEL_LOCKED = 2, e.log.NO_LEVEL_CHECK = 4, e.log.INTERPOLATE = 8;
                for (var i = 0; i < e.log.levels.length; ++i) {
                  var s = e.log.levels[i];
                  t[s] = {
                    index: i,
                    name: s.toUpperCase()
                  };
                }
                e.log.logMessage = function(r) {
                  var i = t[r.level].index;
                  for (var s = 0; s < n.length; ++s) {
                    var o = n[s];
                    if (o.flags & e.log.NO_LEVEL_CHECK)
                      o.f(r);
                    else {
                      var u = t[o.level].index;
                      i <= u && o.f(o, r);
                    }
                  }
                }, e.log.prepareStandard = function(e) {
                  "standard" in e || (e.standard = t[e.level].name + " [" + e.category + "] " + e.message);
                }, e.log.prepareFull = function(t) {
                  if (!("full" in t)) {
                    var n = [t.message];
                    n = n.concat([] || t.arguments), t.full = e.util.format.apply(this, n);
                  }
                }, e.log.prepareStandardFull = function(t) {
                  "standardFull" in t || (e.log.prepareStandard(t), t.standardFull = t.standard);
                };
                var o = ["error", "warning", "info", "debug", "verbose"];
                for (var i = 0; i < o.length; ++i)
                  (function(t) {
                    e.log[t] = function(n, r) {
                      var i = Array.prototype.slice.call(arguments).slice(2),
                          s = {
                            timestamp: new Date,
                            level: t,
                            category: n,
                            message: r,
                            arguments: i
                          };
                      e.log.logMessage(s);
                    };
                  })(o[i]);
                e.log.makeLogger = function(t) {
                  var n = {
                    flags: 0,
                    f: t
                  };
                  return e.log.setLevel(n, "none"), n;
                }, e.log.setLevel = function(t, n) {
                  var r = !1;
                  if (t && !(t.flags & e.log.LEVEL_LOCKED))
                    for (var i = 0; i < e.log.levels.length; ++i) {
                      var s = e.log.levels[i];
                      if (n == s) {
                        t.level = n, r = !0;
                        break;
                      }
                    }
                  return r;
                }, e.log.lock = function(t, n) {
                  typeof n == "undefined" || n ? t.flags |= e.log.LEVEL_LOCKED : t.flags &= ~e.log.LEVEL_LOCKED;
                }, e.log.addLogger = function(e) {
                  n.push(e);
                };
                if (typeof console != "undefined" && "log" in console) {
                  var u;
                  if (console.error && console.warn && console.info && console.debug) {
                    var a = {
                      error: console.error,
                      warning: console.warn,
                      info: console.info,
                      debug: console.debug,
                      verbose: console.debug
                    },
                        f = function(t, n) {
                          e.log.prepareStandard(n);
                          var r = a[n.level],
                              i = [n.standard];
                          i = i.concat(n.arguments.slice()), r.apply(console, i);
                        };
                    u = e.log.makeLogger(f);
                  } else {
                    var f = function(t, n) {
                      e.log.prepareStandardFull(n), console.log(n.standardFull);
                    };
                    u = e.log.makeLogger(f);
                  }
                  e.log.setLevel(u, "debug"), e.log.addLogger(u), r = u;
                } else
                  console = {log: function() {}};
                if (r !== null) {
                  var l = e.util.getQueryVariables();
                  "console.level" in l && e.log.setLevel(r, l["console.level"].slice(-1)[0]);
                  if ("console.lock" in l) {
                    var c = l["console.lock"].slice(-1)[0];
                    c == "true" && e.log.lock(r);
                  }
                }
                e.log.consoleLogger = r;
              }
              var r = "log";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/log", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.asn1,
                    n = e.pkcs7 = e.pkcs7 || {};
                n.messageFromPem = function(r) {
                  var i = e.pem.decode(r)[0];
                  if (i.type !== "PKCS7")
                    throw {
                      message: 'Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".',
                      headerType: i.type
                    };
                  if (i.procType && i.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert PKCS#7 message from PEM; PEM is encrypted."};
                  var s = t.fromDer(i.body);
                  return n.messageFromAsn1(s);
                }, n.messageToPem = function(n, r) {
                  var i = {
                    type: "PKCS7",
                    body: t.toDer(n.toAsn1()).getBytes()
                  };
                  return e.pem.encode(i, {maxline: r});
                }, n.messageFromAsn1 = function(r) {
                  var i = {},
                      s = [];
                  if (!t.validate(r, n.asn1.contentInfoValidator, i, s))
                    throw {
                      message: "Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.",
                      errors: s
                    };
                  var o = t.derToOid(i.contentType),
                      u;
                  switch (o) {
                    case e.pki.oids.envelopedData:
                      u = n.createEnvelopedData();
                      break;
                    case e.pki.oids.encryptedData:
                      u = n.createEncryptedData();
                      break;
                    case e.pki.oids.signedData:
                      u = n.createSignedData();
                      break;
                    default:
                      throw {message: "Cannot read PKCS#7 message. ContentType with OID " + o + " is not (yet) supported."};
                  }
                  return u.fromAsn1(i.content.value[0]), u;
                };
                var r = function(r) {
                  var i = {},
                      s = [];
                  if (!t.validate(r, n.asn1.recipientInfoValidator, i, s))
                    throw {
                      message: "Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 EnvelopedData.",
                      errors: s
                    };
                  return {
                    version: i.version.charCodeAt(0),
                    issuer: e.pki.RDNAttributesAsArray(i.issuer),
                    serialNumber: e.util.createBuffer(i.serial).toHex(),
                    encryptedContent: {
                      algorithm: t.derToOid(i.encAlgorithm),
                      parameter: i.encParameter.value,
                      content: i.encKey
                    }
                  };
                },
                    i = function(n) {
                      return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(n.version).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [e.pki.distinguishedNameToAsn1({attributes: n.issuer}), t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, e.util.hexToBytes(n.serialNumber))]), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.encryptedContent.algorithm).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "")]), t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, n.encryptedContent.content)]);
                    },
                    s = function(e) {
                      var t = [];
                      for (var n = 0; n < e.length; n++)
                        t.push(r(e[n]));
                      return t;
                    },
                    o = function(e) {
                      var t = [];
                      for (var n = 0; n < e.length; n++)
                        t.push(i(e[n]));
                      return t;
                    },
                    u = function(n) {
                      return [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(e.pki.oids.data).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.algorithm).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, n.parameter.getBytes())]), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, n.content.getBytes())])];
                    },
                    a = function(n, r, i) {
                      var s = {},
                          o = [];
                      if (!t.validate(r, i, s, o))
                        throw {
                          message: "Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.",
                          errors: o
                        };
                      var u = t.derToOid(s.contentType);
                      if (u !== e.pki.oids.data)
                        throw {message: "Unsupported PKCS#7 message. Only wrapped ContentType Data supported."};
                      if (s.encryptedContent) {
                        var a = "";
                        if (e.util.isArray(s.encryptedContent))
                          for (var f = 0; f < s.encryptedContent.length; ++f) {
                            if (s.encryptedContent[f].type !== t.Type.OCTETSTRING)
                              throw {message: "Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects."};
                            a += s.encryptedContent[f].value;
                          }
                        else
                          a = s.encryptedContent;
                        n.encryptedContent = {
                          algorithm: t.derToOid(s.encAlgorithm),
                          parameter: e.util.createBuffer(s.encParameter.value),
                          content: e.util.createBuffer(a)
                        };
                      }
                      if (s.content) {
                        var a = "";
                        if (e.util.isArray(s.content))
                          for (var f = 0; f < s.content.length; ++f) {
                            if (s.content[f].type !== t.Type.OCTETSTRING)
                              throw {message: "Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects."};
                            a += s.content[f].value;
                          }
                        else
                          a = s.content;
                        n.content = e.util.createBuffer(a);
                      }
                      return n.version = s.version.charCodeAt(0), n.rawCapture = s, s;
                    },
                    f = function(t) {
                      if (t.encryptedContent.key === undefined)
                        throw {message: "Symmetric key not available."};
                      if (t.content === undefined) {
                        var n;
                        switch (t.encryptedContent.algorithm) {
                          case e.pki.oids["aes128-CBC"]:
                          case e.pki.oids["aes192-CBC"]:
                          case e.pki.oids["aes256-CBC"]:
                            n = e.aes.createDecryptionCipher(t.encryptedContent.key);
                            break;
                          case e.pki.oids.desCBC:
                          case e.pki.oids["des-EDE3-CBC"]:
                            n = e.des.createDecryptionCipher(t.encryptedContent.key);
                            break;
                          default:
                            throw {message: "Unsupported symmetric cipher, OID " + t.encryptedContent.algorithm};
                        }
                        n.start(t.encryptedContent.parameter), n.update(t.encryptedContent.content);
                        if (!n.finish())
                          throw {message: "Symmetric decryption failed."};
                        t.content = n.output;
                      }
                    };
                n.createSignedData = function() {
                  var r = null;
                  return r = {
                    type: e.pki.oids.signedData,
                    version: 1,
                    certificates: [],
                    crls: [],
                    digestAlgorithmIdentifiers: [],
                    contentInfo: null,
                    signerInfos: [],
                    fromAsn1: function(t) {
                      a(r, t, n.asn1.signedDataValidator), r.certificates = [], r.crls = [], r.digestAlgorithmIdentifiers = [], r.contentInfo = null, r.signerInfos = [];
                      var i = r.rawCapture.certificates.value;
                      for (var s = 0; s < i.length; ++s)
                        r.certificates.push(e.pki.certificateFromAsn1(i[s]));
                    },
                    toAsn1: function() {
                      if ("content" in r)
                        throw "Signing PKCS#7 content not yet implemented.";
                      r.contentInfo || r.sign();
                      var n = [];
                      for (var i = 0; i < r.certificates.length; ++i)
                        n.push(e.pki.certificateToAsn1(r.certificates[0]));
                      var s = [];
                      return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(r.type).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(r.version).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, r.digestAlgorithmIdentifiers), r.contentInfo, t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, n), t.create(t.Class.CONTEXT_SPECIFIC, 1, !0, s), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, r.signerInfos)])])]);
                    },
                    sign: function(n) {
                      if ("content" in r)
                        throw "PKCS#7 signing not yet implemented.";
                      typeof r.content != "object" && (r.contentInfo = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(e.pki.oids.data).getBytes())]), "content" in r && r.contentInfo.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, r.content)])));
                    },
                    verify: function() {
                      throw "PKCS#7 signature verification not yet implemented.";
                    },
                    addCertificate: function(t) {
                      typeof t == "string" && (t = e.pki.certificateFromPem(t)), r.certificates.push(t);
                    },
                    addCertificateRevokationList: function(e) {
                      throw "PKCS#7 CRL support not yet implemented.";
                    }
                  }, r;
                }, n.createEncryptedData = function() {
                  var t = null;
                  return t = {
                    type: e.pki.oids.encryptedData,
                    version: 0,
                    encryptedContent: {algorithm: e.pki.oids["aes256-CBC"]},
                    fromAsn1: function(e) {
                      a(t, e, n.asn1.encryptedDataValidator);
                    },
                    decrypt: function(e) {
                      e !== undefined && (t.encryptedContent.key = e), f(t);
                    }
                  }, t;
                }, n.createEnvelopedData = function() {
                  var r = null;
                  return r = {
                    type: e.pki.oids.envelopedData,
                    version: 0,
                    recipients: [],
                    encryptedContent: {algorithm: e.pki.oids["aes256-CBC"]},
                    fromAsn1: function(e) {
                      var t = a(r, e, n.asn1.envelopedDataValidator);
                      r.recipients = s(t.recipientInfos.value);
                    },
                    toAsn1: function() {
                      return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(r.type).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(r.version).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, o(r.recipients)), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, u(r.encryptedContent))])])]);
                    },
                    findRecipient: function(e) {
                      var t = e.issuer.attributes;
                      for (var n = 0; n < r.recipients.length; ++n) {
                        var i = r.recipients[n],
                            s = i.issuer;
                        if (i.serialNumber !== e.serialNumber)
                          continue;
                        if (s.length !== t.length)
                          continue;
                        var o = !0;
                        for (var u = 0; u < t.length; ++u)
                          if (s[u].type !== t[u].type || s[u].value !== t[u].value) {
                            o = !1;
                            break;
                          }
                        if (o)
                          return i;
                      }
                      return null;
                    },
                    decrypt: function(t, n) {
                      if (r.encryptedContent.key === undefined && t !== undefined && n !== undefined)
                        switch (t.encryptedContent.algorithm) {
                          case e.pki.oids.rsaEncryption:
                          case e.pki.oids.desCBC:
                            var i = n.decrypt(t.encryptedContent.content);
                            r.encryptedContent.key = e.util.createBuffer(i);
                            break;
                          default:
                            throw {message: "Unsupported asymmetric cipher, OID " + t.encryptedContent.algorithm};
                        }
                      f(r);
                    },
                    addRecipient: function(t) {
                      r.recipients.push({
                        version: 0,
                        issuer: t.subject.attributes,
                        serialNumber: t.serialNumber,
                        encryptedContent: {
                          algorithm: e.pki.oids.rsaEncryption,
                          key: t.publicKey
                        }
                      });
                    },
                    encrypt: function(t, n) {
                      if (r.encryptedContent.content === undefined) {
                        n = n || r.encryptedContent.algorithm, t = t || r.encryptedContent.key;
                        var i,
                            s,
                            o;
                        switch (n) {
                          case e.pki.oids["aes128-CBC"]:
                            i = 16, s = 16, o = e.aes.createEncryptionCipher;
                            break;
                          case e.pki.oids["aes192-CBC"]:
                            i = 24, s = 16, o = e.aes.createEncryptionCipher;
                            break;
                          case e.pki.oids["aes256-CBC"]:
                            i = 32, s = 16, o = e.aes.createEncryptionCipher;
                            break;
                          case e.pki.oids["des-EDE3-CBC"]:
                            i = 24, s = 8, o = e.des.createEncryptionCipher;
                            break;
                          default:
                            throw {message: "Unsupported symmetric cipher, OID " + n};
                        }
                        if (t === undefined)
                          t = e.util.createBuffer(e.random.getBytes(i));
                        else if (t.length() != i)
                          throw {message: "Symmetric key has wrong length, got " + t.length() + " bytes, expected " + i};
                        r.encryptedContent.algorithm = n, r.encryptedContent.key = t, r.encryptedContent.parameter = e.util.createBuffer(e.random.getBytes(s));
                        var u = o(t);
                        u.start(r.encryptedContent.parameter.copy()), u.update(r.content);
                        if (!u.finish())
                          throw {message: "Symmetric encryption failed."};
                        r.encryptedContent.content = u.output;
                      }
                      for (var a = 0; a < r.recipients.length; a++) {
                        var f = r.recipients[a];
                        if (f.encryptedContent.content !== undefined)
                          continue;
                        switch (f.encryptedContent.algorithm) {
                          case e.pki.oids.rsaEncryption:
                            f.encryptedContent.content = f.encryptedContent.key.encrypt(r.encryptedContent.key.data);
                            break;
                          default:
                            throw {message: "Unsupported asymmetric cipher, OID " + f.encryptedContent.algorithm};
                        }
                      }
                    }
                  }, r;
                };
              }
              var r = "pkcs7";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pkcs7", ["require", "module", "./aes", "./asn1", "./des", "./oids", "./pem", "./pkcs7asn1", "./random", "./util", "./x509"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = "forge.task",
                    n = 0,
                    r = {},
                    i = 0;
                e.debug.set(t, "tasks", r);
                var s = {};
                e.debug.set(t, "queues", s);
                var o = "?",
                    u = 30,
                    a = 20,
                    f = "ready",
                    l = "running",
                    c = "blocked",
                    h = "sleeping",
                    p = "done",
                    d = "error",
                    v = "stop",
                    m = "start",
                    g = "block",
                    y = "unblock",
                    b = "sleep",
                    w = "wakeup",
                    E = "cancel",
                    S = "fail",
                    x = {};
                x[f] = {}, x[f][v] = f, x[f][m] = l, x[f][E] = p, x[f][S] = d, x[l] = {}, x[l][v] = f, x[l][m] = l, x[l][g] = c, x[l][y] = l, x[l][b] = h, x[l][w] = l, x[l][E] = p, x[l][S] = d, x[c] = {}, x[c][v] = c, x[c][m] = c, x[c][g] = c, x[c][y] = c, x[c][b] = c, x[c][w] = c, x[c][E] = p, x[c][S] = d, x[h] = {}, x[h][v] = h, x[h][m] = h, x[h][g] = h, x[h][y] = h, x[h][b] = h, x[h][w] = h, x[h][E] = p, x[h][S] = d, x[p] = {}, x[p][v] = p, x[p][m] = p, x[p][g] = p, x[p][y] = p, x[p][b] = p, x[p][w] = p, x[p][E] = p, x[p][S] = d, x[d] = {}, x[d][v] = d, x[d][m] = d, x[d][g] = d, x[d][y] = d, x[d][b] = d, x[d][w] = d, x[d][E] = d, x[d][S] = d;
                var T = function(s) {
                  this.id = -1, this.name = s.name || o, this.parent = s.parent || null, this.run = s.run, this.subtasks = [], this.error = !1, this.state = f, this.blocks = 0, this.timeoutId = null, this.swapTime = null, this.userData = null, this.id = i++, r[this.id] = this, n >= 1 && e.log.verbose(t, "[%s][%s] init", this.id, this.name, this);
                };
                T.prototype.debug = function(n) {
                  n = n || "", e.log.debug(t, n, "[%s][%s] task:", this.id, this.name, this, "subtasks:", this.subtasks.length, "queue:", s);
                }, T.prototype.next = function(e, t) {
                  typeof e == "function" && (t = e, e = this.name);
                  var n = new T({
                    run: t,
                    name: e,
                    parent: this
                  });
                  return n.state = l, n.type = this.type, n.successCallback = this.successCallback || null, n.failureCallback = this.failureCallback || null, this.subtasks.push(n), this;
                }, T.prototype.parallel = function(t, n) {
                  return e.util.isArray(t) && (n = t, t = this.name), this.next(t, function(r) {
                    var i = r;
                    i.block(n.length);
                    var s = function(t, r) {
                      e.task.start({
                        type: t,
                        run: function(e) {
                          n[r](e);
                        },
                        success: function(e) {
                          i.unblock();
                        },
                        failure: function(e) {
                          i.unblock();
                        }
                      });
                    };
                    for (var o = 0; o < n.length; o++) {
                      var u = t + "__parallel-" + r.id + "-" + o,
                          a = o;
                      s(u, a);
                    }
                  });
                }, T.prototype.stop = function() {
                  this.state = x[this.state][v];
                }, T.prototype.start = function() {
                  this.error = !1, this.state = x[this.state][m], this.state === l && (this.start = new Date, this.run(this), C(this, 0));
                }, T.prototype.block = function(e) {
                  e = typeof e == "undefined" ? 1 : e, this.blocks += e, this.blocks > 0 && (this.state = x[this.state][g]);
                }, T.prototype.unblock = function(e) {
                  return e = typeof e == "undefined" ? 1 : e, this.blocks -= e, this.blocks === 0 && this.state !== p && (this.state = l, C(this, 0)), this.blocks;
                }, T.prototype.sleep = function(e) {
                  e = typeof e == "undefined" ? 0 : e, this.state = x[this.state][b];
                  var t = this;
                  this.timeoutId = setTimeout(function() {
                    t.timeoutId = null, t.state = l, C(t, 0);
                  }, e);
                }, T.prototype.wait = function(e) {
                  e.wait(this);
                }, T.prototype.wakeup = function() {
                  this.state === h && (cancelTimeout(this.timeoutId), this.timeoutId = null, this.state = l, C(this, 0));
                }, T.prototype.cancel = function() {
                  this.state = x[this.state][E], this.permitsNeeded = 0, this.timeoutId !== null && (cancelTimeout(this.timeoutId), this.timeoutId = null), this.subtasks = [];
                }, T.prototype.fail = function(e) {
                  this.error = !0, k(this, !0);
                  if (e)
                    e.error = this.error, e.swapTime = this.swapTime, e.userData = this.userData, C(e, 0);
                  else {
                    if (this.parent !== null) {
                      var t = this.parent;
                      while (t.parent !== null)
                        t.error = this.error, t.swapTime = this.swapTime, t.userData = this.userData, t = t.parent;
                      k(t, !0);
                    }
                    this.failureCallback && this.failureCallback(this);
                  }
                };
                var N = function(e) {
                  e.error = !1, e.state = x[e.state][m], setTimeout(function() {
                    e.state === l && (e.swapTime = +(new Date), e.run(e), C(e, 0));
                  }, 0);
                },
                    C = function(e, t) {
                      var n = t > u || +(new Date) - e.swapTime > a,
                          r = function(t) {
                            t++;
                            if (e.state === l) {
                              n && (e.swapTime = +(new Date));
                              if (e.subtasks.length > 0) {
                                var r = e.subtasks.shift();
                                r.error = e.error, r.swapTime = e.swapTime, r.userData = e.userData, r.run(r), r.error || C(r, t);
                              } else
                                k(e), e.error || e.parent !== null && (e.parent.error = e.error, e.parent.swapTime = e.swapTime, e.parent.userData = e.userData, C(e.parent, t));
                            }
                          };
                      n ? setTimeout(r, 0) : r(t);
                    },
                    k = function(i, o) {
                      i.state = p, delete r[i.id], n >= 1 && e.log.verbose(t, "[%s][%s] finish", i.id, i.name, i), i.parent === null && (i.type in s ? s[i.type].length === 0 ? e.log.error(t, "[%s][%s] task queue empty [%s]", i.id, i.name, i.type) : s[i.type][0] !== i ? e.log.error(t, "[%s][%s] task not first in queue [%s]", i.id, i.name, i.type) : (s[i.type].shift(), s[i.type].length === 0 ? (n >= 1 && e.log.verbose(t, "[%s][%s] delete queue [%s]", i.id, i.name, i.type), delete s[i.type]) : (n >= 1 && e.log.verbose(t, "[%s][%s] queue start next [%s] remain:%s", i.id, i.name, i.type, s[i.type].length), s[i.type][0].start())) : e.log.error(t, "[%s][%s] task queue missing [%s]", i.id, i.name, i.type), o || (i.error && i.failureCallback ? i.failureCallback(i) : !i.error && i.successCallback && i.successCallback(i)));
                    };
                e.task = e.task || {}, e.task.start = function(r) {
                  var i = new T({
                    run: r.run,
                    name: r.name || o
                  });
                  i.type = r.type, i.successCallback = r.success || null, i.failureCallback = r.failure || null, i.type in s ? s[r.type].push(i) : (n >= 1 && e.log.verbose(t, "[%s][%s] create queue [%s]", i.id, i.name, i.type), s[i.type] = [i], N(i));
                }, e.task.cancel = function(e) {
                  e in s && (s[e] = [s[e][0]]);
                }, e.task.createCondition = function() {
                  var e = {tasks: {}};
                  return e.wait = function(t) {
                    t.id in e.tasks || (t.block(), e.tasks[t.id] = t);
                  }, e.notify = function() {
                    var t = e.tasks;
                    e.tasks = {};
                    for (var n in t)
                      t[n].unblock();
                  }, e;
                };
              }
              var r = "task";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/task", ["require", "module", "./debug", "./log", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              var e = "forge";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports) {
                  typeof forge == "undefined" && (forge = {disableNativeCode: !1});
                  return;
                }
                var r = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var i,
                  s = function(t, n) {
                    n.exports = function(n) {
                      var r = i.map(function(e) {
                        return t(e);
                      });
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[e])
                        return n[e];
                      n.defined[e] = !0;
                      for (var s = 0; s < r.length; ++s)
                        r[s](n);
                      return n;
                    }, n.exports.disableNativeCode = !1, n.exports(n.exports);
                  },
                  o = n;
              n = function(e, t) {
                return i = typeof e == "string" ? t.slice(2) : e.slice(2), r ? (delete n, o.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = o, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/forge", ["require", "module", "./aes", "./aesCipherSuites", "./asn1", "./debug", "./des", "./hmac", "./log", "./pbkdf2", "./pem", "./pkcs7", "./pkcs1", "./pkcs12", "./pki", "./prng", "./pss", "./random", "./rc2", "./task", "./tls", "./util", "./md", "./mgf1"], function() {
                s.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), window.forge = t("js/forge");
          })();
        }).call(this, require("sycGbZ"));
      }, {"sycGbZ": 51}],
      6: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var BigInteger = require("jsbn");
          var ECPointFp = require("./lib/ec.js").ECPointFp;
          exports.ECCurves = require("./lib/sec.js");
          function unstupid(hex, len) {
            return (hex.length >= len) ? hex : unstupid("0" + hex, len);
          }
          exports.ECKey = function(curve, key, isPublic) {
            var priv;
            var c = curve();
            var n = c.getN();
            var bytes = Math.floor(n.bitLength() / 8);
            if (key) {
              if (isPublic) {
                if (key.length != bytes * 2 + 1)
                  return false;
                var curve = c.getCurve();
                var x = key.slice(1, bytes + 1);
                var y = key.slice(bytes + 1);
                this.P = new ECPointFp(curve, curve.fromBigInteger(new BigInteger(x.toString("hex"), 16)), curve.fromBigInteger(new BigInteger(y.toString("hex"), 16)));
              } else {
                if (key.length != bytes)
                  return false;
                priv = new BigInteger(key.toString("hex"), 16);
              }
            } else {
              var n1 = n.subtract(BigInteger.ONE);
              var r = new BigInteger(crypto.randomBytes(n.bitLength()));
              priv = r.mod(n1).add(BigInteger.ONE);
              this.P = c.getG().multiply(priv);
            }
            if (this.P) {
              var pubhex = unstupid(this.P.getX().toBigInteger().toString(16), bytes * 2) + unstupid(this.P.getY().toBigInteger().toString(16), bytes * 2);
              this.PublicKey = new Buffer("04" + pubhex, "hex");
            }
            if (priv) {
              this.PrivateKey = new Buffer(unstupid(priv.toString(16), bytes * 2), "hex");
              this.deriveSharedSecret = function(key) {
                if (!key || !key.P)
                  return false;
                var S = key.P.multiply(priv);
                return new Buffer(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
              };
            }
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "./lib/ec.js": 7,
        "./lib/sec.js": 8,
        "buffer": 29,
        "crypto": 35,
        "jsbn": 9
      }],
      7: [function(require, module, exports) {
        var BigInteger = require('jsbn');
        var Barrett = BigInteger.prototype.Barrett;
        function ECFieldElementFp(q, x) {
          this.x = x;
          this.q = q;
        }
        function feFpEquals(other) {
          if (other == this)
            return true;
          return (this.q.equals(other.q) && this.x.equals(other.x));
        }
        function feFpToBigInteger() {
          return this.x;
        }
        function feFpNegate() {
          return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
        }
        function feFpAdd(b) {
          return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
        }
        function feFpSubtract(b) {
          return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
        }
        function feFpMultiply(b) {
          return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
        }
        function feFpSquare() {
          return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
        }
        function feFpDivide(b) {
          return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
        }
        ECFieldElementFp.prototype.equals = feFpEquals;
        ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
        ECFieldElementFp.prototype.negate = feFpNegate;
        ECFieldElementFp.prototype.add = feFpAdd;
        ECFieldElementFp.prototype.subtract = feFpSubtract;
        ECFieldElementFp.prototype.multiply = feFpMultiply;
        ECFieldElementFp.prototype.square = feFpSquare;
        ECFieldElementFp.prototype.divide = feFpDivide;
        function ECPointFp(curve, x, y, z) {
          this.curve = curve;
          this.x = x;
          this.y = y;
          if (z == null) {
            this.z = BigInteger.ONE;
          } else {
            this.z = z;
          }
          this.zinv = null;
        }
        function pointFpGetX() {
          if (this.zinv == null) {
            this.zinv = this.z.modInverse(this.curve.q);
          }
          var r = this.x.toBigInteger().multiply(this.zinv);
          this.curve.reduce(r);
          return this.curve.fromBigInteger(r);
        }
        function pointFpGetY() {
          if (this.zinv == null) {
            this.zinv = this.z.modInverse(this.curve.q);
          }
          var r = this.y.toBigInteger().multiply(this.zinv);
          this.curve.reduce(r);
          return this.curve.fromBigInteger(r);
        }
        function pointFpEquals(other) {
          if (other == this)
            return true;
          if (this.isInfinity())
            return other.isInfinity();
          if (other.isInfinity())
            return this.isInfinity();
          var u,
              v;
          u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
          if (!u.equals(BigInteger.ZERO))
            return false;
          v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
          return v.equals(BigInteger.ZERO);
        }
        function pointFpIsInfinity() {
          if ((this.x == null) && (this.y == null))
            return true;
          return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
        }
        function pointFpNegate() {
          return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
        }
        function pointFpAdd(b) {
          if (this.isInfinity())
            return b;
          if (b.isInfinity())
            return this;
          var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
          var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
          if (BigInteger.ZERO.equals(v)) {
            if (BigInteger.ZERO.equals(u)) {
              return this.twice();
            }
            return this.curve.getInfinity();
          }
          var THREE = new BigInteger("3");
          var x1 = this.x.toBigInteger();
          var y1 = this.y.toBigInteger();
          var x2 = b.x.toBigInteger();
          var y2 = b.y.toBigInteger();
          var v2 = v.square();
          var v3 = v2.multiply(v);
          var x1v2 = x1.multiply(v2);
          var zu2 = u.square().multiply(this.z);
          var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
          var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
          var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
          return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
        }
        function pointFpTwice() {
          if (this.isInfinity())
            return this;
          if (this.y.toBigInteger().signum() == 0)
            return this.curve.getInfinity();
          var THREE = new BigInteger("3");
          var x1 = this.x.toBigInteger();
          var y1 = this.y.toBigInteger();
          var y1z1 = y1.multiply(this.z);
          var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
          var a = this.curve.a.toBigInteger();
          var w = x1.square().multiply(THREE);
          if (!BigInteger.ZERO.equals(a)) {
            w = w.add(this.z.square().multiply(a));
          }
          w = w.mod(this.curve.q);
          var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
          var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
          var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
          return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
        }
        function pointFpMultiply(k) {
          if (this.isInfinity())
            return this;
          if (k.signum() == 0)
            return this.curve.getInfinity();
          var e = k;
          var h = e.multiply(new BigInteger("3"));
          var neg = this.negate();
          var R = this;
          var i;
          for (i = h.bitLength() - 2; i > 0; --i) {
            R = R.twice();
            var hBit = h.testBit(i);
            var eBit = e.testBit(i);
            if (hBit != eBit) {
              R = R.add(hBit ? this : neg);
            }
          }
          return R;
        }
        function pointFpMultiplyTwo(j, x, k) {
          var i;
          if (j.bitLength() > k.bitLength())
            i = j.bitLength() - 1;
          else
            i = k.bitLength() - 1;
          var R = this.curve.getInfinity();
          var both = this.add(x);
          while (i >= 0) {
            R = R.twice();
            if (j.testBit(i)) {
              if (k.testBit(i)) {
                R = R.add(both);
              } else {
                R = R.add(this);
              }
            } else {
              if (k.testBit(i)) {
                R = R.add(x);
              }
            }
            --i;
          }
          return R;
        }
        ECPointFp.prototype.getX = pointFpGetX;
        ECPointFp.prototype.getY = pointFpGetY;
        ECPointFp.prototype.equals = pointFpEquals;
        ECPointFp.prototype.isInfinity = pointFpIsInfinity;
        ECPointFp.prototype.negate = pointFpNegate;
        ECPointFp.prototype.add = pointFpAdd;
        ECPointFp.prototype.twice = pointFpTwice;
        ECPointFp.prototype.multiply = pointFpMultiply;
        ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
        function ECCurveFp(q, a, b) {
          this.q = q;
          this.a = this.fromBigInteger(a);
          this.b = this.fromBigInteger(b);
          this.infinity = new ECPointFp(this, null, null);
          this.reducer = new Barrett(this.q);
        }
        function curveFpGetQ() {
          return this.q;
        }
        function curveFpGetA() {
          return this.a;
        }
        function curveFpGetB() {
          return this.b;
        }
        function curveFpEquals(other) {
          if (other == this)
            return true;
          return (this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
        }
        function curveFpGetInfinity() {
          return this.infinity;
        }
        function curveFpFromBigInteger(x) {
          return new ECFieldElementFp(this.q, x);
        }
        function curveReduce(x) {
          this.reducer.reduce(x);
        }
        function curveFpDecodePointHex(s) {
          switch (parseInt(s.substr(0, 2), 16)) {
            case 0:
              return this.infinity;
            case 2:
            case 3:
              return null;
            case 4:
            case 6:
            case 7:
              var len = (s.length - 2) / 2;
              var xHex = s.substr(2, len);
              var yHex = s.substr(len + 2, len);
              return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));
            default:
              return null;
          }
        }
        function curveFpEncodePointHex(p) {
          if (p.isInfinity())
            return "00";
          var xHex = p.getX().toBigInteger().toString(16);
          var yHex = p.getY().toBigInteger().toString(16);
          var oLen = this.getQ().toString(16).length;
          if ((oLen % 2) != 0)
            oLen++;
          while (xHex.length < oLen) {
            xHex = "0" + xHex;
          }
          while (yHex.length < oLen) {
            yHex = "0" + yHex;
          }
          return "04" + xHex + yHex;
        }
        ECCurveFp.prototype.getQ = curveFpGetQ;
        ECCurveFp.prototype.getA = curveFpGetA;
        ECCurveFp.prototype.getB = curveFpGetB;
        ECCurveFp.prototype.equals = curveFpEquals;
        ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
        ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
        ECCurveFp.prototype.reduce = curveReduce;
        ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
        ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
        var exports = {
          ECCurveFp: ECCurveFp,
          ECPointFp: ECPointFp,
          ECFieldElementFp: ECFieldElementFp
        };
        module.exports = exports;
      }, {"jsbn": 9}],
      8: [function(require, module, exports) {
        var BigInteger = require('jsbn');
        var ECCurveFp = require('./ec.js').ECCurveFp;
        function X9ECParameters(curve, g, n, h) {
          this.curve = curve;
          this.g = g;
          this.n = n;
          this.h = h;
        }
        function x9getCurve() {
          return this.curve;
        }
        function x9getG() {
          return this.g;
        }
        function x9getN() {
          return this.n;
        }
        function x9getH() {
          return this.h;
        }
        X9ECParameters.prototype.getCurve = x9getCurve;
        X9ECParameters.prototype.getG = x9getG;
        X9ECParameters.prototype.getN = x9getN;
        X9ECParameters.prototype.getH = x9getH;
        function fromHex(s) {
          return new BigInteger(s, 16);
        }
        function secp128r1() {
          var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
          var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
          var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "161FF7528B899B2D0C28607CA52C5B86" + "CF5AC8395BAFEB13C02DA292DDED7A83");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp160k1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
          var a = BigInteger.ZERO;
          var b = fromHex("7");
          var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB" + "938CF935318FDCED6BC28286531733C3F03C4FEE");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp160r1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
          var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
          var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "4A96B5688EF573284664698968C38BB913CBFC82" + "23A628553168947D59DCC912042351377AC5FB32");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp192k1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
          var a = BigInteger.ZERO;
          var b = fromHex("3");
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D" + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp192r1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
          var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012" + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp224r1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
          var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21" + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp256r1() {
          var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
          var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
          var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296" + "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
          return new X9ECParameters(curve, G, n, h);
        }
        function getSECCurveByName(name) {
          if (name == "secp128r1")
            return secp128r1();
          if (name == "secp160k1")
            return secp160k1();
          if (name == "secp160r1")
            return secp160r1();
          if (name == "secp192k1")
            return secp192k1();
          if (name == "secp192r1")
            return secp192r1();
          if (name == "secp224r1")
            return secp224r1();
          if (name == "secp256r1")
            return secp256r1();
          return null;
        }
        module.exports = {
          "secp128r1": secp128r1,
          "secp160k1": secp160k1,
          "secp160r1": secp160r1,
          "secp192k1": secp192k1,
          "secp192r1": secp192r1,
          "secp224r1": secp224r1,
          "secp256r1": secp256r1
        };
      }, {
        "./ec.js": 7,
        "jsbn": 9
      }],
      9: [function(require, module, exports) {
        (function() {
          var dbits;
          var canary = 0xdeadbeefcafe;
          var j_lm = ((canary & 0xffffff) == 0xefcafe);
          function BigInteger(a, b, c) {
            if (a != null)
              if ("number" == typeof a)
                this.fromNumber(a, b, c);
              else if (b == null && "string" != typeof a)
                this.fromString(a, 256);
              else
                this.fromString(a, b);
          }
          function nbi() {
            return new BigInteger(null);
          }
          function am1(i, x, w, j, c, n) {
            while (--n >= 0) {
              var v = x * this[i++] + w[j] + c;
              c = Math.floor(v / 0x4000000);
              w[j++] = v & 0x3ffffff;
            }
            return c;
          }
          function am2(i, x, w, j, c, n) {
            var xl = x & 0x7fff,
                xh = x >> 15;
            while (--n >= 0) {
              var l = this[i] & 0x7fff;
              var h = this[i++] >> 15;
              var m = xh * l + h * xl;
              l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
              c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
              w[j++] = l & 0x3fffffff;
            }
            return c;
          }
          function am3(i, x, w, j, c, n) {
            var xl = x & 0x3fff,
                xh = x >> 14;
            while (--n >= 0) {
              var l = this[i] & 0x3fff;
              var h = this[i++] >> 14;
              var m = xh * l + h * xl;
              l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
              c = (l >> 28) + (m >> 14) + xh * h;
              w[j++] = l & 0xfffffff;
            }
            return c;
          }
          var inBrowser = typeof navigator !== "undefined";
          if (inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
            BigInteger.prototype.am = am2;
            dbits = 30;
          } else if (inBrowser && j_lm && (navigator.appName != "Netscape")) {
            BigInteger.prototype.am = am1;
            dbits = 26;
          } else {
            BigInteger.prototype.am = am3;
            dbits = 28;
          }
          BigInteger.prototype.DB = dbits;
          BigInteger.prototype.DM = ((1 << dbits) - 1);
          BigInteger.prototype.DV = (1 << dbits);
          var BI_FP = 52;
          BigInteger.prototype.FV = Math.pow(2, BI_FP);
          BigInteger.prototype.F1 = BI_FP - dbits;
          BigInteger.prototype.F2 = 2 * dbits - BI_FP;
          var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
          var BI_RC = new Array();
          var rr,
              vv;
          rr = "0".charCodeAt(0);
          for (vv = 0; vv <= 9; ++vv)
            BI_RC[rr++] = vv;
          rr = "a".charCodeAt(0);
          for (vv = 10; vv < 36; ++vv)
            BI_RC[rr++] = vv;
          rr = "A".charCodeAt(0);
          for (vv = 10; vv < 36; ++vv)
            BI_RC[rr++] = vv;
          function int2char(n) {
            return BI_RM.charAt(n);
          }
          function intAt(s, i) {
            var c = BI_RC[s.charCodeAt(i)];
            return (c == null) ? -1 : c;
          }
          function bnpCopyTo(r) {
            for (var i = this.t - 1; i >= 0; --i)
              r[i] = this[i];
            r.t = this.t;
            r.s = this.s;
          }
          function bnpFromInt(x) {
            this.t = 1;
            this.s = (x < 0) ? -1 : 0;
            if (x > 0)
              this[0] = x;
            else if (x < -1)
              this[0] = x + DV;
            else
              this.t = 0;
          }
          function nbv(i) {
            var r = nbi();
            r.fromInt(i);
            return r;
          }
          function bnpFromString(s, b) {
            var k;
            if (b == 16)
              k = 4;
            else if (b == 8)
              k = 3;
            else if (b == 256)
              k = 8;
            else if (b == 2)
              k = 1;
            else if (b == 32)
              k = 5;
            else if (b == 4)
              k = 2;
            else {
              this.fromRadix(s, b);
              return;
            }
            this.t = 0;
            this.s = 0;
            var i = s.length,
                mi = false,
                sh = 0;
            while (--i >= 0) {
              var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
              if (x < 0) {
                if (s.charAt(i) == "-")
                  mi = true;
                continue;
              }
              mi = false;
              if (sh == 0)
                this[this.t++] = x;
              else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
              } else
                this[this.t - 1] |= x << sh;
              sh += k;
              if (sh >= this.DB)
                sh -= this.DB;
            }
            if (k == 8 && (s[0] & 0x80) != 0) {
              this.s = -1;
              if (sh > 0)
                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
            this.clamp();
            if (mi)
              BigInteger.ZERO.subTo(this, this);
          }
          function bnpClamp() {
            var c = this.s & this.DM;
            while (this.t > 0 && this[this.t - 1] == c)
              --this.t;
          }
          function bnToString(b) {
            if (this.s < 0)
              return "-" + this.negate().toString(b);
            var k;
            if (b == 16)
              k = 4;
            else if (b == 8)
              k = 3;
            else if (b == 2)
              k = 1;
            else if (b == 32)
              k = 5;
            else if (b == 4)
              k = 2;
            else
              return this.toRadix(b);
            var km = (1 << k) - 1,
                d,
                m = false,
                r = "",
                i = this.t;
            var p = this.DB - (i * this.DB) % k;
            if (i-- > 0) {
              if (p < this.DB && (d = this[i] >> p) > 0) {
                m = true;
                r = int2char(d);
              }
              while (i >= 0) {
                if (p < k) {
                  d = (this[i] & ((1 << p) - 1)) << (k - p);
                  d |= this[--i] >> (p += this.DB - k);
                } else {
                  d = (this[i] >> (p -= k)) & km;
                  if (p <= 0) {
                    p += this.DB;
                    --i;
                  }
                }
                if (d > 0)
                  m = true;
                if (m)
                  r += int2char(d);
              }
            }
            return m ? r : "0";
          }
          function bnNegate() {
            var r = nbi();
            BigInteger.ZERO.subTo(this, r);
            return r;
          }
          function bnAbs() {
            return (this.s < 0) ? this.negate() : this;
          }
          function bnCompareTo(a) {
            var r = this.s - a.s;
            if (r != 0)
              return r;
            var i = this.t;
            r = i - a.t;
            if (r != 0)
              return (this.s < 0) ? -r : r;
            while (--i >= 0)
              if ((r = this[i] - a[i]) != 0)
                return r;
            return 0;
          }
          function nbits(x) {
            var r = 1,
                t;
            if ((t = x >>> 16) != 0) {
              x = t;
              r += 16;
            }
            if ((t = x >> 8) != 0) {
              x = t;
              r += 8;
            }
            if ((t = x >> 4) != 0) {
              x = t;
              r += 4;
            }
            if ((t = x >> 2) != 0) {
              x = t;
              r += 2;
            }
            if ((t = x >> 1) != 0) {
              x = t;
              r += 1;
            }
            return r;
          }
          function bnBitLength() {
            if (this.t <= 0)
              return 0;
            return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
          }
          function bnpDLShiftTo(n, r) {
            var i;
            for (i = this.t - 1; i >= 0; --i)
              r[i + n] = this[i];
            for (i = n - 1; i >= 0; --i)
              r[i] = 0;
            r.t = this.t + n;
            r.s = this.s;
          }
          function bnpDRShiftTo(n, r) {
            for (var i = n; i < this.t; ++i)
              r[i - n] = this[i];
            r.t = Math.max(this.t - n, 0);
            r.s = this.s;
          }
          function bnpLShiftTo(n, r) {
            var bs = n % this.DB;
            var cbs = this.DB - bs;
            var bm = (1 << cbs) - 1;
            var ds = Math.floor(n / this.DB),
                c = (this.s << bs) & this.DM,
                i;
            for (i = this.t - 1; i >= 0; --i) {
              r[i + ds + 1] = (this[i] >> cbs) | c;
              c = (this[i] & bm) << bs;
            }
            for (i = ds - 1; i >= 0; --i)
              r[i] = 0;
            r[ds] = c;
            r.t = this.t + ds + 1;
            r.s = this.s;
            r.clamp();
          }
          function bnpRShiftTo(n, r) {
            r.s = this.s;
            var ds = Math.floor(n / this.DB);
            if (ds >= this.t) {
              r.t = 0;
              return;
            }
            var bs = n % this.DB;
            var cbs = this.DB - bs;
            var bm = (1 << bs) - 1;
            r[0] = this[ds] >> bs;
            for (var i = ds + 1; i < this.t; ++i) {
              r[i - ds - 1] |= (this[i] & bm) << cbs;
              r[i - ds] = this[i] >> bs;
            }
            if (bs > 0)
              r[this.t - ds - 1] |= (this.s & bm) << cbs;
            r.t = this.t - ds;
            r.clamp();
          }
          function bnpSubTo(a, r) {
            var i = 0,
                c = 0,
                m = Math.min(a.t, this.t);
            while (i < m) {
              c += this[i] - a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            if (a.t < this.t) {
              c -= a.s;
              while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += this.s;
            } else {
              c += this.s;
              while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
              }
              c -= a.s;
            }
            r.s = (c < 0) ? -1 : 0;
            if (c < -1)
              r[i++] = this.DV + c;
            else if (c > 0)
              r[i++] = c;
            r.t = i;
            r.clamp();
          }
          function bnpMultiplyTo(a, r) {
            var x = this.abs(),
                y = a.abs();
            var i = x.t;
            r.t = i + y.t;
            while (--i >= 0)
              r[i] = 0;
            for (i = 0; i < y.t; ++i)
              r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
            r.s = 0;
            r.clamp();
            if (this.s != a.s)
              BigInteger.ZERO.subTo(r, r);
          }
          function bnpSquareTo(r) {
            var x = this.abs();
            var i = r.t = 2 * x.t;
            while (--i >= 0)
              r[i] = 0;
            for (i = 0; i < x.t - 1; ++i) {
              var c = x.am(i, x[i], r, 2 * i, 0, 1);
              if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
              }
            }
            if (r.t > 0)
              r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
            r.s = 0;
            r.clamp();
          }
          function bnpDivRemTo(m, q, r) {
            var pm = m.abs();
            if (pm.t <= 0)
              return;
            var pt = this.abs();
            if (pt.t < pm.t) {
              if (q != null)
                q.fromInt(0);
              if (r != null)
                this.copyTo(r);
              return;
            }
            if (r == null)
              r = nbi();
            var y = nbi(),
                ts = this.s,
                ms = m.s;
            var nsh = this.DB - nbits(pm[pm.t - 1]);
            if (nsh > 0) {
              pm.lShiftTo(nsh, y);
              pt.lShiftTo(nsh, r);
            } else {
              pm.copyTo(y);
              pt.copyTo(r);
            }
            var ys = y.t;
            var y0 = y[ys - 1];
            if (y0 == 0)
              return;
            var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
            var d1 = this.FV / yt,
                d2 = (1 << this.F1) / yt,
                e = 1 << this.F2;
            var i = r.t,
                j = i - ys,
                t = (q == null) ? nbi() : q;
            y.dlShiftTo(j, t);
            if (r.compareTo(t) >= 0) {
              r[r.t++] = 1;
              r.subTo(t, r);
            }
            BigInteger.ONE.dlShiftTo(ys, t);
            t.subTo(y, y);
            while (y.t < ys)
              y[y.t++] = 0;
            while (--j >= 0) {
              var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
              if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd)
                  r.subTo(t, r);
              }
            }
            if (q != null) {
              r.drShiftTo(ys, q);
              if (ts != ms)
                BigInteger.ZERO.subTo(q, q);
            }
            r.t = ys;
            r.clamp();
            if (nsh > 0)
              r.rShiftTo(nsh, r);
            if (ts < 0)
              BigInteger.ZERO.subTo(r, r);
          }
          function bnMod(a) {
            var r = nbi();
            this.abs().divRemTo(a, null, r);
            if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
              a.subTo(r, r);
            return r;
          }
          function Classic(m) {
            this.m = m;
          }
          function cConvert(x) {
            if (x.s < 0 || x.compareTo(this.m) >= 0)
              return x.mod(this.m);
            else
              return x;
          }
          function cRevert(x) {
            return x;
          }
          function cReduce(x) {
            x.divRemTo(this.m, null, x);
          }
          function cMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          function cSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          Classic.prototype.convert = cConvert;
          Classic.prototype.revert = cRevert;
          Classic.prototype.reduce = cReduce;
          Classic.prototype.mulTo = cMulTo;
          Classic.prototype.sqrTo = cSqrTo;
          function bnpInvDigit() {
            if (this.t < 1)
              return 0;
            var x = this[0];
            if ((x & 1) == 0)
              return 0;
            var y = x & 3;
            y = (y * (2 - (x & 0xf) * y)) & 0xf;
            y = (y * (2 - (x & 0xff) * y)) & 0xff;
            y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;
            y = (y * (2 - x * y % this.DV)) % this.DV;
            return (y > 0) ? this.DV - y : -y;
          }
          function Montgomery(m) {
            this.m = m;
            this.mp = m.invDigit();
            this.mpl = this.mp & 0x7fff;
            this.mph = this.mp >> 15;
            this.um = (1 << (m.DB - 15)) - 1;
            this.mt2 = 2 * m.t;
          }
          function montConvert(x) {
            var r = nbi();
            x.abs().dlShiftTo(this.m.t, r);
            r.divRemTo(this.m, null, r);
            if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
              this.m.subTo(r, r);
            return r;
          }
          function montRevert(x) {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
          }
          function montReduce(x) {
            while (x.t <= this.mt2)
              x[x.t++] = 0;
            for (var i = 0; i < this.m.t; ++i) {
              var j = x[i] & 0x7fff;
              var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
              j = i + this.m.t;
              x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
              while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
              }
            }
            x.clamp();
            x.drShiftTo(this.m.t, x);
            if (x.compareTo(this.m) >= 0)
              x.subTo(this.m, x);
          }
          function montSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          function montMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          Montgomery.prototype.convert = montConvert;
          Montgomery.prototype.revert = montRevert;
          Montgomery.prototype.reduce = montReduce;
          Montgomery.prototype.mulTo = montMulTo;
          Montgomery.prototype.sqrTo = montSqrTo;
          function bnpIsEven() {
            return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
          }
          function bnpExp(e, z) {
            if (e > 0xffffffff || e < 1)
              return BigInteger.ONE;
            var r = nbi(),
                r2 = nbi(),
                g = z.convert(this),
                i = nbits(e) - 1;
            g.copyTo(r);
            while (--i >= 0) {
              z.sqrTo(r, r2);
              if ((e & (1 << i)) > 0)
                z.mulTo(r2, g, r);
              else {
                var t = r;
                r = r2;
                r2 = t;
              }
            }
            return z.revert(r);
          }
          function bnModPowInt(e, m) {
            var z;
            if (e < 256 || m.isEven())
              z = new Classic(m);
            else
              z = new Montgomery(m);
            return this.exp(e, z);
          }
          BigInteger.prototype.copyTo = bnpCopyTo;
          BigInteger.prototype.fromInt = bnpFromInt;
          BigInteger.prototype.fromString = bnpFromString;
          BigInteger.prototype.clamp = bnpClamp;
          BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
          BigInteger.prototype.drShiftTo = bnpDRShiftTo;
          BigInteger.prototype.lShiftTo = bnpLShiftTo;
          BigInteger.prototype.rShiftTo = bnpRShiftTo;
          BigInteger.prototype.subTo = bnpSubTo;
          BigInteger.prototype.multiplyTo = bnpMultiplyTo;
          BigInteger.prototype.squareTo = bnpSquareTo;
          BigInteger.prototype.divRemTo = bnpDivRemTo;
          BigInteger.prototype.invDigit = bnpInvDigit;
          BigInteger.prototype.isEven = bnpIsEven;
          BigInteger.prototype.exp = bnpExp;
          BigInteger.prototype.toString = bnToString;
          BigInteger.prototype.negate = bnNegate;
          BigInteger.prototype.abs = bnAbs;
          BigInteger.prototype.compareTo = bnCompareTo;
          BigInteger.prototype.bitLength = bnBitLength;
          BigInteger.prototype.mod = bnMod;
          BigInteger.prototype.modPowInt = bnModPowInt;
          BigInteger.ZERO = nbv(0);
          BigInteger.ONE = nbv(1);
          function bnClone() {
            var r = nbi();
            this.copyTo(r);
            return r;
          }
          function bnIntValue() {
            if (this.s < 0) {
              if (this.t == 1)
                return this[0] - this.DV;
              else if (this.t == 0)
                return -1;
            } else if (this.t == 1)
              return this[0];
            else if (this.t == 0)
              return 0;
            return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
          }
          function bnByteValue() {
            return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
          }
          function bnShortValue() {
            return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
          }
          function bnpChunkSize(r) {
            return Math.floor(Math.LN2 * this.DB / Math.log(r));
          }
          function bnSigNum() {
            if (this.s < 0)
              return -1;
            else if (this.t <= 0 || (this.t == 1 && this[0] <= 0))
              return 0;
            else
              return 1;
          }
          function bnpToRadix(b) {
            if (b == null)
              b = 10;
            if (this.signum() == 0 || b < 2 || b > 36)
              return "0";
            var cs = this.chunkSize(b);
            var a = Math.pow(b, cs);
            var d = nbv(a),
                y = nbi(),
                z = nbi(),
                r = "";
            this.divRemTo(d, y, z);
            while (y.signum() > 0) {
              r = (a + z.intValue()).toString(b).substr(1) + r;
              y.divRemTo(d, y, z);
            }
            return z.intValue().toString(b) + r;
          }
          function bnpFromRadix(s, b) {
            this.fromInt(0);
            if (b == null)
              b = 10;
            var cs = this.chunkSize(b);
            var d = Math.pow(b, cs),
                mi = false,
                j = 0,
                w = 0;
            for (var i = 0; i < s.length; ++i) {
              var x = intAt(s, i);
              if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0)
                  mi = true;
                continue;
              }
              w = b * w + x;
              if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
              }
            }
            if (j > 0) {
              this.dMultiply(Math.pow(b, j));
              this.dAddOffset(w, 0);
            }
            if (mi)
              BigInteger.ZERO.subTo(this, this);
          }
          function bnpFromNumber(a, b, c) {
            if ("number" == typeof b) {
              if (a < 2)
                this.fromInt(1);
              else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1))
                  this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                if (this.isEven())
                  this.dAddOffset(1, 0);
                while (!this.isProbablePrime(b)) {
                  this.dAddOffset(2, 0);
                  if (this.bitLength() > a)
                    this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                }
              }
            } else {
              var x = new Array(),
                  t = a & 7;
              x.length = (a >> 3) + 1;
              b.nextBytes(x);
              if (t > 0)
                x[0] &= ((1 << t) - 1);
              else
                x[0] = 0;
              this.fromString(x, 256);
            }
          }
          function bnToByteArray() {
            var i = this.t,
                r = new Array();
            r[0] = this.s;
            var p = this.DB - (i * this.DB) % 8,
                d,
                k = 0;
            if (i-- > 0) {
              if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
                r[k++] = d | (this.s << (this.DB - p));
              while (i >= 0) {
                if (p < 8) {
                  d = (this[i] & ((1 << p) - 1)) << (8 - p);
                  d |= this[--i] >> (p += this.DB - 8);
                } else {
                  d = (this[i] >> (p -= 8)) & 0xff;
                  if (p <= 0) {
                    p += this.DB;
                    --i;
                  }
                }
                if ((d & 0x80) != 0)
                  d |= -256;
                if (k == 0 && (this.s & 0x80) != (d & 0x80))
                  ++k;
                if (k > 0 || d != this.s)
                  r[k++] = d;
              }
            }
            return r;
          }
          function bnEquals(a) {
            return (this.compareTo(a) == 0);
          }
          function bnMin(a) {
            return (this.compareTo(a) < 0) ? this : a;
          }
          function bnMax(a) {
            return (this.compareTo(a) > 0) ? this : a;
          }
          function bnpBitwiseTo(a, op, r) {
            var i,
                f,
                m = Math.min(a.t, this.t);
            for (i = 0; i < m; ++i)
              r[i] = op(this[i], a[i]);
            if (a.t < this.t) {
              f = a.s & this.DM;
              for (i = m; i < this.t; ++i)
                r[i] = op(this[i], f);
              r.t = this.t;
            } else {
              f = this.s & this.DM;
              for (i = m; i < a.t; ++i)
                r[i] = op(f, a[i]);
              r.t = a.t;
            }
            r.s = op(this.s, a.s);
            r.clamp();
          }
          function op_and(x, y) {
            return x & y;
          }
          function bnAnd(a) {
            var r = nbi();
            this.bitwiseTo(a, op_and, r);
            return r;
          }
          function op_or(x, y) {
            return x | y;
          }
          function bnOr(a) {
            var r = nbi();
            this.bitwiseTo(a, op_or, r);
            return r;
          }
          function op_xor(x, y) {
            return x ^ y;
          }
          function bnXor(a) {
            var r = nbi();
            this.bitwiseTo(a, op_xor, r);
            return r;
          }
          function op_andnot(x, y) {
            return x & ~y;
          }
          function bnAndNot(a) {
            var r = nbi();
            this.bitwiseTo(a, op_andnot, r);
            return r;
          }
          function bnNot() {
            var r = nbi();
            for (var i = 0; i < this.t; ++i)
              r[i] = this.DM & ~this[i];
            r.t = this.t;
            r.s = ~this.s;
            return r;
          }
          function bnShiftLeft(n) {
            var r = nbi();
            if (n < 0)
              this.rShiftTo(-n, r);
            else
              this.lShiftTo(n, r);
            return r;
          }
          function bnShiftRight(n) {
            var r = nbi();
            if (n < 0)
              this.lShiftTo(-n, r);
            else
              this.rShiftTo(n, r);
            return r;
          }
          function lbit(x) {
            if (x == 0)
              return -1;
            var r = 0;
            if ((x & 0xffff) == 0) {
              x >>= 16;
              r += 16;
            }
            if ((x & 0xff) == 0) {
              x >>= 8;
              r += 8;
            }
            if ((x & 0xf) == 0) {
              x >>= 4;
              r += 4;
            }
            if ((x & 3) == 0) {
              x >>= 2;
              r += 2;
            }
            if ((x & 1) == 0)
              ++r;
            return r;
          }
          function bnGetLowestSetBit() {
            for (var i = 0; i < this.t; ++i)
              if (this[i] != 0)
                return i * this.DB + lbit(this[i]);
            if (this.s < 0)
              return this.t * this.DB;
            return -1;
          }
          function cbit(x) {
            var r = 0;
            while (x != 0) {
              x &= x - 1;
              ++r;
            }
            return r;
          }
          function bnBitCount() {
            var r = 0,
                x = this.s & this.DM;
            for (var i = 0; i < this.t; ++i)
              r += cbit(this[i] ^ x);
            return r;
          }
          function bnTestBit(n) {
            var j = Math.floor(n / this.DB);
            if (j >= this.t)
              return (this.s != 0);
            return ((this[j] & (1 << (n % this.DB))) != 0);
          }
          function bnpChangeBit(n, op) {
            var r = BigInteger.ONE.shiftLeft(n);
            this.bitwiseTo(r, op, r);
            return r;
          }
          function bnSetBit(n) {
            return this.changeBit(n, op_or);
          }
          function bnClearBit(n) {
            return this.changeBit(n, op_andnot);
          }
          function bnFlipBit(n) {
            return this.changeBit(n, op_xor);
          }
          function bnpAddTo(a, r) {
            var i = 0,
                c = 0,
                m = Math.min(a.t, this.t);
            while (i < m) {
              c += this[i] + a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            if (a.t < this.t) {
              c += a.s;
              while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += this.s;
            } else {
              c += this.s;
              while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += a.s;
            }
            r.s = (c < 0) ? -1 : 0;
            if (c > 0)
              r[i++] = c;
            else if (c < -1)
              r[i++] = this.DV + c;
            r.t = i;
            r.clamp();
          }
          function bnAdd(a) {
            var r = nbi();
            this.addTo(a, r);
            return r;
          }
          function bnSubtract(a) {
            var r = nbi();
            this.subTo(a, r);
            return r;
          }
          function bnMultiply(a) {
            var r = nbi();
            this.multiplyTo(a, r);
            return r;
          }
          function bnSquare() {
            var r = nbi();
            this.squareTo(r);
            return r;
          }
          function bnDivide(a) {
            var r = nbi();
            this.divRemTo(a, r, null);
            return r;
          }
          function bnRemainder(a) {
            var r = nbi();
            this.divRemTo(a, null, r);
            return r;
          }
          function bnDivideAndRemainder(a) {
            var q = nbi(),
                r = nbi();
            this.divRemTo(a, q, r);
            return new Array(q, r);
          }
          function bnpDMultiply(n) {
            this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
            ++this.t;
            this.clamp();
          }
          function bnpDAddOffset(n, w) {
            if (n == 0)
              return;
            while (this.t <= w)
              this[this.t++] = 0;
            this[w] += n;
            while (this[w] >= this.DV) {
              this[w] -= this.DV;
              if (++w >= this.t)
                this[this.t++] = 0;
              ++this[w];
            }
          }
          function NullExp() {}
          function nNop(x) {
            return x;
          }
          function nMulTo(x, y, r) {
            x.multiplyTo(y, r);
          }
          function nSqrTo(x, r) {
            x.squareTo(r);
          }
          NullExp.prototype.convert = nNop;
          NullExp.prototype.revert = nNop;
          NullExp.prototype.mulTo = nMulTo;
          NullExp.prototype.sqrTo = nSqrTo;
          function bnPow(e) {
            return this.exp(e, new NullExp());
          }
          function bnpMultiplyLowerTo(a, n, r) {
            var i = Math.min(this.t + a.t, n);
            r.s = 0;
            r.t = i;
            while (i > 0)
              r[--i] = 0;
            var j;
            for (j = r.t - this.t; i < j; ++i)
              r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
            for (j = Math.min(a.t, n); i < j; ++i)
              this.am(0, a[i], r, i, 0, n - i);
            r.clamp();
          }
          function bnpMultiplyUpperTo(a, n, r) {
            --n;
            var i = r.t = this.t + a.t - n;
            r.s = 0;
            while (--i >= 0)
              r[i] = 0;
            for (i = Math.max(n - this.t, 0); i < a.t; ++i)
              r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
            r.clamp();
            r.drShiftTo(1, r);
          }
          function Barrett(m) {
            this.r2 = nbi();
            this.q3 = nbi();
            BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
            this.mu = this.r2.divide(m);
            this.m = m;
          }
          function barrettConvert(x) {
            if (x.s < 0 || x.t > 2 * this.m.t)
              return x.mod(this.m);
            else if (x.compareTo(this.m) < 0)
              return x;
            else {
              var r = nbi();
              x.copyTo(r);
              this.reduce(r);
              return r;
            }
          }
          function barrettRevert(x) {
            return x;
          }
          function barrettReduce(x) {
            x.drShiftTo(this.m.t - 1, this.r2);
            if (x.t > this.m.t + 1) {
              x.t = this.m.t + 1;
              x.clamp();
            }
            this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
            this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
            while (x.compareTo(this.r2) < 0)
              x.dAddOffset(1, this.m.t + 1);
            x.subTo(this.r2, x);
            while (x.compareTo(this.m) >= 0)
              x.subTo(this.m, x);
          }
          function barrettSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          function barrettMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          Barrett.prototype.convert = barrettConvert;
          Barrett.prototype.revert = barrettRevert;
          Barrett.prototype.reduce = barrettReduce;
          Barrett.prototype.mulTo = barrettMulTo;
          Barrett.prototype.sqrTo = barrettSqrTo;
          function bnModPow(e, m) {
            var i = e.bitLength(),
                k,
                r = nbv(1),
                z;
            if (i <= 0)
              return r;
            else if (i < 18)
              k = 1;
            else if (i < 48)
              k = 3;
            else if (i < 144)
              k = 4;
            else if (i < 768)
              k = 5;
            else
              k = 6;
            if (i < 8)
              z = new Classic(m);
            else if (m.isEven())
              z = new Barrett(m);
            else
              z = new Montgomery(m);
            var g = new Array(),
                n = 3,
                k1 = k - 1,
                km = (1 << k) - 1;
            g[1] = z.convert(this);
            if (k > 1) {
              var g2 = nbi();
              z.sqrTo(g[1], g2);
              while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
              }
            }
            var j = e.t - 1,
                w,
                is1 = true,
                r2 = nbi(),
                t;
            i = nbits(e[j]) - 1;
            while (j >= 0) {
              if (i >= k1)
                w = (e[j] >> (i - k1)) & km;
              else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0)
                  w |= e[j - 1] >> (this.DB + i - k1);
              }
              n = k;
              while ((w & 1) == 0) {
                w >>= 1;
                --n;
              }
              if ((i -= n) < 0) {
                i += this.DB;
                --j;
              }
              if (is1) {
                g[w].copyTo(r);
                is1 = false;
              } else {
                while (n > 1) {
                  z.sqrTo(r, r2);
                  z.sqrTo(r2, r);
                  n -= 2;
                }
                if (n > 0)
                  z.sqrTo(r, r2);
                else {
                  t = r;
                  r = r2;
                  r2 = t;
                }
                z.mulTo(r2, g[w], r);
              }
              while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                  i = this.DB - 1;
                  --j;
                }
              }
            }
            return z.revert(r);
          }
          function bnGCD(a) {
            var x = (this.s < 0) ? this.negate() : this.clone();
            var y = (a.s < 0) ? a.negate() : a.clone();
            if (x.compareTo(y) < 0) {
              var t = x;
              x = y;
              y = t;
            }
            var i = x.getLowestSetBit(),
                g = y.getLowestSetBit();
            if (g < 0)
              return x;
            if (i < g)
              g = i;
            if (g > 0) {
              x.rShiftTo(g, x);
              y.rShiftTo(g, y);
            }
            while (x.signum() > 0) {
              if ((i = x.getLowestSetBit()) > 0)
                x.rShiftTo(i, x);
              if ((i = y.getLowestSetBit()) > 0)
                y.rShiftTo(i, y);
              if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
              } else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
              }
            }
            if (g > 0)
              y.lShiftTo(g, y);
            return y;
          }
          function bnpModInt(n) {
            if (n <= 0)
              return 0;
            var d = this.DV % n,
                r = (this.s < 0) ? n - 1 : 0;
            if (this.t > 0)
              if (d == 0)
                r = this[0] % n;
              else
                for (var i = this.t - 1; i >= 0; --i)
                  r = (d * r + this[i]) % n;
            return r;
          }
          function bnModInverse(m) {
            var ac = m.isEven();
            if ((this.isEven() && ac) || m.signum() == 0)
              return BigInteger.ZERO;
            var u = m.clone(),
                v = this.clone();
            var a = nbv(1),
                b = nbv(0),
                c = nbv(0),
                d = nbv(1);
            while (u.signum() != 0) {
              while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                  if (!a.isEven() || !b.isEven()) {
                    a.addTo(this, a);
                    b.subTo(m, b);
                  }
                  a.rShiftTo(1, a);
                } else if (!b.isEven())
                  b.subTo(m, b);
                b.rShiftTo(1, b);
              }
              while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                  if (!c.isEven() || !d.isEven()) {
                    c.addTo(this, c);
                    d.subTo(m, d);
                  }
                  c.rShiftTo(1, c);
                } else if (!d.isEven())
                  d.subTo(m, d);
                d.rShiftTo(1, d);
              }
              if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac)
                  a.subTo(c, a);
                b.subTo(d, b);
              } else {
                v.subTo(u, v);
                if (ac)
                  c.subTo(a, c);
                d.subTo(b, d);
              }
            }
            if (v.compareTo(BigInteger.ONE) != 0)
              return BigInteger.ZERO;
            if (d.compareTo(m) >= 0)
              return d.subtract(m);
            if (d.signum() < 0)
              d.addTo(m, d);
            else
              return d;
            if (d.signum() < 0)
              return d.add(m);
            else
              return d;
          }
          var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
          var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
          function bnIsProbablePrime(t) {
            var i,
                x = this.abs();
            if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
              for (i = 0; i < lowprimes.length; ++i)
                if (x[0] == lowprimes[i])
                  return true;
              return false;
            }
            if (x.isEven())
              return false;
            i = 1;
            while (i < lowprimes.length) {
              var m = lowprimes[i],
                  j = i + 1;
              while (j < lowprimes.length && m < lplim)
                m *= lowprimes[j++];
              m = x.modInt(m);
              while (i < j)
                if (m % lowprimes[i++] == 0)
                  return false;
            }
            return x.millerRabin(t);
          }
          function bnpMillerRabin(t) {
            var n1 = this.subtract(BigInteger.ONE);
            var k = n1.getLowestSetBit();
            if (k <= 0)
              return false;
            var r = n1.shiftRight(k);
            t = (t + 1) >> 1;
            if (t > lowprimes.length)
              t = lowprimes.length;
            var a = nbi();
            for (var i = 0; i < t; ++i) {
              a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
              var y = a.modPow(r, this);
              if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                  y = y.modPowInt(2, this);
                  if (y.compareTo(BigInteger.ONE) == 0)
                    return false;
                }
                if (y.compareTo(n1) != 0)
                  return false;
              }
            }
            return true;
          }
          BigInteger.prototype.chunkSize = bnpChunkSize;
          BigInteger.prototype.toRadix = bnpToRadix;
          BigInteger.prototype.fromRadix = bnpFromRadix;
          BigInteger.prototype.fromNumber = bnpFromNumber;
          BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
          BigInteger.prototype.changeBit = bnpChangeBit;
          BigInteger.prototype.addTo = bnpAddTo;
          BigInteger.prototype.dMultiply = bnpDMultiply;
          BigInteger.prototype.dAddOffset = bnpDAddOffset;
          BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
          BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
          BigInteger.prototype.modInt = bnpModInt;
          BigInteger.prototype.millerRabin = bnpMillerRabin;
          BigInteger.prototype.clone = bnClone;
          BigInteger.prototype.intValue = bnIntValue;
          BigInteger.prototype.byteValue = bnByteValue;
          BigInteger.prototype.shortValue = bnShortValue;
          BigInteger.prototype.signum = bnSigNum;
          BigInteger.prototype.toByteArray = bnToByteArray;
          BigInteger.prototype.equals = bnEquals;
          BigInteger.prototype.min = bnMin;
          BigInteger.prototype.max = bnMax;
          BigInteger.prototype.and = bnAnd;
          BigInteger.prototype.or = bnOr;
          BigInteger.prototype.xor = bnXor;
          BigInteger.prototype.andNot = bnAndNot;
          BigInteger.prototype.not = bnNot;
          BigInteger.prototype.shiftLeft = bnShiftLeft;
          BigInteger.prototype.shiftRight = bnShiftRight;
          BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
          BigInteger.prototype.bitCount = bnBitCount;
          BigInteger.prototype.testBit = bnTestBit;
          BigInteger.prototype.setBit = bnSetBit;
          BigInteger.prototype.clearBit = bnClearBit;
          BigInteger.prototype.flipBit = bnFlipBit;
          BigInteger.prototype.add = bnAdd;
          BigInteger.prototype.subtract = bnSubtract;
          BigInteger.prototype.multiply = bnMultiply;
          BigInteger.prototype.divide = bnDivide;
          BigInteger.prototype.remainder = bnRemainder;
          BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
          BigInteger.prototype.modPow = bnModPow;
          BigInteger.prototype.modInverse = bnModInverse;
          BigInteger.prototype.pow = bnPow;
          BigInteger.prototype.gcd = bnGCD;
          BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
          BigInteger.prototype.square = bnSquare;
          BigInteger.prototype.Barrett = Barrett;
          if (typeof exports !== 'undefined') {
            exports = module.exports = BigInteger;
          } else {
            this.BigInteger = BigInteger;
          }
        }).call(this);
      }, {}],
      10: [function(require, module, exports) {
        var cs2a = require("./cs2a.js");
        var ecc = require("ecc-jsbn");
        require("./forge.min.js");
        cs2a.crypt(ecc, forge);
        Object.keys(cs2a).forEach(function(f) {
          exports[f] = cs2a[f];
        });
      }, {
        "./cs2a.js": 11,
        "./forge.min.js": 12,
        "ecc-jsbn": 13
      }],
      11: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var sjcl = require("sjcl");
          var self;
          exports.install = function(telehash) {
            self = telehash;
            telehash.CSets["2a"] = exports;
          };
          var forge;
          exports.crypt = function(ecc, f) {
            crypto.ecc = ecc;
            forge = f;
          };
          exports.genkey = function(ret, cbDone, cbStep) {
            var state = forge.rsa.createKeyPairGenerationState(2048, 0x10001);
            var step = function() {
              if (!forge.rsa.stepKeyPairGenerationState(state, 100)) {
                if (cbStep)
                  cbStep();
                setTimeout(step, 10);
              } else {
                var key = forge.asn1.toDer(forge.pki.publicKeyToAsn1(state.keys.publicKey)).bytes();
                ret["2a"] = forge.util.encode64(key);
                ret["2a_secret"] = forge.util.encode64(forge.asn1.toDer(forge.pki.privateKeyToAsn1(state.keys.privateKey)).bytes());
                cbDone();
              }
            };
            setTimeout(step);
          };
          exports.loadkey = function(id, pub, priv) {
            if (pub.length > 300) {
              if (pub.substr(0, 1) == "-")
                pub = forge.asn1.toDer(forge.pki.publicKeyToAsn1(forge.pki.publicKeyFromPem(key))).bytes();
              else
                pub = forge.util.decode64(pub);
            }
            id.key = pub;
            var pk = forge.pki.publicKeyFromAsn1(forge.asn1.fromDer(pub));
            id.encrypt = function(buf) {
              return new Buffer(pk.encrypt(buf.toString("binary"), "RSA-OAEP"), "binary");
            };
            id.verify = function(a, b) {
              return pk.verify(a.toString("binary"), b.toString("binary"));
            };
            if (priv) {
              var sk = (priv.substr(0, 1) == "-") ? forge.pki.privateKeyFromPem(priv) : forge.pki.privateKeyFromAsn1(forge.asn1.fromDer(forge.util.decode64(priv)));
              id.sign = function(buf) {
                var md = forge.md.sha256.create();
                md.update(buf.toString("binary"));
                return new Buffer(sk.sign(md), "binary");
              };
              id.decrypt = function(buf) {
                return new Buffer(sk.decrypt(buf.toString("binary"), "RSA-OAEP"), "binary");
              };
            }
            return false;
          };
          exports.openize = function(id, to, inner) {
            if (!to.ecc)
              to.ecc = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp256r1);
            var eccpub = to.ecc.PublicKey.slice(1);
            var ibody = (!Buffer.isBuffer(inner)) ? self.pencode(inner, id.cs["2a"].key) : inner;
            var keyhex = crypto.createHash("sha256").update(eccpub).digest("hex");
            var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
            var iv = sjcl.codec.hex.toBits("00000000000000000000000000000001");
            var cipher = sjcl.mode.gcm.encrypt(key, sjcl.codec.hex.toBits(ibody.toString("hex")), iv, [], 128);
            var cbody = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            var sig = id.cs["2a"].sign(cbody);
            if (!to.lineOut)
              to.lineOut = "";
            var keyhex = crypto.createHash("sha256").update(Buffer.concat([eccpub, new Buffer(to.lineOut, "hex")])).digest("hex");
            var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
            var cipher = sjcl.mode.gcm.encrypt(key, sjcl.codec.hex.toBits(sig.toString("hex")), iv, [], 32);
            var csig = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            var ekey = to.encrypt(eccpub);
            var body = Buffer.concat([ekey, csig, cbody]);
            var packet = self.pencode(0x2a, body);
            return packet;
          };
          exports.deopenize = function(id, open) {
            var ret = {verify: false};
            var ekey = open.body.slice(0, 256);
            var csig = open.body.slice(256, 256 + 260);
            var cbody = open.body.slice(256 + 260);
            var eccpub = id.cs["2a"].decrypt(ekey);
            if (!eccpub)
              return ret;
            try {
              ret.linepub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp256r1, Buffer.concat([new Buffer("04", "hex"), eccpub]), true);
            } catch (E) {}
            ;
            if (!ret.linepub)
              return ret;
            var keyhex = crypto.createHash("sha256").update(eccpub).digest("hex");
            var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
            var iv = sjcl.codec.hex.toBits("00000000000000000000000000000001");
            var cipher = sjcl.mode.gcm.decrypt(key, sjcl.codec.hex.toBits(cbody.toString("hex")), iv, [], 128);
            var ibody = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            var deciphered = self.pdecode(ibody);
            if (!deciphered || !deciphered.body)
              return ret;
            ret.js = deciphered.js;
            ret.inner = deciphered;
            var from = {};
            var lineIn;
            if (!open.from) {
              ret.key = deciphered.body;
              if (exports.loadkey(from, deciphered.body))
                return ret;
              lineIn = deciphered.js.line;
            } else {
              from = open.from;
              lineIn = "";
            }
            var keyhex = crypto.createHash("sha256").update(Buffer.concat([eccpub, new Buffer(lineIn, "hex")])).digest("hex");
            var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
            var cipher = sjcl.mode.gcm.decrypt(key, sjcl.codec.hex.toBits(csig.toString("hex")), iv, [], 32);
            var sig = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            ret.verify = from.verify(cbody, sig);
            return ret;
          };
          exports.openline = function(from, open) {
            var ecdhe = from.ecc.deriveSharedSecret(open.linepub);
            from.lineInB = new Buffer(from.lineIn, "hex");
            var hex = crypto.createHash("sha256").update(ecdhe).update(new Buffer(from.lineOut, "hex")).update(new Buffer(from.lineIn, "hex")).digest("hex");
            from.encKey = new sjcl.cipher.aes(sjcl.codec.hex.toBits(hex));
            var hex = crypto.createHash("sha256").update(ecdhe).update(new Buffer(from.lineIn, "hex")).update(new Buffer(from.lineOut, "hex")).digest("hex");
            from.decKey = new sjcl.cipher.aes(sjcl.codec.hex.toBits(hex));
            return true;
          };
          exports.lineize = function(to, packet) {
            var iv = crypto.randomBytes(16);
            var buf = self.pencode(packet.js, packet.body);
            var cipher = sjcl.mode.gcm.encrypt(to.encKey, sjcl.codec.hex.toBits(buf.toString("hex")), sjcl.codec.hex.toBits(iv.toString("hex")), [], 128);
            var cbody = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            var body = Buffer.concat([to.lineInB, iv, cbody]);
            return self.pencode(null, body);
          }, exports.delineize = function(from, packet) {
            if (!packet.body)
              return "missing body";
            packet.body = packet.body.slice(16);
            var iv = sjcl.codec.hex.toBits(packet.body.slice(0, 16).toString("hex"));
            try {
              var cipher = sjcl.mode.gcm.decrypt(from.decKey, sjcl.codec.hex.toBits(packet.body.slice(16).toString("hex")), iv, [], 128);
            } catch (E) {
              return E;
            }
            if (!cipher)
              return "no cipher output";
            var deciphered = self.pdecode(new Buffer(sjcl.codec.hex.fromBits(cipher), "hex"));
            if (!deciphered)
              return "invalid decrypted packet";
            packet.js = deciphered.js;
            packet.body = deciphered.body;
            return false;
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "crypto": 35,
        "sjcl": 17
      }],
      12: [function(require, module, exports) {
        module.exports = require(5);
      }, {"sycGbZ": 51}],
      13: [function(require, module, exports) {
        module.exports = require(6);
      }, {
        "./lib/ec.js": 14,
        "./lib/sec.js": 15,
        "buffer": 29,
        "crypto": 35,
        "jsbn": 16
      }],
      14: [function(require, module, exports) {
        module.exports = require(7);
      }, {"jsbn": 16}],
      15: [function(require, module, exports) {
        module.exports = require(8);
      }, {
        "./ec.js": 14,
        "jsbn": 16
      }],
      16: [function(require, module, exports) {
        module.exports = require(9);
      }, {}],
      17: [function(require, module, exports) {
        "use strict";
        function q(a) {
          throw a;
        }
        var t = void 0,
            u = !1;
        var sjcl = {
          cipher: {},
          hash: {},
          keyexchange: {},
          mode: {},
          misc: {},
          codec: {},
          exception: {
            corrupt: function(a) {
              this.toString = function() {
                return "CORRUPT: " + this.message;
              };
              this.message = a;
            },
            invalid: function(a) {
              this.toString = function() {
                return "INVALID: " + this.message;
              };
              this.message = a;
            },
            bug: function(a) {
              this.toString = function() {
                return "BUG: " + this.message;
              };
              this.message = a;
            },
            notReady: function(a) {
              this.toString = function() {
                return "NOT READY: " + this.message;
              };
              this.message = a;
            }
          }
        };
        "undefined" !== typeof module && module.exports && (module.exports = sjcl);
        sjcl.cipher.aes = function(a) {
          this.k[0][0][0] || this.D();
          var b,
              c,
              d,
              e,
              f = this.k[0][4],
              g = this.k[1];
          b = a.length;
          var h = 1;
          4 !== b && (6 !== b && 8 !== b) && q(new sjcl.exception.invalid("invalid aes key size"));
          this.b = [d = a.slice(0), e = []];
          for (a = b; a < 4 * b + 28; a++) {
            c = d[a - 1];
            if (0 === a % b || 8 === b && 4 === a % b)
              c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255], 0 === a % b && (c = c << 8 ^ c >>> 24 ^ h << 24, h = h << 1 ^ 283 * (h >> 7));
            d[a] = d[a - b] ^ c;
          }
          for (b = 0; a; b++, a--)
            c = d[b & 3 ? a : a - 4], e[b] = 4 >= a || 4 > b ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c & 255]];
        };
        sjcl.cipher.aes.prototype = {
          encrypt: function(a) {
            return y(this, a, 0);
          },
          decrypt: function(a) {
            return y(this, a, 1);
          },
          k: [[[], [], [], [], []], [[], [], [], [], []]],
          D: function() {
            var a = this.k[0],
                b = this.k[1],
                c = a[4],
                d = b[4],
                e,
                f,
                g,
                h = [],
                l = [],
                k,
                n,
                m,
                p;
            for (e = 0; 0x100 > e; e++)
              l[(h[e] = e << 1 ^ 283 * (e >> 7)) ^ e] = e;
            for (f = g = 0; !c[f]; f ^= k || 1, g = l[g] || 1) {
              m = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
              m = m >> 8 ^ m & 255 ^ 99;
              c[f] = m;
              d[m] = f;
              n = h[e = h[k = h[f]]];
              p = 0x1010101 * n ^ 0x10001 * e ^ 0x101 * k ^ 0x1010100 * f;
              n = 0x101 * h[m] ^ 0x1010100 * m;
              for (e = 0; 4 > e; e++)
                a[e][f] = n = n << 24 ^ n >>> 8, b[e][m] = p = p << 24 ^ p >>> 8;
            }
            for (e = 0; 5 > e; e++)
              a[e] = a[e].slice(0), b[e] = b[e].slice(0);
          }
        };
        function y(a, b, c) {
          4 !== b.length && q(new sjcl.exception.invalid("invalid aes block size"));
          var d = a.b[c],
              e = b[0] ^ d[0],
              f = b[c ? 3 : 1] ^ d[1],
              g = b[2] ^ d[2];
          b = b[c ? 1 : 3] ^ d[3];
          var h,
              l,
              k,
              n = d.length / 4 - 2,
              m,
              p = 4,
              s = [0, 0, 0, 0];
          h = a.k[c];
          a = h[0];
          var r = h[1],
              v = h[2],
              w = h[3],
              x = h[4];
          for (m = 0; m < n; m++)
            h = a[e >>> 24] ^ r[f >> 16 & 255] ^ v[g >> 8 & 255] ^ w[b & 255] ^ d[p], l = a[f >>> 24] ^ r[g >> 16 & 255] ^ v[b >> 8 & 255] ^ w[e & 255] ^ d[p + 1], k = a[g >>> 24] ^ r[b >> 16 & 255] ^ v[e >> 8 & 255] ^ w[f & 255] ^ d[p + 2], b = a[b >>> 24] ^ r[e >> 16 & 255] ^ v[f >> 8 & 255] ^ w[g & 255] ^ d[p + 3], p += 4, e = h, f = l, g = k;
          for (m = 0; 4 > m; m++)
            s[c ? 3 & -m : m] = x[e >>> 24] << 24 ^ x[f >> 16 & 255] << 16 ^ x[g >> 8 & 255] << 8 ^ x[b & 255] ^ d[p++], h = e, e = f, f = g, g = b, b = h;
          return s;
        }
        sjcl.bitArray = {
          bitSlice: function(a, b, c) {
            a = sjcl.bitArray.P(a.slice(b / 32), 32 - (b & 31)).slice(1);
            return c === t ? a : sjcl.bitArray.clamp(a, c - b);
          },
          extract: function(a, b, c) {
            var d = Math.floor(-b - c & 31);
            return ((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1;
          },
          concat: function(a, b) {
            if (0 === a.length || 0 === b.length)
              return a.concat(b);
            var c = a[a.length - 1],
                d = sjcl.bitArray.getPartial(c);
            return 32 === d ? a.concat(b) : sjcl.bitArray.P(b, d, c | 0, a.slice(0, a.length - 1));
          },
          bitLength: function(a) {
            var b = a.length;
            return 0 === b ? 0 : 32 * (b - 1) + sjcl.bitArray.getPartial(a[b - 1]);
          },
          clamp: function(a, b) {
            if (32 * a.length < b)
              return a;
            a = a.slice(0, Math.ceil(b / 32));
            var c = a.length;
            b &= 31;
            0 < c && b && (a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1));
            return a;
          },
          partial: function(a, b, c) {
            return 32 === a ? b : (c ? b | 0 : b << 32 - a) + 0x10000000000 * a;
          },
          getPartial: function(a) {
            return Math.round(a / 0x10000000000) || 32;
          },
          equal: function(a, b) {
            if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b))
              return u;
            var c = 0,
                d;
            for (d = 0; d < a.length; d++)
              c |= a[d] ^ b[d];
            return 0 === c;
          },
          P: function(a, b, c, d) {
            var e;
            e = 0;
            for (d === t && (d = []); 32 <= b; b -= 32)
              d.push(c), c = 0;
            if (0 === b)
              return d.concat(a);
            for (e = 0; e < a.length; e++)
              d.push(c | a[e] >>> b), c = a[e] << 32 - b;
            e = a.length ? a[a.length - 1] : 0;
            a = sjcl.bitArray.getPartial(e);
            d.push(sjcl.bitArray.partial(b + a & 31, 32 < b + a ? c : d.pop(), 1));
            return d;
          },
          l: function(a, b) {
            return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]];
          }
        };
        sjcl.codec.utf8String = {
          fromBits: function(a) {
            var b = "",
                c = sjcl.bitArray.bitLength(a),
                d,
                e;
            for (d = 0; d < c / 8; d++)
              0 === (d & 3) && (e = a[d / 4]), b += String.fromCharCode(e >>> 24), e <<= 8;
            return decodeURIComponent(escape(b));
          },
          toBits: function(a) {
            a = unescape(encodeURIComponent(a));
            var b = [],
                c,
                d = 0;
            for (c = 0; c < a.length; c++)
              d = d << 8 | a.charCodeAt(c), 3 === (c & 3) && (b.push(d), d = 0);
            c & 3 && b.push(sjcl.bitArray.partial(8 * (c & 3), d));
            return b;
          }
        };
        sjcl.codec.hex = {
          fromBits: function(a) {
            var b = "",
                c;
            for (c = 0; c < a.length; c++)
              b += ((a[c] | 0) + 0xf00000000000).toString(16).substr(4);
            return b.substr(0, sjcl.bitArray.bitLength(a) / 4);
          },
          toBits: function(a) {
            var b,
                c = [],
                d;
            a = a.replace(/\s|0x/g, "");
            d = a.length;
            a += "00000000";
            for (b = 0; b < a.length; b += 8)
              c.push(parseInt(a.substr(b, 8), 16) ^ 0);
            return sjcl.bitArray.clamp(c, 4 * d);
          }
        };
        sjcl.codec.base64 = {
          J: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          fromBits: function(a, b, c) {
            var d = "",
                e = 0,
                f = sjcl.codec.base64.J,
                g = 0,
                h = sjcl.bitArray.bitLength(a);
            c && (f = f.substr(0, 62) + "-_");
            for (c = 0; 6 * d.length < h; )
              d += f.charAt((g ^ a[c] >>> e) >>> 26), 6 > e ? (g = a[c] << 6 - e, e += 26, c++) : (g <<= 6, e -= 6);
            for (; d.length & 3 && !b; )
              d += "=";
            return d;
          },
          toBits: function(a, b) {
            a = a.replace(/\s|=/g, "");
            var c = [],
                d,
                e = 0,
                f = sjcl.codec.base64.J,
                g = 0,
                h;
            b && (f = f.substr(0, 62) + "-_");
            for (d = 0; d < a.length; d++)
              h = f.indexOf(a.charAt(d)), 0 > h && q(new sjcl.exception.invalid("this isn't base64!")), 26 < e ? (e -= 26, c.push(g ^ h >>> e), g = h << 32 - e) : (e += 6, g ^= h << 32 - e);
            e & 56 && c.push(sjcl.bitArray.partial(e & 56, g, 1));
            return c;
          }
        };
        sjcl.codec.base64url = {
          fromBits: function(a) {
            return sjcl.codec.base64.fromBits(a, 1, 1);
          },
          toBits: function(a) {
            return sjcl.codec.base64.toBits(a, 1);
          }
        };
        sjcl.hash.sha256 = function(a) {
          this.b[0] || this.D();
          a ? (this.r = a.r.slice(0), this.o = a.o.slice(0), this.h = a.h) : this.reset();
        };
        sjcl.hash.sha256.hash = function(a) {
          return (new sjcl.hash.sha256).update(a).finalize();
        };
        sjcl.hash.sha256.prototype = {
          blockSize: 512,
          reset: function() {
            this.r = this.N.slice(0);
            this.o = [];
            this.h = 0;
            return this;
          },
          update: function(a) {
            "string" === typeof a && (a = sjcl.codec.utf8String.toBits(a));
            var b,
                c = this.o = sjcl.bitArray.concat(this.o, a);
            b = this.h;
            a = this.h = b + sjcl.bitArray.bitLength(a);
            for (b = 512 + b & -512; b <= a; b += 512)
              z(this, c.splice(0, 16));
            return this;
          },
          finalize: function() {
            var a,
                b = this.o,
                c = this.r,
                b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
            for (a = b.length + 2; a & 15; a++)
              b.push(0);
            b.push(Math.floor(this.h / 4294967296));
            for (b.push(this.h | 0); b.length; )
              z(this, b.splice(0, 16));
            this.reset();
            return c;
          },
          N: [],
          b: [],
          D: function() {
            function a(a) {
              return 0x100000000 * (a - Math.floor(a)) | 0;
            }
            var b = 0,
                c = 2,
                d;
            a: for (; 64 > b; c++) {
              for (d = 2; d * d <= c; d++)
                if (0 === c % d)
                  continue a;
              8 > b && (this.N[b] = a(Math.pow(c, 0.5)));
              this.b[b] = a(Math.pow(c, 1 / 3));
              b++;
            }
          }
        };
        function z(a, b) {
          var c,
              d,
              e,
              f = b.slice(0),
              g = a.r,
              h = a.b,
              l = g[0],
              k = g[1],
              n = g[2],
              m = g[3],
              p = g[4],
              s = g[5],
              r = g[6],
              v = g[7];
          for (c = 0; 64 > c; c++)
            16 > c ? d = f[c] : (d = f[c + 1 & 15], e = f[c + 14 & 15], d = f[c & 15] = (d >>> 7 ^ d >>> 18 ^ d >>> 3 ^ d << 25 ^ d << 14) + (e >>> 17 ^ e >>> 19 ^ e >>> 10 ^ e << 15 ^ e << 13) + f[c & 15] + f[c + 9 & 15] | 0), d = d + v + (p >>> 6 ^ p >>> 11 ^ p >>> 25 ^ p << 26 ^ p << 21 ^ p << 7) + (r ^ p & (s ^ r)) + h[c], v = r, r = s, s = p, p = m + d | 0, m = n, n = k, k = l, l = d + (k & n ^ m & (k ^ n)) + (k >>> 2 ^ k >>> 13 ^ k >>> 22 ^ k << 30 ^ k << 19 ^ k << 10) | 0;
          g[0] = g[0] + l | 0;
          g[1] = g[1] + k | 0;
          g[2] = g[2] + n | 0;
          g[3] = g[3] + m | 0;
          g[4] = g[4] + p | 0;
          g[5] = g[5] + s | 0;
          g[6] = g[6] + r | 0;
          g[7] = g[7] + v | 0;
        }
        sjcl.mode.ccm = {
          name: "ccm",
          encrypt: function(a, b, c, d, e) {
            var f,
                g = b.slice(0),
                h = sjcl.bitArray,
                l = h.bitLength(c) / 8,
                k = h.bitLength(g) / 8;
            e = e || 64;
            d = d || [];
            7 > l && q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes"));
            for (f = 2; 4 > f && k >>> 8 * f; f++)
              ;
            f < 15 - l && (f = 15 - l);
            c = h.clamp(c, 8 * (15 - f));
            b = sjcl.mode.ccm.L(a, b, c, d, e, f);
            g = sjcl.mode.ccm.p(a, g, c, b, e, f);
            return h.concat(g.data, g.tag);
          },
          decrypt: function(a, b, c, d, e) {
            e = e || 64;
            d = d || [];
            var f = sjcl.bitArray,
                g = f.bitLength(c) / 8,
                h = f.bitLength(b),
                l = f.clamp(b, h - e),
                k = f.bitSlice(b, h - e),
                h = (h - e) / 8;
            7 > g && q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes"));
            for (b = 2; 4 > b && h >>> 8 * b; b++)
              ;
            b < 15 - g && (b = 15 - g);
            c = f.clamp(c, 8 * (15 - b));
            l = sjcl.mode.ccm.p(a, l, c, k, e, b);
            a = sjcl.mode.ccm.L(a, l.data, c, d, e, b);
            f.equal(l.tag, a) || q(new sjcl.exception.corrupt("ccm: tag doesn't match"));
            return l.data;
          },
          L: function(a, b, c, d, e, f) {
            var g = [],
                h = sjcl.bitArray,
                l = h.l;
            e /= 8;
            (e % 2 || 4 > e || 16 < e) && q(new sjcl.exception.invalid("ccm: invalid tag length"));
            (0xffffffff < d.length || 0xffffffff < b.length) && q(new sjcl.exception.bug("ccm: can't deal with 4GiB or more data"));
            f = [h.partial(8, (d.length ? 64 : 0) | e - 2 << 2 | f - 1)];
            f = h.concat(f, c);
            f[3] |= h.bitLength(b) / 8;
            f = a.encrypt(f);
            if (d.length) {
              c = h.bitLength(d) / 8;
              65279 >= c ? g = [h.partial(16, c)] : 0xffffffff >= c && (g = h.concat([h.partial(16, 65534)], [c]));
              g = h.concat(g, d);
              for (d = 0; d < g.length; d += 4)
                f = a.encrypt(l(f, g.slice(d, d + 4).concat([0, 0, 0])));
            }
            for (d = 0; d < b.length; d += 4)
              f = a.encrypt(l(f, b.slice(d, d + 4).concat([0, 0, 0])));
            return h.clamp(f, 8 * e);
          },
          p: function(a, b, c, d, e, f) {
            var g,
                h = sjcl.bitArray;
            g = h.l;
            var l = b.length,
                k = h.bitLength(b);
            c = h.concat([h.partial(8, f - 1)], c).concat([0, 0, 0]).slice(0, 4);
            d = h.bitSlice(g(d, a.encrypt(c)), 0, e);
            if (!l)
              return {
                tag: d,
                data: []
              };
            for (g = 0; g < l; g += 4)
              c[3]++, e = a.encrypt(c), b[g] ^= e[0], b[g + 1] ^= e[1], b[g + 2] ^= e[2], b[g + 3] ^= e[3];
            return {
              tag: d,
              data: h.clamp(b, k)
            };
          }
        };
        sjcl.mode.ocb2 = {
          name: "ocb2",
          encrypt: function(a, b, c, d, e, f) {
            128 !== sjcl.bitArray.bitLength(c) && q(new sjcl.exception.invalid("ocb iv must be 128 bits"));
            var g,
                h = sjcl.mode.ocb2.H,
                l = sjcl.bitArray,
                k = l.l,
                n = [0, 0, 0, 0];
            c = h(a.encrypt(c));
            var m,
                p = [];
            d = d || [];
            e = e || 64;
            for (g = 0; g + 4 < b.length; g += 4)
              m = b.slice(g, g + 4), n = k(n, m), p = p.concat(k(c, a.encrypt(k(c, m)))), c = h(c);
            m = b.slice(g);
            b = l.bitLength(m);
            g = a.encrypt(k(c, [0, 0, 0, b]));
            m = l.clamp(k(m.concat([0, 0, 0]), g), b);
            n = k(n, k(m.concat([0, 0, 0]), g));
            n = a.encrypt(k(n, k(c, h(c))));
            d.length && (n = k(n, f ? d : sjcl.mode.ocb2.pmac(a, d)));
            return p.concat(l.concat(m, l.clamp(n, e)));
          },
          decrypt: function(a, b, c, d, e, f) {
            128 !== sjcl.bitArray.bitLength(c) && q(new sjcl.exception.invalid("ocb iv must be 128 bits"));
            e = e || 64;
            var g = sjcl.mode.ocb2.H,
                h = sjcl.bitArray,
                l = h.l,
                k = [0, 0, 0, 0],
                n = g(a.encrypt(c)),
                m,
                p,
                s = sjcl.bitArray.bitLength(b) - e,
                r = [];
            d = d || [];
            for (c = 0; c + 4 < s / 32; c += 4)
              m = l(n, a.decrypt(l(n, b.slice(c, c + 4)))), k = l(k, m), r = r.concat(m), n = g(n);
            p = s - 32 * c;
            m = a.encrypt(l(n, [0, 0, 0, p]));
            m = l(m, h.clamp(b.slice(c), p).concat([0, 0, 0]));
            k = l(k, m);
            k = a.encrypt(l(k, l(n, g(n))));
            d.length && (k = l(k, f ? d : sjcl.mode.ocb2.pmac(a, d)));
            h.equal(h.clamp(k, e), h.bitSlice(b, s)) || q(new sjcl.exception.corrupt("ocb: tag doesn't match"));
            return r.concat(h.clamp(m, p));
          },
          pmac: function(a, b) {
            var c,
                d = sjcl.mode.ocb2.H,
                e = sjcl.bitArray,
                f = e.l,
                g = [0, 0, 0, 0],
                h = a.encrypt([0, 0, 0, 0]),
                h = f(h, d(d(h)));
            for (c = 0; c + 4 < b.length; c += 4)
              h = d(h), g = f(g, a.encrypt(f(h, b.slice(c, c + 4))));
            c = b.slice(c);
            128 > e.bitLength(c) && (h = f(h, d(h)), c = e.concat(c, [-2147483648, 0, 0, 0]));
            g = f(g, c);
            return a.encrypt(f(d(f(h, d(h))), g));
          },
          H: function(a) {
            return [a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ 135 * (a[0] >>> 31)];
          }
        };
        sjcl.mode.gcm = {
          name: "gcm",
          encrypt: function(a, b, c, d, e) {
            var f = b.slice(0);
            b = sjcl.bitArray;
            d = d || [];
            a = sjcl.mode.gcm.p(!0, a, f, d, c, e || 128);
            return b.concat(a.data, a.tag);
          },
          decrypt: function(a, b, c, d, e) {
            var f = b.slice(0),
                g = sjcl.bitArray,
                h = g.bitLength(f);
            e = e || 128;
            d = d || [];
            e <= h ? (b = g.bitSlice(f, h - e), f = g.bitSlice(f, 0, h - e)) : (b = f, f = []);
            a = sjcl.mode.gcm.p(u, a, f, d, c, e);
            g.equal(a.tag, b) || q(new sjcl.exception.corrupt("gcm: tag doesn't match"));
            return a.data;
          },
          Z: function(a, b) {
            var c,
                d,
                e,
                f,
                g,
                h = sjcl.bitArray.l;
            e = [0, 0, 0, 0];
            f = b.slice(0);
            for (c = 0; 128 > c; c++) {
              (d = 0 !== (a[Math.floor(c / 32)] & 1 << 31 - c % 32)) && (e = h(e, f));
              g = 0 !== (f[3] & 1);
              for (d = 3; 0 < d; d--)
                f[d] = f[d] >>> 1 | (f[d - 1] & 1) << 31;
              f[0] >>>= 1;
              g && (f[0] ^= -0x1f000000);
            }
            return e;
          },
          g: function(a, b, c) {
            var d,
                e = c.length;
            b = b.slice(0);
            for (d = 0; d < e; d += 4)
              b[0] ^= 0xffffffff & c[d], b[1] ^= 0xffffffff & c[d + 1], b[2] ^= 0xffffffff & c[d + 2], b[3] ^= 0xffffffff & c[d + 3], b = sjcl.mode.gcm.Z(b, a);
            return b;
          },
          p: function(a, b, c, d, e, f) {
            var g,
                h,
                l,
                k,
                n,
                m,
                p,
                s,
                r = sjcl.bitArray;
            m = c.length;
            p = r.bitLength(c);
            s = r.bitLength(d);
            h = r.bitLength(e);
            g = b.encrypt([0, 0, 0, 0]);
            96 === h ? (e = e.slice(0), e = r.concat(e, [1])) : (e = sjcl.mode.gcm.g(g, [0, 0, 0, 0], e), e = sjcl.mode.gcm.g(g, e, [0, 0, Math.floor(h / 0x100000000), h & 0xffffffff]));
            h = sjcl.mode.gcm.g(g, [0, 0, 0, 0], d);
            n = e.slice(0);
            d = h.slice(0);
            a || (d = sjcl.mode.gcm.g(g, h, c));
            for (k = 0; k < m; k += 4)
              n[3]++, l = b.encrypt(n), c[k] ^= l[0], c[k + 1] ^= l[1], c[k + 2] ^= l[2], c[k + 3] ^= l[3];
            c = r.clamp(c, p);
            a && (d = sjcl.mode.gcm.g(g, h, c));
            a = [Math.floor(s / 0x100000000), s & 0xffffffff, Math.floor(p / 0x100000000), p & 0xffffffff];
            d = sjcl.mode.gcm.g(g, d, a);
            l = b.encrypt(e);
            d[0] ^= l[0];
            d[1] ^= l[1];
            d[2] ^= l[2];
            d[3] ^= l[3];
            return {
              tag: r.bitSlice(d, 0, f),
              data: c
            };
          }
        };
        sjcl.misc.hmac = function(a, b) {
          this.M = b = b || sjcl.hash.sha256;
          var c = [[], []],
              d,
              e = b.prototype.blockSize / 32;
          this.n = [new b, new b];
          a.length > e && (a = b.hash(a));
          for (d = 0; d < e; d++)
            c[0][d] = a[d] ^ 909522486, c[1][d] = a[d] ^ 1549556828;
          this.n[0].update(c[0]);
          this.n[1].update(c[1]);
          this.G = new b(this.n[0]);
        };
        sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function(a) {
          this.Q && q(new sjcl.exception.invalid("encrypt on already updated hmac called!"));
          this.update(a);
          return this.digest(a);
        };
        sjcl.misc.hmac.prototype.reset = function() {
          this.G = new this.M(this.n[0]);
          this.Q = u;
        };
        sjcl.misc.hmac.prototype.update = function(a) {
          this.Q = !0;
          this.G.update(a);
        };
        sjcl.misc.hmac.prototype.digest = function() {
          var a = this.G.finalize(),
              a = (new this.M(this.n[1])).update(a).finalize();
          this.reset();
          return a;
        };
        sjcl.misc.pbkdf2 = function(a, b, c, d, e) {
          c = c || 1E3;
          (0 > d || 0 > c) && q(sjcl.exception.invalid("invalid params to pbkdf2"));
          "string" === typeof a && (a = sjcl.codec.utf8String.toBits(a));
          "string" === typeof b && (b = sjcl.codec.utf8String.toBits(b));
          e = e || sjcl.misc.hmac;
          a = new e(a);
          var f,
              g,
              h,
              l,
              k = [],
              n = sjcl.bitArray;
          for (l = 1; 32 * k.length < (d || 1); l++) {
            e = f = a.encrypt(n.concat(b, [l]));
            for (g = 1; g < c; g++) {
              f = a.encrypt(f);
              for (h = 0; h < f.length; h++)
                e[h] ^= f[h];
            }
            k = k.concat(e);
          }
          d && (k = n.clamp(k, d));
          return k;
        };
        sjcl.prng = function(a) {
          this.c = [new sjcl.hash.sha256];
          this.i = [0];
          this.F = 0;
          this.s = {};
          this.C = 0;
          this.K = {};
          this.O = this.d = this.j = this.W = 0;
          this.b = [0, 0, 0, 0, 0, 0, 0, 0];
          this.f = [0, 0, 0, 0];
          this.A = t;
          this.B = a;
          this.q = u;
          this.w = {
            progress: {},
            seeded: {}
          };
          this.m = this.V = 0;
          this.t = 1;
          this.u = 2;
          this.S = 0x10000;
          this.I = [0, 48, 64, 96, 128, 192, 0x100, 384, 512, 768, 1024];
          this.T = 3E4;
          this.R = 80;
        };
        sjcl.prng.prototype = {
          randomWords: function(a, b) {
            var c = [],
                d;
            d = this.isReady(b);
            var e;
            d === this.m && q(new sjcl.exception.notReady("generator isn't seeded"));
            if (d & this.u) {
              d = !(d & this.t);
              e = [];
              var f = 0,
                  g;
              this.O = e[0] = (new Date).valueOf() + this.T;
              for (g = 0; 16 > g; g++)
                e.push(0x100000000 * Math.random() | 0);
              for (g = 0; g < this.c.length && !(e = e.concat(this.c[g].finalize()), f += this.i[g], this.i[g] = 0, !d && this.F & 1 << g); g++)
                ;
              this.F >= 1 << this.c.length && (this.c.push(new sjcl.hash.sha256), this.i.push(0));
              this.d -= f;
              f > this.j && (this.j = f);
              this.F++;
              this.b = sjcl.hash.sha256.hash(this.b.concat(e));
              this.A = new sjcl.cipher.aes(this.b);
              for (d = 0; 4 > d && !(this.f[d] = this.f[d] + 1 | 0, this.f[d]); d++)
                ;
            }
            for (d = 0; d < a; d += 4)
              0 === (d + 1) % this.S && A(this), e = B(this), c.push(e[0], e[1], e[2], e[3]);
            A(this);
            return c.slice(0, a);
          },
          setDefaultParanoia: function(a, b) {
            0 === a && "Setting paranoia=0 will ruin your security; use it only for testing" !== b && q("Setting paranoia=0 will ruin your security; use it only for testing");
            this.B = a;
          },
          addEntropy: function(a, b, c) {
            c = c || "user";
            var d,
                e,
                f = (new Date).valueOf(),
                g = this.s[c],
                h = this.isReady(),
                l = 0;
            d = this.K[c];
            d === t && (d = this.K[c] = this.W++);
            g === t && (g = this.s[c] = 0);
            this.s[c] = (this.s[c] + 1) % this.c.length;
            switch (typeof a) {
              case "number":
                b === t && (b = 1);
                this.c[g].update([d, this.C++, 1, b, f, 1, a | 0]);
                break;
              case "object":
                c = Object.prototype.toString.call(a);
                if ("[object Uint32Array]" === c) {
                  e = [];
                  for (c = 0; c < a.length; c++)
                    e.push(a[c]);
                  a = e;
                } else {
                  "[object Array]" !== c && (l = 1);
                  for (c = 0; c < a.length && !l; c++)
                    "number" !== typeof a[c] && (l = 1);
                }
                if (!l) {
                  if (b === t)
                    for (c = b = 0; c < a.length; c++)
                      for (e = a[c]; 0 < e; )
                        b++, e >>>= 1;
                  this.c[g].update([d, this.C++, 2, b, f, a.length].concat(a));
                }
                break;
              case "string":
                b === t && (b = a.length);
                this.c[g].update([d, this.C++, 3, b, f, a.length]);
                this.c[g].update(a);
                break;
              default:
                l = 1;
            }
            l && q(new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string"));
            this.i[g] += b;
            this.d += b;
            h === this.m && (this.isReady() !== this.m && C("seeded", Math.max(this.j, this.d)), C("progress", this.getProgress()));
          },
          isReady: function(a) {
            a = this.I[a !== t ? a : this.B];
            return this.j && this.j >= a ? this.i[0] > this.R && (new Date).valueOf() > this.O ? this.u | this.t : this.t : this.d >= a ? this.u | this.m : this.m;
          },
          getProgress: function(a) {
            a = this.I[a ? a : this.B];
            return this.j >= a ? 1 : this.d > a ? 1 : this.d / a;
          },
          startCollectors: function() {
            this.q || (this.a = {
              loadTimeCollector: D(this, this.aa),
              mouseCollector: D(this, this.ba),
              keyboardCollector: D(this, this.$),
              accelerometerCollector: D(this, this.U)
            }, window.addEventListener ? (window.addEventListener("load", this.a.loadTimeCollector, u), window.addEventListener("mousemove", this.a.mouseCollector, u), window.addEventListener("keypress", this.a.keyboardCollector, u), window.addEventListener("devicemotion", this.a.accelerometerCollector, u)) : document.attachEvent ? (document.attachEvent("onload", this.a.loadTimeCollector), document.attachEvent("onmousemove", this.a.mouseCollector), document.attachEvent("keypress", this.a.keyboardCollector)) : q(new sjcl.exception.bug("can't attach event")), this.q = !0);
          },
          stopCollectors: function() {
            this.q && (window.removeEventListener ? (window.removeEventListener("load", this.a.loadTimeCollector, u), window.removeEventListener("mousemove", this.a.mouseCollector, u), window.removeEventListener("keypress", this.a.keyboardCollector, u), window.removeEventListener("devicemotion", this.a.accelerometerCollector, u)) : document.detachEvent && (document.detachEvent("onload", this.a.loadTimeCollector), document.detachEvent("onmousemove", this.a.mouseCollector), document.detachEvent("keypress", this.a.keyboardCollector)), this.q = u);
          },
          addEventListener: function(a, b) {
            this.w[a][this.V++] = b;
          },
          removeEventListener: function(a, b) {
            var c,
                d,
                e = this.w[a],
                f = [];
            for (d in e)
              e.hasOwnProperty(d) && e[d] === b && f.push(d);
            for (c = 0; c < f.length; c++)
              d = f[c], delete e[d];
          },
          $: function() {
            E(1);
          },
          ba: function(a) {
            sjcl.random.addEntropy([a.x || a.clientX || a.offsetX || 0, a.y || a.clientY || a.offsetY || 0], 2, "mouse");
            E(0);
          },
          aa: function() {
            E(2);
          },
          U: function(a) {
            a = a.accelerationIncludingGravity.x || a.accelerationIncludingGravity.y || a.accelerationIncludingGravity.z;
            if (window.orientation) {
              var b = window.orientation;
              "number" === typeof b && sjcl.random.addEntropy(b, 1, "accelerometer");
            }
            a && sjcl.random.addEntropy(a, 2, "accelerometer");
            E(0);
          }
        };
        function C(a, b) {
          var c,
              d = sjcl.random.w[a],
              e = [];
          for (c in d)
            d.hasOwnProperty(c) && e.push(d[c]);
          for (c = 0; c < e.length; c++)
            e[c](b);
        }
        function E(a) {
          window && window.performance && "function" === typeof window.performance.now ? sjcl.random.addEntropy(window.performance.now(), a, "loadtime") : sjcl.random.addEntropy((new Date).valueOf(), a, "loadtime");
        }
        function A(a) {
          a.b = B(a).concat(B(a));
          a.A = new sjcl.cipher.aes(a.b);
        }
        function B(a) {
          for (var b = 0; 4 > b && !(a.f[b] = a.f[b] + 1 | 0, a.f[b]); b++)
            ;
          return a.A.encrypt(a.f);
        }
        function D(a, b) {
          return function() {
            b.apply(a, arguments);
          };
        }
        sjcl.random = new sjcl.prng(6);
        a: try {
          var F,
              G,
              H,
              I;
          if (I = "undefined" !== typeof module) {
            var J;
            if (J = module.exports) {
              var K;
              try {
                K = require("crypto");
              } catch (L) {
                K = null;
              }
              J = (G = K) && G.randomBytes;
            }
            I = J;
          }
          if (I)
            F = G.randomBytes(128), F = new Uint32Array((new Uint8Array(F)).buffer), sjcl.random.addEntropy(F, 1024, "crypto['randomBytes']");
          else if (window && Uint32Array) {
            H = new Uint32Array(32);
            if (window.crypto && window.crypto.getRandomValues)
              window.crypto.getRandomValues(H);
            else if (window.msCrypto && window.msCrypto.getRandomValues)
              window.msCrypto.getRandomValues(H);
            else
              break a;
            sjcl.random.addEntropy(H, 1024, "crypto['getRandomValues']");
          }
        } catch (M) {
          "undefined" !== typeof window && window.console && (console.log("There was an error collecting entropy from the browser:"), console.log(M));
        }
        sjcl.json = {
          defaults: {
            v: 1,
            iter: 1E3,
            ks: 128,
            ts: 64,
            mode: "ccm",
            adata: "",
            cipher: "aes"
          },
          Y: function(a, b, c, d) {
            c = c || {};
            d = d || {};
            var e = sjcl.json,
                f = e.e({iv: sjcl.random.randomWords(4, 0)}, e.defaults),
                g;
            e.e(f, c);
            c = f.adata;
            "string" === typeof f.salt && (f.salt = sjcl.codec.base64.toBits(f.salt));
            "string" === typeof f.iv && (f.iv = sjcl.codec.base64.toBits(f.iv));
            (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || "string" === typeof a && 100 >= f.iter || 64 !== f.ts && 96 !== f.ts && 128 !== f.ts || 128 !== f.ks && 192 !== f.ks && 0x100 !== f.ks || 2 > f.iv.length || 4 < f.iv.length) && q(new sjcl.exception.invalid("json encrypt: invalid parameters"));
            "string" === typeof a ? (g = sjcl.misc.cachedPbkdf2(a, f), a = g.key.slice(0, f.ks / 32), f.salt = g.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.publicKey && (g = a.kem(), f.kemtag = g.tag, a = g.key.slice(0, f.ks / 32));
            "string" === typeof b && (b = sjcl.codec.utf8String.toBits(b));
            "string" === typeof c && (c = sjcl.codec.utf8String.toBits(c));
            g = new sjcl.cipher[f.cipher](a);
            e.e(d, f);
            d.key = a;
            f.ct = sjcl.mode[f.mode].encrypt(g, b, f.iv, c, f.ts);
            return f;
          },
          encrypt: function(a, b, c, d) {
            var e = sjcl.json,
                f = e.Y.apply(e, arguments);
            return e.encode(f);
          },
          X: function(a, b, c, d) {
            c = c || {};
            d = d || {};
            var e = sjcl.json;
            b = e.e(e.e(e.e({}, e.defaults), b), c, !0);
            var f;
            c = b.adata;
            "string" === typeof b.salt && (b.salt = sjcl.codec.base64.toBits(b.salt));
            "string" === typeof b.iv && (b.iv = sjcl.codec.base64.toBits(b.iv));
            (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || "string" === typeof a && 100 >= b.iter || 64 !== b.ts && 96 !== b.ts && 128 !== b.ts || 128 !== b.ks && 192 !== b.ks && 0x100 !== b.ks || !b.iv || 2 > b.iv.length || 4 < b.iv.length) && q(new sjcl.exception.invalid("json decrypt: invalid parameters"));
            "string" === typeof a ? (f = sjcl.misc.cachedPbkdf2(a, b), a = f.key.slice(0, b.ks / 32), b.salt = f.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.secretKey && (a = a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0, b.ks / 32));
            "string" === typeof c && (c = sjcl.codec.utf8String.toBits(c));
            f = new sjcl.cipher[b.cipher](a);
            c = sjcl.mode[b.mode].decrypt(f, b.ct, b.iv, c, b.ts);
            e.e(d, b);
            d.key = a;
            return sjcl.codec.utf8String.fromBits(c);
          },
          decrypt: function(a, b, c, d) {
            var e = sjcl.json;
            return e.X(a, e.decode(b), c, d);
          },
          encode: function(a) {
            var b,
                c = "{",
                d = "";
            for (b in a)
              if (a.hasOwnProperty(b))
                switch (b.match(/^[a-z0-9]+$/i) || q(new sjcl.exception.invalid("json encode: invalid property name")), c += d + '"' + b + '":', d = ",", typeof a[b]) {
                  case "number":
                  case "boolean":
                    c += a[b];
                    break;
                  case "string":
                    c += '"' + escape(a[b]) + '"';
                    break;
                  case "object":
                    c += '"' + sjcl.codec.base64.fromBits(a[b], 0) + '"';
                    break;
                  default:
                    q(new sjcl.exception.bug("json encode: unsupported type"));
                }
            return c + "}";
          },
          decode: function(a) {
            a = a.replace(/\s/g, "");
            a.match(/^\{.*\}$/) || q(new sjcl.exception.invalid("json decode: this isn't json!"));
            a = a.replace(/^\{|\}$/g, "").split(/,/);
            var b = {},
                c,
                d;
            for (c = 0; c < a.length; c++)
              (d = a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i)) || q(new sjcl.exception.invalid("json decode: this isn't json!")), b[d[2]] = d[3] ? parseInt(d[3], 10) : d[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(d[4]) : unescape(d[4]);
            return b;
          },
          e: function(a, b, c) {
            a === t && (a = {});
            if (b === t)
              return a;
            for (var d in b)
              b.hasOwnProperty(d) && (c && (a[d] !== t && a[d] !== b[d]) && q(new sjcl.exception.invalid("required parameter overridden")), a[d] = b[d]);
            return a;
          },
          ea: function(a, b) {
            var c = {},
                d;
            for (d in a)
              a.hasOwnProperty(d) && a[d] !== b[d] && (c[d] = a[d]);
            return c;
          },
          da: function(a, b) {
            var c = {},
                d;
            for (d = 0; d < b.length; d++)
              a[b[d]] !== t && (c[b[d]] = a[b[d]]);
            return c;
          }
        };
        sjcl.encrypt = sjcl.json.encrypt;
        sjcl.decrypt = sjcl.json.decrypt;
        sjcl.misc.ca = {};
        sjcl.misc.cachedPbkdf2 = function(a, b) {
          var c = sjcl.misc.ca,
              d;
          b = b || {};
          d = b.iter || 1E3;
          c = c[a] = c[a] || {};
          d = c[d] = c[d] || {firstSalt: b.salt && b.salt.length ? b.salt.slice(0) : sjcl.random.randomWords(2, 0)};
          c = b.salt === t ? d.firstSalt : b.salt;
          d[c] = d[c] || sjcl.misc.pbkdf2(a, c, b.iter);
          return {
            key: d[c].slice(0),
            salt: c.slice(0)
          };
        };
      }, {"crypto": 35}],
      18: [function(require, module, exports) {
        (function(Buffer) {
          var io = require("socket.io-client");
          exports.install = function(self) {
            var sockets = {};
            self.deliver("http", function(path, msg, to) {
              if (!sockets[path.http]) {
                sockets[path.http] = io.connect(path.http);
                sockets[path.http].on("packet", function(packet) {
                  self.receive((new Buffer(packet.data, "base64")).toString("binary"), path);
                });
              }
              sockets[path.http].emit("packet", {data: msg.toString("base64")});
            });
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "socket.io-client": 19
      }],
      19: [function(require, module, exports) {
        var io = ('undefined' === typeof module ? {} : module.exports);
        (function() {
          (function(exports, global) {
            var io = exports;
            io.version = '0.9.17';
            io.protocol = 1;
            io.transports = [];
            io.j = [];
            io.sockets = {};
            io.connect = function(host, details) {
              var uri = io.util.parseUri(host),
                  uuri,
                  socket;
              if (global && global.location) {
                uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);
                uri.host = uri.host || (global.document ? global.document.domain : global.location.hostname);
                uri.port = uri.port || global.location.port;
              }
              uuri = io.util.uniqueUri(uri);
              var options = {
                host: uri.host,
                secure: 'https' == uri.protocol,
                port: uri.port || ('https' == uri.protocol ? 443 : 80),
                query: uri.query || ''
              };
              io.util.merge(options, details);
              if (options['force new connection'] || !io.sockets[uuri]) {
                socket = new io.Socket(options);
              }
              if (!options['force new connection'] && socket) {
                io.sockets[uuri] = socket;
              }
              socket = socket || io.sockets[uuri];
              return socket.of(uri.path.length > 1 ? uri.path : '');
            };
          })('object' === typeof module ? module.exports : (this.io = {}), this);
          (function(exports, global) {
            var util = exports.util = {};
            var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
            var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
            util.parseUri = function(str) {
              var m = re.exec(str || ''),
                  uri = {},
                  i = 14;
              while (i--) {
                uri[parts[i]] = m[i] || '';
              }
              return uri;
            };
            util.uniqueUri = function(uri) {
              var protocol = uri.protocol,
                  host = uri.host,
                  port = uri.port;
              if ('document' in global) {
                host = host || document.domain;
                port = port || (protocol == 'https' && document.location.protocol !== 'https:' ? 443 : document.location.port);
              } else {
                host = host || 'localhost';
                if (!port && protocol == 'https') {
                  port = 443;
                }
              }
              return (protocol || 'http') + '://' + host + ':' + (port || 80);
            };
            util.query = function(base, addition) {
              var query = util.chunkQuery(base || ''),
                  components = [];
              util.merge(query, util.chunkQuery(addition || ''));
              for (var part in query) {
                if (query.hasOwnProperty(part)) {
                  components.push(part + '=' + query[part]);
                }
              }
              return components.length ? '?' + components.join('&') : '';
            };
            util.chunkQuery = function(qs) {
              var query = {},
                  params = qs.split('&'),
                  i = 0,
                  l = params.length,
                  kv;
              for (; i < l; ++i) {
                kv = params[i].split('=');
                if (kv[0]) {
                  query[kv[0]] = kv[1];
                }
              }
              return query;
            };
            var pageLoaded = false;
            util.load = function(fn) {
              if ('document' in global && document.readyState === 'complete' || pageLoaded) {
                return fn();
              }
              util.on(global, 'load', fn, false);
            };
            util.on = function(element, event, fn, capture) {
              if (element.attachEvent) {
                element.attachEvent('on' + event, fn);
              } else if (element.addEventListener) {
                element.addEventListener(event, fn, capture);
              }
            };
            util.request = function(xdomain) {
              if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {
                return new XDomainRequest();
              }
              if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {
                return new XMLHttpRequest();
              }
              if (!xdomain) {
                try {
                  return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');
                } catch (e) {}
              }
              return null;
            };
            if ('undefined' != typeof window) {
              util.load(function() {
                pageLoaded = true;
              });
            }
            util.defer = function(fn) {
              if (!util.ua.webkit || 'undefined' != typeof importScripts) {
                return fn();
              }
              util.load(function() {
                setTimeout(fn, 100);
              });
            };
            util.merge = function merge(target, additional, deep, lastseen) {
              var seen = lastseen || [],
                  depth = typeof deep == 'undefined' ? 2 : deep,
                  prop;
              for (prop in additional) {
                if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {
                  if (typeof target[prop] !== 'object' || !depth) {
                    target[prop] = additional[prop];
                    seen.push(additional[prop]);
                  } else {
                    util.merge(target[prop], additional[prop], depth - 1, seen);
                  }
                }
              }
              return target;
            };
            util.mixin = function(ctor, ctor2) {
              util.merge(ctor.prototype, ctor2.prototype);
            };
            util.inherit = function(ctor, ctor2) {
              function f() {}
              ;
              f.prototype = ctor2.prototype;
              ctor.prototype = new f;
            };
            util.isArray = Array.isArray || function(obj) {
              return Object.prototype.toString.call(obj) === '[object Array]';
            };
            util.intersect = function(arr, arr2) {
              var ret = [],
                  longest = arr.length > arr2.length ? arr : arr2,
                  shortest = arr.length > arr2.length ? arr2 : arr;
              for (var i = 0,
                  l = shortest.length; i < l; i++) {
                if (~util.indexOf(longest, shortest[i]))
                  ret.push(shortest[i]);
              }
              return ret;
            };
            util.indexOf = function(arr, o, i) {
              for (var j = arr.length,
                  i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0; i < j && arr[i] !== o; i++) {}
              return j <= i ? -1 : i;
            };
            util.toArray = function(enu) {
              var arr = [];
              for (var i = 0,
                  l = enu.length; i < l; i++)
                arr.push(enu[i]);
              return arr;
            };
            util.ua = {};
            util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function() {
              try {
                var a = new XMLHttpRequest();
              } catch (e) {
                return false;
              }
              return a.withCredentials != undefined;
            })();
            util.ua.webkit = 'undefined' != typeof navigator && /webkit/i.test(navigator.userAgent);
            util.ua.iDevice = 'undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent);
          })('undefined' != typeof io ? io : module.exports, this);
          (function(exports, io) {
            exports.EventEmitter = EventEmitter;
            function EventEmitter() {}
            ;
            EventEmitter.prototype.on = function(name, fn) {
              if (!this.$events) {
                this.$events = {};
              }
              if (!this.$events[name]) {
                this.$events[name] = fn;
              } else if (io.util.isArray(this.$events[name])) {
                this.$events[name].push(fn);
              } else {
                this.$events[name] = [this.$events[name], fn];
              }
              return this;
            };
            EventEmitter.prototype.addListener = EventEmitter.prototype.on;
            EventEmitter.prototype.once = function(name, fn) {
              var self = this;
              function on() {
                self.removeListener(name, on);
                fn.apply(this, arguments);
              }
              ;
              on.listener = fn;
              this.on(name, on);
              return this;
            };
            EventEmitter.prototype.removeListener = function(name, fn) {
              if (this.$events && this.$events[name]) {
                var list = this.$events[name];
                if (io.util.isArray(list)) {
                  var pos = -1;
                  for (var i = 0,
                      l = list.length; i < l; i++) {
                    if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
                      pos = i;
                      break;
                    }
                  }
                  if (pos < 0) {
                    return this;
                  }
                  list.splice(pos, 1);
                  if (!list.length) {
                    delete this.$events[name];
                  }
                } else if (list === fn || (list.listener && list.listener === fn)) {
                  delete this.$events[name];
                }
              }
              return this;
            };
            EventEmitter.prototype.removeAllListeners = function(name) {
              if (name === undefined) {
                this.$events = {};
                return this;
              }
              if (this.$events && this.$events[name]) {
                this.$events[name] = null;
              }
              return this;
            };
            EventEmitter.prototype.listeners = function(name) {
              if (!this.$events) {
                this.$events = {};
              }
              if (!this.$events[name]) {
                this.$events[name] = [];
              }
              if (!io.util.isArray(this.$events[name])) {
                this.$events[name] = [this.$events[name]];
              }
              return this.$events[name];
            };
            EventEmitter.prototype.emit = function(name) {
              if (!this.$events) {
                return false;
              }
              var handler = this.$events[name];
              if (!handler) {
                return false;
              }
              var args = Array.prototype.slice.call(arguments, 1);
              if ('function' == typeof handler) {
                handler.apply(this, args);
              } else if (io.util.isArray(handler)) {
                var listeners = handler.slice();
                for (var i = 0,
                    l = listeners.length; i < l; i++) {
                  listeners[i].apply(this, args);
                }
              } else {
                return false;
              }
              return true;
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, nativeJSON) {
            "use strict";
            if (nativeJSON && nativeJSON.parse) {
              return exports.JSON = {
                parse: nativeJSON.parse,
                stringify: nativeJSON.stringify
              };
            }
            var JSON = exports.JSON = {};
            function f(n) {
              return n < 10 ? '0' + n : n;
            }
            function date(d, key) {
              return isFinite(d.valueOf()) ? d.getUTCFullYear() + '-' + f(d.getUTCMonth() + 1) + '-' + f(d.getUTCDate()) + 'T' + f(d.getUTCHours()) + ':' + f(d.getUTCMinutes()) + ':' + f(d.getUTCSeconds()) + 'Z' : null;
            }
            ;
            var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                gap,
                indent,
                meta = {
                  '\b': '\\b',
                  '\t': '\\t',
                  '\n': '\\n',
                  '\f': '\\f',
                  '\r': '\\r',
                  '"': '\\"',
                  '\\': '\\\\'
                },
                rep;
            function quote(string) {
              escapable.lastIndex = 0;
              return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
                var c = meta[a];
                return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
              }) + '"' : '"' + string + '"';
            }
            function str(key, holder) {
              var i,
                  k,
                  v,
                  length,
                  mind = gap,
                  partial,
                  value = holder[key];
              if (value instanceof Date) {
                value = date(key);
              }
              if (typeof rep === 'function') {
                value = rep.call(holder, key, value);
              }
              switch (typeof value) {
                case 'string':
                  return quote(value);
                case 'number':
                  return isFinite(value) ? String(value) : 'null';
                case 'boolean':
                case 'null':
                  return String(value);
                case 'object':
                  if (!value) {
                    return 'null';
                  }
                  gap += indent;
                  partial = [];
                  if (Object.prototype.toString.apply(value) === '[object Array]') {
                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                      partial[i] = str(i, value) || 'null';
                    }
                    v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                  }
                  if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                      if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                      }
                    }
                  } else {
                    for (k in value) {
                      if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                      }
                    }
                  }
                  v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
                  gap = mind;
                  return v;
              }
            }
            JSON.stringify = function(value, replacer, space) {
              var i;
              gap = '';
              indent = '';
              if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                  indent += ' ';
                }
              } else if (typeof space === 'string') {
                indent = space;
              }
              rep = replacer;
              if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
              }
              return str('', {'': value});
            };
            JSON.parse = function(text, reviver) {
              var j;
              function walk(holder, key) {
                var k,
                    v,
                    value = holder[key];
                if (value && typeof value === 'object') {
                  for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = walk(value, k);
                      if (v !== undefined) {
                        value[k] = v;
                      } else {
                        delete value[k];
                      }
                    }
                  }
                }
                return reviver.call(holder, key, value);
              }
              text = String(text);
              cx.lastIndex = 0;
              if (cx.test(text)) {
                text = text.replace(cx, function(a) {
                  return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
              }
              if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
                j = eval('(' + text + ')');
                return typeof reviver === 'function' ? walk({'': j}, '') : j;
              }
              throw new SyntaxError('JSON.parse');
            };
          })('undefined' != typeof io ? io : module.exports, typeof JSON !== 'undefined' ? JSON : undefined);
          (function(exports, io) {
            var parser = exports.parser = {};
            var packets = parser.packets = ['disconnect', 'connect', 'heartbeat', 'message', 'json', 'event', 'ack', 'error', 'noop'];
            var reasons = parser.reasons = ['transport not supported', 'client not handshaken', 'unauthorized'];
            var advice = parser.advice = ['reconnect'];
            var JSON = io.JSON,
                indexOf = io.util.indexOf;
            parser.encodePacket = function(packet) {
              var type = indexOf(packets, packet.type),
                  id = packet.id || '',
                  endpoint = packet.endpoint || '',
                  ack = packet.ack,
                  data = null;
              switch (packet.type) {
                case 'error':
                  var reason = packet.reason ? indexOf(reasons, packet.reason) : '',
                      adv = packet.advice ? indexOf(advice, packet.advice) : '';
                  if (reason !== '' || adv !== '')
                    data = reason + (adv !== '' ? ('+' + adv) : '');
                  break;
                case 'message':
                  if (packet.data !== '')
                    data = packet.data;
                  break;
                case 'event':
                  var ev = {name: packet.name};
                  if (packet.args && packet.args.length) {
                    ev.args = packet.args;
                  }
                  data = JSON.stringify(ev);
                  break;
                case 'json':
                  data = JSON.stringify(packet.data);
                  break;
                case 'connect':
                  if (packet.qs)
                    data = packet.qs;
                  break;
                case 'ack':
                  data = packet.ackId + (packet.args && packet.args.length ? '+' + JSON.stringify(packet.args) : '');
                  break;
              }
              var encoded = [type, id + (ack == 'data' ? '+' : ''), endpoint];
              if (data !== null && data !== undefined)
                encoded.push(data);
              return encoded.join(':');
            };
            parser.encodePayload = function(packets) {
              var decoded = '';
              if (packets.length == 1)
                return packets[0];
              for (var i = 0,
                  l = packets.length; i < l; i++) {
                var packet = packets[i];
                decoded += '\ufffd' + packet.length + '\ufffd' + packets[i];
              }
              return decoded;
            };
            var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
            parser.decodePacket = function(data) {
              var pieces = data.match(regexp);
              if (!pieces)
                return {};
              var id = pieces[2] || '',
                  data = pieces[5] || '',
                  packet = {
                    type: packets[pieces[1]],
                    endpoint: pieces[4] || ''
                  };
              if (id) {
                packet.id = id;
                if (pieces[3])
                  packet.ack = 'data';
                else
                  packet.ack = true;
              }
              switch (packet.type) {
                case 'error':
                  var pieces = data.split('+');
                  packet.reason = reasons[pieces[0]] || '';
                  packet.advice = advice[pieces[1]] || '';
                  break;
                case 'message':
                  packet.data = data || '';
                  break;
                case 'event':
                  try {
                    var opts = JSON.parse(data);
                    packet.name = opts.name;
                    packet.args = opts.args;
                  } catch (e) {}
                  packet.args = packet.args || [];
                  break;
                case 'json':
                  try {
                    packet.data = JSON.parse(data);
                  } catch (e) {}
                  break;
                case 'connect':
                  packet.qs = data || '';
                  break;
                case 'ack':
                  var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
                  if (pieces) {
                    packet.ackId = pieces[1];
                    packet.args = [];
                    if (pieces[3]) {
                      try {
                        packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
                      } catch (e) {}
                    }
                  }
                  break;
                case 'disconnect':
                case 'heartbeat':
                  break;
              }
              ;
              return packet;
            };
            parser.decodePayload = function(data) {
              if (data.charAt(0) == '\ufffd') {
                var ret = [];
                for (var i = 1,
                    length = ''; i < data.length; i++) {
                  if (data.charAt(i) == '\ufffd') {
                    ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));
                    i += Number(length) + 1;
                    length = '';
                  } else {
                    length += data.charAt(i);
                  }
                }
                return ret;
              } else {
                return [parser.decodePacket(data)];
              }
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, io) {
            exports.Transport = Transport;
            function Transport(socket, sessid) {
              this.socket = socket;
              this.sessid = sessid;
            }
            ;
            io.util.mixin(Transport, io.EventEmitter);
            Transport.prototype.heartbeats = function() {
              return true;
            };
            Transport.prototype.onData = function(data) {
              this.clearCloseTimeout();
              if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {
                this.setCloseTimeout();
              }
              if (data !== '') {
                var msgs = io.parser.decodePayload(data);
                if (msgs && msgs.length) {
                  for (var i = 0,
                      l = msgs.length; i < l; i++) {
                    this.onPacket(msgs[i]);
                  }
                }
              }
              return this;
            };
            Transport.prototype.onPacket = function(packet) {
              this.socket.setHeartbeatTimeout();
              if (packet.type == 'heartbeat') {
                return this.onHeartbeat();
              }
              if (packet.type == 'connect' && packet.endpoint == '') {
                this.onConnect();
              }
              if (packet.type == 'error' && packet.advice == 'reconnect') {
                this.isOpen = false;
              }
              this.socket.onPacket(packet);
              return this;
            };
            Transport.prototype.setCloseTimeout = function() {
              if (!this.closeTimeout) {
                var self = this;
                this.closeTimeout = setTimeout(function() {
                  self.onDisconnect();
                }, this.socket.closeTimeout);
              }
            };
            Transport.prototype.onDisconnect = function() {
              if (this.isOpen)
                this.close();
              this.clearTimeouts();
              this.socket.onDisconnect();
              return this;
            };
            Transport.prototype.onConnect = function() {
              this.socket.onConnect();
              return this;
            };
            Transport.prototype.clearCloseTimeout = function() {
              if (this.closeTimeout) {
                clearTimeout(this.closeTimeout);
                this.closeTimeout = null;
              }
            };
            Transport.prototype.clearTimeouts = function() {
              this.clearCloseTimeout();
              if (this.reopenTimeout) {
                clearTimeout(this.reopenTimeout);
              }
            };
            Transport.prototype.packet = function(packet) {
              this.send(io.parser.encodePacket(packet));
            };
            Transport.prototype.onHeartbeat = function(heartbeat) {
              this.packet({type: 'heartbeat'});
            };
            Transport.prototype.onOpen = function() {
              this.isOpen = true;
              this.clearCloseTimeout();
              this.socket.onOpen();
            };
            Transport.prototype.onClose = function() {
              var self = this;
              this.isOpen = false;
              this.socket.onClose();
              this.onDisconnect();
            };
            Transport.prototype.prepareUrl = function() {
              var options = this.socket.options;
              return this.scheme() + '://' + options.host + ':' + options.port + '/' + options.resource + '/' + io.protocol + '/' + this.name + '/' + this.sessid;
            };
            Transport.prototype.ready = function(socket, fn) {
              fn.call(this);
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, io, global) {
            exports.Socket = Socket;
            function Socket(options) {
              this.options = {
                port: 80,
                secure: false,
                document: 'document' in global ? document : false,
                resource: 'socket.io',
                transports: io.transports,
                'connect timeout': 10000,
                'try multiple transports': true,
                'reconnect': true,
                'reconnection delay': 500,
                'reconnection limit': Infinity,
                'reopen delay': 3000,
                'max reconnection attempts': 10,
                'sync disconnect on unload': false,
                'auto connect': true,
                'flash policy port': 10843,
                'manualFlush': false
              };
              io.util.merge(this.options, options);
              this.connected = false;
              this.open = false;
              this.connecting = false;
              this.reconnecting = false;
              this.namespaces = {};
              this.buffer = [];
              this.doBuffer = false;
              if (this.options['sync disconnect on unload'] && (!this.isXDomain() || io.util.ua.hasCORS)) {
                var self = this;
                io.util.on(global, 'beforeunload', function() {
                  self.disconnectSync();
                }, false);
              }
              if (this.options['auto connect']) {
                this.connect();
              }
            }
            ;
            io.util.mixin(Socket, io.EventEmitter);
            Socket.prototype.of = function(name) {
              if (!this.namespaces[name]) {
                this.namespaces[name] = new io.SocketNamespace(this, name);
                if (name !== '') {
                  this.namespaces[name].packet({type: 'connect'});
                }
              }
              return this.namespaces[name];
            };
            Socket.prototype.publish = function() {
              this.emit.apply(this, arguments);
              var nsp;
              for (var i in this.namespaces) {
                if (this.namespaces.hasOwnProperty(i)) {
                  nsp = this.of(i);
                  nsp.$emit.apply(nsp, arguments);
                }
              }
            };
            function empty() {}
            ;
            Socket.prototype.handshake = function(fn) {
              var self = this,
                  options = this.options;
              function complete(data) {
                if (data instanceof Error) {
                  self.connecting = false;
                  self.onError(data.message);
                } else {
                  fn.apply(null, data.split(':'));
                }
              }
              ;
              var url = ['http' + (options.secure ? 's' : '') + ':/', options.host + ':' + options.port, options.resource, io.protocol, io.util.query(this.options.query, 't=' + +new Date)].join('/');
              if (this.isXDomain() && !io.util.ua.hasCORS) {
                var insertAt = document.getElementsByTagName('script')[0],
                    script = document.createElement('script');
                script.src = url + '&jsonp=' + io.j.length;
                insertAt.parentNode.insertBefore(script, insertAt);
                io.j.push(function(data) {
                  complete(data);
                  script.parentNode.removeChild(script);
                });
              } else {
                var xhr = io.util.request();
                xhr.open('GET', url, true);
                if (this.isXDomain()) {
                  xhr.withCredentials = true;
                }
                xhr.onreadystatechange = function() {
                  if (xhr.readyState == 4) {
                    xhr.onreadystatechange = empty;
                    if (xhr.status == 200) {
                      complete(xhr.responseText);
                    } else if (xhr.status == 403) {
                      self.onError(xhr.responseText);
                    } else {
                      self.connecting = false;
                      !self.reconnecting && self.onError(xhr.responseText);
                    }
                  }
                };
                xhr.send(null);
              }
            };
            Socket.prototype.getTransport = function(override) {
              var transports = override || this.transports,
                  match;
              for (var i = 0,
                  transport; transport = transports[i]; i++) {
                if (io.Transport[transport] && io.Transport[transport].check(this) && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {
                  return new io.Transport[transport](this, this.sessionid);
                }
              }
              return null;
            };
            Socket.prototype.connect = function(fn) {
              if (this.connecting) {
                return this;
              }
              var self = this;
              self.connecting = true;
              this.handshake(function(sid, heartbeat, close, transports) {
                self.sessionid = sid;
                self.closeTimeout = close * 1000;
                self.heartbeatTimeout = heartbeat * 1000;
                if (!self.transports)
                  self.transports = self.origTransports = (transports ? io.util.intersect(transports.split(','), self.options.transports) : self.options.transports);
                self.setHeartbeatTimeout();
                function connect(transports) {
                  if (self.transport)
                    self.transport.clearTimeouts();
                  self.transport = self.getTransport(transports);
                  if (!self.transport)
                    return self.publish('connect_failed');
                  self.transport.ready(self, function() {
                    self.connecting = true;
                    self.publish('connecting', self.transport.name);
                    self.transport.open();
                    if (self.options['connect timeout']) {
                      self.connectTimeoutTimer = setTimeout(function() {
                        if (!self.connected) {
                          self.connecting = false;
                          if (self.options['try multiple transports']) {
                            var remaining = self.transports;
                            while (remaining.length > 0 && remaining.splice(0, 1)[0] != self.transport.name) {}
                            if (remaining.length) {
                              connect(remaining);
                            } else {
                              self.publish('connect_failed');
                            }
                          }
                        }
                      }, self.options['connect timeout']);
                    }
                  });
                }
                connect(self.transports);
                self.once('connect', function() {
                  clearTimeout(self.connectTimeoutTimer);
                  fn && typeof fn == 'function' && fn();
                });
              });
              return this;
            };
            Socket.prototype.setHeartbeatTimeout = function() {
              clearTimeout(this.heartbeatTimeoutTimer);
              if (this.transport && !this.transport.heartbeats())
                return;
              var self = this;
              this.heartbeatTimeoutTimer = setTimeout(function() {
                self.transport.onClose();
              }, this.heartbeatTimeout);
            };
            Socket.prototype.packet = function(data) {
              if (this.connected && !this.doBuffer) {
                this.transport.packet(data);
              } else {
                this.buffer.push(data);
              }
              return this;
            };
            Socket.prototype.setBuffer = function(v) {
              this.doBuffer = v;
              if (!v && this.connected && this.buffer.length) {
                if (!this.options['manualFlush']) {
                  this.flushBuffer();
                }
              }
            };
            Socket.prototype.flushBuffer = function() {
              this.transport.payload(this.buffer);
              this.buffer = [];
            };
            Socket.prototype.disconnect = function() {
              if (this.connected || this.connecting) {
                if (this.open) {
                  this.of('').packet({type: 'disconnect'});
                }
                this.onDisconnect('booted');
              }
              return this;
            };
            Socket.prototype.disconnectSync = function() {
              var xhr = io.util.request();
              var uri = ['http' + (this.options.secure ? 's' : '') + ':/', this.options.host + ':' + this.options.port, this.options.resource, io.protocol, '', this.sessionid].join('/') + '/?disconnect=1';
              xhr.open('GET', uri, false);
              xhr.send(null);
              this.onDisconnect('booted');
            };
            Socket.prototype.isXDomain = function() {
              var port = global.location.port || ('https:' == global.location.protocol ? 443 : 80);
              return this.options.host !== global.location.hostname || this.options.port != port;
            };
            Socket.prototype.onConnect = function() {
              if (!this.connected) {
                this.connected = true;
                this.connecting = false;
                if (!this.doBuffer) {
                  this.setBuffer(false);
                }
                this.emit('connect');
              }
            };
            Socket.prototype.onOpen = function() {
              this.open = true;
            };
            Socket.prototype.onClose = function() {
              this.open = false;
              clearTimeout(this.heartbeatTimeoutTimer);
            };
            Socket.prototype.onPacket = function(packet) {
              this.of(packet.endpoint).onPacket(packet);
            };
            Socket.prototype.onError = function(err) {
              if (err && err.advice) {
                if (err.advice === 'reconnect' && (this.connected || this.connecting)) {
                  this.disconnect();
                  if (this.options.reconnect) {
                    this.reconnect();
                  }
                }
              }
              this.publish('error', err && err.reason ? err.reason : err);
            };
            Socket.prototype.onDisconnect = function(reason) {
              var wasConnected = this.connected,
                  wasConnecting = this.connecting;
              this.connected = false;
              this.connecting = false;
              this.open = false;
              if (wasConnected || wasConnecting) {
                this.transport.close();
                this.transport.clearTimeouts();
                if (wasConnected) {
                  this.publish('disconnect', reason);
                  if ('booted' != reason && this.options.reconnect && !this.reconnecting) {
                    this.reconnect();
                  }
                }
              }
            };
            Socket.prototype.reconnect = function() {
              this.reconnecting = true;
              this.reconnectionAttempts = 0;
              this.reconnectionDelay = this.options['reconnection delay'];
              var self = this,
                  maxAttempts = this.options['max reconnection attempts'],
                  tryMultiple = this.options['try multiple transports'],
                  limit = this.options['reconnection limit'];
              function reset() {
                if (self.connected) {
                  for (var i in self.namespaces) {
                    if (self.namespaces.hasOwnProperty(i) && '' !== i) {
                      self.namespaces[i].packet({type: 'connect'});
                    }
                  }
                  self.publish('reconnect', self.transport.name, self.reconnectionAttempts);
                }
                clearTimeout(self.reconnectionTimer);
                self.removeListener('connect_failed', maybeReconnect);
                self.removeListener('connect', maybeReconnect);
                self.reconnecting = false;
                delete self.reconnectionAttempts;
                delete self.reconnectionDelay;
                delete self.reconnectionTimer;
                delete self.redoTransports;
                self.options['try multiple transports'] = tryMultiple;
              }
              ;
              function maybeReconnect() {
                if (!self.reconnecting) {
                  return;
                }
                if (self.connected) {
                  return reset();
                }
                ;
                if (self.connecting && self.reconnecting) {
                  return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);
                }
                if (self.reconnectionAttempts++ >= maxAttempts) {
                  if (!self.redoTransports) {
                    self.on('connect_failed', maybeReconnect);
                    self.options['try multiple transports'] = true;
                    self.transports = self.origTransports;
                    self.transport = self.getTransport();
                    self.redoTransports = true;
                    self.connect();
                  } else {
                    self.publish('reconnect_failed');
                    reset();
                  }
                } else {
                  if (self.reconnectionDelay < limit) {
                    self.reconnectionDelay *= 2;
                  }
                  self.connect();
                  self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);
                  self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
                }
              }
              ;
              this.options['try multiple transports'] = false;
              this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);
              this.on('connect', maybeReconnect);
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          (function(exports, io) {
            exports.SocketNamespace = SocketNamespace;
            function SocketNamespace(socket, name) {
              this.socket = socket;
              this.name = name || '';
              this.flags = {};
              this.json = new Flag(this, 'json');
              this.ackPackets = 0;
              this.acks = {};
            }
            ;
            io.util.mixin(SocketNamespace, io.EventEmitter);
            SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;
            SocketNamespace.prototype.of = function() {
              return this.socket.of.apply(this.socket, arguments);
            };
            SocketNamespace.prototype.packet = function(packet) {
              packet.endpoint = this.name;
              this.socket.packet(packet);
              this.flags = {};
              return this;
            };
            SocketNamespace.prototype.send = function(data, fn) {
              var packet = {
                type: this.flags.json ? 'json' : 'message',
                data: data
              };
              if ('function' == typeof fn) {
                packet.id = ++this.ackPackets;
                packet.ack = true;
                this.acks[packet.id] = fn;
              }
              return this.packet(packet);
            };
            SocketNamespace.prototype.emit = function(name) {
              var args = Array.prototype.slice.call(arguments, 1),
                  lastArg = args[args.length - 1],
                  packet = {
                    type: 'event',
                    name: name
                  };
              if ('function' == typeof lastArg) {
                packet.id = ++this.ackPackets;
                packet.ack = 'data';
                this.acks[packet.id] = lastArg;
                args = args.slice(0, args.length - 1);
              }
              packet.args = args;
              return this.packet(packet);
            };
            SocketNamespace.prototype.disconnect = function() {
              if (this.name === '') {
                this.socket.disconnect();
              } else {
                this.packet({type: 'disconnect'});
                this.$emit('disconnect');
              }
              return this;
            };
            SocketNamespace.prototype.onPacket = function(packet) {
              var self = this;
              function ack() {
                self.packet({
                  type: 'ack',
                  args: io.util.toArray(arguments),
                  ackId: packet.id
                });
              }
              ;
              switch (packet.type) {
                case 'connect':
                  this.$emit('connect');
                  break;
                case 'disconnect':
                  if (this.name === '') {
                    this.socket.onDisconnect(packet.reason || 'booted');
                  } else {
                    this.$emit('disconnect', packet.reason);
                  }
                  break;
                case 'message':
                case 'json':
                  var params = ['message', packet.data];
                  if (packet.ack == 'data') {
                    params.push(ack);
                  } else if (packet.ack) {
                    this.packet({
                      type: 'ack',
                      ackId: packet.id
                    });
                  }
                  this.$emit.apply(this, params);
                  break;
                case 'event':
                  var params = [packet.name].concat(packet.args);
                  if (packet.ack == 'data')
                    params.push(ack);
                  this.$emit.apply(this, params);
                  break;
                case 'ack':
                  if (this.acks[packet.ackId]) {
                    this.acks[packet.ackId].apply(this, packet.args);
                    delete this.acks[packet.ackId];
                  }
                  break;
                case 'error':
                  if (packet.advice) {
                    this.socket.onError(packet);
                  } else {
                    if (packet.reason == 'unauthorized') {
                      this.$emit('connect_failed', packet.reason);
                    } else {
                      this.$emit('error', packet.reason);
                    }
                  }
                  break;
              }
            };
            function Flag(nsp, name) {
              this.namespace = nsp;
              this.name = name;
            }
            ;
            Flag.prototype.send = function() {
              this.namespace.flags[this.name] = true;
              this.namespace.send.apply(this.namespace, arguments);
            };
            Flag.prototype.emit = function() {
              this.namespace.flags[this.name] = true;
              this.namespace.emit.apply(this.namespace, arguments);
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, io, global) {
            exports.websocket = WS;
            function WS(socket) {
              io.Transport.apply(this, arguments);
            }
            ;
            io.util.inherit(WS, io.Transport);
            WS.prototype.name = 'websocket';
            WS.prototype.open = function() {
              var query = io.util.query(this.socket.options.query),
                  self = this,
                  Socket;
              if (!Socket) {
                Socket = global.MozWebSocket || global.WebSocket;
              }
              this.websocket = new Socket(this.prepareUrl() + query);
              this.websocket.onopen = function() {
                self.onOpen();
                self.socket.setBuffer(false);
              };
              this.websocket.onmessage = function(ev) {
                self.onData(ev.data);
              };
              this.websocket.onclose = function() {
                self.onClose();
                self.socket.setBuffer(true);
              };
              this.websocket.onerror = function(e) {
                self.onError(e);
              };
              return this;
            };
            if (io.util.ua.iDevice) {
              WS.prototype.send = function(data) {
                var self = this;
                setTimeout(function() {
                  self.websocket.send(data);
                }, 0);
                return this;
              };
            } else {
              WS.prototype.send = function(data) {
                this.websocket.send(data);
                return this;
              };
            }
            WS.prototype.payload = function(arr) {
              for (var i = 0,
                  l = arr.length; i < l; i++) {
                this.packet(arr[i]);
              }
              return this;
            };
            WS.prototype.close = function() {
              this.websocket.close();
              return this;
            };
            WS.prototype.onError = function(e) {
              this.socket.onError(e);
            };
            WS.prototype.scheme = function() {
              return this.socket.options.secure ? 'wss' : 'ws';
            };
            WS.check = function() {
              return ('WebSocket' in global && !('__addTask' in WebSocket)) || 'MozWebSocket' in global;
            };
            WS.xdomainCheck = function() {
              return true;
            };
            io.transports.push('websocket');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          (function(exports, io) {
            exports.flashsocket = Flashsocket;
            function Flashsocket() {
              io.Transport.websocket.apply(this, arguments);
            }
            ;
            io.util.inherit(Flashsocket, io.Transport.websocket);
            Flashsocket.prototype.name = 'flashsocket';
            Flashsocket.prototype.open = function() {
              var self = this,
                  args = arguments;
              WebSocket.__addTask(function() {
                io.Transport.websocket.prototype.open.apply(self, args);
              });
              return this;
            };
            Flashsocket.prototype.send = function() {
              var self = this,
                  args = arguments;
              WebSocket.__addTask(function() {
                io.Transport.websocket.prototype.send.apply(self, args);
              });
              return this;
            };
            Flashsocket.prototype.close = function() {
              WebSocket.__tasks.length = 0;
              io.Transport.websocket.prototype.close.call(this);
              return this;
            };
            Flashsocket.prototype.ready = function(socket, fn) {
              function init() {
                var options = socket.options,
                    port = options['flash policy port'],
                    path = ['http' + (options.secure ? 's' : '') + ':/', options.host + ':' + options.port, options.resource, 'static/flashsocket', 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'];
                if (!Flashsocket.loaded) {
                  if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {
                    WEB_SOCKET_SWF_LOCATION = path.join('/');
                  }
                  if (port !== 843) {
                    WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);
                  }
                  WebSocket.__initialize();
                  Flashsocket.loaded = true;
                }
                fn.call(self);
              }
              var self = this;
              if (document.body)
                return init();
              io.util.load(init);
            };
            Flashsocket.check = function() {
              if (typeof WebSocket == 'undefined' || !('__initialize' in WebSocket) || !swfobject)
                return false;
              return swfobject.getFlashPlayerVersion().major >= 10;
            };
            Flashsocket.xdomainCheck = function() {
              return true;
            };
            if (typeof window != 'undefined') {
              WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;
            }
            io.transports.push('flashsocket');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          if ('undefined' != typeof window) {
            var swfobject = function() {
              var D = "undefined",
                  r = "object",
                  S = "Shockwave Flash",
                  W = "ShockwaveFlash.ShockwaveFlash",
                  q = "application/x-shockwave-flash",
                  R = "SWFObjectExprInst",
                  x = "onreadystatechange",
                  O = window,
                  j = document,
                  t = navigator,
                  T = false,
                  U = [h],
                  o = [],
                  N = [],
                  I = [],
                  l,
                  Q,
                  E,
                  B,
                  J = false,
                  a = false,
                  n,
                  G,
                  m = true,
                  M = function() {
                    var aa = typeof j.getElementById != D && typeof j.getElementsByTagName != D && typeof j.createElement != D,
                        ah = t.userAgent.toLowerCase(),
                        Y = t.platform.toLowerCase(),
                        ae = Y ? /win/.test(Y) : /win/.test(ah),
                        ac = Y ? /mac/.test(Y) : /mac/.test(ah),
                        af = /webkit/.test(ah) ? parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false,
                        X = !+"\v1",
                        ag = [0, 0, 0],
                        ab = null;
                    if (typeof t.plugins != D && typeof t.plugins[S] == r) {
                      ab = t.plugins[S].description;
                      if (ab && !(typeof t.mimeTypes != D && t.mimeTypes[q] && !t.mimeTypes[q].enabledPlugin)) {
                        T = true;
                        X = false;
                        ab = ab.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
                        ag[0] = parseInt(ab.replace(/^(.*)\..*$/, "$1"), 10);
                        ag[1] = parseInt(ab.replace(/^.*\.(.*)\s.*$/, "$1"), 10);
                        ag[2] = /[a-zA-Z]/.test(ab) ? parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0;
                      }
                    } else {
                      if (typeof O[(['Active'].concat('Object').join('X'))] != D) {
                        try {
                          var ad = new window[(['Active'].concat('Object').join('X'))](W);
                          if (ad) {
                            ab = ad.GetVariable("$version");
                            if (ab) {
                              X = true;
                              ab = ab.split(" ")[1].split(",");
                              ag = [parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10)];
                            }
                          }
                        } catch (Z) {}
                      }
                    }
                    return {
                      w3: aa,
                      pv: ag,
                      wk: af,
                      ie: X,
                      win: ae,
                      mac: ac
                    };
                  }(),
                  k = function() {
                    if (!M.w3) {
                      return;
                    }
                    if ((typeof j.readyState != D && j.readyState == "complete") || (typeof j.readyState == D && (j.getElementsByTagName("body")[0] || j.body))) {
                      f();
                    }
                    if (!J) {
                      if (typeof j.addEventListener != D) {
                        j.addEventListener("DOMContentLoaded", f, false);
                      }
                      if (M.ie && M.win) {
                        j.attachEvent(x, function() {
                          if (j.readyState == "complete") {
                            j.detachEvent(x, arguments.callee);
                            f();
                          }
                        });
                        if (O == top) {
                          (function() {
                            if (J) {
                              return;
                            }
                            try {
                              j.documentElement.doScroll("left");
                            } catch (X) {
                              setTimeout(arguments.callee, 0);
                              return;
                            }
                            f();
                          })();
                        }
                      }
                      if (M.wk) {
                        (function() {
                          if (J) {
                            return;
                          }
                          if (!/loaded|complete/.test(j.readyState)) {
                            setTimeout(arguments.callee, 0);
                            return;
                          }
                          f();
                        })();
                      }
                      s(f);
                    }
                  }();
              function f() {
                if (J) {
                  return;
                }
                try {
                  var Z = j.getElementsByTagName("body")[0].appendChild(C("span"));
                  Z.parentNode.removeChild(Z);
                } catch (aa) {
                  return;
                }
                J = true;
                var X = U.length;
                for (var Y = 0; Y < X; Y++) {
                  U[Y]();
                }
              }
              function K(X) {
                if (J) {
                  X();
                } else {
                  U[U.length] = X;
                }
              }
              function s(Y) {
                if (typeof O.addEventListener != D) {
                  O.addEventListener("load", Y, false);
                } else {
                  if (typeof j.addEventListener != D) {
                    j.addEventListener("load", Y, false);
                  } else {
                    if (typeof O.attachEvent != D) {
                      i(O, "onload", Y);
                    } else {
                      if (typeof O.onload == "function") {
                        var X = O.onload;
                        O.onload = function() {
                          X();
                          Y();
                        };
                      } else {
                        O.onload = Y;
                      }
                    }
                  }
                }
              }
              function h() {
                if (T) {
                  V();
                } else {
                  H();
                }
              }
              function V() {
                var X = j.getElementsByTagName("body")[0];
                var aa = C(r);
                aa.setAttribute("type", q);
                var Z = X.appendChild(aa);
                if (Z) {
                  var Y = 0;
                  (function() {
                    if (typeof Z.GetVariable != D) {
                      var ab = Z.GetVariable("$version");
                      if (ab) {
                        ab = ab.split(" ")[1].split(",");
                        M.pv = [parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10)];
                      }
                    } else {
                      if (Y < 10) {
                        Y++;
                        setTimeout(arguments.callee, 10);
                        return;
                      }
                    }
                    X.removeChild(aa);
                    Z = null;
                    H();
                  })();
                } else {
                  H();
                }
              }
              function H() {
                var ag = o.length;
                if (ag > 0) {
                  for (var af = 0; af < ag; af++) {
                    var Y = o[af].id;
                    var ab = o[af].callbackFn;
                    var aa = {
                      success: false,
                      id: Y
                    };
                    if (M.pv[0] > 0) {
                      var ae = c(Y);
                      if (ae) {
                        if (F(o[af].swfVersion) && !(M.wk && M.wk < 312)) {
                          w(Y, true);
                          if (ab) {
                            aa.success = true;
                            aa.ref = z(Y);
                            ab(aa);
                          }
                        } else {
                          if (o[af].expressInstall && A()) {
                            var ai = {};
                            ai.data = o[af].expressInstall;
                            ai.width = ae.getAttribute("width") || "0";
                            ai.height = ae.getAttribute("height") || "0";
                            if (ae.getAttribute("class")) {
                              ai.styleclass = ae.getAttribute("class");
                            }
                            if (ae.getAttribute("align")) {
                              ai.align = ae.getAttribute("align");
                            }
                            var ah = {};
                            var X = ae.getElementsByTagName("param");
                            var ac = X.length;
                            for (var ad = 0; ad < ac; ad++) {
                              if (X[ad].getAttribute("name").toLowerCase() != "movie") {
                                ah[X[ad].getAttribute("name")] = X[ad].getAttribute("value");
                              }
                            }
                            P(ai, ah, Y, ab);
                          } else {
                            p(ae);
                            if (ab) {
                              ab(aa);
                            }
                          }
                        }
                      }
                    } else {
                      w(Y, true);
                      if (ab) {
                        var Z = z(Y);
                        if (Z && typeof Z.SetVariable != D) {
                          aa.success = true;
                          aa.ref = Z;
                        }
                        ab(aa);
                      }
                    }
                  }
                }
              }
              function z(aa) {
                var X = null;
                var Y = c(aa);
                if (Y && Y.nodeName == "OBJECT") {
                  if (typeof Y.SetVariable != D) {
                    X = Y;
                  } else {
                    var Z = Y.getElementsByTagName(r)[0];
                    if (Z) {
                      X = Z;
                    }
                  }
                }
                return X;
              }
              function A() {
                return !a && F("6.0.65") && (M.win || M.mac) && !(M.wk && M.wk < 312);
              }
              function P(aa, ab, X, Z) {
                a = true;
                E = Z || null;
                B = {
                  success: false,
                  id: X
                };
                var ae = c(X);
                if (ae) {
                  if (ae.nodeName == "OBJECT") {
                    l = g(ae);
                    Q = null;
                  } else {
                    l = ae;
                    Q = X;
                  }
                  aa.id = R;
                  if (typeof aa.width == D || (!/%$/.test(aa.width) && parseInt(aa.width, 10) < 310)) {
                    aa.width = "310";
                  }
                  if (typeof aa.height == D || (!/%$/.test(aa.height) && parseInt(aa.height, 10) < 137)) {
                    aa.height = "137";
                  }
                  j.title = j.title.slice(0, 47) + " - Flash Player Installation";
                  var ad = M.ie && M.win ? (['Active'].concat('').join('X')) : "PlugIn",
                      ac = "MMredirectURL=" + O.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + ad + "&MMdoctitle=" + j.title;
                  if (typeof ab.flashvars != D) {
                    ab.flashvars += "&" + ac;
                  } else {
                    ab.flashvars = ac;
                  }
                  if (M.ie && M.win && ae.readyState != 4) {
                    var Y = C("div");
                    X += "SWFObjectNew";
                    Y.setAttribute("id", X);
                    ae.parentNode.insertBefore(Y, ae);
                    ae.style.display = "none";
                    (function() {
                      if (ae.readyState == 4) {
                        ae.parentNode.removeChild(ae);
                      } else {
                        setTimeout(arguments.callee, 10);
                      }
                    })();
                  }
                  u(aa, ab, X);
                }
              }
              function p(Y) {
                if (M.ie && M.win && Y.readyState != 4) {
                  var X = C("div");
                  Y.parentNode.insertBefore(X, Y);
                  X.parentNode.replaceChild(g(Y), X);
                  Y.style.display = "none";
                  (function() {
                    if (Y.readyState == 4) {
                      Y.parentNode.removeChild(Y);
                    } else {
                      setTimeout(arguments.callee, 10);
                    }
                  })();
                } else {
                  Y.parentNode.replaceChild(g(Y), Y);
                }
              }
              function g(ab) {
                var aa = C("div");
                if (M.win && M.ie) {
                  aa.innerHTML = ab.innerHTML;
                } else {
                  var Y = ab.getElementsByTagName(r)[0];
                  if (Y) {
                    var ad = Y.childNodes;
                    if (ad) {
                      var X = ad.length;
                      for (var Z = 0; Z < X; Z++) {
                        if (!(ad[Z].nodeType == 1 && ad[Z].nodeName == "PARAM") && !(ad[Z].nodeType == 8)) {
                          aa.appendChild(ad[Z].cloneNode(true));
                        }
                      }
                    }
                  }
                }
                return aa;
              }
              function u(ai, ag, Y) {
                var X,
                    aa = c(Y);
                if (M.wk && M.wk < 312) {
                  return X;
                }
                if (aa) {
                  if (typeof ai.id == D) {
                    ai.id = Y;
                  }
                  if (M.ie && M.win) {
                    var ah = "";
                    for (var ae in ai) {
                      if (ai[ae] != Object.prototype[ae]) {
                        if (ae.toLowerCase() == "data") {
                          ag.movie = ai[ae];
                        } else {
                          if (ae.toLowerCase() == "styleclass") {
                            ah += ' class="' + ai[ae] + '"';
                          } else {
                            if (ae.toLowerCase() != "classid") {
                              ah += " " + ae + '="' + ai[ae] + '"';
                            }
                          }
                        }
                      }
                    }
                    var af = "";
                    for (var ad in ag) {
                      if (ag[ad] != Object.prototype[ad]) {
                        af += '<param name="' + ad + '" value="' + ag[ad] + '" />';
                      }
                    }
                    aa.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + ah + ">" + af + "</object>";
                    N[N.length] = ai.id;
                    X = c(ai.id);
                  } else {
                    var Z = C(r);
                    Z.setAttribute("type", q);
                    for (var ac in ai) {
                      if (ai[ac] != Object.prototype[ac]) {
                        if (ac.toLowerCase() == "styleclass") {
                          Z.setAttribute("class", ai[ac]);
                        } else {
                          if (ac.toLowerCase() != "classid") {
                            Z.setAttribute(ac, ai[ac]);
                          }
                        }
                      }
                    }
                    for (var ab in ag) {
                      if (ag[ab] != Object.prototype[ab] && ab.toLowerCase() != "movie") {
                        e(Z, ab, ag[ab]);
                      }
                    }
                    aa.parentNode.replaceChild(Z, aa);
                    X = Z;
                  }
                }
                return X;
              }
              function e(Z, X, Y) {
                var aa = C("param");
                aa.setAttribute("name", X);
                aa.setAttribute("value", Y);
                Z.appendChild(aa);
              }
              function y(Y) {
                var X = c(Y);
                if (X && X.nodeName == "OBJECT") {
                  if (M.ie && M.win) {
                    X.style.display = "none";
                    (function() {
                      if (X.readyState == 4) {
                        b(Y);
                      } else {
                        setTimeout(arguments.callee, 10);
                      }
                    })();
                  } else {
                    X.parentNode.removeChild(X);
                  }
                }
              }
              function b(Z) {
                var Y = c(Z);
                if (Y) {
                  for (var X in Y) {
                    if (typeof Y[X] == "function") {
                      Y[X] = null;
                    }
                  }
                  Y.parentNode.removeChild(Y);
                }
              }
              function c(Z) {
                var X = null;
                try {
                  X = j.getElementById(Z);
                } catch (Y) {}
                return X;
              }
              function C(X) {
                return j.createElement(X);
              }
              function i(Z, X, Y) {
                Z.attachEvent(X, Y);
                I[I.length] = [Z, X, Y];
              }
              function F(Z) {
                var Y = M.pv,
                    X = Z.split(".");
                X[0] = parseInt(X[0], 10);
                X[1] = parseInt(X[1], 10) || 0;
                X[2] = parseInt(X[2], 10) || 0;
                return (Y[0] > X[0] || (Y[0] == X[0] && Y[1] > X[1]) || (Y[0] == X[0] && Y[1] == X[1] && Y[2] >= X[2])) ? true : false;
              }
              function v(ac, Y, ad, ab) {
                if (M.ie && M.mac) {
                  return;
                }
                var aa = j.getElementsByTagName("head")[0];
                if (!aa) {
                  return;
                }
                var X = (ad && typeof ad == "string") ? ad : "screen";
                if (ab) {
                  n = null;
                  G = null;
                }
                if (!n || G != X) {
                  var Z = C("style");
                  Z.setAttribute("type", "text/css");
                  Z.setAttribute("media", X);
                  n = aa.appendChild(Z);
                  if (M.ie && M.win && typeof j.styleSheets != D && j.styleSheets.length > 0) {
                    n = j.styleSheets[j.styleSheets.length - 1];
                  }
                  G = X;
                }
                if (M.ie && M.win) {
                  if (n && typeof n.addRule == r) {
                    n.addRule(ac, Y);
                  }
                } else {
                  if (n && typeof j.createTextNode != D) {
                    n.appendChild(j.createTextNode(ac + " {" + Y + "}"));
                  }
                }
              }
              function w(Z, X) {
                if (!m) {
                  return;
                }
                var Y = X ? "visible" : "hidden";
                if (J && c(Z)) {
                  c(Z).style.visibility = Y;
                } else {
                  v("#" + Z, "visibility:" + Y);
                }
              }
              function L(Y) {
                var Z = /[\\\"<>\.;]/;
                var X = Z.exec(Y) != null;
                return X && typeof encodeURIComponent != D ? encodeURIComponent(Y) : Y;
              }
              var d = function() {
                if (M.ie && M.win) {
                  window.attachEvent("onunload", function() {
                    var ac = I.length;
                    for (var ab = 0; ab < ac; ab++) {
                      I[ab][0].detachEvent(I[ab][1], I[ab][2]);
                    }
                    var Z = N.length;
                    for (var aa = 0; aa < Z; aa++) {
                      y(N[aa]);
                    }
                    for (var Y in M) {
                      M[Y] = null;
                    }
                    M = null;
                    for (var X in swfobject) {
                      swfobject[X] = null;
                    }
                    swfobject = null;
                  });
                }
              }();
              return {
                registerObject: function(ab, X, aa, Z) {
                  if (M.w3 && ab && X) {
                    var Y = {};
                    Y.id = ab;
                    Y.swfVersion = X;
                    Y.expressInstall = aa;
                    Y.callbackFn = Z;
                    o[o.length] = Y;
                    w(ab, false);
                  } else {
                    if (Z) {
                      Z({
                        success: false,
                        id: ab
                      });
                    }
                  }
                },
                getObjectById: function(X) {
                  if (M.w3) {
                    return z(X);
                  }
                },
                embedSWF: function(ab, ah, ae, ag, Y, aa, Z, ad, af, ac) {
                  var X = {
                    success: false,
                    id: ah
                  };
                  if (M.w3 && !(M.wk && M.wk < 312) && ab && ah && ae && ag && Y) {
                    w(ah, false);
                    K(function() {
                      ae += "";
                      ag += "";
                      var aj = {};
                      if (af && typeof af === r) {
                        for (var al in af) {
                          aj[al] = af[al];
                        }
                      }
                      aj.data = ab;
                      aj.width = ae;
                      aj.height = ag;
                      var am = {};
                      if (ad && typeof ad === r) {
                        for (var ak in ad) {
                          am[ak] = ad[ak];
                        }
                      }
                      if (Z && typeof Z === r) {
                        for (var ai in Z) {
                          if (typeof am.flashvars != D) {
                            am.flashvars += "&" + ai + "=" + Z[ai];
                          } else {
                            am.flashvars = ai + "=" + Z[ai];
                          }
                        }
                      }
                      if (F(Y)) {
                        var an = u(aj, am, ah);
                        if (aj.id == ah) {
                          w(ah, true);
                        }
                        X.success = true;
                        X.ref = an;
                      } else {
                        if (aa && A()) {
                          aj.data = aa;
                          P(aj, am, ah, ac);
                          return;
                        } else {
                          w(ah, true);
                        }
                      }
                      if (ac) {
                        ac(X);
                      }
                    });
                  } else {
                    if (ac) {
                      ac(X);
                    }
                  }
                },
                switchOffAutoHideShow: function() {
                  m = false;
                },
                ua: M,
                getFlashPlayerVersion: function() {
                  return {
                    major: M.pv[0],
                    minor: M.pv[1],
                    release: M.pv[2]
                  };
                },
                hasFlashPlayerVersion: F,
                createSWF: function(Z, Y, X) {
                  if (M.w3) {
                    return u(Z, Y, X);
                  } else {
                    return undefined;
                  }
                },
                showExpressInstall: function(Z, aa, X, Y) {
                  if (M.w3 && A()) {
                    P(Z, aa, X, Y);
                  }
                },
                removeSWF: function(X) {
                  if (M.w3) {
                    y(X);
                  }
                },
                createCSS: function(aa, Z, Y, X) {
                  if (M.w3) {
                    v(aa, Z, Y, X);
                  }
                },
                addDomLoadEvent: K,
                addLoadEvent: s,
                getQueryParamValue: function(aa) {
                  var Z = j.location.search || j.location.hash;
                  if (Z) {
                    if (/\?/.test(Z)) {
                      Z = Z.split("?")[1];
                    }
                    if (aa == null) {
                      return L(Z);
                    }
                    var Y = Z.split("&");
                    for (var X = 0; X < Y.length; X++) {
                      if (Y[X].substring(0, Y[X].indexOf("=")) == aa) {
                        return L(Y[X].substring((Y[X].indexOf("=") + 1)));
                      }
                    }
                  }
                  return "";
                },
                expressInstallCallback: function() {
                  if (a) {
                    var X = c(R);
                    if (X && l) {
                      X.parentNode.replaceChild(l, X);
                      if (Q) {
                        w(Q, true);
                        if (M.ie && M.win) {
                          l.style.display = "block";
                        }
                      }
                      if (E) {
                        E(B);
                      }
                    }
                    a = false;
                  }
                }
              };
            }();
          }
          (function() {
            if ('undefined' == typeof window || window.WebSocket)
              return;
            var console = window.console;
            if (!console || !console.log || !console.error) {
              console = {
                log: function() {},
                error: function() {}
              };
            }
            if (!swfobject.hasFlashPlayerVersion("10.0.0")) {
              console.error("Flash Player >= 10.0.0 is required.");
              return;
            }
            if (location.protocol == "file:") {
              console.error("WARNING: web-socket-js doesn't work in file:///... URL " + "unless you set Flash Security Settings properly. " + "Open the page via Web server i.e. http://...");
            }
            WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
              var self = this;
              self.__id = WebSocket.__nextId++;
              WebSocket.__instances[self.__id] = self;
              self.readyState = WebSocket.CONNECTING;
              self.bufferedAmount = 0;
              self.__events = {};
              if (!protocols) {
                protocols = [];
              } else if (typeof protocols == "string") {
                protocols = [protocols];
              }
              setTimeout(function() {
                WebSocket.__addTask(function() {
                  WebSocket.__flash.create(self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
                });
              }, 0);
            };
            WebSocket.prototype.send = function(data) {
              if (this.readyState == WebSocket.CONNECTING) {
                throw "INVALID_STATE_ERR: Web Socket connection has not been established";
              }
              var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
              if (result < 0) {
                return true;
              } else {
                this.bufferedAmount += result;
                return false;
              }
            };
            WebSocket.prototype.close = function() {
              if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
                return;
              }
              this.readyState = WebSocket.CLOSING;
              WebSocket.__flash.close(this.__id);
            };
            WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
              if (!(type in this.__events)) {
                this.__events[type] = [];
              }
              this.__events[type].push(listener);
            };
            WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
              if (!(type in this.__events))
                return;
              var events = this.__events[type];
              for (var i = events.length - 1; i >= 0; --i) {
                if (events[i] === listener) {
                  events.splice(i, 1);
                  break;
                }
              }
            };
            WebSocket.prototype.dispatchEvent = function(event) {
              var events = this.__events[event.type] || [];
              for (var i = 0; i < events.length; ++i) {
                events[i](event);
              }
              var handler = this["on" + event.type];
              if (handler)
                handler(event);
            };
            WebSocket.prototype.__handleEvent = function(flashEvent) {
              if ("readyState" in flashEvent) {
                this.readyState = flashEvent.readyState;
              }
              if ("protocol" in flashEvent) {
                this.protocol = flashEvent.protocol;
              }
              var jsEvent;
              if (flashEvent.type == "open" || flashEvent.type == "error") {
                jsEvent = this.__createSimpleEvent(flashEvent.type);
              } else if (flashEvent.type == "close") {
                jsEvent = this.__createSimpleEvent("close");
              } else if (flashEvent.type == "message") {
                var data = decodeURIComponent(flashEvent.message);
                jsEvent = this.__createMessageEvent("message", data);
              } else {
                throw "unknown event type: " + flashEvent.type;
              }
              this.dispatchEvent(jsEvent);
            };
            WebSocket.prototype.__createSimpleEvent = function(type) {
              if (document.createEvent && window.Event) {
                var event = document.createEvent("Event");
                event.initEvent(type, false, false);
                return event;
              } else {
                return {
                  type: type,
                  bubbles: false,
                  cancelable: false
                };
              }
            };
            WebSocket.prototype.__createMessageEvent = function(type, data) {
              if (document.createEvent && window.MessageEvent && !window.opera) {
                var event = document.createEvent("MessageEvent");
                event.initMessageEvent("message", false, false, data, null, null, window, null);
                return event;
              } else {
                return {
                  type: type,
                  data: data,
                  bubbles: false,
                  cancelable: false
                };
              }
            };
            WebSocket.CONNECTING = 0;
            WebSocket.OPEN = 1;
            WebSocket.CLOSING = 2;
            WebSocket.CLOSED = 3;
            WebSocket.__flash = null;
            WebSocket.__instances = {};
            WebSocket.__tasks = [];
            WebSocket.__nextId = 0;
            WebSocket.loadFlashPolicyFile = function(url) {
              WebSocket.__addTask(function() {
                WebSocket.__flash.loadManualPolicyFile(url);
              });
            };
            WebSocket.__initialize = function() {
              if (WebSocket.__flash)
                return;
              if (WebSocket.__swfLocation) {
                window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
              }
              if (!window.WEB_SOCKET_SWF_LOCATION) {
                console.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
                return;
              }
              var container = document.createElement("div");
              container.id = "webSocketContainer";
              container.style.position = "absolute";
              if (WebSocket.__isFlashLite()) {
                container.style.left = "0px";
                container.style.top = "0px";
              } else {
                container.style.left = "-100px";
                container.style.top = "-100px";
              }
              var holder = document.createElement("div");
              holder.id = "webSocketFlash";
              container.appendChild(holder);
              document.body.appendChild(container);
              swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION, "webSocketFlash", "1", "1", "10.0.0", null, null, {
                hasPriority: true,
                swliveconnect: true,
                allowScriptAccess: "always"
              }, null, function(e) {
                if (!e.success) {
                  console.error("[WebSocket] swfobject.embedSWF failed");
                }
              });
            };
            WebSocket.__onFlashInitialized = function() {
              setTimeout(function() {
                WebSocket.__flash = document.getElementById("webSocketFlash");
                WebSocket.__flash.setCallerUrl(location.href);
                WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
                for (var i = 0; i < WebSocket.__tasks.length; ++i) {
                  WebSocket.__tasks[i]();
                }
                WebSocket.__tasks = [];
              }, 0);
            };
            WebSocket.__onFlashEvent = function() {
              setTimeout(function() {
                try {
                  var events = WebSocket.__flash.receiveEvents();
                  for (var i = 0; i < events.length; ++i) {
                    WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
                  }
                } catch (e) {
                  console.error(e);
                }
              }, 0);
              return true;
            };
            WebSocket.__log = function(message) {
              console.log(decodeURIComponent(message));
            };
            WebSocket.__error = function(message) {
              console.error(decodeURIComponent(message));
            };
            WebSocket.__addTask = function(task) {
              if (WebSocket.__flash) {
                task();
              } else {
                WebSocket.__tasks.push(task);
              }
            };
            WebSocket.__isFlashLite = function() {
              if (!window.navigator || !window.navigator.mimeTypes) {
                return false;
              }
              var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
              if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
                return false;
              }
              return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
            };
            if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
              if (window.addEventListener) {
                window.addEventListener("load", function() {
                  WebSocket.__initialize();
                }, false);
              } else {
                window.attachEvent("onload", function() {
                  WebSocket.__initialize();
                });
              }
            }
          })();
          (function(exports, io, global) {
            exports.XHR = XHR;
            function XHR(socket) {
              if (!socket)
                return;
              io.Transport.apply(this, arguments);
              this.sendBuffer = [];
            }
            ;
            io.util.inherit(XHR, io.Transport);
            XHR.prototype.open = function() {
              this.socket.setBuffer(false);
              this.onOpen();
              this.get();
              this.setCloseTimeout();
              return this;
            };
            XHR.prototype.payload = function(payload) {
              var msgs = [];
              for (var i = 0,
                  l = payload.length; i < l; i++) {
                msgs.push(io.parser.encodePacket(payload[i]));
              }
              this.send(io.parser.encodePayload(msgs));
            };
            XHR.prototype.send = function(data) {
              this.post(data);
              return this;
            };
            function empty() {}
            ;
            XHR.prototype.post = function(data) {
              var self = this;
              this.socket.setBuffer(true);
              function stateChange() {
                if (this.readyState == 4) {
                  this.onreadystatechange = empty;
                  self.posting = false;
                  if (this.status == 200) {
                    self.socket.setBuffer(false);
                  } else {
                    self.onClose();
                  }
                }
              }
              function onload() {
                this.onload = empty;
                self.socket.setBuffer(false);
              }
              ;
              this.sendXHR = this.request('POST');
              if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {
                this.sendXHR.onload = this.sendXHR.onerror = onload;
              } else {
                this.sendXHR.onreadystatechange = stateChange;
              }
              this.sendXHR.send(data);
            };
            XHR.prototype.close = function() {
              this.onClose();
              return this;
            };
            XHR.prototype.request = function(method) {
              var req = io.util.request(this.socket.isXDomain()),
                  query = io.util.query(this.socket.options.query, 't=' + +new Date);
              req.open(method || 'GET', this.prepareUrl() + query, true);
              if (method == 'POST') {
                try {
                  if (req.setRequestHeader) {
                    req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
                  } else {
                    req.contentType = 'text/plain';
                  }
                } catch (e) {}
              }
              return req;
            };
            XHR.prototype.scheme = function() {
              return this.socket.options.secure ? 'https' : 'http';
            };
            XHR.check = function(socket, xdomain) {
              try {
                var request = io.util.request(xdomain),
                    usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),
                    socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),
                    isXProtocol = (global.location && socketProtocol != global.location.protocol);
                if (request && !(usesXDomReq && isXProtocol)) {
                  return true;
                }
              } catch (e) {}
              return false;
            };
            XHR.xdomainCheck = function(socket) {
              return XHR.check(socket, true);
            };
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          (function(exports, io) {
            exports.htmlfile = HTMLFile;
            function HTMLFile(socket) {
              io.Transport.XHR.apply(this, arguments);
            }
            ;
            io.util.inherit(HTMLFile, io.Transport.XHR);
            HTMLFile.prototype.name = 'htmlfile';
            HTMLFile.prototype.get = function() {
              this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
              this.doc.open();
              this.doc.write('<html></html>');
              this.doc.close();
              this.doc.parentWindow.s = this;
              var iframeC = this.doc.createElement('div');
              iframeC.className = 'socketio';
              this.doc.body.appendChild(iframeC);
              this.iframe = this.doc.createElement('iframe');
              iframeC.appendChild(this.iframe);
              var self = this,
                  query = io.util.query(this.socket.options.query, 't=' + +new Date);
              this.iframe.src = this.prepareUrl() + query;
              io.util.on(window, 'unload', function() {
                self.destroy();
              });
            };
            HTMLFile.prototype._ = function(data, doc) {
              data = data.replace(/\\\//g, '/');
              this.onData(data);
              try {
                var script = doc.getElementsByTagName('script')[0];
                script.parentNode.removeChild(script);
              } catch (e) {}
            };
            HTMLFile.prototype.destroy = function() {
              if (this.iframe) {
                try {
                  this.iframe.src = 'about:blank';
                } catch (e) {}
                this.doc = null;
                this.iframe.parentNode.removeChild(this.iframe);
                this.iframe = null;
                CollectGarbage();
              }
            };
            HTMLFile.prototype.close = function() {
              this.destroy();
              return io.Transport.XHR.prototype.close.call(this);
            };
            HTMLFile.check = function(socket) {
              if (typeof window != "undefined" && (['Active'].concat('Object').join('X')) in window) {
                try {
                  var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
                  return a && io.Transport.XHR.check(socket);
                } catch (e) {}
              }
              return false;
            };
            HTMLFile.xdomainCheck = function() {
              return false;
            };
            io.transports.push('htmlfile');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, io, global) {
            exports['xhr-polling'] = XHRPolling;
            function XHRPolling() {
              io.Transport.XHR.apply(this, arguments);
            }
            ;
            io.util.inherit(XHRPolling, io.Transport.XHR);
            io.util.merge(XHRPolling, io.Transport.XHR);
            XHRPolling.prototype.name = 'xhr-polling';
            XHRPolling.prototype.heartbeats = function() {
              return false;
            };
            XHRPolling.prototype.open = function() {
              var self = this;
              io.Transport.XHR.prototype.open.call(self);
              return false;
            };
            function empty() {}
            ;
            XHRPolling.prototype.get = function() {
              if (!this.isOpen)
                return;
              var self = this;
              function stateChange() {
                if (this.readyState == 4) {
                  this.onreadystatechange = empty;
                  if (this.status == 200) {
                    self.onData(this.responseText);
                    self.get();
                  } else {
                    self.onClose();
                  }
                }
              }
              ;
              function onload() {
                this.onload = empty;
                this.onerror = empty;
                self.retryCounter = 1;
                self.onData(this.responseText);
                self.get();
              }
              ;
              function onerror() {
                self.retryCounter++;
                if (!self.retryCounter || self.retryCounter > 3) {
                  self.onClose();
                } else {
                  self.get();
                }
              }
              ;
              this.xhr = this.request();
              if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {
                this.xhr.onload = onload;
                this.xhr.onerror = onerror;
              } else {
                this.xhr.onreadystatechange = stateChange;
              }
              this.xhr.send(null);
            };
            XHRPolling.prototype.onClose = function() {
              io.Transport.XHR.prototype.onClose.call(this);
              if (this.xhr) {
                this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
                try {
                  this.xhr.abort();
                } catch (e) {}
                this.xhr = null;
              }
            };
            XHRPolling.prototype.ready = function(socket, fn) {
              var self = this;
              io.util.defer(function() {
                fn.call(self);
              });
            };
            io.transports.push('xhr-polling');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          (function(exports, io, global) {
            var indicator = global.document && "MozAppearance" in global.document.documentElement.style;
            exports['jsonp-polling'] = JSONPPolling;
            function JSONPPolling(socket) {
              io.Transport['xhr-polling'].apply(this, arguments);
              this.index = io.j.length;
              var self = this;
              io.j.push(function(msg) {
                self._(msg);
              });
            }
            ;
            io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);
            JSONPPolling.prototype.name = 'jsonp-polling';
            JSONPPolling.prototype.post = function(data) {
              var self = this,
                  query = io.util.query(this.socket.options.query, 't=' + (+new Date) + '&i=' + this.index);
              if (!this.form) {
                var form = document.createElement('form'),
                    area = document.createElement('textarea'),
                    id = this.iframeId = 'socketio_iframe_' + this.index,
                    iframe;
                form.className = 'socketio';
                form.style.position = 'absolute';
                form.style.top = '0px';
                form.style.left = '0px';
                form.style.display = 'none';
                form.target = id;
                form.method = 'POST';
                form.setAttribute('accept-charset', 'utf-8');
                area.name = 'd';
                form.appendChild(area);
                document.body.appendChild(form);
                this.form = form;
                this.area = area;
              }
              this.form.action = this.prepareUrl() + query;
              function complete() {
                initIframe();
                self.socket.setBuffer(false);
              }
              ;
              function initIframe() {
                if (self.iframe) {
                  self.form.removeChild(self.iframe);
                }
                try {
                  iframe = document.createElement('<iframe name="' + self.iframeId + '">');
                } catch (e) {
                  iframe = document.createElement('iframe');
                  iframe.name = self.iframeId;
                }
                iframe.id = self.iframeId;
                self.form.appendChild(iframe);
                self.iframe = iframe;
              }
              ;
              initIframe();
              this.area.value = io.JSON.stringify(data);
              try {
                this.form.submit();
              } catch (e) {}
              if (this.iframe.attachEvent) {
                iframe.onreadystatechange = function() {
                  if (self.iframe.readyState == 'complete') {
                    complete();
                  }
                };
              } else {
                this.iframe.onload = complete;
              }
              this.socket.setBuffer(true);
            };
            JSONPPolling.prototype.get = function() {
              var self = this,
                  script = document.createElement('script'),
                  query = io.util.query(this.socket.options.query, 't=' + (+new Date) + '&i=' + this.index);
              if (this.script) {
                this.script.parentNode.removeChild(this.script);
                this.script = null;
              }
              script.async = true;
              script.src = this.prepareUrl() + query;
              script.onerror = function() {
                self.onClose();
              };
              var insertAt = document.getElementsByTagName('script')[0];
              insertAt.parentNode.insertBefore(script, insertAt);
              this.script = script;
              if (indicator) {
                setTimeout(function() {
                  var iframe = document.createElement('iframe');
                  document.body.appendChild(iframe);
                  document.body.removeChild(iframe);
                }, 100);
              }
            };
            JSONPPolling.prototype._ = function(msg) {
              this.onData(msg);
              if (this.isOpen) {
                this.get();
              }
              return this;
            };
            JSONPPolling.prototype.ready = function(socket, fn) {
              var self = this;
              if (!indicator)
                return fn.call(this);
              io.util.load(function() {
                fn.call(self);
              });
            };
            JSONPPolling.check = function() {
              return 'document' in global;
            };
            JSONPPolling.xdomainCheck = function() {
              return true;
            };
            io.transports.push('jsonp-polling');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          if (typeof define === "function" && define.amd) {
            define([], function() {
              return io;
            });
          }
        })();
      }, {}],
      20: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var warn = function() {
            console.log.apply(console, arguments);
            return undefined;
          };
          var debug = function() {};
          exports.debug = function(cb) {
            debug = cb;
          };
          var info = function() {};
          exports.info = function(cb) {
            info = cb;
          };
          var defaults = exports.defaults = {};
          defaults.chan_timeout = 10000;
          defaults.seek_timeout = 3000;
          defaults.chan_autoack = 1000;
          defaults.chan_resend = 2000;
          defaults.chan_outbuf = 100;
          defaults.chan_inbuf = 50;
          defaults.nat_timeout = 30 * 1000;
          defaults.idle_timeout = 2 * defaults.nat_timeout;
          defaults.link_timer = defaults.nat_timeout - (5 * 1000);
          defaults.link_max = 256;
          defaults.link_k = 8;
          var pathShareOrder = ["bluetooth", "webrtc", "ipv6", "ipv4", "http"];
          exports.switch = function() {
            var self = {
              seeds: [],
              locals: [],
              lines: {},
              bridges: {},
              bridgeLine: {},
              all: {},
              buckets: [],
              capacity: [],
              rels: {},
              raws: {},
              paths: [],
              bridgeCache: {},
              networks: {},
              CSets: {}
            };
            self.load = function(id) {
              if (typeof id != "object")
                return "bad keys";
              self.id = id;
              var err = loadkeys(self);
              if (err)
                return err;
              if (Object.keys(self.cs).length == 0)
                return "missing cipher sets";
              self.hashname = parts2hn(self.parts);
              return false;
            };
            self.make = keysgen;
            self.seed = true;
            self.pcounter = 1;
            self.receive = receive;
            self.deliver = function(type, callback) {
              self.networks[type] = callback;
            };
            self.send = function(path, msg, to) {
              if (!msg)
                return debug("send called w/ no packet, dropping", new Error().stack) && false;
              if (!path)
                return debug("send called w/ no path, dropping", new Error().stack) && false;
              if (!self.networks[path.type])
                return false;
              if (to)
                path = to.pathOut(path);
              debug("<<<<", Date(), msg.length, path && [path.type, path.ip, path.port, path.id].join(","), to && to.hashname);
              return self.networks[path.type](path, msg, to);
            };
            self.pathSet = function(path, del) {
              var existing;
              if (!path)
                return;
              if ((existing = pathMatch(path, self.paths))) {
                if (del)
                  self.paths.splice(self.paths.indexOf(existing), 1);
                return;
              }
              debug("local path add", JSON.stringify(path));
              info("self", path.type, JSON.stringify(path));
              self.paths.push(path);
              if (self.isOnline) {
                linkMaint(self);
              }
            };
            self.addSeed = addSeed;
            self.whois = whois;
            self.whokey = whokey;
            self.start = function(hashname, type, arg, cb) {
              var hn = self.whois(hashname);
              if (!hn)
                return cb("invalid hashname");
              return hn.start(type, arg, cb);
            };
            self.online = online;
            self.listen = function(type, callback) {
              if (typeof type != "string" || typeof callback != "function")
                return warn("invalid arguments to listen");
              if (type.substr(0, 1) !== "_")
                type = "_" + type;
              self.rels[type] = callback;
            };
            self.raw = function(type, callback) {
              if (typeof type != "string" || typeof callback != "function")
                return warn("invalid arguments to raw");
              self.raws[type] = callback;
            };
            self.raws["peer"] = inPeer;
            self.raws["connect"] = inConnect;
            self.raws["seek"] = inSeek;
            self.raws["path"] = inPath;
            self.raws["link"] = inLink;
            self.seek = seek;
            self.pencode = pencode;
            self.pdecode = pdecode;
            self.isLocalIP = isLocalIP;
            self.randomHEX = randomHEX;
            self.uriparse = uriparse;
            self.pathMatch = pathMatch;
            self.isHashname = function(hex) {
              return isHEX(hex, 64);
            };
            self.isBridge = isBridge;
            self.wraps = channelWraps;
            self.waits = [];
            self.waiting = false;
            self.wait = function(bool) {
              if (bool)
                return self.waits.push(true);
              self.waits.pop();
              if (self.waiting && self.waits.length == 0)
                self.waiting();
            };
            self.ping = function() {
              if (!self.tracer)
                self.tracer = randomHEX(16);
              var js = {
                type: "ping",
                trace: self.tracer
              };
              Object.keys(self.parts).forEach(function(csid) {
                js[csid] = true;
              });
              return js;
            };
            linkLoop(self);
            return self;
          };
          var channelWraps = {"bulk": function(chan) {
              var bulkIn = "";
              chan.callback = function(end, packet, chan, cb) {
                cb();
                if (packet.body)
                  bulkIn += packet.body;
                if (!chan.onBulk)
                  return;
                if (end)
                  chan.onBulk(end !== true ? end : false, bulkIn);
              };
              chan.bulk = function(data, callback) {
                while (data) {
                  var chunk = data.substr(0, 1000);
                  data = data.substr(1000);
                  var packet = {body: chunk};
                  if (!data)
                    packet.callback = callback;
                  chan.send(packet);
                }
                chan.end();
              };
            }};
          function linkLoop(self) {
            self.bridgeCache = {};
            linkMaint(self);
            setTimeout(function() {
              linkLoop(self);
            }, defaults.link_timer);
          }
          function hnReap(self) {
            var hn;
            function del(why) {
              if (hn.lineOut)
                delete self.lines[hn.lineOut];
              delete self.all[hn.hashname];
              debug("reaping ", hn.hashname, why);
            }
            Object.keys(self.all).forEach(function(h) {
              hn = self.all[h];
              debug("reap check", hn.hashname, Date.now() - hn.sentAt, Date.now() - hn.recvAt, Object.keys(hn.chans).length);
              if (hn.isSeed)
                return;
              if (Object.keys(hn.chans).length > 0)
                return;
              if (Date.now() - hn.at < hn.timeout())
                return;
              if (!hn.sentAt)
                return del("never sent anything, gc");
              if (!hn.recvAt)
                return del("sent open, never received");
              if (Date.now() - hn.sentAt > hn.timeout())
                return del("we stopped sending to them");
              if (Date.now() - hn.recvAt > hn.timeout())
                return del("they stopped responding to us");
            });
          }
          function linkMaint(self) {
            Object.keys(self.buckets).forEach(function(bucket) {
              var sorted = self.buckets[bucket].sort(function(a, b) {
                return a.age - b.age;
              });
              if (sorted.length)
                debug("link maintenance on bucket", bucket, sorted.length);
              sorted.slice(0, defaults.link_k).forEach(function(hn) {
                if (!hn.linked || !pathValid(hn.to))
                  return;
                if ((Date.now() - hn.linked.sentAt) < Math.ceil(defaults.link_timer / 2))
                  return;
                hn.linked.send({js: {seed: self.seed}});
              });
            });
          }
          function isBridge(arg) {
            var self = this;
            if (arg === true)
              self.bridging = true;
            if (self.bridging)
              return true;
            if (!arg)
              return self.bridging;
            var check = (typeof arg == "string") ? self.whois(arg) : arg;
            if (check && check.bridging)
              return true;
            return false;
          }
          function addSeed(arg) {
            var self = this;
            if (!arg.parts)
              return warn("invalid args to addSeed", arg);
            var seed = self.whokey(arg.parts, false, arg.keys);
            if (!seed)
              return warn("invalid seed info", arg);
            if (Array.isArray(arg.paths))
              arg.paths.forEach(function(path) {
                path = seed.pathGet(path);
                path.seed = true;
              });
            seed.isSeed = true;
            self.seeds.push(seed);
          }
          function online(callback) {
            var self = this;
            if (self.waits.length > 0)
              return self.waiting = function() {
                self.online(callback);
              };
            self.isOnline = true;
            self.send({type: "lan"}, pencode(self.ping()));
            var dones = self.seeds.length;
            if (!dones) {
              warn("no seeds");
              return callback(null, 0);
            }
            function done() {
              if (!dones)
                return;
              var alive = self.seeds.filter(function(seed) {
                return pathValid(seed.to);
              }).length;
              if (alive) {
                callback(null, alive);
                dones = 0;
                return;
              }
              dones--;
              if (!dones)
                callback(self.locals.length ? null : "offline", self.locals.length);
            }
            self.seeds.forEach(function(seed) {
              seed.link(function() {
                if (pathValid(seed.to))
                  seed.pathSync();
                done();
              });
            });
          }
          function receive(msg, path) {
            var self = this;
            var packet = pdecode(msg);
            if (!packet)
              return warn("failed to decode a packet from", path, (new Buffer(msg)).toString("hex"));
            if (packet.length == 2)
              return;
            packet.sender = path;
            packet.id = self.pcounter++;
            packet.at = Date.now();
            debug(">>>>", Date(), msg.length, packet.head.length, path && [path.type, path.ip, path.port, path.id].join(","));
            if (packet.js.type == "ping")
              return inPing(self, packet);
            if (packet.js.type == "pong")
              return inPong(self, packet);
            if (packet.head.length == 1) {
              var open = deopenize(self, packet);
              if (!open || !open.verify)
                return warn("couldn't decode open (possibly using the wrong public key?)", open && open.err);
              if (!isHEX(open.js.line, 32))
                return warn("invalid line id enclosed", open.js.line);
              if (open.js.to !== self.hashname)
                return warn("open for wrong hashname", open.js.to);
              var csid = partsMatch(self.parts, open.js.from);
              if (csid != open.csid)
                return warn("open with mismatch CSID", csid, open.csid);
              var from = self.whokey(open.js.from, open.key);
              if (!from)
                return warn("invalid hashname", open.js.from);
              from.csid = open.csid;
              if (typeof open.js.at != "number")
                return warn("invalid at", open.js.at);
              if (from.openAt && open.js.at < from.openAt)
                return debug("dropping older open");
              from.openAt = open.js.at;
              debug("inOpen verified", from.hashname, path && JSON.stringify(path.json));
              if (open.js.line == from.lineIn) {
                var age = Date.now() - (from.openAcked || 0);
                if ((age < defaults.seek_timeout) || (age < defaults.nat_timeout && from.openDup >= 3))
                  return;
                from.openDup++;
              } else {
                from.openDup = 0;
              }
              var openAck = from.open();
              from.active();
              from.openAcked = Date.now();
              path = from.pathIn(path);
              if (path)
                self.send(path, openAck, from);
              else if (from.relayChan)
                from.relayChan.send({body: openAck});
              if (open.js.line != from.lineIn) {
                from.lineIn = open.js.line;
                debug("new line", from.lineIn, from.lineOut);
                self.CSets[open.csid].openline(from, open);
                self.lines[from.lineOut] = from;
                Object.keys(from.chans).forEach(function(id) {
                  var chan = from.chans[id];
                  if (chan) {
                    if (!chan.recvAt)
                      return;
                    from.receive({js: {
                        c: chan.id,
                        err: "reset"
                      }});
                  }
                  delete from.chans[id];
                });
              }
              return;
            }
            if (packet.head.length == 0) {
              var lineID = packet.body.slice(0, 16).toString("hex");
              var from = self.lines[lineID];
              if (!from) {
                if (!self.bridgeLine[lineID])
                  return debug("unknown line received", lineID, packet.sender);
                debug("BRIDGE", JSON.stringify(self.bridgeLine[lineID]), lineID);
                var id = crypto.createHash("sha256").update(packet.body).digest("hex");
                if (self.bridgeCache[id])
                  return;
                self.bridgeCache[id] = true;
                return self.send(self.bridgeLine[lineID], pencode(false, packet.body));
              }
              var err;
              if ((err = self.CSets[from.csid].delineize(from, packet)))
                return debug("couldn't decrypt line", err, packet.sender);
              from.linedAt = from.openAt;
              from.active();
              from.receive(packet);
              return;
            }
            if (Object.keys(packet.js).length > 0)
              warn("dropping incoming packet of unknown type", packet.js, packet.sender);
          }
          function whokey(parts, key, keys) {
            var self = this;
            if (typeof parts != "object")
              return false;
            var csid = partsMatch(self.parts, parts);
            if (!csid)
              return false;
            var hn = self.whois(parts2hn(parts));
            if (!hn)
              return false;
            if (keys)
              key = keys[csid];
            var err = loadkey(self, hn, csid, key);
            if (err) {
              warn("whokey err", hn.hashname, err);
              return false;
            }
            if (crypto.createHash("sha256").update(hn.key).digest("hex") != parts[csid]) {
              warn("whokey part mismatch", hn.hashname, csid, parts[csid], crypto.createHash("sha256").update(hn.key).digest("hex"));
              delete hn.key;
              return false;
            }
            hn.parts = parts;
            return hn;
          }
          function whois(hashname) {
            var self = this;
            if (!hashname) {
              warn("whois called without a hashname", hashname, new Error().stack);
              return false;
            }
            if (typeof hashname != "string") {
              warn("wrong type, should be string", typeof hashname, hashname);
              return false;
            }
            if (!isHEX(hashname, 64)) {
              warn("whois called without a valid hashname", hashname);
              return false;
            }
            if (hashname === self.hashname) {
              debug("whois called for self");
              return false;
            }
            var hn = self.all[hashname];
            if (hn)
              return hn;
            hn = self.all[hashname] = {
              hashname: hashname,
              chans: {},
              self: self,
              paths: [],
              isAlive: 0,
              sendwait: []
            };
            hn.at = Date.now();
            hn.bucket = dhash(self.hashname, hashname);
            if (!self.buckets[hn.bucket])
              self.buckets[hn.bucket] = [];
            var sort = [self.hashname, hashname].sort();
            hn.chanOut = (sort[0] == self.hashname) ? 2 : 1;
            hn.start = channel;
            hn.raw = raw;
            hn.pathGet = function(path) {
              if (typeof path != "object" || typeof path.type != "string")
                return false;
              var match = pathMatch(path, hn.paths);
              if (match)
                return match;
              path = JSON.parse(JSON.stringify(path));
              if (!path.json)
                path.json = JSON.parse(JSON.stringify(path));
              debug("adding new path", hn.paths.length, JSON.stringify(path.json));
              info(hn.hashname, path.type, JSON.stringify(path.json));
              hn.paths.push(path);
              if (!isLocalPath(path))
                hn.isPublic = true;
              if (path.type == "ipv4")
                self.paths.forEach(function(path2) {
                  if (path2.type == "ipv4" && path2.ip == path.ip)
                    hn.isLocal = true;
                });
              return path;
            };
            hn.pathOut = function(path) {
              path = hn.pathGet(path);
              if (!path)
                return false;
              if (!path.sentAt && path.type == "ipv4")
                self.send(path, pencode());
              path.sentAt = Date.now();
              if (!pathValid(hn.to) && pathValid(path))
                hn.to = path;
              return path;
            };
            hn.pathEnd = function(path) {
              if (path.seed)
                return false;
              if (hn.to == path)
                hn.to = false;
              path.gone = true;
              var index = hn.paths.indexOf(path);
              if (index >= 0)
                hn.paths.splice(index, 1);
              debug("PATH END", JSON.stringify(path.json));
              return false;
            };
            hn.pathIn = function(path) {
              path = hn.pathGet(path);
              if (!path)
                return false;
              if (!path.recvAt && !path.sentAt) {
                debug("PATH INNEW", isLocalPath(path) ? "local" : "public", JSON.stringify(path.json), hn.paths.map(function(p) {
                  return JSON.stringify(p.json);
                }));
                if (path.type == "ipv4" && !isLocalIP(path.ip)) {
                  hn.ip = path.ip;
                  hn.port = path.port;
                }
                hn.paths.forEach(function(other) {
                  if (other == path)
                    return;
                  if (other.type != path.type)
                    return;
                  if (!pathValid(other))
                    return hn.pathEnd(other);
                  if (path.ip && other.ip == path.ip)
                    return hn.pathEnd(other);
                  if (path.type == "http")
                    return hn.pathEnd(other);
                });
                if (pathShareOrder.indexOf(path.type) == -1)
                  hn.bridging = true;
                if (isLocalPath(path) && !hn.isLocal) {
                  hn.isLocal = true;
                  hn.pathSync();
                }
              }
              path.recvAt = Date.now();
              hn.to = path;
              return path;
            };
            hn.active = function() {
              self.recvAt = Date.now();
              if (!hn.recvAt || (Date.now() - hn.recvAt) > defaults.nat_timeout)
                setTimeout(function() {
                  hn.pathSync();
                }, 10);
              hn.recvAt = Date.now();
              hn.sendwait.forEach(function(packet) {
                if (!hn.chans[packet.js.c])
                  return;
                hn.send(packet);
              });
              hn.sendwait = [];
            };
            hn.send = function(packet) {
              if (Buffer.isBuffer(packet))
                console.log("lined packet?!", hn.hashname, typeof hn.sendwait.length, new Error().stack);
              if (hn.lineIn) {
                debug("line sending", hn.hashname, hn.lineIn);
                var lined = self.CSets[hn.csid].lineize(hn, packet);
                hn.sentAt = Date.now();
                if (packet.to)
                  return self.send(packet.to, lined, hn);
                if (pathValid(hn.to))
                  return self.send(hn.to, lined, hn);
                if (hn.relayChan)
                  return hn.relayChan.send({body: lined});
              }
              hn.openAt = false;
              if (hn.sendwait.indexOf(packet) == -1)
                hn.sendwait.push(packet);
              debug("alive failthrough", hn.sendSeek, Object.keys(hn.vias || {}));
              if (hn.open())
                hn.paths.forEach(function(path) {
                  self.send(path, hn.open(), hn);
                });
              function vias() {
                if (!hn.vias)
                  return;
                var todo = hn.vias;
                delete hn.vias;
                Object.keys(todo).forEach(function(via) {
                  self.whois(via).peer(hn.hashname, todo[via]);
                });
              }
              if (hn.vias)
                return vias();
              if (!hn.sendSeek || (Date.now() - hn.sendSeek) > 5000) {
                hn.sendSeek = Date.now();
                self.seek(hn, function(err) {
                  if (!hn.sendwait.length)
                    return;
                  vias();
                });
              }
            };
            hn.receive = function(packet) {
              if (!packet.js || typeof packet.js.c != "number")
                return warn("dropping invalid channel packet", packet.js);
              packet.sender = hn.pathIn(packet.sender);
              packet.from = hn;
              var chan = hn.chans[packet.js.c];
              debug("LINEIN", chan && chan.type, JSON.stringify(packet.js), packet.body && packet.body.length);
              if (chan === false)
                return;
              if (chan)
                return chan.receive(packet);
              var listening = {};
              if (typeof packet.js.seq == "undefined")
                listening = self.raws;
              if (packet.js.seq === 0)
                listening = self.rels;
              if (!listening[packet.js.type])
                return;
              if (packet.js.c % 2 == hn.chanOut % 2)
                return warn("channel id incorrect", packet.js.c, hn.chanOut);
              var kind = (listening == self.raws) ? "raw" : "start";
              var chan = hn[kind](packet.js.type, {
                bare: true,
                id: packet.js.c
              }, listening[packet.js.type]);
              chan.receive(packet);
            };
            hn.chanEnded = function(id) {
              if (!hn.chans[id])
                return;
              debug("channel ended", id, hn.chans[id].type, hn.hashname);
              hn.chans[id] = false;
            };
            hn.sees = function(address) {
              if (typeof address != "string")
                warn("invalid see address", address, hn.hashname);
              if (typeof address != "string")
                return false;
              var parts = address.split(",");
              if (!self.isHashname(parts[0]) || parts[0] == self.hashname)
                return false;
              var see = self.whois(parts[0]);
              if (!see)
                return false;
              if (parts.length >= 4 && parts[2].split(".").length == 4 && parseInt(parts[3]) > 0)
                see.pathGet({
                  type: "ipv4",
                  ip: parts[2],
                  port: parseInt(parts[3])
                });
              if (!see.vias)
                see.vias = {};
              see.vias[hn.hashname] = see.cisd || parts[1];
              return see;
            };
            hn.seek = function(hashname, callback) {
              var bucket = dhash(hn.hashname, hashname);
              var prefix = hashname.substr(0, Math.ceil((255 - bucket) / 4) + 2);
              hn.raw("seek", {
                timeout: defaults.seek_timeout,
                retry: 3,
                js: {"seek": prefix}
              }, function(err, packet, chan) {
                callback(packet.js.err, Array.isArray(packet.js.see) ? packet.js.see : []);
              });
            };
            hn.address = function(to) {
              if (!to)
                return "";
              var csid = partsMatch(hn.parts, to.parts);
              if (!csid)
                return "";
              if (!hn.ip)
                return [hn.hashname, csid].join(",");
              return [hn.hashname, csid, hn.ip, hn.port].join(",");
            };
            hn.link = function(callback) {
              if (!callback)
                callback = function() {};
              debug("LINKTRY", hn.hashname);
              var js = {seed: self.seed};
              js.see = self.buckets[hn.bucket].sort(function(a, b) {
                return a.age - b.age;
              }).filter(function(a) {
                return a.seed;
              }).map(function(seed) {
                return seed.address(hn);
              }).slice(0, 8);
              if (js.see.length < 8)
                Object.keys(self.buckets).forEach(function(bucket) {
                  if (js.see.length >= 8)
                    return;
                  self.buckets[bucket].sort(function(a, b) {
                    return a.age - b.age;
                  }).forEach(function(seed) {
                    if (js.see.length >= 8 || !seed.seed || js.see.indexOf(seed.address(hn)) != -1)
                      return;
                    js.see.push(seed.address(hn));
                  });
                });
              if (self.isBridge(hn))
                js.bridges = self.paths.filter(function(path) {
                  return !isLocalPath(path);
                }).map(function(path) {
                  return path.type;
                });
              if (hn.linked) {
                hn.linked.send({js: js});
                return callback();
              }
              hn.linked = hn.raw("link", {
                retry: 3,
                js: js,
                timeout: defaults.idle_timeout
              }, function(err, packet, chan) {
                inLink(err, packet, chan);
                callback(packet.js.err);
              });
            };
            hn.peer = function(hashname, csid) {
              if (!csid || !self.parts[csid])
                return;
              var js = {"peer": hashname};
              js.paths = hn.pathsOut();
              hn.raw("peer", {
                timeout: defaults.nat_timeout,
                js: js,
                body: getkey(self, csid)
              }, function(err, packet, chan) {
                if (!chan.relayTo)
                  chan.relayTo = self.whois(hashname);
                inRelay(chan, packet);
              });
            };
            hn.open = function() {
              if (!hn.parts)
                return false;
              if (!hn.opened)
                hn.opened = openize(self, hn);
              return hn.opened;
            };
            hn.pathsOut = function() {
              var paths = [];
              self.paths.forEach(function(path) {
                if (isLocalPath(path) && !hn.isLocal)
                  return;
                paths.push(path);
              });
              return paths;
            };
            hn.pathSync = function() {
              if (hn.pathSyncing)
                return;
              hn.pathSyncing = true;
              debug("pathSync", hn.hashname);
              var js = {};
              var paths = hn.pathsOut();
              if (paths.length > 0)
                js.paths = paths;
              var alive = [];
              hn.raw("path", {
                js: js,
                timeout: 10 * 1000
              }, function(err, packet) {
                if (err) {
                  hn.pathSyncing = false;
                  return;
                }
                if (packet.from.isSeed && typeof packet.js.path == "object" && packet.js.path.type == "ipv4" && !isLocalIP(packet.js.path.ip)) {
                  debug("updating public ipv4", JSON.stringify(self.pub4), JSON.stringify(packet.js.path));
                  self.pathSet(self.pub4, true);
                  self.pub4 = {
                    type: "ipv4",
                    ip: packet.js.path.ip,
                    port: parseInt(packet.js.path.port)
                  };
                  self.pathSet(self.pub4);
                }
                if (!packet.sender)
                  return;
                alive.push(packet.sender);
                var best = packet.sender;
                alive.forEach(function(path) {
                  if (pathShareOrder.indexOf(best.type) < pathShareOrder.indexOf(path.type))
                    return;
                  if (isLocalPath(best))
                    return;
                  best = path;
                });
                debug("pathSync best", hn.hashname, JSON.stringify(best.json));
                hn.to = best;
              });
            };
            hn.ticket = function(packet) {
              if (self.pencode(packet).length > 1024)
                return false;
              return ticketize(self, hn, packet);
            };
            hn.ticketed = function(ticket) {
              packet = pdecode(ticket);
              if (!packet)
                return false;
              return deticketize(self, hn, packet);
            };
            return hn;
          }
          function seek(hn, callback) {
            var self = this;
            if (typeof hn == "string")
              hn = self.whois(hn);
            if (!callback)
              callback = function() {};
            if (!hn)
              return callback("invalid hashname");
            var did = {};
            var doing = {};
            var queue = [];
            var wise = {};
            var closest = 255;
            var seeds = [];
            Object.keys(self.buckets).forEach(function(bucket) {
              self.buckets[bucket].forEach(function(link) {
                if (link.hashname == hn)
                  return;
                if (link.seed && pathValid(link.to))
                  seeds.push(link);
              });
            });
            seeds.sort(function(a, b) {
              return dhash(hn.hashname, a.hashname) - dhash(hn.hashname, b.hashname);
            }).slice(0, 3).forEach(function(seed) {
              wise[seed.hashname] = true;
              queue.push(seed.hashname);
            });
            debug("seek starting with", queue, seeds.length);
            function sort() {
              queue = queue.sort(function(a, b) {
                return dhash(hn.hashname, a) - dhash(hn.hashname, b);
              });
            }
            function done(err) {
              Object.keys(did).forEach(function(k) {
                if (queue.indexOf(k) == -1)
                  queue.push(k);
              });
              Object.keys(doing).forEach(function(k) {
                if (queue.indexOf(k) == -1)
                  queue.push(k);
              });
              sort();
              while (cb = hn.seeking.shift())
                cb(err, queue.slice());
            }
            if (!hn.seeking)
              hn.seeking = [];
            hn.seeking.push(callback);
            if (hn.seeking.length > 1)
              return;
            function loop(onetime) {
              if (!hn.seeking.length)
                return;
              debug("SEEK LOOP", queue);
              if (Object.keys(doing).length == 0 && queue.length == 0)
                return done("failed to find the hashname");
              var mine = onetime || queue.shift();
              if (!mine)
                return;
              if (mine == hn.hashname)
                return done();
              if (did[mine] || doing[mine])
                return onetime || loop();
              var distance = dhash(hn.hashname, mine);
              if (distance > closest)
                return onetime || loop();
              if (wise[mine])
                closest = distance;
              doing[mine] = true;
              var to = self.whois(mine);
              to.seek(hn.hashname, function(err, sees) {
                sees.forEach(function(address) {
                  var see = to.sees(address);
                  if (!see)
                    return;
                  if (wise[to.hashname] && sees.indexOf(address) == 0)
                    wise[see.hashname] = true;
                  queue.push(see.hashname);
                });
                sort();
                did[mine] = true;
                delete doing[mine];
                onetime || loop();
              });
            }
            loop();
            loop();
            loop();
            self.locals.forEach(function(local) {
              loop(local.hashname);
            });
          }
          function raw(type, arg, callback) {
            var hn = this;
            var chan = {
              type: type,
              callback: callback
            };
            chan.id = arg.id;
            chan.startAt = Date.now();
            if (!chan.id) {
              chan.id = hn.chanOut;
              hn.chanOut += 2;
            }
            chan.isOut = (chan.id % 2 == hn.chanOut % 2);
            hn.chans[chan.id] = chan;
            function timer() {
              if (chan.timer)
                clearTimeout(chan.timer);
              chan.timer = setTimeout(function() {
                if (!chan.ended)
                  return hn.receive({js: {
                      err: "timeout",
                      c: chan.id
                    }});
                hn.chanEnded(chan.id);
              }, arg.timeout);
            }
            chan.timeout = function(timeout) {
              arg.timeout = timeout;
              timer();
            };
            chan.timeout(arg.timeout || defaults.chan_timeout);
            chan.hashname = hn.hashname;
            debug("new unreliable channel", hn.hashname, chan.type, chan.id);
            chan.receive = function(packet) {
              if (!hn.chans[chan.id])
                return debug("dropping receive packet to dead channel", chan.id, packet.js);
              chan.opened = true;
              chan.ended = chan.ended || packet.js.err || packet.js.end;
              chan.recvAt = Date.now();
              chan.last = packet.sender;
              chan.callback(chan.ended, packet, chan);
              timer();
            };
            chan.send = function(packet) {
              if (!hn.chans[chan.id])
                return debug("dropping send packet to dead channel", chan.id, packet.js);
              if (!packet.js)
                packet.js = {};
              packet.js.c = chan.id;
              chan.ended = chan.ended || packet.js.err || packet.js.end;
              chan.sentAt = Date.now();
              debug("SEND", chan.type, JSON.stringify(packet.js), packet.body && packet.body.length);
              hn.send(packet);
            };
            chan.end = function() {
              if (chan.ended)
                return;
              chan.send({js: {end: true}});
            };
            chan.fail = function(err) {
              if (chan.ended)
                return;
              chan.ended = err || "failed";
              hn.send({js: {
                  err: chan.ended,
                  c: chan.id
                }});
            };
            if (arg.js) {
              arg.js.type = type;
              chan.send(arg);
              if (arg.retry) {
                var at = 1000;
                function retry() {
                  if (chan.ended || chan.opened)
                    return;
                  chan.send(arg);
                  if (at < 4000)
                    at *= 2;
                  arg.retry--;
                  if (arg.retry)
                    setTimeout(retry, at);
                }
                ;
                setTimeout(retry, at);
              }
            }
            return chan;
          }
          function channel(type, arg, callback) {
            var hn = this;
            var chan = {
              inq: [],
              outq: [],
              outSeq: 0,
              inDone: -1,
              outConfirmed: -1,
              lastAck: -1,
              callback: callback
            };
            chan.id = arg.id;
            chan.startAt = Date.now();
            if (!chan.id) {
              chan.id = hn.chanOut;
              hn.chanOut += 2;
            }
            chan.isOut = (chan.id % 2 == hn.chanOut % 2);
            hn.chans[chan.id] = chan;
            if (!arg.bare && type.substr(0, 1) !== "_")
              type = "_" + type;
            chan.type = type;
            if (chan.type.substr(0, 1) != "_")
              chan.safe = true;
            chan.hashname = hn.hashname;
            debug("new channel", hn.hashname, chan.type, chan.id);
            chan.timeout = function(timeout) {
              arg.timeout = timeout;
            };
            chan.timeout(arg.timeout || defaults.chan_timeout);
            chan.wrap = function(wrap) {
              if (!channelWraps[wrap])
                return false;
              return channelWraps[wrap](chan);
            };
            function cleanup() {
              if (chan.timer)
                clearTimeout(chan.timer);
              chan.timer = setTimeout(function() {
                chan.ended = chan.ended || true;
                hn.chanEnded(chan.id);
              }, arg.timeout);
            }
            chan.receive = function(packet) {
              if (packet.js.err) {
                chan.inq = [];
                chan.ended = packet.js.err;
                chan.callback(packet.js.err, packet, chan, function() {});
                cleanup();
                return;
              }
              chan.recvAt = Date.now();
              chan.opened = true;
              chan.last = packet.sender;
              var ack = parseInt(packet.js.ack);
              if (ack > chan.outSeq)
                return warn("bad ack, dropping entirely", chan.outSeq, ack);
              var miss = Array.isArray(packet.js.miss) ? packet.js.miss : [];
              if (miss.length > 100) {
                warn("too many misses", miss.length, chan.id, packet.from.hashname);
                miss = miss.slice(0, 100);
              }
              if (miss.length > 0 || ack > chan.lastAck) {
                debug("miss processing", ack, chan.lastAck, miss, chan.outq.length);
                chan.lastAck = ack;
                var outq = chan.outq;
                chan.outq = [];
                outq.forEach(function(pold) {
                  if (pold.js.seq <= ack) {
                    if (pold.callback)
                      pold.callback();
                    if (pold.js.end)
                      cleanup();
                    return;
                  }
                  chan.outq.push(pold);
                  if (miss.indexOf(pold.js.seq) == -1)
                    return;
                  if (Date.now() - pold.resentAt < 1000)
                    return;
                  pold.resentAt = Date.now();
                  chan.ack(pold);
                });
              }
              var seq = packet.js.seq;
              if (!(seq >= 0))
                return;
              if (!chan.acker)
                chan.acker = setTimeout(function() {
                  delete chan.acker;
                  chan.ack();
                }, defaults.chan_autoack);
              if (seq <= chan.inDone || chan.inq[seq - (chan.inDone + 1)])
                return chan.forceAck = true;
              if (seq - chan.inDone > defaults.chan_inbuf) {
                warn("chan too far behind, dropping", seq, chan.inDone, chan.id, packet.from.hashname);
                return chan.forceAck = true;
              }
              chan.inq[seq - (chan.inDone + 1)] = packet;
              debug("INQ", Object.keys(chan.inq), chan.inDone, chan.handling);
              chan.handler();
            };
            chan.handler = function() {
              if (chan.handling)
                return;
              var packet = chan.inq[0];
              if (!packet && chan.inq.length > 0)
                chan.forceAck = true;
              if (!packet)
                return;
              chan.handling = true;
              chan.ended = chan.ended || packet.js.end;
              if (!chan.safe)
                packet.js = packet.js._ || {};
              chan.callback(chan.ended, packet, chan, function(ack) {
                chan.inq.shift();
                chan.inDone++;
                chan.handling = false;
                if (ack)
                  chan.ack();
                if (chan.ended)
                  cleanup();
                chan.handler();
              });
            };
            chan.resend = function() {
              if (chan.ended)
                return;
              if (!chan.outq.length)
                return;
              var lastpacket = chan.outq[chan.outq.length - 1];
              if (Date.now() - lastpacket.sentAt > arg.timeout) {
                hn.receive({js: {
                    err: "timeout",
                    c: chan.id
                  }});
                return;
              }
              debug("channel resending");
              chan.ack(lastpacket);
              setTimeout(function() {
                chan.resend();
              }, defaults.chan_resend);
            };
            chan.ack = function(packet) {
              if (!packet)
                debug("ACK CHECK", chan.id, chan.outConfirmed, chan.inDone);
              if (!packet) {
                if (!chan.forceAck && chan.outConfirmed == chan.inDone)
                  return;
                packet = {js: {}};
              }
              chan.forceAck = false;
              if (chan.inDone >= 0)
                chan.outConfirmed = packet.js.ack = chan.inDone;
              delete packet.js.miss;
              if (chan.inq.length > 0) {
                packet.js.miss = [];
                for (var i = 0; i < chan.inq.length; i++) {
                  if (!chan.inq[i])
                    packet.js.miss.push(chan.inDone + i + 1);
                }
              }
              packet.js.c = chan.id;
              debug("SEND", chan.type, JSON.stringify(packet.js));
              cleanup();
              hn.send(packet);
            };
            chan.send = function(arg) {
              if (!arg)
                arg = {};
              if (arg.err) {
                if (chan.ended)
                  return;
                chan.ended = arg.err;
                hn.send({js: {
                    err: arg.err,
                    c: chan.id
                  }});
                return cleanup();
              }
              var packet = {};
              packet.js = chan.safe ? arg.js : {_: arg.js};
              if (arg.type)
                packet.js.type = arg.type;
              if (arg.end)
                packet.js.end = arg.end;
              packet.body = arg.body;
              packet.callback = arg.callback;
              packet.js.seq = chan.outSeq++;
              packet.sentAt = Date.now();
              chan.outq.push(packet);
              chan.ack(packet);
              if (chan.resender)
                clearTimeout(chan.resender);
              chan.resender = setTimeout(function() {
                chan.resend();
              }, defaults.chan_resend);
              return chan;
            };
            chan.end = function() {
              if (chan.ended)
                return chan.ack();
              chan.send({js: {end: true}});
            };
            chan.fail = function(arg) {
              var err = "failed";
              if (typeof arg == "string")
                err = arg;
              if (typeof arg == "object" && arg.js && arg.js.err)
                err = arg.js.err;
              chan.send({err: err});
            };
            if (arg.js) {
              arg.type = type;
              chan.send(arg);
            }
            return chan;
          }
          function inRelay(chan, packet) {
            var to = chan.relayTo;
            var self = packet.from.self;
            if ((packet.js.err || packet.js.warn) && !chan.migrating && to.relayChan == chan && !to.to) {
              debug("relay failing, trying to migrate", to.hashname);
              chan.migrating = true;
              var bridges = [];
              to.paths.forEach(function(path) {
                if (!self.bridges[path.type])
                  return;
                Object.keys(self.bridges[path.type]).forEach(function(id) {
                  if (bridges.indexOf(id) == -1)
                    bridges.push(id);
                });
              });
              var done;
              bridges.forEach(function(id) {
                if (done)
                  return;
                if (id == to.hashname || id == packet.from.hashname)
                  return;
                var hn = self.whois(id);
                if (!pathValid(hn.to))
                  return;
                done = hn.peer(to.hashname, to.csid);
              });
            }
            if (packet.js.err || packet.js.end) {
              debug("ending relay from", chan.hashname, "to", to.hashname, packet.js.err || packet.js.end);
              if (to.relayChan == chan)
                to.relayChan = false;
              return;
            }
            if (to.to && to.to.recvAt < chan.startAt)
              to.to = false;
            to.relayChan = chan;
            var path = (packet.js.bridge) ? JSON.parse(JSON.stringify(packet.sender.json)) : false;
            if (packet.body && packet.body.length)
              self.receive(packet.body, path);
            to.pathSync();
          }
          function inConnect(err, packet, chan) {
            if (chan.relayTo)
              return inRelay(chan, packet);
            var to = chan.relayTo = packet.from.self.whokey(packet.js.from, packet.body);
            if (!chan.relayTo)
              return warn("invalid connect request from", packet.from.hashname, packet.js);
            chan.timeout(defaults.nat_timeout);
            if (Array.isArray(packet.js.paths))
              packet.js.paths.forEach(function(path) {
                if (typeof path.type != "string")
                  return debug("bad path", JSON.stringify(path));
                packet.from.self.send(path, to.open(), to);
              });
            chan.send({body: to.open()});
            packet.from.sees(to.hashname);
          }
          function relay(self, from, to, packet) {
            if (from.ended && !to.ended)
              return to.send({js: {err: "disconnected"}});
            if (to.ended && !from.ended)
              return from.send({js: {err: "disconnected"}});
            var js = {};
            if (self.isBridge(from.hashname) || self.isBridge(to.hashname)) {
              var bp = pdecode(packet.body);
              var id = bp && bp.body && bp.body.length > 16 && bp.body.slice(0, 16).toString("hex");
              if (id && bp.head.length == 0 && !to.bridged && to.last && !self.lines[id]) {
                to.bridged = true;
                debug("auto-bridging", to.hashname, id, JSON.stringify(to.last.json));
                self.bridgeLine[id] = JSON.parse(JSON.stringify(to.last.json));
              }
            }
            if (from.bridged && to.bridged)
              js = {"bridge": true};
            if (!from.relayed || Date.now() - from.relayed > 1000) {
              from.relayed = Date.now();
              from.relays = 0;
            }
            from.relays++;
            if (from.relays > 5) {
              debug("relay too fast, warning", from.relays);
              js.warn = "toofast";
            }
            from.relayed = Date.now();
            to.send({
              js: js,
              body: packet.body
            });
          }
          function inPeer(err, packet, chan) {
            if (err)
              return;
            var self = packet.from.self;
            if (chan.relay)
              return relay(self, chan, chan.relay, packet);
            if (!isHEX(packet.js.peer, 64))
              return;
            var peer = self.whois(packet.js.peer);
            if (!peer)
              return;
            if (!(pathValid(peer.to) || self.isBridge(packet.from.hashname) || self.isBridge(peer.hashname)))
              return debug("disconnected peer request");
            if (!Array.isArray(packet.js.paths))
              packet.js.paths = [];
            packet.from.paths.forEach(function(path) {
              if (!path.recvAt)
                return;
              if (pathShareOrder.indexOf(path.type) == -1)
                return;
              if (isLocalPath(path) && !peer.isLocal)
                return;
              packet.js.paths.push(path.json);
            });
            var js = {
              from: packet.from.parts,
              paths: []
            };
            packet.js.paths.forEach(function(path) {
              if (typeof path.type != "string")
                return;
              if (pathMatch(path, js.paths))
                return;
              js.paths.push(path);
            });
            chan.timeout(defaults.nat_timeout);
            chan.relay = peer.raw("connect", {
              js: js,
              body: packet.body
            }, function(err, packet, chan2) {
              if (err)
                return;
              relay(self, chan2, chan, packet);
            });
          }
          function inSeek(err, packet, chan) {
            if (err)
              return;
            if (!isHEX(packet.js.seek))
              return warn("invalid seek of ", packet.js.seek, "from:", packet.from.hashname);
            var self = packet.from.self;
            var seek = packet.js.seek;
            var see = [];
            var seen = {};
            var bucket = dhash(self.hashname, packet.js.seek);
            var links = self.buckets[bucket] ? self.buckets[bucket] : [];
            links.sort(function(a, b) {
              return a.age - b.age;
            }).forEach(function(seed) {
              if (see.length)
                return;
              if (!seed.seed)
                return;
              see.push(seed.address(packet.from));
              seen[seed.hashname] = true;
            });
            links.sort(function(a, b) {
              return dhash(seek, a.hashname) - dhash(seek, b.hashname);
            }).forEach(function(link) {
              if (seen[link.hashname])
                return;
              if (link.seed || link.hashname.substr(0, seek.length) == seek) {
                see.push(link.address(packet.from));
                seen[link.hashname] = true;
              }
            });
            var answer = {
              end: true,
              see: see.filter(function(x) {
                return x;
              }).slice(0, 8)
            };
            chan.send({js: answer});
          }
          function inLink(err, packet, chan) {
            if (err)
              return;
            var self = packet.from.self;
            chan.timeout(defaults.nat_timeout * 2);
            debug("LINKUP", packet.from.hashname);
            if (!packet.from.age)
              packet.from.age = Date.now();
            packet.from.linked = chan;
            packet.from.seed = packet.js.seed;
            if (self.buckets[packet.from.bucket].indexOf(packet.from) == -1)
              self.buckets[packet.from.bucket].push(packet.from);
            if (packet.from.seed && packet.from.isLocal && self.locals.indexOf(packet.from) == -1)
              self.locals.push(packet.from);
            if (!chan.sentAt)
              packet.from.link();
            if (Array.isArray(packet.js.see))
              packet.js.see.forEach(function(address) {
                var hn = packet.from.sees(address);
                if (!hn || hn.linked)
                  return;
                if (self.buckets[hn.bucket].length < defaults.link_k)
                  hn.link();
              });
            if (Array.isArray(packet.js.bridges))
              packet.js.bridges.forEach(function(type) {
                if (!self.bridges[type])
                  self.bridges[type] = {};
                self.bridges[type][packet.from.hashname] = Date.now();
              });
            chan.callback = inMaintenance;
          }
          function inMaintenance(err, packet, chan) {
            if (!packet.from || !packet.from.linked || packet.from.linked != chan)
              return;
            var self = packet.from.self;
            if (err) {
              debug("LINKDOWN", packet.from.hashname, err);
              delete packet.from.linked;
              var index = self.buckets[packet.from.bucket].indexOf(packet.from);
              if (index > -1)
                self.buckets[packet.from.bucket].splice(index, 1);
              if (chan.recvAt)
                packet.from.link();
              return;
            }
            packet.from.seed = packet.js.seed;
            if ((Date.now() - chan.sentAt) > Math.ceil(defaults.link_timer / 2))
              chan.send({js: {seed: self.seed}});
          }
          function inPath(err, packet, chan) {
            if (err)
              return;
            var self = packet.from.self;
            if (Array.isArray(packet.js.paths))
              packet.js.paths.forEach(function(path) {
                packet.from.pathGet(path);
              });
            packet.from.paths.forEach(function(path) {
              var js = {};
              if (pathShareOrder.indexOf(path.type) >= 0)
                js.path = path.json;
              chan.send({
                js: js,
                to: path
              });
            });
          }
          function inPing(self, packet) {
            if (packet.js.trace == self.tracer)
              return;
            if (self.locals.length > 1)
              return;
            if (self.lanSkip && self.lanSkip == packet.js.trace)
              return;
            debug("PING-PONG", packet.js, packet.sender);
            self.lanSkip = packet.js.trace;
            var csid = partsMatch(self.parts, packet.js);
            if (!csid)
              return;
            var js = {
              type: "pong",
              from: self.parts,
              trace: packet.js.trace
            };
            self.send(packet.sender, pencode(js, getkey(self, csid)));
          }
          function inPong(self, packet) {
            debug("PONG", JSON.stringify(packet.js), JSON.stringify(packet.sender));
            if (packet.js.trace != self.tracer)
              return;
            if (self.locals.length >= 5)
              return warn("locals full");
            if (!packet.body || packet.body.length == 0)
              return;
            var to = self.whokey(packet.js.from, packet.body);
            if (!to)
              return warn("invalid lan request from", packet.js.from, packet.sender);
            to.local = true;
            debug("local seed open", to.hashname, JSON.stringify(packet.sender));
            self.send(packet.sender, to.open(), to);
            to.link();
          }
          function isHEX(str, len) {
            if (typeof str !== "string")
              return false;
            if (len && str.length !== len)
              return false;
            if (str.replace(/[a-f0-9]+/i, "").length !== 0)
              return false;
            return true;
          }
          function dhash(h1, h2) {
            var n1 = hex2nib(h1);
            var n2 = hex2nib(h2);
            if (!n1.length || !n2.length)
              return -1;
            var sbtab = [-1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3];
            var ret = 252;
            for (var i = 0; i < n1.length; i++) {
              if (!n2[i])
                return ret;
              var diff = n1[i] ^ n2[i];
              if (diff)
                return ret + sbtab[diff];
              ret -= 4;
            }
            return ret;
          }
          function hex2nib(hex) {
            var ret = [];
            for (var i = 0; i < hex.length / 2; i++) {
              var bite = parseInt(hex.substr(i * 2, 2), 16);
              if (isNaN(bite))
                return [];
              ret[ret.length] = bite >> 4;
              ret[ret.length] = bite & 0xf;
            }
            return ret;
          }
          function pathMatch(path1, paths) {
            var match;
            if (!path1 || !Array.isArray(paths))
              return match;
            paths.forEach(function(path2) {
              if (!path2 || path2.type != path1.type)
                return;
              switch (path1.type) {
                case "ipv4":
                case "ipv6":
                  if (path1.ip == path2.ip && path1.port == path2.port)
                    match = path2;
                  break;
                case "http":
                  if (path1.http == path2.http)
                    match = path2;
                  break;
                default:
                  if (path1.id === path2.id)
                    match = path2;
              }
            });
            return match;
          }
          function pathValid(path) {
            if (!path || path.gone)
              return false;
            if (!path.recvAt)
              return false;
            if (Date.now() - path.recvAt < defaults.nat_timeout)
              return true;
            return false;
          }
          function partsMatch(parts1, parts2) {
            if (typeof parts1 != "object" || typeof parts2 != "object")
              return false;
            var ids = Object.keys(parts1).sort();
            var csid;
            while (csid = ids.pop())
              if (parts2[csid])
                return csid;
            return false;
          }
          function isLocalPath(path) {
            if (!path || !path.type)
              return false;
            if (path.type == "bluetooth")
              return true;
            if (path.type == "http" && typeof path.http == "string")
              return isLocalIP(require("url").parse(path.http).hostname);
            if (["ipv4", "ipv6"].indexOf(path.type) >= 0)
              return isLocalIP(path.ip);
            return false;
          }
          function isLocalIP(ip) {
            if (ip.indexOf(":") >= 0) {
              if (ip.indexOf("::") == 0)
                return true;
              if (ip.indexOf("fc00") == 0)
                return true;
              if (ip.indexOf("fe80") == 0)
                return true;
              return false;
            }
            var parts = ip.split(".");
            if (parts[0] == "0")
              return true;
            if (parts[0] == "127")
              return true;
            if (parts[0] == "10")
              return true;
            if (parts[0] == "192" && parts[1] == "168")
              return true;
            if (parts[0] == "172" && parts[1] >= 16 && parts[1] <= 31)
              return true;
            if (parts[0] == "169" && parts[1] == "254")
              return true;
            return false;
          }
          function randomHEX(len) {
            return crypto.randomBytes(len).toString("hex");
          }
          function parts2hn(parts) {
            var rollup = new Buffer(0);
            Object.keys(parts).sort().forEach(function(id) {
              rollup = crypto.createHash("sha256").update(Buffer.concat([rollup, new Buffer(id)])).digest();
              rollup = crypto.createHash("sha256").update(Buffer.concat([rollup, new Buffer(parts[id])])).digest();
            });
            return rollup.toString("hex");
          }
          function pencode(js, body) {
            if (!body && js && js.js) {
              body = js.body;
              js = js.js;
            }
            var head = (typeof js == "number") ? new Buffer(String.fromCharCode(js)) : new Buffer(js ? JSON.stringify(js) : "", "utf8");
            if (typeof body == "string")
              body = new Buffer(body, "binary");
            body = body || new Buffer(0);
            var len = new Buffer(2);
            len.writeInt16BE(head.length, 0);
            return Buffer.concat([len, head, body]);
          }
          function pdecode(packet) {
            if (!packet)
              return undefined;
            var buf = (typeof packet == "string") ? new Buffer(packet, "binary") : packet;
            if (packet.length < 2)
              return undefined;
            var len = buf.readUInt16BE(0);
            if (len > (buf.length - 2))
              return undefined;
            var head = buf.slice(2, len + 2);
            var body = buf.slice(len + 2);
            var js = {};
            if (len > 1) {
              try {
                js = JSON.parse(head.toString("utf8"));
              } catch (E) {
                console.log("couldn't parse JS", buf.toString("hex"), E);
                return undefined;
              }
            }
            return {
              js: js,
              length: buf.length,
              head: head.toString("binary"),
              body: body
            };
          }
          function getkey(id, csid) {
            return id.cs && id.cs[csid] && id.cs[csid].key;
          }
          function loadkeys(self) {
            self.cs = {};
            self.keys = {};
            self.parts = {};
            var err = false;
            Object.keys(self.id).forEach(function(csid) {
              if (csid.length != 2)
                return;
              self.cs[csid] = {};
              if (!self.CSets[csid])
                err = csid + " not supported";
              err = err || self.CSets[csid].loadkey(self.cs[csid], self.id[csid], self.id[csid + "_secret"]);
              self.keys[csid] = self.id[csid];
              self.parts[csid] = crypto.createHash("sha256").update(self.cs[csid].key).digest("hex");
            });
            return err;
          }
          function loadkey(self, id, csid, key) {
            id.csid = csid;
            return self.CSets[csid].loadkey(id, key);
          }
          function keysgen(cbDone, cbStep) {
            var self = this;
            var ret = {};
            var todo = Object.keys(self.CSets);
            if (todo.length == 0)
              return cbDone("no sets supported");
            function pop(err) {
              if (err)
                return cbDone(err);
              var csid = todo.pop();
              if (!csid) {
                self.load(ret);
                return cbDone(null, ret);
              }
              self.CSets[csid].genkey(ret, pop, cbStep);
            }
            pop();
          }
          function ticketize(self, to, inner) {
            if (!to.csid) {
              console.log("can't ticket w/ no key");
              return false;
            }
            var tcs = {};
            self.CSets[to.csid].loadkey(tcs, to.key);
            return self.CSets[to.csid].openize(self, tcs, pencode(inner));
          }
          function deticketize(self, from, open) {
            var ret;
            var csid = open.head.charCodeAt().toString(16);
            if (!self.CSets[csid] || csid != from.csid)
              ret = {err: "invalid CSID of " + csid};
            else {
              open.from = from;
              try {
                ret = self.CSets[csid].deopenize(self, open);
              } catch (E) {
                ret = {err: E};
              }
            }
            if (ret.err || !ret.inner) {
              debug("deticketize failed", ret.err);
              return false;
            }
            return ret.inner;
          }
          function openize(self, to) {
            if (!to.csid) {
              console.log("can't open w/ no key");
              return undefined;
            }
            if (!to.lineOut)
              to.lineOut = randomHEX(16);
            if (!to.lineAt)
              to.lineAt = Date.now();
            var inner = {};
            inner.at = to.lineAt;
            inner.to = to.hashname;
            inner.from = self.parts;
            inner.line = to.lineOut;
            return self.CSets[to.csid].openize(self, to, inner);
          }
          function deopenize(self, open) {
            var ret;
            var csid = open.head.charCodeAt().toString(16);
            if (!self.CSets[csid])
              return {err: "unknown CSID of " + csid};
            try {
              ret = self.CSets[csid].deopenize(self, open);
            } catch (E) {
              return {err: E};
            }
            ret.csid = csid;
            return ret;
          }
          var urllib = require("url");
          function uriparse(uri) {
            if (typeof uri !== "string")
              uri = "";
            var hashname = uri.match(/[0-9A-Fa-f]{64}/);
            if (!hashname)
              return urllib.parse(uri);
            var full = hashname[0];
            var part = full.substr(0, 32);
            var u = urllib.parse(uri.replace(full, part));
            if (u.hostname != part)
              return urllib.parse(uri);
            Object.keys(u).forEach(function(k) {
              if (typeof u[k] != "string")
                return;
              u[k] = u[k].replace(part, full);
            });
            return u;
          }
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "crypto": 35,
        "url": 70
      }],
      21: [function(require, module, exports) {
        exports.json = require("./seeds.json");
        exports.install = function(self, args) {
          var seeds = exports.json;
          if (args && args.seeds) {
            if (typeof args.seeds == "string")
              seeds = require(args.seeds);
            if (typeof args.seeds == "object")
              seeds = args.seeds;
          }
          Object.keys(seeds).forEach(function(seed) {
            self.addSeed(seeds[seed]);
          });
        };
      }, {"./seeds.json": 22}],
      22: [function(require, module, exports) {
        module.exports = {"876d5ce8956009afc010fc908ca29617a444db660cd5598d81bb6a5a2635ba7a": {
            "paths": [{
              "type": "http",
              "http": "http://azure.lewisl.net:42424"
            }, {
              "type": "http",
              "http": "http://191.236.53.66:42424"
            }, {
              "type": "ipv4",
              "ip": "191.236.53.66",
              "port": 42424
            }],
            "parts": {
              "2a": "a9b3da6d514c8aeb1cc001f5423dbf80f0c523a000b1087286fd1b18168d9e3e",
              "1a": "fc1c470beb1ca7fdb6ecf7a7e3b542e087e0e7705d91666e7a124bc2aeeea9bf"
            },
            "keys": {
              "2a": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Lb4LwKUW1D3XI/jK5cBtbO17e/6oSD5myO/wYOIyRcJpDgRe////94ugsPGO/FtDnNdWTJ8/bpRGkxnlHadSGA0K3hukx+SOSdddzB/wAp86l0eCuiIBeDfnBYvxC4KmiRHFHMXSRYq2HWSzH2Knz65g/6VI/Qe/F4M8+A19Wxq1RBDtLcigJtkUdJ/y4TUdSwAPaM/mcQFwjCqssC8sgH6LzqPP43+yloxqG5Hx4IsWgcnBzaCQh8yYbP04nH7fd19gPXyWCSjo3CdSwnvfCHiU/eulXT1wubMhR0ZI/XrF3fC8tglgAOsqSxBdwpWo7iZzrTX2sxV8QWnZ5xsmwIDAQAB",
              "1a": "BO7ZnXZ6VorqlSXhXLfkHtPwctqM53eL3WRqRX/RHGVB2QuTYwLMnw=="
            }
          }};
      }, {}],
      23: [function(require, module, exports) {
        (function(Buffer) {
          exports.install = function(self) {
            self.sock = function(req) {
              if (self.isHashname(req))
                req = {to: req};
              if (typeof req != "object")
                return console.log("invalid args") && false;
              var to = self.whois(req.to);
              if (!to)
                return console.log("invalid to hashname", req.to) && false;
              delete req.to;
              var chan = to.start("sock", {
                bare: true,
                js: req
              });
              return chan.wrap("stream");
            };
            self.onSock = function(cbSock) {
              self.rels["sock"] = function(err, packet, chan, callback) {
                if (err)
                  return;
                callback();
                cbSock(chan.wrap("stream"));
              };
            };
            self.wraps["stream"] = function(chan) {
              var pipe = new require("stream").Duplex();
              pipe.on("finish", function() {
                chan.send({js: {end: true}});
              });
              pipe.on("error", function(err) {
                chan.fail({js: {err: err}});
              });
              pipe._write = function(data, enc, cbWrite) {
                if (chan.ended)
                  return cbWrite("closed");
                while (data.length) {
                  var chunk = data.slice(0, 1000);
                  data = data.slice(1000);
                  var packet = {
                    js: {},
                    body: chunk
                  };
                  if (!data.length) {
                    packet.callback = cbWrite;
                    if (pipe.ended)
                      packet.js.end = true;
                  }
                  chan.send(packet);
                }
              };
              pipe.end = function(data) {
                pipe.ended = true;
                if (!data)
                  data = new Buffer(0);
                pipe.write(data);
              };
              var more = false;
              pipe._read = function(size) {
                if (more)
                  more();
                more = false;
              };
              chan.callback = function(err, packet, chan, cbMore) {
                if (packet.body)
                  if (!pipe.push(packet.body))
                    more = cbMore;
                if (err)
                  pipe.push(null);
                if (!more)
                  cbMore();
              };
              return pipe;
            };
          };
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      24: [function(require, module, exports) {
        exports.install = function(self) {
          self.TSockets = {};
          self.socket = function(uri, callback) {
            if (typeof uri != "string")
              return warn("invalid TS uri") && false;
            if (uri.indexOf("ts://") == 0) {
              var parts = uri.substr(5).split("/");
              var to = self.whois(parts.shift());
              if (!to)
                return warn("invalid TS hashname") && false;
              var pathname = parts.join("/");
              if (!pathname)
                pathname = "/";
              var chan = to.start("ts", {
                bare: true,
                js: {path: pathname}
              });
              chan.wrap("TS");
              return chan.socket;
            }
            if (uri.indexOf("/") != 0)
              return warn("invalid TS listening uri") && false;
            self.TSockets[uri] = callback;
          };
          self.rels["ts"] = function(err, packet, chan, callback) {
            if (err)
              return;
            var self = packet.from.self;
            callback();
            if (typeof packet.js.path != "string" || !self.TSockets[packet.js.path])
              return chan.err("unknown path");
            chan.wrap("TS");
            self.TSockets[packet.js.path](chan.socket);
            chan.send({js: {open: true}});
          };
          self.wraps["TS"] = function(chan) {
            chan.socket = {
              data: "",
              hashname: chan.hashname,
              id: chan.id
            };
            chan.callback = function(err, packet, chan, callback) {
              chan.socket.readyState = 1;
              if (chan.socket.onopen) {
                chan.socket.onopen();
                delete chan.socket.onopen;
              }
              if (packet.body)
                chan.socket.data += packet.body;
              if (packet.js.done) {
                if (chan.socket.onmessageack)
                  chan.socket.onmessageack(chan.socket, callback);
                else {
                  if (chan.socket.onmessage)
                    chan.socket.onmessage(chan.socket);
                  chan.socket.data = "";
                  callback();
                }
              } else {
                callback();
              }
              if (err) {
                chan.socket.readyState = 2;
                if (err != true && chan.socket.onerror)
                  chan.socket.onerror(err);
                if (chan.socket.onclose)
                  chan.socket.onclose();
              }
            };
            chan.socket.readyState = chan.lastIn ? 1 : 0;
            chan.socket.send = function(data, callback) {
              if (chan.socket.readyState != 1)
                return console.log("sending fail to TS readyState", chan.socket.readyState) && false;
              while (data) {
                var chunk = data.substr(0, 1000);
                data = data.substr(1000);
                var packet = {
                  js: {},
                  body: chunk
                };
                if (!data) {
                  packet.callback = callback;
                  packet.js.done = true;
                }
                chan.send(packet);
              }
            };
            chan.socket.close = function() {
              chan.socket.readyState = 2;
              chan.done();
            };
            return chan.socket;
          };
        };
      }, {}],
      25: [function(require, module, exports) {
        (function(Buffer) {
          var stream = require("stream");
          var urllib = require("url");
          var httplib = require("http");
          exports.install = function(self) {
            self.thtp = {};
            self.thtp.request = function(args, cbRequest) {
              if (!cbRequest)
                cbRequest = function() {};
              if (typeof args == "string")
                args = {uri: args};
              if (typeof args != "object" || !(args.uri || args.url || args.hashname))
                return errored("invalid args", cbRequest);
              if (args.hashname)
                args.uri = "thtp://" + args.hashname + args.path;
              var uri = self.uriparse(args.uri || args.url);
              if (uri.protocol != "thtp:")
                return errored("invalid protocol " + uri.protocol, cbRequest);
              if (uri.hostname == self.hashname)
                return errored("can't request self", cbRequest);
              var to;
              if (!(to = self.whois(uri.hostname)))
                return errored("invalid hashname", cbRequest);
              var js = {};
              if (typeof args.headers == "object")
                Object.keys(args.headers).forEach(function(header) {
                  js[header.toLowerCase()] = args.headers[header].toString();
                });
              if (args.body)
                js["content-length"] = args.body.length.toString();
              js.method = args.method || "get";
              js.path = uri.path;
              var body = self.pencode(js, args.body);
              js = {};
              if (body.length <= 1000)
                js.end = true;
              var pin = new Buffer(0);
              var pipe = streamer(to.start("thtp", {
                bare: true,
                js: js,
                body: body.slice(0, 1000)
              }, function(err, packet, chan, cbChan) {
                cbChan(true);
                if (pipe.headers) {
                  pipe.push(packet.body);
                  if (err)
                    pipe.emit("end");
                  return;
                }
                if (packet.body)
                  pin = Buffer.concat([pin, packet.body]);
                var http;
                if (!(http = self.pdecode(pin))) {
                  if (err)
                    cbRequest(500, pipe);
                  return;
                }
                pipe.status = parseInt(http.js.status) || 500;
                pipe.headers = http.js;
                cbRequest(pipe.status >= 300 ? pipe.status.toString() : false, pipe);
                if (http.body)
                  pipe.push(http.body);
                if (err)
                  pipe.emit("end");
              }));
              if (body.length > 1000)
                pipe.end(body.slice(1000));
              return pipe;
            };
            self.thtp.listen = function(cbListen) {
              self.rels["thtp"] = function(err, packet, chan, cbStart) {
                var pipe;
                var pin = new Buffer(0);
                chan.callback = function(err, packet, chan, cbChan) {
                  cbChan(true);
                  if (pipe) {
                    if (packet.body)
                      pipe.push(packet.body);
                    if (err)
                      pipe.emit("end");
                    return;
                  }
                  pin = Buffer.concat([pin, packet.body]);
                  if (!(http = self.pdecode(pin))) {
                    if (err)
                      chan.end();
                    return;
                  }
                  if (typeof http.js.method != "string" || typeof http.js.path != "string")
                    return chan.err("invalid");
                  pipe = streamer(chan);
                  pipe.method = http.js.method;
                  pipe.path = http.js.path;
                  delete http.js.method;
                  delete http.js.path;
                  pipe.headers = http.js;
                  cbListen(pipe, function(args) {
                    if (!args)
                      args = {};
                    if (args.err)
                      return errored(err, chan.err);
                    var js = {};
                    if (typeof args.headers == "object")
                      Object.keys(args.headers).forEach(function(header) {
                        js[header.toLowerCase()] = args.headers[header].toString();
                      });
                    js.status = args.status || 200;
                    if (args.json)
                      args.body = JSON.stringify(args.json);
                    if (args.body)
                      js["content-length"] = args.body.length.toString();
                    var phttp = self.pencode(js, args.body);
                    var js = {};
                    if (args.body && phttp.length <= 1000)
                      js.end = true;
                    chan.send({
                      js: js,
                      body: phttp.slice(0, 1000)
                    });
                    if (phttp.length > 1000)
                      pipe.write(phttp.slice(1000));
                    return pipe;
                  });
                  if (http.body)
                    pipe.push(http.body);
                  if (err)
                    pipe.emit("end");
                };
                chan.callback(err, packet, chan, cbStart);
              };
            };
            var mPaths = {};
            self.thtp.match = function(uri, cbMatch) {
              var path = self.uriparse(uri).pathname;
              mPaths[path] = cbMatch;
              if (Object.keys(mPaths).length > 1)
                return;
              self.thtp.listen(function(req, cbRes) {
                var match;
                Object.keys(mPaths).forEach(function(path) {
                  if (req.path.indexOf(path) != 0)
                    return;
                  if (match && match.length > path)
                    return;
                  match = path;
                });
                if (match)
                  return mPaths[match](req, cbRes);
                cbRes({
                  status: 404,
                  body: "not found"
                });
              });
            };
            self.thtp.proxy = function(args) {
              if (args.address == "0.0.0.0")
                args.address = "127.0.0.1";
              self.thtp.listen(function(req, cbRes) {
                var opt = {
                  host: args.address,
                  port: args.port,
                  headers: req.headers,
                  method: req.method,
                  path: req.path
                };
                req.pipe(httplib.request(opt, function(res) {
                  res.pipe(cbRes({
                    status: res.statusCode,
                    headers: res.headers
                  }));
                }));
              });
            };
          };
          function errored(err, cb) {
            cb(err);
            var pipe = stream.Readable();
            pipe._read = function() {};
            pipe.emit("end");
            return pipe;
          }
          function streamer(chan) {
            var pipe = stream.Duplex();
            pipe._read = function() {};
            pipe.on("finish", function() {
              chan.send({js: {end: true}});
            });
            pipe._write = function(data, enc, cbWrite) {
              while (data.length) {
                var chunk = data.slice(0, 1000);
                data = data.slice(1000);
                var packet = {
                  js: {},
                  body: chunk
                };
                if (!data.length) {
                  packet.callback = cbWrite;
                  if (pipe.ended)
                    packet.js.end = true;
                }
                chan.send(packet);
              }
            };
            pipe.end = function(data) {
              pipe.ended = true;
              if (!data)
                data = new Buffer(0);
              pipe.write(data);
            };
            return pipe;
          }
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "http": 46,
        "stream": 69,
        "url": 70
      }],
      26: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          exports.install = function(self) {
            var tokens = {};
            self.token = function(token, callback) {
              if (typeof token == "function") {
                callback = token;
                token = false;
              }
              if (!token) {
                var bytes = new Buffer(self.hashname, "hex");
                var rand = new Buffer(self.randomHEX(8), "hex");
                var hash = crypto.createHash("sha256").update(Buffer.concat([bytes, rand])).digest();
                token = Buffer.concat([bytes.slice(0, 16), rand, hash.slice(0, 8)]).toString("hex");
              }
              if (callback)
                tokens[token] = callback;
              return token;
            };
            self.raws["token"] = function(err, packet, chan) {
              if (err)
                return;
              var self = packet.from.self;
              if (!self.isHashname(packet.js.token))
                return chan.err("invalid");
              if (tokens[packet.js.token]) {
                tokens[packet.js.token](packet.from);
                return chan.send({js: {end: true}});
              }
              if (!self.tokens)
                return chan.err("unknown");
              self.tokens(packet.js.token, packet.from, function(err) {
                if (err)
                  chan.err(err);
                can.send({js: {end: true}});
              });
            };
            self.dispense = function(token, callback) {
              self.seek(token, function(err, see) {
                if (!Array.isArray(see))
                  return callback(err || "not found");
                var match;
                see.forEach(function(hn) {
                  if (hn.substr(0, 32) != token.substr(0, 32))
                    return;
                  var bytes = new Buffer(hn, "hex");
                  var rand = new Buffer(token.substr(32, 16), "hex");
                  var hash = crypto.createHash("sha256").update(Buffer.concat([bytes, rand])).digest();
                  token2 = Buffer.concat([bytes.slice(0, 16), rand, hash.slice(0, 8)]).toString("hex");
                  if (token == token2)
                    match = hn;
                });
                if (!match || !(match = self.whois(match)))
                  return callback("not found");
                match.raw("token", {
                  js: {token: token},
                  retries: 3
                }, function(err) {
                  callback((err !== true) ? err : false, match);
                });
              });
            };
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "crypto": 35
      }],
      27: [function(require, module, exports) {
        (function(Buffer) {
          var rtc = require("webrtc-peer");
          exports.install = function(self) {
            if (!rtc.hasWebRTC)
              return false;
            self.pathSet({type: "webrtc"});
            var conns = {};
            var peers = {};
            function init(initiate, chan, to) {
              chan.wrap("TS");
              peers[to] = chan;
              var pch;
              chan.socket.onopen = function() {
                pch = new rtc.peer({
                  initiate: initiate,
                  _self: "self",
                  _peer: to
                });
                pch.DEBUG = true;
                pch.onsignal = function(signal) {
                  console.log("RTC OUT", signal);
                  chan.socket.send(JSON.stringify(signal));
                };
                pch.onconnection = function() {
                  console.log("RTC CONNECTED");
                  conns[to] = pch;
                  if (chan.cached)
                    pch.send(chan.cached);
                };
                pch.onmessage = function(safe) {
                  self.receive(new Buffer(safe, "base64"), {type: "webrtc"});
                };
              };
              chan.socket.onmessage = function(data) {
                console.log("RTC IN", data);
                try {
                  data = JSON.parse(data.data);
                } catch (E) {
                  return console.log("rtc parse error", E, data.data);
                }
                pch.signal(data);
              };
            }
            self.deliver("webrtc", function(path, msg, to) {
              var safe = msg.toString("base64");
              if (conns[to.hashname])
                return conns[to.hashname].send(safe);
              if (peers[to.hashname])
                return peers[to.hashname].cached = safe;
              var chan = to.start("webrtc", {bare: true});
              setTimeout(function() {
                chan.send({
                  type: "webrtc",
                  js: {open: true}
                });
              }, 10);
              init(true, chan, to.hashname);
            });
            self.rels["webrtc"] = function(err, packet, chan, cb) {
              cb();
              if (err)
                return;
              var from = packet.from.hashname;
              if (peers[from] && chan.id < peers[from].id)
                return chan.fail("duplicate");
              chan.send({js: {open: true}});
              init(false, chan, from);
            };
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "webrtc-peer": 28
      }],
      28: [function(require, module, exports) {
        exports.peer = PeerConnectionHandler;
        exports.iceServers = [{"url": "stun:23.21.150.121"}];
        var RTCPeerConnection = window.mozRTCPeerConnection || window.RTCPeerConnection || window.webkitRTCPeerConnection,
            RTCSessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription || window.webkitRTCSessionDescription,
            RTCIceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate || window.webkitRTCIceCandidate;
        exports.hasWebRTC = RTCPeerConnection ? true : false;
        function PeerConnectionHandler(opts) {
          if (!opts)
            opts = {};
          opts.reliable = true;
          var cfg = {"iceServers": exports.iceServers},
              con = (opts.reliable) ? {} : {'optional': [{'RtpDataChannels': true}]};
          this._rtc = new RTCPeerConnection(cfg, con);
          this.LOG_SELF = opts._self;
          this.LOG_PEER = opts._peer;
          this._channel = null;
          this.onsignal = null;
          this.onmessage = null;
          this.onconnection = null;
          var handler = this,
              rtc = this._rtc;
          if (opts.initiate)
            this._setupChannel();
          else
            rtc.ondatachannel = this._setupChannel.bind(this);
          rtc.onnegotiationneeded = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "saw negotiation trigger and will create an offer");
            rtc.createOffer(function(offerDesc) {
              if (handler.DEBUG)
                console.log(handler.LOG_SELF, "created offer, sending to", handler.LOG_PEER);
              rtc.setLocalDescription(offerDesc, function() {
                console.log("DONE");
              });
              handler._sendSignal(offerDesc);
            }, function(e) {
              console.warn(handler.LOG_SELF, "failed to create offer", e);
            });
          };
          rtc.onicecandidate = function(evt) {
            if (evt.candidate)
              handler._sendSignal({candidate: evt.candidate});
          };
          rtc.onicechange = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "ICE change", rtc.iceGatheringState, rtc.iceConnectionState);
          };
          rtc.onstatechange = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "State change", rtc.signalingState, rtc.readyState);
          };
        }
        PeerConnectionHandler.prototype._sendSignal = function(data) {
          if (!this.onsignal)
            throw Error("Need to send message but `onsignal` handler is not set.");
          this.onsignal(data);
        };
        PeerConnectionHandler.prototype.signal = function(data) {
          var handler = this,
              rtc = this._rtc;
          if (handler.DEBUG)
            console.log(this.LOG_SELF, "got data", data, "from", this.LOG_PEER);
          if (data.sdp)
            rtc.setRemoteDescription(new RTCSessionDescription(data), function() {
              var needsAnswer = (rtc.remoteDescription.type == 'offer');
              if (handler.DEBUG)
                console.log(handler.LOG_SELF, "set offer, now creating answer:", needsAnswer);
              if (needsAnswer)
                rtc.createAnswer(function(answerDesc) {
                  if (handler.DEBUG)
                    console.log(handler.LOG_SELF, "got anwer, sending back to", handler.LOG_PEER);
                  rtc.setLocalDescription(answerDesc);
                  handler._sendSignal(answerDesc);
                }, function(e) {
                  console.warn(handler.LOG_SELF, "couldn't create answer", e);
                });
            }, function(e) {
              console.warn(handler.LOG_SELF, "couldn't set remote description", e);
            });
          else if (data.candidate)
            try {
              rtc.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (e) {
              console.error("Couldn't add candidate", e);
            }
        };
        PeerConnectionHandler.prototype.send = function(data) {
          if (!this._channel || this._channel.readyState !== 'open')
            return this.DEBUG && console.log("dropping data, no open channel");
          this._channel.send(data);
        };
        PeerConnectionHandler.prototype._setupChannel = function(evt) {
          var handler = this,
              rtc = this._rtc;
          if (evt)
            if (handler.DEBUG)
              console.log(this.LOG_SELF, "received data channel", evt.channel.readyState);
          this._channel = (evt) ? evt.channel : rtc.createDataChannel('telehash');
          this._channel.onopen = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "DATA CHANNEL IS OPEN", handler._channel);
            if (handler.onconnection)
              handler.onconnection(handler._channel);
          };
          this._channel.onmessage = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "received message!", evt);
            if (handler.onmessage)
              handler.onmessage(evt.data);
          };
          if (window.mozRTCPeerConnection)
            setTimeout(function() {
              rtc.onnegotiationneeded();
            }, 0);
          window.dbgChannel = this._channel;
        };
      }, {}],
      29: [function(require, module, exports) {
        var base64 = require('base64-js');
        var ieee754 = require('ieee754');
        exports.Buffer = Buffer;
        exports.SlowBuffer = Buffer;
        exports.INSPECT_MAX_BYTES = 50;
        Buffer.poolSize = 8192;
        Buffer._useTypedArrays = (function() {
          try {
            var buf = new ArrayBuffer(0);
            var arr = new Uint8Array(buf);
            arr.foo = function() {
              return 42;
            };
            return 42 === arr.foo() && typeof arr.subarray === 'function';
          } catch (e) {
            return false;
          }
        })();
        function Buffer(subject, encoding, noZero) {
          if (!(this instanceof Buffer))
            return new Buffer(subject, encoding, noZero);
          var type = typeof subject;
          if (encoding === 'base64' && type === 'string') {
            subject = base64clean(subject);
          }
          var length;
          if (type === 'number')
            length = coerce(subject);
          else if (type === 'string')
            length = Buffer.byteLength(subject, encoding);
          else if (type === 'object')
            length = coerce(subject.length);
          else
            throw new Error('First argument needs to be a number, array or string.');
          var buf;
          if (Buffer._useTypedArrays) {
            buf = Buffer._augment(new Uint8Array(length));
          } else {
            buf = this;
            buf.length = length;
            buf._isBuffer = true;
          }
          var i;
          if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
            buf._set(subject);
          } else if (isArrayish(subject)) {
            if (Buffer.isBuffer(subject)) {
              for (i = 0; i < length; i++)
                buf[i] = subject.readUInt8(i);
            } else {
              for (i = 0; i < length; i++)
                buf[i] = ((subject[i] % 256) + 256) % 256;
            }
          } else if (type === 'string') {
            buf.write(subject, 0, encoding);
          } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
            for (i = 0; i < length; i++) {
              buf[i] = 0;
            }
          }
          return buf;
        }
        Buffer.isEncoding = function(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'raw':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true;
            default:
              return false;
          }
        };
        Buffer.isBuffer = function(b) {
          return !!(b !== null && b !== undefined && b._isBuffer);
        };
        Buffer.byteLength = function(str, encoding) {
          var ret;
          str = str.toString();
          switch (encoding || 'utf8') {
            case 'hex':
              ret = str.length / 2;
              break;
            case 'utf8':
            case 'utf-8':
              ret = utf8ToBytes(str).length;
              break;
            case 'ascii':
            case 'binary':
            case 'raw':
              ret = str.length;
              break;
            case 'base64':
              ret = base64ToBytes(str).length;
              break;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              ret = str.length * 2;
              break;
            default:
              throw new Error('Unknown encoding');
          }
          return ret;
        };
        Buffer.concat = function(list, totalLength) {
          assert(isArray(list), 'Usage: Buffer.concat(list[, length])');
          if (list.length === 0) {
            return new Buffer(0);
          } else if (list.length === 1) {
            return list[0];
          }
          var i;
          if (totalLength === undefined) {
            totalLength = 0;
            for (i = 0; i < list.length; i++) {
              totalLength += list[i].length;
            }
          }
          var buf = new Buffer(totalLength);
          var pos = 0;
          for (i = 0; i < list.length; i++) {
            var item = list[i];
            item.copy(buf, pos);
            pos += item.length;
          }
          return buf;
        };
        Buffer.compare = function(a, b) {
          assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers');
          var x = a.length;
          var y = b.length;
          for (var i = 0,
              len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
          if (i !== len) {
            x = a[i];
            y = b[i];
          }
          if (x < y) {
            return -1;
          }
          if (y < x) {
            return 1;
          }
          return 0;
        };
        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          var strLen = string.length;
          assert(strLen % 2 === 0, 'Invalid hex string');
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; i++) {
            var byte = parseInt(string.substr(i * 2, 2), 16);
            assert(!isNaN(byte), 'Invalid hex string');
            buf[offset + i] = byte;
          }
          return i;
        }
        function utf8Write(buf, string, offset, length) {
          var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length);
          return charsWritten;
        }
        function asciiWrite(buf, string, offset, length) {
          var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
          return charsWritten;
        }
        function binaryWrite(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
          var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
          return charsWritten;
        }
        function utf16leWrite(buf, string, offset, length) {
          var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length);
          return charsWritten;
        }
        Buffer.prototype.write = function(string, offset, length, encoding) {
          if (isFinite(offset)) {
            if (!isFinite(length)) {
              encoding = length;
              length = undefined;
            }
          } else {
            var swap = encoding;
            encoding = offset;
            offset = length;
            length = swap;
          }
          offset = Number(offset) || 0;
          var remaining = this.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          encoding = String(encoding || 'utf8').toLowerCase();
          var ret;
          switch (encoding) {
            case 'hex':
              ret = hexWrite(this, string, offset, length);
              break;
            case 'utf8':
            case 'utf-8':
              ret = utf8Write(this, string, offset, length);
              break;
            case 'ascii':
              ret = asciiWrite(this, string, offset, length);
              break;
            case 'binary':
              ret = binaryWrite(this, string, offset, length);
              break;
            case 'base64':
              ret = base64Write(this, string, offset, length);
              break;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              ret = utf16leWrite(this, string, offset, length);
              break;
            default:
              throw new Error('Unknown encoding');
          }
          return ret;
        };
        Buffer.prototype.toString = function(encoding, start, end) {
          var self = this;
          encoding = String(encoding || 'utf8').toLowerCase();
          start = Number(start) || 0;
          end = (end === undefined) ? self.length : Number(end);
          if (end === start)
            return '';
          var ret;
          switch (encoding) {
            case 'hex':
              ret = hexSlice(self, start, end);
              break;
            case 'utf8':
            case 'utf-8':
              ret = utf8Slice(self, start, end);
              break;
            case 'ascii':
              ret = asciiSlice(self, start, end);
              break;
            case 'binary':
              ret = binarySlice(self, start, end);
              break;
            case 'base64':
              ret = base64Slice(self, start, end);
              break;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              ret = utf16leSlice(self, start, end);
              break;
            default:
              throw new Error('Unknown encoding');
          }
          return ret;
        };
        Buffer.prototype.toJSON = function() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        Buffer.prototype.equals = function(b) {
          assert(Buffer.isBuffer(b), 'Argument must be a Buffer');
          return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.compare = function(b) {
          assert(Buffer.isBuffer(b), 'Argument must be a Buffer');
          return Buffer.compare(this, b);
        };
        Buffer.prototype.copy = function(target, target_start, start, end) {
          var source = this;
          if (!start)
            start = 0;
          if (!end && end !== 0)
            end = this.length;
          if (!target_start)
            target_start = 0;
          if (end === start)
            return;
          if (target.length === 0 || source.length === 0)
            return;
          assert(end >= start, 'sourceEnd < sourceStart');
          assert(target_start >= 0 && target_start < target.length, 'targetStart out of bounds');
          assert(start >= 0 && start < source.length, 'sourceStart out of bounds');
          assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds');
          if (end > this.length)
            end = this.length;
          if (target.length - target_start < end - start)
            end = target.length - target_start + start;
          var len = end - start;
          if (len < 100 || !Buffer._useTypedArrays) {
            for (var i = 0; i < len; i++) {
              target[i + target_start] = this[i + start];
            }
          } else {
            target._set(this.subarray(start, start + len), target_start);
          }
        };
        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }
        function utf8Slice(buf, start, end) {
          var res = '';
          var tmp = '';
          end = Math.min(buf.length, end);
          for (var i = start; i < end; i++) {
            if (buf[i] <= 0x7F) {
              res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
              tmp = '';
            } else {
              tmp += '%' + buf[i].toString(16);
            }
          }
          return res + decodeUtf8Char(tmp);
        }
        function asciiSlice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);
          for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function binarySlice(buf, start, end) {
          return asciiSlice(buf, start, end);
        }
        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0)
            start = 0;
          if (!end || end < 0 || end > len)
            end = len;
          var out = '';
          for (var i = start; i < end; i++) {
            out += toHex(buf[i]);
          }
          return out;
        }
        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = '';
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }
        Buffer.prototype.slice = function(start, end) {
          var len = this.length;
          start = clamp(start, len, 0);
          end = clamp(end, len, len);
          if (Buffer._useTypedArrays) {
            return Buffer._augment(this.subarray(start, end));
          } else {
            var sliceLen = end - start;
            var newBuf = new Buffer(sliceLen, undefined, true);
            for (var i = 0; i < sliceLen; i++) {
              newBuf[i] = this[i + start];
            }
            return newBuf;
          }
        };
        Buffer.prototype.get = function(offset) {
          console.log('.get() is deprecated. Access using array indexes instead.');
          return this.readUInt8(offset);
        };
        Buffer.prototype.set = function(v, offset) {
          console.log('.set() is deprecated. Access using array indexes instead.');
          return this.writeUInt8(v, offset);
        };
        Buffer.prototype.readUInt8 = function(offset, noAssert) {
          if (!noAssert) {
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset < this.length, 'Trying to read beyond buffer length');
          }
          if (offset >= this.length)
            return;
          return this[offset];
        };
        function readUInt16(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');
          }
          var len = buf.length;
          if (offset >= len)
            return;
          var val;
          if (littleEndian) {
            val = buf[offset];
            if (offset + 1 < len)
              val |= buf[offset + 1] << 8;
          } else {
            val = buf[offset] << 8;
            if (offset + 1 < len)
              val |= buf[offset + 1];
          }
          return val;
        }
        Buffer.prototype.readUInt16LE = function(offset, noAssert) {
          return readUInt16(this, offset, true, noAssert);
        };
        Buffer.prototype.readUInt16BE = function(offset, noAssert) {
          return readUInt16(this, offset, false, noAssert);
        };
        function readUInt32(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
          }
          var len = buf.length;
          if (offset >= len)
            return;
          var val;
          if (littleEndian) {
            if (offset + 2 < len)
              val = buf[offset + 2] << 16;
            if (offset + 1 < len)
              val |= buf[offset + 1] << 8;
            val |= buf[offset];
            if (offset + 3 < len)
              val = val + (buf[offset + 3] << 24 >>> 0);
          } else {
            if (offset + 1 < len)
              val = buf[offset + 1] << 16;
            if (offset + 2 < len)
              val |= buf[offset + 2] << 8;
            if (offset + 3 < len)
              val |= buf[offset + 3];
            val = val + (buf[offset] << 24 >>> 0);
          }
          return val;
        }
        Buffer.prototype.readUInt32LE = function(offset, noAssert) {
          return readUInt32(this, offset, true, noAssert);
        };
        Buffer.prototype.readUInt32BE = function(offset, noAssert) {
          return readUInt32(this, offset, false, noAssert);
        };
        Buffer.prototype.readInt8 = function(offset, noAssert) {
          if (!noAssert) {
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset < this.length, 'Trying to read beyond buffer length');
          }
          if (offset >= this.length)
            return;
          var neg = this[offset] & 0x80;
          if (neg)
            return (0xff - this[offset] + 1) * -1;
          else
            return this[offset];
        };
        function readInt16(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');
          }
          var len = buf.length;
          if (offset >= len)
            return;
          var val = readUInt16(buf, offset, littleEndian, true);
          var neg = val & 0x8000;
          if (neg)
            return (0xffff - val + 1) * -1;
          else
            return val;
        }
        Buffer.prototype.readInt16LE = function(offset, noAssert) {
          return readInt16(this, offset, true, noAssert);
        };
        Buffer.prototype.readInt16BE = function(offset, noAssert) {
          return readInt16(this, offset, false, noAssert);
        };
        function readInt32(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
          }
          var len = buf.length;
          if (offset >= len)
            return;
          var val = readUInt32(buf, offset, littleEndian, true);
          var neg = val & 0x80000000;
          if (neg)
            return (0xffffffff - val + 1) * -1;
          else
            return val;
        }
        Buffer.prototype.readInt32LE = function(offset, noAssert) {
          return readInt32(this, offset, true, noAssert);
        };
        Buffer.prototype.readInt32BE = function(offset, noAssert) {
          return readInt32(this, offset, false, noAssert);
        };
        function readFloat(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
          }
          return ieee754.read(buf, offset, littleEndian, 23, 4);
        }
        Buffer.prototype.readFloatLE = function(offset, noAssert) {
          return readFloat(this, offset, true, noAssert);
        };
        Buffer.prototype.readFloatBE = function(offset, noAssert) {
          return readFloat(this, offset, false, noAssert);
        };
        function readDouble(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset + 7 < buf.length, 'Trying to read beyond buffer length');
          }
          return ieee754.read(buf, offset, littleEndian, 52, 8);
        }
        Buffer.prototype.readDoubleLE = function(offset, noAssert) {
          return readDouble(this, offset, true, noAssert);
        };
        Buffer.prototype.readDoubleBE = function(offset, noAssert) {
          return readDouble(this, offset, false, noAssert);
        };
        Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset < this.length, 'trying to write beyond buffer length');
            verifuint(value, 0xff);
          }
          if (offset >= this.length)
            return;
          this[offset] = value;
          return offset + 1;
        };
        function writeUInt16(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 1 < buf.length, 'trying to write beyond buffer length');
            verifuint(value, 0xffff);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          for (var i = 0,
              j = Math.min(len - offset, 2); i < j; i++) {
            buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
          }
          return offset + 2;
        }
        Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
          return writeUInt16(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
          return writeUInt16(this, value, offset, false, noAssert);
        };
        function writeUInt32(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'trying to write beyond buffer length');
            verifuint(value, 0xffffffff);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          for (var i = 0,
              j = Math.min(len - offset, 4); i < j; i++) {
            buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
          }
          return offset + 4;
        }
        Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
          return writeUInt32(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
          return writeUInt32(this, value, offset, false, noAssert);
        };
        Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset < this.length, 'Trying to write beyond buffer length');
            verifsint(value, 0x7f, -0x80);
          }
          if (offset >= this.length)
            return;
          if (value >= 0)
            this.writeUInt8(value, offset, noAssert);
          else
            this.writeUInt8(0xff + value + 1, offset, noAssert);
          return offset + 1;
        };
        function writeInt16(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 1 < buf.length, 'Trying to write beyond buffer length');
            verifsint(value, 0x7fff, -0x8000);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          if (value >= 0)
            writeUInt16(buf, value, offset, littleEndian, noAssert);
          else
            writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert);
          return offset + 2;
        }
        Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
          return writeInt16(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
          return writeInt16(this, value, offset, false, noAssert);
        };
        function writeInt32(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');
            verifsint(value, 0x7fffffff, -0x80000000);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          if (value >= 0)
            writeUInt32(buf, value, offset, littleEndian, noAssert);
          else
            writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert);
          return offset + 4;
        }
        Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
          return writeInt32(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
          return writeInt32(this, value, offset, false, noAssert);
        };
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');
            verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 7 < buf.length, 'Trying to write beyond buffer length');
            verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.fill = function(value, start, end) {
          if (!value)
            value = 0;
          if (!start)
            start = 0;
          if (!end)
            end = this.length;
          assert(end >= start, 'end < start');
          if (end === start)
            return;
          if (this.length === 0)
            return;
          assert(start >= 0 && start < this.length, 'start out of bounds');
          assert(end >= 0 && end <= this.length, 'end out of bounds');
          var i;
          if (typeof value === 'number') {
            for (i = start; i < end; i++) {
              this[i] = value;
            }
          } else {
            var bytes = utf8ToBytes(value.toString());
            var len = bytes.length;
            for (i = start; i < end; i++) {
              this[i] = bytes[i % len];
            }
          }
          return this;
        };
        Buffer.prototype.inspect = function() {
          var out = [];
          var len = this.length;
          for (var i = 0; i < len; i++) {
            out[i] = toHex(this[i]);
            if (i === exports.INSPECT_MAX_BYTES) {
              out[i + 1] = '...';
              break;
            }
          }
          return '<Buffer ' + out.join(' ') + '>';
        };
        Buffer.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array !== 'undefined') {
            if (Buffer._useTypedArrays) {
              return (new Buffer(this)).buffer;
            } else {
              var buf = new Uint8Array(this.length);
              for (var i = 0,
                  len = buf.length; i < len; i += 1) {
                buf[i] = this[i];
              }
              return buf.buffer;
            }
          } else {
            throw new Error('Buffer.toArrayBuffer not supported in this browser');
          }
        };
        var BP = Buffer.prototype;
        Buffer._augment = function(arr) {
          arr._isBuffer = true;
          arr._get = arr.get;
          arr._set = arr.set;
          arr.get = BP.get;
          arr.set = BP.set;
          arr.write = BP.write;
          arr.toString = BP.toString;
          arr.toLocaleString = BP.toString;
          arr.toJSON = BP.toJSON;
          arr.equals = BP.equals;
          arr.compare = BP.compare;
          arr.copy = BP.copy;
          arr.slice = BP.slice;
          arr.readUInt8 = BP.readUInt8;
          arr.readUInt16LE = BP.readUInt16LE;
          arr.readUInt16BE = BP.readUInt16BE;
          arr.readUInt32LE = BP.readUInt32LE;
          arr.readUInt32BE = BP.readUInt32BE;
          arr.readInt8 = BP.readInt8;
          arr.readInt16LE = BP.readInt16LE;
          arr.readInt16BE = BP.readInt16BE;
          arr.readInt32LE = BP.readInt32LE;
          arr.readInt32BE = BP.readInt32BE;
          arr.readFloatLE = BP.readFloatLE;
          arr.readFloatBE = BP.readFloatBE;
          arr.readDoubleLE = BP.readDoubleLE;
          arr.readDoubleBE = BP.readDoubleBE;
          arr.writeUInt8 = BP.writeUInt8;
          arr.writeUInt16LE = BP.writeUInt16LE;
          arr.writeUInt16BE = BP.writeUInt16BE;
          arr.writeUInt32LE = BP.writeUInt32LE;
          arr.writeUInt32BE = BP.writeUInt32BE;
          arr.writeInt8 = BP.writeInt8;
          arr.writeInt16LE = BP.writeInt16LE;
          arr.writeInt16BE = BP.writeInt16BE;
          arr.writeInt32LE = BP.writeInt32LE;
          arr.writeInt32BE = BP.writeInt32BE;
          arr.writeFloatLE = BP.writeFloatLE;
          arr.writeFloatBE = BP.writeFloatBE;
          arr.writeDoubleLE = BP.writeDoubleLE;
          arr.writeDoubleBE = BP.writeDoubleBE;
          arr.fill = BP.fill;
          arr.inspect = BP.inspect;
          arr.toArrayBuffer = BP.toArrayBuffer;
          return arr;
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-z]/g;
        function base64clean(str) {
          str = stringtrim(str).replace(INVALID_BASE64_RE, '');
          while (str.length % 4 !== 0) {
            str = str + '=';
          }
          return str;
        }
        function stringtrim(str) {
          if (str.trim)
            return str.trim();
          return str.replace(/^\s+|\s+$/g, '');
        }
        function clamp(index, len, defaultValue) {
          if (typeof index !== 'number')
            return defaultValue;
          index = ~~index;
          if (index >= len)
            return len;
          if (index >= 0)
            return index;
          index += len;
          if (index >= 0)
            return index;
          return 0;
        }
        function coerce(length) {
          length = ~~Math.ceil(+length);
          return length < 0 ? 0 : length;
        }
        function isArray(subject) {
          return (Array.isArray || function(subject) {
            return Object.prototype.toString.call(subject) === '[object Array]';
          })(subject);
        }
        function isArrayish(subject) {
          return isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === 'object' && typeof subject.length === 'number';
        }
        function toHex(n) {
          if (n < 16)
            return '0' + n.toString(16);
          return n.toString(16);
        }
        function utf8ToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            var b = str.charCodeAt(i);
            if (b <= 0x7F) {
              byteArray.push(b);
            } else {
              var start = i;
              if (b >= 0xD800 && b <= 0xDFFF)
                i++;
              var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%');
              for (var j = 0; j < h.length; j++) {
                byteArray.push(parseInt(h[j], 16));
              }
            }
          }
          return byteArray;
        }
        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            byteArray.push(str.charCodeAt(i) & 0xFF);
          }
          return byteArray;
        }
        function utf16leToBytes(str) {
          var c,
              hi,
              lo;
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes(str) {
          return base64.toByteArray(str);
        }
        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; i++) {
            if ((i + offset >= dst.length) || (i >= src.length))
              break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        function decodeUtf8Char(str) {
          try {
            return decodeURIComponent(str);
          } catch (err) {
            return String.fromCharCode(0xFFFD);
          }
        }
        function verifuint(value, max) {
          assert(typeof value === 'number', 'cannot write a non-number as a number');
          assert(value >= 0, 'specified a negative value for writing an unsigned value');
          assert(value <= max, 'value is larger than maximum value for type');
          assert(Math.floor(value) === value, 'value has a fractional component');
        }
        function verifsint(value, max, min) {
          assert(typeof value === 'number', 'cannot write a non-number as a number');
          assert(value <= max, 'value larger than maximum allowed value');
          assert(value >= min, 'value smaller than minimum allowed value');
          assert(Math.floor(value) === value, 'value has a fractional component');
        }
        function verifIEEE754(value, max, min) {
          assert(typeof value === 'number', 'cannot write a non-number as a number');
          assert(value <= max, 'value larger than maximum allowed value');
          assert(value >= min, 'value smaller than minimum allowed value');
        }
        function assert(test, message) {
          if (!test)
            throw new Error(message || 'Failed assertion');
        }
      }, {
        "base64-js": 30,
        "ieee754": 31
      }],
      30: [function(require, module, exports) {
        var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        ;
        (function(exports) {
          'use strict';
          var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
          var PLUS = '+'.charCodeAt(0);
          var SLASH = '/'.charCodeAt(0);
          var NUMBER = '0'.charCodeAt(0);
          var LOWER = 'a'.charCodeAt(0);
          var UPPER = 'A'.charCodeAt(0);
          function decode(elt) {
            var code = elt.charCodeAt(0);
            if (code === PLUS)
              return 62;
            if (code === SLASH)
              return 63;
            if (code < NUMBER)
              return -1;
            if (code < NUMBER + 10)
              return code - NUMBER + 26 + 26;
            if (code < UPPER + 26)
              return code - UPPER;
            if (code < LOWER + 26)
              return code - LOWER + 26;
          }
          function b64ToByteArray(b64) {
            var i,
                j,
                l,
                tmp,
                placeHolders,
                arr;
            if (b64.length % 4 > 0) {
              throw new Error('Invalid string. Length must be a multiple of 4');
            }
            var len = b64.length;
            placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
            arr = new Arr(b64.length * 3 / 4 - placeHolders);
            l = placeHolders > 0 ? b64.length - 4 : b64.length;
            var L = 0;
            function push(v) {
              arr[L++] = v;
            }
            for (i = 0, j = 0; i < l; i += 4, j += 3) {
              tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
              push((tmp & 0xFF0000) >> 16);
              push((tmp & 0xFF00) >> 8);
              push(tmp & 0xFF);
            }
            if (placeHolders === 2) {
              tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
              push(tmp & 0xFF);
            } else if (placeHolders === 1) {
              tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
              push((tmp >> 8) & 0xFF);
              push(tmp & 0xFF);
            }
            return arr;
          }
          function uint8ToBase64(uint8) {
            var i,
                extraBytes = uint8.length % 3,
                output = "",
                temp,
                length;
            function encode(num) {
              return lookup.charAt(num);
            }
            function tripletToBase64(num) {
              return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
            }
            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
              temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
              output += tripletToBase64(temp);
            }
            switch (extraBytes) {
              case 1:
                temp = uint8[uint8.length - 1];
                output += encode(temp >> 2);
                output += encode((temp << 4) & 0x3F);
                output += '==';
                break;
              case 2:
                temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
                output += encode(temp >> 10);
                output += encode((temp >> 4) & 0x3F);
                output += encode((temp << 2) & 0x3F);
                output += '=';
                break;
            }
            return output;
          }
          exports.toByteArray = b64ToByteArray;
          exports.fromByteArray = uint8ToBase64;
        }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
      }, {}],
      31: [function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e,
              m,
              eLen = nBytes * 8 - mLen - 1,
              eMax = (1 << eLen) - 1,
              eBias = eMax >> 1,
              nBits = -7,
              i = isLE ? (nBytes - 1) : 0,
              d = isLE ? -1 : 1,
              s = buffer[offset + i];
          i += d;
          e = s & ((1 << (-nBits)) - 1);
          s >>= (-nBits);
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
            ;
          m = e & ((1 << (-nBits)) - 1);
          e >>= (-nBits);
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
            ;
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e,
              m,
              c,
              eLen = nBytes * 8 - mLen - 1,
              eMax = (1 << eLen) - 1,
              eBias = eMax >> 1,
              rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
              i = isLE ? 0 : (nBytes - 1),
              d = isLE ? 1 : -1,
              s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8)
            ;
          e = (e << mLen) | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8)
            ;
          buffer[offset + i - d] |= s * 128;
        };
      }, {}],
      32: [function(require, module, exports) {
        (function(Buffer) {
          var createHash = require('sha.js');
          var md5 = toConstructor(require('./md5'));
          var rmd160 = toConstructor(require('ripemd160'));
          function toConstructor(fn) {
            return function() {
              var buffers = [];
              var m = {
                update: function(data, enc) {
                  if (!Buffer.isBuffer(data))
                    data = new Buffer(data, enc);
                  buffers.push(data);
                  return this;
                },
                digest: function(enc) {
                  var buf = Buffer.concat(buffers);
                  var r = fn(buf);
                  buffers = null;
                  return enc ? r.toString(enc) : r;
                }
              };
              return m;
            };
          }
          module.exports = function(alg) {
            if ('md5' === alg)
              return new md5();
            if ('rmd160' === alg)
              return new rmd160();
            return createHash(alg);
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "./md5": 36,
        "buffer": 29,
        "ripemd160": 37,
        "sha.js": 39
      }],
      33: [function(require, module, exports) {
        (function(Buffer) {
          var createHash = require('./create-hash');
          var blocksize = 64;
          var zeroBuffer = new Buffer(blocksize);
          zeroBuffer.fill(0);
          module.exports = Hmac;
          function Hmac(alg, key) {
            if (!(this instanceof Hmac))
              return new Hmac(alg, key);
            this._opad = opad;
            this._alg = alg;
            key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key;
            if (key.length > blocksize) {
              key = createHash(alg).update(key).digest();
            } else if (key.length < blocksize) {
              key = Buffer.concat([key, zeroBuffer], blocksize);
            }
            var ipad = this._ipad = new Buffer(blocksize);
            var opad = this._opad = new Buffer(blocksize);
            for (var i = 0; i < blocksize; i++) {
              ipad[i] = key[i] ^ 0x36;
              opad[i] = key[i] ^ 0x5C;
            }
            this._hash = createHash(alg).update(ipad);
          }
          Hmac.prototype.update = function(data, enc) {
            this._hash.update(data, enc);
            return this;
          };
          Hmac.prototype.digest = function(enc) {
            var h = this._hash.digest();
            return createHash(this._alg).update(this._opad).update(h).digest(enc);
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "./create-hash": 32,
        "buffer": 29
      }],
      34: [function(require, module, exports) {
        (function(Buffer) {
          var intSize = 4;
          var zeroBuffer = new Buffer(intSize);
          zeroBuffer.fill(0);
          var chrsz = 8;
          function toArray(buf, bigEndian) {
            if ((buf.length % intSize) !== 0) {
              var len = buf.length + (intSize - (buf.length % intSize));
              buf = Buffer.concat([buf, zeroBuffer], len);
            }
            var arr = [];
            var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
            for (var i = 0; i < buf.length; i += intSize) {
              arr.push(fn.call(buf, i));
            }
            return arr;
          }
          function toBuffer(arr, size, bigEndian) {
            var buf = new Buffer(size);
            var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
            for (var i = 0; i < arr.length; i++) {
              fn.call(buf, arr[i], i * 4, true);
            }
            return buf;
          }
          function hash(buf, fn, hashSize, bigEndian) {
            if (!Buffer.isBuffer(buf))
              buf = new Buffer(buf);
            var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
            return toBuffer(arr, hashSize, bigEndian);
          }
          module.exports = {hash: hash};
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      35: [function(require, module, exports) {
        (function(Buffer) {
          var rng = require('./rng');
          function error() {
            var m = [].slice.call(arguments).join(' ');
            throw new Error([m, 'we accept pull requests', 'http://github.com/dominictarr/crypto-browserify'].join('\n'));
          }
          exports.createHash = require('./create-hash');
          exports.createHmac = require('./create-hmac');
          exports.randomBytes = function(size, callback) {
            if (callback && callback.call) {
              try {
                callback.call(this, undefined, new Buffer(rng(size)));
              } catch (err) {
                callback(err);
              }
            } else {
              return new Buffer(rng(size));
            }
          };
          function each(a, f) {
            for (var i in a)
              f(a[i], i);
          }
          exports.getHashes = function() {
            return ['sha1', 'sha256', 'md5', 'rmd160'];
          };
          var p = require('./pbkdf2')(exports.createHmac);
          exports.pbkdf2 = p.pbkdf2;
          exports.pbkdf2Sync = p.pbkdf2Sync;
          each(['createCredentials', 'createCipher', 'createCipheriv', 'createDecipher', 'createDecipheriv', 'createSign', 'createVerify', 'createDiffieHellman'], function(name) {
            exports[name] = function() {
              error('sorry,', name, 'is not implemented yet');
            };
          });
        }).call(this, require("buffer").Buffer);
      }, {
        "./create-hash": 32,
        "./create-hmac": 33,
        "./pbkdf2": 43,
        "./rng": 44,
        "buffer": 29
      }],
      36: [function(require, module, exports) {
        var helpers = require('./helpers');
        function core_md5(x, len) {
          x[len >> 5] |= 0x80 << ((len) % 32);
          x[(((len + 64) >>> 9) << 4) + 14] = len;
          var a = 1732584193;
          var b = -271733879;
          var c = -1732584194;
          var d = 271733878;
          for (var i = 0; i < x.length; i += 16) {
            var olda = a;
            var oldb = b;
            var oldc = c;
            var oldd = d;
            a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
            d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
            d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
          }
          return Array(a, b, c, d);
        }
        function md5_cmn(q, a, b, x, s, t) {
          return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
        }
        function md5_ff(a, b, c, d, x, s, t) {
          return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
        }
        function md5_gg(a, b, c, d, x, s, t) {
          return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
        }
        function md5_hh(a, b, c, d, x, s, t) {
          return md5_cmn(b ^ c ^ d, a, b, x, s, t);
        }
        function md5_ii(a, b, c, d, x, s, t) {
          return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
        }
        function safe_add(x, y) {
          var lsw = (x & 0xFFFF) + (y & 0xFFFF);
          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return (msw << 16) | (lsw & 0xFFFF);
        }
        function bit_rol(num, cnt) {
          return (num << cnt) | (num >>> (32 - cnt));
        }
        module.exports = function md5(buf) {
          return helpers.hash(buf, core_md5, 16);
        };
      }, {"./helpers": 34}],
      37: [function(require, module, exports) {
        (function(Buffer) {
          module.exports = ripemd160;
          var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
          var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
          var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
          var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
          var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
          var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
          var bytesToWords = function(bytes) {
            var words = [];
            for (var i = 0,
                b = 0; i < bytes.length; i++, b += 8) {
              words[b >>> 5] |= bytes[i] << (24 - b % 32);
            }
            return words;
          };
          var wordsToBytes = function(words) {
            var bytes = [];
            for (var b = 0; b < words.length * 32; b += 8) {
              bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
            }
            return bytes;
          };
          var processBlock = function(H, M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
            }
            var al,
                bl,
                cl,
                dl,
                el;
            var ar,
                br,
                cr,
                dr,
                er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = (al + M[offset + zl[i]]) | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = (t + el) | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = (ar + M[offset + zr[i]]) | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = (t + er) | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = (H[1] + cl + dr) | 0;
            H[1] = (H[2] + dl + er) | 0;
            H[2] = (H[3] + el + ar) | 0;
            H[3] = (H[4] + al + br) | 0;
            H[4] = (H[0] + bl + cr) | 0;
            H[0] = t;
          };
          function f1(x, y, z) {
            return ((x) ^ (y) ^ (z));
          }
          function f2(x, y, z) {
            return (((x) & (y)) | ((~x) & (z)));
          }
          function f3(x, y, z) {
            return (((x) | (~(y))) ^ (z));
          }
          function f4(x, y, z) {
            return (((x) & (z)) | ((y) & (~(z))));
          }
          function f5(x, y, z) {
            return ((x) ^ ((y) | (~(z))));
          }
          function rotl(x, n) {
            return (x << n) | (x >>> (32 - n));
          }
          function ripemd160(message) {
            var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
            if (typeof message == 'string')
              message = new Buffer(message, 'utf8');
            var m = bytesToWords(message);
            var nBitsLeft = message.length * 8;
            var nBitsTotal = message.length * 8;
            m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00));
            for (var i = 0; i < m.length; i += 16) {
              processBlock(H, m, i);
            }
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
            }
            var digestbytes = wordsToBytes(H);
            return new Buffer(digestbytes);
          }
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      38: [function(require, module, exports) {
        var u = require('./util');
        var write = u.write;
        var fill = u.zeroFill;
        module.exports = function(Buffer) {
          function Hash(blockSize, finalSize) {
            this._block = new Buffer(blockSize);
            this._finalSize = finalSize;
            this._blockSize = blockSize;
            this._len = 0;
            this._s = 0;
          }
          Hash.prototype.init = function() {
            this._s = 0;
            this._len = 0;
          };
          function lengthOf(data, enc) {
            if (enc == null)
              return data.byteLength || data.length;
            if (enc == 'ascii' || enc == 'binary')
              return data.length;
            if (enc == 'hex')
              return data.length / 2;
            if (enc == 'base64')
              return data.length / 3;
          }
          Hash.prototype.update = function(data, enc) {
            var bl = this._blockSize;
            var length;
            if (!enc && 'string' === typeof data)
              enc = 'utf8';
            if (enc) {
              if (enc === 'utf-8')
                enc = 'utf8';
              if (enc === 'base64' || enc === 'utf8')
                data = new Buffer(data, enc), enc = null;
              length = lengthOf(data, enc);
            } else
              length = data.byteLength || data.length;
            var l = this._len += length;
            var s = this._s = (this._s || 0);
            var f = 0;
            var buffer = this._block;
            while (s < l) {
              var t = Math.min(length, f + bl);
              write(buffer, data, enc, s % bl, f, t);
              var ch = (t - f);
              s += ch;
              f += ch;
              if (!(s % bl))
                this._update(buffer);
            }
            this._s = s;
            return this;
          };
          Hash.prototype.digest = function(enc) {
            var bl = this._blockSize;
            var fl = this._finalSize;
            var len = this._len * 8;
            var x = this._block;
            var bits = len % (bl * 8);
            x[this._len % bl] = 0x80;
            fill(this._block, this._len % bl + 1);
            if (bits >= fl * 8) {
              this._update(this._block);
              u.zeroFill(this._block, 0);
            }
            x.writeInt32BE(len, fl + 4);
            var hash = this._update(this._block) || this._hash();
            if (enc == null)
              return hash;
            return hash.toString(enc);
          };
          Hash.prototype._update = function() {
            throw new Error('_update must be implemented by subclass');
          };
          return Hash;
        };
      }, {"./util": 42}],
      39: [function(require, module, exports) {
        var exports = module.exports = function(alg) {
          var Alg = exports[alg];
          if (!Alg)
            throw new Error(alg + ' is not supported (we accept pull requests)');
          return new Alg();
        };
        var Buffer = require('buffer').Buffer;
        var Hash = require('./hash')(Buffer);
        exports.sha = exports.sha1 = require('./sha1')(Buffer, Hash);
        exports.sha256 = require('./sha256')(Buffer, Hash);
      }, {
        "./hash": 38,
        "./sha1": 40,
        "./sha256": 41,
        "buffer": 29
      }],
      40: [function(require, module, exports) {
        module.exports = function(Buffer, Hash) {
          var inherits = require('util').inherits;
          inherits(Sha1, Hash);
          var A = 0 | 0;
          var B = 4 | 0;
          var C = 8 | 0;
          var D = 12 | 0;
          var E = 16 | 0;
          var BE = false;
          var LE = true;
          var W = new Int32Array(80);
          var POOL = [];
          function Sha1() {
            if (POOL.length)
              return POOL.pop().init();
            if (!(this instanceof Sha1))
              return new Sha1();
            this._w = W;
            Hash.call(this, 16 * 4, 14 * 4);
            this._h = null;
            this.init();
          }
          Sha1.prototype.init = function() {
            this._a = 0x67452301;
            this._b = 0xefcdab89;
            this._c = 0x98badcfe;
            this._d = 0x10325476;
            this._e = 0xc3d2e1f0;
            Hash.prototype.init.call(this);
            return this;
          };
          Sha1.prototype._POOL = POOL;
          var isDV = new Buffer(1) instanceof DataView;
          function readInt32BE(X, i) {
            return isDV ? X.getInt32(i, false) : X.readInt32BE(i);
          }
          Sha1.prototype._update = function(array) {
            var X = this._block;
            var h = this._h;
            var a,
                b,
                c,
                d,
                e,
                _a,
                _b,
                _c,
                _d,
                _e;
            a = _a = this._a;
            b = _b = this._b;
            c = _c = this._c;
            d = _d = this._d;
            e = _e = this._e;
            var w = this._w;
            for (var j = 0; j < 80; j++) {
              var W = w[j] = j < 16 ? X.readInt32BE(j * 4) : rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
              var t = add(add(rol(a, 5), sha1_ft(j, b, c, d)), add(add(e, W), sha1_kt(j)));
              e = d;
              d = c;
              c = rol(b, 30);
              b = a;
              a = t;
            }
            this._a = add(a, _a);
            this._b = add(b, _b);
            this._c = add(c, _c);
            this._d = add(d, _d);
            this._e = add(e, _e);
          };
          Sha1.prototype._hash = function() {
            if (POOL.length < 100)
              POOL.push(this);
            var H = new Buffer(20);
            H.writeInt32BE(this._a | 0, A);
            H.writeInt32BE(this._b | 0, B);
            H.writeInt32BE(this._c | 0, C);
            H.writeInt32BE(this._d | 0, D);
            H.writeInt32BE(this._e | 0, E);
            return H;
          };
          function sha1_ft(t, b, c, d) {
            if (t < 20)
              return (b & c) | ((~b) & d);
            if (t < 40)
              return b ^ c ^ d;
            if (t < 60)
              return (b & c) | (b & d) | (c & d);
            return b ^ c ^ d;
          }
          function sha1_kt(t) {
            return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514;
          }
          function add(x, y) {
            return (x + y) | 0;
          }
          function rol(num, cnt) {
            return (num << cnt) | (num >>> (32 - cnt));
          }
          return Sha1;
        };
      }, {"util": 72}],
      41: [function(require, module, exports) {
        var inherits = require('util').inherits;
        var BE = false;
        var LE = true;
        var u = require('./util');
        module.exports = function(Buffer, Hash) {
          var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
          inherits(Sha256, Hash);
          var W = new Array(64);
          var POOL = [];
          function Sha256() {
            if (POOL.length) {}
            this.init();
            this._w = W;
            Hash.call(this, 16 * 4, 14 * 4);
          }
          ;
          Sha256.prototype.init = function() {
            this._a = 0x6a09e667 | 0;
            this._b = 0xbb67ae85 | 0;
            this._c = 0x3c6ef372 | 0;
            this._d = 0xa54ff53a | 0;
            this._e = 0x510e527f | 0;
            this._f = 0x9b05688c | 0;
            this._g = 0x1f83d9ab | 0;
            this._h = 0x5be0cd19 | 0;
            this._len = this._s = 0;
            return this;
          };
          var safe_add = function(x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
          };
          function S(X, n) {
            return (X >>> n) | (X << (32 - n));
          }
          function R(X, n) {
            return (X >>> n);
          }
          function Ch(x, y, z) {
            return ((x & y) ^ ((~x) & z));
          }
          function Maj(x, y, z) {
            return ((x & y) ^ (x & z) ^ (y & z));
          }
          function Sigma0256(x) {
            return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
          }
          function Sigma1256(x) {
            return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
          }
          function Gamma0256(x) {
            return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
          }
          function Gamma1256(x) {
            return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
          }
          Sha256.prototype._update = function(m) {
            var M = this._block;
            var W = this._w;
            var a,
                b,
                c,
                d,
                e,
                f,
                g,
                h;
            var T1,
                T2;
            a = this._a | 0;
            b = this._b | 0;
            c = this._c | 0;
            d = this._d | 0;
            e = this._e | 0;
            f = this._f | 0;
            g = this._g | 0;
            h = this._h | 0;
            for (var j = 0; j < 64; j++) {
              var w = W[j] = j < 16 ? M.readInt32BE(j * 4) : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16];
              T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w;
              T2 = Sigma0256(a) + Maj(a, b, c);
              h = g;
              g = f;
              f = e;
              e = d + T1;
              d = c;
              c = b;
              b = a;
              a = T1 + T2;
            }
            this._a = (a + this._a) | 0;
            this._b = (b + this._b) | 0;
            this._c = (c + this._c) | 0;
            this._d = (d + this._d) | 0;
            this._e = (e + this._e) | 0;
            this._f = (f + this._f) | 0;
            this._g = (g + this._g) | 0;
            this._h = (h + this._h) | 0;
          };
          Sha256.prototype._hash = function() {
            if (POOL.length < 10)
              POOL.push(this);
            var H = new Buffer(32);
            H.writeInt32BE(this._a, 0);
            H.writeInt32BE(this._b, 4);
            H.writeInt32BE(this._c, 8);
            H.writeInt32BE(this._d, 12);
            H.writeInt32BE(this._e, 16);
            H.writeInt32BE(this._f, 20);
            H.writeInt32BE(this._g, 24);
            H.writeInt32BE(this._h, 28);
            return H;
          };
          return Sha256;
        };
      }, {
        "./util": 42,
        "util": 72
      }],
      42: [function(require, module, exports) {
        exports.write = write;
        exports.zeroFill = zeroFill;
        exports.toString = toString;
        function write(buffer, string, enc, start, from, to, LE) {
          var l = (to - from);
          if (enc === 'ascii' || enc === 'binary') {
            for (var i = 0; i < l; i++) {
              buffer[start + i] = string.charCodeAt(i + from);
            }
          } else if (enc == null) {
            for (var i = 0; i < l; i++) {
              buffer[start + i] = string[i + from];
            }
          } else if (enc === 'hex') {
            for (var i = 0; i < l; i++) {
              var j = from + i;
              buffer[start + i] = parseInt(string[j * 2] + string[(j * 2) + 1], 16);
            }
          } else if (enc === 'base64') {
            throw new Error('base64 encoding not yet supported');
          } else
            throw new Error(enc + ' encoding not yet supported');
        }
        function zeroFill(buf, from) {
          for (var i = from; i < buf.length; i++)
            buf[i] = 0;
        }
      }, {}],
      43: [function(require, module, exports) {
        (function(Buffer) {
          var blocksize = 64;
          var zeroBuffer = new Buffer(blocksize);
          zeroBuffer.fill(0);
          module.exports = function(createHmac, exports) {
            exports = exports || {};
            exports.pbkdf2 = function(password, salt, iterations, keylen, cb) {
              if ('function' !== typeof cb)
                throw new Error('No callback provided to pbkdf2');
              setTimeout(function() {
                cb(null, exports.pbkdf2Sync(password, salt, iterations, keylen));
              });
            };
            exports.pbkdf2Sync = function(key, salt, iterations, keylen) {
              if ('number' !== typeof iterations)
                throw new TypeError('Iterations not a number');
              if (iterations < 0)
                throw new TypeError('Bad iterations');
              if ('number' !== typeof keylen)
                throw new TypeError('Key length not a number');
              if (keylen < 0)
                throw new TypeError('Bad key length');
              var key = !Buffer.isBuffer(key) ? new Buffer(key) : key;
              if (key.length > blocksize) {
                key = createHash(alg).update(key).digest();
              } else if (key.length < blocksize) {
                key = Buffer.concat([key, zeroBuffer], blocksize);
              }
              var HMAC;
              var cplen,
                  p = 0,
                  i = 1,
                  itmp = new Buffer(4),
                  digtmp;
              var out = new Buffer(keylen);
              out.fill(0);
              while (keylen) {
                if (keylen > 20)
                  cplen = 20;
                else
                  cplen = keylen;
                itmp[0] = (i >> 24) & 0xff;
                itmp[1] = (i >> 16) & 0xff;
                itmp[2] = (i >> 8) & 0xff;
                itmp[3] = i & 0xff;
                HMAC = createHmac('sha1', key);
                HMAC.update(salt);
                HMAC.update(itmp);
                digtmp = HMAC.digest();
                digtmp.copy(out, p, 0, cplen);
                for (var j = 1; j < iterations; j++) {
                  HMAC = createHmac('sha1', key);
                  HMAC.update(digtmp);
                  digtmp = HMAC.digest();
                  for (var k = 0; k < cplen; k++) {
                    out[k] ^= digtmp[k];
                  }
                }
                keylen -= cplen;
                i++;
                p += cplen;
              }
              return out;
            };
            return exports;
          };
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      44: [function(require, module, exports) {
        (function(Buffer) {
          (function() {
            var _global = this;
            var mathRNG,
                whatwgRNG;
            mathRNG = function(size) {
              var bytes = new Buffer(size);
              var r;
              for (var i = 0,
                  r; i < size; i++) {
                if ((i & 0x03) == 0)
                  r = Math.random() * 0x100000000;
                bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
              }
              return bytes;
            };
            if (_global.crypto && crypto.getRandomValues) {
              whatwgRNG = function(size) {
                var bytes = new Buffer(size);
                crypto.getRandomValues(bytes);
                return bytes;
              };
            }
            module.exports = whatwgRNG || mathRNG;
          }());
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      45: [function(require, module, exports) {
        function EventEmitter() {
          this._events = this._events || {};
          this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;
        EventEmitter.defaultMaxListeners = 10;
        EventEmitter.prototype.setMaxListeners = function(n) {
          if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
          this._maxListeners = n;
          return this;
        };
        EventEmitter.prototype.emit = function(type) {
          var er,
              handler,
              len,
              args,
              i,
              listeners;
          if (!this._events)
            this._events = {};
          if (type === 'error') {
            if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
              er = arguments[1];
              if (er instanceof Error) {
                throw er;
              } else {
                throw TypeError('Uncaught, unspecified "error" event.');
              }
              return false;
            }
          }
          handler = this._events[type];
          if (isUndefined(handler))
            return false;
          if (isFunction(handler)) {
            switch (arguments.length) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                len = arguments.length;
                args = new Array(len - 1);
                for (i = 1; i < len; i++)
                  args[i - 1] = arguments[i];
                handler.apply(this, args);
            }
          } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
              listeners[i].apply(this, args);
          }
          return true;
        };
        EventEmitter.prototype.addListener = function(type, listener) {
          var m;
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          if (!this._events)
            this._events = {};
          if (this._events.newListener)
            this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
          if (!this._events[type])
            this._events[type] = listener;
          else if (isObject(this._events[type]))
            this._events[type].push(listener);
          else
            this._events[type] = [this._events[type], listener];
          if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
              m = this._maxListeners;
            } else {
              m = EventEmitter.defaultMaxListeners;
            }
            if (m && m > 0 && this._events[type].length > m) {
              this._events[type].warned = true;
              console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
              if (typeof console.trace === 'function') {
                console.trace();
              }
            }
          }
          return this;
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.once = function(type, listener) {
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          var fired = false;
          function g() {
            this.removeListener(type, g);
            if (!fired) {
              fired = true;
              listener.apply(this, arguments);
            }
          }
          g.listener = listener;
          this.on(type, g);
          return this;
        };
        EventEmitter.prototype.removeListener = function(type, listener) {
          var list,
              position,
              length,
              i;
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          if (!this._events || !this._events[type])
            return this;
          list = this._events[type];
          length = list.length;
          position = -1;
          if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
            delete this._events[type];
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          } else if (isObject(list)) {
            for (i = length; i-- > 0; ) {
              if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
                position = i;
                break;
              }
            }
            if (position < 0)
              return this;
            if (list.length === 1) {
              list.length = 0;
              delete this._events[type];
            } else {
              list.splice(position, 1);
            }
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function(type) {
          var key,
              listeners;
          if (!this._events)
            return this;
          if (!this._events.removeListener) {
            if (arguments.length === 0)
              this._events = {};
            else if (this._events[type])
              delete this._events[type];
            return this;
          }
          if (arguments.length === 0) {
            for (key in this._events) {
              if (key === 'removeListener')
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
          }
          listeners = this._events[type];
          if (isFunction(listeners)) {
            this.removeListener(type, listeners);
          } else {
            while (listeners.length)
              this.removeListener(type, listeners[listeners.length - 1]);
          }
          delete this._events[type];
          return this;
        };
        EventEmitter.prototype.listeners = function(type) {
          var ret;
          if (!this._events || !this._events[type])
            ret = [];
          else if (isFunction(this._events[type]))
            ret = [this._events[type]];
          else
            ret = this._events[type].slice();
          return ret;
        };
        EventEmitter.listenerCount = function(emitter, type) {
          var ret;
          if (!emitter._events || !emitter._events[type])
            ret = 0;
          else if (isFunction(emitter._events[type]))
            ret = 1;
          else
            ret = emitter._events[type].length;
          return ret;
        };
        function isFunction(arg) {
          return typeof arg === 'function';
        }
        function isNumber(arg) {
          return typeof arg === 'number';
        }
        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        function isUndefined(arg) {
          return arg === void 0;
        }
      }, {}],
      46: [function(require, module, exports) {
        var http = module.exports;
        var EventEmitter = require('events').EventEmitter;
        var Request = require('./lib/request');
        var url = require('url');
        http.request = function(params, cb) {
          if (typeof params === 'string') {
            params = url.parse(params);
          }
          if (!params)
            params = {};
          if (!params.host && !params.port) {
            params.port = parseInt(window.location.port, 10);
          }
          if (!params.host && params.hostname) {
            params.host = params.hostname;
          }
          if (!params.scheme)
            params.scheme = window.location.protocol.split(':')[0];
          if (!params.host) {
            params.host = window.location.hostname || window.location.host;
          }
          if (/:/.test(params.host)) {
            if (!params.port) {
              params.port = params.host.split(':')[1];
            }
            params.host = params.host.split(':')[0];
          }
          if (!params.port)
            params.port = params.scheme == 'https' ? 443 : 80;
          var req = new Request(new xhrHttp, params);
          if (cb)
            req.on('response', cb);
          return req;
        };
        http.get = function(params, cb) {
          params.method = 'GET';
          var req = http.request(params, cb);
          req.end();
          return req;
        };
        http.Agent = function() {};
        http.Agent.defaultMaxSockets = 4;
        var xhrHttp = (function() {
          if (typeof window === 'undefined') {
            throw new Error('no window object present');
          } else if (window.XMLHttpRequest) {
            return window.XMLHttpRequest;
          } else if (window.ActiveXObject) {
            var axs = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP'];
            for (var i = 0; i < axs.length; i++) {
              try {
                var ax = new (window.ActiveXObject)(axs[i]);
                return function() {
                  if (ax) {
                    var ax_ = ax;
                    ax = null;
                    return ax_;
                  } else {
                    return new (window.ActiveXObject)(axs[i]);
                  }
                };
              } catch (e) {}
            }
            throw new Error('ajax not supported in this browser');
          } else {
            throw new Error('ajax not supported in this browser');
          }
        })();
        http.STATUS_CODES = {
          100: 'Continue',
          101: 'Switching Protocols',
          102: 'Processing',
          200: 'OK',
          201: 'Created',
          202: 'Accepted',
          203: 'Non-Authoritative Information',
          204: 'No Content',
          205: 'Reset Content',
          206: 'Partial Content',
          207: 'Multi-Status',
          300: 'Multiple Choices',
          301: 'Moved Permanently',
          302: 'Moved Temporarily',
          303: 'See Other',
          304: 'Not Modified',
          305: 'Use Proxy',
          307: 'Temporary Redirect',
          400: 'Bad Request',
          401: 'Unauthorized',
          402: 'Payment Required',
          403: 'Forbidden',
          404: 'Not Found',
          405: 'Method Not Allowed',
          406: 'Not Acceptable',
          407: 'Proxy Authentication Required',
          408: 'Request Time-out',
          409: 'Conflict',
          410: 'Gone',
          411: 'Length Required',
          412: 'Precondition Failed',
          413: 'Request Entity Too Large',
          414: 'Request-URI Too Large',
          415: 'Unsupported Media Type',
          416: 'Requested Range Not Satisfiable',
          417: 'Expectation Failed',
          418: 'I\'m a teapot',
          422: 'Unprocessable Entity',
          423: 'Locked',
          424: 'Failed Dependency',
          425: 'Unordered Collection',
          426: 'Upgrade Required',
          428: 'Precondition Required',
          429: 'Too Many Requests',
          431: 'Request Header Fields Too Large',
          500: 'Internal Server Error',
          501: 'Not Implemented',
          502: 'Bad Gateway',
          503: 'Service Unavailable',
          504: 'Gateway Time-out',
          505: 'HTTP Version Not Supported',
          506: 'Variant Also Negotiates',
          507: 'Insufficient Storage',
          509: 'Bandwidth Limit Exceeded',
          510: 'Not Extended',
          511: 'Network Authentication Required'
        };
      }, {
        "./lib/request": 47,
        "events": 45,
        "url": 70
      }],
      47: [function(require, module, exports) {
        var Stream = require('stream');
        var Response = require('./response');
        var Base64 = require('Base64');
        var inherits = require('inherits');
        var Request = module.exports = function(xhr, params) {
          var self = this;
          self.writable = true;
          self.xhr = xhr;
          self.body = [];
          self.uri = (params.scheme || 'http') + '://' + params.host + (params.port ? ':' + params.port : '') + (params.path || '/');
          ;
          if (typeof params.withCredentials === 'undefined') {
            params.withCredentials = true;
          }
          try {
            xhr.withCredentials = params.withCredentials;
          } catch (e) {}
          if (params.responseType)
            try {
              xhr.responseType = params.responseType;
            } catch (e) {}
          xhr.open(params.method || 'GET', self.uri, true);
          self._headers = {};
          if (params.headers) {
            var keys = objectKeys(params.headers);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (!self.isSafeRequestHeader(key))
                continue;
              var value = params.headers[key];
              self.setHeader(key, value);
            }
          }
          if (params.auth) {
            this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
          }
          var res = new Response;
          res.on('close', function() {
            self.emit('close');
          });
          res.on('ready', function() {
            self.emit('response', res);
          });
          xhr.onreadystatechange = function() {
            if (xhr.__aborted)
              return;
            res.handle(xhr);
          };
        };
        inherits(Request, Stream);
        Request.prototype.setHeader = function(key, value) {
          this._headers[key.toLowerCase()] = value;
        };
        Request.prototype.getHeader = function(key) {
          return this._headers[key.toLowerCase()];
        };
        Request.prototype.removeHeader = function(key) {
          delete this._headers[key.toLowerCase()];
        };
        Request.prototype.write = function(s) {
          this.body.push(s);
        };
        Request.prototype.destroy = function(s) {
          this.xhr.__aborted = true;
          this.xhr.abort();
          this.emit('close');
        };
        Request.prototype.end = function(s) {
          if (s !== undefined)
            this.body.push(s);
          var keys = objectKeys(this._headers);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this._headers[key];
            if (isArray(value)) {
              for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
              }
            } else
              this.xhr.setRequestHeader(key, value);
          }
          if (this.body.length === 0) {
            this.xhr.send('');
          } else if (typeof this.body[0] === 'string') {
            this.xhr.send(this.body.join(''));
          } else if (isArray(this.body[0])) {
            var body = [];
            for (var i = 0; i < this.body.length; i++) {
              body.push.apply(body, this.body[i]);
            }
            this.xhr.send(body);
          } else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
            var len = 0;
            for (var i = 0; i < this.body.length; i++) {
              len += this.body[i].length;
            }
            var body = new (this.body[0].constructor)(len);
            var k = 0;
            for (var i = 0; i < this.body.length; i++) {
              var b = this.body[i];
              for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
              }
            }
            this.xhr.send(body);
          } else {
            var body = '';
            for (var i = 0; i < this.body.length; i++) {
              body += this.body[i].toString();
            }
            this.xhr.send(body);
          }
        };
        Request.unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];
        Request.prototype.isSafeRequestHeader = function(headerName) {
          if (!headerName)
            return false;
          return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
        };
        var objectKeys = Object.keys || function(obj) {
          var keys = [];
          for (var key in obj)
            keys.push(key);
          return keys;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
        var indexOf = function(xs, x) {
          if (xs.indexOf)
            return xs.indexOf(x);
          for (var i = 0; i < xs.length; i++) {
            if (xs[i] === x)
              return i;
          }
          return -1;
        };
      }, {
        "./response": 48,
        "Base64": 49,
        "inherits": 50,
        "stream": 69
      }],
      48: [function(require, module, exports) {
        var Stream = require('stream');
        var util = require('util');
        var Response = module.exports = function(res) {
          this.offset = 0;
          this.readable = true;
        };
        util.inherits(Response, Stream);
        var capable = {
          streaming: true,
          status2: true
        };
        function parseHeaders(res) {
          var lines = res.getAllResponseHeaders().split(/\r?\n/);
          var headers = {};
          for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (line === '')
              continue;
            var m = line.match(/^([^:]+):\s*(.*)/);
            if (m) {
              var key = m[1].toLowerCase(),
                  value = m[2];
              if (headers[key] !== undefined) {
                if (isArray(headers[key])) {
                  headers[key].push(value);
                } else {
                  headers[key] = [headers[key], value];
                }
              } else {
                headers[key] = value;
              }
            } else {
              headers[line] = true;
            }
          }
          return headers;
        }
        Response.prototype.getResponse = function(xhr) {
          var respType = String(xhr.responseType).toLowerCase();
          if (respType === 'blob')
            return xhr.responseBlob || xhr.response;
          if (respType === 'arraybuffer')
            return xhr.response;
          return xhr.responseText;
        };
        Response.prototype.getHeader = function(key) {
          return this.headers[key.toLowerCase()];
        };
        Response.prototype.handle = function(res) {
          if (res.readyState === 2 && capable.status2) {
            try {
              this.statusCode = res.status;
              this.headers = parseHeaders(res);
            } catch (err) {
              capable.status2 = false;
            }
            if (capable.status2) {
              this.emit('ready');
            }
          } else if (capable.streaming && res.readyState === 3) {
            try {
              if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
              }
            } catch (err) {}
            try {
              this._emitData(res);
            } catch (err) {
              capable.streaming = false;
            }
          } else if (res.readyState === 4) {
            if (!this.statusCode) {
              this.statusCode = res.status;
              this.emit('ready');
            }
            this._emitData(res);
            if (res.error) {
              this.emit('error', this.getResponse(res));
            } else
              this.emit('end');
            this.emit('close');
          }
        };
        Response.prototype._emitData = function(res) {
          var respBody = this.getResponse(res);
          if (respBody.toString().match(/ArrayBuffer/)) {
            this.emit('data', new Uint8Array(respBody, this.offset));
            this.offset = respBody.byteLength;
            return;
          }
          if (respBody.length > this.offset) {
            this.emit('data', respBody.slice(this.offset));
            this.offset = respBody.length;
          }
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
      }, {
        "stream": 69,
        "util": 72
      }],
      49: [function(require, module, exports) {
        ;
        (function() {
          var object = typeof exports != 'undefined' ? exports : this;
          var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
          function InvalidCharacterError(message) {
            this.message = message;
          }
          InvalidCharacterError.prototype = new Error;
          InvalidCharacterError.prototype.name = 'InvalidCharacterError';
          object.btoa || (object.btoa = function(input) {
            for (var block,
                charCode,
                idx = 0,
                map = chars,
                output = ''; input.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
              charCode = input.charCodeAt(idx += 3 / 4);
              if (charCode > 0xFF) {
                throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
              }
              block = block << 8 | charCode;
            }
            return output;
          });
          object.atob || (object.atob = function(input) {
            input = input.replace(/=+$/, '');
            if (input.length % 4 == 1) {
              throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
            }
            for (var bc = 0,
                bs,
                buffer,
                idx = 0,
                output = ''; buffer = input.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
              buffer = chars.indexOf(buffer);
            }
            return output;
          });
        }());
      }, {}],
      50: [function(require, module, exports) {
        if (typeof Object.create === 'function') {
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }});
          };
        } else {
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      }, {}],
      51: [function(require, module, exports) {
        var process = module.exports = {};
        process.nextTick = (function() {
          var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;
          var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;
          ;
          if (canSetImmediate) {
            return function(f) {
              return window.setImmediate(f);
            };
          }
          if (canPost) {
            var queue = [];
            window.addEventListener('message', function(ev) {
              var source = ev.source;
              if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                  var fn = queue.shift();
                  fn();
                }
              }
            }, true);
            return function nextTick(fn) {
              queue.push(fn);
              window.postMessage('process-tick', '*');
            };
          }
          return function nextTick(fn) {
            setTimeout(fn, 0);
          };
        })();
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.binding = function(name) {
          throw new Error('process.binding is not supported');
        };
        process.cwd = function() {
          return '/';
        };
        process.chdir = function(dir) {
          throw new Error('process.chdir is not supported');
        };
      }, {}],
      52: [function(require, module, exports) {
        (function(global) {
          ;
          (function(root) {
            var freeExports = typeof exports == 'object' && exports;
            var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
            var freeGlobal = typeof global == 'object' && global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
              root = freeGlobal;
            }
            var punycode,
                maxInt = 2147483647,
                base = 36,
                tMin = 1,
                tMax = 26,
                skew = 38,
                damp = 700,
                initialBias = 72,
                initialN = 128,
                delimiter = '-',
                regexPunycode = /^xn--/,
                regexNonASCII = /[^ -~]/,
                regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g,
                errors = {
                  'overflow': 'Overflow: input needs wider integers to process',
                  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                  'invalid-input': 'Invalid input'
                },
                baseMinusTMin = base - tMin,
                floor = Math.floor,
                stringFromCharCode = String.fromCharCode,
                key;
            function error(type) {
              throw RangeError(errors[type]);
            }
            function map(array, fn) {
              var length = array.length;
              while (length--) {
                array[length] = fn(array[length]);
              }
              return array;
            }
            function mapDomain(string, fn) {
              return map(string.split(regexSeparators), fn).join('.');
            }
            function ucs2decode(string) {
              var output = [],
                  counter = 0,
                  length = string.length,
                  value,
                  extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                  extra = string.charCodeAt(counter++);
                  if ((extra & 0xFC00) == 0xDC00) {
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                  } else {
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }
            function ucs2encode(array) {
              return map(array, function(value) {
                var output = '';
                if (value > 0xFFFF) {
                  value -= 0x10000;
                  output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                  value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
              }).join('');
            }
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base;
            }
            function digitToBasic(digit, flag) {
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }
            function decode(input) {
              var output = [],
                  inputLength = input.length,
                  out,
                  i = 0,
                  n = initialN,
                  bias = initialBias,
                  basic,
                  j,
                  index,
                  oldi,
                  w,
                  k,
                  digit,
                  t,
                  baseMinusT;
              basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }
              for (j = 0; j < basic; ++j) {
                if (input.charCodeAt(j) >= 0x80) {
                  error('not-basic');
                }
                output.push(input.charCodeAt(j));
              }
              for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                for (oldi = i, w = 1, k = base; ; k += base) {
                  if (index >= inputLength) {
                    error('invalid-input');
                  }
                  digit = basicToDigit(input.charCodeAt(index++));
                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow');
                  }
                  i += digit * w;
                  t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                  if (digit < t) {
                    break;
                  }
                  baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow');
                  }
                  w *= baseMinusT;
                }
                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                if (floor(i / out) > maxInt - n) {
                  error('overflow');
                }
                n += floor(i / out);
                i %= out;
                output.splice(i++, 0, n);
              }
              return ucs2encode(output);
            }
            function encode(input) {
              var n,
                  delta,
                  handledCPCount,
                  basicLength,
                  bias,
                  j,
                  m,
                  q,
                  k,
                  t,
                  currentValue,
                  output = [],
                  inputLength,
                  handledCPCountPlusOne,
                  baseMinusT,
                  qMinusT;
              input = ucs2decode(input);
              inputLength = input.length;
              n = initialN;
              delta = 0;
              bias = initialBias;
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue));
                }
              }
              handledCPCount = basicLength = output.length;
              if (basicLength) {
                output.push(delimiter);
              }
              while (handledCPCount < inputLength) {
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow');
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                  }
                  if (currentValue == n) {
                    for (q = delta, k = base; ; k += base) {
                      t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                      q = floor(qMinusT / baseMinusT);
                    }
                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }
                ++delta;
                ++n;
              }
              return output.join('');
            }
            function toUnicode(domain) {
              return mapDomain(domain, function(string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
              });
            }
            function toASCII(domain) {
              return mapDomain(domain, function(string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
              });
            }
            punycode = {
              'version': '1.2.4',
              'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
              },
              'decode': decode,
              'encode': encode,
              'toASCII': toASCII,
              'toUnicode': toUnicode
            };
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
              define('punycode', function() {
                return punycode;
              });
            } else if (freeExports && !freeExports.nodeType) {
              if (freeModule) {
                freeModule.exports = punycode;
              } else {
                for (key in punycode) {
                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
              }
            } else {
              root.punycode = punycode;
            }
          }(this));
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}],
      53: [function(require, module, exports) {
        'use strict';
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function(qs, sep, eq, options) {
          sep = sep || '&';
          eq = eq || '=';
          var obj = {};
          if (typeof qs !== 'string' || qs.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs = qs.split(sep);
          var maxKeys = 1000;
          if (options && typeof options.maxKeys === 'number') {
            maxKeys = options.maxKeys;
          }
          var len = qs.length;
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, '%20'),
                idx = x.indexOf(eq),
                kstr,
                vstr,
                k,
                v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = '';
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }
          return obj;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
      }, {}],
      54: [function(require, module, exports) {
        'use strict';
        var stringifyPrimitive = function(v) {
          switch (typeof v) {
            case 'string':
              return v;
            case 'boolean':
              return v ? 'true' : 'false';
            case 'number':
              return isFinite(v) ? v : '';
            default:
              return '';
          }
        };
        module.exports = function(obj, sep, eq, name) {
          sep = sep || '&';
          eq = eq || '=';
          if (obj === null) {
            obj = undefined;
          }
          if (typeof obj === 'object') {
            return map(objectKeys(obj), function(k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function(v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }
          if (!name)
            return '';
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
        function map(xs, f) {
          if (xs.map)
            return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }
        var objectKeys = Object.keys || function(obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              res.push(key);
          }
          return res;
        };
      }, {}],
      55: [function(require, module, exports) {
        'use strict';
        exports.decode = exports.parse = require('./decode');
        exports.encode = exports.stringify = require('./encode');
      }, {
        "./decode": 53,
        "./encode": 54
      }],
      56: [function(require, module, exports) {
        module.exports = require("./lib/_stream_duplex.js");
      }, {"./lib/_stream_duplex.js": 57}],
      57: [function(require, module, exports) {
        (function(process) {
          module.exports = Duplex;
          var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj)
              keys.push(key);
            return keys;
          };
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var Readable = require('./_stream_readable');
          var Writable = require('./_stream_writable');
          util.inherits(Duplex, Readable);
          forEach(objectKeys(Writable.prototype), function(method) {
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          });
          function Duplex(options) {
            if (!(this instanceof Duplex))
              return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            if (options && options.readable === false)
              this.readable = false;
            if (options && options.writable === false)
              this.writable = false;
            this.allowHalfOpen = true;
            if (options && options.allowHalfOpen === false)
              this.allowHalfOpen = false;
            this.once('end', onend);
          }
          function onend() {
            if (this.allowHalfOpen || this._writableState.ended)
              return;
            process.nextTick(this.end.bind(this));
          }
          function forEach(xs, f) {
            for (var i = 0,
                l = xs.length; i < l; i++) {
              f(xs[i], i);
            }
          }
        }).call(this, require("sycGbZ"));
      }, {
        "./_stream_readable": 59,
        "./_stream_writable": 61,
        "core-util-is": 62,
        "inherits": 50,
        "sycGbZ": 51
      }],
      58: [function(require, module, exports) {
        module.exports = PassThrough;
        var Transform = require('./_stream_transform');
        var util = require('core-util-is');
        util.inherits = require('inherits');
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, {
        "./_stream_transform": 60,
        "core-util-is": 62,
        "inherits": 50
      }],
      59: [function(require, module, exports) {
        (function(process) {
          module.exports = Readable;
          var isArray = require('isarray');
          var Buffer = require('buffer').Buffer;
          Readable.ReadableState = ReadableState;
          var EE = require('events').EventEmitter;
          if (!EE.listenerCount)
            EE.listenerCount = function(emitter, type) {
              return emitter.listeners(type).length;
            };
          var Stream = require('stream');
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var StringDecoder;
          util.inherits(Readable, Stream);
          function ReadableState(options, stream) {
            options = options || {};
            var hwm = options.highWaterMark;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
            this.highWaterMark = ~~this.highWaterMark;
            this.buffer = [];
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = false;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.calledRead = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.objectMode = !!options.objectMode;
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            this.ranOut = false;
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            if (!(this instanceof Readable))
              return new Readable(options);
            this._readableState = new ReadableState(options, this);
            this.readable = true;
            Stream.call(this);
          }
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            if (typeof chunk === 'string' && !state.objectMode) {
              encoding = encoding || state.defaultEncoding;
              if (encoding !== state.encoding) {
                chunk = new Buffer(chunk, encoding);
                encoding = '';
              }
            }
            return readableAddChunk(this, state, chunk, encoding, false);
          };
          Readable.prototype.unshift = function(chunk) {
            var state = this._readableState;
            return readableAddChunk(this, state, chunk, '', true);
          };
          function readableAddChunk(stream, state, chunk, encoding, addToFront) {
            var er = chunkInvalid(state, chunk);
            if (er) {
              stream.emit('error', er);
            } else if (chunk === null || chunk === undefined) {
              state.reading = false;
              if (!state.ended)
                onEofChunk(stream, state);
            } else if (state.objectMode || chunk && chunk.length > 0) {
              if (state.ended && !addToFront) {
                var e = new Error('stream.push() after EOF');
                stream.emit('error', e);
              } else if (state.endEmitted && addToFront) {
                var e = new Error('stream.unshift() after end event');
                stream.emit('error', e);
              } else {
                if (state.decoder && !addToFront && !encoding)
                  chunk = state.decoder.write(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) {
                  state.buffer.unshift(chunk);
                } else {
                  state.reading = false;
                  state.buffer.push(chunk);
                }
                if (state.needReadable)
                  emitReadable(stream);
                maybeReadMore(stream, state);
              }
            } else if (!addToFront) {
              state.reading = false;
            }
            return needMoreData(state);
          }
          function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
          }
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require('string_decoder/').StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
          };
          var MAX_HWM = 0x800000;
          function roundUpToNextPowerOf2(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              n--;
              for (var p = 1; p < 32; p <<= 1)
                n |= n >> p;
              n++;
            }
            return n;
          }
          function howMuchToRead(n, state) {
            if (state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return n === 0 ? 0 : 1;
            if (isNaN(n) || n === null) {
              if (state.flowing && state.buffer.length)
                return state.buffer[0].length;
              else
                return state.length;
            }
            if (n <= 0)
              return 0;
            if (n > state.highWaterMark)
              state.highWaterMark = roundUpToNextPowerOf2(n);
            if (n > state.length) {
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              } else
                return state.length;
            }
            return n;
          }
          Readable.prototype.read = function(n) {
            var state = this._readableState;
            state.calledRead = true;
            var nOrig = n;
            if (typeof n !== 'number' || n > 0)
              state.emittedReadable = false;
            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
              emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            var doRead = state.needReadable;
            if (state.length - n <= state.highWaterMark)
              doRead = true;
            if (state.ended || state.reading)
              doRead = false;
            if (doRead) {
              state.reading = true;
              state.sync = true;
              if (state.length === 0)
                state.needReadable = true;
              this._read(state.highWaterMark);
              state.sync = false;
            }
            if (doRead && !state.reading)
              n = howMuchToRead(nOrig, state);
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = true;
              n = 0;
            }
            state.length -= n;
            if (state.length === 0 && !state.ended)
              state.needReadable = true;
            if (state.ended && !state.endEmitted && state.length === 0)
              endReadable(this);
            return ret;
          };
          function chunkInvalid(state, chunk) {
            var er = null;
            if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode && !er) {
              er = new TypeError('Invalid non-string/buffer chunk');
            }
            return er;
          }
          function onEofChunk(stream, state) {
            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            if (state.length > 0)
              emitReadable(stream);
            else
              endReadable(stream);
          }
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (state.emittedReadable)
              return;
            state.emittedReadable = true;
            if (state.sync)
              process.nextTick(function() {
                emitReadable_(stream);
              });
            else
              emitReadable_(stream);
          }
          function emitReadable_(stream) {
            stream.emit('readable');
          }
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              process.nextTick(function() {
                maybeReadMore_(stream, state);
              });
            }
          }
          function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
              stream.read(0);
              if (len === state.length)
                break;
              else
                len = state.length;
            }
            state.readingMore = false;
          }
          Readable.prototype._read = function(n) {
            this.emit('error', new Error('not implemented'));
          };
          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : cleanup;
            if (state.endEmitted)
              process.nextTick(endFn);
            else
              src.once('end', endFn);
            dest.on('unpipe', onunpipe);
            function onunpipe(readable) {
              if (readable !== src)
                return;
              cleanup();
            }
            function onend() {
              dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);
            function cleanup() {
              dest.removeListener('close', onclose);
              dest.removeListener('finish', onfinish);
              dest.removeListener('drain', ondrain);
              dest.removeListener('error', onerror);
              dest.removeListener('unpipe', onunpipe);
              src.removeListener('end', onend);
              src.removeListener('end', cleanup);
              if (!dest._writableState || dest._writableState.needDrain)
                ondrain();
            }
            function onerror(er) {
              unpipe();
              dest.removeListener('error', onerror);
              if (EE.listenerCount(dest, 'error') === 0)
                dest.emit('error', er);
            }
            if (!dest._events || !dest._events.error)
              dest.on('error', onerror);
            else if (isArray(dest._events.error))
              dest._events.error.unshift(onerror);
            else
              dest._events.error = [onerror, dest._events.error];
            function onclose() {
              dest.removeListener('finish', onfinish);
              unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
              dest.removeListener('close', onclose);
              unpipe();
            }
            dest.once('finish', onfinish);
            function unpipe() {
              src.unpipe(dest);
            }
            dest.emit('pipe', src);
            if (!state.flowing) {
              this.on('readable', pipeOnReadable);
              state.flowing = true;
              process.nextTick(function() {
                flow(src);
              });
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function() {
              var dest = this;
              var state = src._readableState;
              state.awaitDrain--;
              if (state.awaitDrain === 0)
                flow(src);
            };
          }
          function flow(src) {
            var state = src._readableState;
            var chunk;
            state.awaitDrain = 0;
            function write(dest, i, list) {
              var written = dest.write(chunk);
              if (false === written) {
                state.awaitDrain++;
              }
            }
            while (state.pipesCount && null !== (chunk = src.read())) {
              if (state.pipesCount === 1)
                write(state.pipes, 0, null);
              else
                forEach(state.pipes, write);
              src.emit('data', chunk);
              if (state.awaitDrain > 0)
                return;
            }
            if (state.pipesCount === 0) {
              state.flowing = false;
              if (EE.listenerCount(src, 'data') > 0)
                emitDataEvents(src);
              return;
            }
            state.ranOut = true;
          }
          function pipeOnReadable() {
            if (this._readableState.ranOut) {
              this._readableState.ranOut = false;
              flow(this);
            }
          }
          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            if (state.pipesCount === 0)
              return this;
            if (state.pipesCount === 1) {
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              state.pipes = null;
              state.pipesCount = 0;
              this.removeListener('readable', pipeOnReadable);
              state.flowing = false;
              if (dest)
                dest.emit('unpipe', this);
              return this;
            }
            if (!dest) {
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              this.removeListener('readable', pipeOnReadable);
              state.flowing = false;
              for (var i = 0; i < len; i++)
                dests[i].emit('unpipe', this);
              return this;
            }
            var i = indexOf(state.pipes, dest);
            if (i === -1)
              return this;
            state.pipes.splice(i, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit('unpipe', this);
            return this;
          };
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if (ev === 'data' && !this._readableState.flowing)
              emitDataEvents(this);
            if (ev === 'readable' && this.readable) {
              var state = this._readableState;
              if (!state.readableListening) {
                state.readableListening = true;
                state.emittedReadable = false;
                state.needReadable = true;
                if (!state.reading) {
                  this.read(0);
                } else if (state.length) {
                  emitReadable(this, state);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          Readable.prototype.resume = function() {
            emitDataEvents(this);
            this.read(0);
            this.emit('resume');
          };
          Readable.prototype.pause = function() {
            emitDataEvents(this, true);
            this.emit('pause');
          };
          function emitDataEvents(stream, startPaused) {
            var state = stream._readableState;
            if (state.flowing) {
              throw new Error('Cannot switch to old mode now.');
            }
            var paused = startPaused || false;
            var readable = false;
            stream.readable = true;
            stream.pipe = Stream.prototype.pipe;
            stream.on = stream.addListener = Stream.prototype.on;
            stream.on('readable', function() {
              readable = true;
              var c;
              while (!paused && (null !== (c = stream.read())))
                stream.emit('data', c);
              if (c === null) {
                readable = false;
                stream._readableState.needReadable = true;
              }
            });
            stream.pause = function() {
              paused = true;
              this.emit('pause');
            };
            stream.resume = function() {
              paused = false;
              if (readable)
                process.nextTick(function() {
                  stream.emit('readable');
                });
              else
                this.read(0);
              this.emit('resume');
            };
            stream.emit('readable');
          }
          Readable.prototype.wrap = function(stream) {
            var state = this._readableState;
            var paused = false;
            var self = this;
            stream.on('end', function() {
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  self.push(chunk);
              }
              self.push(null);
            });
            stream.on('data', function(chunk) {
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              if (!chunk || !state.objectMode && !chunk.length)
                return;
              var ret = self.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            for (var i in stream) {
              if (typeof stream[i] === 'function' && typeof this[i] === 'undefined') {
                this[i] = function(method) {
                  return function() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            var events = ['error', 'close', 'destroy', 'pause', 'resume'];
            forEach(events, function(ev) {
              stream.on(ev, self.emit.bind(self, ev));
            });
            self._read = function(n) {
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return self;
          };
          Readable._fromList = fromList;
          function fromList(n, state) {
            var list = state.buffer;
            var length = state.length;
            var stringMode = !!state.decoder;
            var objectMode = !!state.objectMode;
            var ret;
            if (list.length === 0)
              return null;
            if (length === 0)
              ret = null;
            else if (objectMode)
              ret = list.shift();
            else if (!n || n >= length) {
              if (stringMode)
                ret = list.join('');
              else
                ret = Buffer.concat(list, length);
              list.length = 0;
            } else {
              if (n < list[0].length) {
                var buf = list[0];
                ret = buf.slice(0, n);
                list[0] = buf.slice(n);
              } else if (n === list[0].length) {
                ret = list.shift();
              } else {
                if (stringMode)
                  ret = '';
                else
                  ret = new Buffer(n);
                var c = 0;
                for (var i = 0,
                    l = list.length; i < l && c < n; i++) {
                  var buf = list[0];
                  var cpy = Math.min(n - c, buf.length);
                  if (stringMode)
                    ret += buf.slice(0, cpy);
                  else
                    buf.copy(ret, c, 0, cpy);
                  if (cpy < buf.length)
                    list[0] = buf.slice(cpy);
                  else
                    list.shift();
                  c += cpy;
                }
              }
            }
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            if (state.length > 0)
              throw new Error('endReadable called on non-empty stream');
            if (!state.endEmitted && state.calledRead) {
              state.ended = true;
              process.nextTick(function() {
                if (!state.endEmitted && state.length === 0) {
                  state.endEmitted = true;
                  stream.readable = false;
                  stream.emit('end');
                }
              });
            }
          }
          function forEach(xs, f) {
            for (var i = 0,
                l = xs.length; i < l; i++) {
              f(xs[i], i);
            }
          }
          function indexOf(xs, x) {
            for (var i = 0,
                l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }).call(this, require("sycGbZ"));
      }, {
        "buffer": 29,
        "core-util-is": 62,
        "events": 45,
        "inherits": 50,
        "isarray": 63,
        "stream": 69,
        "string_decoder/": 64,
        "sycGbZ": 51
      }],
      60: [function(require, module, exports) {
        module.exports = Transform;
        var Duplex = require('./_stream_duplex');
        var util = require('core-util-is');
        util.inherits = require('inherits');
        util.inherits(Transform, Duplex);
        function TransformState(options, stream) {
          this.afterTransform = function(er, data) {
            return afterTransform(stream, er, data);
          };
          this.needTransform = false;
          this.transforming = false;
          this.writecb = null;
          this.writechunk = null;
        }
        function afterTransform(stream, er, data) {
          var ts = stream._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb)
            return stream.emit('error', new Error('no writecb in Transform class'));
          ts.writechunk = null;
          ts.writecb = null;
          if (data !== null && data !== undefined)
            stream.push(data);
          if (cb)
            cb(er);
          var rs = stream._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            stream._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          var ts = this._transformState = new TransformState(options, this);
          var stream = this;
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          this.once('finish', function() {
            if ('function' === typeof this._flush)
              this._flush(function(er) {
                done(stream, er);
              });
            else
              done(stream);
          });
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error('not implemented');
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        function done(stream, er) {
          if (er)
            return stream.emit('error', er);
          var ws = stream._writableState;
          var rs = stream._readableState;
          var ts = stream._transformState;
          if (ws.length)
            throw new Error('calling transform done when ws.length != 0');
          if (ts.transforming)
            throw new Error('calling transform done when still transforming');
          return stream.push(null);
        }
      }, {
        "./_stream_duplex": 57,
        "core-util-is": 62,
        "inherits": 50
      }],
      61: [function(require, module, exports) {
        (function(process) {
          module.exports = Writable;
          var Buffer = require('buffer').Buffer;
          Writable.WritableState = WritableState;
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var Stream = require('stream');
          util.inherits(Writable, Stream);
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
          }
          function WritableState(options, stream) {
            options = options || {};
            var hwm = options.highWaterMark;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
            this.objectMode = !!options.objectMode;
            this.highWaterMark = ~~this.highWaterMark;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            this.length = 0;
            this.writing = false;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.buffer = [];
            this.errorEmitted = false;
          }
          function Writable(options) {
            var Duplex = require('./_stream_duplex');
            if (!(this instanceof Writable) && !(this instanceof Duplex))
              return new Writable(options);
            this._writableState = new WritableState(options, this);
            this.writable = true;
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            this.emit('error', new Error('Cannot pipe. Not readable.'));
          };
          function writeAfterEnd(stream, state, cb) {
            var er = new Error('write after end');
            stream.emit('error', er);
            process.nextTick(function() {
              cb(er);
            });
          }
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {
              var er = new TypeError('Invalid non-string/buffer chunk');
              stream.emit('error', er);
              process.nextTick(function() {
                cb(er);
              });
              valid = false;
            }
            return valid;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (Buffer.isBuffer(chunk))
              encoding = 'buffer';
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== 'function')
              cb = function() {};
            if (state.ended)
              writeAfterEnd(this, state, cb);
            else if (validChunk(this, state, chunk, cb))
              ret = writeOrBuffer(this, state, chunk, encoding, cb);
            return ret;
          };
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = new Buffer(chunk, encoding);
            }
            return chunk;
          }
          function writeOrBuffer(stream, state, chunk, encoding, cb) {
            chunk = decodeChunk(state, chunk, encoding);
            if (Buffer.isBuffer(chunk))
              encoding = 'buffer';
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing)
              state.buffer.push(new WriteReq(chunk, encoding, cb));
            else
              doWrite(stream, state, len, chunk, encoding, cb);
            return ret;
          }
          function doWrite(stream, state, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            if (sync)
              process.nextTick(function() {
                cb(er);
              });
            else
              cb(er);
            stream._writableState.errorEmitted = true;
            stream.emit('error', er);
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(stream, state);
              if (!finished && !state.bufferProcessing && state.buffer.length)
                clearBuffer(stream, state);
              if (sync) {
                process.nextTick(function() {
                  afterWrite(stream, state, finished, cb);
                });
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            cb();
            if (finished)
              finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit('drain');
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            for (var c = 0; c < state.buffer.length; c++) {
              var entry = state.buffer[c];
              var chunk = entry.chunk;
              var encoding = entry.encoding;
              var cb = entry.callback;
              var len = state.objectMode ? 1 : chunk.length;
              doWrite(stream, state, len, chunk, encoding, cb);
              if (state.writing) {
                c++;
                break;
              }
            }
            state.bufferProcessing = false;
            if (c < state.buffer.length)
              state.buffer = state.buffer.slice(c);
            else
              state.buffer.length = 0;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error('not implemented'));
          };
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === 'function') {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (typeof chunk !== 'undefined' && chunk !== null)
              this.write(chunk, encoding);
            if (!state.ending && !state.finished)
              endWritable(this, state, cb);
          };
          function needFinish(stream, state) {
            return (state.ending && state.length === 0 && !state.finished && !state.writing);
          }
          function finishMaybe(stream, state) {
            var need = needFinish(stream, state);
            if (need) {
              state.finished = true;
              stream.emit('finish');
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                process.nextTick(cb);
              else
                stream.once('finish', cb);
            }
            state.ended = true;
          }
        }).call(this, require("sycGbZ"));
      }, {
        "./_stream_duplex": 57,
        "buffer": 29,
        "core-util-is": 62,
        "inherits": 50,
        "stream": 69,
        "sycGbZ": 51
      }],
      62: [function(require, module, exports) {
        (function(Buffer) {
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;
          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }
          exports.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          exports.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
          }
          exports.isError = isError;
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;
          function isBuffer(arg) {
            return Buffer.isBuffer(arg);
          }
          exports.isBuffer = isBuffer;
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      63: [function(require, module, exports) {
        module.exports = Array.isArray || function(arr) {
          return Object.prototype.toString.call(arr) == '[object Array]';
        };
      }, {}],
      64: [function(require, module, exports) {
        var Buffer = require('buffer').Buffer;
        var isBufferEncoding = Buffer.isEncoding || function(encoding) {
          switch (encoding && encoding.toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
            case 'raw':
              return true;
            default:
              return false;
          }
        };
        function assertEncoding(encoding) {
          if (encoding && !isBufferEncoding(encoding)) {
            throw new Error('Unknown encoding: ' + encoding);
          }
        }
        var StringDecoder = exports.StringDecoder = function(encoding) {
          this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
          assertEncoding(encoding);
          switch (this.encoding) {
            case 'utf8':
              this.surrogateSize = 3;
              break;
            case 'ucs2':
            case 'utf16le':
              this.surrogateSize = 2;
              this.detectIncompleteChar = utf16DetectIncompleteChar;
              break;
            case 'base64':
              this.surrogateSize = 3;
              this.detectIncompleteChar = base64DetectIncompleteChar;
              break;
            default:
              this.write = passThroughWrite;
              return;
          }
          this.charBuffer = new Buffer(6);
          this.charReceived = 0;
          this.charLength = 0;
        };
        StringDecoder.prototype.write = function(buffer) {
          var charStr = '';
          var offset = 0;
          while (this.charLength) {
            var i = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length;
            buffer.copy(this.charBuffer, this.charReceived, offset, i);
            this.charReceived += (i - offset);
            offset = i;
            if (this.charReceived < this.charLength) {
              return '';
            }
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 0xD800 && charCode <= 0xDBFF) {
              this.charLength += this.surrogateSize;
              charStr = '';
              continue;
            }
            this.charReceived = this.charLength = 0;
            if (i == buffer.length)
              return charStr;
            buffer = buffer.slice(i, buffer.length);
            break;
          }
          var lenIncomplete = this.detectIncompleteChar(buffer);
          var end = buffer.length;
          if (this.charLength) {
            buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
            this.charReceived = lenIncomplete;
            end -= lenIncomplete;
          }
          charStr += buffer.toString(this.encoding, 0, end);
          var end = charStr.length - 1;
          var charCode = charStr.charCodeAt(end);
          if (charCode >= 0xD800 && charCode <= 0xDBFF) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
            return charStr.substring(0, end);
          }
          return charStr;
        };
        StringDecoder.prototype.detectIncompleteChar = function(buffer) {
          var i = (buffer.length >= 3) ? 3 : buffer.length;
          for (; i > 0; i--) {
            var c = buffer[buffer.length - i];
            if (i == 1 && c >> 5 == 0x06) {
              this.charLength = 2;
              break;
            }
            if (i <= 2 && c >> 4 == 0x0E) {
              this.charLength = 3;
              break;
            }
            if (i <= 3 && c >> 3 == 0x1E) {
              this.charLength = 4;
              break;
            }
          }
          return i;
        };
        StringDecoder.prototype.end = function(buffer) {
          var res = '';
          if (buffer && buffer.length)
            res = this.write(buffer);
          if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
          }
          return res;
        };
        function passThroughWrite(buffer) {
          return buffer.toString(this.encoding);
        }
        function utf16DetectIncompleteChar(buffer) {
          var incomplete = this.charReceived = buffer.length % 2;
          this.charLength = incomplete ? 2 : 0;
          return incomplete;
        }
        function base64DetectIncompleteChar(buffer) {
          var incomplete = this.charReceived = buffer.length % 3;
          this.charLength = incomplete ? 3 : 0;
          return incomplete;
        }
      }, {"buffer": 29}],
      65: [function(require, module, exports) {
        module.exports = require("./lib/_stream_passthrough.js");
      }, {"./lib/_stream_passthrough.js": 58}],
      66: [function(require, module, exports) {
        exports = module.exports = require('./lib/_stream_readable.js');
        exports.Readable = exports;
        exports.Writable = require('./lib/_stream_writable.js');
        exports.Duplex = require('./lib/_stream_duplex.js');
        exports.Transform = require('./lib/_stream_transform.js');
        exports.PassThrough = require('./lib/_stream_passthrough.js');
      }, {
        "./lib/_stream_duplex.js": 57,
        "./lib/_stream_passthrough.js": 58,
        "./lib/_stream_readable.js": 59,
        "./lib/_stream_transform.js": 60,
        "./lib/_stream_writable.js": 61
      }],
      67: [function(require, module, exports) {
        module.exports = require("./lib/_stream_transform.js");
      }, {"./lib/_stream_transform.js": 60}],
      68: [function(require, module, exports) {
        module.exports = require("./lib/_stream_writable.js");
      }, {"./lib/_stream_writable.js": 61}],
      69: [function(require, module, exports) {
        module.exports = Stream;
        var EE = require('events').EventEmitter;
        var inherits = require('inherits');
        inherits(Stream, EE);
        Stream.Readable = require('readable-stream/readable.js');
        Stream.Writable = require('readable-stream/writable.js');
        Stream.Duplex = require('readable-stream/duplex.js');
        Stream.Transform = require('readable-stream/transform.js');
        Stream.PassThrough = require('readable-stream/passthrough.js');
        Stream.Stream = Stream;
        function Stream() {
          EE.call(this);
        }
        Stream.prototype.pipe = function(dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on('data', ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on('drain', ondrain);
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on('end', onend);
            source.on('close', onclose);
          }
          var didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === 'function')
              dest.destroy();
          }
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, 'error') === 0) {
              throw er;
            }
          }
          source.on('error', onerror);
          dest.on('error', onerror);
          function cleanup() {
            source.removeListener('data', ondata);
            dest.removeListener('drain', ondrain);
            source.removeListener('end', onend);
            source.removeListener('close', onclose);
            source.removeListener('error', onerror);
            dest.removeListener('error', onerror);
            source.removeListener('end', cleanup);
            source.removeListener('close', cleanup);
            dest.removeListener('close', cleanup);
          }
          source.on('end', cleanup);
          source.on('close', cleanup);
          dest.on('close', cleanup);
          dest.emit('pipe', source);
          return dest;
        };
      }, {
        "events": 45,
        "inherits": 50,
        "readable-stream/duplex.js": 56,
        "readable-stream/passthrough.js": 65,
        "readable-stream/readable.js": 66,
        "readable-stream/transform.js": 67,
        "readable-stream/writable.js": 68
      }],
      70: [function(require, module, exports) {
        var punycode = require('punycode');
        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;
        exports.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/,
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
            unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
            autoEscape = ['\''].concat(unwise),
            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
            hostEndingChars = ['/', '?', '#'],
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
            unsafeProtocol = {
              'javascript': true,
              'javascript:': true
            },
            hostlessProtocol = {
              'javascript': true,
              'javascript:': true
            },
            slashedProtocol = {
              'http': true,
              'https': true,
              'ftp': true,
              'gopher': true,
              'file': true,
              'http:': true,
              'https:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true
            },
            querystring = require('querystring');
        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && isObject(url) && url instanceof Url)
            return url;
          var u = new Url;
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
          if (!isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
          }
          var rest = url;
          rest = rest.trim();
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            var auth,
                atSign;
            if (hostEnd === -1) {
              atSign = rest.lastIndexOf('@');
            } else {
              atSign = rest.lastIndexOf('@', hostEnd);
            }
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            if (hostEnd === -1)
              hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            this.parseHost();
            this.hostname = this.hostname || '';
            var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0,
                  l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part)
                  continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = '';
                  for (var j = 0,
                      k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      newpart += 'x';
                    } else {
                      newpart += part[j];
                    }
                  }
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = '/' + notHost.join('.') + rest;
                    }
                    this.hostname = validParts.join('.');
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = '';
            } else {
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              var domainArray = this.hostname.split('.');
              var newOut = [];
              for (var i = 0; i < domainArray.length; ++i) {
                var s = domainArray[i];
                newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
              }
              this.hostname = newOut.join('.');
            }
            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== '/') {
                rest = '/' + rest;
              }
            }
          }
          if (!unsafeProtocol[lowerProto]) {
            for (var i = 0,
                l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }
          var hash = rest.indexOf('#');
          if (hash !== -1) {
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf('?');
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            this.search = '';
            this.query = {};
          }
          if (rest)
            this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = '/';
          }
          if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
          }
          this.href = this.format();
          return this;
        };
        function urlFormat(obj) {
          if (isString(obj))
            obj = urlParse(obj);
          if (!(obj instanceof Url))
            return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function() {
          var auth = this.auth || '';
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
          }
          var protocol = this.protocol || '',
              pathname = this.pathname || '',
              hash = this.hash || '',
              host = false,
              query = '';
          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
            if (this.port) {
              host += ':' + this.port;
            }
          }
          if (this.query && isObject(this.query) && Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }
          var search = this.search || (query && ('?' + query)) || '';
          if (protocol && protocol.substr(-1) !== ':')
            protocol += ':';
          if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/')
              pathname = '/' + pathname;
          } else if (!host) {
            host = '';
          }
          if (hash && hash.charAt(0) !== '#')
            hash = '#' + hash;
          if (search && search.charAt(0) !== '?')
            search = '?' + search;
          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match);
          });
          search = search.replace('#', '%23');
          return protocol + host + pathname + search + hash;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source)
            return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
          if (isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          Object.keys(this).forEach(function(k) {
            result[k] = this[k];
          }, this);
          result.hash = relative.hash;
          if (relative.href === '') {
            result.href = result.format();
            return result;
          }
          if (relative.slashes && !relative.protocol) {
            Object.keys(relative).forEach(function(k) {
              if (k !== 'protocol')
                result[k] = relative[k];
            });
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = '/';
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol[relative.protocol]) {
              Object.keys(relative).forEach(function(k) {
                result[k] = relative[k];
              });
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || '').split('/');
              while (relPath.length && !(relative.host = relPath.shift()))
                ;
              if (!relative.host)
                relative.host = '';
              if (!relative.hostname)
                relative.hostname = '';
              if (relPath[0] !== '')
                relPath.unshift('');
              if (relPath.length < 2)
                relPath.unshift('');
              result.pathname = relPath.join('/');
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
              var p = result.pathname || '';
              var s = result.search || '';
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
              isRelAbs = (relative.host || relative.pathname && relative.pathname.charAt(0) === '/'),
              mustEndAbs = (isRelAbs || isSourceAbs || (result.host && relative.pathname)),
              removeAllDots = mustEndAbs,
              srcPath = result.pathname && result.pathname.split('/') || [],
              relPath = relative.pathname && relative.pathname.split('/') || [],
              psychotic = result.protocol && !slashedProtocol[result.protocol];
          if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
              if (srcPath[0] === '')
                srcPath[0] = result.host;
              else
                srcPath.unshift(result.host);
            }
            result.host = '';
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === '')
                  relPath[0] = relative.host;
                else
                  relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
          }
          if (isRelAbs) {
            result.host = (relative.host || relative.host === '') ? relative.host : result.host;
            result.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
          } else if (relPath.length) {
            if (!srcPath)
              srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!isNullOrUndefined(relative.search)) {
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (!isNull(result.pathname) || !isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
              result.path = '/' + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = ((result.host || relative.host) && (last === '.' || last === '..') || last === '');
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last == '.') {
              srcPath.splice(i, 1);
            } else if (last === '..') {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift('..');
            }
          }
          if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
          }
          if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
            srcPath.push('');
          }
          var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || (result.host && srcPath.length);
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join('/');
          }
          if (!isNull(result.pathname) || !isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function() {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ':') {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host)
            this.hostname = host;
        };
        function isString(arg) {
          return typeof arg === "string";
        }
        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        function isNull(arg) {
          return arg === null;
        }
        function isNullOrUndefined(arg) {
          return arg == null;
        }
      }, {
        "punycode": 52,
        "querystring": 55
      }],
      71: [function(require, module, exports) {
        module.exports = function isBuffer(arg) {
          return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
        };
      }, {}],
      72: [function(require, module, exports) {
        (function(process, global) {
          var formatRegExp = /%[sdj%]/g;
          exports.format = function(f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(' ');
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
              if (x === '%%')
                return '%';
              if (i >= len)
                return x;
              switch (x) {
                case '%s':
                  return String(args[i++]);
                case '%d':
                  return Number(args[i++]);
                case '%j':
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return '[Circular]';
                  }
                default:
                  return x;
              }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }
            return str;
          };
          exports.deprecate = function(fn, msg) {
            if (isUndefined(global.process)) {
              return function() {
                return exports.deprecate(fn, msg).apply(this, arguments);
              };
            }
            if (process.noDeprecation === true) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          };
          var debugs = {};
          var debugEnviron;
          exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
              debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                var pid = process.pid;
                debugs[set] = function() {
                  var msg = exports.format.apply(exports, arguments);
                  console.error('%s %d: %s', set, pid, msg);
                };
              } else {
                debugs[set] = function() {};
              }
            }
            return debugs[set];
          };
          function inspect(obj, opts) {
            var ctx = {
              seen: [],
              stylize: stylizeNoColor
            };
            if (arguments.length >= 3)
              ctx.depth = arguments[2];
            if (arguments.length >= 4)
              ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              ctx.showHidden = opts;
            } else if (opts) {
              exports._extend(ctx, opts);
            }
            if (isUndefined(ctx.showHidden))
              ctx.showHidden = false;
            if (isUndefined(ctx.depth))
              ctx.depth = 2;
            if (isUndefined(ctx.colors))
              ctx.colors = false;
            if (isUndefined(ctx.customInspect))
              ctx.customInspect = true;
            if (ctx.colors)
              ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports.inspect = inspect;
          inspect.colors = {
            'bold': [1, 22],
            'italic': [3, 23],
            'underline': [4, 24],
            'inverse': [7, 27],
            'white': [37, 39],
            'grey': [90, 39],
            'black': [30, 39],
            'blue': [34, 39],
            'cyan': [36, 39],
            'green': [32, 39],
            'magenta': [35, 39],
            'red': [31, 39],
            'yellow': [33, 39]
          };
          inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            'regexp': 'red'
          };
          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) {
              return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
              return str;
            }
          }
          function stylizeNoColor(str, styleType) {
            return str;
          }
          function arrayToHash(array) {
            var hash = {};
            array.forEach(function(val, idx) {
              hash[val] = true;
            });
            return hash;
          }
          function formatValue(ctx, value, recurseTimes) {
            if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }
            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
              return formatError(value);
            }
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }
              if (isError(value)) {
                return formatError(value);
              }
            }
            var base = '',
                array = false,
                braces = ['{', '}'];
            if (isArray(value)) {
              array = true;
              braces = ['[', ']'];
            }
            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            }
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            }
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            }
            if (isError(value)) {
              base = ' ' + formatError(value);
            }
            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }
          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
              return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
              return ctx.stylize('' + value, 'boolean');
            if (isNull(value))
              return ctx.stylize('null', 'null');
          }
          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0,
                l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push('');
              }
            }
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name,
                str,
                desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function(line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function(line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify('' + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, 'string');
              }
            }
            return name + ': ' + str;
          }
          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
              numLinesEst++;
              if (cur.indexOf('\n') >= 0)
                numLinesEst++;
              return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);
            if (length > 60) {
              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
            }
            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          }
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;
          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }
          exports.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          exports.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
          }
          exports.isError = isError;
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;
          exports.isBuffer = require('./support/isBuffer');
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }
          var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
          }
          exports.log = function() {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
          };
          exports.inherits = require('inherits');
          exports._extend = function(origin, add) {
            if (!add || !isObject(add))
              return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
        }).call(this, require("sycGbZ"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {
        "./support/isBuffer": 71,
        "inherits": 50,
        "sycGbZ": 51
      }]
    }, {}, [1]);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:angular-toastr@1.3.1/dist/angular-toastr.tpls.js", ["github:angular/bower-angular@1.4.1.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function() {
      'use strict';
      angular.module('toastr', []).factory('toastr', toastr);
      toastr.$inject = ['$animate', '$injector', '$document', '$rootScope', '$sce', 'toastrConfig', '$q'];
      function toastr($animate, $injector, $document, $rootScope, $sce, toastrConfig, $q) {
        var container;
        var index = 0;
        var toasts = [];
        var previousToastMessage = '';
        var containerDefer = $q.defer();
        var toast = {
          clear: clear,
          error: error,
          info: info,
          remove: remove,
          success: success,
          warning: warning
        };
        return toast;
        function clear(toast) {
          if (toast) {
            remove(toast.toastId);
          } else {
            for (var i = 0; i < toasts.length; i++) {
              remove(toasts[i].toastId);
            }
          }
        }
        function error(message, title, optionsOverride) {
          var type = _getOptions().iconClasses.error;
          return _buildNotification(type, message, title, optionsOverride);
        }
        function info(message, title, optionsOverride) {
          var type = _getOptions().iconClasses.info;
          return _buildNotification(type, message, title, optionsOverride);
        }
        function success(message, title, optionsOverride) {
          var type = _getOptions().iconClasses.success;
          return _buildNotification(type, message, title, optionsOverride);
        }
        function warning(message, title, optionsOverride) {
          var type = _getOptions().iconClasses.warning;
          return _buildNotification(type, message, title, optionsOverride);
        }
        function remove(toastId, wasClicked) {
          var toast = findToast(toastId);
          if (toast && !toast.deleting) {
            toast.deleting = true;
            toast.isOpened = false;
            $animate.leave(toast.el).then(function() {
              if (toast.scope.options.onHidden) {
                toast.scope.options.onHidden(wasClicked);
              }
              toast.scope.$destroy();
              var index = toasts.indexOf(toast);
              toasts.splice(index, 1);
              var maxOpened = toastrConfig.maxOpened;
              if (maxOpened && toasts.length >= maxOpened) {
                toasts[maxOpened - 1].open.resolve();
              }
              if (lastToast()) {
                container.remove();
                container = null;
                containerDefer = $q.defer();
              }
            });
          }
          function findToast(toastId) {
            for (var i = 0; i < toasts.length; i++) {
              if (toasts[i].toastId === toastId) {
                return toasts[i];
              }
            }
          }
          function lastToast() {
            return !toasts.length;
          }
        }
        function _buildNotification(type, message, title, optionsOverride) {
          if (angular.isObject(title)) {
            optionsOverride = title;
            title = null;
          }
          return _notify({
            iconClass: type,
            message: message,
            optionsOverride: optionsOverride,
            title: title
          });
        }
        function _getOptions() {
          return angular.extend({}, toastrConfig);
        }
        function _createOrGetContainer(options) {
          if (container) {
            return containerDefer.promise;
          }
          container = angular.element('<div></div>');
          container.attr('id', options.containerId);
          container.addClass(options.positionClass);
          container.css({'pointer-events': 'auto'});
          var target = angular.element(document.querySelector(options.target));
          if (!target || !target.length) {
            throw 'Target for toasts doesn\'t exist';
          }
          $animate.enter(container, target).then(function() {
            containerDefer.resolve();
          });
          return containerDefer.promise;
        }
        function _notify(map) {
          var options = _getOptions();
          if (shouldExit()) {
            return;
          }
          var newToast = createToast();
          toasts.push(newToast);
          if (options.autoDismiss && options.maxOpened > 0) {
            var oldToasts = toasts.slice(0, (toasts.length - options.maxOpened));
            for (var i = 0,
                len = oldToasts.length; i < len; i++) {
              remove(oldToasts[i].toastId);
            }
          }
          if (maxOpenedNotReached()) {
            newToast.open.resolve();
          }
          newToast.open.promise.then(function() {
            _createOrGetContainer(options).then(function() {
              newToast.isOpened = true;
              if (options.newestOnTop) {
                $animate.enter(newToast.el, container).then(function() {
                  newToast.scope.init();
                });
              } else {
                var sibling = container[0].lastChild ? angular.element(container[0].lastChild) : null;
                $animate.enter(newToast.el, container, sibling).then(function() {
                  newToast.scope.init();
                });
              }
            });
          });
          return newToast;
          function createScope(toast, map, options) {
            if (options.allowHtml) {
              toast.scope.allowHtml = true;
              toast.scope.title = $sce.trustAsHtml(map.title);
              toast.scope.message = $sce.trustAsHtml(map.message);
            } else {
              toast.scope.title = map.title;
              toast.scope.message = map.message;
            }
            toast.scope.toastType = toast.iconClass;
            toast.scope.toastId = toast.toastId;
            toast.scope.options = {
              extendedTimeOut: options.extendedTimeOut,
              messageClass: options.messageClass,
              onHidden: options.onHidden,
              onShown: options.onShown,
              progressBar: options.progressBar,
              tapToDismiss: options.tapToDismiss,
              timeOut: options.timeOut,
              titleClass: options.titleClass,
              toastClass: options.toastClass
            };
            if (options.closeButton) {
              toast.scope.options.closeHtml = options.closeHtml;
            }
          }
          function createToast() {
            var newToast = {
              toastId: index++,
              isOpened: false,
              scope: $rootScope.$new(),
              open: $q.defer()
            };
            newToast.iconClass = map.iconClass;
            if (map.optionsOverride) {
              options = angular.extend(options, cleanOptionsOverride(map.optionsOverride));
              newToast.iconClass = map.optionsOverride.iconClass || newToast.iconClass;
            }
            createScope(newToast, map, options);
            newToast.el = createToastEl(newToast.scope);
            return newToast;
            function cleanOptionsOverride(options) {
              var badOptions = ['containerId', 'iconClasses', 'maxOpened', 'newestOnTop', 'positionClass', 'preventDuplicates', 'templates'];
              for (var i = 0,
                  l = badOptions.length; i < l; i++) {
                delete options[badOptions[i]];
              }
              return options;
            }
          }
          function createToastEl(scope) {
            var angularDomEl = angular.element('<div toast></div>'),
                $compile = $injector.get('$compile');
            return $compile(angularDomEl)(scope);
          }
          function maxOpenedNotReached() {
            return options.maxOpened && toasts.length <= options.maxOpened || !options.maxOpened;
          }
          function shouldExit() {
            if (options.preventDuplicates) {
              if (map.message === previousToastMessage) {
                return true;
              } else {
                previousToastMessage = map.message;
              }
              return false;
            }
          }
        }
      }
    }());
    (function() {
      'use strict';
      angular.module('toastr').constant('toastrConfig', {
        allowHtml: false,
        autoDismiss: false,
        closeButton: false,
        closeHtml: '<button>&times;</button>',
        containerId: 'toast-container',
        extendedTimeOut: 1000,
        iconClasses: {
          error: 'toast-error',
          info: 'toast-info',
          success: 'toast-success',
          warning: 'toast-warning'
        },
        maxOpened: 0,
        messageClass: 'toast-message',
        newestOnTop: true,
        onHidden: null,
        onShown: null,
        positionClass: 'toast-top-right',
        preventDuplicates: false,
        progressBar: false,
        tapToDismiss: true,
        target: 'body',
        templates: {
          toast: 'directives/toast/toast.html',
          progressbar: 'directives/progressbar/progressbar.html'
        },
        timeOut: 5000,
        titleClass: 'toast-title',
        toastClass: 'toast'
      });
    }());
    (function() {
      'use strict';
      angular.module('toastr').directive('progressBar', progressBar);
      progressBar.$inject = ['toastrConfig'];
      function progressBar(toastrConfig) {
        return {
          replace: true,
          require: '^toast',
          templateUrl: function() {
            return toastrConfig.templates.progressbar;
          },
          link: linkFunction
        };
        function linkFunction(scope, element, attrs, toastCtrl) {
          var intervalId,
              currentTimeOut,
              hideTime;
          toastCtrl.progressBar = scope;
          scope.start = function(duration) {
            if (intervalId) {
              clearInterval(intervalId);
            }
            currentTimeOut = parseFloat(duration);
            hideTime = new Date().getTime() + currentTimeOut;
            intervalId = setInterval(updateProgress, 10);
          };
          scope.stop = function() {
            if (intervalId) {
              clearInterval(intervalId);
            }
          };
          function updateProgress() {
            var percentage = ((hideTime - (new Date().getTime())) / currentTimeOut) * 100;
            element.css('width', percentage + '%');
          }
          scope.$on('$destroy', function() {
            clearInterval(intervalId);
          });
        }
      }
    }());
    (function() {
      'use strict';
      angular.module('toastr').controller('ToastController', ToastController);
      function ToastController() {
        this.progressBar = null;
        this.startProgressBar = function(duration) {
          if (this.progressBar) {
            this.progressBar.start(duration);
          }
        };
        this.stopProgressBar = function() {
          if (this.progressBar) {
            this.progressBar.stop();
          }
        };
      }
    }());
    (function() {
      'use strict';
      angular.module('toastr').directive('toast', toast);
      toast.$inject = ['$injector', '$interval', 'toastrConfig', 'toastr'];
      function toast($injector, $interval, toastrConfig, toastr) {
        return {
          replace: true,
          templateUrl: function() {
            return toastrConfig.templates.toast;
          },
          controller: 'ToastController',
          link: toastLinkFunction
        };
        function toastLinkFunction(scope, element, attrs, toastCtrl) {
          var timeout;
          scope.toastClass = scope.options.toastClass;
          scope.titleClass = scope.options.titleClass;
          scope.messageClass = scope.options.messageClass;
          scope.progressBar = scope.options.progressBar;
          if (wantsCloseButton()) {
            var button = angular.element(scope.options.closeHtml),
                $compile = $injector.get('$compile');
            button.addClass('toast-close-button');
            button.attr('ng-click', 'close()');
            $compile(button)(scope);
            element.prepend(button);
          }
          scope.init = function() {
            if (scope.options.timeOut) {
              timeout = createTimeout(scope.options.timeOut);
            }
            if (scope.options.onShown) {
              scope.options.onShown();
            }
          };
          element.on('mouseenter', function() {
            hideAndStopProgressBar();
            if (timeout) {
              $interval.cancel(timeout);
            }
          });
          scope.tapToast = function() {
            if (scope.options.tapToDismiss) {
              scope.close(true);
            }
          };
          scope.close = function(wasClicked) {
            toastr.remove(scope.toastId, wasClicked);
          };
          element.on('mouseleave', function() {
            if (scope.options.timeOut === 0 && scope.options.extendedTimeOut === 0) {
              return;
            }
            scope.$apply(function() {
              scope.progressBar = scope.options.progressBar;
            });
            timeout = createTimeout(scope.options.extendedTimeOut);
          });
          function createTimeout(time) {
            toastCtrl.startProgressBar(time);
            return $interval(function() {
              toastCtrl.stopProgressBar();
              toastr.remove(scope.toastId);
            }, time, 1);
          }
          function hideAndStopProgressBar() {
            scope.progressBar = false;
            toastCtrl.stopProgressBar();
          }
          function wantsCloseButton() {
            return scope.options.closeHtml;
          }
        }
      }
    }());
    angular.module("toastr").run(["$templateCache", function($templateCache) {
      $templateCache.put("directives/progressbar/progressbar.html", "<div class=\"toast-progress\"></div>\n");
      $templateCache.put("directives/toast/toast.html", "<div class=\"{{toastClass}} {{toastType}}\" ng-click=\"tapToast()\">\n  <div ng-switch on=\"allowHtml\">\n    <div ng-switch-default ng-if=\"title\" class=\"{{titleClass}}\">{{title}}</div>\n    <div ng-switch-default class=\"{{messageClass}}\">{{message}}</div>\n    <div ng-switch-when=\"true\" ng-if=\"title\" class=\"{{titleClass}}\" ng-bind-html=\"title\"></div>\n    <div ng-switch-when=\"true\" class=\"{{messageClass}}\" ng-bind-html=\"message\"></div>\n  </div>\n  <progress-bar ng-if=\"progressBar\"></progress-bar>\n</div>\n");
    }]);
  })();
  return _retrieveGlobal();
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var util = forge.util = forge.util || {};
    (function() {
      if (typeof process !== 'undefined' && process.nextTick) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === 'function') {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === 'function') {
        util.setImmediate = setImmediate;
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== 'undefined' && typeof window.postMessage === 'function') {
        var msg = 'forge.setImmediate';
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, '*');
          }
        };
        function handler(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        }
        window.addEventListener('message', handler, true);
      }
      if (typeof MutationObserver !== 'undefined') {
        var now = Date.now();
        var attr = true;
        var div = document.createElement('div');
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, {attributes: true});
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute('a', attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === '[object Array]';
    };
    util.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x) {
      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
    };
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = '';
      this.read = 0;
      if (typeof b === 'string') {
        this.data = b;
      } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
        var arr = new Uint8Array(b);
        try {
          this.data = String.fromCharCode.apply(null, arr);
        } catch (e) {
          for (var i = 0; i < arr.length; ++i) {
            this.putByte(arr[i]);
          }
        }
      } else if (b instanceof ByteStringBuffer || (typeof b === 'object' && typeof b.data === 'string' && typeof b.read === 'number')) {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt = function(i, n) {
      var bytes = '';
      do {
        n -= 8;
        bytes += String.fromCharCode((i >> n) & 0xFF);
      } while (n > 0);
      return this.putBytes(bytes);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << (n - 1);
      }
      return this.putInt(i, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = (this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1));
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = (this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2));
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = (this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3));
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = (this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = (this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = (this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << (n - 2);
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = '';
      } else {
        rval = (this.read === 0) ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return (typeof(count) === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count));
    };
    util.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util.ByteStringBuffer.prototype.setAt = function(i, b) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = '';
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = '';
      for (var i = this.read; i < this.data.length; ++i) {
        var b = this.data.charCodeAt(i);
        if (b < 16) {
          rval += '0';
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b);
      var isArrayBufferView = util.isArrayBufferView(b);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = ('writeOffset' in options ? options.writeOffset : this.data.byteLength);
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== undefined) {
        this.putBytes(b);
      }
      if ('writeOffset' in options) {
        this.write = options.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util.isArrayBufferView(bytes)) {
        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes)) {
        var src = new Uint8Array(bytes);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.DataBuffer || (typeof bytes === 'object' && typeof bytes.read === 'number' && typeof bytes.write === 'number' && util.isArrayBufferView(bytes.data))) {
        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = 'binary';
      }
      encoding = encoding || 'binary';
      if (typeof bytes === 'string') {
        var view;
        if (encoding === 'hex') {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === 'base64') {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === 'utf8') {
          bytes = util.encodeUtf8(bytes);
          encoding = 'binary';
        }
        if (encoding === 'binary' || encoding === 'raw') {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === 'utf16') {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error('Invalid encoding: ' + encoding);
      }
      throw Error('Invalid parameter: ' + bytes);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, 'utf16');
    };
    util.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 0xFFFF);
      this.data.setInt8(this.write, i >> 16 & 0xFF);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 0xFF);
      this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i, n) {
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, (i >> n) & 0xFF);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i, n) {
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << (n - 1);
      }
      return this.putInt(i, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = (this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2));
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = (this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << (n - 2);
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = '';
      } else {
        rval = (this.read === 0) ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return (typeof(count) === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count));
    };
    util.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util.DataBuffer.prototype.setAt = function(i, b) {
      this.data.setUint8(i, b);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = '';
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b = this.data.getUint8(i);
        if (b < 16) {
          rval += '0';
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || 'utf8';
      if (encoding === 'binary' || encoding === 'raw') {
        return util.binary.raw.encode(view);
      }
      if (encoding === 'hex') {
        return util.binary.hex.encode(view);
      }
      if (encoding === 'base64') {
        return util.binary.base64.encode(view);
      }
      if (encoding === 'utf8') {
        return util.text.utf8.decode(view);
      }
      if (encoding === 'utf16') {
        return util.text.utf16.decode(view);
      }
      throw new Error('Invalid encoding: ' + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || 'raw';
      if (input !== undefined && encoding === 'utf8') {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n) {
      var s = '';
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = '';
      var b = '';
      var t = '';
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = '';
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = '';
      var i = 0;
      if (hex.length & 1 == 1) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes) {
      return util.createBuffer(bytes).toHex();
    };
    util.int32ToBytes = function(i) {
      return (String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
    };
    var _base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var _base64Idx = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
    util.encode64 = function(input, maxline) {
      var line = '';
      var output = '';
      var chr1,
          chr2,
          chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
        if (isNaN(chr2)) {
          line += '==';
        } else {
          line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
          line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + '\r\n';
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
      var output = '';
      var enc1,
          enc2,
          enc3,
          enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));
        if (enc3 !== 64) {
          output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));
          if (enc4 !== 64) {
            output += String.fromCharCode(((enc3 & 3) << 6) | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {}
    };
    util.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? (j - offset) : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0,
          j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output ? (j - offset) : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = '';
      var output = '';
      var chr1,
          chr2,
          chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
        if (isNaN(chr2)) {
          line += '==';
        } else {
          line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
          line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + '\r\n';
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
      offset = offset || 0;
      var enc1,
          enc2,
          enc3,
          enc4;
      var i = 0,
          j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = (enc1 << 2) | (enc2 >> 4);
        if (enc3 !== 64) {
          out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);
          if (enc4 !== 64) {
            out[j++] = ((enc3 & 3) << 6) | enc4;
          }
        }
      }
      return output ? (j - offset) : out.subarray(0, j);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? (j - offset) : out;
    };
    util.text.utf8.decode = function(bytes) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      var view = new Uint16Array(out);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output ? (j - offset) : out;
    };
    util.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes));
    };
    util.deflate = function(api, bytes, raw) {
      bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 0x20) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util.encode64(bytes)).rval;
      return (rval === null) ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error('WebStorage not available.');
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof(rval) !== 'undefined' && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error('WebStorage not available.');
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = (key in rval) ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty = true;
        for (var prop in obj) {
          empty = false;
          break;
        }
        if (empty) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof(location) === 'undefined') {
        location = ['web', 'flash'];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === 'flash' || type === 'both') {
            if (args[0] === null) {
              throw new Error('Flash local storage not available.');
            }
            rval = func.apply(this, args);
            done = (type === 'flash');
          }
          if (type === 'web' || type === 'both') {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util.getItem = function(api, id, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util.removeItem = function(api, id, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util.clearItems = function(api, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util.parseUrl = function(str) {
      var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
      regex.lastIndex = 0;
      var m = regex.exec(str);
      var url = (m === null) ? null : {
        full: str,
        scheme: m[1],
        host: m[2],
        port: m[3],
        path: m[4]
      };
      if (url) {
        url.fullHost = url.host;
        if (url.port) {
          if (url.port !== 80 && url.scheme === 'http') {
            url.fullHost += ':' + url.port;
          } else if (url.port !== 443 && url.scheme === 'https') {
            url.fullHost += ':' + url.port;
          }
        } else if (url.scheme === 'http') {
          url.port = 80;
        } else if (url.scheme === 'https') {
          url.port = 443;
        }
        url.full = url.scheme + '://' + url.fullHost;
      }
      return url;
    };
    var _queryVariables = null;
    util.getQueryVariables = function(query) {
      var parse = function(q) {
        var rval = {};
        var kvpairs = q.split('&');
        for (var i = 0; i < kvpairs.length; i++) {
          var pos = kvpairs[i].indexOf('=');
          var key;
          var val;
          if (pos > 0) {
            key = kvpairs[i].substring(0, pos);
            val = kvpairs[i].substring(pos + 1);
          } else {
            key = kvpairs[i];
            val = null;
          }
          if (!(key in rval)) {
            rval[key] = [];
          }
          if (!(key in Object.prototype) && val !== null) {
            rval[key].push(unescape(val));
          }
        }
        return rval;
      };
      var rval;
      if (typeof(query) === 'undefined') {
        if (_queryVariables === null) {
          if (typeof(window) !== 'undefined' && window.location && window.location.search) {
            _queryVariables = parse(window.location.search.substring(1));
          } else {
            _queryVariables = {};
          }
        }
        rval = _queryVariables;
      } else {
        rval = parse(query);
      }
      return rval;
    };
    util.parseFragment = function(fragment) {
      var fp = fragment;
      var fq = '';
      var pos = fragment.indexOf('?');
      if (pos > 0) {
        fp = fragment.substring(0, pos);
        fq = fragment.substring(pos + 1);
      }
      var path = fp.split('/');
      if (path.length > 0 && path[0] === '') {
        path.shift();
      }
      var query = (fq === '') ? {} : util.getQueryVariables(fq);
      return {
        pathString: fp,
        queryString: fq,
        path: path,
        query: query
      };
    };
    util.makeRequest = function(reqString) {
      var frag = util.parseFragment(reqString);
      var req = {
        path: frag.pathString,
        query: frag.queryString,
        getPath: function(i) {
          return (typeof(i) === 'undefined') ? frag.path : frag.path[i];
        },
        getQuery: function(k, i) {
          var rval;
          if (typeof(k) === 'undefined') {
            rval = frag.query;
          } else {
            rval = frag.query[k];
            if (rval && typeof(i) !== 'undefined') {
              rval = rval[i];
            }
          }
          return rval;
        },
        getQueryLast: function(k, _default) {
          var rval;
          var vals = req.getQuery(k);
          if (vals) {
            rval = vals[vals.length - 1];
          } else {
            rval = _default;
          }
          return rval;
        }
      };
      return req;
    };
    util.makeLink = function(path, query, fragment) {
      path = jQuery.isArray(path) ? path.join('/') : path;
      var qstr = jQuery.param(query || {});
      fragment = fragment || '';
      return path + ((qstr.length > 0) ? ('?' + qstr) : '') + ((fragment.length > 0) ? ('#' + fragment) : '');
    };
    util.setPath = function(object, keys, value) {
      if (typeof(object) === 'object' && object !== null) {
        var i = 0;
        var len = keys.length;
        while (i < len) {
          var next = keys[i++];
          if (i == len) {
            object[next] = value;
          } else {
            var hasNext = (next in object);
            if (!hasNext || (hasNext && typeof(object[next]) !== 'object') || (hasNext && object[next] === null)) {
              object[next] = {};
            }
            object = object[next];
          }
        }
      }
    };
    util.getPath = function(object, keys, _default) {
      var i = 0;
      var len = keys.length;
      var hasNext = true;
      while (hasNext && i < len && typeof(object) === 'object' && object !== null) {
        var next = keys[i++];
        hasNext = next in object;
        if (hasNext) {
          object = object[next];
        }
      }
      return (hasNext ? object : _default);
    };
    util.deletePath = function(object, keys) {
      if (typeof(object) === 'object' && object !== null) {
        var i = 0;
        var len = keys.length;
        while (i < len) {
          var next = keys[i++];
          if (i == len) {
            delete object[next];
          } else {
            if (!(next in object) || (typeof(object[next]) !== 'object') || (object[next] === null)) {
              break;
            }
            object = object[next];
          }
        }
      }
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while ((match = re.exec(format))) {
        part = format.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code = match[0][1];
        switch (code) {
          case 's':
          case 'o':
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push('<?>');
            }
            break;
          case '%':
            parts.push('%');
            break;
          default:
            parts.push('<%' + code + '?>');
        }
      }
      parts.push(format.substring(last));
      return parts.join('');
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number,
          c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === undefined ? ',' : dec_point;
      var t = thousands_sep === undefined ? '.' : thousands_sep,
          s = n < 0 ? '-' : '';
      var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';
      var j = (i.length > 3) ? i.length % 3 : 0;
      return s + (j ? i.substr(0, j) + t : '') + i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + ' KiB';
      } else {
        size = util.formatNumber(size, 0) + ' bytes';
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf('.') !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(':') !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split('.');
      if (ip.length !== 4) {
        return null;
      }
      var b = util.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(':').filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util.hexToBytes(ip[i]);
        if (bytes.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes);
      }
      return b.getBytes();
    };
    util.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util.bytesToIPv6(bytes);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes.length; ++i) {
        ip.push(bytes.charCodeAt(i));
      }
      return ip.join('.');
    };
    util.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes.length; i += 2) {
        var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
        while (hex[0] === '0' && hex !== '0') {
          hex = hex.substr(1);
        }
        if (hex === '0') {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({
              start: idx,
              end: idx
            });
          } else {
            last.end = idx;
            if ((last.end - last.start) > (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, '');
          if (group.start === 0) {
            ip.unshift('');
          }
          if (group.end === 7) {
            ip.push('');
          }
        }
      }
      return ip.join(':');
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      if ('cores' in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== 'undefined' && 'hardwareConcurrency' in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === 'undefined') {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === 'undefined') {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob(['(', function() {
        self.addEventListener('message', function(e) {
          var st = Date.now();
          var et = st + 4;
          while (Date.now() < et)
            ;
          self.postMessage({
            st: st,
            et: et
          });
        });
      }.toString(), ')()'], {type: 'application/javascript'}));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg, x) {
            return avg + x;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map(numWorkers, callback) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener('message', function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i = 0; i < numWorkers; ++i) {
                workers[i].terminate();
              }
              callback(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if ((r1.st > r2.st && r1.st < r2.et) || (r2.st > r1.st && r2.st < r1.et)) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap) {
          return Math.max(max, overlap.length);
        }, 0);
      }
    };
  }
  var name = 'util';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/util.js", ["require", "module"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.cipher = forge.cipher || {};
    var modes = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = 'ECB';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {};
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = (input.length() === this.blockSize ? this.blockSize : (this.blockSize - input.length()));
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > (this.blockSize << 2)) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = 'CBC';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error('Invalid IV parameter.');
        }
        this._iv = this._prev.slice(0);
      } else if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      } else {
        this._iv = transformIV(options.iv);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = (input.length() === this.blockSize ? this.blockSize : (this.blockSize - input.length()));
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > (this.blockSize << 2)) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = 'CFB';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = 'OFB';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = 'CTR';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = 'GCM';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 0xE1000000;
    };
    modes.gcm.prototype.start = function(options) {
      if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      }
      var iv = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ('additionalData' in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ('tagLength' in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== (this._tagLength / 8)) {
          throw new Error('Authentication tag does not match tag length.');
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
        }
        this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes === 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = (i / 8) | 0;
        var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;
        var ah = this._m[i][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = (i / perInt) | 0;
        var shft = ((perInt - 1 - (i % perInt)) * bits);
        tmp[idx] = (1 << (bits - 1)) << shft;
        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m[2 * i], m[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m[i];
          var m_j = m[j];
          m[i + j] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];
        }
        i *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m[i ^ half];
        m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv) {
      if (typeof iv === 'string') {
        iv = forge.util.createBuffer(iv);
      }
      if (forge.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (!forge.util.isArray(iv)) {
        iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;
    }
    function from64To32(num) {
      return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];
    }
  }
  var name = 'cipherModes';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/cipherModes.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.pki = forge.pki || {};
    var oids = forge.pki.oids = forge.oids = forge.oids || {};
    oids['1.2.840.113549.1.1.1'] = 'rsaEncryption';
    oids['rsaEncryption'] = '1.2.840.113549.1.1.1';
    oids['1.2.840.113549.1.1.4'] = 'md5WithRSAEncryption';
    oids['md5WithRSAEncryption'] = '1.2.840.113549.1.1.4';
    oids['1.2.840.113549.1.1.5'] = 'sha1WithRSAEncryption';
    oids['sha1WithRSAEncryption'] = '1.2.840.113549.1.1.5';
    oids['1.2.840.113549.1.1.7'] = 'RSAES-OAEP';
    oids['RSAES-OAEP'] = '1.2.840.113549.1.1.7';
    oids['1.2.840.113549.1.1.8'] = 'mgf1';
    oids['mgf1'] = '1.2.840.113549.1.1.8';
    oids['1.2.840.113549.1.1.9'] = 'pSpecified';
    oids['pSpecified'] = '1.2.840.113549.1.1.9';
    oids['1.2.840.113549.1.1.10'] = 'RSASSA-PSS';
    oids['RSASSA-PSS'] = '1.2.840.113549.1.1.10';
    oids['1.2.840.113549.1.1.11'] = 'sha256WithRSAEncryption';
    oids['sha256WithRSAEncryption'] = '1.2.840.113549.1.1.11';
    oids['1.2.840.113549.1.1.12'] = 'sha384WithRSAEncryption';
    oids['sha384WithRSAEncryption'] = '1.2.840.113549.1.1.12';
    oids['1.2.840.113549.1.1.13'] = 'sha512WithRSAEncryption';
    oids['sha512WithRSAEncryption'] = '1.2.840.113549.1.1.13';
    oids['1.3.14.3.2.7'] = 'desCBC';
    oids['desCBC'] = '1.3.14.3.2.7';
    oids['1.3.14.3.2.26'] = 'sha1';
    oids['sha1'] = '1.3.14.3.2.26';
    oids['2.16.840.1.101.3.4.2.1'] = 'sha256';
    oids['sha256'] = '2.16.840.1.101.3.4.2.1';
    oids['2.16.840.1.101.3.4.2.2'] = 'sha384';
    oids['sha384'] = '2.16.840.1.101.3.4.2.2';
    oids['2.16.840.1.101.3.4.2.3'] = 'sha512';
    oids['sha512'] = '2.16.840.1.101.3.4.2.3';
    oids['1.2.840.113549.2.5'] = 'md5';
    oids['md5'] = '1.2.840.113549.2.5';
    oids['1.2.840.113549.1.7.1'] = 'data';
    oids['data'] = '1.2.840.113549.1.7.1';
    oids['1.2.840.113549.1.7.2'] = 'signedData';
    oids['signedData'] = '1.2.840.113549.1.7.2';
    oids['1.2.840.113549.1.7.3'] = 'envelopedData';
    oids['envelopedData'] = '1.2.840.113549.1.7.3';
    oids['1.2.840.113549.1.7.4'] = 'signedAndEnvelopedData';
    oids['signedAndEnvelopedData'] = '1.2.840.113549.1.7.4';
    oids['1.2.840.113549.1.7.5'] = 'digestedData';
    oids['digestedData'] = '1.2.840.113549.1.7.5';
    oids['1.2.840.113549.1.7.6'] = 'encryptedData';
    oids['encryptedData'] = '1.2.840.113549.1.7.6';
    oids['1.2.840.113549.1.9.1'] = 'emailAddress';
    oids['emailAddress'] = '1.2.840.113549.1.9.1';
    oids['1.2.840.113549.1.9.2'] = 'unstructuredName';
    oids['unstructuredName'] = '1.2.840.113549.1.9.2';
    oids['1.2.840.113549.1.9.3'] = 'contentType';
    oids['contentType'] = '1.2.840.113549.1.9.3';
    oids['1.2.840.113549.1.9.4'] = 'messageDigest';
    oids['messageDigest'] = '1.2.840.113549.1.9.4';
    oids['1.2.840.113549.1.9.5'] = 'signingTime';
    oids['signingTime'] = '1.2.840.113549.1.9.5';
    oids['1.2.840.113549.1.9.6'] = 'counterSignature';
    oids['counterSignature'] = '1.2.840.113549.1.9.6';
    oids['1.2.840.113549.1.9.7'] = 'challengePassword';
    oids['challengePassword'] = '1.2.840.113549.1.9.7';
    oids['1.2.840.113549.1.9.8'] = 'unstructuredAddress';
    oids['unstructuredAddress'] = '1.2.840.113549.1.9.8';
    oids['1.2.840.113549.1.9.14'] = 'extensionRequest';
    oids['extensionRequest'] = '1.2.840.113549.1.9.14';
    oids['1.2.840.113549.1.9.20'] = 'friendlyName';
    oids['friendlyName'] = '1.2.840.113549.1.9.20';
    oids['1.2.840.113549.1.9.21'] = 'localKeyId';
    oids['localKeyId'] = '1.2.840.113549.1.9.21';
    oids['1.2.840.113549.1.9.22.1'] = 'x509Certificate';
    oids['x509Certificate'] = '1.2.840.113549.1.9.22.1';
    oids['1.2.840.113549.1.12.10.1.1'] = 'keyBag';
    oids['keyBag'] = '1.2.840.113549.1.12.10.1.1';
    oids['1.2.840.113549.1.12.10.1.2'] = 'pkcs8ShroudedKeyBag';
    oids['pkcs8ShroudedKeyBag'] = '1.2.840.113549.1.12.10.1.2';
    oids['1.2.840.113549.1.12.10.1.3'] = 'certBag';
    oids['certBag'] = '1.2.840.113549.1.12.10.1.3';
    oids['1.2.840.113549.1.12.10.1.4'] = 'crlBag';
    oids['crlBag'] = '1.2.840.113549.1.12.10.1.4';
    oids['1.2.840.113549.1.12.10.1.5'] = 'secretBag';
    oids['secretBag'] = '1.2.840.113549.1.12.10.1.5';
    oids['1.2.840.113549.1.12.10.1.6'] = 'safeContentsBag';
    oids['safeContentsBag'] = '1.2.840.113549.1.12.10.1.6';
    oids['1.2.840.113549.1.5.13'] = 'pkcs5PBES2';
    oids['pkcs5PBES2'] = '1.2.840.113549.1.5.13';
    oids['1.2.840.113549.1.5.12'] = 'pkcs5PBKDF2';
    oids['pkcs5PBKDF2'] = '1.2.840.113549.1.5.12';
    oids['1.2.840.113549.1.12.1.1'] = 'pbeWithSHAAnd128BitRC4';
    oids['pbeWithSHAAnd128BitRC4'] = '1.2.840.113549.1.12.1.1';
    oids['1.2.840.113549.1.12.1.2'] = 'pbeWithSHAAnd40BitRC4';
    oids['pbeWithSHAAnd40BitRC4'] = '1.2.840.113549.1.12.1.2';
    oids['1.2.840.113549.1.12.1.3'] = 'pbeWithSHAAnd3-KeyTripleDES-CBC';
    oids['pbeWithSHAAnd3-KeyTripleDES-CBC'] = '1.2.840.113549.1.12.1.3';
    oids['1.2.840.113549.1.12.1.4'] = 'pbeWithSHAAnd2-KeyTripleDES-CBC';
    oids['pbeWithSHAAnd2-KeyTripleDES-CBC'] = '1.2.840.113549.1.12.1.4';
    oids['1.2.840.113549.1.12.1.5'] = 'pbeWithSHAAnd128BitRC2-CBC';
    oids['pbeWithSHAAnd128BitRC2-CBC'] = '1.2.840.113549.1.12.1.5';
    oids['1.2.840.113549.1.12.1.6'] = 'pbewithSHAAnd40BitRC2-CBC';
    oids['pbewithSHAAnd40BitRC2-CBC'] = '1.2.840.113549.1.12.1.6';
    oids['1.2.840.113549.3.7'] = 'des-EDE3-CBC';
    oids['des-EDE3-CBC'] = '1.2.840.113549.3.7';
    oids['2.16.840.1.101.3.4.1.2'] = 'aes128-CBC';
    oids['aes128-CBC'] = '2.16.840.1.101.3.4.1.2';
    oids['2.16.840.1.101.3.4.1.22'] = 'aes192-CBC';
    oids['aes192-CBC'] = '2.16.840.1.101.3.4.1.22';
    oids['2.16.840.1.101.3.4.1.42'] = 'aes256-CBC';
    oids['aes256-CBC'] = '2.16.840.1.101.3.4.1.42';
    oids['2.5.4.3'] = 'commonName';
    oids['commonName'] = '2.5.4.3';
    oids['2.5.4.5'] = 'serialName';
    oids['serialName'] = '2.5.4.5';
    oids['2.5.4.6'] = 'countryName';
    oids['countryName'] = '2.5.4.6';
    oids['2.5.4.7'] = 'localityName';
    oids['localityName'] = '2.5.4.7';
    oids['2.5.4.8'] = 'stateOrProvinceName';
    oids['stateOrProvinceName'] = '2.5.4.8';
    oids['2.5.4.10'] = 'organizationName';
    oids['organizationName'] = '2.5.4.10';
    oids['2.5.4.11'] = 'organizationalUnitName';
    oids['organizationalUnitName'] = '2.5.4.11';
    oids['2.16.840.1.113730.1.1'] = 'nsCertType';
    oids['nsCertType'] = '2.16.840.1.113730.1.1';
    oids['2.5.29.1'] = 'authorityKeyIdentifier';
    oids['2.5.29.2'] = 'keyAttributes';
    oids['2.5.29.3'] = 'certificatePolicies';
    oids['2.5.29.4'] = 'keyUsageRestriction';
    oids['2.5.29.5'] = 'policyMapping';
    oids['2.5.29.6'] = 'subtreesConstraint';
    oids['2.5.29.7'] = 'subjectAltName';
    oids['2.5.29.8'] = 'issuerAltName';
    oids['2.5.29.9'] = 'subjectDirectoryAttributes';
    oids['2.5.29.10'] = 'basicConstraints';
    oids['2.5.29.11'] = 'nameConstraints';
    oids['2.5.29.12'] = 'policyConstraints';
    oids['2.5.29.13'] = 'basicConstraints';
    oids['2.5.29.14'] = 'subjectKeyIdentifier';
    oids['subjectKeyIdentifier'] = '2.5.29.14';
    oids['2.5.29.15'] = 'keyUsage';
    oids['keyUsage'] = '2.5.29.15';
    oids['2.5.29.16'] = 'privateKeyUsagePeriod';
    oids['2.5.29.17'] = 'subjectAltName';
    oids['subjectAltName'] = '2.5.29.17';
    oids['2.5.29.18'] = 'issuerAltName';
    oids['issuerAltName'] = '2.5.29.18';
    oids['2.5.29.19'] = 'basicConstraints';
    oids['basicConstraints'] = '2.5.29.19';
    oids['2.5.29.20'] = 'cRLNumber';
    oids['2.5.29.21'] = 'cRLReason';
    oids['2.5.29.22'] = 'expirationDate';
    oids['2.5.29.23'] = 'instructionCode';
    oids['2.5.29.24'] = 'invalidityDate';
    oids['2.5.29.25'] = 'cRLDistributionPoints';
    oids['2.5.29.26'] = 'issuingDistributionPoint';
    oids['2.5.29.27'] = 'deltaCRLIndicator';
    oids['2.5.29.28'] = 'issuingDistributionPoint';
    oids['2.5.29.29'] = 'certificateIssuer';
    oids['2.5.29.30'] = 'nameConstraints';
    oids['2.5.29.31'] = 'cRLDistributionPoints';
    oids['2.5.29.32'] = 'certificatePolicies';
    oids['2.5.29.33'] = 'policyMappings';
    oids['2.5.29.34'] = 'policyConstraints';
    oids['2.5.29.35'] = 'authorityKeyIdentifier';
    oids['2.5.29.36'] = 'policyConstraints';
    oids['2.5.29.37'] = 'extKeyUsage';
    oids['extKeyUsage'] = '2.5.29.37';
    oids['2.5.29.46'] = 'freshestCRL';
    oids['2.5.29.54'] = 'inhibitAnyPolicy';
    oids['1.3.6.1.5.5.7.3.1'] = 'serverAuth';
    oids['serverAuth'] = '1.3.6.1.5.5.7.3.1';
    oids['1.3.6.1.5.5.7.3.2'] = 'clientAuth';
    oids['clientAuth'] = '1.3.6.1.5.5.7.3.2';
    oids['1.3.6.1.5.5.7.3.3'] = 'codeSigning';
    oids['codeSigning'] = '1.3.6.1.5.5.7.3.3';
    oids['1.3.6.1.5.5.7.3.4'] = 'emailProtection';
    oids['emailProtection'] = '1.3.6.1.5.5.7.3.4';
    oids['1.3.6.1.5.5.7.3.8'] = 'timeStamping';
    oids['timeStamping'] = '1.3.6.1.5.5.7.3.8';
  }
  var name = 'oids';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/oids.js", ["require", "module"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var md5 = forge.md5 = forge.md5 || {};
    forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
    forge.md.md5 = forge.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(16);
      var md = {
        algorithm: 'md5',
        blockLength: 64,
        digestLength: 16,
        messageLength: 0,
        messageLength64: [0, 0]
      };
      md.start = function() {
        md.messageLength = 0;
        md.messageLength64 = [0, 0];
        _input = forge.util.createBuffer();
        _state = {
          h0: 0x67452301,
          h1: 0xEFCDAB89,
          h2: 0x98BADCFE,
          h3: 0x10325476
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === 'utf8') {
          msg = forge.util.encodeUtf8(msg);
        }
        md.messageLength += msg.length;
        md.messageLength64[0] += (msg.length / 0x100000000) >>> 0;
        md.messageLength64[1] += msg.length >>> 0;
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var padBytes = forge.util.createBuffer();
        padBytes.putBytes(_input.bytes());
        padBytes.putBytes(_padding.substr(0, 64 - ((md.messageLength64[1] + 8) & 0x3F)));
        padBytes.putInt32Le(md.messageLength64[1] << 3);
        padBytes.putInt32Le((md.messageLength64[0] << 3) | (md.messageLength64[0] >>> 28));
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, padBytes);
        var rval = forge.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _g = null;
    var _r = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0x00), 64);
      _g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9];
      _r = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21];
      _k = new Array(64);
      for (var i = 0; i < 64; ++i) {
        _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000);
      }
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t,
          a,
          b,
          c,
          d,
          f,
          r,
          i;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        for (i = 0; i < 16; ++i) {
          w[i] = bytes.getInt32Le();
          f = d ^ (b & (c ^ d));
          t = (a + f + _k[i] + w[i]);
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += (t << r) | (t >>> (32 - r));
        }
        for (; i < 32; ++i) {
          f = c ^ (d & (b ^ c));
          t = (a + f + _k[i] + w[_g[i]]);
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += (t << r) | (t >>> (32 - r));
        }
        for (; i < 48; ++i) {
          f = b ^ c ^ d;
          t = (a + f + _k[i] + w[_g[i]]);
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += (t << r) | (t >>> (32 - r));
        }
        for (; i < 64; ++i) {
          f = c ^ (b | ~d);
          t = (a + f + _k[i] + w[_g[i]]);
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += (t << r) | (t >>> (32 - r));
        }
        s.h0 = (s.h0 + a) | 0;
        s.h1 = (s.h1 + b) | 0;
        s.h2 = (s.h2 + c) | 0;
        s.h3 = (s.h3 + d) | 0;
        len -= 64;
      }
    }
  }
  var name = 'md5';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/md5.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var sha1 = forge.sha1 = forge.sha1 || {};
    forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: 'sha1',
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        messageLength64: [0, 0]
      };
      md.start = function() {
        md.messageLength = 0;
        md.messageLength64 = [0, 0];
        _input = forge.util.createBuffer();
        _state = {
          h0: 0x67452301,
          h1: 0xEFCDAB89,
          h2: 0x98BADCFE,
          h3: 0x10325476,
          h4: 0xC3D2E1F0
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === 'utf8') {
          msg = forge.util.encodeUtf8(msg);
        }
        md.messageLength += msg.length;
        md.messageLength64[0] += (msg.length / 0x100000000) >>> 0;
        md.messageLength64[1] += msg.length >>> 0;
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var padBytes = forge.util.createBuffer();
        padBytes.putBytes(_input.bytes());
        padBytes.putBytes(_padding.substr(0, 64 - ((md.messageLength64[1] + 8) & 0x3F)));
        padBytes.putInt32((md.messageLength64[0] << 3) | (md.messageLength64[0] >>> 28));
        padBytes.putInt32(md.messageLength64[1] << 3);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, padBytes);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0x00), 64);
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t,
          a,
          b,
          c,
          d,
          e,
          f,
          i;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes.getInt32();
          w[i] = t;
          f = d ^ (b & (c ^ d));
          t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 20; ++i) {
          t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
          t = (t << 1) | (t >>> 31);
          w[i] = t;
          f = d ^ (b & (c ^ d));
          t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 32; ++i) {
          t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
          t = (t << 1) | (t >>> 31);
          w[i] = t;
          f = b ^ c ^ d;
          t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 40; ++i) {
          t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
          t = (t << 2) | (t >>> 30);
          w[i] = t;
          f = b ^ c ^ d;
          t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 60; ++i) {
          t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
          t = (t << 2) | (t >>> 30);
          w[i] = t;
          f = (b & c) | (d & (b ^ c));
          t = ((a << 5) | (a >>> 27)) + f + e + 0x8F1BBCDC + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 80; ++i) {
          t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
          t = (t << 2) | (t >>> 30);
          w[i] = t;
          f = b ^ c ^ d;
          t = ((a << 5) | (a >>> 27)) + f + e + 0xCA62C1D6 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        s.h0 = (s.h0 + a) | 0;
        s.h1 = (s.h1 + b) | 0;
        s.h2 = (s.h2 + c) | 0;
        s.h3 = (s.h3 + d) | 0;
        s.h4 = (s.h4 + e) | 0;
        len -= 64;
      }
    }
  }
  var name = 'sha1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/sha1.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var sha256 = forge.sha256 = forge.sha256 || {};
    forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: 'sha256',
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        messageLength64: [0, 0]
      };
      md.start = function() {
        md.messageLength = 0;
        md.messageLength64 = [0, 0];
        _input = forge.util.createBuffer();
        _state = {
          h0: 0x6A09E667,
          h1: 0xBB67AE85,
          h2: 0x3C6EF372,
          h3: 0xA54FF53A,
          h4: 0x510E527F,
          h5: 0x9B05688C,
          h6: 0x1F83D9AB,
          h7: 0x5BE0CD19
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === 'utf8') {
          msg = forge.util.encodeUtf8(msg);
        }
        md.messageLength += msg.length;
        md.messageLength64[0] += (msg.length / 0x100000000) >>> 0;
        md.messageLength64[1] += msg.length >>> 0;
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var padBytes = forge.util.createBuffer();
        padBytes.putBytes(_input.bytes());
        padBytes.putBytes(_padding.substr(0, 64 - ((md.messageLength64[1] + 8) & 0x3F)));
        padBytes.putInt32((md.messageLength64[0] << 3) | (md.messageLength64[0] >>> 28));
        padBytes.putInt32(md.messageLength64[1] << 3);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, padBytes);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0x00), 64);
      _k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t1,
          t2,
          s0,
          s1,
          ch,
          maj,
          i,
          a,
          b,
          c,
          d,
          e,
          f,
          g,
          h;
      var len = bytes.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w[i] = bytes.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w[i - 2];
          t1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
          t2 = w[i - 15];
          t2 = ((t2 >>> 7) | (t2 << 25)) ^ ((t2 >>> 18) | (t2 << 14)) ^ (t2 >>> 3);
          w[i] = (t1 + w[i - 7] + t2 + w[i - 16]) | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i = 0; i < 64; ++i) {
          s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
          ch = g ^ (e & (f ^ g));
          s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
          maj = (a & b) | (c & (a ^ b));
          t1 = h + s1 + ch + _k[i] + w[i];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = (d + t1) | 0;
          d = c;
          c = b;
          b = a;
          a = (t1 + t2) | 0;
        }
        s.h0 = (s.h0 + a) | 0;
        s.h1 = (s.h1 + b) | 0;
        s.h2 = (s.h2 + c) | 0;
        s.h3 = (s.h3 + d) | 0;
        s.h4 = (s.h4 + e) | 0;
        s.h5 = (s.h5 + f) | 0;
        s.h6 = (s.h6 + g) | 0;
        s.h7 = (s.h7 + h) | 0;
        len -= 64;
      }
    }
  }
  var name = 'sha256';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/sha256.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var sha512 = forge.sha512 = forge.sha512 || {};
    forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha512.create('SHA-384');
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {create: function() {
        return sha512.create('SHA-512/256');
      }};
    forge.md['sha512/256'] = forge.md.algorithms['sha512/256'] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {create: function() {
        return sha512.create('SHA-512/224');
      }};
    forge.md['sha512/224'] = forge.md.algorithms['sha512/224'] = forge.sha512.sha224;
    sha512.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === 'undefined') {
        algorithm = 'SHA-512';
      }
      if (!(algorithm in _states)) {
        throw new Error('Invalid SHA-512 algorithm: ' + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var md = {
        algorithm: algorithm.replace('-', '').toLowerCase(),
        blockLength: 128,
        digestLength: 64,
        messageLength: 0,
        messageLength128: [0, 0, 0, 0]
      };
      md.start = function() {
        md.messageLength = 0;
        md.messageLength128 = [0, 0, 0, 0];
        _input = forge.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === 'utf8') {
          msg = forge.util.encodeUtf8(msg);
        }
        md.messageLength += msg.length;
        var len = msg.length;
        len = [(len / 0x100000000) >>> 0, len >>> 0];
        for (var i = 3; i >= 0; --i) {
          md.messageLength128[i] += len[1];
          len[1] = len[0] + ((md.messageLength128[i] / 0x100000000) >>> 0);
          md.messageLength128[i] = md.messageLength128[i] >>> 0;
          len[0] = ((len[1] / 0x100000000) >>> 0);
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var padBytes = forge.util.createBuffer();
        padBytes.putBytes(_input.bytes());
        padBytes.putBytes(_padding.substr(0, 128 - ((md.messageLength128[3] + 16) & 0x7F)));
        var bitLength = [];
        for (var i = 0; i < 3; ++i) {
          bitLength[i] = ((md.messageLength128[i] << 3) | (md.messageLength128[i - 1] >>> 28));
        }
        bitLength[3] = md.messageLength128[3] << 3;
        padBytes.putInt32(bitLength[0]);
        padBytes.putInt32(bitLength[1]);
        padBytes.putInt32(bitLength[2]);
        padBytes.putInt32(bitLength[3]);
        var h = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h[i] = _h[i].slice(0);
        }
        _update(h, _w, padBytes);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === 'SHA-512') {
          hlen = h.length;
        } else if (algorithm === 'SHA-384') {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h[i][0]);
          if (i !== hlen - 1 || algorithm !== 'SHA-512/224') {
            rval.putInt32(h[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0x00), 128);
      _k = [[0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd], [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc], [0x3956c25b, 0xf348b538], [0x59f111f1, 0xb605d019], [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118], [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe], [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2], [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1], [0x9bdc06a7, 0x25c71235], [0xc19bf174, 0xcf692694], [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3], [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65], [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483], [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5], [0x983e5152, 0xee66dfab], [0xa831c66d, 0x2db43210], [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4], [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725], [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70], [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926], [0x4d2c6dfc, 0x5ac42aed], [0x53380d13, 0x9d95b3df], [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8], [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b], [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001], [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30], [0xd192e819, 0xd6ef5218], [0xd6990624, 0x5565a910], [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8], [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53], [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8], [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb], [0x5b9cca4f, 0x7763e373], [0x682e6ff3, 0xd6b2b8a3], [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60], [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec], [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9], [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b], [0xca273ece, 0xea26619c], [0xd186b8c7, 0x21c0c207], [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178], [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6], [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b], [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493], [0x3c9ebe0a, 0x15c9bebc], [0x431d67c4, 0x9c100d4c], [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a], [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]];
      _states = {};
      _states['SHA-512'] = [[0x6a09e667, 0xf3bcc908], [0xbb67ae85, 0x84caa73b], [0x3c6ef372, 0xfe94f82b], [0xa54ff53a, 0x5f1d36f1], [0x510e527f, 0xade682d1], [0x9b05688c, 0x2b3e6c1f], [0x1f83d9ab, 0xfb41bd6b], [0x5be0cd19, 0x137e2179]];
      _states['SHA-384'] = [[0xcbbb9d5d, 0xc1059ed8], [0x629a292a, 0x367cd507], [0x9159015a, 0x3070dd17], [0x152fecd8, 0xf70e5939], [0x67332667, 0xffc00b31], [0x8eb44a87, 0x68581511], [0xdb0c2e0d, 0x64f98fa7], [0x47b5481d, 0xbefa4fa4]];
      _states['SHA-512/256'] = [[0x22312194, 0xFC2BF72C], [0x9F555FA3, 0xC84C64C2], [0x2393B86B, 0x6F53B151], [0x96387719, 0x5940EABD], [0x96283EE2, 0xA88EFFE3], [0xBE5E1E25, 0x53863992], [0x2B0199FC, 0x2C85B8AA], [0x0EB72DDC, 0x81C52CA2]];
      _states['SHA-512/224'] = [[0x8C3D37C8, 0x19544DA2], [0x73E19966, 0x89DCD4D6], [0x1DFAB7AE, 0x32FF9C82], [0x679DD514, 0x582F9FCF], [0x0F6D2B69, 0x7BD44DA8], [0x77E36F73, 0x04C48942], [0x3F9D85A8, 0x6A1D36C8], [0x1112E6AD, 0x91D692A1]];
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t1_hi,
          t1_lo;
      var t2_hi,
          t2_lo;
      var s0_hi,
          s0_lo;
      var s1_hi,
          s1_lo;
      var ch_hi,
          ch_lo;
      var maj_hi,
          maj_lo;
      var a_hi,
          a_lo;
      var b_hi,
          b_lo;
      var c_hi,
          c_lo;
      var d_hi,
          d_lo;
      var e_hi,
          e_lo;
      var f_hi,
          f_lo;
      var g_hi,
          g_lo;
      var h_hi,
          h_lo;
      var i,
          hi,
          lo,
          w2,
          w7,
          w15,
          w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w[i][0] = bytes.getInt32() >>> 0;
          w[i][1] = bytes.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w2 = w[i - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = (((hi >>> 19) | (lo << 13)) ^ ((lo >>> 29) | (hi << 3)) ^ (hi >>> 6)) >>> 0;
          t1_lo = (((hi << 13) | (lo >>> 19)) ^ ((lo << 3) | (hi >>> 29)) ^ ((hi << 26) | (lo >>> 6))) >>> 0;
          w15 = w[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = (((hi >>> 1) | (lo << 31)) ^ ((hi >>> 8) | (lo << 24)) ^ (hi >>> 7)) >>> 0;
          t2_lo = (((hi << 31) | (lo >>> 1)) ^ ((hi << 24) | (lo >>> 8)) ^ ((hi << 25) | (lo >>> 7))) >>> 0;
          w7 = w[i - 7];
          w16 = w[i - 16];
          lo = (t1_lo + w7[1] + t2_lo + w16[1]);
          w[i][0] = (t1_hi + w7[0] + t2_hi + w16[0] + ((lo / 0x100000000) >>> 0)) >>> 0;
          w[i][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = (((e_hi >>> 14) | (e_lo << 18)) ^ ((e_hi >>> 18) | (e_lo << 14)) ^ ((e_lo >>> 9) | (e_hi << 23))) >>> 0;
          s1_lo = (((e_hi << 18) | (e_lo >>> 14)) ^ ((e_hi << 14) | (e_lo >>> 18)) ^ ((e_lo << 23) | (e_hi >>> 9))) >>> 0;
          ch_hi = (g_hi ^ (e_hi & (f_hi ^ g_hi))) >>> 0;
          ch_lo = (g_lo ^ (e_lo & (f_lo ^ g_lo))) >>> 0;
          s0_hi = (((a_hi >>> 28) | (a_lo << 4)) ^ ((a_lo >>> 2) | (a_hi << 30)) ^ ((a_lo >>> 7) | (a_hi << 25))) >>> 0;
          s0_lo = (((a_hi << 4) | (a_lo >>> 28)) ^ ((a_lo << 30) | (a_hi >>> 2)) ^ ((a_lo << 25) | (a_hi >>> 7))) >>> 0;
          maj_hi = ((a_hi & b_hi) | (c_hi & (a_hi ^ b_hi))) >>> 0;
          maj_lo = ((a_lo & b_lo) | (c_lo & (a_lo ^ b_lo))) >>> 0;
          lo = (h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1]);
          t1_hi = (h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + ((lo / 0x100000000) >>> 0)) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = (s0_hi + maj_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = (d_hi + t1_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = (t1_hi + t2_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = (s[0][0] + a_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = (s[1][0] + b_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = (s[2][0] + c_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = (s[3][0] + d_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = (s[4][0] + e_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = (s[5][0] + f_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = (s[6][0] + g_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = (s[7][0] + h_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
  var name = 'sha512';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/sha512.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var pem = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = '-----BEGIN ' + msg.type + '-----\r\n';
      var header;
      if (msg.procType) {
        header = {
          name: 'Proc-Type',
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = {
          name: 'Content-Domain',
          values: [msg.contentDomain]
        };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = {
          name: 'DEK-Info',
          values: [msg.dekInfo.algorithm]
        };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += '\r\n';
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + '\r\n';
      rval += '-----END ' + msg.type + '-----\r\n';
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var msg = {
          type: match[1],
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, '');
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = {
              name: match[1],
              values: []
            };
            var values = match[2].split(',');
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== 'Proc-Type') {
                throw new Error('Invalid PEM formatted message. The first ' + 'encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" ' + 'header must have two subfields.');
              }
              msg.procType = {
                version: values[0],
                type: values[1]
              };
            } else if (!msg.contentDomain && header.name === 'Content-Domain') {
              msg.contentDomain = values[0] || '';
            } else if (!msg.dekInfo && header.name === 'DEK-Info') {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" ' + 'header must have at least one subfield.');
              }
              msg.dekInfo = {
                algorithm: values[0],
                parameters: values[1] || null
              };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === 'ENCRYPTED' && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" ' + 'header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error('Invalid PEM formatted message.');
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ': ';
      var values = [];
      var insertSpace = function(match, $1) {
        return ' ' + $1;
      };
      for (var i = 0; i < header.values.length; ++i) {
        values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(',') + '\r\n';
      var length = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ',') {
            ++candidate;
            rval = rval.substr(0, candidate) + '\r\n ' + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + '\r\n' + insert + rval.substr(candidate + 1);
          }
          length = (i - candidate - 1);
          candidate = -1;
          ++i;
        } else if (rval[i] === ' ' || rval[i] === '\t' || rval[i] === ',') {
          candidate = i;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, '');
    }
  }
  var name = 'pem';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pem.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key: key,
        output: output,
        decrypt: false,
        mode: mode || (iv === null ? 'ECB' : 'CBC')
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key: key,
        output: null,
        decrypt: false,
        mode: mode
      });
    };
    forge.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key: key,
        output: output,
        decrypt: true,
        mode: mode || (iv === null ? 'ECB' : 'CBC')
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key: key,
        output: null,
        decrypt: true,
        mode: mode
      });
    };
    forge.des.Algorithm = function(name, mode) {
      var self = this;
      self.name = name;
      self.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self._keys, inBlock, outBlock, true);
          }
        }
      });
      self._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf('3DES') === 0) {
        if (key.length() !== 24) {
          throw new Error('Invalid Triple-DES key size: ' + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm('DES-ECB', forge.cipher.modes.ecb);
    registerAlgorithm('DES-CBC', forge.cipher.modes.cbc);
    registerAlgorithm('DES-CFB', forge.cipher.modes.cfb);
    registerAlgorithm('DES-OFB', forge.cipher.modes.ofb);
    registerAlgorithm('DES-CTR', forge.cipher.modes.ctr);
    registerAlgorithm('3DES-ECB', forge.cipher.modes.ecb);
    registerAlgorithm('3DES-CBC', forge.cipher.modes.cbc);
    registerAlgorithm('3DES-CFB', forge.cipher.modes.cfb);
    registerAlgorithm('3DES-OFB', forge.cipher.modes.ofb);
    registerAlgorithm('3DES-CTR', forge.cipher.modes.ctr);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge.des.Algorithm(name, mode);
      };
      forge.cipher.registerAlgorithm(name, factory);
    }
    var spfunction1 = [0x1010400, 0, 0x10000, 0x1010404, 0x1010004, 0x10404, 0x4, 0x10000, 0x400, 0x1010400, 0x1010404, 0x400, 0x1000404, 0x1010004, 0x1000000, 0x4, 0x404, 0x1000400, 0x1000400, 0x10400, 0x10400, 0x1010000, 0x1010000, 0x1000404, 0x10004, 0x1000004, 0x1000004, 0x10004, 0, 0x404, 0x10404, 0x1000000, 0x10000, 0x1010404, 0x4, 0x1010000, 0x1010400, 0x1000000, 0x1000000, 0x400, 0x1010004, 0x10000, 0x10400, 0x1000004, 0x400, 0x4, 0x1000404, 0x10404, 0x1010404, 0x10004, 0x1010000, 0x1000404, 0x1000004, 0x404, 0x10404, 0x1010400, 0x404, 0x1000400, 0x1000400, 0, 0x10004, 0x10400, 0, 0x1010004];
    var spfunction2 = [-0x7fef7fe0, -0x7fff8000, 0x8000, 0x108020, 0x100000, 0x20, -0x7fefffe0, -0x7fff7fe0, -0x7fffffe0, -0x7fef7fe0, -0x7fef8000, -0x80000000, -0x7fff8000, 0x100000, 0x20, -0x7fefffe0, 0x108000, 0x100020, -0x7fff7fe0, 0, -0x80000000, 0x8000, 0x108020, -0x7ff00000, 0x100020, -0x7fffffe0, 0, 0x108000, 0x8020, -0x7fef8000, -0x7ff00000, 0x8020, 0, 0x108020, -0x7fefffe0, 0x100000, -0x7fff7fe0, -0x7ff00000, -0x7fef8000, 0x8000, -0x7ff00000, -0x7fff8000, 0x20, -0x7fef7fe0, 0x108020, 0x20, 0x8000, -0x80000000, 0x8020, -0x7fef8000, 0x100000, -0x7fffffe0, 0x100020, -0x7fff7fe0, -0x7fffffe0, 0x100020, 0x108000, 0, -0x7fff8000, 0x8020, -0x80000000, -0x7fefffe0, -0x7fef7fe0, 0x108000];
    var spfunction3 = [0x208, 0x8020200, 0, 0x8020008, 0x8000200, 0, 0x20208, 0x8000200, 0x20008, 0x8000008, 0x8000008, 0x20000, 0x8020208, 0x20008, 0x8020000, 0x208, 0x8000000, 0x8, 0x8020200, 0x200, 0x20200, 0x8020000, 0x8020008, 0x20208, 0x8000208, 0x20200, 0x20000, 0x8000208, 0x8, 0x8020208, 0x200, 0x8000000, 0x8020200, 0x8000000, 0x20008, 0x208, 0x20000, 0x8020200, 0x8000200, 0, 0x200, 0x20008, 0x8020208, 0x8000200, 0x8000008, 0x200, 0, 0x8020008, 0x8000208, 0x20000, 0x8000000, 0x8020208, 0x8, 0x20208, 0x20200, 0x8000008, 0x8020000, 0x8000208, 0x208, 0x8020000, 0x20208, 0x8, 0x8020008, 0x20200];
    var spfunction4 = [0x802001, 0x2081, 0x2081, 0x80, 0x802080, 0x800081, 0x800001, 0x2001, 0, 0x802000, 0x802000, 0x802081, 0x81, 0, 0x800080, 0x800001, 0x1, 0x2000, 0x800000, 0x802001, 0x80, 0x800000, 0x2001, 0x2080, 0x800081, 0x1, 0x2080, 0x800080, 0x2000, 0x802080, 0x802081, 0x81, 0x800080, 0x800001, 0x802000, 0x802081, 0x81, 0, 0, 0x802000, 0x2080, 0x800080, 0x800081, 0x1, 0x802001, 0x2081, 0x2081, 0x80, 0x802081, 0x81, 0x1, 0x2000, 0x800001, 0x2001, 0x802080, 0x800081, 0x2001, 0x2080, 0x800000, 0x802001, 0x80, 0x800000, 0x2000, 0x802080];
    var spfunction5 = [0x100, 0x2080100, 0x2080000, 0x42000100, 0x80000, 0x100, 0x40000000, 0x2080000, 0x40080100, 0x80000, 0x2000100, 0x40080100, 0x42000100, 0x42080000, 0x80100, 0x40000000, 0x2000000, 0x40080000, 0x40080000, 0, 0x40000100, 0x42080100, 0x42080100, 0x2000100, 0x42080000, 0x40000100, 0, 0x42000000, 0x2080100, 0x2000000, 0x42000000, 0x80100, 0x80000, 0x42000100, 0x100, 0x2000000, 0x40000000, 0x2080000, 0x42000100, 0x40080100, 0x2000100, 0x40000000, 0x42080000, 0x2080100, 0x40080100, 0x100, 0x2000000, 0x42080000, 0x42080100, 0x80100, 0x42000000, 0x42080100, 0x2080000, 0, 0x40080000, 0x42000000, 0x80100, 0x2000100, 0x40000100, 0x80000, 0, 0x40080000, 0x2080100, 0x40000100];
    var spfunction6 = [0x20000010, 0x20400000, 0x4000, 0x20404010, 0x20400000, 0x10, 0x20404010, 0x400000, 0x20004000, 0x404010, 0x400000, 0x20000010, 0x400010, 0x20004000, 0x20000000, 0x4010, 0, 0x400010, 0x20004010, 0x4000, 0x404000, 0x20004010, 0x10, 0x20400010, 0x20400010, 0, 0x404010, 0x20404000, 0x4010, 0x404000, 0x20404000, 0x20000000, 0x20004000, 0x10, 0x20400010, 0x404000, 0x20404010, 0x400000, 0x4010, 0x20000010, 0x400000, 0x20004000, 0x20000000, 0x4010, 0x20000010, 0x20404010, 0x404000, 0x20400000, 0x404010, 0x20404000, 0, 0x20400010, 0x10, 0x4000, 0x20400000, 0x404010, 0x4000, 0x400010, 0x20004010, 0, 0x20404000, 0x20000000, 0x400010, 0x20004010];
    var spfunction7 = [0x200000, 0x4200002, 0x4000802, 0, 0x800, 0x4000802, 0x200802, 0x4200800, 0x4200802, 0x200000, 0, 0x4000002, 0x2, 0x4000000, 0x4200002, 0x802, 0x4000800, 0x200802, 0x200002, 0x4000800, 0x4000002, 0x4200000, 0x4200800, 0x200002, 0x4200000, 0x800, 0x802, 0x4200802, 0x200800, 0x2, 0x4000000, 0x200800, 0x4000000, 0x200800, 0x200000, 0x4000802, 0x4000802, 0x4200002, 0x4200002, 0x2, 0x200002, 0x4000000, 0x4000800, 0x200000, 0x4200800, 0x802, 0x200802, 0x4200800, 0x802, 0x4000002, 0x4200802, 0x4200000, 0x200800, 0, 0x2, 0x4200802, 0, 0x200802, 0x4200000, 0x800, 0x4000002, 0x4000800, 0x800, 0x200002];
    var spfunction8 = [0x10001040, 0x1000, 0x40000, 0x10041040, 0x10000000, 0x10001040, 0x40, 0x10000000, 0x40040, 0x10040000, 0x10041040, 0x41000, 0x10041000, 0x41040, 0x1000, 0x40, 0x10040000, 0x10000040, 0x10001000, 0x1040, 0x41000, 0x40040, 0x10040040, 0x10041000, 0x1040, 0, 0, 0x10040040, 0x10000040, 0x10001000, 0x41040, 0x40000, 0x41040, 0x40000, 0x10041000, 0x1000, 0x40, 0x10040040, 0x1000, 0x41040, 0x10001000, 0x40, 0x10000040, 0x10040000, 0x10040040, 0x10000000, 0x40000, 0x10001040, 0, 0x10041040, 0x40040, 0x10000040, 0x10040000, 0x10001000, 0x10001040, 0, 0x10041040, 0x41000, 0x41000, 0x1040, 0x1040, 0x40040, 0x10000000, 0x10041000];
    function _createKeys(key) {
      var pc2bytes0 = [0, 0x4, 0x20000000, 0x20000004, 0x10000, 0x10004, 0x20010000, 0x20010004, 0x200, 0x204, 0x20000200, 0x20000204, 0x10200, 0x10204, 0x20010200, 0x20010204],
          pc2bytes1 = [0, 0x1, 0x100000, 0x100001, 0x4000000, 0x4000001, 0x4100000, 0x4100001, 0x100, 0x101, 0x100100, 0x100101, 0x4000100, 0x4000101, 0x4100100, 0x4100101],
          pc2bytes2 = [0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808, 0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808],
          pc2bytes3 = [0, 0x200000, 0x8000000, 0x8200000, 0x2000, 0x202000, 0x8002000, 0x8202000, 0x20000, 0x220000, 0x8020000, 0x8220000, 0x22000, 0x222000, 0x8022000, 0x8222000],
          pc2bytes4 = [0, 0x40000, 0x10, 0x40010, 0, 0x40000, 0x10, 0x40010, 0x1000, 0x41000, 0x1010, 0x41010, 0x1000, 0x41000, 0x1010, 0x41010],
          pc2bytes5 = [0, 0x400, 0x20, 0x420, 0, 0x400, 0x20, 0x420, 0x2000000, 0x2000400, 0x2000020, 0x2000420, 0x2000000, 0x2000400, 0x2000020, 0x2000420],
          pc2bytes6 = [0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002, 0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002],
          pc2bytes7 = [0, 0x10000, 0x800, 0x10800, 0x20000000, 0x20010000, 0x20000800, 0x20010800, 0x20000, 0x30000, 0x20800, 0x30800, 0x20020000, 0x20030000, 0x20020800, 0x20030800],
          pc2bytes8 = [0, 0x40000, 0, 0x40000, 0x2, 0x40002, 0x2, 0x40002, 0x2000000, 0x2040000, 0x2000000, 0x2040000, 0x2000002, 0x2040002, 0x2000002, 0x2040002],
          pc2bytes9 = [0, 0x10000000, 0x8, 0x10000008, 0, 0x10000000, 0x8, 0x10000008, 0x400, 0x10000400, 0x408, 0x10000408, 0x400, 0x10000400, 0x408, 0x10000408],
          pc2bytes10 = [0, 0x20, 0, 0x20, 0x100000, 0x100020, 0x100000, 0x100020, 0x2000, 0x2020, 0x2000, 0x2020, 0x102000, 0x102020, 0x102000, 0x102020],
          pc2bytes11 = [0, 0x1000000, 0x200, 0x1000200, 0x200000, 0x1200000, 0x200200, 0x1200200, 0x4000000, 0x5000000, 0x4000200, 0x5000200, 0x4200000, 0x5200000, 0x4200200, 0x5200200],
          pc2bytes12 = [0, 0x1000, 0x8000000, 0x8001000, 0x80000, 0x81000, 0x8080000, 0x8081000, 0x10, 0x1010, 0x8000010, 0x8001010, 0x80010, 0x81010, 0x8080010, 0x8081010],
          pc2bytes13 = [0, 0x4, 0x100, 0x104, 0, 0x4, 0x100, 0x104, 0x1, 0x5, 0x101, 0x105, 0x1, 0x5, 0x101, 0x105];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0,
          tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
        right ^= tmp;
        left ^= (tmp << 4);
        tmp = ((right >>> -16) ^ left) & 0x0000ffff;
        left ^= tmp;
        right ^= (tmp << -16);
        tmp = ((left >>> 2) ^ right) & 0x33333333;
        right ^= tmp;
        left ^= (tmp << 2);
        tmp = ((right >>> -16) ^ left) & 0x0000ffff;
        left ^= tmp;
        right ^= (tmp << -16);
        tmp = ((left >>> 1) ^ right) & 0x55555555;
        right ^= tmp;
        left ^= (tmp << 1);
        tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
        left ^= tmp;
        right ^= (tmp << 8);
        tmp = ((left >>> 1) ^ right) & 0x55555555;
        right ^= tmp;
        left ^= (tmp << 1);
        tmp = (left << 8) | ((right >>> 20) & 0x000000f0);
        left = ((right << 24) | ((right << 8) & 0xff0000) | ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0));
        right = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left = (left << 2) | (left >>> 26);
            right = (right << 2) | (right >>> 26);
          } else {
            left = (left << 1) | (left >>> 27);
            right = (right << 1) | (right >>> 27);
          }
          left &= -0xf;
          right &= -0xf;
          var lefttmp = (pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf] | pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf] | pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf] | pc2bytes6[(left >>> 4) & 0xf]);
          var righttmp = (pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf] | pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf] | pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf] | pc2bytes13[(right >>> 4) & 0xf]);
          tmp = ((righttmp >>> 16) ^ lefttmp) & 0x0000ffff;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ (tmp << 16);
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = (decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2]);
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
      right ^= tmp;
      left ^= (tmp << 4);
      tmp = ((left >>> 16) ^ right) & 0x0000ffff;
      right ^= tmp;
      left ^= (tmp << 16);
      tmp = ((right >>> 2) ^ left) & 0x33333333;
      left ^= tmp;
      right ^= (tmp << 2);
      tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
      left ^= tmp;
      right ^= (tmp << 8);
      tmp = ((left >>> 1) ^ right) & 0x55555555;
      right ^= tmp;
      left ^= (tmp << 1);
      left = ((left << 1) | (left >>> 31));
      right = ((right << 1) | (right >>> 31));
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right ^ keys[i];
          var right2 = ((right >>> 4) | (right << 28)) ^ keys[i + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[(right1 >>> 24) & 0x3f] | spfunction4[(right1 >>> 16) & 0x3f] | spfunction6[(right1 >>> 8) & 0x3f] | spfunction8[right1 & 0x3f] | spfunction1[(right2 >>> 24) & 0x3f] | spfunction3[(right2 >>> 16) & 0x3f] | spfunction5[(right2 >>> 8) & 0x3f] | spfunction7[right2 & 0x3f]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = ((left >>> 1) | (left << 31));
      right = ((right >>> 1) | (right << 31));
      tmp = ((left >>> 1) ^ right) & 0x55555555;
      right ^= tmp;
      left ^= (tmp << 1);
      tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
      left ^= tmp;
      right ^= (tmp << 8);
      tmp = ((right >>> 2) ^ left) & 0x33333333;
      left ^= tmp;
      right ^= (tmp << 2);
      tmp = ((left >>> 16) ^ right) & 0x0000ffff;
      right ^= tmp;
      left ^= (tmp << 16);
      tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
      right ^= tmp;
      left ^= (tmp << 4);
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || 'CBC').toUpperCase();
      var algorithm = 'DES-' + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options) {
        var output = null;
        if (options instanceof forge.util.ByteBuffer) {
          output = options;
          options = {};
        }
        options = options || {};
        options.output = output;
        options.iv = iv;
        start.call(cipher, options);
      };
      return cipher;
    }
  }
  var name = 'des';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/des.js", ["require", "module", "npm:node-forge@0.6.30/js/cipher.js", "npm:node-forge@0.6.30/js/cipherModes.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var _nodejs = (typeof process !== 'undefined' && process.versions && process.versions.node);
    var crypto;
    if (_nodejs && !forge.disableNativeCode) {
      crypto = require('crypto');
    }
    forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === 'function') {
        callback = md;
        md = null;
      }
      if (_nodejs && !forge.disableNativeCode && crypto.pbkdf2 && (md === null || typeof md !== 'object') && (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {
        if (typeof md !== 'string') {
          md = 'sha1';
        }
        s = new Buffer(s, 'binary');
        if (!callback) {
          if (crypto.pbkdf2Sync.length === 4) {
            return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');
          }
          return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');
        }
        if (crypto.pbkdf2Sync.length === 4) {
          return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {
            if (err) {
              return callback(err);
            }
            callback(null, key.toString('binary'));
          });
        }
        return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {
          if (err) {
            return callback(err);
          }
          callback(null, key.toString('binary'));
        });
      }
      if (typeof md === 'undefined' || md === null) {
        md = forge.md.sha1.create();
      }
      if (typeof md === 'string') {
        if (!(md in forge.md.algorithms)) {
          throw new Error('Unknown hash algorithm: ' + md);
        }
        md = forge.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > (0xFFFFFFFF * hLen)) {
        var err = new Error('Derived key is too long.');
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md, p);
      var dk = '';
      var xor,
          u_c,
          u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge.util.int32ToBytes(i));
          xor = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += (i < len) ? xor : xor.substr(0, r);
        }
        return dk;
      }
      var i = 1,
          j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge.util.setImmediate(inner);
        }
        dk += (i < len) ? xor : xor.substr(0, r);
        ++i;
        outer();
      }
      outer();
    };
  }
  var name = 'pbkdf2';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pbkdf2.js", ["require", "module", "npm:node-forge@0.6.30/js/hmac.js", "npm:node-forge@0.6.30/js/md.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var _nodejs = (typeof process !== 'undefined' && process.versions && process.versions.node);
    var _crypto = null;
    if (!forge.disableNativeCode && _nodejs && !process.versions['node-webkit']) {
      _crypto = require('crypto');
    }
    var prng = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin: plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 0xfffff) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 0xfffff) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = (32 - ctx.pools[0].messageLength) << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = (32 - ctx.pools[0].messageLength) << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        var md = ctx.plugin.md.create();
        md.update(ctx.pools[0].digest().getBytes());
        ctx.pools[0].start();
        var k = 1;
        for (var i = 1; i < 32; ++i) {
          k = (k === 31) ? 0x80000000 : (k << 2);
          if (k % ctx.reseeds === 0) {
            md.update(ctx.pools[i].digest().getBytes());
            ctx.pools[i].start();
          }
        }
        var keyBytes = md.digest().getBytes();
        md.start();
        md.update(keyBytes);
        var seedBytes = md.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        if (typeof window !== 'undefined') {
          var _crypto = window.crypto || window.msCrypto;
          if (_crypto && _crypto.getRandomValues) {
            getRandomValues = function(arr) {
              return _crypto.getRandomValues(arr);
            };
          }
        }
        var b = forge.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i = 0; i < entropy.length; ++i) {
                b.putInt32(entropy[i]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== 'undefined' && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi,
              lo,
              next;
          var seed = Math.floor(Math.random() * 0x010000);
          while (b.length() < needed) {
            lo = 16807 * (seed & 0xFFFF);
            hi = 16807 * (seed >> 16);
            lo += (hi & 0x7FFF) << 16;
            lo += hi >> 15;
            lo = (lo & 0x7FFFFFFF) + (lo >> 31);
            seed = lo & 0xFFFFFFFF;
            for (var i = 0; i < 3; ++i) {
              next = seed >>> (i << 3);
              next ^= Math.floor(Math.random() * 0x0100);
              b.putByte(String.fromCharCode(next & 0xFF));
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i = 0; i < count; ++i) {
          ctx.pools[ctx.pool].update(bytes.substr(i, 1));
          ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i, n) {
        var bytes = '';
        for (var x = 0; x < n; x += 8) {
          bytes += String.fromCharCode((i >> x) & 0xFF);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener('message', listener);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener('message', listener);
            self.postMessage({forge: {prng: {needed: needed}}});
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({forge: {prng: {
                      err: err,
                      bytes: bytes
                    }}});
              });
            }
          };
          worker.addEventListener('message', listener);
        }
      };
      return ctx;
    };
  }
  var name = 'prng';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/prng.js", ["require", "module", "npm:node-forge@0.6.30/js/md.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var piTable = [0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d, 0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2, 0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32, 0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82, 0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc, 0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26, 0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03, 0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7, 0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a, 0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec, 0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39, 0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31, 0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9, 0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9, 0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e, 0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad];
    var s = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return ((word << bits) & 0xffff) | ((word & 0xffff) >> (16 - bits));
    };
    var ror = function(word, bits) {
      return ((word & 0xffff) >> bits) | ((word << (16 - bits)) & 0xffff);
    };
    forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === 'string') {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 0xff >> (T1 & 0x07);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[(L.at(i - 1) + L.at(i - T)) & 0xff]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher = function(key, bits, encrypt) {
      var _finish = false,
          _input = null,
          _output = null,
          _iv = null;
      var mixRound,
          mashRound;
      var i,
          j,
          K = [];
      key = forge.rc2.expandKey(key, bits);
      for (i = 0; i < 64; i++) {
        K.push(key.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);
            R[i] = rol(R[i], s[i]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[R[(i + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s[i]);
            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K[R[(i + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 0xffff);
        }
        j = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      };
      var cipher = null;
      cipher = {
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === 'string') {
              iv = forge.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([[5, mixRound], [1, mashRound], [6, mixRound], [1, mashRound], [5, mixRound]]);
          }
        },
        finish: function(pad) {
          var rval = true;
          if (encrypt) {
            if (pad) {
              rval = pad(8, _input, !encrypt);
            } else {
              var padding = (_input.length() === 8) ? 8 : (8 - _input.length());
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = (_input.length() === 0);
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
  var name = 'rc2';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/rc2.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var dbits;
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary & 0xffffff) == 0xefcafe);
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a)
          this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i++] + w.data[j] + c;
        c = Math.floor(v / 0x4000000);
        w.data[j++] = v & 0x3ffffff;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 0x7fff,
          xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 0x7fff;
        var h = this.data[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x7fff) << 15) + w.data[j] + (c & 0x3fffffff);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 0x3fffffff;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 0x3fff,
          xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 0x3fff;
        var h = this.data[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x3fff) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 0xfffffff;
      }
      return c;
    }
    if (typeof(navigator) === 'undefined') {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1 << dbits) - 1);
    BigInteger.prototype.DV = (1 << dbits);
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,
        vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c == null) ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r.data[i] = this.data[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x < 0) ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length,
          mi = false,
          sh = 0;
      while (--i >= 0) {
        var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
          this.data[this.t++] = (x >> (this.DB - sh));
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 0x80) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1,
          d,
          m = false,
          r = "",
          i = this.t;
      var p = this.DB - (i * this.DB) % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this.data[i] & ((1 << p) - 1)) << (k - p);
            d |= this.data[--i] >> (p += this.DB - k);
          } else {
            d = (this.data[i] >> (p -= k)) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return (this.s < 0) ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return (this.s < 0) ? -r : r;
      while (--i >= 0)
        if ((r = this.data[i] - a.data[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1,
          t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ (this.s & this.DM));
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i)
        r.data[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r.data[i - n] = this.data[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB),
          c = (this.s << bs) & this.DM,
          i;
      for (i = this.t - 1; i >= 0; --i) {
        r.data[i + ds + 1] = (this.data[i] >> cbs) | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r.data[i] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
        r.data[i - ds] = this.data[i] >> bs;
      }
      if (bs > 0)
        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0,
          c = 0,
          m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] - a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c < 0) ? -1 : 0;
      if (c < -1)
        r.data[i++] = this.DV + c;
      else if (c > 0)
        r.data[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(),
          y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < y.t; ++i)
        r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r.data[i + x.t] -= x.DV;
          r.data[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(),
          ts = this.s,
          ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + ((ys > 1) ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt,
          d2 = (1 << this.F1) / yt,
          e = 1 << this.F2;
      var i = r.t,
          j = i - ys,
          t = (q == null) ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = (r.data[--i] == y0) ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = (y * (2 - (x & 0xf) * y)) & 0xf;
      y = (y * (2 - (x & 0xff) * y)) & 0xff;
      y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;
      y = (y * (2 - x * y % this.DV)) % this.DV;
      return (y > 0) ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 0x7fff;
      this.mph = this.mp >> 15;
      this.um = (1 << (m.DB - 15)) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 0x7fff;
        var u0 = (j * this.mpl + (((j * this.mph + (x.data[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return ((this.t > 0) ? (this.data[0] & 1) : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 0xffffffff || e < 1)
        return BigInteger.ONE;
      var r = nbi(),
          r2 = nbi(),
          g = z.convert(this),
          i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & (1 << i)) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return ((this.data[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this.data[0];
    }
    function bnByteValue() {
      return (this.t == 0) ? this.s : (this.data[0] << 24) >> 24;
    }
    function bnShortValue() {
      return (this.t == 0) ? this.s : (this.data[0] << 16) >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || (this.t == 1 && this.data[0] <= 0))
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a),
          y = nbi(),
          z = nbi(),
          r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs),
          mi = false,
          j = 0,
          w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(),
            t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= ((1 << t) - 1);
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t,
          r = new Array();
      r[0] = this.s;
      var p = this.DB - (i * this.DB) % 8,
          d,
          k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | (this.s << (this.DB - p));
        while (i >= 0) {
          if (p < 8) {
            d = (this.data[i] & ((1 << p) - 1)) << (8 - p);
            d |= this.data[--i] >> (p += this.DB - 8);
          } else {
            d = (this.data[i] >> (p -= 8)) & 0xff;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 0x80) != 0)
            d |= -256;
          if (k == 0 && (this.s & 0x80) != (d & 0x80))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return (this.compareTo(a) == 0);
    }
    function bnMin(a) {
      return (this.compareTo(a) < 0) ? this : a;
    }
    function bnMax(a) {
      return (this.compareTo(a) > 0) ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i,
          f,
          m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r.data[i] = op(this.data[i], a.data[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r.data[i] = op(this.data[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r.data[i] = op(f, a.data[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r.data[i] = this.DM & ~this.data[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 0xffff) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 0xff) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 0xf) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0)
          return i * this.DB + lbit(this.data[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0,
          x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this.data[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return (this.s != 0);
      return ((this.data[j] & (1 << (n % this.DB))) != 0);
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0,
          c = 0,
          m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] + a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c < 0) ? -1 : 0;
      if (c > 0)
        r.data[i++] = c;
      else if (c < -1)
        r.data[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(),
          r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {}
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r.data[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a.data[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(),
          k,
          r = nbv(1),
          z;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(),
          n = 3,
          k1 = k - 1,
          km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1,
          w,
          is1 = true,
          r2 = nbi(),
          t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = (e.data[j] >> (i - k1)) & km;
        else {
          w = (e.data[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
          if (j > 0)
            w |= e.data[j - 1] >> (this.DB + i - k1);
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & (1 << i)) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = (this.s < 0) ? this.negate() : this.clone();
      var y = (a.s < 0) ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(),
          g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n,
          r = (this.s < 0) ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this.data[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this.data[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if ((this.isEven() && ac) || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(),
          v = this.clone();
      var a = nbv(1),
          b = nbv(0),
          c = nbv(0),
          d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i,
          x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i],
            j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i = 0; i < t; ++i) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {nextBytes: function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 0x0100);
          }
        }};
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    forge.jsbn = forge.jsbn || {};
    forge.jsbn.BigInteger = BigInteger;
  }
  var name = 'jsbn';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/jsbn.js", ["require", "module"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var pkcs1 = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === 'string') {
        label = options;
        seed = arguments[3] || undefined;
        md = arguments[4] || undefined;
      } else if (options) {
        label = options.label || undefined;
        seed = options.seed || undefined;
        md = options.md || undefined;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error('RSAES-OAEP input message length is too long.');
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = '';
      }
      md.update(label, 'raw');
      var lHash = md.digest();
      var PS = '';
      var PS_length = maxLength - message.length;
      for (var i = 0; i < PS_length; i++) {
        PS += '\x00';
      }
      var DB = lHash.getBytes() + PS + '\x01' + message;
      if (!seed) {
        seed = forge.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' + 'match the digest length.');
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return '\x00' + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === 'string') {
        label = options;
        md = arguments[3] || undefined;
      } else if (options) {
        label = options.label || undefined;
        md = options.md || undefined;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error('RSAES-OAEP encoded message length is invalid.');
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === undefined) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error('RSAES-OAEP key is too short for the hash function.');
      }
      if (!label) {
        label = '';
      }
      md.update(label, 'raw');
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = (y !== '\x00');
      for (var i = 0; i < md.digestLength; ++i) {
        error |= (lHash.charAt(i) !== lHashPrime.charAt(i));
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code = db.charCodeAt(j);
        var is_0 = (code & 0x1) ^ 0x1;
        var error_mask = in_ps ? 0xfffe : 0x0000;
        error |= (code & error_mask);
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 0x1) {
        throw new Error('Invalid RSAES-OAEP padding.');
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash) {
      if (!hash) {
        hash = forge.md.sha1.create();
      }
      var t = '';
      var count = Math.ceil(maskLength / hash.digestLength);
      for (var i = 0; i < count; ++i) {
        var c = String.fromCharCode((i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);
        hash.start();
        hash.update(seed + c);
        t += hash.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
  var name = 'pkcs1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pkcs1.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/sha1.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    if (forge.prime) {
      return;
    }
    var prime = forge.prime = forge.prime || {};
    var BigInteger = forge.jsbn.BigInteger;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    var op_or = function(x, y) {
      return x | y;
    };
    prime.generateProbablePrime = function(bits, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      var algorithm = options.algorithm || 'PRIMEINC';
      if (typeof algorithm === 'string') {
        algorithm = {name: algorithm};
      }
      algorithm.options = algorithm.options || {};
      var prng = options.prng || forge.random;
      var rng = {nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }};
      if (algorithm.name === 'PRIMEINC') {
        return primeincFindPrime(bits, rng, algorithm.options, callback);
      }
      throw new Error('Invalid prime generation algorithm: ' + algorithm.name);
    };
    function primeincFindPrime(bits, rng, options, callback) {
      if ('workers' in options) {
        return primeincFindPrimeWithWorkers(bits, rng, options, callback);
      }
      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    }
    function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
      var num = generateRandom(bits, rng);
      var deltaIdx = 0;
      var mrTests = getMillerRabinTests(num.bitLength());
      if ('millerRabinTests' in options) {
        mrTests = options.millerRabinTests;
      }
      var maxBlockTime = 10;
      if ('maxBlockTime' in options) {
        maxBlockTime = options.maxBlockTime;
      }
      var start = +new Date();
      do {
        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng);
        }
        if (num.isProbablePrime(mrTests)) {
          return callback(null, num);
        }
        num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
      } while (maxBlockTime < 0 || (+new Date() - start < maxBlockTime));
      forge.util.setImmediate(function() {
        primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      });
    }
    function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
      if (typeof Worker === 'undefined') {
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      var num = generateRandom(bits, rng);
      var numWorkers = options.workers;
      var workLoad = options.workLoad || 100;
      var range = workLoad * 30 / 8;
      var workerScript = options.workerScript || 'forge/prime.worker.js';
      if (numWorkers === -1) {
        return forge.util.estimateCores(function(err, cores) {
          if (err) {
            cores = 2;
          }
          numWorkers = cores - 1;
          generate();
        });
      }
      generate();
      function generate() {
        numWorkers = Math.max(1, numWorkers);
        var workers = [];
        for (var i = 0; i < numWorkers; ++i) {
          workers[i] = new Worker(workerScript);
        }
        var running = numWorkers;
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].addEventListener('message', workerMessage);
        }
        var found = false;
        function workerMessage(e) {
          if (found) {
            return;
          }
          --running;
          var data = e.data;
          if (data.found) {
            for (var i = 0; i < workers.length; ++i) {
              workers[i].terminate();
            }
            found = true;
            return callback(null, new BigInteger(data.prime, 16));
          }
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          var hex = num.toString(16);
          e.target.postMessage({
            hex: hex,
            workLoad: workLoad
          });
          num.dAddOffset(range, 0);
        }
      }
    }
    function generateRandom(bits, rng) {
      var num = new BigInteger(bits, rng);
      var bits1 = bits - 1;
      if (!num.testBit(bits1)) {
        num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
      }
      num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
      return num;
    }
    function getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
  }
  var name = 'prime';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/prime.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js", "npm:node-forge@0.6.30/js/jsbn.js", "npm:node-forge@0.6.30/js/random.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var p7v = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
    forge.pkcs7 = forge.pkcs7 || {};
    forge.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: 'ContentInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'ContentInfo.ContentType',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'contentType'
      }, {
        name: 'ContentInfo.content',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: 'content'
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: 'EncryptedContentInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'EncryptedContentInfo.contentType',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'contentType'
      }, {
        name: 'EncryptedContentInfo.contentEncryptionAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'encAlgorithm'
        }, {
          name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: 'encParameter'
        }]
      }, {
        name: 'EncryptedContentInfo.encryptedContent',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: 'encryptedContent',
        captureAsn1: 'encryptedContentAsn1'
      }]
    };
    p7v.envelopedDataValidator = {
      name: 'EnvelopedData',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'EnvelopedData.Version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }, {
        name: 'EnvelopedData.RecipientInfos',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: 'recipientInfos'
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: 'EncryptedData',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'EncryptedData.Version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: 'SignerInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'SignerInfo.Version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: 'SignerInfo.IssuerAndSerialNumber',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true
      }, {
        name: 'SignerInfo.DigestAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true
      }, {
        name: 'SignerInfo.AuthenticatedAttributes',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: 'authenticatedAttributes'
      }, {
        name: 'SignerInfo.DigestEncryptionAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true
      }, {
        name: 'SignerInfo.EncryptedDigest',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'signature'
      }, {
        name: 'SignerInfo.UnauthenticatedAttributes',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true
      }]
    };
    p7v.signedDataValidator = {
      name: 'SignedData',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'SignedData.Version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }, {
        name: 'SignedData.DigestAlgorithms',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: 'digestAlgorithms'
      }, contentInfoValidator, {
        name: 'SignedData.Certificates',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        optional: true,
        captureAsn1: 'certificates'
      }, {
        name: 'SignedData.CertificateRevocationLists',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        optional: true,
        captureAsn1: 'crls'
      }, {
        name: 'SignedData.SignerInfos',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        capture: 'signerInfos',
        optional: true,
        value: [signerValidator]
      }]
    };
    p7v.recipientInfoValidator = {
      name: 'RecipientInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'RecipientInfo.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }, {
        name: 'RecipientInfo.issuerAndSerial',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'RecipientInfo.issuerAndSerial.issuer',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'issuer'
        }, {
          name: 'RecipientInfo.issuerAndSerial.serialNumber',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: 'serial'
        }]
      }, {
        name: 'RecipientInfo.keyEncryptionAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'encAlgorithm'
        }, {
          name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: 'encParameter'
        }]
      }, {
        name: 'RecipientInfo.encryptedKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'encKey'
      }]
    };
  }
  var name = 'pkcs7asn1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pkcs7asn1.js", ["require", "module", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.mgf = forge.mgf || {};
    var mgf1 = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {generate: function(seed, maskLen) {
          var t = new forge.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }};
      return mgf;
    };
  }
  var name = 'mgf1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/mgf1.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var pss = forge.pss = forge.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash = options.md;
      var mgf = options.mgf;
      var hLen = hash.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === 'string') {
        salt_ = forge.util.createBuffer(salt_);
      }
      var sLen;
      if ('saltLength' in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error('Salt length not specified or specific salt not given.');
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error('Given salt length does not match length of given salt.');
      }
      var prng = options.prng || forge.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error('Message is too long to encrypt.');
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h = hash.digest().getBytes();
        var ps = new forge.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(0x01);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = '';
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(0xbc);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error('Inconsistent parameters to PSS signature verification.');
        }
        if (em.charCodeAt(emLen - 1) !== 0xbc) {
          throw new Error('Encoded message does not end in 0xBC.');
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error('Bits beyond keysize not zero as expected.');
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = '';
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen; i++) {
          if (db.charCodeAt(i) !== 0x00) {
            throw new Error('Leftmost octets not zero as expected');
          }
        }
        if (db.charCodeAt(checkLen) !== 0x01) {
          throw new Error('Inconsistent PSS signature, 0x01 marker not found');
        }
        var salt = db.substr(-sLen);
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h_ = hash.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
  var name = 'pss';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pss.js", ["require", "module", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.debug = forge.debug || {};
    forge.debug.storage = {};
    forge.debug.get = function(cat, name) {
      var rval;
      if (typeof(cat) === 'undefined') {
        rval = forge.debug.storage;
      } else if (cat in forge.debug.storage) {
        if (typeof(name) === 'undefined') {
          rval = forge.debug.storage[cat];
        } else {
          rval = forge.debug.storage[cat][name];
        }
      }
      return rval;
    };
    forge.debug.set = function(cat, name, data) {
      if (!(cat in forge.debug.storage)) {
        forge.debug.storage[cat] = {};
      }
      forge.debug.storage[cat][name] = data;
    };
    forge.debug.clear = function(cat, name) {
      if (typeof(cat) === 'undefined') {
        forge.debug.storage = {};
      } else if (cat in forge.debug.storage) {
        if (typeof(name) === 'undefined') {
          delete forge.debug.storage[cat];
        } else {
          delete forge.debug.storage[cat][name];
        }
      }
    };
  }
  var name = 'debug';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/debug.js", ["require", "module"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.kem = forge.kem || {};
    var BigInteger = forge.jsbn.BigInteger;
    forge.kem.rsa = {};
    forge.kem.rsa.create = function(kdf, options) {
      options = options || {};
      var prng = options.prng || forge.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
        var r;
        do {
          r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);
        } while (r.equals(BigInteger.ZERO));
        r = forge.util.hexToBytes(r.toString(16));
        var zeros = byteLength - r.length;
        if (zeros > 0) {
          r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
        }
        var encapsulation = publicKey.encrypt(r, 'NONE');
        var key = kdf.generate(r, keyLength);
        return {
          encapsulation: encapsulation,
          key: key
        };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r = privateKey.decrypt(encapsulation, 'NONE');
        return kdf.generate(r, keyLength);
      };
      return kem;
    };
    forge.kem.kdf1 = function(md, digestLength) {
      _createKDF(this, md, 0, digestLength || md.digestLength);
    };
    forge.kem.kdf2 = function(md, digestLength) {
      _createKDF(this, md, 1, digestLength || md.digestLength);
    };
    function _createKDF(kdf, md, counterStart, digestLength) {
      kdf.generate = function(x, length) {
        var key = new forge.util.ByteBuffer();
        var k = Math.ceil(length / digestLength) + counterStart;
        var c = new forge.util.ByteBuffer();
        for (var i = counterStart; i < k; ++i) {
          c.putInt32(i);
          md.start();
          md.update(x + c.getBytes());
          var hash = md.digest();
          key.putBytes(hash.getBytes(digestLength));
        }
        key.truncate(key.length() - length);
        return key.getBytes();
      };
    }
  }
  var name = 'kem';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/kem.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/jsbn.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.log = forge.log || {};
    forge.log.levels = ['none', 'error', 'warning', 'info', 'debug', 'verbose', 'max'];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge.log.LEVEL_LOCKED = (1 << 1);
    forge.log.NO_LEVEL_CHECK = (1 << 2);
    forge.log.INTERPOLATE = (1 << 3);
    for (var i = 0; i < forge.log.levels.length; ++i) {
      var level = forge.log.levels[i];
      sLevelInfo[level] = {
        index: i,
        name: level.toUpperCase()
      };
    }
    forge.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i = 0; i < sLoggers.length; ++i) {
        var logger = sLoggers[i];
        if (logger.flags & forge.log.NO_LEVEL_CHECK) {
          logger.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger.f(logger, message);
          }
        }
      }
    };
    forge.log.prepareStandard = function(message) {
      if (!('standard' in message)) {
        message.standard = sLevelInfo[message.level].name + ' [' + message.category + '] ' + message.message;
      }
    };
    forge.log.prepareFull = function(message) {
      if (!('full' in message)) {
        var args = [message.message];
        args = args.concat([] || message['arguments']);
        message.full = forge.util.format.apply(this, args);
      }
    };
    forge.log.prepareStandardFull = function(message) {
      if (!('standardFull' in message)) {
        forge.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    if (true) {
      var levels = ['error', 'warning', 'info', 'debug', 'verbose'];
      for (var i = 0; i < levels.length; ++i) {
        (function(level) {
          forge.log[level] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: new Date(),
              level: level,
              category: category,
              message: message,
              'arguments': args
            };
            forge.log.logMessage(msg);
          };
        })(levels[i]);
      }
    }
    forge.log.makeLogger = function(logFunction) {
      var logger = {
        flags: 0,
        f: logFunction
      };
      forge.log.setLevel(logger, 'none');
      return logger;
    };
    forge.log.setLevel = function(logger, level) {
      var rval = false;
      if (logger && !(logger.flags & forge.log.LEVEL_LOCKED)) {
        for (var i = 0; i < forge.log.levels.length; ++i) {
          var aValidLevel = forge.log.levels[i];
          if (level == aValidLevel) {
            logger.level = level;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge.log.lock = function(logger, lock) {
      if (typeof lock === 'undefined' || lock) {
        logger.flags |= forge.log.LEVEL_LOCKED;
      } else {
        logger.flags &= ~forge.log.LEVEL_LOCKED;
      }
    };
    forge.log.addLogger = function(logger) {
      sLoggers.push(logger);
    };
    if (typeof(console) !== 'undefined' && 'log' in console) {
      var logger;
      if (console.error && console.warn && console.info && console.debug) {
        var levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        var f = function(logger, message) {
          forge.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message['arguments'].slice());
          handler.apply(console, args);
        };
        logger = forge.log.makeLogger(f);
      } else {
        var f = function(logger, message) {
          forge.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger = forge.log.makeLogger(f);
      }
      forge.log.setLevel(logger, 'debug');
      forge.log.addLogger(logger);
      sConsoleLogger = logger;
    } else {
      console = {log: function() {}};
    }
    if (sConsoleLogger !== null) {
      var query = forge.util.getQueryVariables();
      if ('console.level' in query) {
        forge.log.setLevel(sConsoleLogger, query['console.level'].slice(-1)[0]);
      }
      if ('console.lock' in query) {
        var lock = query['console.lock'].slice(-1)[0];
        if (lock == 'true') {
          forge.log.lock(sConsoleLogger);
        }
      }
    }
    forge.log.consoleLogger = sConsoleLogger;
  }
  var name = 'log';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/log.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var p7 = forge.pkcs7 = forge.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'PKCS7') {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM ' + 'header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: 'PKCS7',
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge.pem.encode(pemObj, {maxline: maxline});
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#7 message. ' + 'ASN.1 object is not an PKCS#7 ContentInfo.');
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error('Cannot read PKCS#7 message. ContentType with OID ' + contentType + ' is not (yet) supported.');
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    var _recipientInfoFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#7 message. ' + 'ASN.1 object is not an PKCS#7 EnvelopedData.');
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter.value,
          content: capture.encKey
        }
      };
    };
    var _recipientInfoToAsn1 = function(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)]);
    };
    var _recipientInfosFromAsn1 = function(objArr) {
      var ret = [];
      for (var i = 0; i < objArr.length; i++) {
        ret.push(_recipientInfoFromAsn1(objArr[i]));
      }
      return ret;
    };
    var _recipientInfosToAsn1 = function(recipientsArr) {
      var ret = [];
      for (var i = 0; i < recipientsArr.length; i++) {
        ret.push(_recipientInfoToAsn1(recipientsArr[i]));
      }
      return ret;
    };
    var _encryptedContentToAsn1 = function(ec) {
      return [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())]), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())])];
    };
    var _fromAsn1 = function(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error('Cannot read PKCS#7 message. ' + 'ASN.1 object is not a supported PKCS#7 message.');
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge.pki.oids.data) {
        throw new Error('Unsupported PKCS#7 message. ' + 'Only wrapped ContentType Data supported.');
      }
      if (capture.encryptedContent) {
        var content = '';
        if (forge.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error('Malformed PKCS#7 message, expecting encrypted ' + 'content constructed of only OCTET STRING objects.');
            }
            content += capture.encryptedContent[i].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge.util.createBuffer(capture.encParameter.value),
          content: forge.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = '';
        if (forge.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error('Malformed PKCS#7 message, expecting ' + 'content constructed of only OCTET STRING objects.');
            }
            content += capture.content[i].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    };
    var _decryptContent = function(msg) {
      if (msg.encryptedContent.key === undefined) {
        throw new Error('Symmetric key not available.');
      }
      if (msg.content === undefined) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge.pki.oids['aes128-CBC']:
          case forge.pki.oids['aes192-CBC']:
          case forge.pki.oids['aes256-CBC']:
            ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge.pki.oids['desCBC']:
          case forge.pki.oids['des-EDE3-CBC']:
            ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error('Unsupported symmetric cipher, OID ' + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error('Symmetric decryption failed.');
        }
        msg.content = ciph.output;
      }
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          var certs = msg.rawCapture.certificates.value;
          for (var i = 0; i < certs.length; ++i) {
            msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
          }
        },
        toAsn1: function() {
          if ('content' in msg) {
            throw new Error('Signing PKCS#7 content not yet implemented.');
          }
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge.pki.certificateToAsn1(msg.certificates[0]));
          }
          var crls = [];
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers), msg.contentInfo, asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos)])])]);
        },
        sign: function(signer) {
          if ('content' in msg) {
            throw new Error('PKCS#7 signing not yet implemented.');
          }
          if (typeof msg.content !== 'object') {
            msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())]);
            if ('content' in msg) {
              msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, msg.content)]));
            }
          }
        },
        verify: function() {
          throw new Error('PKCS#7 signature verification not yet implemented.');
        },
        addCertificate: function(cert) {
          if (typeof cert === 'string') {
            cert = forge.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        addCertificateRevokationList: function(crl) {
          throw new Error('PKCS#7 CRL support not yet implemented.');
        }
      };
      return msg;
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {algorithm: forge.pki.oids['aes256-CBC']},
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        decrypt: function(key) {
          if (key !== undefined) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {algorithm: forge.pki.oids['aes256-CBC']},
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientInfosFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientInfosToAsn1(msg.recipients)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))])])]);
        },
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r = msg.recipients[i];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === undefined && recipient !== undefined && privKey !== undefined) {
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
              case forge.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge.util.createBuffer(key);
                break;
              default:
                throw new Error('Unsupported asymmetric cipher, ' + 'OID ' + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              algorithm: forge.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === undefined) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen,
                ivLen,
                ciphFn;
            switch (cipher) {
              case forge.pki.oids['aes128-CBC']:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids['aes192-CBC']:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids['aes256-CBC']:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids['des-EDE3-CBC']:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge.des.createEncryptionCipher;
                break;
              default:
                throw new Error('Unsupported symmetric cipher, OID ' + cipher);
            }
            if (key === undefined) {
              key = forge.util.createBuffer(forge.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error('Symmetric key has wrong length; ' + 'got ' + key.length() + ' bytes, expected ' + keyLen + '.');
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error('Symmetric encryption failed.');
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; i++) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== undefined) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
                break;
              default:
                throw new Error('Unsupported asymmetric cipher, OID ' + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
  }
  var name = 'pkcs7';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pkcs7.js", ["require", "module", "npm:node-forge@0.6.30/js/aes.js", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/des.js", "npm:node-forge@0.6.30/js/oids.js", "npm:node-forge@0.6.30/js/pem.js", "npm:node-forge@0.6.30/js/pkcs7asn1.js", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/util.js", "npm:node-forge@0.6.30/js/x509.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var ssh = forge.ssh = forge.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || '';
      passphrase = passphrase || '';
      var algorithm = 'ssh-rsa';
      var encryptionAlgorithm = (passphrase === '') ? 'none' : 'aes256-cbc';
      var ppk = 'PuTTY-User-Key-File-2: ' + algorithm + '\r\n';
      ppk += 'Encryption: ' + encryptionAlgorithm + '\r\n';
      ppk += 'Comment: ' + comment + '\r\n';
      var pubbuffer = forge.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge.util.encode64(pubbuffer.bytes(), 64);
      var length = Math.floor(pub.length / 66) + 1;
      ppk += 'Public-Lines: ' + length + '\r\n';
      ppk += pub;
      var privbuffer = forge.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding = _sha1(privbuffer.bytes());
        padding.truncate(padding.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding);
        var aeskey = forge.util.createBuffer();
        aeskey.putBuffer(_sha1('\x00\x00\x00\x00', passphrase));
        aeskey.putBuffer(_sha1('\x00\x00\x00\x01', passphrase));
        var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), 'CBC');
        cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge.util.encode64(encrypted.bytes(), 64);
      }
      length = Math.floor(priv.length / 66) + 1;
      ppk += '\r\nPrivate-Lines: ' + length + '\r\n';
      ppk += priv;
      var mackey = _sha1('putty-private-key-file-mac-key', passphrase);
      var macbuffer = forge.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac = forge.hmac.create();
      hmac.start('sha1', mackey);
      hmac.update(macbuffer.bytes());
      ppk += '\r\nPrivate-MAC: ' + hmac.digest().toHex() + '\r\n';
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key, comment) {
      var type = 'ssh-rsa';
      comment = comment || '';
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      return type + ' ' + forge.util.encode64(buffer.bytes()) + ' ' + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge.pki.privateKeyToPem(privateKey);
      }
      return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, {
        legacy: true,
        algorithm: 'aes128'
      });
    };
    ssh.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.md5.create();
      var type = 'ssh-rsa';
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      md.start();
      md.update(buffer.getBytes());
      var digest = md.digest();
      if (options.encoding === 'hex') {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === 'binary') {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    function _addBigIntegerToBuffer(buffer, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= '8') {
        hexVal = '00' + hexVal;
      }
      var bytes = forge.util.hexToBytes(hexVal);
      buffer.putInt32(bytes.length);
      buffer.putBytes(bytes);
    }
    function _addStringToBuffer(buffer, val) {
      buffer.putInt32(val.length);
      buffer.putString(val);
    }
    function _sha1() {
      var sha = forge.md.sha1.create();
      var num = arguments.length;
      for (var i = 0; i < num; ++i) {
        sha.update(arguments[i]);
      }
      return sha.digest();
    }
  }
  var name = 'ssh';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/ssh.js", ["require", "module", "npm:node-forge@0.6.30/js/aes.js", "npm:node-forge@0.6.30/js/hmac.js", "npm:node-forge@0.6.30/js/md5.js", "npm:node-forge@0.6.30/js/sha1.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var cat = 'forge.task';
    var sVL = 0;
    var sTasks = {};
    var sNextTaskId = 0;
    forge.debug.set(cat, 'tasks', sTasks);
    var sTaskQueues = {};
    forge.debug.set(cat, 'queues', sTaskQueues);
    var sNoTaskName = '?';
    var sMaxRecursions = 30;
    var sTimeSlice = 20;
    var READY = 'ready';
    var RUNNING = 'running';
    var BLOCKED = 'blocked';
    var SLEEPING = 'sleeping';
    var DONE = 'done';
    var ERROR = 'error';
    var STOP = 'stop';
    var START = 'start';
    var BLOCK = 'block';
    var UNBLOCK = 'unblock';
    var SLEEP = 'sleep';
    var WAKEUP = 'wakeup';
    var CANCEL = 'cancel';
    var FAIL = 'fail';
    var sStateTable = {};
    sStateTable[READY] = {};
    sStateTable[READY][STOP] = READY;
    sStateTable[READY][START] = RUNNING;
    sStateTable[READY][CANCEL] = DONE;
    sStateTable[READY][FAIL] = ERROR;
    sStateTable[RUNNING] = {};
    sStateTable[RUNNING][STOP] = READY;
    sStateTable[RUNNING][START] = RUNNING;
    sStateTable[RUNNING][BLOCK] = BLOCKED;
    sStateTable[RUNNING][UNBLOCK] = RUNNING;
    sStateTable[RUNNING][SLEEP] = SLEEPING;
    sStateTable[RUNNING][WAKEUP] = RUNNING;
    sStateTable[RUNNING][CANCEL] = DONE;
    sStateTable[RUNNING][FAIL] = ERROR;
    sStateTable[BLOCKED] = {};
    sStateTable[BLOCKED][STOP] = BLOCKED;
    sStateTable[BLOCKED][START] = BLOCKED;
    sStateTable[BLOCKED][BLOCK] = BLOCKED;
    sStateTable[BLOCKED][UNBLOCK] = BLOCKED;
    sStateTable[BLOCKED][SLEEP] = BLOCKED;
    sStateTable[BLOCKED][WAKEUP] = BLOCKED;
    sStateTable[BLOCKED][CANCEL] = DONE;
    sStateTable[BLOCKED][FAIL] = ERROR;
    sStateTable[SLEEPING] = {};
    sStateTable[SLEEPING][STOP] = SLEEPING;
    sStateTable[SLEEPING][START] = SLEEPING;
    sStateTable[SLEEPING][BLOCK] = SLEEPING;
    sStateTable[SLEEPING][UNBLOCK] = SLEEPING;
    sStateTable[SLEEPING][SLEEP] = SLEEPING;
    sStateTable[SLEEPING][WAKEUP] = SLEEPING;
    sStateTable[SLEEPING][CANCEL] = DONE;
    sStateTable[SLEEPING][FAIL] = ERROR;
    sStateTable[DONE] = {};
    sStateTable[DONE][STOP] = DONE;
    sStateTable[DONE][START] = DONE;
    sStateTable[DONE][BLOCK] = DONE;
    sStateTable[DONE][UNBLOCK] = DONE;
    sStateTable[DONE][SLEEP] = DONE;
    sStateTable[DONE][WAKEUP] = DONE;
    sStateTable[DONE][CANCEL] = DONE;
    sStateTable[DONE][FAIL] = ERROR;
    sStateTable[ERROR] = {};
    sStateTable[ERROR][STOP] = ERROR;
    sStateTable[ERROR][START] = ERROR;
    sStateTable[ERROR][BLOCK] = ERROR;
    sStateTable[ERROR][UNBLOCK] = ERROR;
    sStateTable[ERROR][SLEEP] = ERROR;
    sStateTable[ERROR][WAKEUP] = ERROR;
    sStateTable[ERROR][CANCEL] = ERROR;
    sStateTable[ERROR][FAIL] = ERROR;
    var Task = function(options) {
      this.id = -1;
      this.name = options.name || sNoTaskName;
      this.parent = options.parent || null;
      this.run = options.run;
      this.subtasks = [];
      this.error = false;
      this.state = READY;
      this.blocks = 0;
      this.timeoutId = null;
      this.swapTime = null;
      this.userData = null;
      this.id = sNextTaskId++;
      sTasks[this.id] = this;
      if (sVL >= 1) {
        forge.log.verbose(cat, '[%s][%s] init', this.id, this.name, this);
      }
    };
    Task.prototype.debug = function(msg) {
      msg = msg || '';
      forge.log.debug(cat, msg, '[%s][%s] task:', this.id, this.name, this, 'subtasks:', this.subtasks.length, 'queue:', sTaskQueues);
    };
    Task.prototype.next = function(name, subrun) {
      if (typeof(name) === 'function') {
        subrun = name;
        name = this.name;
      }
      var subtask = new Task({
        run: subrun,
        name: name,
        parent: this
      });
      subtask.state = RUNNING;
      subtask.type = this.type;
      subtask.successCallback = this.successCallback || null;
      subtask.failureCallback = this.failureCallback || null;
      this.subtasks.push(subtask);
      return this;
    };
    Task.prototype.parallel = function(name, subrun) {
      if (forge.util.isArray(name)) {
        subrun = name;
        name = this.name;
      }
      return this.next(name, function(task) {
        var ptask = task;
        ptask.block(subrun.length);
        var startParallelTask = function(pname, pi) {
          forge.task.start({
            type: pname,
            run: function(task) {
              subrun[pi](task);
            },
            success: function(task) {
              ptask.unblock();
            },
            failure: function(task) {
              ptask.unblock();
            }
          });
        };
        for (var i = 0; i < subrun.length; i++) {
          var pname = name + '__parallel-' + task.id + '-' + i;
          var pi = i;
          startParallelTask(pname, pi);
        }
      });
    };
    Task.prototype.stop = function() {
      this.state = sStateTable[this.state][STOP];
    };
    Task.prototype.start = function() {
      this.error = false;
      this.state = sStateTable[this.state][START];
      if (this.state === RUNNING) {
        this.start = new Date();
        this.run(this);
        runNext(this, 0);
      }
    };
    Task.prototype.block = function(n) {
      n = typeof(n) === 'undefined' ? 1 : n;
      this.blocks += n;
      if (this.blocks > 0) {
        this.state = sStateTable[this.state][BLOCK];
      }
    };
    Task.prototype.unblock = function(n) {
      n = typeof(n) === 'undefined' ? 1 : n;
      this.blocks -= n;
      if (this.blocks === 0 && this.state !== DONE) {
        this.state = RUNNING;
        runNext(this, 0);
      }
      return this.blocks;
    };
    Task.prototype.sleep = function(n) {
      n = typeof(n) === 'undefined' ? 0 : n;
      this.state = sStateTable[this.state][SLEEP];
      var self = this;
      this.timeoutId = setTimeout(function() {
        self.timeoutId = null;
        self.state = RUNNING;
        runNext(self, 0);
      }, n);
    };
    Task.prototype.wait = function(cond) {
      cond.wait(this);
    };
    Task.prototype.wakeup = function() {
      if (this.state === SLEEPING) {
        cancelTimeout(this.timeoutId);
        this.timeoutId = null;
        this.state = RUNNING;
        runNext(this, 0);
      }
    };
    Task.prototype.cancel = function() {
      this.state = sStateTable[this.state][CANCEL];
      this.permitsNeeded = 0;
      if (this.timeoutId !== null) {
        cancelTimeout(this.timeoutId);
        this.timeoutId = null;
      }
      this.subtasks = [];
    };
    Task.prototype.fail = function(next) {
      this.error = true;
      finish(this, true);
      if (next) {
        next.error = this.error;
        next.swapTime = this.swapTime;
        next.userData = this.userData;
        runNext(next, 0);
      } else {
        if (this.parent !== null) {
          var parent = this.parent;
          while (parent.parent !== null) {
            parent.error = this.error;
            parent.swapTime = this.swapTime;
            parent.userData = this.userData;
            parent = parent.parent;
          }
          finish(parent, true);
        }
        if (this.failureCallback) {
          this.failureCallback(this);
        }
      }
    };
    var start = function(task) {
      task.error = false;
      task.state = sStateTable[task.state][START];
      setTimeout(function() {
        if (task.state === RUNNING) {
          task.swapTime = +new Date();
          task.run(task);
          runNext(task, 0);
        }
      }, 0);
    };
    var runNext = function(task, recurse) {
      var swap = (recurse > sMaxRecursions) || (+new Date() - task.swapTime) > sTimeSlice;
      var doNext = function(recurse) {
        recurse++;
        if (task.state === RUNNING) {
          if (swap) {
            task.swapTime = +new Date();
          }
          if (task.subtasks.length > 0) {
            var subtask = task.subtasks.shift();
            subtask.error = task.error;
            subtask.swapTime = task.swapTime;
            subtask.userData = task.userData;
            subtask.run(subtask);
            if (!subtask.error) {
              runNext(subtask, recurse);
            }
          } else {
            finish(task);
            if (!task.error) {
              if (task.parent !== null) {
                task.parent.error = task.error;
                task.parent.swapTime = task.swapTime;
                task.parent.userData = task.userData;
                runNext(task.parent, recurse);
              }
            }
          }
        }
      };
      if (swap) {
        setTimeout(doNext, 0);
      } else {
        doNext(recurse);
      }
    };
    var finish = function(task, suppressCallbacks) {
      task.state = DONE;
      delete sTasks[task.id];
      if (sVL >= 1) {
        forge.log.verbose(cat, '[%s][%s] finish', task.id, task.name, task);
      }
      if (task.parent === null) {
        if (!(task.type in sTaskQueues)) {
          forge.log.error(cat, '[%s][%s] task queue missing [%s]', task.id, task.name, task.type);
        } else if (sTaskQueues[task.type].length === 0) {
          forge.log.error(cat, '[%s][%s] task queue empty [%s]', task.id, task.name, task.type);
        } else if (sTaskQueues[task.type][0] !== task) {
          forge.log.error(cat, '[%s][%s] task not first in queue [%s]', task.id, task.name, task.type);
        } else {
          sTaskQueues[task.type].shift();
          if (sTaskQueues[task.type].length === 0) {
            if (sVL >= 1) {
              forge.log.verbose(cat, '[%s][%s] delete queue [%s]', task.id, task.name, task.type);
            }
            delete sTaskQueues[task.type];
          } else {
            if (sVL >= 1) {
              forge.log.verbose(cat, '[%s][%s] queue start next [%s] remain:%s', task.id, task.name, task.type, sTaskQueues[task.type].length);
            }
            sTaskQueues[task.type][0].start();
          }
        }
        if (!suppressCallbacks) {
          if (task.error && task.failureCallback) {
            task.failureCallback(task);
          } else if (!task.error && task.successCallback) {
            task.successCallback(task);
          }
        }
      }
    };
    forge.task = forge.task || {};
    forge.task.start = function(options) {
      var task = new Task({
        run: options.run,
        name: options.name || sNoTaskName
      });
      task.type = options.type;
      task.successCallback = options.success || null;
      task.failureCallback = options.failure || null;
      if (!(task.type in sTaskQueues)) {
        if (sVL >= 1) {
          forge.log.verbose(cat, '[%s][%s] create queue [%s]', task.id, task.name, task.type);
        }
        sTaskQueues[task.type] = [task];
        start(task);
      } else {
        sTaskQueues[options.type].push(task);
      }
    };
    forge.task.cancel = function(type) {
      if (type in sTaskQueues) {
        sTaskQueues[type] = [sTaskQueues[type][0]];
      }
    };
    forge.task.createCondition = function() {
      var cond = {tasks: {}};
      cond.wait = function(task) {
        if (!(task.id in cond.tasks)) {
          task.block();
          cond.tasks[task.id] = task;
        }
      };
      cond.notify = function() {
        var tmp = cond.tasks;
        cond.tasks = {};
        for (var id in tmp) {
          tmp[id].unblock();
        }
      };
      return cond;
    };
  }
  var name = 'task';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/task.js", ["require", "module", "npm:node-forge@0.6.30/js/debug.js", "npm:node-forge@0.6.30/js/log.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
System.registerDynamic("npm:moment@2.10.3/moment.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
  }(this, function() {
    'use strict';
    var hookCallback;
    function utils_hooks__hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return Object.prototype.toString.call(input) === '[object Array]';
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }
    function map(arr, fn) {
      var res = [],
          i;
      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function create_utc__createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    function valid__isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
        if (m._strict) {
          m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }
      }
      return m._isValid;
    }
    function valid__createInvalid(flags) {
      var m = create_utc__createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = utils_hooks__hooks.momentProperties = [];
    function copyConfig(to, from) {
      var i,
          prop,
          val;
      if (typeof from._isAMomentObject !== 'undefined') {
        to._isAMomentObject = from._isAMomentObject;
      }
      if (typeof from._i !== 'undefined') {
        to._i = from._i;
      }
      if (typeof from._f !== 'undefined') {
        to._f = from._f;
      }
      if (typeof from._l !== 'undefined') {
        to._l = from._l;
      }
      if (typeof from._strict !== 'undefined') {
        to._strict = from._strict;
      }
      if (typeof from._tzm !== 'undefined') {
        to._tzm = from._tzm;
      }
      if (typeof from._isUTC !== 'undefined') {
        to._isUTC = from._isUTC;
      }
      if (typeof from._offset !== 'undefined') {
        to._offset = from._offset;
      }
      if (typeof from._pf !== 'undefined') {
        to._pf = getParsingFlags(from);
      }
      if (typeof from._locale !== 'undefined') {
        to._locale = from._locale;
      }
      if (momentProperties.length > 0) {
        for (i in momentProperties) {
          prop = momentProperties[i];
          val = from[prop];
          if (typeof val !== 'undefined') {
            to[prop] = val;
          }
        }
      }
      return to;
    }
    var updateInProgress = false;
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(+config._d);
      if (updateInProgress === false) {
        updateInProgress = true;
        utils_hooks__hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        if (coercedNumber >= 0) {
          value = Math.floor(coercedNumber);
        } else {
          value = Math.ceil(coercedNumber);
        }
      }
      return value;
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;
      for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function Locale() {}
    var locales = {};
    var globalLocale;
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    }
    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));
          if (locale) {
            return locale;
          }
          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return null;
    }
    function loadLocale(name) {
      var oldLocale = null;
      if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          require('./locale/' + name);
          locale_locales__getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }
      return locales[name];
    }
    function locale_locales__getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (typeof values === 'undefined') {
          data = locale_locales__getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, values) {
      if (values !== null) {
        values.abbr = name;
        if (!locales[name]) {
          locales[name] = new Locale();
        }
        locales[name].set(values);
        locale_locales__getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function locale_locales__getLocale(key) {
      var locale;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale = loadLocale(key);
        if (locale) {
          return locale;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          get_set__set(this, unit, value);
          utils_hooks__hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get_set__get(this, unit);
        }
      };
    }
    function get_set__get(mom, unit) {
      return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }
    function get_set__set(mom, unit, value) {
      return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
    function getSet(units, value) {
      var unit;
      if (typeof units === 'object') {
        for (unit in units) {
          this.set(unit, units[unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (typeof this[units] === 'function') {
          return this[units](value);
        }
      }
      return this;
    }
    function zeroFill(number, targetLength, forceSign) {
      var output = '' + Math.abs(number),
          sign = number >= 0;
      while (output.length < targetLength) {
        output = '0' + output;
      }
      return (sign ? (forceSign ? '+' : '') : '-') + output;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;
      if (typeof callback === 'string') {
        func = function() {
          return this[callback]();
        };
      }
      if (token) {
        formatTokenFunctions[token] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal) {
        formatTokenFunctions[ordinal] = function() {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }
      return input.replace(/\\/g, '');
    }
    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;
      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = '';
        for (i = 0; i < length; i++) {
          output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
        }
        return output;
      };
    }
    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format = expandFormat(format, m.localeData());
      if (!formatFunctions[format]) {
        formatFunctions[format] = makeFormatFunction(format);
      }
      return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format;
    }
    var match1 = /\d/;
    var match2 = /\d\d/;
    var match3 = /\d{3}/;
    var match4 = /\d{4}/;
    var match6 = /[+-]?\d{6}/;
    var match1to2 = /\d\d?/;
    var match1to3 = /\d{1,3}/;
    var match1to4 = /\d{1,4}/;
    var match1to6 = /[+-]?\d{1,6}/;
    var matchUnsigned = /\d+/;
    var matchSigned = /[+-]?\d+/;
    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    var regexes = {};
    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = typeof regex === 'function' ? regex : function(isStrict) {
        return (isStrict && strictRegex) ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }
      return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    var tokens = {};
    function addParseToken(token, callback) {
      var i,
          func = callback;
      if (typeof token === 'string') {
        token = [token];
      }
      if (typeof callback === 'number') {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }
    function addWeekParseToken(token, callback) {
      addParseToken(token, function(input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }
    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    function daysInMonth(year, month) {
      return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    addFormatToken('M', ['MM', 2], 'Mo', function() {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function(format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function(format) {
      return this.localeData().months(this, format);
    });
    addUnitAlias('month', 'M');
    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', matchWord);
    addRegexToken('MMMM', matchWord);
    addParseToken(['M', 'MM'], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths(m) {
      return this._months[m.month()];
    }
    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort(m) {
      return this._monthsShort[m.month()];
    }
    function localeMonthsParse(monthName, format, strict) {
      var i,
          mom,
          regex;
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = create_utc__createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      var dayOfMonth;
      if (typeof value === 'string') {
        value = mom.localeData().monthsParse(value);
        if (typeof value !== 'number') {
          return mom;
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        utils_hooks__hooks.updateOffset(this, true);
        return this;
      } else {
        return get_set__get(this, 'Month');
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function checkOverflow(m) {
      var overflow;
      var a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    function warn(msg) {
      if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true,
          msgWithStack = msg + '\n' + (new Error()).stack;
      return extend(function() {
        if (firstTime) {
          warn(msgWithStack);
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    utils_hooks__hooks.suppressDeprecationWarnings = false;
    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/], ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/], ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/], ['GGGG-[W]WW', /\d{4}-W\d{2}/], ['YYYY-DDD', /\d{4}-\d{3}/]];
    var isoTimes = [['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/], ['HH:mm', /(T| )\d\d:\d\d/], ['HH', /(T| )\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = from_string__isoRegex.exec(string);
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(string)) {
            config._f = isoDates[i][0] + (match[6] || ' ');
            break;
          }
        }
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(string)) {
            config._f += isoTimes[i][0];
            break;
          }
        }
        if (string.match(matchOffset)) {
          config._f += 'Z';
        }
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
        utils_hooks__hooks.createFromInputFallback(config);
      }
    }
    utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'https://github.com/moment/moment/issues/1407 for more info.', function(config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    });
    function createDate(y, m, d, h, M, s, ms) {
      var date = new Date(y, m, d, h, M, s, ms);
      if (y < 1970) {
        date.setFullYear(y);
      }
      return date;
    }
    function createUTCDate(y) {
      var date = new Date(Date.UTC.apply(null, arguments));
      if (y < 1970) {
        date.setUTCFullYear(y);
      }
      return date;
    }
    addFormatToken(0, ['YY', 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
    addUnitAlias('year', 'y');
    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYY', 'YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YY', function(input, array) {
      array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
      return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }
    utils_hooks__hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };
    var getSetYear = makeGetSet('FullYear', false);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');
    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    });
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
      var end = firstDayOfWeekOfYear - firstDayOfWeek,
          daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
          adjustedMoment;
      if (daysToDayOfWeek > end) {
        daysToDayOfWeek -= 7;
      }
      if (daysToDayOfWeek < end - 7) {
        daysToDayOfWeek += 7;
      }
      adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
      return {
        week: Math.ceil(adjustedMoment.dayOfYear() / 7),
        year: adjustedMoment.year()
      };
    }
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    }
    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
    addUnitAlias('dayOfYear', 'DDD');
    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
      var d = createUTCDate(year, 0, 1).getUTCDay();
      var daysToAdd;
      var dayOfYear;
      d = d === 0 ? 7 : d;
      weekday = weekday != null ? weekday : firstDayOfWeek;
      daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
      dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
      return {
        year: dayOfYear > 0 ? year : year - 1,
        dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
      };
    }
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var now = new Date();
      if (config._useUTC) {
        return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
      }
      return [now.getFullYear(), now.getMonth(), now.getDate()];
    }
    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse)) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w,
          weekYear,
          week,
          weekday,
          dow,
          doy,
          temp;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
        week = defaults(w.w, 1);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < dow) {
            ++week;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
        } else {
          weekday = dow;
        }
      }
      temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
    utils_hooks__hooks.ISO_8601 = function() {};
    function configFromStringAndFormat(config) {
      if (config._f === utils_hooks__hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }
          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }
      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;
      if (meridiem == null) {
        return hour;
      }
      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig,
          bestMoment,
          scoreToBeat,
          i,
          currentScore;
      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }
      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (!valid__isValid(tempConfig)) {
          continue;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i);
      config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];
      configFromArray(config);
    }
    function createFromConfig(config) {
      var input = config._i,
          format = config._f,
          res;
      config._locale = config._locale || locale_locales__getLocale(config._l);
      if (input === null || (format === undefined && input === '')) {
        return valid__createInvalid({nullInput: true});
      }
      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else if (isDate(input)) {
        config._d = input;
      } else {
        configFromInput(config);
      }
      res = new Moment(checkOverflow(config));
      if (res._nextDay) {
        res.add(1, 'd');
        res._nextDay = undefined;
      }
      return res;
    }
    function configFromInput(config) {
      var input = config._i;
      if (input === undefined) {
        config._d = new Date();
      } else if (isDate(input)) {
        config._d = new Date(+input);
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (typeof(input) === 'object') {
        configFromObject(config);
      } else if (typeof(input) === 'number') {
        config._d = new Date(input);
      } else {
        utils_hooks__hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};
      if (typeof(locale) === 'boolean') {
        strict = locale;
        locale = undefined;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }
    function local__createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate('moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548', function() {
      var other = local__createLocal.apply(null, arguments);
      return other < this ? this : other;
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548', function() {
      var other = local__createLocal.apply(null, arguments);
      return other > this ? this : other;
    });
    function pickBy(fn, moments) {
      var res,
          i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return local__createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
      this._days = +days + weeks * 7;
      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = locale_locales__getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function offset(token, separator) {
      addFormatToken(token, 0, 0, function() {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
      });
    }
    offset('Z', ':');
    offset('ZZ', '');
    addRegexToken('Z', matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(string) {
      var matches = ((string || '').match(matchOffset) || []);
      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return parts[0] === '+' ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
      var res,
          diff;
      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
        res._d.setTime(+res._d + diff);
        utils_hooks__hooks.updateOffset(res, false);
        return res;
      } else {
        return local__createLocal(input).local();
      }
      return model._isUTC ? local__createLocal(input).zone(model._offset || 0) : local__createLocal(input).local();
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    utils_hooks__hooks.updateOffset = function() {};
    function getSetOffset(input, keepLocalTime) {
      var offset = this._offset || 0,
          localAdjust;
      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(input);
        }
        if (Math.abs(input) < 16) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }
        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            utils_hooks__hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm) {
        this.utcOffset(this._tzm);
      } else if (typeof this._i === 'string') {
        this.utcOffset(offsetFromString(this._i));
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!input) {
        input = 0;
      } else {
        input = local__createLocal(input).utcOffset();
      }
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
    }
    function isDaylightSavingTimeShifted() {
      if (this._a) {
        var other = this._isUTC ? create_utc__createUTC(this._a) : local__createLocal(this._a);
        return this.isValid() && compareArrays(this._a, other.toArray()) > 0;
      }
      return false;
    }
    function isLocal() {
      return !this._isUTC;
    }
    function isUtcOffset() {
      return this._isUTC;
    }
    function isUtc() {
      return this._isUTC && this._offset === 0;
    }
    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
    function create__createDuration(input, key) {
      var duration = input,
          match = null,
          sign,
          ret,
          diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (typeof input === 'number') {
        duration = {};
        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(match[MILLISECOND]) * sign
        };
      } else if (!!(match = create__isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          d: parseIso(match[4], sign),
          h: parseIso(match[5], sign),
          m: parseIso(match[6], sign),
          s: parseIso(match[7], sign),
          w: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }
      return ret;
    }
    create__createDuration.fn = Duration.prototype;
    function parseIso(inp, sign) {
      var res = inp && parseFloat(inp.replace(',', '.'));
      return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
      var res = {
        milliseconds: 0,
        months: 0
      };
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur,
            tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
          tmp = val;
          val = period;
          period = tmp;
        }
        val = typeof val === 'string' ? +val : val;
        dur = create__createDuration(val, period);
        add_subtract__addSubtract(this, dur, direction);
        return this;
      };
    }
    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = duration._days,
          months = duration._months;
      updateOffset = updateOffset == null ? true : updateOffset;
      if (milliseconds) {
        mom._d.setTime(+mom._d + milliseconds * isAdding);
      }
      if (days) {
        get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
      }
      if (months) {
        setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
      }
      if (updateOffset) {
        utils_hooks__hooks.updateOffset(mom, days || months);
      }
    }
    var add_subtract__add = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');
    function moment_calendar__calendar(time) {
      var now = time || local__createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          diff = this.diff(sod, 'days', true),
          format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
      return this.format(this.localeData().calendar(format, this, local__createLocal(now)));
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var inputMs;
      units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
      if (units === 'millisecond') {
        input = isMoment(input) ? input : local__createLocal(input);
        return +this > +input;
      } else {
        inputMs = isMoment(input) ? +input : +local__createLocal(input);
        return inputMs < +this.clone().startOf(units);
      }
    }
    function isBefore(input, units) {
      var inputMs;
      units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
      if (units === 'millisecond') {
        input = isMoment(input) ? input : local__createLocal(input);
        return +this < +input;
      } else {
        inputMs = isMoment(input) ? +input : +local__createLocal(input);
        return +this.clone().endOf(units) < inputMs;
      }
    }
    function isBetween(from, to, units) {
      return this.isAfter(from, units) && this.isBefore(to, units);
    }
    function isSame(input, units) {
      var inputMs;
      units = normalizeUnits(units || 'millisecond');
      if (units === 'millisecond') {
        input = isMoment(input) ? input : local__createLocal(input);
        return +this === +input;
      } else {
        inputMs = +local__createLocal(input);
        return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
      }
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number);
      } else {
        return Math.floor(number);
      }
    }
    function diff(input, units, asFloat) {
      var that = cloneWithOffset(input, this),
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
          delta,
          output;
      units = normalizeUnits(units);
      if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
          output = output / 3;
        } else if (units === 'year') {
          output = output / 12;
        }
      } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : units === 'minute' ? delta / 6e4 : units === 'hour' ? delta / 36e5 : units === 'day' ? (delta - zoneDelta) / 864e5 : units === 'week' ? (delta - zoneDelta) / 6048e5 : delta;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
          anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust);
    }
    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }
    function moment_format__toISOString() {
      var m = this.clone().utc();
      if (0 < m.year() && m.year() <= 9999) {
        if ('function' === typeof Date.prototype.toISOString) {
          return this.toDate().toISOString();
        } else {
          return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
      } else {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      }
    }
    function format(inputString) {
      var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      return create__createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function fromNow(withoutSuffix) {
      return this.from(local__createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      return create__createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function toNow(withoutSuffix) {
      return this.to(local__createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = locale_locales__getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });
    function localeData() {
      return this._locale;
    }
    function startOf(units) {
      units = normalizeUnits(units);
      switch (units) {
        case 'year':
          this.month(0);
        case 'quarter':
        case 'month':
          this.date(1);
        case 'week':
        case 'isoWeek':
        case 'day':
          this.hours(0);
        case 'hour':
          this.minutes(0);
        case 'minute':
          this.seconds(0);
        case 'second':
          this.milliseconds(0);
      }
      if (units === 'week') {
        this.weekday(0);
      }
      if (units === 'isoWeek') {
        this.isoWeekday(1);
      }
      if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
      }
      return this;
    }
    function endOf(units) {
      units = normalizeUnits(units);
      if (units === undefined || units === 'millisecond') {
        return this;
      }
      return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }
    function to_type__valueOf() {
      return +this._d - ((this._offset || 0) * 60000);
    }
    function unix() {
      return Math.floor(+this / 1000);
    }
    function toDate() {
      return this._offset ? new Date(+this) : this._d;
    }
    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }
    function moment_valid__isValid() {
      return valid__isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    addFormatToken(0, ['gg', 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }
    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');
    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
      week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function weeksInYear(year, dow, doy) {
      return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }
    function getSetWeekYear(input) {
      var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
      return input == null ? year : this.add((input - year), 'y');
    }
    function getSetISOWeekYear(input) {
      var year = weekOfYear(this, 1, 4).year;
      return input == null ? year : this.add((input - year), 'y');
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    addFormatToken('Q', 0, 0, 'quarter');
    addUnitAlias('quarter', 'Q');
    addRegexToken('Q', match1);
    addParseToken('Q', function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken('D', ['DD', 2], 'Do', 'date');
    addUnitAlias('date', 'D');
    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function(isStrict, locale) {
      return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet('Date', true);
    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function(format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function(format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function(format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');
    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');
    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', matchWord);
    addRegexToken('ddd', matchWord);
    addRegexToken('dddd', matchWord);
    addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config) {
      var weekday = config._locale.weekdaysParse(input);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
      week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
      if (typeof input === 'string') {
        if (!isNaN(input)) {
          input = parseInt(input, 10);
        } else {
          input = locale.weekdaysParse(input);
          if (typeof input !== 'number') {
            return null;
          }
        }
      }
      return input;
    }
    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays(m) {
      return this._weekdays[m.day()];
    }
    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort(m) {
      return this._weekdaysShort[m.day()];
    }
    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin(m) {
      return this._weekdaysMin[m.day()];
    }
    function localeWeekdaysParse(weekdayName) {
      var i,
          mom,
          regex;
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        if (!this._weekdaysParse[i]) {
          mom = local__createLocal([2000, 1]).day(i);
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        if (this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }
    function getSetISODayOfWeek(input) {
      return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }
    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function() {
      return this.hours() % 12 || 12;
    });
    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }
    meridiem('a', true);
    meridiem('A', false);
    addUnitAlias('hour', 'h');
    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }
    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    function localeIsPM(input) {
      return ((input + '').toLowerCase().charAt(0) === 'p');
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    }
    var getSetHour = makeGetSet('Hours', true);
    addFormatToken('m', ['mm', 2], 0, 'minute');
    addUnitAlias('minute', 'm');
    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);
    var getSetMinute = makeGetSet('Minutes', false);
    addFormatToken('s', ['ss', 2], 0, 'second');
    addUnitAlias('second', 's');
    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);
    var getSetSecond = makeGetSet('Seconds', false);
    addFormatToken('S', 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    function millisecond__milliseconds(token) {
      addFormatToken(0, [token, 3], 0, 'millisecond');
    }
    millisecond__milliseconds('SSS');
    millisecond__milliseconds('SSSS');
    addUnitAlias('millisecond', 'ms');
    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    addRegexToken('SSSS', matchUnsigned);
    addParseToken(['S', 'SS', 'SSS', 'SSSS'], function(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    });
    var getSetMillisecond = makeGetSet('Milliseconds', false);
    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');
    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }
    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }
    var momentPrototype__proto = Moment.prototype;
    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = getSet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = getSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = moment_format__toISOString;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;
    momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
    var momentPrototype = momentPrototype__proto;
    function moment__createUnix(input) {
      return local__createLocal(input * 1000);
    }
    function moment__createInZone() {
      return local__createLocal.apply(null, arguments).parseZone();
    }
    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };
    function locale_calendar__calendar(key, mom, now) {
      var output = this._calendar[key];
      return typeof output === 'function' ? output.call(mom, now) : output;
    }
    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY LT',
      LLLL: 'dddd, MMMM D, YYYY LT'
    };
    function longDateFormat(key) {
      var output = this._longDateFormat[key];
      if (!output && this._longDateFormat[key.toUpperCase()]) {
        output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
          return val.slice(1);
        });
        this._longDateFormat[key] = output;
      }
      return output;
    }
    var defaultInvalidDate = 'Invalid date';
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }
    function preParsePostFormat(string) {
      return string;
    }
    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };
    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return (typeof output === 'function') ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }
    function locale_set__set(config) {
      var prop,
          i;
      for (i in config) {
        prop = config[i];
        if (typeof prop === 'function') {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }
      this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }
    var prototype__proto = Locale.prototype;
    prototype__proto._calendar = defaultCalendar;
    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto._invalidDate = defaultInvalidDate;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto._ordinal = defaultOrdinal;
    prototype__proto.ordinal = ordinal;
    prototype__proto._ordinalParse = defaultOrdinalParse;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto._relativeTime = defaultRelativeTime;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;
    prototype__proto.months = localeMonths;
    prototype__proto._months = defaultLocaleMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto._weekdays = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;
    function lists__get(format, index, field, setter) {
      var locale = locale_locales__getLocale();
      var utc = create_utc__createUTC().set(setter, index);
      return locale[field](utc, format);
    }
    function list(format, index, field, count, setter) {
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
      if (index != null) {
        return lists__get(format, index, field, setter);
      }
      var i;
      var out = [];
      for (i = 0; i < count; i++) {
        out[i] = lists__get(format, i, field, setter);
      }
      return out;
    }
    function lists__listMonths(format, index) {
      return list(format, index, 'months', 12, 'month');
    }
    function lists__listMonthsShort(format, index) {
      return list(format, index, 'monthsShort', 12, 'month');
    }
    function lists__listWeekdays(format, index) {
      return list(format, index, 'weekdays', 7, 'day');
    }
    function lists__listWeekdaysShort(format, index) {
      return list(format, index, 'weekdaysShort', 7, 'day');
    }
    function lists__listWeekdaysMin(format, index) {
      return list(format, index, 'weekdaysMin', 7, 'day');
    }
    locale_locales__getSetGlobalLocale('en', {
      ordinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
        return number + output;
      }
    });
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
    var mathAbs = Math.abs;
    function duration_abs__abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function duration_add_subtract__addSubtract(duration, input, value, direction) {
      var other = create__createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function duration_add_subtract__add(input, value) {
      return duration_add_subtract__addSubtract(this, input, value, 1);
    }
    function duration_add_subtract__subtract(input, value) {
      return duration_add_subtract__addSubtract(this, input, value, -1);
    }
    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds,
          minutes,
          hours,
          years = 0;
      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24);
      years = absFloor(daysToYears(days));
      days -= absFloor(yearsToDays(years));
      months += absFloor(days / 30);
      days %= 30;
      years += absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }
    function daysToYears(days) {
      return days * 400 / 146097;
    }
    function yearsToDays(years) {
      return years * 146097 / 400;
    }
    function as(units) {
      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);
      if (units === 'month' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToYears(days) * 12;
        return units === 'month' ? months : months / 12;
      } else {
        days = this._days + Math.round(yearsToDays(this._months / 12));
        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;
          case 'day':
            return days + milliseconds / 864e5;
          case 'hour':
            return days * 24 + milliseconds / 36e5;
          case 'minute':
            return days * 1440 + milliseconds / 6e4;
          case 'second':
            return days * 86400 + milliseconds / 1000;
          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;
          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    }
    function duration_as__valueOf() {
      return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asYears = makeAs('y');
    function duration_get__get(units) {
      units = normalizeUnits(units);
      return this[units + 's']();
    }
    function makeGetter(name) {
      return function() {
        return this._data[name];
      };
    }
    var duration_get__milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round;
    var thresholds = {
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
      var duration = create__createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds < thresholds.s && ['s', seconds] || minutes === 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours === 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days === 1 && ['d'] || days < thresholds.d && ['dd', days] || months === 1 && ['M'] || months < thresholds.M && ['MM', months] || years === 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    }
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }
      if (limit === undefined) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      return true;
    }
    function humanize(withSuffix) {
      var locale = this.localeData();
      var output = duration_humanize__relativeTime(this, !withSuffix, locale);
      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }
      return locale.postformat(output);
    }
    var iso_string__abs = Math.abs;
    function iso_string__toISOString() {
      var Y = iso_string__abs(this.years());
      var M = iso_string__abs(this.months());
      var D = iso_string__abs(this.days());
      var h = iso_string__abs(this.hours());
      var m = iso_string__abs(this.minutes());
      var s = iso_string__abs(this.seconds() + this.milliseconds() / 1000);
      var total = this.asSeconds();
      if (!total) {
        return 'P0D';
      }
      return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
    }
    var duration_prototype__proto = Duration.prototype;
    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = duration_get__milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;
    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');
    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function(input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    utils_hooks__hooks.version = '2.10.3';
    setHookCallback(local__createLocal);
    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    var _moment = utils_hooks__hooks;
    return _moment;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:driftyco/ionic@1.0.0/release/js/ionic.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    (function() {
      window.ionic = window.ionic || {};
      window.ionic.views = {};
      window.ionic.version = '1.0.0';
      (function(ionic) {
        ionic.DelegateService = function(methodNames) {
          if (methodNames.indexOf('$getByHandle') > -1) {
            throw new Error("Method '$getByHandle' is implicitly added to each delegate service. Do not list it as a method.");
          }
          function trueFn() {
            return true;
          }
          return ['$log', function($log) {
            function DelegateInstance(instances, handle) {
              this._instances = instances;
              this.handle = handle;
            }
            methodNames.forEach(function(methodName) {
              DelegateInstance.prototype[methodName] = instanceMethodCaller(methodName);
            });
            function DelegateService() {
              this._instances = [];
            }
            DelegateService.prototype = DelegateInstance.prototype;
            DelegateService.prototype._registerInstance = function(instance, handle, filterFn) {
              var instances = this._instances;
              instance.$$delegateHandle = handle;
              instance.$$filterFn = filterFn || trueFn;
              instances.push(instance);
              return function deregister() {
                var index = instances.indexOf(instance);
                if (index !== -1) {
                  instances.splice(index, 1);
                }
              };
            };
            DelegateService.prototype.$getByHandle = function(handle) {
              return new DelegateInstance(this._instances, handle);
            };
            return new DelegateService();
            function instanceMethodCaller(methodName) {
              return function caller() {
                var handle = this.handle;
                var args = arguments;
                var foundInstancesCount = 0;
                var returnValue;
                this._instances.forEach(function(instance) {
                  if ((!handle || handle == instance.$$delegateHandle) && instance.$$filterFn(instance)) {
                    foundInstancesCount++;
                    var ret = instance[methodName].apply(instance, args);
                    if (foundInstancesCount === 1) {
                      returnValue = ret;
                    }
                  }
                });
                if (!foundInstancesCount && handle) {
                  return $log.warn('Delegate for handle "' + handle + '" could not find a ' + 'corresponding element with delegate-handle="' + handle + '"! ' + methodName + '() was not called!\n' + 'Possible cause: If you are calling ' + methodName + '() immediately, and ' + 'your element with delegate-handle="' + handle + '" is a child of your ' + 'controller, then your element may not be compiled yet. Put a $timeout ' + 'around your call to ' + methodName + '() and try again.');
                }
                return returnValue;
              };
            }
          }];
        };
      })(window.ionic);
      (function(window, document, ionic) {
        var readyCallbacks = [];
        var isDomReady = document.readyState === 'complete' || document.readyState === 'interactive';
        function domReady() {
          isDomReady = true;
          for (var x = 0; x < readyCallbacks.length; x++) {
            ionic.requestAnimationFrame(readyCallbacks[x]);
          }
          readyCallbacks = [];
          document.removeEventListener('DOMContentLoaded', domReady);
        }
        if (!isDomReady) {
          document.addEventListener('DOMContentLoaded', domReady);
        }
        window._rAF = (function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
            window.setTimeout(callback, 16);
          };
        })();
        var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;
        ionic.DomUtil = {
          requestAnimationFrame: function(cb) {
            return window._rAF(cb);
          },
          cancelAnimationFrame: function(requestId) {
            cancelAnimationFrame(requestId);
          },
          animationFrameThrottle: function(cb) {
            var args,
                isQueued,
                context;
            return function() {
              args = arguments;
              context = this;
              if (!isQueued) {
                isQueued = true;
                ionic.requestAnimationFrame(function() {
                  cb.apply(context, args);
                  isQueued = false;
                });
              }
            };
          },
          contains: function(parentNode, otherNode) {
            var current = otherNode;
            while (current) {
              if (current === parentNode)
                return true;
              current = current.parentNode;
            }
          },
          getPositionInParent: function(el) {
            return {
              left: el.offsetLeft,
              top: el.offsetTop
            };
          },
          ready: function(cb) {
            if (isDomReady) {
              ionic.requestAnimationFrame(cb);
            } else {
              readyCallbacks.push(cb);
            }
          },
          getTextBounds: function(textNode) {
            if (document.createRange) {
              var range = document.createRange();
              range.selectNodeContents(textNode);
              if (range.getBoundingClientRect) {
                var rect = range.getBoundingClientRect();
                if (rect) {
                  var sx = window.scrollX;
                  var sy = window.scrollY;
                  return {
                    top: rect.top + sy,
                    left: rect.left + sx,
                    right: rect.left + sx + rect.width,
                    bottom: rect.top + sy + rect.height,
                    width: rect.width,
                    height: rect.height
                  };
                }
              }
            }
            return null;
          },
          getChildIndex: function(element, type) {
            if (type) {
              var ch = element.parentNode.children;
              var c;
              for (var i = 0,
                  k = 0,
                  j = ch.length; i < j; i++) {
                c = ch[i];
                if (c.nodeName && c.nodeName.toLowerCase() == type) {
                  if (c == element) {
                    return k;
                  }
                  k++;
                }
              }
            }
            return Array.prototype.slice.call(element.parentNode.children).indexOf(element);
          },
          swapNodes: function(src, dest) {
            dest.parentNode.insertBefore(src, dest);
          },
          elementIsDescendant: function(el, parent, stopAt) {
            var current = el;
            do {
              if (current === parent)
                return true;
              current = current.parentNode;
            } while (current && current !== stopAt);
            return false;
          },
          getParentWithClass: function(e, className, depth) {
            depth = depth || 10;
            while (e.parentNode && depth--) {
              if (e.parentNode.classList && e.parentNode.classList.contains(className)) {
                return e.parentNode;
              }
              e = e.parentNode;
            }
            return null;
          },
          getParentOrSelfWithClass: function(e, className, depth) {
            depth = depth || 10;
            while (e && depth--) {
              if (e.classList && e.classList.contains(className)) {
                return e;
              }
              e = e.parentNode;
            }
            return null;
          },
          rectContains: function(x, y, x1, y1, x2, y2) {
            if (x < x1 || x > x2)
              return false;
            if (y < y1 || y > y2)
              return false;
            return true;
          },
          blurAll: function() {
            if (document.activeElement && document.activeElement != document.body) {
              document.activeElement.blur();
              return document.activeElement;
            }
            return null;
          },
          cachedAttr: function(ele, key, value) {
            ele = ele && ele.length && ele[0] || ele;
            if (ele && ele.setAttribute) {
              var dataKey = '$attr-' + key;
              if (arguments.length > 2) {
                if (ele[dataKey] !== value) {
                  ele.setAttribute(key, value);
                  ele[dataKey] = value;
                }
              } else if (typeof ele[dataKey] == 'undefined') {
                ele[dataKey] = ele.getAttribute(key);
              }
              return ele[dataKey];
            }
          },
          cachedStyles: function(ele, styles) {
            ele = ele && ele.length && ele[0] || ele;
            if (ele && ele.style) {
              for (var prop in styles) {
                if (ele['$style-' + prop] !== styles[prop]) {
                  ele.style[prop] = ele['$style-' + prop] = styles[prop];
                }
              }
            }
          }
        };
        ionic.requestAnimationFrame = ionic.DomUtil.requestAnimationFrame;
        ionic.cancelAnimationFrame = ionic.DomUtil.cancelAnimationFrame;
        ionic.animationFrameThrottle = ionic.DomUtil.animationFrameThrottle;
      })(window, document, ionic);
      (function(ionic) {
        ionic.CustomEvent = (function() {
          if (typeof window.CustomEvent === 'function')
            return CustomEvent;
          var customEvent = function(event, params) {
            var evt;
            params = params || {
              bubbles: false,
              cancelable: false,
              detail: undefined
            };
            try {
              evt = document.createEvent("CustomEvent");
              evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            } catch (error) {
              evt = document.createEvent("Event");
              for (var param in params) {
                evt[param] = params[param];
              }
              evt.initEvent(event, params.bubbles, params.cancelable);
            }
            return evt;
          };
          customEvent.prototype = window.Event.prototype;
          return customEvent;
        })();
        ionic.EventController = {
          VIRTUALIZED_EVENTS: ['tap', 'swipe', 'swiperight', 'swipeleft', 'drag', 'hold', 'release'],
          trigger: function(eventType, data, bubbles, cancelable) {
            var event = new ionic.CustomEvent(eventType, {
              detail: data,
              bubbles: !!bubbles,
              cancelable: !!cancelable
            });
            data && data.target && data.target.dispatchEvent && data.target.dispatchEvent(event) || window.dispatchEvent(event);
          },
          on: function(type, callback, element) {
            var e = element || window;
            for (var i = 0,
                j = this.VIRTUALIZED_EVENTS.length; i < j; i++) {
              if (type == this.VIRTUALIZED_EVENTS[i]) {
                var gesture = new ionic.Gesture(element);
                gesture.on(type, callback);
                return gesture;
              }
            }
            e.addEventListener(type, callback);
          },
          off: function(type, callback, element) {
            element.removeEventListener(type, callback);
          },
          onGesture: function(type, callback, element, options) {
            var gesture = new ionic.Gesture(element, options);
            gesture.on(type, callback);
            return gesture;
          },
          offGesture: function(gesture, type, callback) {
            gesture && gesture.off(type, callback);
          },
          handlePopState: function() {}
        };
        ionic.on = function() {
          ionic.EventController.on.apply(ionic.EventController, arguments);
        };
        ionic.off = function() {
          ionic.EventController.off.apply(ionic.EventController, arguments);
        };
        ionic.trigger = ionic.EventController.trigger;
        ionic.onGesture = function() {
          return ionic.EventController.onGesture.apply(ionic.EventController.onGesture, arguments);
        };
        ionic.offGesture = function() {
          return ionic.EventController.offGesture.apply(ionic.EventController.offGesture, arguments);
        };
      })(window.ionic);
      (function(ionic) {
        ionic.Gesture = function(element, options) {
          return new ionic.Gestures.Instance(element, options || {});
        };
        ionic.Gestures = {};
        ionic.Gestures.defaults = {stop_browser_behavior: 'disable-user-behavior'};
        ionic.Gestures.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
        ionic.Gestures.HAS_TOUCHEVENTS = ('ontouchstart' in window);
        ionic.Gestures.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
        ionic.Gestures.NO_MOUSEEVENTS = ionic.Gestures.HAS_TOUCHEVENTS && window.navigator.userAgent.match(ionic.Gestures.MOBILE_REGEX);
        ionic.Gestures.EVENT_TYPES = {};
        ionic.Gestures.DIRECTION_DOWN = 'down';
        ionic.Gestures.DIRECTION_LEFT = 'left';
        ionic.Gestures.DIRECTION_UP = 'up';
        ionic.Gestures.DIRECTION_RIGHT = 'right';
        ionic.Gestures.POINTER_MOUSE = 'mouse';
        ionic.Gestures.POINTER_TOUCH = 'touch';
        ionic.Gestures.POINTER_PEN = 'pen';
        ionic.Gestures.EVENT_START = 'start';
        ionic.Gestures.EVENT_MOVE = 'move';
        ionic.Gestures.EVENT_END = 'end';
        ionic.Gestures.DOCUMENT = window.document;
        ionic.Gestures.plugins = {};
        ionic.Gestures.READY = false;
        function setup() {
          if (ionic.Gestures.READY) {
            return;
          }
          ionic.Gestures.event.determineEventTypes();
          for (var name in ionic.Gestures.gestures) {
            if (ionic.Gestures.gestures.hasOwnProperty(name)) {
              ionic.Gestures.detection.register(ionic.Gestures.gestures[name]);
            }
          }
          ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_MOVE, ionic.Gestures.detection.detect);
          ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_END, ionic.Gestures.detection.detect);
          ionic.Gestures.READY = true;
        }
        ionic.Gestures.Instance = function(element, options) {
          var self = this;
          if (element === null) {
            void 0;
            return this;
          }
          setup();
          this.element = element;
          this.enabled = true;
          this.options = ionic.Gestures.utils.extend(ionic.Gestures.utils.extend({}, ionic.Gestures.defaults), options || {});
          if (this.options.stop_browser_behavior) {
            ionic.Gestures.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
          }
          ionic.Gestures.event.onTouch(element, ionic.Gestures.EVENT_START, function(ev) {
            if (self.enabled) {
              ionic.Gestures.detection.startDetect(self, ev);
            }
          });
          return this;
        };
        ionic.Gestures.Instance.prototype = {
          on: function onEvent(gesture, handler) {
            var gestures = gesture.split(' ');
            for (var t = 0; t < gestures.length; t++) {
              this.element.addEventListener(gestures[t], handler, false);
            }
            return this;
          },
          off: function offEvent(gesture, handler) {
            var gestures = gesture.split(' ');
            for (var t = 0; t < gestures.length; t++) {
              this.element.removeEventListener(gestures[t], handler, false);
            }
            return this;
          },
          trigger: function triggerEvent(gesture, eventData) {
            var event = ionic.Gestures.DOCUMENT.createEvent('Event');
            event.initEvent(gesture, true, true);
            event.gesture = eventData;
            var element = this.element;
            if (ionic.Gestures.utils.hasParent(eventData.target, element)) {
              element = eventData.target;
            }
            element.dispatchEvent(event);
            return this;
          },
          enable: function enable(state) {
            this.enabled = state;
            return this;
          }
        };
        var last_move_event = null;
        var enable_detect = false;
        var touch_triggered = false;
        ionic.Gestures.event = {
          bindDom: function(element, type, handler) {
            var types = type.split(' ');
            for (var t = 0; t < types.length; t++) {
              element.addEventListener(types[t], handler, false);
            }
          },
          onTouch: function onTouch(element, eventType, handler) {
            var self = this;
            this.bindDom(element, ionic.Gestures.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
              var sourceEventType = ev.type.toLowerCase();
              if (sourceEventType.match(/mouse/) && touch_triggered) {
                return;
              } else if (sourceEventType.match(/touch/) || sourceEventType.match(/pointerdown/) || (sourceEventType.match(/mouse/) && ev.which === 1)) {
                enable_detect = true;
              } else if (sourceEventType.match(/mouse/) && ev.which !== 1) {
                enable_detect = false;
              }
              if (sourceEventType.match(/touch|pointer/)) {
                touch_triggered = true;
              }
              var count_touches = 0;
              if (enable_detect) {
                if (ionic.Gestures.HAS_POINTEREVENTS && eventType != ionic.Gestures.EVENT_END) {
                  count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
                } else if (sourceEventType.match(/touch/)) {
                  count_touches = ev.touches.length;
                } else if (!touch_triggered) {
                  count_touches = sourceEventType.match(/up/) ? 0 : 1;
                }
                if (count_touches > 0 && eventType == ionic.Gestures.EVENT_END) {
                  eventType = ionic.Gestures.EVENT_MOVE;
                } else if (!count_touches) {
                  eventType = ionic.Gestures.EVENT_END;
                }
                if (count_touches || last_move_event === null) {
                  last_move_event = ev;
                }
                handler.call(ionic.Gestures.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));
                if (ionic.Gestures.HAS_POINTEREVENTS && eventType == ionic.Gestures.EVENT_END) {
                  count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
                }
              }
              if (!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                ionic.Gestures.PointerEvent.reset();
              }
            });
          },
          determineEventTypes: function determineEventTypes() {
            var types;
            if (ionic.Gestures.HAS_POINTEREVENTS) {
              types = ionic.Gestures.PointerEvent.getEvents();
            } else if (ionic.Gestures.NO_MOUSEEVENTS) {
              types = ['touchstart', 'touchmove', 'touchend touchcancel'];
            } else {
              types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
            }
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_START] = types[0];
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_MOVE] = types[1];
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_END] = types[2];
          },
          getTouchList: function getTouchList(ev) {
            if (ionic.Gestures.HAS_POINTEREVENTS) {
              return ionic.Gestures.PointerEvent.getTouchList();
            } else if (ev.touches) {
              return ev.touches;
            } else {
              ev.identifier = 1;
              return [ev];
            }
          },
          collectEventData: function collectEventData(element, eventType, touches, ev) {
            var pointerType = ionic.Gestures.POINTER_TOUCH;
            if (ev.type.match(/mouse/) || ionic.Gestures.PointerEvent.matchType(ionic.Gestures.POINTER_MOUSE, ev)) {
              pointerType = ionic.Gestures.POINTER_MOUSE;
            }
            return {
              center: ionic.Gestures.utils.getCenter(touches),
              timeStamp: new Date().getTime(),
              target: ev.target,
              touches: touches,
              eventType: eventType,
              pointerType: pointerType,
              srcEvent: ev,
              preventDefault: function() {
                if (this.srcEvent.preventManipulation) {
                  this.srcEvent.preventManipulation();
                }
                if (this.srcEvent.preventDefault) {}
              },
              stopPropagation: function() {
                this.srcEvent.stopPropagation();
              },
              stopDetect: function() {
                return ionic.Gestures.detection.stopDetect();
              }
            };
          }
        };
        ionic.Gestures.PointerEvent = {
          pointers: {},
          getTouchList: function() {
            var self = this;
            var touchlist = [];
            Object.keys(self.pointers).sort().forEach(function(id) {
              touchlist.push(self.pointers[id]);
            });
            return touchlist;
          },
          updatePointer: function(type, pointerEvent) {
            if (type == ionic.Gestures.EVENT_END) {
              this.pointers = {};
            } else {
              pointerEvent.identifier = pointerEvent.pointerId;
              this.pointers[pointerEvent.pointerId] = pointerEvent;
            }
            return Object.keys(this.pointers).length;
          },
          matchType: function(pointerType, ev) {
            if (!ev.pointerType) {
              return false;
            }
            var types = {};
            types[ionic.Gestures.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == ionic.Gestures.POINTER_MOUSE);
            types[ionic.Gestures.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == ionic.Gestures.POINTER_TOUCH);
            types[ionic.Gestures.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == ionic.Gestures.POINTER_PEN);
            return types[pointerType];
          },
          getEvents: function() {
            return ['pointerdown MSPointerDown', 'pointermove MSPointerMove', 'pointerup pointercancel MSPointerUp MSPointerCancel'];
          },
          reset: function() {
            this.pointers = {};
          }
        };
        ionic.Gestures.utils = {
          extend: function extend(dest, src, merge) {
            for (var key in src) {
              if (dest[key] !== undefined && merge) {
                continue;
              }
              dest[key] = src[key];
            }
            return dest;
          },
          hasParent: function(node, parent) {
            while (node) {
              if (node == parent) {
                return true;
              }
              node = node.parentNode;
            }
            return false;
          },
          getCenter: function getCenter(touches) {
            var valuesX = [],
                valuesY = [];
            for (var t = 0,
                len = touches.length; t < len; t++) {
              valuesX.push(touches[t].pageX);
              valuesY.push(touches[t].pageY);
            }
            return {
              pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
              pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
            };
          },
          getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
            return {
              x: Math.abs(delta_x / delta_time) || 0,
              y: Math.abs(delta_y / delta_time) || 0
            };
          },
          getAngle: function getAngle(touch1, touch2) {
            var y = touch2.pageY - touch1.pageY,
                x = touch2.pageX - touch1.pageX;
            return Math.atan2(y, x) * 180 / Math.PI;
          },
          getDirection: function getDirection(touch1, touch2) {
            var x = Math.abs(touch1.pageX - touch2.pageX),
                y = Math.abs(touch1.pageY - touch2.pageY);
            if (x >= y) {
              return touch1.pageX - touch2.pageX > 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
            } else {
              return touch1.pageY - touch2.pageY > 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
            }
          },
          getDistance: function getDistance(touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
          },
          getScale: function getScale(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
            }
            return 1;
          },
          getRotation: function getRotation(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
            }
            return 0;
          },
          isVertical: function isVertical(direction) {
            return (direction == ionic.Gestures.DIRECTION_UP || direction == ionic.Gestures.DIRECTION_DOWN);
          },
          stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_class) {
            if (element && element.classList) {
              element.classList.add(css_class);
              element.onselectstart = function() {
                return false;
              };
            }
          }
        };
        ionic.Gestures.detection = {
          gestures: [],
          current: null,
          previous: null,
          stopped: false,
          startDetect: function startDetect(inst, eventData) {
            if (this.current) {
              return;
            }
            this.stopped = false;
            this.current = {
              inst: inst,
              startEvent: ionic.Gestures.utils.extend({}, eventData),
              lastEvent: false,
              name: ''
            };
            this.detect(eventData);
          },
          detect: function detect(eventData) {
            if (!this.current || this.stopped) {
              return null;
            }
            eventData = this.extendEventData(eventData);
            var inst_options = this.current.inst.options;
            for (var g = 0,
                len = this.gestures.length; g < len; g++) {
              var gesture = this.gestures[g];
              if (!this.stopped && inst_options[gesture.name] !== false) {
                if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                  this.stopDetect();
                  break;
                }
              }
            }
            if (this.current) {
              this.current.lastEvent = eventData;
            }
            if (eventData.eventType == ionic.Gestures.EVENT_END && !eventData.touches.length - 1) {
              this.stopDetect();
            }
            return eventData;
          },
          stopDetect: function stopDetect() {
            this.previous = ionic.Gestures.utils.extend({}, this.current);
            this.current = null;
            this.stopped = true;
          },
          extendEventData: function extendEventData(ev) {
            var startEv = this.current.startEvent;
            if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
              startEv.touches = [];
              for (var i = 0,
                  len = ev.touches.length; i < len; i++) {
                startEv.touches.push(ionic.Gestures.utils.extend({}, ev.touches[i]));
              }
            }
            var delta_time = ev.timeStamp - startEv.timeStamp,
                delta_x = ev.center.pageX - startEv.center.pageX,
                delta_y = ev.center.pageY - startEv.center.pageY,
                velocity = ionic.Gestures.utils.getVelocity(delta_time, delta_x, delta_y);
            ionic.Gestures.utils.extend(ev, {
              deltaTime: delta_time,
              deltaX: delta_x,
              deltaY: delta_y,
              velocityX: velocity.x,
              velocityY: velocity.y,
              distance: ionic.Gestures.utils.getDistance(startEv.center, ev.center),
              angle: ionic.Gestures.utils.getAngle(startEv.center, ev.center),
              direction: ionic.Gestures.utils.getDirection(startEv.center, ev.center),
              scale: ionic.Gestures.utils.getScale(startEv.touches, ev.touches),
              rotation: ionic.Gestures.utils.getRotation(startEv.touches, ev.touches),
              startEvent: startEv
            });
            return ev;
          },
          register: function register(gesture) {
            var options = gesture.defaults || {};
            if (options[gesture.name] === undefined) {
              options[gesture.name] = true;
            }
            ionic.Gestures.utils.extend(ionic.Gestures.defaults, options, true);
            gesture.index = gesture.index || 1000;
            this.gestures.push(gesture);
            this.gestures.sort(function(a, b) {
              if (a.index < b.index) {
                return -1;
              }
              if (a.index > b.index) {
                return 1;
              }
              return 0;
            });
            return this.gestures;
          }
        };
        ionic.Gestures.gestures = ionic.Gestures.gestures || {};
        ionic.Gestures.gestures.Hold = {
          name: 'hold',
          index: 10,
          defaults: {
            hold_timeout: 500,
            hold_threshold: 1
          },
          timer: null,
          handler: function holdGesture(ev, inst) {
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                clearTimeout(this.timer);
                ionic.Gestures.detection.current.name = this.name;
                this.timer = setTimeout(function() {
                  if (ionic.Gestures.detection.current.name == 'hold') {
                    ionic.tap.cancelClick();
                    inst.trigger('hold', ev);
                  }
                }, inst.options.hold_timeout);
                break;
              case ionic.Gestures.EVENT_MOVE:
                if (ev.distance > inst.options.hold_threshold) {
                  clearTimeout(this.timer);
                }
                break;
              case ionic.Gestures.EVENT_END:
                clearTimeout(this.timer);
                break;
            }
          }
        };
        ionic.Gestures.gestures.Tap = {
          name: 'tap',
          index: 100,
          defaults: {
            tap_max_touchtime: 250,
            tap_max_distance: 10,
            tap_always: true,
            doubletap_distance: 20,
            doubletap_interval: 300
          },
          handler: function tapGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END && ev.srcEvent.type != 'touchcancel') {
              var prev = ionic.Gestures.detection.previous,
                  did_doubletap = false;
              if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) {
                return;
              }
              if (prev && prev.name == 'tap' && (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance) {
                inst.trigger('doubletap', ev);
                did_doubletap = true;
              }
              if (!did_doubletap || inst.options.tap_always) {
                ionic.Gestures.detection.current.name = 'tap';
                inst.trigger('tap', ev);
              }
            }
          }
        };
        ionic.Gestures.gestures.Swipe = {
          name: 'swipe',
          index: 40,
          defaults: {
            swipe_max_touches: 1,
            swipe_velocity: 0.4
          },
          handler: function swipeGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END) {
              if (inst.options.swipe_max_touches > 0 && ev.touches.length > inst.options.swipe_max_touches) {
                return;
              }
              if (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) {
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
              }
            }
          }
        };
        ionic.Gestures.gestures.Drag = {
          name: 'drag',
          index: 50,
          defaults: {
            drag_min_distance: 10,
            correct_for_drag_min_distance: true,
            drag_max_touches: 1,
            drag_block_horizontal: true,
            drag_block_vertical: true,
            drag_lock_to_axis: false,
            drag_lock_min_distance: 25,
            prevent_default_directions: []
          },
          triggered: false,
          handler: function dragGesture(ev, inst) {
            if (ev.srcEvent.type == 'touchstart' || ev.srcEvent.type == 'touchend') {
              this.preventedFirstMove = false;
            } else if (!this.preventedFirstMove && ev.srcEvent.type == 'touchmove') {
              if (inst.options.prevent_default_directions.indexOf(ev.direction) != -1) {
                ev.srcEvent.preventDefault();
              }
              this.preventedFirstMove = true;
            }
            if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
              inst.trigger(this.name + 'end', ev);
              this.triggered = false;
              return;
            }
            if (inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches) {
              return;
            }
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                this.triggered = false;
                break;
              case ionic.Gestures.EVENT_MOVE:
                if (ev.distance < inst.options.drag_min_distance && ionic.Gestures.detection.current.name != this.name) {
                  return;
                }
                if (ionic.Gestures.detection.current.name != this.name) {
                  ionic.Gestures.detection.current.name = this.name;
                  if (inst.options.correct_for_drag_min_distance) {
                    var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
                    ionic.Gestures.detection.current.startEvent.center.pageX += ev.deltaX * factor;
                    ionic.Gestures.detection.current.startEvent.center.pageY += ev.deltaY * factor;
                    ev = ionic.Gestures.detection.extendEventData(ev);
                  }
                }
                if (ionic.Gestures.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance)) {
                  ev.drag_locked_to_axis = true;
                }
                var last_direction = ionic.Gestures.detection.current.lastEvent.direction;
                if (ev.drag_locked_to_axis && last_direction !== ev.direction) {
                  if (ionic.Gestures.utils.isVertical(last_direction)) {
                    ev.direction = (ev.deltaY < 0) ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
                  } else {
                    ev.direction = (ev.deltaX < 0) ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
                  }
                }
                if (!this.triggered) {
                  inst.trigger(this.name + 'start', ev);
                  this.triggered = true;
                }
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
                if ((inst.options.drag_block_vertical && ionic.Gestures.utils.isVertical(ev.direction)) || (inst.options.drag_block_horizontal && !ionic.Gestures.utils.isVertical(ev.direction))) {
                  ev.preventDefault();
                }
                break;
              case ionic.Gestures.EVENT_END:
                if (this.triggered) {
                  inst.trigger(this.name + 'end', ev);
                }
                this.triggered = false;
                break;
            }
          }
        };
        ionic.Gestures.gestures.Transform = {
          name: 'transform',
          index: 45,
          defaults: {
            transform_min_scale: 0.01,
            transform_min_rotation: 1,
            transform_always_block: false
          },
          triggered: false,
          handler: function transformGesture(ev, inst) {
            if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
              inst.trigger(this.name + 'end', ev);
              this.triggered = false;
              return;
            }
            if (ev.touches.length < 2) {
              return;
            }
            if (inst.options.transform_always_block) {
              ev.preventDefault();
            }
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                this.triggered = false;
                break;
              case ionic.Gestures.EVENT_MOVE:
                var scale_threshold = Math.abs(1 - ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);
                if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) {
                  return;
                }
                ionic.Gestures.detection.current.name = this.name;
                if (!this.triggered) {
                  inst.trigger(this.name + 'start', ev);
                  this.triggered = true;
                }
                inst.trigger(this.name, ev);
                if (rotation_threshold > inst.options.transform_min_rotation) {
                  inst.trigger('rotate', ev);
                }
                if (scale_threshold > inst.options.transform_min_scale) {
                  inst.trigger('pinch', ev);
                  inst.trigger('pinch' + ((ev.scale < 1) ? 'in' : 'out'), ev);
                }
                break;
              case ionic.Gestures.EVENT_END:
                if (this.triggered) {
                  inst.trigger(this.name + 'end', ev);
                }
                this.triggered = false;
                break;
            }
          }
        };
        ionic.Gestures.gestures.Touch = {
          name: 'touch',
          index: -Infinity,
          defaults: {
            prevent_default: false,
            prevent_mouseevents: false
          },
          handler: function touchGesture(ev, inst) {
            if (inst.options.prevent_mouseevents && ev.pointerType == ionic.Gestures.POINTER_MOUSE) {
              ev.stopDetect();
              return;
            }
            if (inst.options.prevent_default) {
              ev.preventDefault();
            }
            if (ev.eventType == ionic.Gestures.EVENT_START) {
              inst.trigger(this.name, ev);
            }
          }
        };
        ionic.Gestures.gestures.Release = {
          name: 'release',
          index: Infinity,
          handler: function releaseGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END) {
              inst.trigger(this.name, ev);
            }
          }
        };
      })(window.ionic);
      (function(window, document, ionic) {
        function getParameterByName(name) {
          name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
          var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
              results = regex.exec(location.search);
          return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        }
        var IOS = 'ios';
        var ANDROID = 'android';
        var WINDOWS_PHONE = 'windowsphone';
        var requestAnimationFrame = ionic.requestAnimationFrame;
        var self = ionic.Platform = {
          navigator: window.navigator,
          isReady: false,
          isFullScreen: false,
          platforms: null,
          grade: null,
          ua: navigator.userAgent,
          ready: function(cb) {
            if (self.isReady) {
              cb();
            } else {
              readyCallbacks.push(cb);
            }
          },
          detect: function() {
            self._checkPlatforms();
            requestAnimationFrame(function() {
              for (var i = 0; i < self.platforms.length; i++) {
                document.body.classList.add('platform-' + self.platforms[i]);
              }
            });
          },
          setGrade: function(grade) {
            var oldGrade = self.grade;
            self.grade = grade;
            requestAnimationFrame(function() {
              if (oldGrade) {
                document.body.classList.remove('grade-' + oldGrade);
              }
              document.body.classList.add('grade-' + grade);
            });
          },
          device: function() {
            return window.device || {};
          },
          _checkPlatforms: function() {
            self.platforms = [];
            var grade = 'a';
            if (self.isWebView()) {
              self.platforms.push('webview');
              if (!(!window.cordova && !window.PhoneGap && !window.phonegap)) {
                self.platforms.push('cordova');
              } else if (window.forge) {
                self.platforms.push('trigger');
              }
            } else {
              self.platforms.push('browser');
            }
            if (self.isIPad())
              self.platforms.push('ipad');
            var platform = self.platform();
            if (platform) {
              self.platforms.push(platform);
              var version = self.version();
              if (version) {
                var v = version.toString();
                if (v.indexOf('.') > 0) {
                  v = v.replace('.', '_');
                } else {
                  v += '_0';
                }
                self.platforms.push(platform + v.split('_')[0]);
                self.platforms.push(platform + v);
                if (self.isAndroid() && version < 4.4) {
                  grade = (version < 4 ? 'c' : 'b');
                } else if (self.isWindowsPhone()) {
                  grade = 'b';
                }
              }
            }
            self.setGrade(grade);
          },
          isWebView: function() {
            return !(!window.cordova && !window.PhoneGap && !window.phonegap && !window.forge);
          },
          isIPad: function() {
            if (/iPad/i.test(self.navigator.platform)) {
              return true;
            }
            return /iPad/i.test(self.ua);
          },
          isIOS: function() {
            return self.is(IOS);
          },
          isAndroid: function() {
            return self.is(ANDROID);
          },
          isWindowsPhone: function() {
            return self.is(WINDOWS_PHONE);
          },
          platform: function() {
            if (platformName === null)
              self.setPlatform(self.device().platform);
            return platformName;
          },
          setPlatform: function(n) {
            if (typeof n != 'undefined' && n !== null && n.length) {
              platformName = n.toLowerCase();
            } else if (getParameterByName('ionicplatform')) {
              platformName = getParameterByName('ionicplatform');
            } else if (self.ua.indexOf('Android') > 0) {
              platformName = ANDROID;
            } else if (/iPhone|iPad|iPod/.test(self.ua)) {
              platformName = IOS;
            } else if (self.ua.indexOf('Windows Phone') > -1) {
              platformName = WINDOWS_PHONE;
            } else {
              platformName = self.navigator.platform && navigator.platform.toLowerCase().split(' ')[0] || '';
            }
          },
          version: function() {
            if (platformVersion === null)
              self.setVersion(self.device().version);
            return platformVersion;
          },
          setVersion: function(v) {
            if (typeof v != 'undefined' && v !== null) {
              v = v.split('.');
              v = parseFloat(v[0] + '.' + (v.length > 1 ? v[1] : 0));
              if (!isNaN(v)) {
                platformVersion = v;
                return;
              }
            }
            platformVersion = 0;
            var pName = self.platform();
            var versionMatch = {
              'android': /Android (\d+).(\d+)?/,
              'ios': /OS (\d+)_(\d+)?/,
              'windowsphone': /Windows Phone (\d+).(\d+)?/
            };
            if (versionMatch[pName]) {
              v = self.ua.match(versionMatch[pName]);
              if (v && v.length > 2) {
                platformVersion = parseFloat(v[1] + '.' + v[2]);
              }
            }
          },
          is: function(type) {
            type = type.toLowerCase();
            if (self.platforms) {
              for (var x = 0; x < self.platforms.length; x++) {
                if (self.platforms[x] === type)
                  return true;
              }
            }
            var pName = self.platform();
            if (pName) {
              return pName === type.toLowerCase();
            }
            return self.ua.toLowerCase().indexOf(type) >= 0;
          },
          exitApp: function() {
            self.ready(function() {
              navigator.app && navigator.app.exitApp && navigator.app.exitApp();
            });
          },
          showStatusBar: function(val) {
            self._showStatusBar = val;
            self.ready(function() {
              requestAnimationFrame(function() {
                if (self._showStatusBar) {
                  window.StatusBar && window.StatusBar.show();
                  document.body.classList.remove('status-bar-hide');
                } else {
                  window.StatusBar && window.StatusBar.hide();
                  document.body.classList.add('status-bar-hide');
                }
              });
            });
          },
          fullScreen: function(showFullScreen, showStatusBar) {
            self.isFullScreen = (showFullScreen !== false);
            ionic.DomUtil.ready(function() {
              requestAnimationFrame(function() {
                if (self.isFullScreen) {
                  document.body.classList.add('fullscreen');
                } else {
                  document.body.classList.remove('fullscreen');
                }
              });
              self.showStatusBar((showStatusBar === true));
            });
          }
        };
        var platformName = null,
            platformVersion = null,
            readyCallbacks = [],
            windowLoadListenderAttached;
        function onWindowLoad() {
          if (self.isWebView()) {
            document.addEventListener("deviceready", onPlatformReady, false);
          } else {
            onPlatformReady();
          }
          if (windowLoadListenderAttached) {
            window.removeEventListener("load", onWindowLoad, false);
          }
        }
        if (document.readyState === 'complete') {
          onWindowLoad();
        } else {
          windowLoadListenderAttached = true;
          window.addEventListener("load", onWindowLoad, false);
        }
        function onPlatformReady() {
          self.isReady = true;
          self.detect();
          for (var x = 0; x < readyCallbacks.length; x++) {
            readyCallbacks[x]();
          }
          readyCallbacks = [];
          ionic.trigger('platformready', {target: document});
          requestAnimationFrame(function() {
            document.body.classList.add('platform-ready');
          });
        }
      })(this, document, ionic);
      (function(document, ionic) {
        'use strict';
        ionic.CSS = {};
        (function() {
          var i,
              keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
          for (i = 0; i < keys.length; i++) {
            if (document.documentElement.style[keys[i]] !== undefined) {
              ionic.CSS.TRANSFORM = keys[i];
              break;
            }
          }
          keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
          for (i = 0; i < keys.length; i++) {
            if (document.documentElement.style[keys[i]] !== undefined) {
              ionic.CSS.TRANSITION = keys[i];
              break;
            }
          }
          var isWebkit = ionic.CSS.TRANSITION.indexOf('webkit') > -1;
          ionic.CSS.TRANSITION_DURATION = (isWebkit ? '-webkit-' : '') + 'transition-duration';
          ionic.CSS.TRANSITIONEND = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
        })();
        if (!("classList" in document.documentElement) && Object.defineProperty && typeof HTMLElement !== 'undefined') {
          Object.defineProperty(HTMLElement.prototype, 'classList', {get: function() {
              var self = this;
              function update(fn) {
                return function() {
                  var x,
                      classes = self.className.split(/\s+/);
                  for (x = 0; x < arguments.length; x++) {
                    fn(classes, classes.indexOf(arguments[x]), arguments[x]);
                  }
                  self.className = classes.join(" ");
                };
              }
              return {
                add: update(function(classes, index, value) {
                  ~index || classes.push(value);
                }),
                remove: update(function(classes, index) {
                  ~index && classes.splice(index, 1);
                }),
                toggle: update(function(classes, index, value) {
                  ~index ? classes.splice(index, 1) : classes.push(value);
                }),
                contains: function(value) {
                  return !!~self.className.split(/\s+/).indexOf(value);
                },
                item: function(i) {
                  return self.className.split(/\s+/)[i] || null;
                }
              };
            }});
        }
      })(document, ionic);
      var tapDoc;
      var tapActiveEle;
      var tapEnabledTouchEvents;
      var tapMouseResetTimer;
      var tapPointerMoved;
      var tapPointerStart;
      var tapTouchFocusedInput;
      var tapLastTouchTarget;
      var tapTouchMoveListener = 'touchmove';
      var TAP_RELEASE_TOLERANCE = 12;
      var TAP_RELEASE_BUTTON_TOLERANCE = 50;
      var tapEventListeners = {
        'click': tapClickGateKeeper,
        'mousedown': tapMouseDown,
        'mouseup': tapMouseUp,
        'mousemove': tapMouseMove,
        'touchstart': tapTouchStart,
        'touchend': tapTouchEnd,
        'touchcancel': tapTouchCancel,
        'touchmove': tapTouchMove,
        'pointerdown': tapTouchStart,
        'pointerup': tapTouchEnd,
        'pointercancel': tapTouchCancel,
        'pointermove': tapTouchMove,
        'MSPointerDown': tapTouchStart,
        'MSPointerUp': tapTouchEnd,
        'MSPointerCancel': tapTouchCancel,
        'MSPointerMove': tapTouchMove,
        'focusin': tapFocusIn,
        'focusout': tapFocusOut
      };
      ionic.tap = {
        register: function(ele) {
          tapDoc = ele;
          tapEventListener('click', true, true);
          tapEventListener('mouseup');
          tapEventListener('mousedown');
          if (window.navigator.pointerEnabled) {
            tapEventListener('pointerdown');
            tapEventListener('pointerup');
            tapEventListener('pointcancel');
            tapTouchMoveListener = 'pointermove';
          } else if (window.navigator.msPointerEnabled) {
            tapEventListener('MSPointerDown');
            tapEventListener('MSPointerUp');
            tapEventListener('MSPointerCancel');
            tapTouchMoveListener = 'MSPointerMove';
          } else {
            tapEventListener('touchstart');
            tapEventListener('touchend');
            tapEventListener('touchcancel');
          }
          tapEventListener('focusin');
          tapEventListener('focusout');
          return function() {
            for (var type in tapEventListeners) {
              tapEventListener(type, false);
            }
            tapDoc = null;
            tapActiveEle = null;
            tapEnabledTouchEvents = false;
            tapPointerMoved = false;
            tapPointerStart = null;
          };
        },
        ignoreScrollStart: function(e) {
          return (e.defaultPrevented) || (/^(file|range)$/i).test(e.target.type) || (e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll')) == 'true' || (!!(/^(object|embed)$/i).test(e.target.tagName)) || ionic.tap.isElementTapDisabled(e.target);
        },
        isTextInput: function(ele) {
          return !!ele && (ele.tagName == 'TEXTAREA' || ele.contentEditable === 'true' || (ele.tagName == 'INPUT' && !(/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i).test(ele.type)));
        },
        isDateInput: function(ele) {
          return !!ele && (ele.tagName == 'INPUT' && (/^(date|time|datetime-local|month|week)$/i).test(ele.type));
        },
        isKeyboardElement: function(ele) {
          if (!ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
            return ionic.tap.isTextInput(ele) && !ionic.tap.isDateInput(ele);
          } else {
            return ionic.tap.isTextInput(ele) || (!!ele && ele.tagName == "SELECT");
          }
        },
        isLabelWithTextInput: function(ele) {
          var container = tapContainingElement(ele, false);
          return !!container && ionic.tap.isTextInput(tapTargetElement(container));
        },
        containsOrIsTextInput: function(ele) {
          return ionic.tap.isTextInput(ele) || ionic.tap.isLabelWithTextInput(ele);
        },
        cloneFocusedInput: function(container) {
          if (ionic.tap.hasCheckedClone)
            return;
          ionic.tap.hasCheckedClone = true;
          ionic.requestAnimationFrame(function() {
            var focusInput = container.querySelector(':focus');
            if (ionic.tap.isTextInput(focusInput)) {
              var clonedInput = focusInput.cloneNode(true);
              clonedInput.value = focusInput.value;
              clonedInput.classList.add('cloned-text-input');
              clonedInput.readOnly = true;
              if (focusInput.isContentEditable) {
                clonedInput.contentEditable = focusInput.contentEditable;
                clonedInput.innerHTML = focusInput.innerHTML;
              }
              focusInput.parentElement.insertBefore(clonedInput, focusInput);
              focusInput.classList.add('previous-input-focus');
              clonedInput.scrollTop = focusInput.scrollTop;
            }
          });
        },
        hasCheckedClone: false,
        removeClonedInputs: function(container) {
          ionic.tap.hasCheckedClone = false;
          ionic.requestAnimationFrame(function() {
            var clonedInputs = container.querySelectorAll('.cloned-text-input');
            var previousInputFocus = container.querySelectorAll('.previous-input-focus');
            var x;
            for (x = 0; x < clonedInputs.length; x++) {
              clonedInputs[x].parentElement.removeChild(clonedInputs[x]);
            }
            for (x = 0; x < previousInputFocus.length; x++) {
              previousInputFocus[x].classList.remove('previous-input-focus');
              previousInputFocus[x].style.top = '';
              if (ionic.keyboard.isOpen && !ionic.keyboard.isClosing)
                previousInputFocus[x].focus();
            }
          });
        },
        requiresNativeClick: function(ele) {
          if (!ele || ele.disabled || (/^(file|range)$/i).test(ele.type) || (/^(object|video)$/i).test(ele.tagName) || ionic.tap.isLabelContainingFileInput(ele)) {
            return true;
          }
          return ionic.tap.isElementTapDisabled(ele);
        },
        isLabelContainingFileInput: function(ele) {
          var lbl = tapContainingElement(ele);
          if (lbl.tagName !== 'LABEL')
            return false;
          var fileInput = lbl.querySelector('input[type=file]');
          if (fileInput && fileInput.disabled === false)
            return true;
          return false;
        },
        isElementTapDisabled: function(ele) {
          if (ele && ele.nodeType === 1) {
            var element = ele;
            while (element) {
              if ((element.dataset ? element.dataset.tapDisabled : element.getAttribute('data-tap-disabled')) == 'true') {
                return true;
              }
              element = element.parentElement;
            }
          }
          return false;
        },
        setTolerance: function(releaseTolerance, releaseButtonTolerance) {
          TAP_RELEASE_TOLERANCE = releaseTolerance;
          TAP_RELEASE_BUTTON_TOLERANCE = releaseButtonTolerance;
        },
        cancelClick: function() {
          tapPointerMoved = true;
        },
        pointerCoord: function(event) {
          var c = {
            x: 0,
            y: 0
          };
          if (event) {
            var touches = event.touches && event.touches.length ? event.touches : [event];
            var e = (event.changedTouches && event.changedTouches[0]) || touches[0];
            if (e) {
              c.x = e.clientX || e.pageX || 0;
              c.y = e.clientY || e.pageY || 0;
            }
          }
          return c;
        }
      };
      function tapEventListener(type, enable, useCapture) {
        if (enable !== false) {
          tapDoc.addEventListener(type, tapEventListeners[type], useCapture);
        } else {
          tapDoc.removeEventListener(type, tapEventListeners[type]);
        }
      }
      function tapClick(e) {
        var container = tapContainingElement(e.target);
        var ele = tapTargetElement(container);
        if (ionic.tap.requiresNativeClick(ele) || tapPointerMoved)
          return false;
        var c = ionic.tap.pointerCoord(e);
        triggerMouseEvent('click', ele, c.x, c.y);
        tapHandleFocus(ele);
      }
      function triggerMouseEvent(type, ele, x, y) {
        var clickEvent = document.createEvent("MouseEvents");
        clickEvent.initMouseEvent(type, true, true, window, 1, 0, 0, x, y, false, false, false, false, 0, null);
        clickEvent.isIonicTap = true;
        ele.dispatchEvent(clickEvent);
      }
      function tapClickGateKeeper(e) {
        if (e.target.type == 'submit' && e.detail === 0) {
          return null;
        }
        if ((ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) || (!e.isIonicTap && !ionic.tap.requiresNativeClick(e.target))) {
          e.stopPropagation();
          if (!ionic.tap.isLabelWithTextInput(e.target)) {
            e.preventDefault();
          }
          return false;
        }
      }
      function tapMouseDown(e) {
        if (e.isIonicTap || tapIgnoreEvent(e))
          return null;
        if (tapEnabledTouchEvents) {
          void 0;
          e.stopPropagation();
          if ((!ionic.tap.isTextInput(e.target) || tapLastTouchTarget !== e.target) && !(/^(select|option)$/i).test(e.target.tagName)) {
            e.preventDefault();
          }
          return false;
        }
        tapPointerMoved = false;
        tapPointerStart = ionic.tap.pointerCoord(e);
        tapEventListener('mousemove');
        ionic.activator.start(e);
      }
      function tapMouseUp(e) {
        if (tapEnabledTouchEvents) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        if (tapIgnoreEvent(e) || (/^(select|option)$/i).test(e.target.tagName))
          return false;
        if (!tapHasPointerMoved(e)) {
          tapClick(e);
        }
        tapEventListener('mousemove', false);
        ionic.activator.end();
        tapPointerMoved = false;
      }
      function tapMouseMove(e) {
        if (tapHasPointerMoved(e)) {
          tapEventListener('mousemove', false);
          ionic.activator.end();
          tapPointerMoved = true;
          return false;
        }
      }
      function tapTouchStart(e) {
        if (tapIgnoreEvent(e))
          return;
        tapPointerMoved = false;
        tapEnableTouchEvents();
        tapPointerStart = ionic.tap.pointerCoord(e);
        tapEventListener(tapTouchMoveListener);
        ionic.activator.start(e);
        if (ionic.Platform.isIOS() && ionic.tap.isLabelWithTextInput(e.target)) {
          var textInput = tapTargetElement(tapContainingElement(e.target));
          if (textInput !== tapActiveEle) {
            e.preventDefault();
          }
        }
      }
      function tapTouchEnd(e) {
        if (tapIgnoreEvent(e))
          return;
        tapEnableTouchEvents();
        if (!tapHasPointerMoved(e)) {
          tapClick(e);
          if ((/^(select|option)$/i).test(e.target.tagName)) {
            e.preventDefault();
          }
        }
        tapLastTouchTarget = e.target;
        tapTouchCancel();
      }
      function tapTouchMove(e) {
        if (tapHasPointerMoved(e)) {
          tapPointerMoved = true;
          tapEventListener(tapTouchMoveListener, false);
          ionic.activator.end();
          return false;
        }
      }
      function tapTouchCancel() {
        tapEventListener(tapTouchMoveListener, false);
        ionic.activator.end();
        tapPointerMoved = false;
      }
      function tapEnableTouchEvents() {
        tapEnabledTouchEvents = true;
        clearTimeout(tapMouseResetTimer);
        tapMouseResetTimer = setTimeout(function() {
          tapEnabledTouchEvents = false;
        }, 600);
      }
      function tapIgnoreEvent(e) {
        if (e.isTapHandled)
          return true;
        e.isTapHandled = true;
        if (ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) {
          e.preventDefault();
          return true;
        }
      }
      function tapHandleFocus(ele) {
        tapTouchFocusedInput = null;
        var triggerFocusIn = false;
        if (ele.tagName == 'SELECT') {
          triggerMouseEvent('mousedown', ele, 0, 0);
          ele.focus && ele.focus();
          triggerFocusIn = true;
        } else if (tapActiveElement() === ele) {
          triggerFocusIn = true;
        } else if ((/^(input|textarea)$/i).test(ele.tagName) || ele.isContentEditable) {
          triggerFocusIn = true;
          ele.focus && ele.focus();
          ele.value = ele.value;
          if (tapEnabledTouchEvents) {
            tapTouchFocusedInput = ele;
          }
        } else {
          tapFocusOutActive();
        }
        if (triggerFocusIn) {
          tapActiveElement(ele);
          ionic.trigger('ionic.focusin', {target: ele}, true);
        }
      }
      function tapFocusOutActive() {
        var ele = tapActiveElement();
        if (ele && ((/^(input|textarea|select)$/i).test(ele.tagName) || ele.isContentEditable)) {
          void 0;
          ele.blur();
        }
        tapActiveElement(null);
      }
      function tapFocusIn(e) {
        if (tapEnabledTouchEvents && ionic.tap.isTextInput(tapActiveElement()) && ionic.tap.isTextInput(tapTouchFocusedInput) && tapTouchFocusedInput !== e.target) {
          void 0;
          tapTouchFocusedInput.focus();
          tapTouchFocusedInput = null;
        }
        ionic.scroll.isScrolling = false;
      }
      function tapFocusOut() {
        tapActiveElement(null);
      }
      function tapActiveElement(ele) {
        if (arguments.length) {
          tapActiveEle = ele;
        }
        return tapActiveEle || document.activeElement;
      }
      function tapHasPointerMoved(endEvent) {
        if (!endEvent || endEvent.target.nodeType !== 1 || !tapPointerStart || (tapPointerStart.x === 0 && tapPointerStart.y === 0)) {
          return false;
        }
        var endCoordinates = ionic.tap.pointerCoord(endEvent);
        var hasClassList = !!(endEvent.target.classList && endEvent.target.classList.contains && typeof endEvent.target.classList.contains === 'function');
        var releaseTolerance = hasClassList && endEvent.target.classList.contains('button') ? TAP_RELEASE_BUTTON_TOLERANCE : TAP_RELEASE_TOLERANCE;
        return Math.abs(tapPointerStart.x - endCoordinates.x) > releaseTolerance || Math.abs(tapPointerStart.y - endCoordinates.y) > releaseTolerance;
      }
      function tapContainingElement(ele, allowSelf) {
        var climbEle = ele;
        for (var x = 0; x < 6; x++) {
          if (!climbEle)
            break;
          if (climbEle.tagName === 'LABEL')
            return climbEle;
          climbEle = climbEle.parentElement;
        }
        if (allowSelf !== false)
          return ele;
      }
      function tapTargetElement(ele) {
        if (ele && ele.tagName === 'LABEL') {
          if (ele.control)
            return ele.control;
          if (ele.querySelector) {
            var control = ele.querySelector('input,textarea,select');
            if (control)
              return control;
          }
        }
        return ele;
      }
      ionic.DomUtil.ready(function() {
        var ng = typeof angular !== 'undefined' ? angular : null;
        if (!ng || (ng && !ng.scenario)) {
          ionic.tap.register(document);
        }
      });
      (function(document, ionic) {
        'use strict';
        var queueElements = {};
        var activeElements = {};
        var keyId = 0;
        var ACTIVATED_CLASS = 'activated';
        ionic.activator = {
          start: function(e) {
            var hitX = ionic.tap.pointerCoord(e).x;
            if (hitX > 0 && hitX < 30) {
              return;
            }
            ionic.requestAnimationFrame(function() {
              if ((ionic.scroll && ionic.scroll.isScrolling) || ionic.tap.requiresNativeClick(e.target))
                return;
              var ele = e.target;
              var eleToActivate;
              for (var x = 0; x < 6; x++) {
                if (!ele || ele.nodeType !== 1)
                  break;
                if (eleToActivate && ele.classList && ele.classList.contains('item')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.tagName == 'A' || ele.tagName == 'BUTTON' || ele.hasAttribute('ng-click')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.classList.contains('button')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.tagName == 'ION-CONTENT' || (ele.classList && ele.classList.contains('pane')) || ele.tagName == 'BODY') {
                  break;
                }
                ele = ele.parentElement;
              }
              if (eleToActivate) {
                queueElements[keyId] = eleToActivate;
                ionic.requestAnimationFrame(activateElements);
                keyId = (keyId > 29 ? 0 : keyId + 1);
              }
            });
          },
          end: function() {
            setTimeout(clear, 200);
          }
        };
        function clear() {
          queueElements = {};
          ionic.requestAnimationFrame(deactivateElements);
        }
        function activateElements() {
          for (var key in queueElements) {
            if (queueElements[key]) {
              queueElements[key].classList.add(ACTIVATED_CLASS);
              activeElements[key] = queueElements[key];
            }
          }
          queueElements = {};
        }
        function deactivateElements() {
          if (ionic.transition && ionic.transition.isActive) {
            setTimeout(deactivateElements, 400);
            return;
          }
          for (var key in activeElements) {
            if (activeElements[key]) {
              activeElements[key].classList.remove(ACTIVATED_CLASS);
              delete activeElements[key];
            }
          }
        }
      })(document, ionic);
      (function(ionic) {
        var nextId = 0;
        ionic.Utils = {
          arrayMove: function(arr, oldIndex, newIndex) {
            if (newIndex >= arr.length) {
              var k = newIndex - arr.length;
              while ((k--) + 1) {
                arr.push(undefined);
              }
            }
            arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
            return arr;
          },
          proxy: function(func, context) {
            var args = Array.prototype.slice.call(arguments, 2);
            return function() {
              return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));
            };
          },
          debounce: function(func, wait, immediate) {
            var timeout,
                args,
                context,
                timestamp,
                result;
            return function() {
              context = this;
              args = arguments;
              timestamp = new Date();
              var later = function() {
                var last = (new Date()) - timestamp;
                if (last < wait) {
                  timeout = setTimeout(later, wait - last);
                } else {
                  timeout = null;
                  if (!immediate)
                    result = func.apply(context, args);
                }
              };
              var callNow = immediate && !timeout;
              if (!timeout) {
                timeout = setTimeout(later, wait);
              }
              if (callNow)
                result = func.apply(context, args);
              return result;
            };
          },
          throttle: function(func, wait, options) {
            var context,
                args,
                result;
            var timeout = null;
            var previous = 0;
            options || (options = {});
            var later = function() {
              previous = options.leading === false ? 0 : Date.now();
              timeout = null;
              result = func.apply(context, args);
            };
            return function() {
              var now = Date.now();
              if (!previous && options.leading === false)
                previous = now;
              var remaining = wait - (now - previous);
              context = this;
              args = arguments;
              if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
              } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
              }
              return result;
            };
          },
          inherit: function(protoProps, staticProps) {
            var parent = this;
            var child;
            if (protoProps && protoProps.hasOwnProperty('constructor')) {
              child = protoProps.constructor;
            } else {
              child = function() {
                return parent.apply(this, arguments);
              };
            }
            ionic.extend(child, parent, staticProps);
            var Surrogate = function() {
              this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            if (protoProps)
              ionic.extend(child.prototype, protoProps);
            child.__super__ = parent.prototype;
            return child;
          },
          extend: function(obj) {
            var args = Array.prototype.slice.call(arguments, 1);
            for (var i = 0; i < args.length; i++) {
              var source = args[i];
              if (source) {
                for (var prop in source) {
                  obj[prop] = source[prop];
                }
              }
            }
            return obj;
          },
          nextUid: function() {
            return 'ion' + (nextId++);
          },
          disconnectScope: function disconnectScope(scope) {
            if (!scope)
              return;
            if (scope.$root === scope) {
              return;
            }
            var parent = scope.$parent;
            scope.$$disconnected = true;
            scope.$broadcast('$ionic.disconnectScope', scope);
            if (parent.$$childHead === scope) {
              parent.$$childHead = scope.$$nextSibling;
            }
            if (parent.$$childTail === scope) {
              parent.$$childTail = scope.$$prevSibling;
            }
            if (scope.$$prevSibling) {
              scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
            }
            if (scope.$$nextSibling) {
              scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
            }
            scope.$$nextSibling = scope.$$prevSibling = null;
          },
          reconnectScope: function reconnectScope(scope) {
            if (!scope)
              return;
            if (scope.$root === scope) {
              return;
            }
            if (!scope.$$disconnected) {
              return;
            }
            var parent = scope.$parent;
            scope.$$disconnected = false;
            scope.$broadcast('$ionic.reconnectScope', scope);
            scope.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = scope;
              parent.$$childTail = scope;
            } else {
              parent.$$childHead = parent.$$childTail = scope;
            }
          },
          isScopeDisconnected: function(scope) {
            var climbScope = scope;
            while (climbScope) {
              if (climbScope.$$disconnected)
                return true;
              climbScope = climbScope.$parent;
            }
            return false;
          }
        };
        ionic.inherit = ionic.Utils.inherit;
        ionic.extend = ionic.Utils.extend;
        ionic.throttle = ionic.Utils.throttle;
        ionic.proxy = ionic.Utils.proxy;
        ionic.debounce = ionic.Utils.debounce;
      })(window.ionic);
      var keyboardCurrentViewportHeight = 0;
      var keyboardPortraitViewportHeight = 0;
      var keyboardLandscapeViewportHeight = 0;
      var keyboardActiveElement;
      var scrollView;
      var waitForResizeTimer;
      var keyboardFocusOutTimer;
      var wasOrientationChange = false;
      var KEYBOARD_OPEN_CSS = 'keyboard-open';
      var SCROLL_CONTAINER_CSS = 'scroll-content';
      var debouncedKeyboardFocusIn = ionic.debounce(keyboardFocusIn, 200, true);
      var debouncedKeyboardNativeShow = ionic.debounce(keyboardNativeShow, 100, true);
      ionic.keyboard = {
        isOpen: false,
        isClosing: false,
        isOpening: false,
        height: 0,
        isLandscape: false,
        isInitialized: false,
        hide: function() {
          if (keyboardHasPlugin()) {
            cordova.plugins.Keyboard.close();
          }
          keyboardActiveElement && keyboardActiveElement.blur();
        },
        show: function() {
          if (keyboardHasPlugin()) {
            cordova.plugins.Keyboard.show();
          }
        },
        disable: function() {
          if (keyboardHasPlugin()) {
            window.removeEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
            window.removeEventListener('native.keyboardhide', keyboardFocusOut);
          } else {
            document.body.removeEventListener('focusout', keyboardFocusOut);
          }
          document.body.removeEventListener('ionic.focusin', debouncedKeyboardFocusIn);
          document.body.removeEventListener('focusin', debouncedKeyboardFocusIn);
          window.removeEventListener('orientationchange', keyboardOrientationChange);
          if (window.navigator.msPointerEnabled) {
            document.removeEventListener("MSPointerDown", keyboardInit);
          } else {
            document.removeEventListener('touchstart', keyboardInit);
          }
          ionic.keyboard.isInitialized = false;
        },
        enable: function() {
          keyboardInit();
        }
      };
      keyboardCurrentViewportHeight = getViewportHeight();
      function keyboardInit() {
        if (ionic.keyboard.isInitialized)
          return;
        if (keyboardHasPlugin()) {
          window.addEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
          window.addEventListener('native.keyboardhide', keyboardFocusOut);
        } else {
          document.body.addEventListener('focusout', keyboardFocusOut);
        }
        document.body.addEventListener('ionic.focusin', debouncedKeyboardFocusIn);
        document.body.addEventListener('focusin', debouncedKeyboardFocusIn);
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerDown", keyboardInit);
        } else {
          document.removeEventListener('touchstart', keyboardInit);
        }
        ionic.keyboard.isInitialized = true;
      }
      function keyboardNativeShow(e) {
        clearTimeout(keyboardFocusOutTimer);
        if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
          ionic.keyboard.isOpening = true;
          ionic.keyboard.isClosing = false;
        }
        ionic.keyboard.height = e.keyboardHeight;
        if (wasOrientationChange) {
          keyboardWaitForResize(keyboardUpdateViewportHeight, true);
        } else {
          keyboardWaitForResize(keyboardShow, true);
        }
      }
      function keyboardFocusIn(e) {
        clearTimeout(keyboardFocusOutTimer);
        if (!e.target || e.target.readOnly || !ionic.tap.isKeyboardElement(e.target) || !(scrollView = inputScrollView(e.target))) {
          keyboardActiveElement = null;
          return;
        }
        keyboardActiveElement = e.target;
        document.body.scrollTop = 0;
        scrollView.scrollTop = 0;
        ionic.requestAnimationFrame(function() {
          document.body.scrollTop = 0;
          scrollView.scrollTop = 0;
        });
        if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
          ionic.keyboard.isOpening = true;
          ionic.keyboard.isClosing = false;
        }
        document.addEventListener('keydown', keyboardOnKeyDown, false);
        if (window.navigator.msPointerEnabled) {
          document.addEventListener("MSPointerMove", keyboardPreventDefault, false);
        } else {
          document.addEventListener('touchmove', keyboardPreventDefault, false);
        }
        if (!ionic.keyboard.isOpen && !keyboardHasPlugin()) {
          keyboardWaitForResize(keyboardShow, true);
        } else if (ionic.keyboard.isOpen) {
          keyboardShow();
        }
      }
      function keyboardFocusOut() {
        clearTimeout(keyboardFocusOutTimer);
        if (ionic.keyboard.isOpen || ionic.keyboard.isOpening) {
          ionic.keyboard.isClosing = true;
          ionic.keyboard.isOpening = false;
        }
        keyboardFocusOutTimer = setTimeout(function() {
          ionic.requestAnimationFrame(function() {
            if (wasOrientationChange) {
              keyboardWaitForResize(function() {
                keyboardUpdateViewportHeight();
                keyboardHide();
              }, false);
            } else {
              keyboardWaitForResize(keyboardHide, false);
            }
          });
        }, 50);
      }
      function keyboardOrientationChange() {
        ionic.keyboard.isLandscape = !ionic.keyboard.isLandscape;
        if (ionic.Platform.isIOS()) {
          keyboardUpdateViewportHeight();
        }
        if (ionic.Platform.isAndroid()) {
          if (!ionic.keyboard.isOpen || !keyboardHasPlugin()) {
            keyboardWaitForResize(keyboardUpdateViewportHeight, false);
          } else {
            wasOrientationChange = true;
          }
        }
      }
      function keyboardOnKeyDown(e) {
        if (ionic.scroll.isScrolling) {
          keyboardPreventDefault(e);
        }
      }
      function keyboardPreventDefault(e) {
        if (e.target.tagName !== 'TEXTAREA') {
          e.preventDefault();
        }
      }
      function keyboardWaitForResize(callback, isOpening) {
        clearInterval(waitForResizeTimer);
        var count = 0;
        var maxCount;
        var initialHeight = getViewportHeight();
        var viewportHeight = initialHeight;
        if (ionic.Platform.isAndroid() && ionic.Platform.version() < 4.4) {
          maxCount = 30;
        } else if (ionic.Platform.isAndroid()) {
          maxCount = 10;
        } else {
          maxCount = 1;
        }
        waitForResizeTimer = setInterval(function() {
          viewportHeight = getViewportHeight();
          if (++count < maxCount && ((!isPortraitViewportHeight(viewportHeight) && !isLandscapeViewportHeight(viewportHeight)) || !ionic.keyboard.height)) {
            return;
          }
          if (!keyboardHasPlugin()) {
            ionic.keyboard.height = Math.abs(initialHeight - window.innerHeight);
          }
          ionic.keyboard.isOpen = isOpening;
          clearInterval(waitForResizeTimer);
          callback();
        }, 50);
        return maxCount;
      }
      function keyboardHide() {
        clearTimeout(keyboardFocusOutTimer);
        ionic.keyboard.isOpen = false;
        ionic.keyboard.isClosing = false;
        if (keyboardActiveElement) {
          ionic.trigger('resetScrollView', {target: keyboardActiveElement}, true);
        }
        ionic.requestAnimationFrame(function() {
          document.body.classList.remove(KEYBOARD_OPEN_CSS);
        });
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerMove", keyboardPreventDefault);
        } else {
          document.removeEventListener('touchmove', keyboardPreventDefault);
        }
        document.removeEventListener('keydown', keyboardOnKeyDown);
        if (ionic.Platform.isAndroid()) {
          if (keyboardHasPlugin())
            cordova.plugins.Keyboard.close();
          keyboardActiveElement && keyboardActiveElement.blur();
        }
        keyboardActiveElement = null;
      }
      function keyboardShow() {
        ionic.keyboard.isOpen = true;
        ionic.keyboard.isOpening = false;
        var details = {
          keyboardHeight: keyboardGetHeight(),
          viewportHeight: keyboardCurrentViewportHeight
        };
        if (keyboardActiveElement) {
          details.target = keyboardActiveElement;
          var elementBounds = keyboardActiveElement.getBoundingClientRect();
          details.elementTop = Math.round(elementBounds.top);
          details.elementBottom = Math.round(elementBounds.bottom);
          details.windowHeight = details.viewportHeight - details.keyboardHeight;
          details.isElementUnderKeyboard = (details.elementBottom > details.windowHeight);
          ionic.trigger('scrollChildIntoView', details, true);
        }
        setTimeout(function() {
          document.body.classList.add(KEYBOARD_OPEN_CSS);
        }, 400);
        return details;
      }
      function keyboardGetHeight() {
        if (ionic.keyboard.height) {
          return ionic.keyboard.height;
        }
        if (ionic.Platform.isAndroid()) {
          if (ionic.Platform.isFullScreen) {
            return 275;
          }
          var contentHeight = window.innerHeight;
          if (contentHeight < keyboardCurrentViewportHeight) {
            return keyboardCurrentViewportHeight - contentHeight;
          } else {
            return 0;
          }
        }
        if (ionic.Platform.isIOS()) {
          if (ionic.keyboard.isLandscape) {
            return 206;
          }
          if (!ionic.Platform.isWebView()) {
            return 216;
          }
          return 260;
        }
        return 275;
      }
      function isPortraitViewportHeight(viewportHeight) {
        return !!(!ionic.keyboard.isLandscape && keyboardPortraitViewportHeight && (Math.abs(keyboardPortraitViewportHeight - viewportHeight) < 2));
      }
      function isLandscapeViewportHeight(viewportHeight) {
        return !!(ionic.keyboard.isLandscape && keyboardLandscapeViewportHeight && (Math.abs(keyboardLandscapeViewportHeight - viewportHeight) < 2));
      }
      function keyboardUpdateViewportHeight() {
        wasOrientationChange = false;
        keyboardCurrentViewportHeight = getViewportHeight();
        if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
          keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
        } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
          keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
        }
        if (keyboardActiveElement) {
          ionic.trigger('resetScrollView', {target: keyboardActiveElement}, true);
        }
        if (ionic.keyboard.isOpen && ionic.tap.isTextInput(keyboardActiveElement)) {
          keyboardShow();
        }
      }
      function keyboardInitViewportHeight() {
        var viewportHeight = getViewportHeight();
        if ((viewportHeight / window.innerWidth) < 1) {
          ionic.keyboard.isLandscape = true;
        }
        keyboardCurrentViewportHeight = viewportHeight;
        if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
          keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
        } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
          keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
        }
      }
      function getViewportHeight() {
        var windowHeight = window.innerHeight;
        if (!(ionic.Platform.isAndroid() && ionic.Platform.isFullScreen) && (ionic.keyboard.isOpen || ionic.keyboard.isOpening) && !ionic.keyboard.isClosing) {
          return windowHeight + keyboardGetHeight();
        }
        return windowHeight;
      }
      function inputScrollView(ele) {
        while (ele) {
          if (ele.classList.contains(SCROLL_CONTAINER_CSS)) {
            return ele;
          }
          ele = ele.parentElement;
        }
        return null;
      }
      function keyboardHasPlugin() {
        return !!(window.cordova && cordova.plugins && cordova.plugins.Keyboard);
      }
      ionic.Platform.ready(function() {
        keyboardInitViewportHeight();
        window.addEventListener('orientationchange', keyboardOrientationChange);
        setTimeout(keyboardInitViewportHeight, 999);
        if (window.navigator.msPointerEnabled) {
          document.addEventListener("MSPointerDown", keyboardInit, false);
        } else {
          document.addEventListener('touchstart', keyboardInit, false);
        }
      });
      var viewportTag;
      var viewportProperties = {};
      ionic.viewport = {orientation: function() {
          return (window.innerWidth > window.innerHeight ? 90 : 0);
        }};
      function viewportLoadTag() {
        var x;
        for (x = 0; x < document.head.children.length; x++) {
          if (document.head.children[x].name == 'viewport') {
            viewportTag = document.head.children[x];
            break;
          }
        }
        if (viewportTag) {
          var props = viewportTag.content.toLowerCase().replace(/\s+/g, '').split(',');
          var keyValue;
          for (x = 0; x < props.length; x++) {
            if (props[x]) {
              keyValue = props[x].split('=');
              viewportProperties[keyValue[0]] = (keyValue.length > 1 ? keyValue[1] : '_');
            }
          }
          viewportUpdate();
        }
      }
      function viewportUpdate() {
        var initWidth = viewportProperties.width;
        var initHeight = viewportProperties.height;
        var p = ionic.Platform;
        var version = p.version();
        var DEVICE_WIDTH = 'device-width';
        var DEVICE_HEIGHT = 'device-height';
        var orientation = ionic.viewport.orientation();
        delete viewportProperties.height;
        viewportProperties.width = DEVICE_WIDTH;
        if (p.isIPad()) {
          if (version > 7) {
            delete viewportProperties.width;
          } else {
            if (p.isWebView()) {
              if (orientation == 90) {
                viewportProperties.height = '0';
              } else if (version == 7) {
                viewportProperties.height = DEVICE_HEIGHT;
              }
            } else {
              if (version < 7) {
                viewportProperties.height = '0';
              }
            }
          }
        } else if (p.isIOS()) {
          if (p.isWebView()) {
            if (version > 7) {
              delete viewportProperties.width;
            } else if (version < 7) {
              if (initHeight)
                viewportProperties.height = '0';
            } else if (version == 7) {
              viewportProperties.height = DEVICE_HEIGHT;
            }
          } else {
            if (version < 7) {
              if (initHeight)
                viewportProperties.height = '0';
            }
          }
        }
        if (initWidth !== viewportProperties.width || initHeight !== viewportProperties.height) {
          viewportTagUpdate();
        }
      }
      function viewportTagUpdate() {
        var key,
            props = [];
        for (key in viewportProperties) {
          if (viewportProperties[key]) {
            props.push(key + (viewportProperties[key] == '_' ? '' : '=' + viewportProperties[key]));
          }
        }
        viewportTag.content = props.join(', ');
      }
      ionic.Platform.ready(function() {
        viewportLoadTag();
        window.addEventListener("orientationchange", function() {
          setTimeout(viewportUpdate, 1000);
        }, false);
      });
      (function(ionic) {
        'use strict';
        ionic.views.View = function() {
          this.initialize.apply(this, arguments);
        };
        ionic.views.View.inherit = ionic.inherit;
        ionic.extend(ionic.views.View.prototype, {initialize: function() {}});
      })(window.ionic);
      var zyngaCore = {effect: {}};
      (function(global) {
        var time = Date.now || function() {
          return +new Date();
        };
        var desiredFrames = 60;
        var millisecondsPerSecond = 1000;
        var running = {};
        var counter = 1;
        zyngaCore.effect.Animate = {
          requestAnimationFrame: (function() {
            var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
            var isNative = !!requestFrame;
            if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
              isNative = false;
            }
            if (isNative) {
              return function(callback, root) {
                requestFrame(callback, root);
              };
            }
            var TARGET_FPS = 60;
            var requests = {};
            var requestCount = 0;
            var rafHandle = 1;
            var intervalHandle = null;
            var lastActive = +new Date();
            return function(callback) {
              var callbackHandle = rafHandle++;
              requests[callbackHandle] = callback;
              requestCount++;
              if (intervalHandle === null) {
                intervalHandle = setInterval(function() {
                  var time = +new Date();
                  var currentRequests = requests;
                  requests = {};
                  requestCount = 0;
                  for (var key in currentRequests) {
                    if (currentRequests.hasOwnProperty(key)) {
                      currentRequests[key](time);
                      lastActive = time;
                    }
                  }
                  if (time - lastActive > 2500) {
                    clearInterval(intervalHandle);
                    intervalHandle = null;
                  }
                }, 1000 / TARGET_FPS);
              }
              return callbackHandle;
            };
          })(),
          stop: function(id) {
            var cleared = running[id] != null;
            if (cleared) {
              running[id] = null;
            }
            return cleared;
          },
          isRunning: function(id) {
            return running[id] != null;
          },
          start: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
            var start = time();
            var lastFrame = start;
            var percent = 0;
            var dropCounter = 0;
            var id = counter++;
            if (!root) {
              root = document.body;
            }
            if (id % 20 === 0) {
              var newRunning = {};
              for (var usedId in running) {
                newRunning[usedId] = true;
              }
              running = newRunning;
            }
            var step = function(virtual) {
              var render = virtual !== true;
              var now = time();
              if (!running[id] || (verifyCallback && !verifyCallback(id))) {
                running[id] = null;
                completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);
                return;
              }
              if (render) {
                var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
                for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
                  step(true);
                  dropCounter++;
                }
              }
              if (duration) {
                percent = (now - start) / duration;
                if (percent > 1) {
                  percent = 1;
                }
              }
              var value = easingMethod ? easingMethod(percent) : percent;
              if ((stepCallback(value, now, render) === false || percent === 1) && render) {
                running[id] = null;
                completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);
              } else if (render) {
                lastFrame = now;
                zyngaCore.effect.Animate.requestAnimationFrame(step, root);
              }
            };
            running[id] = true;
            zyngaCore.effect.Animate.requestAnimationFrame(step, root);
            return id;
          }
        };
      })(this);
      (function(ionic) {
        var NOOP = function() {};
        var easeOutCubic = function(pos) {
          return (Math.pow((pos - 1), 3) + 1);
        };
        var easeInOutCubic = function(pos) {
          if ((pos /= 0.5) < 1) {
            return 0.5 * Math.pow(pos, 3);
          }
          return 0.5 * (Math.pow((pos - 2), 3) + 2);
        };
        ionic.views.Scroll = ionic.views.View.inherit({
          initialize: function(options) {
            var self = this;
            self.__container = options.el;
            self.__content = options.el.firstElementChild;
            setTimeout(function() {
              if (self.__container && self.__content) {
                self.__container.scrollTop = 0;
                self.__content.scrollTop = 0;
              }
            });
            self.options = {
              scrollingX: false,
              scrollbarX: true,
              scrollingY: true,
              scrollbarY: true,
              startX: 0,
              startY: 0,
              wheelDampen: 6,
              minScrollbarSizeX: 5,
              minScrollbarSizeY: 5,
              scrollbarsFade: true,
              scrollbarFadeDelay: 300,
              scrollbarResizeFadeDelay: 1000,
              animating: true,
              animationDuration: 250,
              decelVelocityThreshold: 4,
              decelVelocityThresholdPaging: 4,
              bouncing: true,
              locking: true,
              paging: false,
              snapping: false,
              zooming: false,
              minZoom: 0.5,
              maxZoom: 3,
              speedMultiplier: 1,
              deceleration: 0.97,
              preventDefault: false,
              scrollingComplete: NOOP,
              penetrationDeceleration: 0.03,
              penetrationAcceleration: 0.08,
              scrollEventInterval: 10,
              freeze: false,
              getContentWidth: function() {
                return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
              },
              getContentHeight: function() {
                return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
              }
            };
            for (var key in options) {
              self.options[key] = options[key];
            }
            self.hintResize = ionic.debounce(function() {
              self.resize();
            }, 1000, true);
            self.onScroll = function() {
              if (!ionic.scroll.isScrolling) {
                setTimeout(self.setScrollStart, 50);
              } else {
                clearTimeout(self.scrollTimer);
                self.scrollTimer = setTimeout(self.setScrollStop, 80);
              }
            };
            self.freeze = function(shouldFreeze) {
              if (arguments.length) {
                self.options.freeze = shouldFreeze;
              }
              return self.options.freeze;
            };
            self.setScrollStart = function() {
              ionic.scroll.isScrolling = Math.abs(ionic.scroll.lastTop - self.__scrollTop) > 1;
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(self.setScrollStop, 80);
            };
            self.setScrollStop = function() {
              ionic.scroll.isScrolling = false;
              ionic.scroll.lastTop = self.__scrollTop;
            };
            self.triggerScrollEvent = ionic.throttle(function() {
              self.onScroll();
              ionic.trigger('scroll', {
                scrollTop: self.__scrollTop,
                scrollLeft: self.__scrollLeft,
                target: self.__container
              });
            }, self.options.scrollEventInterval);
            self.triggerScrollEndEvent = function() {
              ionic.trigger('scrollend', {
                scrollTop: self.__scrollTop,
                scrollLeft: self.__scrollLeft,
                target: self.__container
              });
            };
            self.__scrollLeft = self.options.startX;
            self.__scrollTop = self.options.startY;
            self.__callback = self.getRenderFn();
            self.__initEventHandlers();
            self.__createScrollbars();
          },
          run: function() {
            this.resize();
            this.__fadeScrollbars('out', this.options.scrollbarResizeFadeDelay);
          },
          __isSingleTouch: false,
          __isTracking: false,
          __didDecelerationComplete: false,
          __isGesturing: false,
          __isDragging: false,
          __isDecelerating: false,
          __isAnimating: false,
          __clientLeft: 0,
          __clientTop: 0,
          __clientWidth: 0,
          __clientHeight: 0,
          __contentWidth: 0,
          __contentHeight: 0,
          __snapWidth: 100,
          __snapHeight: 100,
          __refreshHeight: null,
          __refreshActive: false,
          __refreshActivate: null,
          __refreshDeactivate: null,
          __refreshStart: null,
          __zoomLevel: 1,
          __scrollLeft: 0,
          __scrollTop: 0,
          __maxScrollLeft: 0,
          __maxScrollTop: 0,
          __scheduledLeft: 0,
          __scheduledTop: 0,
          __scheduledZoom: 0,
          __lastTouchLeft: null,
          __lastTouchTop: null,
          __lastTouchMove: null,
          __positions: null,
          __minDecelerationScrollLeft: null,
          __minDecelerationScrollTop: null,
          __maxDecelerationScrollLeft: null,
          __maxDecelerationScrollTop: null,
          __decelerationVelocityX: null,
          __decelerationVelocityY: null,
          __transformProperty: null,
          __perspectiveProperty: null,
          __indicatorX: null,
          __indicatorY: null,
          __scrollbarFadeTimeout: null,
          __didWaitForSize: null,
          __sizerTimeout: null,
          __initEventHandlers: function() {
            var self = this;
            var container = self.__container;
            var scrollViewOffsetHeight;
            self.scrollChildIntoView = function(e) {
              var scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
              scrollViewOffsetHeight = container.offsetHeight;
              var alreadyShrunk = self.isShrunkForKeyboard;
              var isModal = container.parentNode.classList.contains('modal');
              var isInsetModal = isModal && window.innerWidth >= 680;
              if (!alreadyShrunk) {
                if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) {
                  var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop;
                  var keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
                  ionic.requestAnimationFrame(function() {
                    scrollViewOffsetHeight = scrollViewOffsetHeight - keyboardOffset;
                    container.style.height = scrollViewOffsetHeight + "px";
                    container.style.overflow = "visible";
                    self.resize();
                  });
                }
                self.isShrunkForKeyboard = true;
              }
              if (e.detail.isElementUnderKeyboard) {
                ionic.requestAnimationFrame(function() {
                  container.scrollTop = 0;
                  if (self.isShrunkForKeyboard && !alreadyShrunk) {
                    scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
                  }
                  var scrollMidpointOffset = scrollViewOffsetHeight * 0.5;
                  var inputMidpoint = ((e.detail.elementBottom + e.detail.elementTop) / 2);
                  var inputMidpointOffsetToScrollBottom = inputMidpoint - scrollBottomOffsetToTop;
                  var scrollTop = inputMidpointOffsetToScrollBottom + scrollMidpointOffset;
                  if (scrollTop > 0) {
                    if (ionic.Platform.isIOS())
                      ionic.tap.cloneFocusedInput(container, self);
                    self.scrollBy(0, scrollTop, true);
                    self.onScroll();
                  }
                });
              }
              e.stopPropagation();
            };
            self.resetScrollView = function() {
              if (self.isShrunkForKeyboard) {
                self.isShrunkForKeyboard = false;
                container.style.height = "";
                container.style.overflow = "";
              }
              self.resize();
            };
            container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.addEventListener('resetScrollView', self.resetScrollView);
            function getEventTouches(e) {
              return e.touches && e.touches.length ? e.touches : [{
                pageX: e.pageX,
                pageY: e.pageY
              }];
            }
            self.touchStart = function(e) {
              self.startCoordinates = ionic.tap.pointerCoord(e);
              if (ionic.tap.ignoreScrollStart(e)) {
                return;
              }
              self.__isDown = true;
              if (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT') {
                self.__hasStarted = false;
                return;
              }
              self.__isSelectable = true;
              self.__enableScrollY = true;
              self.__hasStarted = true;
              self.doTouchStart(getEventTouches(e), e.timeStamp);
              e.preventDefault();
            };
            self.touchMove = function(e) {
              if (self.options.freeze || !self.__isDown || (!self.__isDown && e.defaultPrevented) || (e.target.tagName === 'TEXTAREA' && e.target.parentElement.querySelector(':focus'))) {
                return;
              }
              if (!self.__hasStarted && (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT')) {
                self.__hasStarted = true;
                self.doTouchStart(getEventTouches(e), e.timeStamp);
                e.preventDefault();
                return;
              }
              if (self.startCoordinates) {
                var currentCoordinates = ionic.tap.pointerCoord(e);
                if (self.__isSelectable && ionic.tap.isTextInput(e.target) && Math.abs(self.startCoordinates.x - currentCoordinates.x) > 20) {
                  self.__enableScrollY = false;
                  self.__isSelectable = true;
                }
                if (self.__enableScrollY && Math.abs(self.startCoordinates.y - currentCoordinates.y) > 10) {
                  self.__isSelectable = false;
                  ionic.tap.cloneFocusedInput(container, self);
                }
              }
              self.doTouchMove(getEventTouches(e), e.timeStamp, e.scale);
              self.__isDown = true;
            };
            self.touchMoveBubble = function(e) {
              if (self.__isDown && self.options.preventDefault) {
                e.preventDefault();
              }
            };
            self.touchEnd = function(e) {
              if (!self.__isDown)
                return;
              self.doTouchEnd(e, e.timeStamp);
              self.__isDown = false;
              self.__hasStarted = false;
              self.__isSelectable = true;
              self.__enableScrollY = true;
              if (!self.__isDragging && !self.__isDecelerating && !self.__isAnimating) {
                ionic.tap.removeClonedInputs(container, self);
              }
            };
            self.mouseWheel = ionic.animationFrameThrottle(function(e) {
              var scrollParent = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'ionic-scroll');
              if (!self.options.freeze && scrollParent === self.__container) {
                self.hintResize();
                self.scrollBy((e.wheelDeltaX || e.deltaX || 0) / self.options.wheelDampen, (-e.wheelDeltaY || e.deltaY || 0) / self.options.wheelDampen);
                self.__fadeScrollbars('in');
                clearTimeout(self.__wheelHideBarTimeout);
                self.__wheelHideBarTimeout = setTimeout(function() {
                  self.__fadeScrollbars('out');
                }, 100);
              }
            });
            if ('ontouchstart' in window) {
              container.addEventListener("touchstart", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("touchmove", self.touchMoveBubble, false);
              document.addEventListener("touchmove", self.touchMove, false);
              document.addEventListener("touchend", self.touchEnd, false);
              document.addEventListener("touchcancel", self.touchEnd, false);
            } else if (window.navigator.pointerEnabled) {
              container.addEventListener("pointerdown", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("pointermove", self.touchMoveBubble, false);
              document.addEventListener("pointermove", self.touchMove, false);
              document.addEventListener("pointerup", self.touchEnd, false);
              document.addEventListener("pointercancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else if (window.navigator.msPointerEnabled) {
              container.addEventListener("MSPointerDown", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("MSPointerMove", self.touchMoveBubble, false);
              document.addEventListener("MSPointerMove", self.touchMove, false);
              document.addEventListener("MSPointerUp", self.touchEnd, false);
              document.addEventListener("MSPointerCancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else {
              var mousedown = false;
              self.mouseDown = function(e) {
                if (ionic.tap.ignoreScrollStart(e) || e.target.tagName === 'SELECT') {
                  return;
                }
                self.doTouchStart(getEventTouches(e), e.timeStamp);
                if (!ionic.tap.isTextInput(e.target)) {
                  e.preventDefault();
                }
                mousedown = true;
              };
              self.mouseMove = function(e) {
                if (self.options.freeze || !mousedown || (!mousedown && e.defaultPrevented)) {
                  return;
                }
                self.doTouchMove(getEventTouches(e), e.timeStamp);
                mousedown = true;
              };
              self.mouseMoveBubble = function(e) {
                if (mousedown && self.options.preventDefault) {
                  e.preventDefault();
                }
              };
              self.mouseUp = function(e) {
                if (!mousedown) {
                  return;
                }
                self.doTouchEnd(e, e.timeStamp);
                mousedown = false;
              };
              container.addEventListener("mousedown", self.mouseDown, false);
              if (self.options.preventDefault)
                container.addEventListener("mousemove", self.mouseMoveBubble, false);
              document.addEventListener("mousemove", self.mouseMove, false);
              document.addEventListener("mouseup", self.mouseUp, false);
              document.addEventListener('mousewheel', self.mouseWheel, false);
              document.addEventListener('wheel', self.mouseWheel, false);
            }
          },
          __cleanup: function() {
            var self = this;
            var container = self.__container;
            container.removeEventListener('touchstart', self.touchStart);
            container.removeEventListener('touchmove', self.touchMoveBubble);
            document.removeEventListener('touchmove', self.touchMove);
            document.removeEventListener('touchend', self.touchEnd);
            document.removeEventListener('touchcancel', self.touchCancel);
            container.removeEventListener("pointerdown", self.touchStart);
            container.removeEventListener("pointermove", self.touchMoveBubble);
            document.removeEventListener("pointermove", self.touchMove);
            document.removeEventListener("pointerup", self.touchEnd);
            document.removeEventListener("pointercancel", self.touchEnd);
            container.removeEventListener("MSPointerDown", self.touchStart);
            container.removeEventListener("MSPointerMove", self.touchMoveBubble);
            document.removeEventListener("MSPointerMove", self.touchMove);
            document.removeEventListener("MSPointerUp", self.touchEnd);
            document.removeEventListener("MSPointerCancel", self.touchEnd);
            container.removeEventListener("mousedown", self.mouseDown);
            container.removeEventListener("mousemove", self.mouseMoveBubble);
            document.removeEventListener("mousemove", self.mouseMove);
            document.removeEventListener("mouseup", self.mouseUp);
            document.removeEventListener('mousewheel', self.mouseWheel);
            document.removeEventListener('wheel', self.mouseWheel);
            container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.removeEventListener('resetScrollView', self.resetScrollView);
            ionic.tap.removeClonedInputs(container, self);
            delete self.__container;
            delete self.__content;
            delete self.__indicatorX;
            delete self.__indicatorY;
            delete self.options.el;
            self.__callback = self.scrollChildIntoView = self.resetScrollView = NOOP;
            self.mouseMove = self.mouseDown = self.mouseUp = self.mouseWheel = self.touchStart = self.touchMove = self.touchEnd = self.touchCancel = NOOP;
            self.resize = self.scrollTo = self.zoomTo = self.__scrollingComplete = NOOP;
            container = null;
          },
          __createScrollbar: function(direction) {
            var bar = document.createElement('div'),
                indicator = document.createElement('div');
            indicator.className = 'scroll-bar-indicator scroll-bar-fade-out';
            if (direction == 'h') {
              bar.className = 'scroll-bar scroll-bar-h';
            } else {
              bar.className = 'scroll-bar scroll-bar-v';
            }
            bar.appendChild(indicator);
            return bar;
          },
          __createScrollbars: function() {
            var self = this;
            var indicatorX,
                indicatorY;
            if (self.options.scrollingX) {
              indicatorX = {
                el: self.__createScrollbar('h'),
                sizeRatio: 1
              };
              indicatorX.indicator = indicatorX.el.children[0];
              if (self.options.scrollbarX) {
                self.__container.appendChild(indicatorX.el);
              }
              self.__indicatorX = indicatorX;
            }
            if (self.options.scrollingY) {
              indicatorY = {
                el: self.__createScrollbar('v'),
                sizeRatio: 1
              };
              indicatorY.indicator = indicatorY.el.children[0];
              if (self.options.scrollbarY) {
                self.__container.appendChild(indicatorY.el);
              }
              self.__indicatorY = indicatorY;
            }
          },
          __resizeScrollbars: function() {
            var self = this;
            if (self.__indicatorX) {
              var width = Math.max(Math.round(self.__clientWidth * self.__clientWidth / (self.__contentWidth)), 20);
              if (width > self.__contentWidth) {
                width = 0;
              }
              if (width !== self.__indicatorX.size) {
                ionic.requestAnimationFrame(function() {
                  self.__indicatorX.indicator.style.width = width + 'px';
                });
              }
              self.__indicatorX.size = width;
              self.__indicatorX.minScale = self.options.minScrollbarSizeX / width;
              self.__indicatorX.maxPos = self.__clientWidth - width;
              self.__indicatorX.sizeRatio = self.__maxScrollLeft ? self.__indicatorX.maxPos / self.__maxScrollLeft : 1;
            }
            if (self.__indicatorY) {
              var height = Math.max(Math.round(self.__clientHeight * self.__clientHeight / (self.__contentHeight)), 20);
              if (height > self.__contentHeight) {
                height = 0;
              }
              if (height !== self.__indicatorY.size) {
                ionic.requestAnimationFrame(function() {
                  self.__indicatorY && (self.__indicatorY.indicator.style.height = height + 'px');
                });
              }
              self.__indicatorY.size = height;
              self.__indicatorY.minScale = self.options.minScrollbarSizeY / height;
              self.__indicatorY.maxPos = self.__clientHeight - height;
              self.__indicatorY.sizeRatio = self.__maxScrollTop ? self.__indicatorY.maxPos / self.__maxScrollTop : 1;
            }
          },
          __repositionScrollbars: function() {
            var self = this,
                heightScale,
                widthScale,
                widthDiff,
                heightDiff,
                x,
                y,
                xstop = 0,
                ystop = 0;
            if (self.__indicatorX) {
              if (self.__indicatorY)
                xstop = 10;
              x = Math.round(self.__indicatorX.sizeRatio * self.__scrollLeft) || 0;
              widthDiff = self.__scrollLeft - (self.__maxScrollLeft - xstop);
              if (self.__scrollLeft < 0) {
                widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - Math.abs(self.__scrollLeft)) / self.__indicatorX.size);
                x = 0;
                self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'left center';
              } else if (widthDiff > 0) {
                widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - widthDiff) / self.__indicatorX.size);
                x = self.__indicatorX.maxPos - xstop;
                self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'right center';
              } else {
                x = Math.min(self.__maxScrollLeft, Math.max(0, x));
                widthScale = 1;
              }
              var translate3dX = 'translate3d(' + x + 'px, 0, 0) scaleX(' + widthScale + ')';
              if (self.__indicatorX.transformProp !== translate3dX) {
                self.__indicatorX.indicator.style[self.__transformProperty] = translate3dX;
                self.__indicatorX.transformProp = translate3dX;
              }
            }
            if (self.__indicatorY) {
              y = Math.round(self.__indicatorY.sizeRatio * self.__scrollTop) || 0;
              if (self.__indicatorX)
                ystop = 10;
              heightDiff = self.__scrollTop - (self.__maxScrollTop - ystop);
              if (self.__scrollTop < 0) {
                heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - Math.abs(self.__scrollTop)) / self.__indicatorY.size);
                y = 0;
                if (self.__indicatorY.originProp !== 'center top') {
                  self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center top';
                  self.__indicatorY.originProp = 'center top';
                }
              } else if (heightDiff > 0) {
                heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - heightDiff) / self.__indicatorY.size);
                y = self.__indicatorY.maxPos - ystop;
                if (self.__indicatorY.originProp !== 'center bottom') {
                  self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center bottom';
                  self.__indicatorY.originProp = 'center bottom';
                }
              } else {
                y = Math.min(self.__maxScrollTop, Math.max(0, y));
                heightScale = 1;
              }
              var translate3dY = 'translate3d(0,' + y + 'px, 0) scaleY(' + heightScale + ')';
              if (self.__indicatorY.transformProp !== translate3dY) {
                self.__indicatorY.indicator.style[self.__transformProperty] = translate3dY;
                self.__indicatorY.transformProp = translate3dY;
              }
            }
          },
          __fadeScrollbars: function(direction, delay) {
            var self = this;
            if (!self.options.scrollbarsFade) {
              return;
            }
            var className = 'scroll-bar-fade-out';
            if (self.options.scrollbarsFade === true) {
              clearTimeout(self.__scrollbarFadeTimeout);
              if (direction == 'in') {
                if (self.__indicatorX) {
                  self.__indicatorX.indicator.classList.remove(className);
                }
                if (self.__indicatorY) {
                  self.__indicatorY.indicator.classList.remove(className);
                }
              } else {
                self.__scrollbarFadeTimeout = setTimeout(function() {
                  if (self.__indicatorX) {
                    self.__indicatorX.indicator.classList.add(className);
                  }
                  if (self.__indicatorY) {
                    self.__indicatorY.indicator.classList.add(className);
                  }
                }, delay || self.options.scrollbarFadeDelay);
              }
            }
          },
          __scrollingComplete: function() {
            this.options.scrollingComplete();
            ionic.tap.removeClonedInputs(this.__container, this);
            this.__fadeScrollbars('out');
          },
          resize: function(continueScrolling) {
            var self = this;
            if (!self.__container || !self.options)
              return;
            self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
          },
          getRenderFn: function() {
            var self = this;
            var content = self.__content;
            var docStyle = document.documentElement.style;
            var engine;
            if ('MozAppearance' in docStyle) {
              engine = 'gecko';
            } else if ('WebkitAppearance' in docStyle) {
              engine = 'webkit';
            } else if (typeof navigator.cpuClass === 'string') {
              engine = 'trident';
            }
            var vendorPrefix = {
              trident: 'ms',
              gecko: 'Moz',
              webkit: 'Webkit',
              presto: 'O'
            }[engine];
            var helperElem = document.createElement("div");
            var undef;
            var perspectiveProperty = vendorPrefix + "Perspective";
            var transformProperty = vendorPrefix + "Transform";
            var transformOriginProperty = vendorPrefix + 'TransformOrigin';
            self.__perspectiveProperty = transformProperty;
            self.__transformProperty = transformProperty;
            self.__transformOriginProperty = transformOriginProperty;
            if (helperElem.style[perspectiveProperty] !== undef) {
              return function(left, top, zoom, wasResize) {
                var translate3d = 'translate3d(' + (-left) + 'px,' + (-top) + 'px,0) scale(' + zoom + ')';
                if (translate3d !== self.contentTransform) {
                  content.style[transformProperty] = translate3d;
                  self.contentTransform = translate3d;
                }
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            } else if (helperElem.style[transformProperty] !== undef) {
              return function(left, top, zoom, wasResize) {
                content.style[transformProperty] = 'translate(' + (-left) + 'px,' + (-top) + 'px) scale(' + zoom + ')';
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            } else {
              return function(left, top, zoom, wasResize) {
                content.style.marginLeft = left ? (-left / zoom) + 'px' : '';
                content.style.marginTop = top ? (-top / zoom) + 'px' : '';
                content.style.zoom = zoom || '';
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            }
          },
          setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight, continueScrolling) {
            var self = this;
            if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
              return;
            }
            if (clientWidth === +clientWidth) {
              self.__clientWidth = clientWidth;
            }
            if (clientHeight === +clientHeight) {
              self.__clientHeight = clientHeight;
            }
            if (contentWidth === +contentWidth) {
              self.__contentWidth = contentWidth;
            }
            if (contentHeight === +contentHeight) {
              self.__contentHeight = contentHeight;
            }
            self.__computeScrollMax();
            self.__resizeScrollbars();
            if (!continueScrolling) {
              self.scrollTo(self.__scrollLeft, self.__scrollTop, true, null, true);
            }
          },
          setPosition: function(left, top) {
            this.__clientLeft = left || 0;
            this.__clientTop = top || 0;
          },
          setSnapSize: function(width, height) {
            this.__snapWidth = width;
            this.__snapHeight = height;
          },
          activatePullToRefresh: function(height, refresherMethods) {
            var self = this;
            self.__refreshHeight = height;
            self.__refreshActivate = function() {
              ionic.requestAnimationFrame(refresherMethods.activate);
            };
            self.__refreshDeactivate = function() {
              ionic.requestAnimationFrame(refresherMethods.deactivate);
            };
            self.__refreshStart = function() {
              ionic.requestAnimationFrame(refresherMethods.start);
            };
            self.__refreshShow = function() {
              ionic.requestAnimationFrame(refresherMethods.show);
            };
            self.__refreshHide = function() {
              ionic.requestAnimationFrame(refresherMethods.hide);
            };
            self.__refreshTail = function() {
              ionic.requestAnimationFrame(refresherMethods.tail);
            };
            self.__refreshTailTime = 100;
            self.__minSpinTime = 600;
          },
          triggerPullToRefresh: function() {
            this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);
            var d = new Date();
            this.refreshStartTime = d.getTime();
            if (this.__refreshStart) {
              this.__refreshStart();
            }
          },
          finishPullToRefresh: function() {
            var self = this;
            var d = new Date();
            var delay = 0;
            if (self.refreshStartTime + self.__minSpinTime > d.getTime()) {
              delay = self.refreshStartTime + self.__minSpinTime - d.getTime();
            }
            setTimeout(function() {
              if (self.__refreshTail) {
                self.__refreshTail();
              }
              setTimeout(function() {
                self.__refreshActive = false;
                if (self.__refreshDeactivate) {
                  self.__refreshDeactivate();
                }
                if (self.__refreshHide) {
                  self.__refreshHide();
                }
                self.scrollTo(self.__scrollLeft, self.__scrollTop, true);
              }, self.__refreshTailTime);
            }, delay);
          },
          getValues: function() {
            return {
              left: this.__scrollLeft,
              top: this.__scrollTop,
              zoom: this.__zoomLevel
            };
          },
          getScrollMax: function() {
            return {
              left: this.__maxScrollLeft,
              top: this.__maxScrollTop
            };
          },
          zoomTo: function(level, animate, originLeft, originTop) {
            var self = this;
            if (!self.options.zooming) {
              throw new Error("Zooming is not enabled!");
            }
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
            }
            var oldLevel = self.__zoomLevel;
            if (originLeft == null) {
              originLeft = self.__clientWidth / 2;
            }
            if (originTop == null) {
              originTop = self.__clientHeight / 2;
            }
            level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
            self.__computeScrollMax(level);
            var left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;
            var top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;
            if (left > self.__maxScrollLeft) {
              left = self.__maxScrollLeft;
            } else if (left < 0) {
              left = 0;
            }
            if (top > self.__maxScrollTop) {
              top = self.__maxScrollTop;
            } else if (top < 0) {
              top = 0;
            }
            self.__publish(left, top, level, animate);
          },
          zoomBy: function(factor, animate, originLeft, originTop) {
            this.zoomTo(this.__zoomLevel * factor, animate, originLeft, originTop);
          },
          scrollTo: function(left, top, animate, zoom, wasResize) {
            var self = this;
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
            }
            if (zoom != null && zoom !== self.__zoomLevel) {
              if (!self.options.zooming) {
                throw new Error("Zooming is not enabled!");
              }
              left *= zoom;
              top *= zoom;
              self.__computeScrollMax(zoom);
            } else {
              zoom = self.__zoomLevel;
            }
            if (!self.options.scrollingX) {
              left = self.__scrollLeft;
            } else {
              if (self.options.paging) {
                left = Math.round(left / self.__clientWidth) * self.__clientWidth;
              } else if (self.options.snapping) {
                left = Math.round(left / self.__snapWidth) * self.__snapWidth;
              }
            }
            if (!self.options.scrollingY) {
              top = self.__scrollTop;
            } else {
              if (self.options.paging) {
                top = Math.round(top / self.__clientHeight) * self.__clientHeight;
              } else if (self.options.snapping) {
                top = Math.round(top / self.__snapHeight) * self.__snapHeight;
              }
            }
            left = Math.max(Math.min(self.__maxScrollLeft, left), 0);
            top = Math.max(Math.min(self.__maxScrollTop, top), 0);
            if (left === self.__scrollLeft && top === self.__scrollTop) {
              animate = false;
            }
            self.__publish(left, top, zoom, animate, wasResize);
          },
          scrollBy: function(left, top, animate) {
            var self = this;
            var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
            var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
            self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
          },
          doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {
            var change = wheelDelta > 0 ? 0.97 : 1.03;
            return this.zoomTo(this.__zoomLevel * change, false, pageX - this.__clientLeft, pageY - this.__clientTop);
          },
          doTouchStart: function(touches, timeStamp) {
            var self = this;
            self.__decStopped = !!(self.__isDecelerating || self.__isAnimating);
            self.hintResize();
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            self.__interruptedAnimation = true;
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
              self.__interruptedAnimation = true;
            }
            if (self.__isAnimating) {
              zyngaCore.effect.Animate.stop(self.__isAnimating);
              self.__isAnimating = false;
              self.__interruptedAnimation = true;
            }
            var currentTouchLeft,
                currentTouchTop;
            var isSingleTouch = touches.length === 1;
            if (isSingleTouch) {
              currentTouchLeft = touches[0].pageX;
              currentTouchTop = touches[0].pageY;
            } else {
              currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
              currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
            }
            self.__initialTouchLeft = currentTouchLeft;
            self.__initialTouchTop = currentTouchTop;
            self.__initialTouches = touches;
            self.__zoomLevelStart = self.__zoomLevel;
            self.__lastTouchLeft = currentTouchLeft;
            self.__lastTouchTop = currentTouchTop;
            self.__lastTouchMove = timeStamp;
            self.__lastScale = 1;
            self.__enableScrollX = !isSingleTouch && self.options.scrollingX;
            self.__enableScrollY = !isSingleTouch && self.options.scrollingY;
            self.__isTracking = true;
            self.__didDecelerationComplete = false;
            self.__isDragging = !isSingleTouch;
            self.__isSingleTouch = isSingleTouch;
            self.__positions = [];
          },
          doTouchMove: function(touches, timeStamp, scale) {
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            var self = this;
            if (!self.__isTracking) {
              return;
            }
            var currentTouchLeft,
                currentTouchTop;
            if (touches.length === 2) {
              currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
              currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
              if (!scale && self.options.zooming) {
                scale = self.__getScale(self.__initialTouches, touches);
              }
            } else {
              currentTouchLeft = touches[0].pageX;
              currentTouchTop = touches[0].pageY;
            }
            var positions = self.__positions;
            if (self.__isDragging) {
              self.__decStopped = false;
              var moveX = currentTouchLeft - self.__lastTouchLeft;
              var moveY = currentTouchTop - self.__lastTouchTop;
              var scrollLeft = self.__scrollLeft;
              var scrollTop = self.__scrollTop;
              var level = self.__zoomLevel;
              if (scale != null && self.options.zooming) {
                var oldLevel = level;
                level = level / self.__lastScale * scale;
                level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
                if (oldLevel !== level) {
                  var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;
                  var currentTouchTopRel = currentTouchTop - self.__clientTop;
                  scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;
                  scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;
                  self.__computeScrollMax(level);
                }
              }
              if (self.__enableScrollX) {
                scrollLeft -= moveX * self.options.speedMultiplier;
                var maxScrollLeft = self.__maxScrollLeft;
                if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
                  if (self.options.bouncing) {
                    scrollLeft += (moveX / 2 * self.options.speedMultiplier);
                  } else if (scrollLeft > maxScrollLeft) {
                    scrollLeft = maxScrollLeft;
                  } else {
                    scrollLeft = 0;
                  }
                }
              }
              if (self.__enableScrollY) {
                scrollTop -= moveY * self.options.speedMultiplier;
                var maxScrollTop = self.__maxScrollTop;
                if (scrollTop > maxScrollTop || scrollTop < 0) {
                  if (self.options.bouncing || (self.__refreshHeight && scrollTop < 0)) {
                    scrollTop += (moveY / 2 * self.options.speedMultiplier);
                    if (!self.__enableScrollX && self.__refreshHeight != null) {
                      if (scrollTop < 0) {
                        self.__refreshHidden = false;
                        self.__refreshShow();
                      } else {
                        self.__refreshHide();
                        self.__refreshHidden = true;
                      }
                      if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {
                        self.__refreshActive = true;
                        if (self.__refreshActivate) {
                          self.__refreshActivate();
                        }
                      } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {
                        self.__refreshActive = false;
                        if (self.__refreshDeactivate) {
                          self.__refreshDeactivate();
                        }
                      }
                    }
                  } else if (scrollTop > maxScrollTop) {
                    scrollTop = maxScrollTop;
                  } else {
                    scrollTop = 0;
                  }
                } else if (self.__refreshHeight && !self.__refreshHidden) {
                  self.__refreshHide();
                  self.__refreshHidden = true;
                }
              }
              if (positions.length > 60) {
                positions.splice(0, 30);
              }
              positions.push(scrollLeft, scrollTop, timeStamp);
              self.__publish(scrollLeft, scrollTop, level);
            } else {
              var minimumTrackingForScroll = self.options.locking ? 3 : 0;
              var minimumTrackingForDrag = 5;
              var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);
              var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);
              self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;
              self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;
              positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);
              self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
              if (self.__isDragging) {
                self.__interruptedAnimation = false;
                self.__fadeScrollbars('in');
              }
            }
            self.__lastTouchLeft = currentTouchLeft;
            self.__lastTouchTop = currentTouchTop;
            self.__lastTouchMove = timeStamp;
            self.__lastScale = scale;
          },
          doTouchEnd: function(e, timeStamp) {
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            var self = this;
            if (!self.__isTracking) {
              return;
            }
            self.__isTracking = false;
            if (self.__isDragging) {
              self.__isDragging = false;
              if (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {
                var positions = self.__positions;
                var endPos = positions.length - 1;
                var startPos = endPos;
                for (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {
                  startPos = i;
                }
                if (startPos !== endPos) {
                  var timeOffset = positions[endPos] - positions[startPos];
                  var movedLeft = self.__scrollLeft - positions[startPos - 2];
                  var movedTop = self.__scrollTop - positions[startPos - 1];
                  self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
                  self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);
                  var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? self.options.decelVelocityThresholdPaging : self.options.decelVelocityThreshold;
                  if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {
                    if (!self.__refreshActive) {
                      self.__startDeceleration(timeStamp);
                    }
                  }
                } else {
                  self.__scrollingComplete();
                }
              } else if ((timeStamp - self.__lastTouchMove) > 100) {
                self.__scrollingComplete();
              }
            } else if (self.__decStopped) {
              e.isTapHandled = true;
              self.__decStopped = false;
            }
            if (!self.__isDecelerating) {
              if (self.__refreshActive && self.__refreshStart) {
                self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);
                var d = new Date();
                self.refreshStartTime = d.getTime();
                if (self.__refreshStart) {
                  self.__refreshStart();
                }
                if (!ionic.Platform.isAndroid())
                  self.__startDeceleration();
              } else {
                if (self.__interruptedAnimation || self.__isDragging) {
                  self.__scrollingComplete();
                }
                self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);
                if (self.__refreshActive) {
                  self.__refreshActive = false;
                  if (self.__refreshDeactivate) {
                    self.__refreshDeactivate();
                  }
                }
              }
            }
            self.__positions.length = 0;
          },
          __publish: function(left, top, zoom, animate, wasResize) {
            var self = this;
            var wasAnimating = self.__isAnimating;
            if (wasAnimating) {
              zyngaCore.effect.Animate.stop(wasAnimating);
              self.__isAnimating = false;
            }
            if (animate && self.options.animating) {
              self.__scheduledLeft = left;
              self.__scheduledTop = top;
              self.__scheduledZoom = zoom;
              var oldLeft = self.__scrollLeft;
              var oldTop = self.__scrollTop;
              var oldZoom = self.__zoomLevel;
              var diffLeft = left - oldLeft;
              var diffTop = top - oldTop;
              var diffZoom = zoom - oldZoom;
              var step = function(percent, now, render) {
                if (render) {
                  self.__scrollLeft = oldLeft + (diffLeft * percent);
                  self.__scrollTop = oldTop + (diffTop * percent);
                  self.__zoomLevel = oldZoom + (diffZoom * percent);
                  if (self.__callback) {
                    self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel, wasResize);
                  }
                }
              };
              var verify = function(id) {
                return self.__isAnimating === id;
              };
              var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
                if (animationId === self.__isAnimating) {
                  self.__isAnimating = false;
                }
                if (self.__didDecelerationComplete || wasFinished) {
                  self.__scrollingComplete();
                }
                if (self.options.zooming) {
                  self.__computeScrollMax();
                }
              };
              self.__isAnimating = zyngaCore.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
            } else {
              self.__scheduledLeft = self.__scrollLeft = left;
              self.__scheduledTop = self.__scrollTop = top;
              self.__scheduledZoom = self.__zoomLevel = zoom;
              if (self.__callback) {
                self.__callback(left, top, zoom, wasResize);
              }
              if (self.options.zooming) {
                self.__computeScrollMax();
              }
            }
          },
          __computeScrollMax: function(zoomLevel) {
            var self = this;
            if (zoomLevel == null) {
              zoomLevel = self.__zoomLevel;
            }
            self.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);
            self.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);
            if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
              self.__didWaitForSize = true;
              self.__waitForSize();
            }
          },
          __waitForSize: function() {
            var self = this;
            clearTimeout(self.__sizerTimeout);
            var sizer = function() {
              self.resize(true);
            };
            sizer();
            self.__sizerTimeout = setTimeout(sizer, 500);
          },
          __startDeceleration: function() {
            var self = this;
            if (self.options.paging) {
              var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);
              var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);
              var clientWidth = self.__clientWidth;
              var clientHeight = self.__clientHeight;
              self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
              self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
              self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
              self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
            } else {
              self.__minDecelerationScrollLeft = 0;
              self.__minDecelerationScrollTop = 0;
              self.__maxDecelerationScrollLeft = self.__maxScrollLeft;
              self.__maxDecelerationScrollTop = self.__maxScrollTop;
              if (self.__refreshActive)
                self.__minDecelerationScrollTop = self.__refreshHeight * -1;
            }
            var step = function(percent, now, render) {
              self.__stepThroughDeceleration(render);
            };
            self.__minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1;
            var verify = function() {
              var shouldContinue = Math.abs(self.__decelerationVelocityX) >= self.__minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= self.__minVelocityToKeepDecelerating;
              if (!shouldContinue) {
                self.__didDecelerationComplete = true;
                if (self.options.bouncing && !self.__refreshActive) {
                  self.scrollTo(Math.min(Math.max(self.__scrollLeft, 0), self.__maxScrollLeft), Math.min(Math.max(self.__scrollTop, 0), self.__maxScrollTop), self.__refreshActive);
                }
              }
              return shouldContinue;
            };
            var completed = function() {
              self.__isDecelerating = false;
              if (self.__didDecelerationComplete) {
                self.__scrollingComplete();
              }
              if (self.options.paging) {
                self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);
              }
            };
            self.__isDecelerating = zyngaCore.effect.Animate.start(step, verify, completed);
          },
          __stepThroughDeceleration: function(render) {
            var self = this;
            var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;
            var scrollTop = self.__scrollTop + self.__decelerationVelocityY;
            if (!self.options.bouncing) {
              var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);
              if (scrollLeftFixed !== scrollLeft) {
                scrollLeft = scrollLeftFixed;
                self.__decelerationVelocityX = 0;
              }
              var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);
              if (scrollTopFixed !== scrollTop) {
                scrollTop = scrollTopFixed;
                self.__decelerationVelocityY = 0;
              }
            }
            if (render) {
              self.__publish(scrollLeft, scrollTop, self.__zoomLevel);
            } else {
              self.__scrollLeft = scrollLeft;
              self.__scrollTop = scrollTop;
            }
            if (!self.options.paging) {
              var frictionFactor = self.options.deceleration;
              self.__decelerationVelocityX *= frictionFactor;
              self.__decelerationVelocityY *= frictionFactor;
            }
            if (self.options.bouncing) {
              var scrollOutsideX = 0;
              var scrollOutsideY = 0;
              var penetrationDeceleration = self.options.penetrationDeceleration;
              var penetrationAcceleration = self.options.penetrationAcceleration;
              if (scrollLeft < self.__minDecelerationScrollLeft) {
                scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;
              } else if (scrollLeft > self.__maxDecelerationScrollLeft) {
                scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;
              }
              if (scrollTop < self.__minDecelerationScrollTop) {
                scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;
              } else if (scrollTop > self.__maxDecelerationScrollTop) {
                scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;
              }
              if (scrollOutsideX !== 0) {
                var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;
                if (isHeadingOutwardsX) {
                  self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
                }
                var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;
                if (!isHeadingOutwardsX || isStoppedX) {
                  self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
                }
              }
              if (scrollOutsideY !== 0) {
                var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;
                if (isHeadingOutwardsY) {
                  self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
                }
                var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;
                if (!isHeadingOutwardsY || isStoppedY) {
                  self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
                }
              }
            }
          },
          __getDistance: function getDistance(touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
          },
          __getScale: function getScale(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.__getDistance(end[0], end[1]) / this.__getDistance(start[0], start[1]);
            }
            return 1;
          }
        });
        ionic.scroll = {
          isScrolling: false,
          lastTop: 0
        };
      })(ionic);
      (function(ionic) {
        var NOOP = function() {};
        var depreciated = function(name) {
          void 0;
        };
        ionic.views.ScrollNative = ionic.views.View.inherit({
          initialize: function(options) {
            var self = this;
            self.__container = self.el = options.el;
            self.__content = options.el.firstElementChild;
            self.isNative = true;
            self.__scrollTop = self.el.scrollTop;
            self.__scrollLeft = self.el.scrollLeft;
            self.__clientHeight = self.__content.clientHeight;
            self.__clientWidth = self.__content.clientWidth;
            self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
            self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
            self.options = {
              freeze: false,
              getContentWidth: function() {
                return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
              },
              getContentHeight: function() {
                return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
              }
            };
            for (var key in options) {
              self.options[key] = options[key];
            }
            self.onScroll = function() {
              if (!ionic.scroll.isScrolling) {
                ionic.scroll.isScrolling = true;
              }
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(function() {
                ionic.scroll.isScrolling = false;
              }, 80);
            };
            self.freeze = NOOP;
            self.__initEventHandlers();
          },
          __callback: function() {
            depreciated('__callback');
          },
          zoomTo: function() {
            depreciated('zoomTo');
          },
          zoomBy: function() {
            depreciated('zoomBy');
          },
          activatePullToRefresh: function() {
            depreciated('activatePullToRefresh');
          },
          resize: function(continueScrolling) {
            var self = this;
            if (!self.__container || !self.options)
              return;
            self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
          },
          run: function() {
            this.resize();
          },
          getValues: function() {
            var self = this;
            self.update();
            return {
              left: self.__scrollLeft,
              top: self.__scrollTop,
              zoom: 1
            };
          },
          update: function() {
            var self = this;
            self.__scrollLeft = self.el.scrollLeft;
            self.__scrollTop = self.el.scrollTop;
          },
          setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {
            var self = this;
            if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
              return;
            }
            if (clientWidth === +clientWidth) {
              self.__clientWidth = clientWidth;
            }
            if (clientHeight === +clientHeight) {
              self.__clientHeight = clientHeight;
            }
            if (contentWidth === +contentWidth) {
              self.__contentWidth = contentWidth;
            }
            if (contentHeight === +contentHeight) {
              self.__contentHeight = contentHeight;
            }
            self.__computeScrollMax();
          },
          getScrollMax: function() {
            return {
              left: this.__maxScrollLeft,
              top: this.__maxScrollTop
            };
          },
          scrollBy: function(left, top, animate) {
            var self = this;
            self.update();
            var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
            var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
            self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
          },
          scrollTo: function(left, top, animate) {
            var self = this;
            if (!animate) {
              self.el.scrollTop = top;
              self.el.scrollLeft = left;
              self.resize();
              return;
            }
            animateScroll(top, left);
            function animateScroll(Y, X) {
              var start = Date.now(),
                  duration = 1000,
                  fromY = self.el.scrollTop,
                  fromX = self.el.scrollLeft;
              if (fromY === Y && fromX === X) {
                self.resize();
                return;
              }
              function easeOutCubic(t) {
                return (--t) * t * t + 1;
              }
              function animateScrollStep() {
                var currentTime = Date.now(),
                    time = Math.min(1, ((currentTime - start) / duration)),
                    easedT = easeOutCubic(time);
                if (fromY != Y) {
                  self.el.scrollTop = parseInt((easedT * (Y - fromY)) + fromY, 10);
                }
                if (fromX != X) {
                  self.el.scrollLeft = parseInt((easedT * (X - fromX)) + fromX, 10);
                }
                if (time < 1) {
                  ionic.requestAnimationFrame(animateScrollStep);
                } else {
                  self.resize();
                }
              }
              ionic.requestAnimationFrame(animateScrollStep);
            }
          },
          __waitForSize: function() {
            var self = this;
            clearTimeout(self.__sizerTimeout);
            var sizer = function() {
              self.resize(true);
            };
            sizer();
            self.__sizerTimeout = setTimeout(sizer, 500);
          },
          __computeScrollMax: function() {
            var self = this;
            self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
            self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
            if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
              self.__didWaitForSize = true;
              self.__waitForSize();
            }
          },
          __initEventHandlers: function() {
            var self = this;
            var container = self.__container;
            self.scrollChildIntoView = NOOP;
            self.resetScrollView = function() {
              if (self.isScrolledIntoView) {
                self.isScrolledIntoView = false;
                container.style.height = "";
                container.style.overflow = "";
                self.resize();
                ionic.scroll.isScrolling = false;
              }
            };
            container.addEventListener('resetScrollView', self.resetScrollView);
            container.addEventListener('scroll', self.onScroll);
            container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
            container.addEventListener('resetScrollView', self.resetScrollView);
          },
          __cleanup: function() {
            var self = this;
            var container = self.__container;
            container.removeEventListener('resetScrollView', self.resetScrollView);
            container.removeEventListener('scroll', self.onScroll);
            container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
            container.removeEventListener('resetScrollView', self.resetScrollView);
            ionic.tap.removeClonedInputs(container, self);
            delete self.__container;
            delete self.__content;
            delete self.__indicatorX;
            delete self.__indicatorY;
            delete self.options.el;
            self.resize = self.scrollTo = self.onScroll = self.resetScrollView = NOOP;
            container = null;
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        var ITEM_CLASS = 'item';
        var ITEM_CONTENT_CLASS = 'item-content';
        var ITEM_SLIDING_CLASS = 'item-sliding';
        var ITEM_OPTIONS_CLASS = 'item-options';
        var ITEM_PLACEHOLDER_CLASS = 'item-placeholder';
        var ITEM_REORDERING_CLASS = 'item-reordering';
        var ITEM_REORDER_BTN_CLASS = 'item-reorder';
        var DragOp = function() {};
        DragOp.prototype = {
          start: function() {},
          drag: function() {},
          end: function() {},
          isSameItem: function() {
            return false;
          }
        };
        var SlideDrag = function(opts) {
          this.dragThresholdX = opts.dragThresholdX || 10;
          this.el = opts.el;
          this.item = opts.item;
          this.canSwipe = opts.canSwipe;
        };
        SlideDrag.prototype = new DragOp();
        SlideDrag.prototype.start = function(e) {
          var content,
              buttons,
              offsetX,
              buttonsWidth;
          if (!this.canSwipe()) {
            return;
          }
          if (e.target.classList.contains(ITEM_CONTENT_CLASS)) {
            content = e.target;
          } else if (e.target.classList.contains(ITEM_CLASS)) {
            content = e.target.querySelector('.' + ITEM_CONTENT_CLASS);
          } else {
            content = ionic.DomUtil.getParentWithClass(e.target, ITEM_CONTENT_CLASS);
          }
          if (!content) {
            return;
          }
          content.classList.remove(ITEM_SLIDING_CLASS);
          offsetX = parseFloat(content.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]) || 0;
          buttons = content.parentNode.querySelector('.' + ITEM_OPTIONS_CLASS);
          if (!buttons) {
            return;
          }
          buttons.classList.remove('invisible');
          buttonsWidth = buttons.offsetWidth;
          this._currentDrag = {
            buttons: buttons,
            buttonsWidth: buttonsWidth,
            content: content,
            startOffsetX: offsetX
          };
        };
        SlideDrag.prototype.isSameItem = function(op) {
          if (op._lastDrag && this._currentDrag) {
            return this._currentDrag.content == op._lastDrag.content;
          }
          return false;
        };
        SlideDrag.prototype.clean = function(isInstant) {
          var lastDrag = this._lastDrag;
          if (!lastDrag || !lastDrag.content)
            return;
          lastDrag.content.style[ionic.CSS.TRANSITION] = '';
          lastDrag.content.style[ionic.CSS.TRANSFORM] = '';
          if (isInstant) {
            lastDrag.content.style[ionic.CSS.TRANSITION] = 'none';
            makeInvisible();
            ionic.requestAnimationFrame(function() {
              lastDrag.content.style[ionic.CSS.TRANSITION] = '';
            });
          } else {
            ionic.requestAnimationFrame(function() {
              setTimeout(makeInvisible, 250);
            });
          }
          function makeInvisible() {
            lastDrag.buttons && lastDrag.buttons.classList.add('invisible');
          }
        };
        SlideDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
          var buttonsWidth;
          if (!this._currentDrag) {
            return;
          }
          if (!this._isDragging && ((Math.abs(e.gesture.deltaX) > this.dragThresholdX) || (Math.abs(this._currentDrag.startOffsetX) > 0))) {
            this._isDragging = true;
          }
          if (this._isDragging) {
            buttonsWidth = this._currentDrag.buttonsWidth;
            var newX = Math.min(0, this._currentDrag.startOffsetX + e.gesture.deltaX);
            if (newX < -buttonsWidth) {
              newX = Math.min(-buttonsWidth, -buttonsWidth + (((e.gesture.deltaX + buttonsWidth) * 0.4)));
            }
            this._currentDrag.content.$$ionicOptionsOpen = newX !== 0;
            this._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + newX + 'px, 0, 0)';
            this._currentDrag.content.style[ionic.CSS.TRANSITION] = 'none';
          }
        });
        SlideDrag.prototype.end = function(e, doneCallback) {
          var self = this;
          if (!self._currentDrag) {
            doneCallback && doneCallback();
            return;
          }
          var restingPoint = -self._currentDrag.buttonsWidth;
          if (e.gesture.deltaX > -(self._currentDrag.buttonsWidth / 2)) {
            if (e.gesture.direction == "left" && Math.abs(e.gesture.velocityX) < 0.3) {
              restingPoint = 0;
            } else if (e.gesture.direction == "right") {
              restingPoint = 0;
            }
          }
          ionic.requestAnimationFrame(function() {
            if (restingPoint === 0) {
              self._currentDrag.content.style[ionic.CSS.TRANSFORM] = '';
              var buttons = self._currentDrag.buttons;
              setTimeout(function() {
                buttons && buttons.classList.add('invisible');
              }, 250);
            } else {
              self._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + restingPoint + 'px,0,0)';
            }
            self._currentDrag.content.style[ionic.CSS.TRANSITION] = '';
            if (!self._lastDrag) {
              self._lastDrag = {};
            }
            ionic.extend(self._lastDrag, self._currentDrag);
            if (self._currentDrag) {
              self._currentDrag.buttons = null;
              self._currentDrag.content = null;
            }
            self._currentDrag = null;
            doneCallback && doneCallback();
          });
        };
        var ReorderDrag = function(opts) {
          var self = this;
          self.dragThresholdY = opts.dragThresholdY || 0;
          self.onReorder = opts.onReorder;
          self.listEl = opts.listEl;
          self.el = self.item = opts.el;
          self.scrollEl = opts.scrollEl;
          self.scrollView = opts.scrollView;
          self.listElTrueTop = 0;
          if (self.listEl.offsetParent) {
            var obj = self.listEl;
            do {
              self.listElTrueTop += obj.offsetTop;
              obj = obj.offsetParent;
            } while (obj);
          }
        };
        ReorderDrag.prototype = new DragOp();
        ReorderDrag.prototype._moveElement = function(e) {
          var y = e.gesture.center.pageY + this.scrollView.getValues().top - (this._currentDrag.elementHeight / 2) - this.listElTrueTop;
          this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(0, ' + y + 'px, 0)';
        };
        ReorderDrag.prototype.deregister = function() {
          this.listEl = this.el = this.scrollEl = this.scrollView = null;
        };
        ReorderDrag.prototype.start = function(e) {
          var startIndex = ionic.DomUtil.getChildIndex(this.el, this.el.nodeName.toLowerCase());
          var elementHeight = this.el.scrollHeight;
          var placeholder = this.el.cloneNode(true);
          placeholder.classList.add(ITEM_PLACEHOLDER_CLASS);
          this.el.parentNode.insertBefore(placeholder, this.el);
          this.el.classList.add(ITEM_REORDERING_CLASS);
          this._currentDrag = {
            elementHeight: elementHeight,
            startIndex: startIndex,
            placeholder: placeholder,
            scrollHeight: scroll,
            list: placeholder.parentNode
          };
          this._moveElement(e);
        };
        ReorderDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
          var self = this;
          if (!this._currentDrag) {
            return;
          }
          var scrollY = 0;
          var pageY = e.gesture.center.pageY;
          var offset = this.listElTrueTop;
          if (this.scrollView) {
            var container = this.scrollView.__container;
            scrollY = this.scrollView.getValues().top;
            var containerTop = container.offsetTop;
            var pixelsPastTop = containerTop - pageY + this._currentDrag.elementHeight / 2;
            var pixelsPastBottom = pageY + this._currentDrag.elementHeight / 2 - containerTop - container.offsetHeight;
            if (e.gesture.deltaY < 0 && pixelsPastTop > 0 && scrollY > 0) {
              this.scrollView.scrollBy(null, -pixelsPastTop);
              ionic.requestAnimationFrame(function() {
                self.drag(e);
              });
            }
            if (e.gesture.deltaY > 0 && pixelsPastBottom > 0) {
              if (scrollY < this.scrollView.getScrollMax().top) {
                this.scrollView.scrollBy(null, pixelsPastBottom);
                ionic.requestAnimationFrame(function() {
                  self.drag(e);
                });
              }
            }
          }
          if (!this._isDragging && Math.abs(e.gesture.deltaY) > this.dragThresholdY) {
            this._isDragging = true;
          }
          if (this._isDragging) {
            this._moveElement(e);
            this._currentDrag.currentY = scrollY + pageY - offset;
          }
        });
        ReorderDrag.prototype._getReorderIndex = function() {
          var self = this;
          var siblings = Array.prototype.slice.call(self._currentDrag.placeholder.parentNode.children).filter(function(el) {
            return el.nodeName === self.el.nodeName && el !== self.el;
          });
          var dragOffsetTop = self._currentDrag.currentY;
          var el;
          for (var i = 0,
              len = siblings.length; i < len; i++) {
            el = siblings[i];
            if (i === len - 1) {
              if (dragOffsetTop > el.offsetTop) {
                return i;
              }
            } else if (i === 0) {
              if (dragOffsetTop < el.offsetTop + el.offsetHeight) {
                return i;
              }
            } else if (dragOffsetTop > el.offsetTop - el.offsetHeight / 2 && dragOffsetTop < el.offsetTop + el.offsetHeight) {
              return i;
            }
          }
          return self._currentDrag.startIndex;
        };
        ReorderDrag.prototype.end = function(e, doneCallback) {
          if (!this._currentDrag) {
            doneCallback && doneCallback();
            return;
          }
          var placeholder = this._currentDrag.placeholder;
          var finalIndex = this._getReorderIndex();
          this.el.classList.remove(ITEM_REORDERING_CLASS);
          this.el.style[ionic.CSS.TRANSFORM] = '';
          placeholder.parentNode.insertBefore(this.el, placeholder);
          placeholder.parentNode.removeChild(placeholder);
          this.onReorder && this.onReorder(this.el, this._currentDrag.startIndex, finalIndex);
          this._currentDrag = {
            placeholder: null,
            content: null
          };
          this._currentDrag = null;
          doneCallback && doneCallback();
        };
        ionic.views.ListView = ionic.views.View.inherit({
          initialize: function(opts) {
            var self = this;
            opts = ionic.extend({
              onReorder: function() {},
              virtualRemoveThreshold: -200,
              virtualAddThreshold: 200,
              canSwipe: function() {
                return true;
              }
            }, opts);
            ionic.extend(self, opts);
            if (!self.itemHeight && self.listEl) {
              self.itemHeight = self.listEl.children[0] && parseInt(self.listEl.children[0].style.height, 10);
            }
            self.onRefresh = opts.onRefresh || function() {};
            self.onRefreshOpening = opts.onRefreshOpening || function() {};
            self.onRefreshHolding = opts.onRefreshHolding || function() {};
            var gestureOpts = {};
            if (ionic.DomUtil.getParentOrSelfWithClass(self.el, 'overflow-scroll')) {
              gestureOpts.prevent_default_directions = ['left', 'right'];
            }
            window.ionic.onGesture('release', function(e) {
              self._handleEndDrag(e);
            }, self.el, gestureOpts);
            window.ionic.onGesture('drag', function(e) {
              self._handleDrag(e);
            }, self.el, gestureOpts);
            self._initDrag();
          },
          deregister: function() {
            this.el = this.listEl = this.scrollEl = this.scrollView = null;
            if (this.isScrollFreeze) {
              self.scrollView.freeze(false);
            }
          },
          stopRefreshing: function() {
            var refresher = this.el.querySelector('.list-refresher');
            refresher.style.height = '0';
          },
          didScroll: function(e) {
            var self = this;
            if (self.isVirtual) {
              var itemHeight = self.itemHeight;
              var scrollHeight = e.target.scrollHeight;
              var viewportHeight = self.el.parentNode.offsetHeight;
              var highWater = Math.max(0, e.scrollTop + self.virtualRemoveThreshold);
              var lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + self.virtualAddThreshold);
              var first = parseInt(Math.abs(highWater / itemHeight), 10);
              var last = parseInt(Math.abs(lowWater / itemHeight), 10);
              self._virtualItemsToRemove = Array.prototype.slice.call(self.listEl.children, 0, first);
              self.renderViewport && self.renderViewport(highWater, lowWater, first, last);
            }
          },
          didStopScrolling: function() {
            if (this.isVirtual) {
              for (var i = 0; i < this._virtualItemsToRemove.length; i++) {
                this.didHideItem && this.didHideItem(i);
              }
            }
          },
          clearDragEffects: function(isInstant) {
            if (this._lastDragOp) {
              this._lastDragOp.clean && this._lastDragOp.clean(isInstant);
              this._lastDragOp.deregister && this._lastDragOp.deregister();
              this._lastDragOp = null;
            }
          },
          _initDrag: function() {
            if (this._lastDragOp) {
              this._lastDragOp.deregister && this._lastDragOp.deregister();
            }
            this._lastDragOp = this._dragOp;
            this._dragOp = null;
          },
          _getItem: function(target) {
            while (target) {
              if (target.classList && target.classList.contains(ITEM_CLASS)) {
                return target;
              }
              target = target.parentNode;
            }
            return null;
          },
          _startDrag: function(e) {
            var self = this;
            self._isDragging = false;
            var lastDragOp = self._lastDragOp;
            var item;
            if (self._didDragUpOrDown && lastDragOp instanceof SlideDrag) {
              lastDragOp.clean && lastDragOp.clean();
            }
            if (ionic.DomUtil.getParentOrSelfWithClass(e.target, ITEM_REORDER_BTN_CLASS) && (e.gesture.direction == 'up' || e.gesture.direction == 'down')) {
              item = self._getItem(e.target);
              if (item) {
                self._dragOp = new ReorderDrag({
                  listEl: self.el,
                  el: item,
                  scrollEl: self.scrollEl,
                  scrollView: self.scrollView,
                  onReorder: function(el, start, end) {
                    self.onReorder && self.onReorder(el, start, end);
                  }
                });
                self._dragOp.start(e);
                e.preventDefault();
              }
            } else if (!self._didDragUpOrDown && (e.gesture.direction == 'left' || e.gesture.direction == 'right') && Math.abs(e.gesture.deltaX) > 5) {
              item = self._getItem(e.target);
              if (item && item.querySelector('.item-options')) {
                self._dragOp = new SlideDrag({
                  el: self.el,
                  item: item,
                  canSwipe: self.canSwipe
                });
                self._dragOp.start(e);
                e.preventDefault();
                self.isScrollFreeze = self.scrollView.freeze(true);
              }
            }
            if (lastDragOp && self._dragOp && !self._dragOp.isSameItem(lastDragOp) && e.defaultPrevented) {
              lastDragOp.clean && lastDragOp.clean();
            }
          },
          _handleEndDrag: function(e) {
            var self = this;
            if (self.scrollView) {
              self.isScrollFreeze = self.scrollView.freeze(false);
            }
            self._didDragUpOrDown = false;
            if (!self._dragOp) {
              return;
            }
            self._dragOp.end(e, function() {
              self._initDrag();
            });
          },
          _handleDrag: function(e) {
            var self = this;
            if (Math.abs(e.gesture.deltaY) > 5) {
              self._didDragUpOrDown = true;
            }
            if (!self.isDragging && !self._dragOp) {
              self._startDrag(e);
            }
            if (!self._dragOp) {
              return;
            }
            e.gesture.srcEvent.preventDefault();
            self._dragOp.drag(e);
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Modal = ionic.views.View.inherit({
          initialize: function(opts) {
            opts = ionic.extend({
              focusFirstInput: false,
              unfocusOnHide: true,
              focusFirstDelay: 600,
              backdropClickToClose: true,
              hardwareBackButtonClose: true
            }, opts);
            ionic.extend(this, opts);
            this.el = opts.el;
          },
          show: function() {
            var self = this;
            if (self.focusFirstInput) {
              window.setTimeout(function() {
                var input = self.el.querySelector('input, textarea');
                input && input.focus && input.focus();
              }, self.focusFirstDelay);
            }
          },
          hide: function() {
            if (this.unfocusOnHide) {
              var inputs = this.el.querySelectorAll('input, textarea');
              window.setTimeout(function() {
                for (var i = 0; i < inputs.length; i++) {
                  inputs[i].blur && inputs[i].blur();
                }
              });
            }
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.SideMenu = ionic.views.View.inherit({
          initialize: function(opts) {
            this.el = opts.el;
            this.isEnabled = (typeof opts.isEnabled === 'undefined') ? true : opts.isEnabled;
            this.setWidth(opts.width);
          },
          getFullWidth: function() {
            return this.width;
          },
          setWidth: function(width) {
            this.width = width;
            this.el.style.width = width + 'px';
          },
          setIsEnabled: function(isEnabled) {
            this.isEnabled = isEnabled;
          },
          bringUp: function() {
            if (this.el.style.zIndex !== '0') {
              this.el.style.zIndex = '0';
            }
          },
          pushDown: function() {
            if (this.el.style.zIndex !== '-1') {
              this.el.style.zIndex = '-1';
            }
          }
        });
        ionic.views.SideMenuContent = ionic.views.View.inherit({
          initialize: function(opts) {
            ionic.extend(this, {
              animationClass: 'menu-animated',
              onDrag: function() {},
              onEndDrag: function() {}
            }, opts);
            ionic.onGesture('drag', ionic.proxy(this._onDrag, this), this.el);
            ionic.onGesture('release', ionic.proxy(this._onEndDrag, this), this.el);
          },
          _onDrag: function(e) {
            this.onDrag && this.onDrag(e);
          },
          _onEndDrag: function(e) {
            this.onEndDrag && this.onEndDrag(e);
          },
          disableAnimation: function() {
            this.el.classList.remove(this.animationClass);
          },
          enableAnimation: function() {
            this.el.classList.add(this.animationClass);
          },
          getTranslateX: function() {
            return parseFloat(this.el.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]);
          },
          setTranslateX: ionic.animationFrameThrottle(function(x) {
            this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(' + x + 'px, 0, 0)';
          })
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Slider = ionic.views.View.inherit({initialize: function(options) {
            var slider = this;
            var noop = function() {};
            var offloadFn = function(fn) {
              setTimeout(fn || noop, 0);
            };
            var browser = {
              addEventListener: !!window.addEventListener,
              touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,
              transitions: (function(temp) {
                var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
                for (var i in props)
                  if (temp.style[props[i]] !== undefined)
                    return true;
                return false;
              })(document.createElement('swipe'))
            };
            var container = options.el;
            if (!container)
              return;
            var element = container.children[0];
            var slides,
                slidePos,
                width,
                length;
            options = options || {};
            var index = parseInt(options.startSlide, 10) || 0;
            var speed = options.speed || 300;
            options.continuous = options.continuous !== undefined ? options.continuous : true;
            function setup() {
              if (!container.offsetWidth) {
                return;
              }
              slides = element.children;
              length = slides.length;
              if (slides.length < 2)
                options.continuous = false;
              if (browser.transitions && options.continuous && slides.length < 3) {
                element.appendChild(slides[0].cloneNode(true));
                element.appendChild(element.children[1].cloneNode(true));
                slides = element.children;
              }
              slidePos = new Array(slides.length);
              width = container.offsetWidth || container.getBoundingClientRect().width;
              element.style.width = (slides.length * width) + 'px';
              var pos = slides.length;
              while (pos--) {
                var slide = slides[pos];
                slide.style.width = width + 'px';
                slide.setAttribute('data-index', pos);
                if (browser.transitions) {
                  slide.style.left = (pos * -width) + 'px';
                  move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
                }
              }
              if (options.continuous && browser.transitions) {
                move(circle(index - 1), -width, 0);
                move(circle(index + 1), width, 0);
              }
              if (!browser.transitions)
                element.style.left = (index * -width) + 'px';
              container.style.visibility = 'visible';
              options.slidesChanged && options.slidesChanged();
            }
            function prev(slideSpeed) {
              if (options.continuous)
                slide(index - 1, slideSpeed);
              else if (index)
                slide(index - 1, slideSpeed);
            }
            function next(slideSpeed) {
              if (options.continuous)
                slide(index + 1, slideSpeed);
              else if (index < slides.length - 1)
                slide(index + 1, slideSpeed);
            }
            function circle(index) {
              return (slides.length + (index % slides.length)) % slides.length;
            }
            function slide(to, slideSpeed) {
              if (index == to)
                return;
              if (browser.transitions) {
                var direction = Math.abs(index - to) / (index - to);
                if (options.continuous) {
                  var naturalDirection = direction;
                  direction = -slidePos[circle(to)] / width;
                  if (direction !== naturalDirection)
                    to = -direction * slides.length + to;
                }
                var diff = Math.abs(index - to) - 1;
                while (diff--)
                  move(circle((to > index ? to : index) - diff - 1), width * direction, 0);
                to = circle(to);
                move(index, width * direction, slideSpeed || speed);
                move(to, 0, slideSpeed || speed);
                if (options.continuous)
                  move(circle(to - direction), -(width * direction), 0);
              } else {
                to = circle(to);
                animate(index * -width, to * -width, slideSpeed || speed);
              }
              index = to;
              offloadFn(options.callback && options.callback(index, slides[index]));
            }
            function move(index, dist, speed) {
              translate(index, dist, speed);
              slidePos[index] = dist;
            }
            function translate(index, dist, speed) {
              var slide = slides[index];
              var style = slide && slide.style;
              if (!style)
                return;
              style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + 'ms';
              style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
              style.msTransform = style.MozTransform = style.OTransform = 'translateX(' + dist + 'px)';
            }
            function animate(from, to, speed) {
              if (!speed) {
                element.style.left = to + 'px';
                return;
              }
              var start = +new Date();
              var timer = setInterval(function() {
                var timeElap = +new Date() - start;
                if (timeElap > speed) {
                  element.style.left = to + 'px';
                  if (delay)
                    begin();
                  options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                  clearInterval(timer);
                  return;
                }
                element.style.left = (((to - from) * (Math.floor((timeElap / speed) * 100) / 100)) + from) + 'px';
              }, 4);
            }
            var delay = options.auto || 0;
            var interval;
            function begin() {
              interval = setTimeout(next, delay);
            }
            function stop() {
              delay = options.auto || 0;
              clearTimeout(interval);
            }
            var start = {};
            var delta = {};
            var isScrolling;
            var events = {
              handleEvent: function(event) {
                if (event.type == 'mousedown' || event.type == 'mouseup' || event.type == 'mousemove') {
                  event.touches = [{
                    pageX: event.pageX,
                    pageY: event.pageY
                  }];
                }
                switch (event.type) {
                  case 'mousedown':
                    this.start(event);
                    break;
                  case 'touchstart':
                    this.start(event);
                    break;
                  case 'touchmove':
                    this.touchmove(event);
                    break;
                  case 'mousemove':
                    this.touchmove(event);
                    break;
                  case 'touchend':
                    offloadFn(this.end(event));
                    break;
                  case 'mouseup':
                    offloadFn(this.end(event));
                    break;
                  case 'webkitTransitionEnd':
                  case 'msTransitionEnd':
                  case 'oTransitionEnd':
                  case 'otransitionend':
                  case 'transitionend':
                    offloadFn(this.transitionEnd(event));
                    break;
                  case 'resize':
                    offloadFn(setup);
                    break;
                }
                if (options.stopPropagation)
                  event.stopPropagation();
              },
              start: function(event) {
                var touches = event.touches[0];
                start = {
                  x: touches.pageX,
                  y: touches.pageY,
                  time: +new Date()
                };
                isScrolling = undefined;
                delta = {};
                if (browser.touch) {
                  element.addEventListener('touchmove', this, false);
                  element.addEventListener('touchend', this, false);
                } else {
                  element.addEventListener('mousemove', this, false);
                  element.addEventListener('mouseup', this, false);
                  document.addEventListener('mouseup', this, false);
                }
              },
              touchmove: function(event) {
                if (event.touches.length > 1 || event.scale && event.scale !== 1 || slider.slideIsDisabled) {
                  return;
                }
                if (options.disableScroll)
                  event.preventDefault();
                var touches = event.touches[0];
                delta = {
                  x: touches.pageX - start.x,
                  y: touches.pageY - start.y
                };
                if (typeof isScrolling == 'undefined') {
                  isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
                }
                if (!isScrolling) {
                  event.preventDefault();
                  stop();
                  if (options.continuous) {
                    translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);
                  } else {
                    delta.x = delta.x / ((!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0) ? (Math.abs(delta.x) / width + 1) : 1);
                    translate(index - 1, delta.x + slidePos[index - 1], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(index + 1, delta.x + slidePos[index + 1], 0);
                  }
                  options.onDrag && options.onDrag();
                }
              },
              end: function() {
                var duration = +new Date() - start.time;
                var isValidSlide = Number(duration) < 250 && Math.abs(delta.x) > 20 || Math.abs(delta.x) > width / 2;
                var isPastBounds = (!index && delta.x > 0) || (index == slides.length - 1 && delta.x < 0);
                if (options.continuous)
                  isPastBounds = false;
                var direction = delta.x < 0;
                if (!isScrolling) {
                  if (isValidSlide && !isPastBounds) {
                    if (direction) {
                      if (options.continuous) {
                        move(circle(index - 1), -width, 0);
                        move(circle(index + 2), width, 0);
                      } else {
                        move(index - 1, -width, 0);
                      }
                      move(index, slidePos[index] - width, speed);
                      move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);
                      index = circle(index + 1);
                    } else {
                      if (options.continuous) {
                        move(circle(index + 1), width, 0);
                        move(circle(index - 2), -width, 0);
                      } else {
                        move(index + 1, width, 0);
                      }
                      move(index, slidePos[index] + width, speed);
                      move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);
                      index = circle(index - 1);
                    }
                    options.callback && options.callback(index, slides[index]);
                  } else {
                    if (options.continuous) {
                      move(circle(index - 1), -width, speed);
                      move(index, 0, speed);
                      move(circle(index + 1), width, speed);
                    } else {
                      move(index - 1, -width, speed);
                      move(index, 0, speed);
                      move(index + 1, width, speed);
                    }
                  }
                }
                if (browser.touch) {
                  element.removeEventListener('touchmove', events, false);
                  element.removeEventListener('touchend', events, false);
                } else {
                  element.removeEventListener('mousemove', events, false);
                  element.removeEventListener('mouseup', events, false);
                  document.removeEventListener('mouseup', events, false);
                }
                options.onDragEnd && options.onDragEnd();
              },
              transitionEnd: function(event) {
                if (parseInt(event.target.getAttribute('data-index'), 10) == index) {
                  if (delay)
                    begin();
                  options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                }
              }
            };
            this.update = function() {
              setTimeout(setup);
            };
            this.setup = function() {
              setup();
            };
            this.loop = function(value) {
              if (arguments.length)
                options.continuous = !!value;
              return options.continuous;
            };
            this.enableSlide = function(shouldEnable) {
              if (arguments.length) {
                this.slideIsDisabled = !shouldEnable;
              }
              return !this.slideIsDisabled;
            };
            this.slide = this.select = function(to, speed) {
              stop();
              slide(to, speed);
            };
            this.prev = this.previous = function() {
              stop();
              prev();
            };
            this.next = function() {
              stop();
              next();
            };
            this.stop = function() {
              stop();
            };
            this.start = function() {
              begin();
            };
            this.autoPlay = function(newDelay) {
              if (!delay || delay < 0) {
                stop();
              } else {
                delay = newDelay;
                begin();
              }
            };
            this.currentIndex = this.selected = function() {
              return index;
            };
            this.slidesCount = this.count = function() {
              return length;
            };
            this.kill = function() {
              stop();
              element.style.width = '';
              element.style.left = '';
              slides && (slides = []);
              if (browser.addEventListener) {
                element.removeEventListener('touchstart', events, false);
                element.removeEventListener('webkitTransitionEnd', events, false);
                element.removeEventListener('msTransitionEnd', events, false);
                element.removeEventListener('oTransitionEnd', events, false);
                element.removeEventListener('otransitionend', events, false);
                element.removeEventListener('transitionend', events, false);
                window.removeEventListener('resize', events, false);
              } else {
                window.onresize = null;
              }
            };
            this.load = function() {
              setup();
              if (delay)
                begin();
              if (browser.addEventListener) {
                if (browser.touch) {
                  element.addEventListener('touchstart', events, false);
                } else {
                  element.addEventListener('mousedown', events, false);
                }
                if (browser.transitions) {
                  element.addEventListener('webkitTransitionEnd', events, false);
                  element.addEventListener('msTransitionEnd', events, false);
                  element.addEventListener('oTransitionEnd', events, false);
                  element.addEventListener('otransitionend', events, false);
                  element.addEventListener('transitionend', events, false);
                }
                window.addEventListener('resize', events, false);
              } else {
                window.onresize = function() {
                  setup();
                };
              }
            };
          }});
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Toggle = ionic.views.View.inherit({
          initialize: function(opts) {
            var self = this;
            this.el = opts.el;
            this.checkbox = opts.checkbox;
            this.track = opts.track;
            this.handle = opts.handle;
            this.openPercent = -1;
            this.onChange = opts.onChange || function() {};
            this.triggerThreshold = opts.triggerThreshold || 20;
            this.dragStartHandler = function(e) {
              self.dragStart(e);
            };
            this.dragHandler = function(e) {
              self.drag(e);
            };
            this.holdHandler = function(e) {
              self.hold(e);
            };
            this.releaseHandler = function(e) {
              self.release(e);
            };
            this.dragStartGesture = ionic.onGesture('dragstart', this.dragStartHandler, this.el);
            this.dragGesture = ionic.onGesture('drag', this.dragHandler, this.el);
            this.dragHoldGesture = ionic.onGesture('hold', this.holdHandler, this.el);
            this.dragReleaseGesture = ionic.onGesture('release', this.releaseHandler, this.el);
          },
          destroy: function() {
            ionic.offGesture(this.dragStartGesture, 'dragstart', this.dragStartGesture);
            ionic.offGesture(this.dragGesture, 'drag', this.dragGesture);
            ionic.offGesture(this.dragHoldGesture, 'hold', this.holdHandler);
            ionic.offGesture(this.dragReleaseGesture, 'release', this.releaseHandler);
          },
          tap: function() {
            if (this.el.getAttribute('disabled') !== 'disabled') {
              this.val(!this.checkbox.checked);
            }
          },
          dragStart: function(e) {
            if (this.checkbox.disabled)
              return;
            this._dragInfo = {
              width: this.el.offsetWidth,
              left: this.el.offsetLeft,
              right: this.el.offsetLeft + this.el.offsetWidth,
              triggerX: this.el.offsetWidth / 2,
              initialState: this.checkbox.checked
            };
            e.gesture.srcEvent.preventDefault();
            this.hold(e);
          },
          drag: function(e) {
            var self = this;
            if (!this._dragInfo) {
              return;
            }
            e.gesture.srcEvent.preventDefault();
            ionic.requestAnimationFrame(function() {
              if (!self._dragInfo) {
                return;
              }
              var px = e.gesture.touches[0].pageX - self._dragInfo.left;
              var mx = self._dragInfo.width - self.triggerThreshold;
              if (self._dragInfo.initialState) {
                if (px < self.triggerThreshold) {
                  self.setOpenPercent(0);
                } else if (px > self._dragInfo.triggerX) {
                  self.setOpenPercent(100);
                }
              } else {
                if (px < self._dragInfo.triggerX) {
                  self.setOpenPercent(0);
                } else if (px > mx) {
                  self.setOpenPercent(100);
                }
              }
            });
          },
          endDrag: function() {
            this._dragInfo = null;
          },
          hold: function() {
            this.el.classList.add('dragging');
          },
          release: function(e) {
            this.el.classList.remove('dragging');
            this.endDrag(e);
          },
          setOpenPercent: function(openPercent) {
            if (this.openPercent < 0 || (openPercent < (this.openPercent - 3) || openPercent > (this.openPercent + 3))) {
              this.openPercent = openPercent;
              if (openPercent === 0) {
                this.val(false);
              } else if (openPercent === 100) {
                this.val(true);
              } else {
                var openPixel = Math.round((openPercent / 100) * this.track.offsetWidth - (this.handle.offsetWidth));
                openPixel = (openPixel < 1 ? 0 : openPixel);
                this.handle.style[ionic.CSS.TRANSFORM] = 'translate3d(' + openPixel + 'px,0,0)';
              }
            }
          },
          val: function(value) {
            if (value === true || value === false) {
              if (this.handle.style[ionic.CSS.TRANSFORM] !== "") {
                this.handle.style[ionic.CSS.TRANSFORM] = "";
              }
              this.checkbox.checked = value;
              this.openPercent = (value ? 100 : 0);
              this.onChange && this.onChange();
            }
            return this.checkbox.checked;
          }
        });
      })(ionic);
    })();
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-animate@1.4.1/angular-animate.js", ["github:angular/bower-angular@1.4.1.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var noop = angular.noop;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return [];
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationOptions(element, target, newOptions) {
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        extend(target, newOptions);
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var tickQueue = [];
        var cancelFn;
        function scheduler(tasks) {
          tickQueue.push([].concat(tasks));
          nextTick();
        }
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!tickQueue.length)
            return;
          var updatedQueue = [];
          for (var i = 0; i < tickQueue.length; i++) {
            var innerQueue = tickQueue[i];
            runNextTask(innerQueue);
            if (innerQueue.length) {
              updatedQueue.push(innerQueue);
            }
          }
          tickQueue = updatedQueue;
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
        function runNextTask(tasks) {
          var nextTask = tasks.shift();
          nextTask();
        }
      }];
      var $$AnimateChildrenDirective = [function() {
        return function(scope, element, attrs) {
          var val = attrs.ngAnimateChildren;
          if (angular.isString(val) && val.length === 0) {
            element.data(NG_ANIMATE_CHILDREN_DATA, true);
          } else {
            attrs.$observe('ngAnimateChildren', function(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            });
          }
        };
      }];
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$document', '$sniffer', '$$rAFScheduler', function($window, $$jqLite, $$AnimateRunner, $timeout, $document, $sniffer, $$rAFScheduler) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var bod = getDomNode($document).body;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var width = bod.offsetWidth + 1;
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](width);
              }
              rafWaitQueue.length = 0;
            });
          }
          return init;
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          function init(element, options) {
            var node = getDomNode(element);
            options = prepareAnimationOptions(options);
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, 'ng-', true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, '-add');
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, '-remove');
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
              addRemoveClassName = '';
            }
            var setupClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + setupClasses;
            var activeClasses = pendClasses(setupClasses, '-active');
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            if (!hasToStyles && !setupClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, setupClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            $$jqLite.addClass(element, setupClasses);
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            applyAnimationFromStyles(element, options);
            if (!flags.blockTransition) {
              blockTransitions(node, false);
            }
            applyBlocking(maxDuration);
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              $$jqLite.removeClass(element, setupClasses);
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (options.onDone) {
                options.onDone();
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function start() {
              if (animationClosed)
                return;
              var startTime,
                  events = [];
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + setupClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyTransitionDelay || flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  var delayStyle;
                  if (flags.applyTransitionDelay) {
                    timings.transitionDelay = relativeDelay;
                    delayStyle = getCssDelayStyle(relativeDelay);
                    temporaryStyles.push(delayStyle);
                    node.style[delayStyle[0]] = delayStyle[1];
                  }
                  if (flags.applyAnimationDelay) {
                    timings.animationDelay = relativeDelay;
                    delayStyle = getCssDelayStyle(relativeDelay, true);
                    temporaryStyles.push(delayStyle);
                    node.style[delayStyle[0]] = delayStyle[1];
                  }
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                element.on(events.join(' '), onAnimationProgress);
                $timeout(onAnimationExpired, maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime);
                applyAnimationToStyles(element, options);
              }
              function onAnimationExpired() {
                close();
              }
              function onAnimationProgress(event) {
                event.stopPropagation();
                var ev = event.originalEvent || event;
                var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
                var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                  animationCompleted = true;
                  close();
                }
              }
            }
          }
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$document', '$sniffer', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $document, $sniffer) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = getDomNode($document).body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(bodyNode.parentNode === rootNode ? bodyNode : rootNode);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from);
            var toAnimation = prepareRegularAnimation(to);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.structural = options.applyClassesEarly = true;
              options.event = animationDetails.event;
              if (options.event === 'leave') {
                options.onDone = options.domOperation;
              }
            } else {
              options.event = null;
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$rAFMutex', '$$jqLite', function($injector, $$AnimateRunner, $$rAFMutex, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            return {start: function() {
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                var animationClosed = false;
                var runner = new $$AnimateRunner({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  animationClosed = true;
                  applyOptions();
                  applyAnimationStyles(element, options);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }};
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(options, and) {
          options = options || {};
          var a = (options.addClass || '').length > 0;
          var b = (options.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation.options);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          var nO = newAnimation.options;
          var cO = currentAnimation.options;
          return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var bodyElement = jqLite($document[0].body);
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationOptions(element, options) {
            return mergeAnimationOptions(element, options, {});
          }
          function findCallbacks(element, event) {
            var targetNode = getDomNode(element);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (entry.node.contains(targetNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          function triggerCallback(event, element, phase, data) {
            $$rAF(function() {
              forEach(findCallbacks(element, event), function(callback) {
                callback(element, phase, data);
              });
            });
          }
          return {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
            },
            off: function(event, container, callback) {
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
              function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                  var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                  return !isMatch;
                });
              }
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    bool = !!bool;
                    if (!bool) {
                      disabledElementsLookup.put(node, true);
                    } else if (recordExists) {
                      disabledElementsLookup.remove(node);
                    }
                  }
                }
              }
              return bool;
            }
          };
          function queueAnimation(element, event, options) {
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            if (!node) {
              close();
              return runner;
            }
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              close();
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationOptions(element, existingAnimation.options, options);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationOptions(element, newAnimation.options, existingAnimation.options);
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationOptions(element, options);
                  } else {
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
                    return runner;
                  }
                }
              }
            } else {
              normalizeAnimationOptions(element, options);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation.options);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            if (isStructural) {
              closeParentClassBasedAnimations(parent);
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails.options));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true) ? 'setClass' : animationDetails.event;
              if (animationDetails.structural) {
                closeParentClassBasedAnimations(parentElement);
              }
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              triggerCallback(event, element, phase, data);
              runner.progress(event, phase, data);
            }
            function close(reject) {
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              switch (state) {
                case RUNNING_STATE:
                  animationDetails.runner.end();
                case PRE_DIGEST_STATE:
                  if (animationDetails) {
                    activeAnimationsLookup.remove(child);
                  }
                  break;
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function closeParentClassBasedAnimations(startingElement) {
            var parentNode = getDomNode(startingElement);
            do {
              if (!parentNode || parentNode.nodeType !== ELEMENT_NODE)
                break;
              var animationDetails = activeAnimationsLookup.get(parentNode);
              if (animationDetails) {
                examineParentAnimation(parentNode, animationDetails);
              }
              parentNode = parentNode.parentNode;
            } while (true);
            function examineParentAnimation(node, animationDetails) {
              if (animationDetails.structural || !hasAnimationClasses(animationDetails.options))
                return;
              if (animationDetails.state === RUNNING_STATE) {
                animationDetails.runner.end();
              }
              clearElementAnimationState(node);
            }
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElementDetected = false;
            var rootElementDetected = false;
            var parentAnimationDetected = false;
            var animateChildren;
            var parentHost = element.data(NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            while (parentElement && parentElement.length) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              var parentNode = parentElement[0];
              if (parentNode.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentNode) || {};
              if (!parentAnimationDetected) {
                parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
                if (!rootElementDetected) {
                  parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);
                  if (parentHost) {
                    parentElement = parentHost;
                  }
                }
              }
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              parentElement = parentElement.parent();
            }
            var allowAnimation = !parentAnimationDetected || animateChildren;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$rAFMutexFactory = ['$$rAF', function($$rAF) {
        return function() {
          var passed = false;
          $$rAF(function() {
            passed = true;
          });
          return function(fn) {
            passed ? fn() : $$rAF(fn);
          };
        };
      }];
      var $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {
        var INITIAL_STATE = 0;
        var DONE_PENDING_STATE = 1;
        var DONE_COMPLETE_STATE = 2;
        AnimateRunner.chain = function(chain, callback) {
          var index = 0;
          next();
          function next() {
            if (index === chain.length) {
              callback(true);
              return;
            }
            chain[index](function(response) {
              if (response === false) {
                callback(false);
                return;
              }
              index++;
              next();
            });
          }
        };
        AnimateRunner.all = function(runners, callback) {
          var count = 0;
          var status = true;
          forEach(runners, function(runner) {
            runner.done(onProgress);
          });
          function onProgress(response) {
            status = status && response;
            if (++count === runners.length) {
              callback(status);
            }
          }
        };
        function AnimateRunner(host) {
          this.setHost(host);
          this._doneCallbacks = [];
          this._runInAnimationFrame = $$rAFMutex();
          this._state = 0;
        }
        AnimateRunner.prototype = {
          setHost: function(host) {
            this.host = host || {};
          },
          done: function(fn) {
            if (this._state === DONE_COMPLETE_STATE) {
              fn();
            } else {
              this._doneCallbacks.push(fn);
            }
          },
          progress: noop,
          getPromise: function() {
            if (!this.promise) {
              var self = this;
              this.promise = $q(function(resolve, reject) {
                self.done(function(status) {
                  status === false ? reject() : resolve();
                });
              });
            }
            return this.promise;
          },
          then: function(resolveHandler, rejectHandler) {
            return this.getPromise().then(resolveHandler, rejectHandler);
          },
          'catch': function(handler) {
            return this.getPromise()['catch'](handler);
          },
          'finally': function(handler) {
            return this.getPromise()['finally'](handler);
          },
          pause: function() {
            if (this.host.pause) {
              this.host.pause();
            }
          },
          resume: function() {
            if (this.host.resume) {
              this.host.resume();
            }
          },
          end: function() {
            if (this.host.end) {
              this.host.end();
            }
            this._resolve(true);
          },
          cancel: function() {
            if (this.host.cancel) {
              this.host.cancel();
            }
            this._resolve(false);
          },
          complete: function(response) {
            var self = this;
            if (self._state === INITIAL_STATE) {
              self._state = DONE_PENDING_STATE;
              self._runInAnimationFrame(function() {
                self._resolve(response);
              });
            }
          },
          _resolve: function(response) {
            if (this._state !== DONE_COMPLETE_STATE) {
              forEach(this._doneCallbacks, function(fn) {
                fn(response);
              });
              this._doneCallbacks.length = 0;
              this._state = DONE_COMPLETE_STATE;
            }
          }
        };
        return AnimateRunner;
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var totalPendingClassBasedAnimations = 0;
          var totalActiveClassBasedAnimations = 0;
          var classBasedAnimationsQueue = [];
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var classBasedIndex;
            if (!isStructural) {
              classBasedIndex = totalPendingClassBasedAnimations;
              totalPendingClassBasedAnimations += 1;
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              classBasedIndex: classBasedIndex,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              totalActiveClassBasedAnimations = totalPendingClassBasedAnimations;
              totalPendingClassBasedAnimations = 0;
              classBasedAnimationsQueue.length = 0;
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                }
              });
              animationQueue.length = 0;
              forEach(groupAnimations(animations), function(animationEntry) {
                if (animationEntry.structural) {
                  triggerAnimationStart();
                } else {
                  classBasedAnimationsQueue.push({
                    node: getDomNode(animationEntry.element),
                    fn: triggerAnimationStart
                  });
                  if (animationEntry.classBasedIndex === totalActiveClassBasedAnimations - 1) {
                    classBasedAnimationsQueue = classBasedAnimationsQueue.sort(function(a, b) {
                      return b.node.contains(a.node);
                    }).map(function(entry) {
                      return entry.fn;
                    });
                    $$rAFScheduler(classBasedAnimationsQueue);
                  }
                }
                function triggerAnimationStart() {
                  animationEntry.beforeStart();
                  var startAnimationFn,
                      closeFn = animationEntry.close;
                  var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                  if (getRunner(targetElement)) {
                    var operation = invokeFirstDriver(animationEntry);
                    if (operation) {
                      startAnimationFn = operation.start;
                    }
                  }
                  if (!startAnimationFn) {
                    closeFn();
                  } else {
                    var animationRunner = startAnimationFn();
                    animationRunner.done(function(status) {
                      closeFn(!status);
                    });
                    updateAnimationRunners(animationEntry, animationRunner);
                  }
                }
              });
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                if (!$injector.has(driverName))
                  continue;
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                getRunner(element).setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      angular.module('ngAnimate', []).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFMutex', $$rAFMutexFactory).factory('$$rAFScheduler', $$rAFSchedulerFactory).factory('$$AnimateRunner', $$AnimateRunnerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-sanitize@1.4.1/angular-sanitize.js", ["github:angular/bower-angular@1.4.1.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      function $SanitizeProvider() {
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
      }
      var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
          END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
          ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
          BEGIN_TAG_REGEXP = /^</,
          BEGING_END_TAGE_REGEXP = /^<\//,
          COMMENT_REGEXP = /<!--(.*?)-->/g,
          DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
          CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
          SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
          NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
      var voidElements = makeMap("area,br,col,hr,img,wbr");
      var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
          optionalEndTagInlineElements = makeMap("rp,rt"),
          optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
      var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
      var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
      var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
      var specialElements = makeMap("script,style");
      var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
      var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
      var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
      var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
      var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
      function makeMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
      }
      function htmlParser(html, handler) {
        if (typeof html !== 'string') {
          if (html === null || typeof html === 'undefined') {
            html = '';
          } else {
            html = '' + html;
          }
        }
        var index,
            chars,
            match,
            stack = [],
            last = html,
            text;
        stack.last = function() {
          return stack[stack.length - 1];
        };
        while (html) {
          text = '';
          chars = true;
          if (!stack.last() || !specialElements[stack.last()]) {
            if (html.indexOf("<!--") === 0) {
              index = html.indexOf("--", 4);
              if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                if (handler.comment)
                  handler.comment(html.substring(4, index));
                html = html.substring(index + 3);
                chars = false;
              }
            } else if (DOCTYPE_REGEXP.test(html)) {
              match = html.match(DOCTYPE_REGEXP);
              if (match) {
                html = html.replace(match[0], '');
                chars = false;
              }
            } else if (BEGING_END_TAGE_REGEXP.test(html)) {
              match = html.match(END_TAG_REGEXP);
              if (match) {
                html = html.substring(match[0].length);
                match[0].replace(END_TAG_REGEXP, parseEndTag);
                chars = false;
              }
            } else if (BEGIN_TAG_REGEXP.test(html)) {
              match = html.match(START_TAG_REGEXP);
              if (match) {
                if (match[4]) {
                  html = html.substring(match[0].length);
                  match[0].replace(START_TAG_REGEXP, parseStartTag);
                }
                chars = false;
              } else {
                text += '<';
                html = html.substring(1);
              }
            }
            if (chars) {
              index = html.indexOf("<");
              text += index < 0 ? html : html.substring(0, index);
              html = index < 0 ? "" : html.substring(index);
              if (handler.chars)
                handler.chars(decodeEntities(text));
            }
          } else {
            html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'), function(all, text) {
              text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
              if (handler.chars)
                handler.chars(decodeEntities(text));
              return "";
            });
            parseEndTag("", stack.last());
          }
          if (html == last) {
            throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " + "of html: {0}", html);
          }
          last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
          tagName = angular.lowercase(tagName);
          if (blockElements[tagName]) {
            while (stack.last() && inlineElements[stack.last()]) {
              parseEndTag("", stack.last());
            }
          }
          if (optionalEndTagElements[tagName] && stack.last() == tagName) {
            parseEndTag("", tagName);
          }
          unary = voidElements[tagName] || !!unary;
          if (!unary) {
            stack.push(tagName);
          }
          var attrs = {};
          rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
            var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';
            attrs[name] = decodeEntities(value);
          });
          if (handler.start)
            handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
          var pos = 0,
              i;
          tagName = angular.lowercase(tagName);
          if (tagName) {
            for (pos = stack.length - 1; pos >= 0; pos--) {
              if (stack[pos] == tagName)
                break;
            }
          }
          if (pos >= 0) {
            for (i = stack.length - 1; i >= pos; i--)
              if (handler.end)
                handler.end(stack[i]);
            stack.length = pos;
          }
        }
      }
      var hiddenPre = document.createElement("pre");
      function decodeEntities(value) {
        if (!value) {
          return '';
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
      }
      function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
          return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
          start: function(tag, attrs, unary) {
            tag = angular.lowercase(tag);
            if (!ignore && specialElements[tag]) {
              ignore = tag;
            }
            if (!ignore && validElements[tag] === true) {
              out('<');
              out(tag);
              angular.forEach(attrs, function(value, key) {
                var lkey = angular.lowercase(key);
                var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                  out(' ');
                  out(key);
                  out('="');
                  out(encodeEntities(value));
                  out('"');
                }
              });
              out(unary ? '/>' : '>');
            }
          },
          end: function(tag) {
            tag = angular.lowercase(tag);
            if (!ignore && validElements[tag] === true) {
              out('</');
              out(tag);
              out('>');
            }
            if (tag == ignore) {
              ignore = false;
            }
          },
          chars: function(chars) {
            if (!ignore) {
              out(encodeEntities(chars));
            }
          }
        };
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/i,
            MAILTO_REGEXP = /^mailto:/i;
        return function(text, target) {
          if (!text)
            return text;
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            html.push('<a ');
            if (angular.isDefined(target)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular-ui/ui-router@0.2.15/angular-ui-router.js", ["github:angular/bower-angular@1.4.1.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')' + (optional ? "?" : "")];
              break;
            case true:
              surroundPattern = ['?(', ')?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/g, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          var param = this.params[paramName];
          var paramVal = m[i + 1];
          for (j = 0; j < param.replace; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$normalize = arrayHandler(bindTo(type, '$normalize'));
          this.name = type.name;
          this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                  return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
              },
              int: {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              bool: {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              date: {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            return config.type instanceof Type ? config.type : new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = injector.invoke(config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
              throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
            return defaultValue;
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var keys = this.$$keys(),
                i,
                param,
                rawVal,
                normalized,
                encoded;
            for (i = 0; i < keys.length; i++) {
              param = this[keys[i]];
              rawVal = paramValues[keys[i]];
              if ((rawVal === undefined || rawVal === null) && param.isOptional)
                break;
              normalized = param.type.$normalize(rawVal);
              if (!param.type.is(normalized))
                return false;
              encoded = param.type.encode(normalized);
              if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                return false;
            }
            return true;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
        function $get($location, $rootScope, $injector, $browser) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return;
              }
              if ($location.url() === location)
                return;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              var url = urlMatcher.format(params || {});
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              $location.url(url);
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = extend({}, state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "'' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload(state) {
            return $state.transitionTo($state.current, $stateParams, {
              reload: state || true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            var hash = toParams['#'];
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            } else if (isString(options.reload) || isObject(options.reload)) {
              if (isObject(options.reload) && !options.reload.name) {
                throw new Error('Invalid reload state object');
              }
              var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
              if (options.reload && !reloadState) {
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
              }
              while (state && state === fromPath[keep] && state !== reloadState) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
              if (hash)
                toParams['#'] = hash;
              $state.params = toParams;
              copy($state.params, $stateParams);
              if (options.location && to.navigable && to.navigable.url) {
                $urlRouter.push(to.navigable.url, toParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
                $urlRouter.update(true);
              }
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if (hash)
                toParams['#'] = hash;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            function resolveViews() {
              var viewsPromises = [];
              forEach(state.views, function(view, name) {
                var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                injectables.$template = [function() {
                  return $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify
                  }) || '';
                }];
                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                  if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                    var injectLocals = angular.extend({}, injectables, dst.globals);
                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  dst[name] = result;
                }));
              });
              return $q.all(viewsPromises).then(function() {
                return dst.globals;
              });
            }
            return $q.all(promises).then(resolveViews).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
          function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
            function notSearchParam(key) {
              return fromAndToState.params[key].location != "search";
            }
            var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
            var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
            var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
            return nonQueryParamSet.$$equals(fromParams, toParams);
          }
          if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              if (result && options.notify) {
                $rootScope.$broadcast('$viewContentLoading', options);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            return $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = function() {
            return {
              enter: function(element, target, cb) {
                target.after(element);
                cb();
              },
              leave: function(element, cb) {
                element.remove();
                cb();
              }
            };
          };
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                var promise = $animate.enter(element, null, target, cb);
                if (promise && promise.then)
                  promise.then(cb);
              },
              leave: function(element, cb) {
                var promise = $animate.leave(element, cb);
                if (promise && promise.then)
                  promise.then(cb);
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics();
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                if (previousEl) {
                  previousEl.remove();
                  previousEl = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    previousEl = null;
                  });
                  previousEl = currentEl;
                  currentEl = null;
                }
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals)
                  return;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded');
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                locals.$element = $element;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var params = null,
                url = null,
                base = stateContext(element) || $state.$current;
            var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
            var newHref = null,
                isAnchor = element.prop("tagName").toUpperCase() === "A";
            var isForm = element[0].nodeName === "FORM";
            var attr = isForm ? "action" : hrefKind,
                nav = true;
            var options = {
              relative: base,
              inherit: true
            };
            var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
            angular.forEach(allowedOptions, function(option) {
              if (option in optionsOverride) {
                options[option] = optionsOverride[option];
              }
            });
            var update = function(newVal) {
              if (newVal)
                params = angular.copy(newVal);
              if (!nav)
                return;
              newHref = $state.href(ref.state, params, options);
              var activeDirective = uiSrefActive[1] || uiSrefActive[0];
              if (activeDirective) {
                activeDirective.$$addStateInfo(ref.state, params);
              }
              if (newHref === null) {
                nav = false;
                return false;
              }
              attrs.$set(attr, newHref);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                if (newVal !== params)
                  update(newVal);
              }, true);
              params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (isForm)
              return;
            element.bind("click", function(e) {
              var button = e.which || e.button;
              if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                var transition = $timeout(function() {
                  $state.go(ref.state, params, options);
                });
                e.preventDefault();
                var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                e.preventDefault = function() {
                  if (ignorePreventDefaultCount-- <= 0)
                    $timeout.cancel(transition);
                };
              }
            });
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var states = [],
                activeClass;
            activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
            this.$$addStateInfo = function(newState, newParams) {
              var state = $state.get(newState, stateContext($element));
              states.push({
                state: state || {name: newState},
                params: newParams
              });
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function update() {
              if (anyMatch()) {
                $element.addClass(activeClass);
              } else {
                $element.removeClass(activeClass);
              }
            }
            function anyMatch() {
              for (var i = 0; i < states.length; i++) {
                if (isMatch(states[i].state, states[i].params)) {
                  return true;
                }
              }
              return false;
            }
            function isMatch(state, params) {
              if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
                return $state.is(state.name, params);
              } else {
                return $state.includes(state.name, params);
              }
            }
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state) {
          return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
          return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:emmett@3.0.1/emmett.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function() {
    'use strict';
    var __allowedOptions = {
      once: 'boolean',
      scope: 'object'
    };
    var __order = 0;
    function shallowMerge(o1, o2) {
      var o = {},
          k;
      for (k in o1)
        o[k] = o1[k];
      for (k in o2)
        o[k] = o2[k];
      return o;
    }
    function isPlainObject(v) {
      return v && typeof v === 'object' && !Array.isArray(v) && !(v instanceof Function) && !(v instanceof RegExp);
    }
    var Emitter = function() {
      this._enabled = true;
      this.unbindAll();
    };
    Emitter.prototype.unbindAll = function() {
      this._handlers = {};
      this._handlersAll = [];
      this._handlersComplex = [];
      return this;
    };
    Emitter.prototype.on = function(a, b, c) {
      var i,
          l,
          k,
          event,
          eArray,
          handlersList,
          bindingObject;
      if (isPlainObject(a)) {
        for (event in a)
          this.on(event, a[event], b);
        return this;
      }
      if (typeof a === 'function') {
        c = b;
        b = a;
        a = null;
      }
      eArray = [].concat(a);
      for (i = 0, l = eArray.length; i < l; i++) {
        event = eArray[i];
        bindingObject = {
          order: __order++,
          fn: b
        };
        if (typeof event === 'string') {
          if (!this._handlers[event])
            this._handlers[event] = [];
          handlersList = this._handlers[event];
          bindingObject.type = event;
        } else if (event instanceof RegExp) {
          handlersList = this._handlersComplex;
          bindingObject.pattern = event;
        } else if (event === null) {
          handlersList = this._handlersAll;
        } else {
          throw Error('Emitter.on: invalid event.');
        }
        for (k in c || {})
          if (__allowedOptions[k])
            bindingObject[k] = c[k];
        handlersList.push(bindingObject);
      }
      return this;
    };
    Emitter.prototype.once = function() {
      var args = Array.prototype.slice.call(arguments),
          li = args.length - 1;
      if (isPlainObject(args[li]) && args.length > 1)
        args[li] = shallowMerge(args[li], {once: true});
      else
        args.push({once: true});
      return this.on.apply(this, args);
    };
    function filter(target, fn) {
      target = target || [];
      var a = [],
          l,
          i;
      for (i = 0, l = target.length; i < l; i++)
        if (target[i].fn !== fn)
          a.push(target[i]);
      return a;
    }
    Emitter.prototype.off = function(events, fn) {
      var i,
          n,
          k,
          event;
      if (arguments.length === 1 && typeof events === 'function') {
        fn = arguments[0];
        for (k in this._handlers) {
          this._handlers[k] = filter(this._handlers[k], fn);
          if (this._handlers[k].length === 0)
            delete this._handlers[k];
        }
        this._handlersAll = filter(this._handlersAll, fn);
        this._handlersComplex = filter(this._handlersComplex, fn);
      } else if (arguments.length === 1 && typeof events === 'string') {
        delete this._handlers[events];
      } else if (arguments.length === 2) {
        var eArray = [].concat(events);
        for (i = 0, n = eArray.length; i < n; i++) {
          event = eArray[i];
          this._handlers[event] = filter(this._handlers[event], fn);
          if ((this._handlers[event] || []).length === 0)
            delete this._handlers[event];
        }
      } else if (isPlainObject(events)) {
        for (k in events)
          this.off(k, events[k]);
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      var handlers = this._handlersAll || [],
          complex = false,
          h,
          i,
          l;
      if (!event)
        throw Error('Emitter.listeners: no event provided.');
      handlers = handlers.concat(this._handlers[event] || []);
      for (i = 0, l = this._handlersComplex.length; i < l; i++) {
        h = this._handlersComplex[i];
        if (~event.search(h.pattern)) {
          complex = true;
          handlers.push(h);
        }
      }
      if (this._handlersAll.length || complex)
        return handlers.sort(function(a, b) {
          return a.order - b.order;
        });
      else
        return handlers.slice(0);
    };
    Emitter.prototype.emit = function(events, data) {
      if (!this._enabled)
        return this;
      if (isPlainObject(events)) {
        for (var k in events)
          this.emit(k, events[k]);
        return this;
      }
      var eArray = [].concat(events),
          onces = [],
          event,
          parent,
          handlers,
          handler,
          i,
          j,
          l,
          m;
      for (i = 0, l = eArray.length; i < l; i++) {
        handlers = this.listeners(eArray[i]);
        for (j = 0, m = handlers.length; j < m; j++) {
          handler = handlers[j];
          event = {
            type: eArray[i],
            target: this
          };
          if (arguments.length > 1)
            event.data = data;
          handler.fn.call('scope' in handler ? handler.scope : this, event);
          if (handler.once)
            onces.push(handler);
        }
        for (j = onces.length - 1; j >= 0; j--) {
          parent = onces[j].type ? this._handlers[onces[j].type] : onces[j].pattern ? this._handlersComplex : this._handlersAll;
          parent.splice(parent.indexOf(onces[j]), 1);
        }
      }
      return this;
    };
    Emitter.prototype.kill = function() {
      this.unbindAll();
      this._handlers = null;
      this._handlersAll = null;
      this._handlersComplex = null;
      this._enabled = false;
      this.unbindAll = this.on = this.once = this.off = this.emit = this.listeners = Function.prototype;
    };
    Emitter.prototype.disable = function() {
      this._enabled = false;
      return this;
    };
    Emitter.prototype.enable = function() {
      this._enabled = true;
      return this;
    };
    Emitter.version = '3.0.1';
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports)
        exports = module.exports = Emitter;
      exports.Emitter = Emitter;
    } else if (typeof define === 'function' && define.amd)
      define('emmett', [], function() {
        return Emitter;
      });
    else
      this.Emitter = Emitter;
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@1.1.1/src/facet.js", ["npm:emmett@3.0.1.js", "npm:baobab@1.1.1/src/cursor.js", "npm:baobab@1.1.1/src/helpers.js", "npm:baobab@1.1.1/src/type.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var EventEmitter = require("npm:emmett@3.0.1.js"),
      Cursor = require("npm:baobab@1.1.1/src/cursor.js"),
      helpers = require("npm:baobab@1.1.1/src/helpers.js"),
      type = require("npm:baobab@1.1.1/src/type.js");
  function Facet(tree, definition, args) {
    var self = this;
    var firstTime = true,
        solved = false,
        getter = definition.get,
        facetData = null;
    EventEmitter.call(this);
    this.killed = false;
    this.tree = tree;
    this.cursors = {};
    this.facets = {};
    var cursorsMapping = definition.cursors,
        facetsMapping = definition.facets,
        complexCursors = typeof definition.cursors === 'function',
        complexFacets = typeof definition.facets === 'function';
    function refresh(complexity, targetMapping, targetProperty, mappingType, refreshArgs) {
      if (!complexity && !firstTime)
        return;
      solved = false;
      var solvedMapping = targetMapping;
      if (complexity)
        solvedMapping = targetMapping.apply(this, refreshArgs);
      if (!mappingType(solvedMapping))
        throw Error('baobab.Facet: incorrect ' + targetProperty + ' mapping.');
      self[targetProperty] = {};
      Object.keys(solvedMapping).forEach(function(k) {
        if (targetProperty === 'cursors') {
          if (solvedMapping[k] instanceof Cursor) {
            self.cursors[k] = solvedMapping[k];
            return;
          }
          if (type.Path(solvedMapping[k])) {
            self.cursors[k] = tree.select(solvedMapping[k]);
            return;
          }
        } else {
          if (solvedMapping[k] instanceof Facet) {
            self.facets[k] = solvedMapping[k];
            return;
          }
          if (typeof solvedMapping[k] === 'string') {
            self.facets[k] = tree.facets[solvedMapping[k]];
            if (!self.facets[k])
              throw Error('baobab.Facet: unkown "' + solvedMapping[k] + '" facet in facets mapping.');
            return;
          }
        }
      });
    }
    this.refresh = function(refreshArgs) {
      refreshArgs = refreshArgs || [];
      if (!type.Array(refreshArgs))
        throw Error('baobab.Facet.refresh: first argument should be an array.');
      if (cursorsMapping)
        refresh(complexCursors, cursorsMapping, 'cursors', type.FacetCursors, refreshArgs);
      if (facetsMapping)
        refresh(complexFacets, facetsMapping, 'facets', type.FacetFacets, refreshArgs);
    };
    this.get = function() {
      if (solved)
        return facetData;
      var data = {},
          k;
      for (k in self.facets)
        data[k] = self.facets[k].get();
      for (k in self.cursors)
        data[k] = self.cursors[k].get();
      data = typeof getter === 'function' ? getter.call(self, data) : data;
      solved = true;
      facetData = data;
      return facetData;
    };
    function cursorsPaths(cursors) {
      return Object.keys(cursors).map(function(k) {
        return cursors[k].solvedPath;
      });
    }
    function facetsPaths(facets) {
      var paths = Object.keys(facets).map(function(k) {
        return cursorsPaths(facets[k].cursors);
      });
      return [].concat.apply([], paths);
    }
    this.updateHandler = function(e) {
      if (self.killed)
        return;
      var paths = cursorsPaths(self.cursors).concat(facetsPaths(self.facets));
      if (helpers.solveUpdate(e.data.log, paths)) {
        solved = false;
        self.emit('update');
      }
    };
    this.refresh(args);
    this.tree.on('update', this.updateHandler);
    firstTime = false;
  }
  helpers.inherits(Facet, EventEmitter);
  Facet.prototype.release = function() {
    this.tree.off('update', this.updateHandler);
    this.tree = null;
    this.cursors = null;
    this.facets = null;
    this.killed = true;
    this.kill();
  };
  module.exports = Facet;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@1.1.1/defaults.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    autoCommit: true,
    asynchronous: true,
    facets: {},
    immutable: false,
    validate: null,
    validationBehavior: 'rollback',
    syncwrite: false
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@1.1.1/src/update.js", ["npm:baobab@1.1.1/src/helpers.js", "npm:baobab@1.1.1/src/type.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var helpers = require("npm:baobab@1.1.1/src/helpers.js"),
      type = require("npm:baobab@1.1.1/src/type.js");
  function makeError(path, message) {
    var e = new Error('baobab.update: ' + message + ' at path /' + path.slice(1).join('/'));
    e.path = path;
    return e;
  }
  module.exports = function(data, spec, opts) {
    opts = opts || {};
    var log = {};
    data = {root: helpers.shallowClone(data)};
    var mutator = function(o, spec, path, parent) {
      path = path || ['root'];
      var hash = path.join('||'),
          lastKey = path[path.length - 1],
          oldValue = o[lastKey],
          fn,
          k,
          v,
          i,
          l;
      var leafLevel = Object.keys(spec).some(function(k) {
        return k.charAt(0) === '$';
      });
      if (leafLevel) {
        log[hash] = true;
        for (k in spec) {
          if (k === '$unset') {
            var olderKey = path[path.length - 2];
            if (!type.Object(parent[olderKey]))
              throw makeError(path.slice(0, -1), 'using command $unset on a non-object');
            parent[olderKey] = helpers.shallowClone(o);
            delete parent[olderKey][lastKey];
            if (opts.immutable)
              helpers.freeze(parent[olderKey]);
            break;
          }
          if (k === '$set') {
            v = spec.$set;
            o[lastKey] = v;
          } else if (k === '$apply' || k === '$chain') {
            fn = spec.$apply || spec.$chain;
            if (typeof fn !== 'function')
              throw makeError(path, 'using command $apply with a non function');
            o[lastKey] = fn.call(null, oldValue);
          } else if (k === '$merge') {
            v = spec.$merge;
            if (!type.Object(o[lastKey]) || !type.Object(v))
              throw makeError(path, 'using command $merge with a non object');
            o[lastKey] = helpers.shallowMerge(o[lastKey], v);
          }
          if (k === '$splice') {
            v = spec.$splice;
            if (!type.Array(o[lastKey]))
              throw makeError(path, 'using command $push to a non array');
            for (i = 0, l = v.length; i < l; i++)
              o[lastKey] = helpers.splice.apply(null, [o[lastKey]].concat(v[i]));
          }
          if (k === '$push') {
            v = spec.$push;
            if (!type.Array(o[lastKey]))
              throw makeError(path, 'using command $push to a non array');
            o[lastKey] = o[lastKey].concat(v);
          }
          if (k === '$unshift') {
            v = spec.$unshift;
            if (!type.Array(o[lastKey]))
              throw makeError(path, 'using command $unshift to a non array');
            o[lastKey] = [].concat(v).concat(o[lastKey]);
          }
          if (opts.immutable)
            helpers.deepFreeze(o);
        }
      } else {
        if (type.Primitive(o[lastKey]))
          o[lastKey] = {};
        else
          o[lastKey] = helpers.shallowClone(o[lastKey]);
        if (opts.immutable)
          helpers.freeze(o);
        for (k in spec) {
          mutator(o[lastKey], spec[k], path.concat(k), o);
        }
      }
    };
    mutator(data, spec);
    return {
      data: data.root,
      log: Object.keys(log).map(function(hash) {
        return hash.split('||').slice(1);
      })
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@1.1.1/src/merge.js", ["npm:baobab@1.1.1/src/helpers.js", "npm:baobab@1.1.1/src/type.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var helpers = require("npm:baobab@1.1.1/src/helpers.js"),
      type = require("npm:baobab@1.1.1/src/type.js");
  var COMMANDS = ['$unset', '$set', '$apply'];
  function only(command, commandValue) {
    var o = {};
    o[command] = commandValue;
    return o;
  }
  function merge(a, b) {
    var o = helpers.shallowClone(a || {}),
        leafLevel = false,
        k,
        i;
    COMMANDS.forEach(function(c) {
      if (c in b) {
        o = only(c, b[c]);
        leafLevel = true;
      }
    });
    if (b.$chain) {
      if (o.$apply)
        o.$apply = helpers.compose(o.$apply, b.$chain);
      else
        o.$apply = b.$chain;
      o = only('$apply', o.$apply);
      leafLevel = true;
    }
    if (b.$merge) {
      o.$merge = helpers.shallowMerge(o.$merge || {}, b.$merge);
      leafLevel = true;
    }
    if (b.$splice || b.$splice) {
      o.$splice = [].concat(o.$splice || []).concat(b.$splice || []);
      leafLevel = true;
    }
    if (b.$push || o.$push) {
      o.$push = [].concat(o.$push || []).concat(b.$push || []);
      leafLevel = true;
    }
    if (b.$unshift || o.$unshift) {
      o.$unshift = [].concat(b.$unshift || []).concat(o.$unshift || []);
      leafLevel = true;
    }
    if (leafLevel)
      return o;
    for (k in o) {
      if (k.charAt(0) === '$')
        delete o[k];
    }
    for (k in b) {
      if (type.Object(b[k]))
        o[k] = merge(o[k], b[k]);
    }
    return o;
  }
  module.exports = merge;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/b64encode.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var base64EncodeOutputStream = function() {
    var _buffer = 0;
    var _buflen = 0;
    var _length = 0;
    var _base64 = '';
    var _this = {};
    var writeEncoded = function(b) {
      _base64 += String.fromCharCode(encode(b & 0x3f));
    };
    var encode = function(n) {
      if (n < 0) {} else if (n < 26) {
        return 0x41 + n;
      } else if (n < 52) {
        return 0x61 + (n - 26);
      } else if (n < 62) {
        return 0x30 + (n - 52);
      } else if (n == 62) {
        return 0x2b;
      } else if (n == 63) {
        return 0x2f;
      }
      throw new Error('n:' + n);
    };
    _this.writeByte = function(n) {
      _buffer = (_buffer << 8) | (n & 0xff);
      _buflen += 8;
      _length += 1;
      while (_buflen >= 6) {
        writeEncoded(_buffer >>> (_buflen - 6));
        _buflen -= 6;
      }
    };
    _this.flush = function() {
      if (_buflen > 0) {
        writeEncoded(_buffer << (6 - _buflen));
        _buffer = 0;
        _buflen = 0;
      }
      if (_length % 3 != 0) {
        var padlen = 3 - _length % 3;
        for (var i = 0; i < padlen; i += 1) {
          _base64 += '=';
        }
      }
    };
    _this.toString = function() {
      return _base64;
    };
    return _this;
  };
  module.exports = base64EncodeOutputStream;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/byte-array.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var byteArrayOutputStream = function() {
    var _bytes = new Array();
    var _this = {};
    _this.writeByte = function(b) {
      _bytes.push(b & 0xff);
    };
    _this.writeShort = function(i) {
      _this.writeByte(i);
      _this.writeByte(i >>> 8);
    };
    _this.writeBytes = function(b, off, len) {
      off = off || 0;
      len = len || b.length;
      for (var i = 0; i < len; i += 1) {
        _this.writeByte(b[i + off]);
      }
    };
    _this.writeString = function(s) {
      for (var i = 0; i < s.length; i += 1) {
        _this.writeByte(s.charCodeAt(i));
      }
    };
    _this.toByteArray = function() {
      return _bytes;
    };
    return _this;
  };
  module.exports = byteArrayOutputStream;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/math.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var QRMath = function() {
    var EXP_TABLE = new Array(256);
    var LOG_TABLE = new Array(256);
    for (var i = 0; i < 8; i += 1) {
      EXP_TABLE[i] = 1 << i;
    }
    for (var i = 8; i < 256; i += 1) {
      EXP_TABLE[i] = EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^ EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8];
    }
    for (var i = 0; i < 255; i += 1) {
      LOG_TABLE[EXP_TABLE[i]] = i;
    }
    var _this = {};
    _this.glog = function(n) {
      if (n < 1) {
        throw new Error('glog(' + n + ')');
      }
      return LOG_TABLE[n];
    };
    _this.gexp = function(n) {
      while (n < 0) {
        n += 255;
      }
      while (n >= 256) {
        n -= 255;
      }
      return EXP_TABLE[n];
    };
    return _this;
  }();
  module.exports = QRMath;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/polynomial.js", ["npm:qr-encode@0.3.0/lib/math.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var QRMath = require("npm:qr-encode@0.3.0/lib/math.js");
  function qrPolynomial(num, shift) {
    if (typeof num.length == 'undefined') {
      throw new Error(num.length + '/' + shift);
    }
    var _num = function() {
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset += 1;
      }
      var _num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i += 1) {
        _num[i] = num[i + offset];
      }
      return _num;
    }();
    var _this = {};
    _this.getAt = function(index) {
      return _num[index];
    };
    _this.getLength = function() {
      return _num.length;
    };
    _this.multiply = function(e) {
      var num = new Array(_this.getLength() + e.getLength() - 1);
      for (var i = 0; i < _this.getLength(); i += 1) {
        for (var j = 0; j < e.getLength(); j += 1) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i)) + QRMath.glog(e.getAt(j)));
        }
      }
      return qrPolynomial(num, 0);
    };
    _this.mod = function(e) {
      if (_this.getLength() - e.getLength() < 0) {
        return _this;
      }
      var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e.getAt(0));
      var num = new Array(_this.getLength());
      for (var i = 0; i < _this.getLength(); i += 1) {
        num[i] = _this.getAt(i);
      }
      for (var i = 0; i < e.getLength(); i += 1) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i)) + ratio);
      }
      return qrPolynomial(num, 0).mod(e);
    };
    return _this;
  }
  module.exports = qrPolynomial;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/constants.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var QRMode = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3
  };
  var QRErrorCorrectLevel = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  };
  var QRMaskPattern = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  module.exports = {
    QRMode: QRMode,
    QRErrorCorrectLevel: QRErrorCorrectLevel,
    QRMaskPattern: QRMaskPattern
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/bit-buffer.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var qrBitBuffer = function() {
    var _buffer = new Array();
    var _length = 0;
    var _this = {};
    _this.getBuffer = function() {
      return _buffer;
    };
    _this.getAt = function(index) {
      var bufIndex = Math.floor(index / 8);
      return ((_buffer[bufIndex] >>> (7 - index % 8)) & 1) == 1;
    };
    _this.put = function(num, length) {
      for (var i = 0; i < length; i += 1) {
        _this.putBit(((num >>> (length - i - 1)) & 1) == 1);
      }
    };
    _this.getLengthInBits = function() {
      return _length;
    };
    _this.putBit = function(bit) {
      var bufIndex = Math.floor(_length / 8);
      if (_buffer.length <= bufIndex) {
        _buffer.push(0);
      }
      if (bit) {
        _buffer[bufIndex] |= (0x80 >>> (_length % 8));
      }
      _length += 1;
    };
    return _this;
  };
  module.exports = qrBitBuffer;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/string.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var stringToBytes = function(s) {
    var bytes = new Array();
    for (var i = 0; i < s.length; i += 1) {
      var c = s.charCodeAt(i);
      bytes.push(c & 0xff);
    }
    return bytes;
  };
  module.exports = {stringToBytes: stringToBytes};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/bit-byte.js", ["npm:qr-encode@0.3.0/lib/constants.js", "npm:qr-encode@0.3.0/lib/string.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var QRMode = require("npm:qr-encode@0.3.0/lib/constants.js").QRMode;
  var string = require("npm:qr-encode@0.3.0/lib/string.js");
  var qr8BitByte = function(data) {
    var _mode = QRMode.MODE_8BIT_BYTE;
    var _data = data;
    var _bytes = string.stringToBytes(data);
    var _this = {};
    _this.getMode = function() {
      return _mode;
    };
    _this.getLength = function(buffer) {
      return _bytes.length;
    };
    _this.write = function(buffer) {
      for (var i = 0; i < _bytes.length; i += 1) {
        buffer.put(_bytes[i], 8);
      }
    };
    return _this;
  };
  module.exports = qr8BitByte;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/rsblock.js", ["npm:qr-encode@0.3.0/lib/constants.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var constants = require("npm:qr-encode@0.3.0/lib/constants.js");
  var QRMode = constants.QRMode;
  var QRErrorCorrectLevel = constants.QRErrorCorrectLevel;
  var QRMaskPattern = constants.QRMaskPattern;
  var QRRSBlock = function() {
    var RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
    var qrRSBlock = function(totalCount, dataCount) {
      var _this = {};
      _this.totalCount = totalCount;
      _this.dataCount = dataCount;
      return _this;
    };
    var _this = {};
    var getRsBlockTable = function(typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case QRErrorCorrectLevel.L:
          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case QRErrorCorrectLevel.M:
          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case QRErrorCorrectLevel.Q:
          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case QRErrorCorrectLevel.H:
          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
          return undefined;
      }
    };
    _this.getRSBlocks = function(typeNumber, errorCorrectLevel) {
      var rsBlock = getRsBlockTable(typeNumber, errorCorrectLevel);
      if (typeof rsBlock == 'undefined') {
        throw new Error('bad rs block @ typeNumber:' + typeNumber + '/errorCorrectLevel:' + errorCorrectLevel);
      }
      var length = rsBlock.length / 3;
      var list = new Array();
      for (var i = 0; i < length; i += 1) {
        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];
        for (var j = 0; j < count; j += 1) {
          list.push(qrRSBlock(totalCount, dataCount));
        }
      }
      return list;
    };
    return _this;
  }();
  module.exports = QRRSBlock;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/gif.js", ["npm:qr-encode@0.3.0/lib/byte-array.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var byteArrayOutputStream = require("npm:qr-encode@0.3.0/lib/byte-array.js");
  var gifImage = function(width, height) {
    var _width = width;
    var _height = height;
    var _data = new Array(width * height);
    var _this = {};
    _this.setPixel = function(x, y, pixel) {
      _data[y * _width + x] = pixel;
    };
    _this.write = function(out) {
      out.writeString('GIF87a');
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0x80);
      out.writeByte(0);
      out.writeByte(0);
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeString(',');
      out.writeShort(0);
      out.writeShort(0);
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0);
      var lzwMinCodeSize = 2;
      var raster = getLZWRaster(lzwMinCodeSize);
      out.writeByte(lzwMinCodeSize);
      var offset = 0;
      while (raster.length - offset > 255) {
        out.writeByte(255);
        out.writeBytes(raster, offset, 255);
        offset += 255;
      }
      out.writeByte(raster.length - offset);
      out.writeBytes(raster, offset, raster.length - offset);
      out.writeByte(0x00);
      out.writeString(';');
    };
    var bitOutputStream = function(out) {
      var _out = out;
      var _bitLength = 0;
      var _bitBuffer = 0;
      var _this = {};
      _this.write = function(data, length) {
        if ((data >>> length) != 0) {
          throw new Error('length over');
        }
        while (_bitLength + length >= 8) {
          _out.writeByte(0xff & ((data << _bitLength) | _bitBuffer));
          length -= (8 - _bitLength);
          data >>>= (8 - _bitLength);
          _bitBuffer = 0;
          _bitLength = 0;
        }
        _bitBuffer = (data << _bitLength) | _bitBuffer;
        _bitLength = _bitLength + length;
      };
      _this.flush = function() {
        if (_bitLength > 0) {
          _out.writeByte(_bitBuffer);
        }
      };
      return _this;
    };
    var getLZWRaster = function(lzwMinCodeSize) {
      var clearCode = 1 << lzwMinCodeSize;
      var endCode = (1 << lzwMinCodeSize) + 1;
      var bitLength = lzwMinCodeSize + 1;
      var table = lzwTable();
      for (var i = 0; i < clearCode; i += 1) {
        table.add(String.fromCharCode(i));
      }
      table.add(String.fromCharCode(clearCode));
      table.add(String.fromCharCode(endCode));
      var byteOut = byteArrayOutputStream();
      var bitOut = bitOutputStream(byteOut);
      bitOut.write(clearCode, bitLength);
      var dataIndex = 0;
      var s = String.fromCharCode(_data[dataIndex]);
      dataIndex += 1;
      while (dataIndex < _data.length) {
        var c = String.fromCharCode(_data[dataIndex]);
        dataIndex += 1;
        if (table.contains(s + c)) {
          s = s + c;
        } else {
          bitOut.write(table.indexOf(s), bitLength);
          if (table.size() < 0xfff) {
            if (table.size() == (1 << bitLength)) {
              bitLength += 1;
            }
            table.add(s + c);
          }
          s = c;
        }
      }
      bitOut.write(table.indexOf(s), bitLength);
      bitOut.write(endCode, bitLength);
      bitOut.flush();
      return byteOut.toByteArray();
    };
    var lzwTable = function() {
      var _map = {};
      var _size = 0;
      var _this = {};
      _this.add = function(key) {
        if (_this.contains(key)) {
          throw new Error('dup key:' + key);
        }
        _map[key] = _size;
        _size += 1;
      };
      _this.size = function() {
        return _size;
      };
      _this.indexOf = function(key) {
        return _map[key];
      };
      _this.contains = function(key) {
        return typeof _map[key] != 'undefined';
      };
      return _this;
    };
    return _this;
  };
  module.exports = gifImage;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("views/channel/channel.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"{{channelView.title}}\">\n  <ion-nav-bar class=\"bar-positive\">\n    <toc-header></toc-header>\n  </ion-nav-bar>\n  <div class=\"bar bar-subheader item-input-inset\">\n    <div class=\"row\">\n      <div class=\"col-10\" ng-class=\"{\n        'dark-bg': channelView.contact.statusId === 0,\n        'balanced-bg': channelView.contact.statusId === 1,\n        'stable-bg': channelView.contact.statusId === undefined\n      }\"></div>\n      <label class=\"col-60 item-input-wrapper\">\n        <i class=\"icon ion-email placeholder-icon\"></i>\n        <input type=\"text\" placeholder=\"Email\"\n          value=\"{{channelView.contact.userInfo.email}}\" readonly>\n      </label>\n      <label class=\"col-30 item-input-wrapper\">\n        <i class=\"icon ion-android-person placeholder-icon\"></i>\n        <input type=\"text\" placeholder=\"ID\"\n          value=\"{{channelView.contact.userInfo.id}}\" readonly>\n      </label>\n    </div>\n  </div>\n\n  <ion-content class=\"has-subheader has-footer\">\n    <toc-message-list channel-id=\"{{channelView.channelId}}\">\n    </toc-message-list>\n  </ion-content>\n  <!-- TODO: refactor into separate component -->\n  <form name=\"toc-message-input-form\">\n    <div class=\"bar bar-footer bar-calm item-input-inset\">\n      <label class=\"item-input-wrapper\">\n        <input type=\"text\" placeholder=\"Message\"\n          ng-model=\"channelView.message\" toc-auto-focus>\n      </label>\n      <button type=\"submit\" class=\"button button-clear\"\n        ng-click=\"channelView.send()\" toc-spinner-button\n        loading-promise=\"channelView.sending\">\n        <i class=\"icon ion-paper-airplane\"></i>\n        <!-- FIXME: memory leak in ion-spinner.\n          see https://github.com/driftyco/ionic/issues/3583 -->\n        <!-- <ion-spinner icon=\"ripple\" class=\"spinner-light toc-send-spinner\">\n        </ion-spinner> -->\n      </button>\n    </div>\n  </form>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("views/home/home.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"{{homeView.currentUser.userInfo.displayName}}\">\n  <ion-nav-bar class=\"bar-positive\">\n    <toc-header></toc-header>\n  </ion-nav-bar>\n  <ion-content has-header=\"true\">\n    <div class=\"toc-flex-container\">\n      <div class=\"toc-flex-content\">\n        <div class=\"list\">\n          <!-- <div class=\"row balanced-bg\"></div>\n          <div class=\"item item-avatar\">\n            <img ng-src=\"http://cdn.libravatar.org/avatar/{{homeView.currentUser.userInfo.id | limitTo:32}}?d=identicon\" alt=\"Avatar for {{homeView.currentUser.userInfo.email}}\" />\n            <h2>{{homeView.currentUser.userInfo.displayName}}</h2>\n            <p>{{homeView.currentUser.userInfo.id}}</p>\n          </div> -->\n          <label class=\"item item-input item-stacked-label\">\n            <span class=\"input-label\">User ID</span>\n            <input type=\"text\" placeholder=\"ID\"\n              value=\"{{homeView.currentUser.userInfo.id}}\" readonly>\n          </label>\n          <div class=\"item item-image toc-qr-image-container\">\n            <toc-qr-image data=\"{{homeView.currentUser.userInfo.id}}\">\n            </toc-qr-image>\n          </div>\n        </div>\n      </div>\n      <div class=\"toc-flex-footer\">\n        <div class=\"row\" ng-if=\"!homeView.isStorageConnected()\">\n          <div class=\"col\">\n            <button ui-sref=\"app.cloud\" class=\"button button-block button-outline button-royal\">\n              Connect a cloud account\n            </button>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"col\">\n            <button class=\"button button-block button-outline button-assertive\"\n              ng-click=\"homeView.showSignoutConfirm()\">\n              Sign out\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  </ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("views/welcome/welcome.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"Toc Messenger\">\n  <ion-content>\n    <div class=\"toc-flex-container\">\n      <div class=\"toc-flex-content\">\n\n      </div>\n      <div class=\"toc-flex-footer\">\n        <div class=\"row\" ng-if=\"!welcomeView.isStorageConnected()\">\n          <div class=\"col\">\n            <button ui-sref=\"app.cloud\" class=\"button button-block button-outline button-royal\">\n              Connect a cloud account\n            </button>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"col\">\n            <button ui-sref=\"app.signup\"\n              class=\"button button-block button-outline button-calm\">\n              Create account\n            </button>\n          </div>\n          <div class=\"col\" ng-if=\"welcomeView.users\">\n            <button ui-sref=\"app.signin\"\n              class=\"button button-block button-outline button-calm\">\n              Sign in\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  </ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("views/signin/signin.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"Sign In\">\n  <ion-content>\n    <toc-signin-form></toc-signin-form>\n  </ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("views/signup/signup.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"Create Account\">\n  <ion-header-bar class=\"bar-positive\"></ion-header-bar>\n  <ion-content has-header=\"true\">\n    <toc-signup-form></toc-signup-form>\n  </ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("views/cloud/cloud.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"Cloud Accounts\">\n  <ion-content>\n    <toc-cloud-connect-form ng-hide=\"cloudView.isConnected()\">\n    </toc-cloud-connect-form>\n    <toc-cloud-manage-form ng-show=\"cloudView.isConnected()\">\n    </toc-cloud-manage-form>\n  </ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("components/header/header.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-nav-back-button class=\"button-clear\">\n  <!-- <i class=\"icon ion-ios-arrow-back\"></i> Back -->\n</ion-nav-back-button>\n<ion-nav-buttons side=\"left\">\n  <button class=\"button button-icon button-clear ion-navicon\"\n    menu-toggle=\"left\" ng-show=\"header.isPrivateState()\">\n  </button>\n</ion-nav-buttons>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("components/channel-list/channel-list.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-list>\n  <div class=\"item item-divider item-calm\">\n    You\n  </div>\n  <div ng-click=\"this.channelId !== 'home' ?\n    channelList.goToHome() : undefined\" menu-close>\n    <div class=\"row balanced-bg\"></div>\n    <ion-item class=\"item item-avatar\">\n      <img ng-src=\"http://cdn.libravatar.org/avatar/{{channelList.userInfo.id | limitTo:32}}?d=identicon\" alt=\"Avatar for {{channelList.userInfo.email}}\" />\n      <h2>{{channelList.userInfo.displayName}}</h2>\n      <p>{{channelList.userInfo.id}}</p>\n    </ion-item>\n  </div>\n\n  <div class=\"item item-divider item-royal\">\n    Groups\n  </div>\n  <form name=\"toc-group-create-form\">\n    <div class=\"item item-input-inset\">\n      <label class=\"item-input-wrapper\">\n        <input type=\"text\" placeholder=\"Group Name\">\n      </label>\n      <button type=\"submit\" class=\"button button-clear button-balanced\"\n        disabled>\n        <i class=\"icon ion-plus\"></i>\n        <!-- <ion-spinner icon=\"ripple\" class=\"spinner-balanced\"></ion-spinner> -->\n      </button>\n    </div>\n  </form>\n\n  <div class=\"item item-divider item-balanced\">\n    Contacts\n  </div>\n  <form name=\"toc-contact-invite-form\">\n    <div class=\"item item-input-inset\">\n      <label class=\"item-input-wrapper\">\n        <input type=\"text\" placeholder=\"Contact ID\"\n          ng-model=\"channelList.inviteId\">\n      </label>\n      <button type=\"submit\" class=\"button button-clear button-balanced\"\n        ng-click=\"channelList.invite()\" toc-spinner-button\n        loading-promise=\"channelList.inviting\">\n        <i class=\"icon ion-plus\"></i>\n        <!-- <ion-spinner icon=\"ripple\" class=\"spinner-balanced\"></ion-spinner> -->\n      </button>\n    </div>\n  </form>\n  <!-- FIXME: use ui-sref here for nav-clear to work-->\n  <div ng-repeat=\"(id, channel) in channelList.channels track by id\"\n    ng-click=\"channelList.channelId !== id ?\n      channelList.goToChannel(id) : undefined\" nav-clear menu-close>\n    <div class=\"row\" ng-class=\"{\n      'dark-bg':\n        channelList.contacts[channel.channelInfo.contactIds[0]].statusId === 0,\n      'balanced-bg':\n        channelList.contacts[channel.channelInfo.contactIds[0]].statusId === 1,\n      'stable-bg':\n        channelList.contacts[channel.channelInfo.contactIds[0]].statusId === undefined\n      }\"></div>\n    <ion-item class=\"item item-avatar\"\n      ng-class=\"{'item-button-right': channel.channelInfo.pendingAccept}\">\n      <img ng-src=\"http://cdn.libravatar.org/avatar/{{channelList.contacts[channel.channelInfo.contactIds[0]].userInfo.id | limitTo:32}}?d=identicon\" alt=\"Avatar for {{channelList.contacts[channel.channelInfo.contactIds[0]].userInfo.email}}\" />\n      <h2>{{channelList.contacts[channel.channelInfo.contactIds[0]].userInfo.displayName}}</h2>\n      <p>{{channelList.contacts[channel.channelInfo.contactIds[0]].userInfo.id}}</p>\n      <div class=\"buttons\" ng-if=\"channel.channelInfo.pendingAccept\">\n        <!-- FIXME: spinner not showing here -->\n        <button class=\"button button-balanced button-clear\"\n          ng-click=\"channelList.acceptInvite(channel.channelInfo);\n            $event.stopPropagation()\" toc-spinner-button\n            loading-promise=\"channelList.invitesAccepting[id]\">\n          <i class=\"icon ion-checkmark\"></i>\n          <!-- <ion-spinner icon=\"ripple\" class=\"spinner-balanced\"></ion-spinner> -->\n        </button>\n        <button class=\"button button-assertive button-clear\">\n          <i class=\"icon ion-close\"></i>\n        </button>\n      </div>\n    </ion-item>\n  </div>\n</ion-list>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("components/message-list/message-list.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"list\">\n  <div ng-repeat=\"messageGroup in messageList.groupedMessages\n    track by messageGroup[0].id\">\n    <div class=\"row\" ng-class=\"{\n      'balanced-bg': messageGroup[0].sender !== messageList.userInfo.id,\n      'calm-bg': messageGroup[0].sender === messageList.userInfo.id\n    }\"></div>\n    <div class=\"item item-avatar\">\n      <img ng-src=\"http://cdn.libravatar.org/avatar/{{\n        messageGroup[0].sender === messageList.userInfo.id ?\n        messageList.userInfo.id :\n        messageList.contacts[messageGroup[0].sender].userInfo.id | limitTo:32\n      }}?d=identicon\" alt=\"Avatar for  {{\n        messageGroup[0].sender === messageList.userInfo.id ?\n        messageList.userInfo.email :\n        messageList.contacts[messageGroup[0].sender].userInfo.email\n      }}\" />\n      <h2>{{\n        messageGroup[0].sender === messageList.userInfo.id ?\n        'You' :\n        messageList.contacts[messageGroup[0].sender].userInfo.displayName\n      }}</h2>\n      <div class=\"row toc-message\" ng-repeat=\"message in messageGroup track by message.id\"\n        ng-class=\"{'toc-unread-message': !message.isRead}\">\n        <p class=\"col toc-message-content\">\n          {{message.content}}\n        </p>\n        <p class=\"col col-20 toc-message-timestamp\">\n          {{\n            message.sender === messageList.userInfo.id ?\n            message.sentTime : message.receivedTime |\n            date : 'shortTime'\n          }}\n        </p>\n      </div>\n    </div>\n  </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("components/signup-form/signup-form.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<form name=\"toc-signup-form\" class=\"toc-flex-container\"\n  ng-submit=\"signupForm.createUser(signupForm.newUser)\">\n  <div class=\"toc-flex-content\">\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm\">\n        Welcome{{signupForm.newUser.displayName ?\n          ' ' + signupForm.newUser.displayName : ''}}!\n      </div>\n      <label class=\"item item-avatar\">\n        <!-- TODO: create directive for libravatar icon -->\n        <img ng-src=\"http://cdn.libravatar.org/avatar/2012345b479e2123456ec07710c08d50?d=identicon\" alt=\"New User 1\" />\n        <h2>{{signupForm.newUser.displayName || 'Anonymous'}}</h2>\n        <p>Your contact card.</p>\n      </label>\n      <label class=\"item item-input item-stacked-label\">\n        <span class=\"input-label\">Display Name</span>\n        <input type=\"text\" placeholder=\"A friendly name to know you by.\"\n          ng-model=\"signupForm.newUser.displayName\" toc-auto-focus>\n      </label>\n      <label class=\"item item-input item-stacked-label\">\n        <span class=\"input-label\">Contact Email</span>\n        <input type=\"text\" placeholder=\"Another way to reach you.\"\n          ng-model=\"signupForm.newUser.email\">\n      </label>\n      <label class=\"item item-input item-stacked-label\">\n        <span class=\"input-label\">Password</span>\n        <input type=\"password\" placeholder=\"The only key to your data.\"\n          ng-model=\"signupForm.newUser.password\">\n      </label>\n      <label class=\"item item-input item-stacked-label\">\n        <span class=\"input-label\">Password Confirmation</span>\n        <input type=\"password\" placeholder=\"Have you typed it correctly?\"\n          ng-model=\"signupForm.newUser.passwordConfirmation\">\n      </label>\n      <ion-toggle ng-model=\"signupForm.staySignedIn\"\n        toggle-class=\"toggle-assertive\">\n        Stay signed in?\n      </ion-toggle>\n    </div>\n  </div>\n\n  <div class=\"toc-flex-footer\">\n    <div class=\"row\">\n      <div class=\"col\">\n        <button type=\"button\" ng-click=\"signupForm.goBack()\"\n          class=\"button button-block button-outline button-calm\">\n          Back\n        </button>\n      </div>\n      <div class=\"col\">\n        <button type=\"submit\"\n          class=\"button button-block button-outline button-balanced\"\n          toc-spinner-button loading-promise=\"signupForm.signingUp\">\n          <!-- <ion-spinner icon=\"ripple\" class=\"spinner-light\"></ion-spinner> -->\n          Create account\n        </button>\n      </div>\n    </div>\n  </div>\n</form>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("components/signin-form/signin-form.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<form name=\"toc-signin-form\" class=\"toc-flex-container\"\n  ng-submit=\"signinForm.signIn({\n    id: signinForm.model.selectedUser,\n    password: signinForm.model.password\n  })\">\n  <div class=\"toc-flex-content\">\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm item-clear\">\n        Welcome back {{signinForm.model.users[signinForm.model.selectedUser].userInfo.displayName}}!\n      </div>\n      <label class=\"item item-avatar\">\n        <img ng-src=\"http://cdn.libravatar.org/avatar/{{signinForm.model.users[signinForm.model.selectedUser].userInfo.id | limitTo:32}}?d=identicon\"\n          alt=\"Avatar for {{signinForm.model.users[signinForm.model.selectedUser].userInfo.email}}\" />\n        <h2>{{signinForm.model.users[signinForm.model.selectedUser].userInfo.displayName}}</h2>\n        <p>{{signinForm.model.users[signinForm.model.selectedUser].userInfo.id}}</p>\n      </label>\n      <label class=\"item item-input item-stacked-label\">\n        <span class=\"input-label\">Password</span>\n        <input type=\"password\" placeholder=\"To unlock your data.\"\n          ng-model=\"signinForm.model.password\" toc-auto-focus>\n      </label>\n      <ion-toggle ng-model=\"signinForm.model.staySignedIn\"\n        toggle-class=\"toggle-assertive\">\n        Stay signed in?\n      </ion-toggle>\n    </div>\n  </div>\n\n  <div class=\"toc-flex-footer\">\n    <div class=\"row\">\n      <div class=\"col\">\n        <button type=\"button\"\n          class=\"button button-block button-outline button-royal\"\n          ng-click=\"signinForm.userListModal.show()\">\n          Not you?\n        </button>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col\">\n        <button type=\"button\" ng-click=\"signinForm.goBack()\"\n          class=\"button button-block button-outline button-calm\">\n          Back\n        </button>\n      </div>\n      <div class=\"col\">\n        <button type=\"submit\"\n          class=\"button button-block button-outline button-balanced\"\n          toc-spinner-button loading-promise=\"signinForm.signingIn\">\n          <!-- <ion-spinner icon=\"ripple\" class=\"spinner-light\"></ion-spinner> -->\n          Sign in\n        </button>\n      </div>\n    </div>\n  </div>\n</form>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("components/signin-form/signin-form-user-list.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-royal\">\n    <h1 class=\"title\">Choose an account</h1>\n  </ion-header-bar>\n  <ion-content>\n    <div class=\"toc-flex-container\">\n      <div class=\"toc-flex-content\">\n        <ion-scroll>\n          <div class=\"list\">\n            <ion-radio class=\"item item-avatar\"\n              ng-repeat=\"user in model.userList track by user.userInfo.id\"\n              ng-model=\"model.selectedUser\" ng-value=\"'{{user.userInfo.id}}'\"\n              ng-click=\"userListModal.hide()\"\n              icon=\"ion-checkmark\">\n              <img ng-src=\"http://cdn.libravatar.org/avatar/{{user.userInfo.id | limitTo:32}}?d=identicon\" alt=\"Avatar for {{user.userInfo.email}}\" />\n              <h2>{{user.userInfo.displayName}}</h2>\n              <p>{{user.userInfo.id}}</p>\n            </ion-radio>\n          </div>\n        </ion-scroll>\n      </div>\n      <div class=\"toc-flex-footer\">\n        <div class=\"row\">\n          <div class=\"col\">\n            <button class=\"button button-block button-outline button-calm\"\n              ng-click=\"userListModal.hide()\">\n              Cancel\n            </button>\n          </div>\n          <div class=\"col\">\n            <button class=\"button button-block button-outline button-balanced\"\n              ng-click=\"userListModal.hide()\">\n              Select\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  </ion-content>\n</ion-modal-view>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("components/cloud-connect-form/cloud-connect-form.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"toc-flex-container\">\n  <ion-scroll class=\"toc-flex-content\">\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm item-clear\">\n        Select a cloud storage service\n      </div>\n      <ion-radio class=\"item item-avatar toc-square-avatar\"\n        ng-repeat=\"service in cloudConnectForm.serviceList track by service.id\"\n        ng-model=\"cloudConnectForm.selectedService\" ng-value=\"'{{service.id}}'\"\n        icon=\"ion-checkmark\">\n        <img ng-src=\"assets/images/{{service.img}}\"\n          alt=\"Avatar for {{service.name}}\" />\n        <h2>{{service.name}}</h2>\n        <p>{{service.description}}</p>\n      </ion-radio>\n      <!-- <label class=\"item item-input item-stacked-label\">\n        <span class=\"input-label\">Email</span>\n        <input type=\"password\" placeholder=\"Your remoteStorage.io email.\"\n          ng-model=\"cloudConnectForm.email\" toc-auto-focus>\n      </label> -->\n    </div>\n  </ion-scroll>\n  <div class=\"toc-flex-footer\">\n    <div class=\"row\">\n      <div class=\"col\">\n        <button class=\"button button-block button-outline button-calm\"\n          ng-click=\"cloudConnectForm.goBack()\">\n          Back\n        </button>\n      </div>\n      <div class=\"col\">\n        <button class=\"button button-block button-outline button-balanced\"\n          ng-click=\"cloudConnectForm.services[cloudConnectForm.selectedService].connect()\">\n          Connect\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("components/cloud-manage-form/cloud-manage-form.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"toc-flex-container\">\n  <ion-scroll class=\"toc-flex-content\">\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm item-clear\">\n        Cloud accounts\n      </div>\n      <ion-radio class=\"item item-avatar\"\n        ng-repeat=\"user in model.userList track by user.userInfo.id\"\n        ng-model=\"model.selectedUser\" ng-value=\"'{{user.userInfo.id}}'\"\n        ng-click=\"userListModal.hide()\"\n        icon=\"ion-checkmark\">\n        <img ng-src=\"http://cdn.libravatar.org/avatar/{{user.userInfo.id | limitTo:32}}?d=identicon\" alt=\"Avatar for {{user.userInfo.email}}\" />\n        <h2>{{user.userInfo.displayName}}</h2>\n        <p>{{user.userInfo.id}}</p>\n      </ion-radio>\n    </div>\n  </ion-scroll>\n  <div class=\"toc-flex-footer\">\n    <div class=\"row\">\n      <div class=\"col\">\n        <button ui-sref=\"app.signup\" class=\"button button-block button-outline button-calm\">\n          Create an account\n        </button>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col\">\n        <button class=\"button button-block button-outline button-assertive\"\n          ng-click=\"userListModal.hide()\">\n          Cancel\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("app.html!github:systemjs/plugin-text@0.0.2.js", [], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-side-menus enable-menu-with-back-views=\"false\" ng-controller=\"AppController as appView\">\n  <ion-side-menu-content>\n    <ion-nav-bar class=\"bar-positive\">\n      <toc-header></toc-header>\n    </ion-nav-bar>\n    <ion-nav-view></ion-nav-view>\n  </ion-side-menu-content>\n  <ion-side-menu side=\"left\" expose-aside-when=\"appView.isPrivateState() ? 'large' : false\"\n    is-enabled=\"appView.isPrivateState()\">\n    <ion-header-bar class=\"bar-positive\">\n      <h1 class=\"title\">Contacts</h1>\n    </ion-header-bar>\n    <ion-content>\n      <toc-channel-list ng-if=\"appView.isPrivateState()\">\n      </toc-channel-list>\n    </ion-content>\n  </ion-side-menu>\n</ion-side-menus>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular@1.4.1.js", ["github:angular/bower-angular@1.4.1/angular.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular@1.4.1/angular.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.10.1.js", ["npm:process@0.10.1/browser.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:remotestoragejs@0.11.2.js", ["npm:remotestoragejs@0.11.2/release/0.11.2/remotestorage.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:remotestoragejs@0.11.2/release/0.11.2/remotestorage.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@0.9.17/library/modules/$.js", ["npm:core-js@0.9.17/library/modules/$.fw.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var global = typeof self != 'undefined' ? self : Function('return this')(),
      core = {},
      defineProperty = Object.defineProperty,
      hasOwnProperty = {}.hasOwnProperty,
      ceil = Math.ceil,
      floor = Math.floor,
      max = Math.max,
      min = Math.min;
  var DESC = !!function() {
    try {
      return defineProperty({}, 'a', {get: function() {
          return 2;
        }}).a == 2;
    } catch (e) {}
  }();
  var hide = createDefiner(1);
  function toInteger(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  }
  function desc(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  }
  function simpleSet(object, key, value) {
    object[key] = value;
    return object;
  }
  function createDefiner(bitmap) {
    return DESC ? function(object, key, value) {
      return $.setDesc(object, key, desc(bitmap, value));
    } : simpleSet;
  }
  function isObject(it) {
    return it !== null && (typeof it == 'object' || typeof it == 'function');
  }
  function isFunction(it) {
    return typeof it == 'function';
  }
  function assertDefined(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  }
  var $ = module.exports = require("npm:core-js@0.9.17/library/modules/$.fw.js")({
    g: global,
    core: core,
    html: global.document && document.documentElement,
    isObject: isObject,
    isFunction: isFunction,
    that: function() {
      return this;
    },
    toInteger: toInteger,
    toLength: function(it) {
      return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
    },
    toIndex: function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    },
    has: function(it, key) {
      return hasOwnProperty.call(it, key);
    },
    create: Object.create,
    getProto: Object.getPrototypeOf,
    DESC: DESC,
    desc: desc,
    getDesc: Object.getOwnPropertyDescriptor,
    setDesc: defineProperty,
    setDescs: Object.defineProperties,
    getKeys: Object.keys,
    getNames: Object.getOwnPropertyNames,
    getSymbols: Object.getOwnPropertySymbols,
    assertDefined: assertDefined,
    ES5Object: Object,
    toObject: function(it) {
      return $.ES5Object(assertDefined(it));
    },
    hide: hide,
    def: createDefiner(0),
    set: global.Symbol ? simpleSet : hide,
    each: [].forEach
  });
  if (typeof __e != 'undefined')
    __e = core;
  if (typeof __g != 'undefined')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@0.9.17/library/modules/$.assign.js", ["npm:core-js@0.9.17/library/modules/$.js", "npm:core-js@0.9.17/library/modules/$.enum-keys.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.17/library/modules/$.js"),
      enumKeys = require("npm:core-js@0.9.17/library/modules/$.enum-keys.js");
  module.exports = Object.assign || function assign(target, source) {
    var T = Object($.assertDefined(target)),
        l = arguments.length,
        i = 1;
    while (l > i) {
      var S = $.ES5Object(arguments[i++]),
          keys = enumKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        T[key = keys[j++]] = S[key];
    }
    return T;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-toastr@1.3.1.js", ["npm:angular-toastr@1.3.1/dist/angular-toastr.tpls.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:angular-toastr@1.3.1/dist/angular-toastr.tpls.js");
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === 'string') {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error('Unsupported algorithm: ' + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key: key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === 'string') {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error('Unsupported algorithm: ' + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key: key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name, algorithm) {
      name = name.toUpperCase();
      forge.cipher.algorithms[name] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name) {
      name = name.toUpperCase();
      if (name in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {}
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && this.mode.name === 'CBC') {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
  var name = 'cipher';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/cipher.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1 = forge.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0x00,
      APPLICATION: 0x40,
      CONTEXT_SPECIFIC: 0x80,
      PRIVATE: 0xC0
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i = 0; i < value.length; ++i) {
          if (value[i] !== undefined) {
            tmp.push(value[i]);
          }
        }
        value = tmp;
      }
      return {
        tagClass: tagClass,
        type: type,
        constructed: constructed,
        composed: constructed || forge.util.isArray(value),
        value: value
      };
    };
    var _getValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 0x80) {
        return undefined;
      }
      var length;
      var longForm = b2 & 0x80;
      if (!longForm) {
        length = b2;
      } else {
        length = b.getInt((b2 & 0x7F) << 3);
      }
      return length;
    };
    asn1.fromDer = function(bytes, strict) {
      if (strict === undefined) {
        strict = true;
      }
      if (typeof bytes === 'string') {
        bytes = forge.util.createBuffer(bytes);
      }
      if (bytes.length() < 2) {
        var error = new Error('Too few bytes to parse DER.');
        error.bytes = bytes.length();
        throw error;
      }
      var b1 = bytes.getByte();
      var tagClass = (b1 & 0xC0);
      var type = b1 & 0x1F;
      var length = _getValueLength(bytes);
      if (bytes.length() < length) {
        if (strict) {
          var error = new Error('Too few bytes to read ASN.1 value.');
          error.detail = bytes.length() + ' < ' + length;
          throw error;
        }
        length = bytes.length();
      }
      var value;
      var constructed = ((b1 & 0x20) === 0x20);
      var composed = constructed;
      if (!composed && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) {
        var read = bytes.read;
        var unused = bytes.getByte();
        if (unused === 0) {
          b1 = bytes.getByte();
          var tc = (b1 & 0xC0);
          if (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC) {
            try {
              var len = _getValueLength(bytes);
              composed = (len === length - (bytes.read - read));
              if (composed) {
                ++read;
                --length;
              }
            } catch (ex) {}
          }
        }
        bytes.read = read;
      }
      if (composed) {
        value = [];
        if (length === undefined) {
          for (; ; ) {
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              break;
            }
            value.push(asn1.fromDer(bytes, strict));
          }
        } else {
          var start = bytes.length();
          while (length > 0) {
            value.push(asn1.fromDer(bytes, strict));
            length -= start - bytes.length();
            start = bytes.length();
          }
        }
      } else {
        if (length === undefined) {
          if (strict) {
            throw new Error('Non-constructed ASN.1 object of indefinite length.');
          }
          length = bytes.length();
        }
        if (type === asn1.Type.BMPSTRING) {
          value = '';
          for (var i = 0; i < length; i += 2) {
            value += String.fromCharCode(bytes.getInt16());
          }
        } else {
          value = bytes.getBytes(length);
        }
      }
      return asn1.create(tagClass, type, constructed, value);
    };
    asn1.toDer = function(obj) {
      var bytes = forge.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      if (obj.composed) {
        if (obj.constructed) {
          b1 |= 0x20;
        } else {
          value.putByte(0x00);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== undefined) {
            value.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          value.putBytes(obj.value);
        }
      }
      bytes.putByte(b1);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 0x7F);
      } else {
        var len = value.length();
        var lenBytes = '';
        do {
          lenBytes += String.fromCharCode(len & 0xFF);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 0x80);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split('.');
      var bytes = forge.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last,
          valueBytes,
          value,
          b;
      for (var i = 2; i < values.length; ++i) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i], 10);
        do {
          b = value & 0x7F;
          value = value >>> 7;
          if (!last) {
            b |= 0x80;
          }
          valueBytes.push(b);
          last = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes.putByte(valueBytes[n]);
        }
      }
      return bytes;
    };
    asn1.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === 'string') {
        bytes = forge.util.createBuffer(bytes);
      }
      var b = bytes.getByte();
      oid = Math.floor(b / 40) + '.' + (b % 40);
      var value = 0;
      while (bytes.length() > 0) {
        b = bytes.getByte();
        value = value << 7;
        if (b & 0x80) {
          value += b & 0x7F;
        } else {
          oid += '.' + (value + b);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = (year >= 50) ? 1900 + year : 2000 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== '+' && c !== '-') {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === '+' || c === '-') {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 60000;
          if (c === '+') {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === 'Z') {
        isUTC = true;
      }
      var end = gentime.length - 5,
          c = gentime.charAt(end);
      if (c === '+' || c === '-') {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 60000;
        if (c === '+') {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === '.') {
        fff = parseFloat(gentime.substr(14), 10) * 1000;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      var rval = '';
      var format = [];
      format.push(('' + date.getUTCFullYear()).substr(2));
      format.push('' + (date.getUTCMonth() + 1));
      format.push('' + date.getUTCDate());
      format.push('' + date.getUTCHours());
      format.push('' + date.getUTCMinutes());
      format.push('' + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += '0';
        }
        rval += format[i];
      }
      rval += 'Z';
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge.util.createBuffer();
      if (x >= -0x80 && x < 0x80) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -0x8000 && x < 0x8000) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -0x800000 && x < 0x800000) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -0x80000000 && x < 0x80000000) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error('Integer too large; max is 32-bits.');
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes) {
      if (typeof bytes === 'string') {
        bytes = forge.util.createBuffer(bytes);
      }
      var n = bytes.length() * 8;
      if (n > 32) {
        throw new Error('Integer too large; max is 32-bits.');
      }
      return bytes.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof(v.tagClass) === 'undefined') && (obj.type === v.type || typeof(v.type) === 'undefined')) {
        if (obj.constructed === v.constructed || typeof(v.constructed) === 'undefined') {
          rval = true;
          if (v.value && forge.util.isArray(v.value)) {
            var j = 0;
            for (var i = 0; rval && i < v.value.length; ++i) {
              rval = v.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                if (rval) {
                  ++j;
                } else if (v.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push('[' + v.name + '] ' + 'Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
          }
        } else if (errors) {
          errors.push('[' + v.name + '] ' + 'Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
        }
      } else if (errors) {
        if (obj.tagClass !== v.tagClass) {
          errors.push('[' + v.name + '] ' + 'Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
        }
        if (obj.type !== v.type) {
          errors.push('[' + v.name + '] ' + 'Expected type "' + v.type + '", got "' + obj.type + '"');
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = '';
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += '\n';
      }
      var indent = '';
      for (var i = 0; i < level * indentation; ++i) {
        indent += ' ';
      }
      rval += indent + 'Tag: ';
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += 'Universal:';
          break;
        case asn1.Class.APPLICATION:
          rval += 'Application:';
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += 'Context-Specific:';
          break;
        case asn1.Class.PRIVATE:
          rval += 'Private:';
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += ' (None)';
            break;
          case asn1.Type.BOOLEAN:
            rval += ' (Boolean)';
            break;
          case asn1.Type.BITSTRING:
            rval += ' (Bit string)';
            break;
          case asn1.Type.INTEGER:
            rval += ' (Integer)';
            break;
          case asn1.Type.OCTETSTRING:
            rval += ' (Octet string)';
            break;
          case asn1.Type.NULL:
            rval += ' (Null)';
            break;
          case asn1.Type.OID:
            rval += ' (Object Identifier)';
            break;
          case asn1.Type.ODESC:
            rval += ' (Object Descriptor)';
            break;
          case asn1.Type.EXTERNAL:
            rval += ' (External or Instance of)';
            break;
          case asn1.Type.REAL:
            rval += ' (Real)';
            break;
          case asn1.Type.ENUMERATED:
            rval += ' (Enumerated)';
            break;
          case asn1.Type.EMBEDDED:
            rval += ' (Embedded PDV)';
            break;
          case asn1.Type.UTF8:
            rval += ' (UTF8)';
            break;
          case asn1.Type.ROID:
            rval += ' (Relative Object Identifier)';
            break;
          case asn1.Type.SEQUENCE:
            rval += ' (Sequence)';
            break;
          case asn1.Type.SET:
            rval += ' (Set)';
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += ' (Printable String)';
            break;
          case asn1.Type.IA5String:
            rval += ' (IA5String (ASCII))';
            break;
          case asn1.Type.UTCTIME:
            rval += ' (UTC time)';
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += ' (Generalized time)';
            break;
          case asn1.Type.BMPSTRING:
            rval += ' (BMP String)';
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += '\n';
      rval += indent + 'Constructed: ' + obj.constructed + '\n';
      if (obj.composed) {
        var subvalues = 0;
        var sub = '';
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== undefined) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if ((i + 1) < obj.value.length) {
              sub += ',';
            }
          }
        }
        rval += indent + 'Sub values: ' + subvalues + sub;
      } else {
        rval += indent + 'Value: ';
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += ' (' + forge.pki.oids[oid] + ') ';
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += '0x' + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += '(' + obj.value + ') ';
          }
          rval += '0x' + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          rval += forge.util.decodeUtf8(obj.value);
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += '0x' + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += '[null]';
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
  var name = 'asn1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/asn1.js", ["require", "module", "npm:node-forge@0.6.30/js/util.js", "npm:node-forge@0.6.30/js/oids.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.md = forge.md || {};
    forge.md.algorithms = {
      md5: forge.md5,
      sha1: forge.sha1,
      sha256: forge.sha256
    };
    forge.md.md5 = forge.md5;
    forge.md.sha1 = forge.sha1;
    forge.md.sha256 = forge.sha256;
  }
  var name = 'md';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/md.js", ["require", "module", "npm:node-forge@0.6.30/js/md5.js", "npm:node-forge@0.6.30/js/sha1.js", "npm:node-forge@0.6.30/js/sha256.js", "npm:node-forge@0.6.30/js/sha512.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    if (forge.random && forge.random.getBytes) {
      return;
    }
    (function(jQuery) {
      var prng_aes = {};
      var _prng_aes_output = new Array(4);
      var _prng_aes_buffer = forge.util.createBuffer();
      prng_aes.formatKey = function(key) {
        var tmp = forge.util.createBuffer(key);
        key = new Array(4);
        key[0] = tmp.getInt32();
        key[1] = tmp.getInt32();
        key[2] = tmp.getInt32();
        key[3] = tmp.getInt32();
        return forge.aes._expandKey(key, false);
      };
      prng_aes.formatSeed = function(seed) {
        var tmp = forge.util.createBuffer(seed);
        seed = new Array(4);
        seed[0] = tmp.getInt32();
        seed[1] = tmp.getInt32();
        seed[2] = tmp.getInt32();
        seed[3] = tmp.getInt32();
        return seed;
      };
      prng_aes.cipher = function(key, seed) {
        forge.aes._updateBlock(key, seed, _prng_aes_output, false);
        _prng_aes_buffer.putInt32(_prng_aes_output[0]);
        _prng_aes_buffer.putInt32(_prng_aes_output[1]);
        _prng_aes_buffer.putInt32(_prng_aes_output[2]);
        _prng_aes_buffer.putInt32(_prng_aes_output[3]);
        return _prng_aes_buffer.getBytes();
      };
      prng_aes.increment = function(seed) {
        ++seed[3];
        return seed;
      };
      prng_aes.md = forge.md.sha256;
      function spawnPrng() {
        var ctx = forge.prng.create(prng_aes);
        ctx.getBytes = function(count, callback) {
          return ctx.generate(count, callback);
        };
        ctx.getBytesSync = function(count) {
          return ctx.generate(count);
        };
        return ctx;
      }
      var _ctx = spawnPrng();
      var _nodejs = (typeof process !== 'undefined' && process.versions && process.versions.node);
      var getRandomValues = null;
      if (typeof window !== 'undefined') {
        var _crypto = window.crypto || window.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
      }
      if (forge.disableNativeCode || (!_nodejs && !getRandomValues)) {
        if (typeof window === 'undefined' || window.document === undefined) {}
        _ctx.collectInt(+new Date(), 32);
        if (typeof(navigator) !== 'undefined') {
          var _navBytes = '';
          for (var key in navigator) {
            try {
              if (typeof(navigator[key]) == 'string') {
                _navBytes += navigator[key];
              }
            } catch (e) {}
          }
          _ctx.collect(_navBytes);
          _navBytes = null;
        }
        if (jQuery) {
          jQuery().mousemove(function(e) {
            _ctx.collectInt(e.clientX, 16);
            _ctx.collectInt(e.clientY, 16);
          });
          jQuery().keypress(function(e) {
            _ctx.collectInt(e.charCode, 8);
          });
        }
      }
      if (!forge.random) {
        forge.random = _ctx;
      } else {
        for (var key in _ctx) {
          forge.random[key] = _ctx[key];
        }
      }
      forge.random.createInstance = spawnPrng;
    })(typeof(jQuery) !== 'undefined' ? jQuery : null);
  }
  var name = 'random';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/random.js", ["require", "module", "npm:node-forge@0.6.30/js/aes.js", "npm:node-forge@0.6.30/js/md.js", "npm:node-forge@0.6.30/js/prng.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    if (typeof BigInteger === 'undefined') {
      var BigInteger = forge.jsbn.BigInteger;
    }
    var asn1 = forge.asn1;
    forge.pki = forge.pki || {};
    forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      name: 'PrivateKeyInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PrivateKeyInfo.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyVersion'
      }, {
        name: 'PrivateKeyInfo.privateKeyAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'AlgorithmIdentifier.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'privateKeyOid'
        }]
      }, {
        name: 'PrivateKeyInfo',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'privateKey'
      }]
    };
    var rsaPrivateKeyValidator = {
      name: 'RSAPrivateKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'RSAPrivateKey.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyVersion'
      }, {
        name: 'RSAPrivateKey.modulus',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyModulus'
      }, {
        name: 'RSAPrivateKey.publicExponent',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyPublicExponent'
      }, {
        name: 'RSAPrivateKey.privateExponent',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyPrivateExponent'
      }, {
        name: 'RSAPrivateKey.prime1',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyPrime1'
      }, {
        name: 'RSAPrivateKey.prime2',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyPrime2'
      }, {
        name: 'RSAPrivateKey.exponent1',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyExponent1'
      }, {
        name: 'RSAPrivateKey.exponent2',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyExponent2'
      }, {
        name: 'RSAPrivateKey.coefficient',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyCoefficient'
      }]
    };
    var rsaPublicKeyValidator = {
      name: 'RSAPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'RSAPublicKey.modulus',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'publicKeyModulus'
      }, {
        name: 'RSAPublicKey.exponent',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'publicKeyExponent'
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: 'SubjectPublicKeyInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'subjectPublicKeyInfo',
      value: [{
        name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'AlgorithmIdentifier.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'publicKeyOid'
        }]
      }, {
        name: 'SubjectPublicKeyInfo.subjectPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: 'rsaPublicKey'
        }]
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error('Unknown message digest algorithm.');
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));
      var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16).mod(key.n);
      } while (r.equals(BigInteger.ZERO));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = (bt === 0x02);
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0x00);
        --zeros;
      }
      ed.putBytes(forge.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error('Encrypted message length is invalid.');
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error('Encrypted message is invalid.');
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0x00);
        --zeros;
      }
      eb.putBytes(forge.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof(bits) === 'string') {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }};
      var algorithm = options.algorithm || 'PRIMEINC';
      var rval;
      if (algorithm === 'PRIMEINC') {
        rval = {
          algorithm: algorithm,
          state: 0,
          bits: bits,
          rng: rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error('Invalid key generation algorithm: ' + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!('algorithm' in state)) {
        state.algorithm = 'PRIMEINC';
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = (state.p === null) ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = (state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0) ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === 'object') {
          options = bits;
          bits = undefined;
        } else if (typeof bits === 'function') {
          callback = bits;
          bits = undefined;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === 'number') {
          if (typeof e === 'function') {
            callback = e;
            e = undefined;
          } else if (typeof e !== 'number') {
            options = e;
            e = undefined;
          }
        } else {
          options = bits;
          callback = e;
          bits = undefined;
          e = undefined;
        }
      } else if (arguments.length === 3) {
        if (typeof e === 'number') {
          if (typeof options === 'function') {
            callback = options;
            options = undefined;
          }
        } else {
          callback = options;
          options = e;
          e = undefined;
        }
      }
      options = options || {};
      if (bits === undefined) {
        bits = options.bits || 2048;
      }
      if (e === undefined) {
        e = options.e || 0x10001;
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key = {
        n: n,
        e: e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === 'string') {
          scheme = scheme.toUpperCase();
        } else if (scheme === undefined) {
          scheme = 'RSAES-PKCS1-V1_5';
        }
        if (scheme === 'RSAES-PKCS1-V1_5') {
          scheme = {encode: function(m, key, pub) {
              return _encodePkcs1_v1_5(m, key, 0x02).getBytes();
            }};
        } else if (scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
          scheme = {encode: function(m, key) {
              return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
            }};
        } else if (['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
          scheme = {encode: function(e) {
              return e;
            }};
        } else if (typeof scheme === 'string') {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e, key, true);
      };
      key.verify = function(digest, signature, scheme) {
        if (typeof scheme === 'string') {
          scheme = scheme.toUpperCase();
        } else if (scheme === undefined) {
          scheme = 'RSASSA-PKCS1-V1_5';
        }
        if (scheme === 'RSASSA-PKCS1-V1_5') {
          scheme = {verify: function(digest, d) {
              d = _decodePkcs1_v1_5(d, key, true);
              var obj = asn1.fromDer(d);
              return digest === obj.value[1].value;
            }};
        } else if (scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
          scheme = {verify: function(digest, d) {
              d = _decodePkcs1_v1_5(d, key, true);
              return digest === d;
            }};
        }
        var d = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest, d, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n: n,
        e: e,
        d: d,
        p: p,
        q: q,
        dP: dP,
        dQ: dQ,
        qInv: qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === 'string') {
          scheme = scheme.toUpperCase();
        } else if (scheme === undefined) {
          scheme = 'RSAES-PKCS1-V1_5';
        }
        var d = pki.rsa.decrypt(data, key, false, false);
        if (scheme === 'RSAES-PKCS1-V1_5') {
          scheme = {decode: _decodePkcs1_v1_5};
        } else if (scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
          scheme = {decode: function(d, key) {
              return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
            }};
        } else if (['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
          scheme = {decode: function(d) {
              return d;
            }};
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === 'string') {
          scheme = scheme.toUpperCase();
        }
        if (scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {
          scheme = {encode: emsaPkcs1v15encode};
          bt = 0x01;
        } else if (scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
          scheme = {encode: function() {
              return md;
            }};
          bt = 0x01;
        }
        var d = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error('Cannot read private key. ' + 'ASN.1 object does not contain an RSAPrivateKey.');
        error.errors = errors;
        throw error;
      }
      var n,
          e,
          d,
          p,
          q,
          dP,
          dQ,
          qInv;
      n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error('Cannot read public key. Unknown OID.');
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error('Cannot read public key. ' + 'ASN.1 object does not contain an RSAPublicKey.');
        error.errors = errors;
        throw error;
      }
      var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [pki.publicKeyToRSAPublicKey(key)])]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > (k - 11)) {
        var error = new Error('Message is too long for PKCS#1 v1.5 padding.');
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0x00);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0x00 || bt === 0x01) {
        padByte = (bt === 0x00) ? 0x00 : 0xFF;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0x00);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0x00 || (pub && bt !== 0x00 && bt !== 0x01) || (!pub && bt != 0x02) || (pub && bt === 0x00 && typeof(ml) === 'undefined')) {
        throw new Error('Encryption block is invalid.');
      }
      var padNum = 0;
      if (bt === 0x00) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0x00) {
            throw new Error('Encryption block is invalid.');
          }
        }
      } else if (bt === 0x01) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 0xFF) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 0x02) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0x00) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0x00 || padNum !== (k - 3 - eb.length())) {
        throw new Error('Encryption block is invalid.');
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {algorithm: {
          name: options.algorithm || 'PRIMEINC',
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }};
      if ('prng' in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback) {
        forge.prime.generateProbablePrime(bits, opts, callback);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= '8') {
        hex = '00' + hex;
      }
      return forge.util.hexToBytes(hex);
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
  }
  var name = 'rsa';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/rsa.js", ["require", "module", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/jsbn.js", "npm:node-forge@0.6.30/js/oids.js", "npm:node-forge@0.6.30/js/pkcs1.js", "npm:node-forge@0.6.30/js/prime.js", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.mgf = forge.mgf || {};
    forge.mgf.mgf1 = forge.mgf1;
  }
  var name = 'mgf';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/mgf.js", ["require", "module", "npm:node-forge@0.6.30/js/mgf1.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
System.registerDynamic("npm:moment@2.10.3.js", ["npm:moment@2.10.3/moment.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:moment@2.10.3/moment.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-animate@1.4.1.js", ["github:angular/bower-angular-animate@1.4.1/angular-animate.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular-animate@1.4.1/angular-animate.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-sanitize@1.4.1.js", ["github:angular/bower-angular-sanitize@1.4.1/angular-sanitize.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular-sanitize@1.4.1/angular-sanitize.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/ui-router@0.2.15.js", ["github:angular-ui/ui-router@0.2.15/angular-ui-router.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-ui/ui-router@0.2.15/angular-ui-router.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:emmett@3.0.1.js", ["npm:emmett@3.0.1/emmett.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:emmett@3.0.1/emmett.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@1.1.1/src/type.js", ["npm:baobab@1.1.1/src/cursor.js", "npm:baobab@1.1.1/src/facet.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var type = {};
  function anyOf(value, allowed) {
    return allowed.some(function(t) {
      return type[t](value);
    });
  }
  type.Array = function(value) {
    return Array.isArray(value);
  };
  type.Object = function(value) {
    return value && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date) && !(value instanceof RegExp);
  };
  type.String = function(value) {
    return typeof value === 'string';
  };
  type.Number = function(value) {
    return typeof value === 'number';
  };
  type.PositiveInteger = function(value) {
    return typeof value === 'number' && value > 0 && value % 1 === 0;
  };
  type.Function = function(value) {
    return typeof value === 'function';
  };
  type.Primitive = function(value) {
    return value !== Object(value);
  };
  type.Date = function(value) {
    return value instanceof Date;
  };
  type.NonScalar = function(value) {
    return type.Object(value) || type.Array(value);
  };
  type.Splicer = function(value) {
    return type.Array(value) && value.every(type.Array);
  };
  type.Path = function(value, allowed) {
    allowed = allowed || ['String', 'Number', 'Function', 'Object'];
    if (type.Array(value)) {
      return value.every(function(step) {
        return anyOf(step, allowed);
      });
    } else {
      return anyOf(value, allowed);
    }
  };
  type.ComplexPath = function(value) {
    return value.some(function(step) {
      return anyOf(step, ['Object', 'Function']);
    });
  };
  type.FacetCursors = function(value) {
    if (!type.Object(value))
      return false;
    return Object.keys(value).every(function(k) {
      var v = value[k];
      return type.Path(v, ['String', 'Number', 'Object']) || v instanceof require("npm:baobab@1.1.1/src/cursor.js");
    });
  };
  type.FacetFacets = function(value) {
    if (!type.Object(value))
      return false;
    return Object.keys(value).every(function(k) {
      var v = value[k];
      return typeof v === 'string' || v instanceof require("npm:baobab@1.1.1/src/facet.js");
    });
  };
  module.exports = type;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/qr.js", ["npm:qr-encode@0.3.0/lib/b64encode.js", "npm:qr-encode@0.3.0/lib/byte-array.js", "npm:qr-encode@0.3.0/lib/math.js", "npm:qr-encode@0.3.0/lib/polynomial.js", "npm:qr-encode@0.3.0/lib/constants.js", "npm:qr-encode@0.3.0/lib/bit-buffer.js", "npm:qr-encode@0.3.0/lib/string.js", "npm:qr-encode@0.3.0/lib/bit-byte.js", "npm:qr-encode@0.3.0/lib/rsblock.js", "npm:qr-encode@0.3.0/lib/gif.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var base64EncodeOutputStream = require("npm:qr-encode@0.3.0/lib/b64encode.js");
  var byteArrayOutputStream = require("npm:qr-encode@0.3.0/lib/byte-array.js");
  var QRMath = require("npm:qr-encode@0.3.0/lib/math.js");
  var qrPolynomial = require("npm:qr-encode@0.3.0/lib/polynomial.js");
  var constants = require("npm:qr-encode@0.3.0/lib/constants.js");
  var qrBitBuffer = require("npm:qr-encode@0.3.0/lib/bit-buffer.js");
  var string = require("npm:qr-encode@0.3.0/lib/string.js");
  var qr8BitByte = require("npm:qr-encode@0.3.0/lib/bit-byte.js");
  var QRRSBlock = require("npm:qr-encode@0.3.0/lib/rsblock.js");
  var gifImage = require("npm:qr-encode@0.3.0/lib/gif.js");
  var QRMode = constants.QRMode;
  var QRErrorCorrectLevel = constants.QRErrorCorrectLevel;
  var QRMaskPattern = constants.QRMaskPattern;
  module.exports = function() {
    var qrcode = function(typeNumber, errorCorrectLevel) {
      var PAD0 = 0xEC;
      var PAD1 = 0x11;
      var _typeNumber = typeNumber;
      var _errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel];
      var _modules = null;
      var _moduleCount = 0;
      var _dataCache = null;
      var _dataList = new Array();
      var _this = {};
      var makeImpl = function(test, maskPattern) {
        _moduleCount = _typeNumber * 4 + 17;
        _modules = function(moduleCount) {
          var modules = new Array(moduleCount);
          for (var row = 0; row < moduleCount; row += 1) {
            modules[row] = new Array(moduleCount);
            for (var col = 0; col < moduleCount; col += 1) {
              modules[row][col] = null;
            }
          }
          return modules;
        }(_moduleCount);
        setupPositionProbePattern(0, 0);
        setupPositionProbePattern(_moduleCount - 7, 0);
        setupPositionProbePattern(0, _moduleCount - 7);
        setupPositionAdjustPattern();
        setupTimingPattern();
        setupTypeInfo(test, maskPattern);
        if (_typeNumber >= 7) {
          setupTypeNumber(test);
        }
        if (_dataCache == null) {
          _dataCache = createData(_typeNumber, _errorCorrectLevel, _dataList);
        }
        mapData(_dataCache, maskPattern);
      };
      var setupPositionProbePattern = function(row, col) {
        for (var r = -1; r <= 7; r += 1) {
          if (row + r <= -1 || _moduleCount <= row + r)
            continue;
          for (var c = -1; c <= 7; c += 1) {
            if (col + c <= -1 || _moduleCount <= col + c)
              continue;
            if ((0 <= r && r <= 6 && (c == 0 || c == 6)) || (0 <= c && c <= 6 && (r == 0 || r == 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
              _modules[row + r][col + c] = true;
            } else {
              _modules[row + r][col + c] = false;
            }
          }
        }
      };
      var getBestMaskPattern = function() {
        var minLostPoint = 0;
        var pattern = 0;
        for (var i = 0; i < 8; i += 1) {
          makeImpl(true, i);
          var lostPoint = QRUtil.getLostPoint(_this);
          if (i == 0 || minLostPoint > lostPoint) {
            minLostPoint = lostPoint;
            pattern = i;
          }
        }
        return pattern;
      };
      var setupTimingPattern = function() {
        for (var r = 8; r < _moduleCount - 8; r += 1) {
          if (_modules[r][6] != null) {
            continue;
          }
          _modules[r][6] = (r % 2 == 0);
        }
        for (var c = 8; c < _moduleCount - 8; c += 1) {
          if (_modules[6][c] != null) {
            continue;
          }
          _modules[6][c] = (c % 2 == 0);
        }
      };
      var setupPositionAdjustPattern = function() {
        var pos = QRUtil.getPatternPosition(_typeNumber);
        for (var i = 0; i < pos.length; i += 1) {
          for (var j = 0; j < pos.length; j += 1) {
            var row = pos[i];
            var col = pos[j];
            if (_modules[row][col] != null) {
              continue;
            }
            for (var r = -2; r <= 2; r += 1) {
              for (var c = -2; c <= 2; c += 1) {
                if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0)) {
                  _modules[row + r][col + c] = true;
                } else {
                  _modules[row + r][col + c] = false;
                }
              }
            }
          }
        }
      };
      var setupTypeNumber = function(test) {
        var bits = QRUtil.getBCHTypeNumber(_typeNumber);
        for (var i = 0; i < 18; i += 1) {
          var mod = (!test && ((bits >> i) & 1) == 1);
          _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
        }
        for (var i = 0; i < 18; i += 1) {
          var mod = (!test && ((bits >> i) & 1) == 1);
          _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
        }
      };
      var setupTypeInfo = function(test, maskPattern) {
        var data = (_errorCorrectLevel << 3) | maskPattern;
        var bits = QRUtil.getBCHTypeInfo(data);
        for (var i = 0; i < 15; i += 1) {
          var mod = (!test && ((bits >> i) & 1) == 1);
          if (i < 6) {
            _modules[i][8] = mod;
          } else if (i < 8) {
            _modules[i + 1][8] = mod;
          } else {
            _modules[_moduleCount - 15 + i][8] = mod;
          }
        }
        for (var i = 0; i < 15; i += 1) {
          var mod = (!test && ((bits >> i) & 1) == 1);
          if (i < 8) {
            _modules[8][_moduleCount - i - 1] = mod;
          } else if (i < 9) {
            _modules[8][15 - i - 1 + 1] = mod;
          } else {
            _modules[8][15 - i - 1] = mod;
          }
        }
        _modules[_moduleCount - 8][8] = (!test);
      };
      var mapData = function(data, maskPattern) {
        var inc = -1;
        var row = _moduleCount - 1;
        var bitIndex = 7;
        var byteIndex = 0;
        var maskFunc = QRUtil.getMaskFunction(maskPattern);
        for (var col = _moduleCount - 1; col > 0; col -= 2) {
          if (col == 6)
            col -= 1;
          while (true) {
            for (var c = 0; c < 2; c += 1) {
              if (_modules[row][col - c] == null) {
                var dark = false;
                if (byteIndex < data.length) {
                  dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
                }
                var mask = maskFunc(row, col - c);
                if (mask) {
                  dark = !dark;
                }
                _modules[row][col - c] = dark;
                bitIndex -= 1;
                if (bitIndex == -1) {
                  byteIndex += 1;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if (row < 0 || _moduleCount <= row) {
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      };
      var createBytes = function(buffer, rsBlocks) {
        var offset = 0;
        var maxDcCount = 0;
        var maxEcCount = 0;
        var dcdata = new Array(rsBlocks.length);
        var ecdata = new Array(rsBlocks.length);
        for (var r = 0; r < rsBlocks.length; r += 1) {
          var dcCount = rsBlocks[r].dataCount;
          var ecCount = rsBlocks[r].totalCount - dcCount;
          maxDcCount = Math.max(maxDcCount, dcCount);
          maxEcCount = Math.max(maxEcCount, ecCount);
          dcdata[r] = new Array(dcCount);
          for (var i = 0; i < dcdata[r].length; i += 1) {
            dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
          }
          offset += dcCount;
          var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
          var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);
          var modPoly = rawPoly.mod(rsPoly);
          ecdata[r] = new Array(rsPoly.getLength() - 1);
          for (var i = 0; i < ecdata[r].length; i += 1) {
            var modIndex = i + modPoly.getLength() - ecdata[r].length;
            ecdata[r][i] = (modIndex >= 0) ? modPoly.getAt(modIndex) : 0;
          }
        }
        var totalCodeCount = 0;
        for (var i = 0; i < rsBlocks.length; i += 1) {
          totalCodeCount += rsBlocks[i].totalCount;
        }
        var data = new Array(totalCodeCount);
        var index = 0;
        for (var i = 0; i < maxDcCount; i += 1) {
          for (var r = 0; r < rsBlocks.length; r += 1) {
            if (i < dcdata[r].length) {
              data[index] = dcdata[r][i];
              index += 1;
            }
          }
        }
        for (var i = 0; i < maxEcCount; i += 1) {
          for (var r = 0; r < rsBlocks.length; r += 1) {
            if (i < ecdata[r].length) {
              data[index] = ecdata[r][i];
              index += 1;
            }
          }
        }
        return data;
      };
      var createData = function(typeNumber, errorCorrectLevel, dataList) {
        var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
        var buffer = qrBitBuffer();
        for (var i = 0; i < dataList.length; i += 1) {
          var data = dataList[i];
          buffer.put(data.getMode(), 4);
          buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber));
          data.write(buffer);
        }
        var totalDataCount = 0;
        for (var i = 0; i < rsBlocks.length; i += 1) {
          totalDataCount += rsBlocks[i].dataCount;
        }
        if (buffer.getLengthInBits() > totalDataCount * 8) {
          throw new Error('code length overflow. (' + buffer.getLengthInBits() + '>' + totalDataCount * 8 + ')');
        }
        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
          buffer.put(0, 4);
        }
        while (buffer.getLengthInBits() % 8 != 0) {
          buffer.putBit(false);
        }
        while (true) {
          if (buffer.getLengthInBits() >= totalDataCount * 8) {
            break;
          }
          buffer.put(PAD0, 8);
          if (buffer.getLengthInBits() >= totalDataCount * 8) {
            break;
          }
          buffer.put(PAD1, 8);
        }
        return createBytes(buffer, rsBlocks);
      };
      _this.addData = function(data) {
        var newData = qr8BitByte(data);
        _dataList.push(newData);
        _dataCache = null;
      };
      _this.isDark = function(row, col) {
        if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
          throw new Error(row + ',' + col);
        }
        return _modules[row][col];
      };
      _this.getModuleCount = function() {
        return _moduleCount;
      };
      _this.make = function() {
        makeImpl(false, getBestMaskPattern());
      };
      _this.createTableTag = function(cellSize, margin) {
        cellSize = cellSize || 2;
        margin = (typeof margin == 'undefined') ? cellSize * 4 : margin;
        var qrHtml = '';
        qrHtml += '<table style="';
        qrHtml += ' border-width: 0px; border-style: none;';
        qrHtml += ' border-collapse: collapse;';
        qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
        qrHtml += '">';
        qrHtml += '<tbody>';
        for (var r = 0; r < _this.getModuleCount(); r += 1) {
          qrHtml += '<tr>';
          for (var c = 0; c < _this.getModuleCount(); c += 1) {
            qrHtml += '<td style="';
            qrHtml += ' border-width: 0px; border-style: none;';
            qrHtml += ' border-collapse: collapse;';
            qrHtml += ' padding: 0px; margin: 0px;';
            qrHtml += ' width: ' + cellSize + 'px;';
            qrHtml += ' height: ' + cellSize + 'px;';
            qrHtml += ' background-color: ';
            qrHtml += _this.isDark(r, c) ? '#000000' : '#ffffff';
            qrHtml += ';';
            qrHtml += '"/>';
          }
          qrHtml += '</tr>';
        }
        qrHtml += '</tbody>';
        qrHtml += '</table>';
        return qrHtml;
      };
      _this.createImgTag = function(cellSize, margin) {
        cellSize = cellSize || 2;
        margin = (typeof margin == 'undefined') ? cellSize * 4 : margin;
        var size = _this.getModuleCount() * cellSize + margin * 2;
        var min = margin;
        var max = size - margin;
        return createImgTag(size, size, function(x, y) {
          if (min <= x && x < max && min <= y && y < max) {
            var c = Math.floor((x - min) / cellSize);
            var r = Math.floor((y - min) / cellSize);
            return _this.isDark(r, c) ? 0 : 1;
          } else {
            return 1;
          }
        });
      };
      _this.createImgSrc = function(cellSize, margin) {
        cellSize = cellSize || 2;
        margin = (typeof margin == 'undefined') ? cellSize * 4 : margin;
        var size = _this.getModuleCount() * cellSize + margin * 2;
        var min = margin;
        var max = size - margin;
        return createImgSrc(size, size, function(x, y) {
          if (min <= x && x < max && min <= y && y < max) {
            var c = Math.floor((x - min) / cellSize);
            var r = Math.floor((y - min) / cellSize);
            return _this.isDark(r, c) ? 0 : 1;
          } else {
            return 1;
          }
        });
      };
      return _this;
    };
    var QRUtil = function() {
      var PATTERN_POSITION_TABLE = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]];
      var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
      var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
      var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
      var _this = {};
      var getBCHDigit = function(data) {
        var digit = 0;
        while (data != 0) {
          digit += 1;
          data >>>= 1;
        }
        return digit;
      };
      _this.getBCHTypeInfo = function(data) {
        var d = data << 10;
        while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
          d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15)));
        }
        return ((data << 10) | d) ^ G15_MASK;
      };
      _this.getBCHTypeNumber = function(data) {
        var d = data << 12;
        while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
          d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18)));
        }
        return (data << 12) | d;
      };
      _this.getPatternPosition = function(typeNumber) {
        return PATTERN_POSITION_TABLE[typeNumber - 1];
      };
      _this.getMaskFunction = function(maskPattern) {
        switch (maskPattern) {
          case QRMaskPattern.PATTERN000:
            return function(i, j) {
              return (i + j) % 2 == 0;
            };
          case QRMaskPattern.PATTERN001:
            return function(i, j) {
              return i % 2 == 0;
            };
          case QRMaskPattern.PATTERN010:
            return function(i, j) {
              return j % 3 == 0;
            };
          case QRMaskPattern.PATTERN011:
            return function(i, j) {
              return (i + j) % 3 == 0;
            };
          case QRMaskPattern.PATTERN100:
            return function(i, j) {
              return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
            };
          case QRMaskPattern.PATTERN101:
            return function(i, j) {
              return (i * j) % 2 + (i * j) % 3 == 0;
            };
          case QRMaskPattern.PATTERN110:
            return function(i, j) {
              return ((i * j) % 2 + (i * j) % 3) % 2 == 0;
            };
          case QRMaskPattern.PATTERN111:
            return function(i, j) {
              return ((i * j) % 3 + (i + j) % 2) % 2 == 0;
            };
          default:
            throw new Error('bad maskPattern:' + maskPattern);
        }
      };
      _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
        var a = qrPolynomial([1], 0);
        for (var i = 0; i < errorCorrectLength; i += 1) {
          a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0));
        }
        return a;
      };
      _this.getLengthInBits = function(mode, type) {
        if (1 <= type && type < 10) {
          switch (mode) {
            case QRMode.MODE_NUMBER:
              return 10;
            case QRMode.MODE_ALPHA_NUM:
              return 9;
            case QRMode.MODE_8BIT_BYTE:
              return 8;
            case QRMode.MODE_KANJI:
              return 8;
            default:
              throw new Error('mode:' + mode);
          }
        } else if (type < 27) {
          switch (mode) {
            case QRMode.MODE_NUMBER:
              return 12;
            case QRMode.MODE_ALPHA_NUM:
              return 11;
            case QRMode.MODE_8BIT_BYTE:
              return 16;
            case QRMode.MODE_KANJI:
              return 10;
            default:
              throw new Error('mode:' + mode);
          }
        } else if (type < 41) {
          switch (mode) {
            case QRMode.MODE_NUMBER:
              return 14;
            case QRMode.MODE_ALPHA_NUM:
              return 13;
            case QRMode.MODE_8BIT_BYTE:
              return 16;
            case QRMode.MODE_KANJI:
              return 12;
            default:
              throw new Error('mode:' + mode);
          }
        } else {
          throw new Error('type:' + type);
        }
      };
      _this.getLostPoint = function(qrcode) {
        var moduleCount = qrcode.getModuleCount();
        var lostPoint = 0;
        for (var row = 0; row < moduleCount; row += 1) {
          for (var col = 0; col < moduleCount; col += 1) {
            var sameCount = 0;
            var dark = qrcode.isDark(row, col);
            for (var r = -1; r <= 1; r += 1) {
              if (row + r < 0 || moduleCount <= row + r) {
                continue;
              }
              for (var c = -1; c <= 1; c += 1) {
                if (col + c < 0 || moduleCount <= col + c) {
                  continue;
                }
                if (r == 0 && c == 0) {
                  continue;
                }
                if (dark == qrcode.isDark(row + r, col + c)) {
                  sameCount += 1;
                }
              }
            }
            if (sameCount > 5) {
              lostPoint += (3 + sameCount - 5);
            }
          }
        }
        for (var row = 0; row < moduleCount - 1; row += 1) {
          for (var col = 0; col < moduleCount - 1; col += 1) {
            var count = 0;
            if (qrcode.isDark(row, col))
              count += 1;
            if (qrcode.isDark(row + 1, col))
              count += 1;
            if (qrcode.isDark(row, col + 1))
              count += 1;
            if (qrcode.isDark(row + 1, col + 1))
              count += 1;
            if (count == 0 || count == 4) {
              lostPoint += 3;
            }
          }
        }
        for (var row = 0; row < moduleCount; row += 1) {
          for (var col = 0; col < moduleCount - 6; col += 1) {
            if (qrcode.isDark(row, col) && !qrcode.isDark(row, col + 1) && qrcode.isDark(row, col + 2) && qrcode.isDark(row, col + 3) && qrcode.isDark(row, col + 4) && !qrcode.isDark(row, col + 5) && qrcode.isDark(row, col + 6)) {
              lostPoint += 40;
            }
          }
        }
        for (var col = 0; col < moduleCount; col += 1) {
          for (var row = 0; row < moduleCount - 6; row += 1) {
            if (qrcode.isDark(row, col) && !qrcode.isDark(row + 1, col) && qrcode.isDark(row + 2, col) && qrcode.isDark(row + 3, col) && qrcode.isDark(row + 4, col) && !qrcode.isDark(row + 5, col) && qrcode.isDark(row + 6, col)) {
              lostPoint += 40;
            }
          }
        }
        var darkCount = 0;
        for (var col = 0; col < moduleCount; col += 1) {
          for (var row = 0; row < moduleCount; row += 1) {
            if (qrcode.isDark(row, col)) {
              darkCount += 1;
            }
          }
        }
        var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
        lostPoint += ratio * 10;
        return lostPoint;
      };
      return _this;
    }();
    var createImgTag = function(width, height, getPixel, alt) {
      var gif = gifImage(width, height);
      for (var y = 0; y < height; y += 1) {
        for (var x = 0; x < width; x += 1) {
          gif.setPixel(x, y, getPixel(x, y));
        }
      }
      var b = byteArrayOutputStream();
      gif.write(b);
      var base64 = base64EncodeOutputStream();
      var bytes = b.toByteArray();
      for (var i = 0; i < bytes.length; i += 1) {
        base64.writeByte(bytes[i]);
      }
      base64.flush();
      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += 'data:image/gif;base64,';
      img += base64;
      img += '"';
      img += '\u0020width="';
      img += width;
      img += '"';
      img += '\u0020height="';
      img += height;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += alt;
        img += '"';
      }
      img += '/>';
      return img;
    };
    var createImgSrc = function(width, height, getPixel, alt) {
      var gif = gifImage(width, height);
      for (var y = 0; y < height; y += 1) {
        for (var x = 0; x < width; x += 1) {
          gif.setPixel(x, y, getPixel(x, y));
        }
      }
      var b = byteArrayOutputStream();
      gif.write(b);
      var base64 = base64EncodeOutputStream();
      var bytes = b.toByteArray();
      for (var i = 0; i < bytes.length; i += 1) {
        base64.writeByte(bytes[i]);
      }
      base64.flush();
      var d = '';
      d += 'data:image/gif;base64,' + base64;
      return d;
      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += 'data:image/gif;base64,';
      img += base64;
      img += '"';
      img += '\u0020width="';
      img += width;
      img += '"';
      img += '\u0020height="';
      img += height;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += alt;
        img += '"';
      }
      img += '/>';
      return img;
    };
    return qrcode;
  }();
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.1/index.js", ["npm:process@0.10.1.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.1.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@0.9.17/library/modules/$.def.js", ["npm:core-js@0.9.17/library/modules/$.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.17/library/modules/$.js"),
      global = $.g,
      core = $.core,
      isFunction = $.isFunction;
  function ctx(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  }
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  function $def(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] : (global[name] || {}).prototype,
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      if (isGlobal && !isFunction(target[key]))
        exp = source[key];
      else if (type & $def.B && own)
        exp = ctx(out, global);
      else if (type & $def.W && target[key] == out)
        !function(C) {
          exp = function(param) {
            return this instanceof C ? new C(param) : C(param);
          };
          exp.prototype = C.prototype;
        }(out);
      else
        exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
      exports[key] = exp;
      if (isProto)
        (exports.prototype || (exports.prototype = {}))[key] = out;
    }
  }
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key: key,
        output: output,
        decrypt: false,
        mode: mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key: key,
        output: null,
        decrypt: false,
        mode: mode
      });
    };
    forge.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key: key,
        output: output,
        decrypt: true,
        mode: mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key: key,
        output: null,
        decrypt: true,
        mode: mode
      });
    };
    forge.aes.Algorithm = function(name, mode) {
      if (!init) {
        initialize();
      }
      var self = this;
      self.name = name;
      self.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self._w, inBlock, outBlock, true);
          }
        }
      });
      self._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === 'string' && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error('Invalid key parameter.');
      }
      var mode = this.mode.name;
      var encryptOp = (['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm('AES-CBC', forge.cipher.modes.cbc);
    registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
    registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
    registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
    registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge.aes.Algorithm(name, mode);
      };
      forge.cipher.registerAlgorithm(name, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = (i + 128) << 1 ^ 0x11B;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0,
          ei = 0,
          e2,
          e4,
          e8,
          sx,
          sx2,
          me,
          ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ (ei << 1) ^ (ei << 2) ^ (ei << 3) ^ (ei << 4);
        sx = (sx >> 8) ^ (sx & 255) ^ 0x63;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = (sx2 << 24) ^ (sx << 16) ^ (sx << 8) ^ (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt) {
      var w = key.slice(0);
      var temp,
          iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ (rcon[iNk] << 24);
          iNk++;
        } else if (Nk > 6 && (i % Nk === 4)) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i] = w[i - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i = 0,
            wi = end - Nb; i < end; i += Nb, wi -= Nb) {
          if (i === 0 || i === (end - Nb)) {
            wnew[i] = w[wi];
            wnew[i + 1] = w[wi + 3];
            wnew[i + 2] = w[wi + 2];
            wnew[i + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt) {
      var Nr = w.length / 4 - 1;
      var m0,
          m1,
          m2,
          m3,
          sub;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a,
          b,
          c,
          d,
          a2,
          b2,
          c2;
      a = input[0] ^ w[0];
      b = input[decrypt ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt ? 1 : 3] ^ w[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = (sub[a >>> 24] << 24) ^ (sub[b >>> 16 & 255] << 16) ^ (sub[c >>> 8 & 255] << 8) ^ (sub[d & 255]) ^ w[++i];
      output[decrypt ? 3 : 1] = (sub[b >>> 24] << 24) ^ (sub[c >>> 16 & 255] << 16) ^ (sub[d >>> 8 & 255] << 8) ^ (sub[a & 255]) ^ w[++i];
      output[2] = (sub[c >>> 24] << 24) ^ (sub[d >>> 16 & 255] << 16) ^ (sub[a >>> 8 & 255] << 8) ^ (sub[b & 255]) ^ w[++i];
      output[decrypt ? 1 : 3] = (sub[d >>> 24] << 24) ^ (sub[a >>> 16 & 255] << 16) ^ (sub[b >>> 8 & 255] << 8) ^ (sub[c & 255]) ^ w[++i];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || 'CBC').toUpperCase();
      var algorithm = 'AES-' + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options) {
        var output = null;
        if (options instanceof forge.util.ByteBuffer) {
          output = options;
          options = {};
        }
        options = options || {};
        options.output = output;
        options.iv = iv;
        start.call(cipher, options);
      };
      return cipher;
    }
  }
  var name = 'aes';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/aes.js", ["require", "module", "npm:node-forge@0.6.30/js/cipher.js", "npm:node-forge@0.6.30/js/cipherModes.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var hmac = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === 'string') {
            md = md.toLowerCase();
            if (md in forge.md.algorithms) {
              _md = forge.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === 'string') {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key.at(i);
            _ipadding.putByte(0x36 ^ tmp);
            _opadding.putByte(0x5C ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(0x36);
              _opadding.putByte(0x5C);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
  var name = 'hmac';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/hmac.js", ["require", "module", "npm:node-forge@0.6.30/js/md.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    if (typeof BigInteger === 'undefined') {
      var BigInteger = forge.jsbn.BigInteger;
    }
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    pki.pbe = forge.pbe = forge.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: 'EncryptedPrivateKeyInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'AlgorithmIdentifier.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'encryptionOid'
        }, {
          name: 'AlgorithmIdentifier.parameters',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'encryptionParams'
        }]
      }, {
        name: 'EncryptedPrivateKeyInfo.encryptedData',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'encryptedData'
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: 'PBES2Algorithms',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PBES2Algorithms.keyDerivationFunc',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'PBES2Algorithms.keyDerivationFunc.oid',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'kdfOid'
        }, {
          name: 'PBES2Algorithms.params',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'PBES2Algorithms.params.salt',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: 'kdfSalt'
          }, {
            name: 'PBES2Algorithms.params.iterationCount',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            onstructed: true,
            capture: 'kdfIterationCount'
          }]
        }]
      }, {
        name: 'PBES2Algorithms.encryptionScheme',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'PBES2Algorithms.encryptionScheme.oid',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'encOid'
        }, {
          name: 'PBES2Algorithms.encryptionScheme.iv',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: 'encIv'
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: 'pkcs-12PbeParams',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'pkcs-12PbeParams.salt',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'salt'
      }, {
        name: 'pkcs-12PbeParams.iterations',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'iterations'
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || 'aes128';
      var salt = forge.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {
        var ivLen,
            encOid,
            cipherFn;
        switch (options.algorithm) {
          case 'aes128':
            dkLen = 16;
            ivLen = 16;
            encOid = oids['aes128-CBC'];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case 'aes192':
            dkLen = 24;
            ivLen = 16;
            encOid = oids['aes192-CBC'];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case 'aes256':
            dkLen = 32;
            ivLen = 16;
            encOid = oids['aes256-CBC'];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case 'des':
            dkLen = 8;
            ivLen = 8;
            encOid = oids['desCBC'];
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
            error.algorithm = options.algorithm;
            throw error;
        }
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen);
        var iv = forge.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pkcs5PBES2']).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())])]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)])])]);
      } else if (options.algorithm === '3des') {
        dkLen = 24;
        var saltBytes = new forge.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())])]);
      } else {
        var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [encryptionAlgorithm, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error('Cannot read encrypted private key. ' + 'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: 'ENCRYPTED PRIVATE KEY',
        body: asn1.toDer(epki).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'ENCRYPTED PRIVATE KEY') {
        var error = new Error('Could not convert encrypted private key from PEM; ' + 'PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert encrypted private key from PEM; ' + 'PEM is encrypted.');
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case 'aes128':
          algorithm = 'AES-128-CBC';
          dkLen = 16;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case 'aes192':
          algorithm = 'AES-192-CBC';
          dkLen = 24;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case 'aes256':
          algorithm = 'AES-256-CBC';
          dkLen = 32;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case '3des':
          algorithm = 'DES-EDE3-CBC';
          dkLen = 24;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        case 'des':
          algorithm = 'DES-CBC';
          dkLen = 8;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported ' + 'encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: 'RSA PRIVATE KEY',
        procType: {
          version: '4',
          type: 'ENCRYPTED'
        },
        dekInfo: {
          algorithm: algorithm,
          parameters: forge.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'ENCRYPTED PRIVATE KEY' && msg.type !== 'PRIVATE KEY' && msg.type !== 'RSA PRIVATE KEY') {
        var error = new Error('Could not convert private key from PEM; PEM header type ' + 'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case 'DES-CBC':
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case 'DES-EDE3-CBC':
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case 'AES-128-CBC':
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case 'AES-192-CBC':
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case 'AES-256-CBC':
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case 'RC2-40-CBC':
            dkLen = 5;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case 'RC2-64-CBC':
            dkLen = 8;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case 'RC2-128-CBC':
            dkLen = 16;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported ' + 'encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === 'ENCRYPTED PRIVATE KEY') {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j,
          l;
      if (typeof md === 'undefined' || md === null) {
        md = forge.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge.util.ByteBuffer();
      var passBuf = new forge.util.ByteBuffer();
      if (password !== null && password !== undefined) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf = new forge.util.ByteBuffer();
        buf.putBytes(D.bytes());
        buf.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B = new forge.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge.util.ByteBuffer(I.getBytes(v));
          var x = 0x1ff;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 0xff);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids['pkcs5PBES2']:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
        case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');
          error.oid = oid;
          error.supportedOids = ['pkcs5PBES2', 'pbeWithSHAAnd3-KeyTripleDES-CBC', 'pbewithSHAAnd40BitRC2-CBC'];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error('Cannot read password-based-encryption algorithm ' + 'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids['pkcs5PBKDF2']) {
        var error = new Error('Cannot read encrypted private key. ' + 'Unsupported key derivation function OID.');
        error.oid = oid;
        error.supportedOids = ['pkcs5PBKDF2'];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids['aes128-CBC'] && oid !== pki.oids['aes192-CBC'] && oid !== pki.oids['aes256-CBC'] && oid !== pki.oids['des-EDE3-CBC'] && oid !== pki.oids['desCBC']) {
        var error = new Error('Cannot read encrypted private key. ' + 'Unsupported encryption scheme OID.');
        error.oid = oid;
        error.supportedOids = ['aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case 'aes128-CBC':
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case 'aes192-CBC':
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case 'aes256-CBC':
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case 'des-EDE3-CBC':
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case 'desCBC':
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
      }
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error('Cannot read password-based-encryption algorithm ' + 'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
        error.errors = errors;
        throw error;
      }
      var salt = forge.util.createBuffer(capture.salt);
      var count = forge.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen,
          dIvLen,
          cipherFn;
      switch (oid) {
        case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge.des.startDecrypting;
          break;
        case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key, iv) {
            var cipher = forge.rc2.createDecryptionCipher(key, 40);
            cipher.start(iv, null);
            return cipher;
          };
          break;
        default:
          var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');
          error.oid = oid;
          throw error;
      }
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen);
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === 'undefined' || md === null) {
        md = forge.md.md5.create();
      }
      if (salt === null) {
        salt = '';
      }
      var digests = [hash(md, password + salt)];
      for (var length = 16,
          i = 1; length < dkLen; ++i, length += 16) {
        digests.push(hash(md, digests[i - 1] + password + salt));
      }
      return digests.join('').substr(0, dkLen);
    };
    function hash(md, bytes) {
      return md.start().update(bytes).digest().getBytes();
    }
  }
  var name = 'pbe';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pbe.js", ["require", "module", "npm:node-forge@0.6.30/js/aes.js", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/des.js", "npm:node-forge@0.6.30/js/md.js", "npm:node-forge@0.6.30/js/oids.js", "npm:node-forge@0.6.30/js/pem.js", "npm:node-forge@0.6.30/js/pbkdf2.js", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/rc2.js", "npm:node-forge@0.6.30/js/rsa.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames['CN'] = oids['commonName'];
    _shortNames['commonName'] = 'CN';
    _shortNames['C'] = oids['countryName'];
    _shortNames['countryName'] = 'C';
    _shortNames['L'] = oids['localityName'];
    _shortNames['localityName'] = 'L';
    _shortNames['ST'] = oids['stateOrProvinceName'];
    _shortNames['stateOrProvinceName'] = 'ST';
    _shortNames['O'] = oids['organizationName'];
    _shortNames['organizationName'] = 'O';
    _shortNames['OU'] = oids['organizationalUnitName'];
    _shortNames['organizationalUnitName'] = 'OU';
    _shortNames['E'] = oids['emailAddress'];
    _shortNames['emailAddress'] = 'E';
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: 'Certificate',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'Certificate.TBSCertificate',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: 'tbsCertificate',
        value: [{
          name: 'Certificate.TBSCertificate.version',
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          value: [{
            name: 'Certificate.TBSCertificate.version.integer',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: 'certVersion'
          }]
        }, {
          name: 'Certificate.TBSCertificate.serialNumber',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: 'certSerialNumber'
        }, {
          name: 'Certificate.TBSCertificate.signature',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'Certificate.TBSCertificate.signature.algorithm',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: 'certinfoSignatureOid'
          }, {
            name: 'Certificate.TBSCertificate.signature.parameters',
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: 'certinfoSignatureParams'
          }]
        }, {
          name: 'Certificate.TBSCertificate.issuer',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'certIssuer'
        }, {
          name: 'Certificate.TBSCertificate.validity',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'Certificate.TBSCertificate.validity.notBefore (utc)',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: false,
            optional: true,
            capture: 'certValidity1UTCTime'
          }, {
            name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: false,
            optional: true,
            capture: 'certValidity2GeneralizedTime'
          }, {
            name: 'Certificate.TBSCertificate.validity.notAfter (utc)',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: false,
            optional: true,
            capture: 'certValidity3UTCTime'
          }, {
            name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: false,
            optional: true,
            capture: 'certValidity4GeneralizedTime'
          }]
        }, {
          name: 'Certificate.TBSCertificate.subject',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'certSubject'
        }, publicKeyValidator, {
          name: 'Certificate.TBSCertificate.issuerUniqueID',
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          optional: true,
          value: [{
            name: 'Certificate.TBSCertificate.issuerUniqueID.id',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            capture: 'certIssuerUniqueId'
          }]
        }, {
          name: 'Certificate.TBSCertificate.subjectUniqueID',
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          constructed: true,
          optional: true,
          value: [{
            name: 'Certificate.TBSCertificate.subjectUniqueID.id',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            capture: 'certSubjectUniqueId'
          }]
        }, {
          name: 'Certificate.TBSCertificate.extensions',
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 3,
          constructed: true,
          captureAsn1: 'certExtensions',
          optional: true
        }]
      }, {
        name: 'Certificate.signatureAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'Certificate.signatureAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'certSignatureOid'
        }, {
          name: 'Certificate.TBSCertificate.signature.parameters',
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: 'certSignatureParams'
        }]
      }, {
        name: 'Certificate.signatureValue',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        capture: 'certSignature'
      }]
    };
    var rsassaPssParameterValidator = {
      name: 'rsapss',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'rsapss.hashAlgorithm',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: 'hashOid'
          }]
        }]
      }, {
        name: 'rsapss.maskGenAlgorithm',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: 'maskGenOid'
          }, {
            name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: 'maskGenHashOid'
            }]
          }]
        }]
      }, {
        name: 'rsapss.saltLength',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: 'rsapss.saltLength.saltLength',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: 'saltLength'
        }]
      }, {
        name: 'rsapss.trailerField',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: 'rsapss.trailer.trailer',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: 'trailer'
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: 'CertificationRequestInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certificationRequestInfo',
      value: [{
        name: 'CertificationRequestInfo.integer',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'certificationRequestInfoVersion'
      }, {
        name: 'CertificationRequestInfo.subject',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: 'certificationRequestInfoSubject'
      }, publicKeyValidator, {
        name: 'CertificationRequestInfo.attributes',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: 'certificationRequestInfoAttributes',
        value: [{
          name: 'CertificationRequestInfo.attributes',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'CertificationRequestInfo.attributes.type',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false
          }, {
            name: 'CertificationRequestInfo.attributes.value',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true
          }]
        }]
      }]
    };
    var certificationRequestValidator = {
      name: 'CertificationRequest',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'csr',
      value: [certificationRequestInfoValidator, {
        name: 'CertificationRequest.signatureAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'CertificationRequest.signatureAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'csrSignatureOid'
        }, {
          name: 'CertificationRequest.signatureAlgorithm.parameters',
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: 'csrSignatureParams'
        }]
      }, {
        name: 'CertificationRequest.signature',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        capture: 'csrSignature'
      }]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set,
          attr,
          obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i = 0; i < set.value.length; ++i) {
          obj = {};
          attr = set.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === 'string') {
        options = {shortName: options};
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids['RSASSA-PSS']) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {algorithmOid: oids['sha1']},
          mgf: {
            algorithmOid: oids['mgf1'],
            hash: {algorithmOid: oids['sha1']}
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error('Cannot read RSASSA-PSS parameter block.');
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== undefined) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== undefined) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== undefined) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'CERTIFICATE' && msg.type !== 'X509 CERTIFICATE' && msg.type !== 'TRUSTED CERTIFICATE') {
        var error = new Error('Could not convert certificate from PEM; PEM header type ' + 'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert certificate from PEM; PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert, maxline) {
      var msg = {
        type: 'CERTIFICATE',
        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {
        var error = new Error('Could not convert public key from PEM; PEM header ' + 'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert public key from PEM; PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: 'PUBLIC KEY',
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: 'RSA PUBLIC KEY',
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.sha1.create();
      var type = options.type || 'RSAPublicKey';
      var bytes;
      switch (type) {
        case 'RSAPublicKey':
          bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case 'SubjectPublicKeyInfo':
          bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes);
      var digest = md.digest();
      if (options.encoding === 'hex') {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === 'binary') {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'CERTIFICATE REQUEST') {
        var error = new Error('Could not convert certification request from PEM; ' + 'PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert certification request from PEM; ' + 'PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: 'CERTIFICATE REQUEST',
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.createCertificate = function() {
      var cert = {};
      cert.version = 0x02;
      cert.serialNumber = '00';
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], {cert: cert});
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === 'string') {
          options = {name: options};
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
          ext = cert.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];
        if (!algorithmOid) {
          var error = new Error('Could not compute certificate digest. ' + 'Unknown message digest algorithm OID.');
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki.getTBSCertificate(cert);
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error('The parent certificate did not issue the given child ' + 'certificate; the child certificate\'s issuer does not match the ' + 'parent\'s subject.');
          error.expectedIssuer = issuer.attributes;
          error.actualIssuer = subject.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          if (child.signatureOid in oids) {
            var oid = oids[child.signatureOid];
            switch (oid) {
              case 'sha1WithRSAEncryption':
                md = forge.md.sha1.create();
                break;
              case 'md5WithRSAEncryption':
                md = forge.md.md5.create();
                break;
              case 'sha256WithRSAEncryption':
                md = forge.md.sha256.create();
                break;
              case 'RSASSA-PSS':
                md = forge.md.sha256.create();
                break;
            }
          }
          if (md === null) {
            var error = new Error('Could not compute certificate digest. ' + 'Unknown signature OID.');
            error.signatureOid = child.signatureOid;
            throw error;
          }
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes = asn1.toDer(tbsCertificate);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          var scheme;
          switch (child.signatureOid) {
            case oids.sha1WithRSAEncryption:
              scheme = undefined;
              break;
            case oids['RSASSA-PSS']:
              var hash,
                  mgf;
              hash = oids[child.signatureParameters.mgf.hash.algorithmOid];
              if (hash === undefined || forge.md[hash] === undefined) {
                var error = new Error('Unsupported MGF hash function.');
                error.oid = child.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              mgf = oids[child.signatureParameters.mgf.algorithmOid];
              if (mgf === undefined || forge.mgf[mgf] === undefined) {
                var error = new Error('Unsupported MGF function.');
                error.oid = child.signatureParameters.mgf.algorithmOid;
                error.name = mgf;
                throw error;
              }
              mgf = forge.mgf[mgf].create(forge.md[hash].create());
              hash = oids[child.signatureParameters.hash.algorithmOid];
              if (hash === undefined || forge.md[hash] === undefined) {
                throw {
                  message: 'Unsupported RSASSA-PSS hash function.',
                  oid: child.signatureParameters.hash.algorithmOid,
                  name: hash
                };
              }
              scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength);
              break;
          }
          rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i = cert.issuer;
        var s = parent.subject;
        if (i.hash && s.hash) {
          rval = (i.hash === s.hash);
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr,
              sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert.publicKey, {type: 'RSAPublicKey'});
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids['subjectKeyIdentifier'];
        for (var i = 0; i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return (forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski);
          }
        }
        return false;
      };
      return cert;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error('Cannot read X.509 certificate. ' + 'ASN.1 object is not an X509v3 Certificate.');
        error.errors = errors;
        throw error;
      }
      if (typeof capture.certSignature !== 'string') {
        var certSignature = '\x00';
        for (var i = 0; i < capture.certSignature.length; ++i) {
          certSignature += asn1.toDer(capture.certSignature[i]).getBytes();
        }
        capture.certSignature = certSignature;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids['rsaEncryption']) {
        throw new Error('Cannot read public key. OID is not RSA.');
      }
      var cert = pki.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
      cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
      var signature = forge.util.createBuffer(capture.certSignature);
      ++signature.read;
      cert.signature = signature.getBytes();
      var validity = [];
      if (capture.certValidity1UTCTime !== undefined) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== undefined) {
        validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
      }
      if (capture.certValidity3UTCTime !== undefined) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== undefined) {
        validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
      }
      if (validity.length > 2) {
        throw new Error('Cannot read notBefore/notAfter validity times; more ' + 'than two times were provided in the certificate.');
      }
      if (validity.length < 2) {
        throw new Error('Cannot read notBefore/notAfter validity times; they ' + 'were not provided as either UTCTime or GeneralizedTime.');
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = null;
        if (cert.signatureOid in oids) {
          var oid = oids[cert.signatureOid];
          switch (oid) {
            case 'sha1WithRSAEncryption':
              cert.md = forge.md.sha1.create();
              break;
            case 'md5WithRSAEncryption':
              cert.md = forge.md.md5.create();
              break;
            case 'sha256WithRSAEncryption':
              cert.md = forge.md.sha256.create();
              break;
            case 'RSASSA-PSS':
              cert.md = forge.md.sha256.create();
              break;
          }
        }
        if (cert.md === null) {
          var error = new Error('Could not compute certificate digest. ' + 'Unknown signature OID.');
          error.signatureOid = cert.signatureOid;
          throw error;
        }
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
      }
      var imd = forge.md.sha1.create();
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge.md.sha1.create();
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === 'keyUsage') {
          var ev = asn1.fromDer(e.value);
          var b2 = 0x00;
          var b3 = 0x00;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 0x80) === 0x80;
          e.nonRepudiation = (b2 & 0x40) === 0x40;
          e.keyEncipherment = (b2 & 0x20) === 0x20;
          e.dataEncipherment = (b2 & 0x10) === 0x10;
          e.keyAgreement = (b2 & 0x08) === 0x08;
          e.keyCertSign = (b2 & 0x04) === 0x04;
          e.cRLSign = (b2 & 0x02) === 0x02;
          e.encipherOnly = (b2 & 0x01) === 0x01;
          e.decipherOnly = (b3 & 0x80) === 0x80;
        } else if (e.name === 'basicConstraints') {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === 'extKeyUsage') {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === 'nsCertType') {
          var ev = asn1.fromDer(e.value);
          var b2 = 0x00;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 0x80) === 0x80;
          e.server = (b2 & 0x40) === 0x40;
          e.email = (b2 & 0x20) === 0x20;
          e.objsign = (b2 & 0x10) === 0x10;
          e.reserved = (b2 & 0x08) === 0x08;
          e.sslCA = (b2 & 0x04) === 0x04;
          e.emailCA = (b2 & 0x02) === 0x02;
          e.objCA = (b2 & 0x01) === 0x01;
        } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === 'subjectKeyIdentifier') {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#10 certificate request. ' + 'ASN.1 object is not a PKCS#10 CertificationRequest.');
        error.errors = errors;
        throw error;
      }
      if (typeof capture.csrSignature !== 'string') {
        var csrSignature = '\x00';
        for (var i = 0; i < capture.csrSignature.length; ++i) {
          csrSignature += asn1.toDer(capture.csrSignature[i]).getBytes();
        }
        capture.csrSignature = csrSignature;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error('Cannot read public key. OID is not RSA.');
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
      csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
      var signature = forge.util.createBuffer(capture.csrSignature);
      ++signature.read;
      csr.signature = signature.getBytes();
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = null;
        if (csr.signatureOid in oids) {
          var oid = oids[csr.signatureOid];
          switch (oid) {
            case 'sha1WithRSAEncryption':
              csr.md = forge.md.sha1.create();
              break;
            case 'md5WithRSAEncryption':
              csr.md = forge.md.md5.create();
              break;
            case 'sha256WithRSAEncryption':
              csr.md = forge.md.sha256.create();
              break;
            case 'RSASSA-PSS':
              csr.md = forge.md.sha256.create();
              break;
          }
        }
        if (csr.md === null) {
          var error = new Error('Could not compute certification request digest. ' + 'Unknown signature OID.');
          error.signatureOid = csr.signatureOid;
          throw error;
        }
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0x00;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];
        if (!algorithmOid) {
          var error = new Error('Could not compute certification request digest. ' + 'Unknown message digest algorithm OID.');
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          if (csr.signatureOid in oids) {
            var oid = oids[csr.signatureOid];
            switch (oid) {
              case 'sha1WithRSAEncryption':
                md = forge.md.sha1.create();
                break;
              case 'md5WithRSAEncryption':
                md = forge.md.md5.create();
                break;
              case 'sha256WithRSAEncryption':
                md = forge.md.sha256.create();
                break;
              case 'RSASSA-PSS':
                md = forge.md.sha256.create();
                break;
            }
          }
          if (md === null) {
            var error = new Error('Could not compute certification request digest. ' + 'Unknown signature OID.');
            error.signatureOid = csr.signatureOid;
            throw error;
          }
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(cri);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          var scheme;
          switch (csr.signatureOid) {
            case oids.sha1WithRSAEncryption:
              break;
            case oids['RSASSA-PSS']:
              var hash,
                  mgf;
              hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];
              if (hash === undefined || forge.md[hash] === undefined) {
                var error = new Error('Unsupported MGF hash function.');
                error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              mgf = oids[csr.signatureParameters.mgf.algorithmOid];
              if (mgf === undefined || forge.mgf[mgf] === undefined) {
                var error = new Error('Unsupported MGF function.');
                error.oid = csr.signatureParameters.mgf.algorithmOid;
                error.name = mgf;
                throw error;
              }
              mgf = forge.mgf[mgf].create(forge.md[hash].create());
              hash = oids[csr.signatureParameters.hash.algorithmOid];
              if (hash === undefined || forge.md[hash] === undefined) {
                var error = new Error('Unsupported RSASSA-PSS hash function.');
                error.oid = csr.signatureParameters.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength);
              break;
          }
          rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var attr,
          set;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ('valueTagClass' in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)])]);
        rval.value.push(set);
      }
      return rval;
    }
    function _getAttributesAsJson(attrs) {
      var rval = {};
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        if (attr.shortName && (attr.valueTagClass === asn1.Type.UTF8 || attr.valueTagClass === asn1.Type.PRINTABLESTRING || attr.valueTagClass === asn1.Type.IA5STRING)) {
          var value = attr.value;
          if (attr.valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(attr.value);
          }
          if (!(attr.shortName in rval)) {
            rval[attr.shortName] = value;
          } else if (forge.util.isArray(rval[attr.shortName])) {
            rval[attr.shortName].push(value);
          } else {
            rval[attr.shortName] = [rval[attr.shortName], value];
          }
        }
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === 'undefined') {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === 'undefined') {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error('Attribute type not specified.');
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === 'undefined') {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
            }
          }
        }
        if (typeof attr.value === 'undefined') {
          var error = new Error('Attribute value not specified.');
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === 'undefined') {
        if (e.id && e.id in pki.oids) {
          e.name = pki.oids[e.id];
        }
      }
      if (typeof e.id === 'undefined') {
        if (e.name && e.name in pki.oids) {
          e.id = pki.oids[e.name];
        } else {
          var error = new Error('Extension ID not specified.');
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== 'undefined') {
        return;
      }
      if (e.name === 'keyUsage') {
        var unused = 0;
        var b2 = 0x00;
        var b3 = 0x00;
        if (e.digitalSignature) {
          b2 |= 0x80;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 0x40;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 0x20;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 0x10;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 0x08;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 0x04;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 0x02;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 0x01;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 0x80;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
      } else if (e.name === 'basicConstraints') {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        if (e.cA) {
          e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));
        }
        if ('pathLenConstraint' in e) {
          e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
        }
      } else if (e.name === 'extKeyUsage') {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
          } else if (key.indexOf('.') !== -1) {
            seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
          }
        }
      } else if (e.name === 'nsCertType') {
        var unused = 0;
        var b2 = 0x00;
        if (e.client) {
          b2 |= 0x80;
          unused = 7;
        }
        if (e.server) {
          b2 |= 0x40;
          unused = 6;
        }
        if (e.email) {
          b2 |= 0x20;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 0x10;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 0x08;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 0x04;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 0x02;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 0x01;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
      } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
      } else if (e.name === 'subjectKeyIdentifier' && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
      }
      if (typeof e.value === 'undefined') {
        var error = new Error('Extension value not specified.');
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids['RSASSA-PSS']:
          var parts = [];
          if (params.hash.algorithmOid !== undefined) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])]));
          }
          if (params.mgf.algorithmOid !== undefined) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])])]));
          }
          if (params.saltLength !== undefined) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ('valueTagClass' in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ('valueConstructed' in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]);
        rval.value.push(seq);
      }
      return rval;
    }
    pki.getTBSCertificate = function(cert) {
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]), _dnToAsn1(cert.issuer), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(cert.validity.notBefore)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(cert.validity.notAfter))]), _dnToAsn1(cert.subject), pki.publicKeyToAsn1(cert.publicKey)]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.issuer.uniqueId)]));
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.subject.uniqueId)]));
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()), _dnToAsn1(csr.subject), pki.publicKeyToAsn1(csr.publicKey), _CRIAttributesToAsn1(csr)]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [tbsCertificate, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()), _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.signature)]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
      if (ext.critical) {
        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));
      }
      var value = ext.value;
      if (typeof ext.value !== 'string') {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [cri, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()), _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + csr.signature)]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {certs: {}};
      caStore.getIssuer = function(cert) {
        var rval = getBySubject(cert.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert) {
        if (typeof cert === 'string') {
          cert = forge.pki.certificateFromPem(cert);
        }
        if (!cert.subject.hash) {
          var md = forge.md.sha1.create();
          cert.subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(cert.subject), md);
          cert.subject.hash = md.digest().toHex();
        }
        if (cert.subject.hash in caStore.certs) {
          var tmp = caStore.certs[cert.subject.hash];
          if (!forge.util.isArray(tmp)) {
            tmp = [tmp];
          }
          tmp.push(cert);
        } else {
          caStore.certs[cert.subject.hash] = cert;
        }
      };
      caStore.hasCertificate = function(cert) {
        var match = getBySubject(cert.subject);
        if (!match) {
          return false;
        }
        if (!forge.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
        for (var i = 0; i < match.length; ++i) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      function getBySubject(subject) {
        if (!subject.hash) {
          var md = forge.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
        return caStore.certs[subject.hash] || null;
      }
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert = certs[i];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: 'forge.pki.BadCertificate',
      unsupported_certificate: 'forge.pki.UnsupportedCertificate',
      certificate_revoked: 'forge.pki.CertificateRevoked',
      certificate_expired: 'forge.pki.CertificateExpired',
      certificate_unknown: 'forge.pki.CertificateUnknown',
      unknown_ca: 'forge.pki.UnknownCertificateAuthority'
    };
    pki.verifyCertificateChain = function(caStore, chain, verify) {
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var now = new Date();
      var first = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (now < cert.validity.notBefore || now > cert.validity.notAfter) {
          error = {
            message: 'Certificate is not valid yet or has expired.',
            error: pki.certificateError.certificate_expired,
            notBefore: cert.validity.notBefore,
            notAfter: cert.validity.notAfter,
            now: now
          };
        }
        if (error === null) {
          parent = chain[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {}
            }
            if (!verified) {
              error = {
                message: 'Certificate signature is invalid.',
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: 'Certificate is not trusted.',
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent && !cert.isIssuer(parent)) {
          error = {
            message: 'Certificate issuer is invalid.',
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error === null && i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: 'Certificate has an unsupported critical extension.',
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first || (chain.length === 0 && (!parent || selfSigned)))) {
          var bcExt = cert.getExtension('basicConstraints');
          var keyUsageExt = cert.getExtension('keyUsage');
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: 'Certificate keyUsage or basicConstraints conflict ' + 'or indicate that the certificate is not a CA. ' + 'If the certificate is the only one in the chain or ' + 'isn\'t the first then the certificate must be a ' + 'valid CA.',
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: 'Certificate basicConstraints indicates the certificate ' + 'is not a CA.',
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && 'pathLenConstraint' in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: 'Certificate basicConstraints pathLenConstraint violated.',
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = (error === null) ? true : error.error;
        var ret = verify ? verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: 'The application rejected the certificate.',
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === 'object' && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === 'string') {
              error.error = ret;
            }
          }
          throw error;
        }
        first = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
  var name = 'x509';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge.pki;
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/x509.js", ["require", "module", "npm:node-forge@0.6.30/js/aes.js", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/des.js", "npm:node-forge@0.6.30/js/md.js", "npm:node-forge@0.6.30/js/mgf.js", "npm:node-forge@0.6.30/js/oids.js", "npm:node-forge@0.6.30/js/pem.js", "npm:node-forge@0.6.30/js/pss.js", "npm:node-forge@0.6.30/js/rsa.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
System.registerDynamic("github:driftyco/ionic@1.0.0/release/js/ionic-angular.js", ["github:driftyco/ionic@1.0.0/release/js/ionic.js", "github:angular/bower-angular@1.4.1.js", "github:angular/bower-angular-animate@1.4.1.js", "github:angular/bower-angular-sanitize@1.4.1.js", "github:angular-ui/ui-router@0.2.15.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps ./ionic";
    "deps angular";
    "deps angular-animate";
    "deps angular-sanitize";
    "deps angular-ui-router";
    (function() {
      var IonicModule = angular.module('ionic', ['ngAnimate', 'ngSanitize', 'ui.router']),
          extend = angular.extend,
          forEach = angular.forEach,
          isDefined = angular.isDefined,
          isNumber = angular.isNumber,
          isString = angular.isString,
          jqLite = angular.element,
          noop = angular.noop;
      IonicModule.factory('$ionicActionSheet', ['$rootScope', '$compile', '$animate', '$timeout', '$ionicTemplateLoader', '$ionicPlatform', '$ionicBody', 'IONIC_BACK_PRIORITY', function($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody, IONIC_BACK_PRIORITY) {
        return {show: actionSheet};
        function actionSheet(opts) {
          var scope = $rootScope.$new(true);
          extend(scope, {
            cancel: noop,
            destructiveButtonClicked: noop,
            buttonClicked: noop,
            $deregisterBackButton: noop,
            buttons: [],
            cancelOnStateChange: true
          }, opts || {});
          function textForIcon(text) {
            if (text && /icon/.test(text)) {
              scope.$actionSheetHasIcon = true;
            }
          }
          for (var x = 0; x < scope.buttons.length; x++) {
            textForIcon(scope.buttons[x].text);
          }
          textForIcon(scope.cancelText);
          textForIcon(scope.destructiveText);
          var element = scope.element = $compile('<ion-action-sheet ng-class="cssClass" buttons="buttons"></ion-action-sheet>')(scope);
          var sheetEl = jqLite(element[0].querySelector('.action-sheet-wrapper'));
          var stateChangeListenDone = scope.cancelOnStateChange ? $rootScope.$on('$stateChangeSuccess', function() {
            scope.cancel();
          }) : noop;
          scope.removeSheet = function(done) {
            if (scope.removed)
              return;
            scope.removed = true;
            sheetEl.removeClass('action-sheet-up');
            $timeout(function() {
              $ionicBody.removeClass('action-sheet-open');
            }, 400);
            scope.$deregisterBackButton();
            stateChangeListenDone();
            $animate.removeClass(element, 'active').then(function() {
              scope.$destroy();
              element.remove();
              scope.cancel.$scope = sheetEl = null;
              (done || noop)();
            });
          };
          scope.showSheet = function(done) {
            if (scope.removed)
              return;
            $ionicBody.append(element).addClass('action-sheet-open');
            $animate.addClass(element, 'active').then(function() {
              if (scope.removed)
                return;
              (done || noop)();
            });
            $timeout(function() {
              if (scope.removed)
                return;
              sheetEl.addClass('action-sheet-up');
            }, 20, false);
          };
          scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(function() {
            $timeout(scope.cancel);
          }, IONIC_BACK_PRIORITY.actionSheet);
          scope.cancel = function() {
            scope.removeSheet(opts.cancel);
          };
          scope.buttonClicked = function(index) {
            if (opts.buttonClicked(index, opts.buttons[index]) === true) {
              scope.removeSheet();
            }
          };
          scope.destructiveButtonClicked = function() {
            if (opts.destructiveButtonClicked() === true) {
              scope.removeSheet();
            }
          };
          scope.showSheet();
          scope.cancel.$scope = scope;
          return scope.cancel;
        }
      }]);
      jqLite.prototype.addClass = function(cssClasses) {
        var x,
            y,
            cssClass,
            el,
            splitClasses,
            existingClasses;
        if (cssClasses && cssClasses != 'ng-scope' && cssClasses != 'ng-isolate-scope') {
          for (x = 0; x < this.length; x++) {
            el = this[x];
            if (el.setAttribute) {
              if (cssClasses.indexOf(' ') < 0 && el.classList.add) {
                el.classList.add(cssClasses);
              } else {
                existingClasses = (' ' + (el.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
                splitClasses = cssClasses.split(' ');
                for (y = 0; y < splitClasses.length; y++) {
                  cssClass = splitClasses[y].trim();
                  if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                    existingClasses += cssClass + ' ';
                  }
                }
                el.setAttribute('class', existingClasses.trim());
              }
            }
          }
        }
        return this;
      };
      jqLite.prototype.removeClass = function(cssClasses) {
        var x,
            y,
            splitClasses,
            cssClass,
            el;
        if (cssClasses) {
          for (x = 0; x < this.length; x++) {
            el = this[x];
            if (el.getAttribute) {
              if (cssClasses.indexOf(' ') < 0 && el.classList.remove) {
                el.classList.remove(cssClasses);
              } else {
                splitClasses = cssClasses.split(' ');
                for (y = 0; y < splitClasses.length; y++) {
                  cssClass = splitClasses[y];
                  el.setAttribute('class', ((" " + (el.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + cssClass.trim() + " ", " ")).trim());
                }
              }
            }
          }
        }
        return this;
      };
      IonicModule.factory('$ionicBackdrop', ['$document', '$timeout', '$$rAF', function($document, $timeout, $$rAF) {
        var el = jqLite('<div class="backdrop">');
        var backdropHolds = 0;
        $document[0].body.appendChild(el[0]);
        return {
          retain: retain,
          release: release,
          getElement: getElement,
          _element: el
        };
        function retain() {
          backdropHolds++;
          if (backdropHolds === 1) {
            el.addClass('visible');
            $$rAF(function() {
              if (backdropHolds >= 1)
                el.addClass('active');
            });
          }
        }
        function release() {
          if (backdropHolds === 1) {
            el.removeClass('active');
            $timeout(function() {
              if (backdropHolds === 0)
                el.removeClass('visible');
            }, 400, false);
          }
          backdropHolds = Math.max(0, backdropHolds - 1);
        }
        function getElement() {
          return el;
        }
      }]);
      IonicModule.factory('$ionicBind', ['$parse', '$interpolate', function($parse, $interpolate) {
        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
        return function(scope, attrs, bindDefinition) {
          forEach(bindDefinition || {}, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                mode = match[1],
                parentGet,
                unwatch;
            switch (mode) {
              case '@':
                if (!attrs[attrName]) {
                  return;
                }
                attrs.$observe(attrName, function(value) {
                  scope[scopeName] = value;
                });
                if (attrs[attrName]) {
                  scope[scopeName] = $interpolate(attrs[attrName])(scope);
                }
                break;
              case '=':
                if (!attrs[attrName]) {
                  return;
                }
                unwatch = scope.$watch(attrs[attrName], function(value) {
                  scope[scopeName] = value;
                });
                scope.$on('$destroy', unwatch);
                break;
              case '&':
                if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + '\(.*?\)'))) {
                  throw new Error('& expression binding "' + scopeName + '" looks like it will recursively call "' + attrs[attrName] + '" and cause a stack overflow! Please choose a different scopeName.');
                }
                parentGet = $parse(attrs[attrName]);
                scope[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });
        };
      }]);
      IonicModule.factory('$ionicBody', ['$document', function($document) {
        return {
          addClass: function() {
            for (var x = 0; x < arguments.length; x++) {
              $document[0].body.classList.add(arguments[x]);
            }
            return this;
          },
          removeClass: function() {
            for (var x = 0; x < arguments.length; x++) {
              $document[0].body.classList.remove(arguments[x]);
            }
            return this;
          },
          enableClass: function(shouldEnableClass) {
            var args = Array.prototype.slice.call(arguments).slice(1);
            if (shouldEnableClass) {
              this.addClass.apply(this, args);
            } else {
              this.removeClass.apply(this, args);
            }
            return this;
          },
          append: function(ele) {
            $document[0].body.appendChild(ele.length ? ele[0] : ele);
            return this;
          },
          get: function() {
            return $document[0].body;
          }
        };
      }]);
      IonicModule.factory('$ionicClickBlock', ['$document', '$ionicBody', '$timeout', function($document, $ionicBody, $timeout) {
        var CSS_HIDE = 'click-block-hide';
        var cbEle,
            fallbackTimer,
            pendingShow;
        function preventClick(ev) {
          ev.preventDefault();
          ev.stopPropagation();
        }
        function addClickBlock() {
          if (pendingShow) {
            if (cbEle) {
              cbEle.classList.remove(CSS_HIDE);
            } else {
              cbEle = $document[0].createElement('div');
              cbEle.className = 'click-block';
              $ionicBody.append(cbEle);
              cbEle.addEventListener('touchstart', preventClick);
              cbEle.addEventListener('mousedown', preventClick);
            }
            pendingShow = false;
          }
        }
        function removeClickBlock() {
          cbEle && cbEle.classList.add(CSS_HIDE);
        }
        return {
          show: function(autoExpire) {
            pendingShow = true;
            $timeout.cancel(fallbackTimer);
            fallbackTimer = $timeout(this.hide, autoExpire || 310, false);
            addClickBlock();
          },
          hide: function() {
            pendingShow = false;
            $timeout.cancel(fallbackTimer);
            removeClickBlock();
          }
        };
      }]);
      IonicModule.factory('$ionicGesture', [function() {
        return {
          on: function(eventType, cb, $element, options) {
            return window.ionic.onGesture(eventType, cb, $element[0], options);
          },
          off: function(gesture, eventType, cb) {
            return window.ionic.offGesture(gesture, eventType, cb);
          }
        };
      }]);
      IonicModule.factory('$ionicHistory', ['$rootScope', '$state', '$location', '$window', '$timeout', '$ionicViewSwitcher', '$ionicNavViewDelegate', function($rootScope, $state, $location, $window, $timeout, $ionicViewSwitcher, $ionicNavViewDelegate) {
        var ACTION_INITIAL_VIEW = 'initialView';
        var ACTION_NEW_VIEW = 'newView';
        var ACTION_MOVE_BACK = 'moveBack';
        var ACTION_MOVE_FORWARD = 'moveForward';
        var DIRECTION_BACK = 'back';
        var DIRECTION_FORWARD = 'forward';
        var DIRECTION_ENTER = 'enter';
        var DIRECTION_EXIT = 'exit';
        var DIRECTION_SWAP = 'swap';
        var DIRECTION_NONE = 'none';
        var stateChangeCounter = 0;
        var lastStateId,
            nextViewOptions,
            nextViewExpireTimer,
            forcedNav;
        var viewHistory = {
          histories: {root: {
              historyId: 'root',
              parentHistoryId: null,
              stack: [],
              cursor: -1
            }},
          views: {},
          backView: null,
          forwardView: null,
          currentView: null
        };
        var View = function() {};
        View.prototype.initialize = function(data) {
          if (data) {
            for (var name in data)
              this[name] = data[name];
            return this;
          }
          return null;
        };
        View.prototype.go = function() {
          if (this.stateName) {
            return $state.go(this.stateName, this.stateParams);
          }
          if (this.url && this.url !== $location.url()) {
            if (viewHistory.backView === this) {
              return $window.history.go(-1);
            } else if (viewHistory.forwardView === this) {
              return $window.history.go(1);
            }
            $location.url(this.url);
          }
          return null;
        };
        View.prototype.destroy = function() {
          if (this.scope) {
            this.scope.$destroy && this.scope.$destroy();
            this.scope = null;
          }
        };
        function getViewById(viewId) {
          return (viewId ? viewHistory.views[viewId] : null);
        }
        function getBackView(view) {
          return (view ? getViewById(view.backViewId) : null);
        }
        function getForwardView(view) {
          return (view ? getViewById(view.forwardViewId) : null);
        }
        function getHistoryById(historyId) {
          return (historyId ? viewHistory.histories[historyId] : null);
        }
        function getHistory(scope) {
          var histObj = getParentHistoryObj(scope);
          if (!viewHistory.histories[histObj.historyId]) {
            viewHistory.histories[histObj.historyId] = {
              historyId: histObj.historyId,
              parentHistoryId: getParentHistoryObj(histObj.scope.$parent).historyId,
              stack: [],
              cursor: -1
            };
          }
          return getHistoryById(histObj.historyId);
        }
        function getParentHistoryObj(scope) {
          var parentScope = scope;
          while (parentScope) {
            if (parentScope.hasOwnProperty('$historyId')) {
              return {
                historyId: parentScope.$historyId,
                scope: parentScope
              };
            }
            parentScope = parentScope.$parent;
          }
          return {
            historyId: 'root',
            scope: $rootScope
          };
        }
        function setNavViews(viewId) {
          viewHistory.currentView = getViewById(viewId);
          viewHistory.backView = getBackView(viewHistory.currentView);
          viewHistory.forwardView = getForwardView(viewHistory.currentView);
        }
        function getCurrentStateId() {
          var id;
          if ($state && $state.current && $state.current.name) {
            id = $state.current.name;
            if ($state.params) {
              for (var key in $state.params) {
                if ($state.params.hasOwnProperty(key) && $state.params[key]) {
                  id += "_" + key + "=" + $state.params[key];
                }
              }
            }
            return id;
          }
          return ionic.Utils.nextUid();
        }
        function getCurrentStateParams() {
          var rtn;
          if ($state && $state.params) {
            for (var key in $state.params) {
              if ($state.params.hasOwnProperty(key)) {
                rtn = rtn || {};
                rtn[key] = $state.params[key];
              }
            }
          }
          return rtn;
        }
        return {
          register: function(parentScope, viewLocals) {
            var currentStateId = getCurrentStateId(),
                hist = getHistory(parentScope),
                currentView = viewHistory.currentView,
                backView = viewHistory.backView,
                forwardView = viewHistory.forwardView,
                viewId = null,
                action = null,
                direction = DIRECTION_NONE,
                historyId = hist.historyId,
                url = $location.url(),
                tmp,
                x,
                ele;
            if (lastStateId !== currentStateId) {
              lastStateId = currentStateId;
              stateChangeCounter++;
            }
            if (forcedNav) {
              viewId = forcedNav.viewId;
              action = forcedNav.action;
              direction = forcedNav.direction;
              forcedNav = null;
            } else if (backView && backView.stateId === currentStateId) {
              viewId = backView.viewId;
              historyId = backView.historyId;
              action = ACTION_MOVE_BACK;
              if (backView.historyId === currentView.historyId) {
                direction = DIRECTION_BACK;
              } else if (currentView) {
                direction = DIRECTION_EXIT;
                tmp = getHistoryById(backView.historyId);
                if (tmp && tmp.parentHistoryId === currentView.historyId) {
                  direction = DIRECTION_ENTER;
                } else {
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  }
                }
              }
            } else if (forwardView && forwardView.stateId === currentStateId) {
              viewId = forwardView.viewId;
              historyId = forwardView.historyId;
              action = ACTION_MOVE_FORWARD;
              if (forwardView.historyId === currentView.historyId) {
                direction = DIRECTION_FORWARD;
              } else if (currentView) {
                direction = DIRECTION_EXIT;
                if (currentView.historyId === hist.parentHistoryId) {
                  direction = DIRECTION_ENTER;
                } else {
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  }
                }
              }
              tmp = getParentHistoryObj(parentScope);
              if (forwardView.historyId && tmp.scope) {
                tmp.scope.$historyId = forwardView.historyId;
                historyId = forwardView.historyId;
              }
            } else if (currentView && currentView.historyId !== historyId && hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length && hist.stack[hist.cursor].stateId === currentStateId) {
              var switchToView = hist.stack[hist.cursor];
              viewId = switchToView.viewId;
              historyId = switchToView.historyId;
              action = ACTION_MOVE_BACK;
              direction = DIRECTION_SWAP;
              tmp = getHistoryById(currentView.historyId);
              if (tmp && tmp.parentHistoryId === historyId) {
                direction = DIRECTION_EXIT;
              } else {
                tmp = getHistoryById(historyId);
                if (tmp && tmp.parentHistoryId === currentView.historyId) {
                  direction = DIRECTION_ENTER;
                }
              }
              tmp = getViewById(switchToView.backViewId);
              if (tmp && switchToView.historyId !== tmp.historyId) {
                hist.stack[hist.cursor].backViewId = currentView.viewId;
              }
            } else {
              ele = $ionicViewSwitcher.createViewEle(viewLocals);
              if (this.isAbstractEle(ele, viewLocals)) {
                void 0;
                return {
                  action: 'abstractView',
                  direction: DIRECTION_NONE,
                  ele: ele
                };
              }
              viewId = ionic.Utils.nextUid();
              if (currentView) {
                currentView.forwardViewId = viewId;
                action = ACTION_NEW_VIEW;
                if (forwardView && currentView.stateId !== forwardView.stateId && currentView.historyId === forwardView.historyId) {
                  tmp = getHistoryById(forwardView.historyId);
                  if (tmp) {
                    for (x = tmp.stack.length - 1; x >= forwardView.index; x--) {
                      var stackItem = tmp.stack[x];
                      stackItem && stackItem.destroy && stackItem.destroy();
                      tmp.stack.splice(x);
                    }
                    historyId = forwardView.historyId;
                  }
                }
                if (hist.historyId === currentView.historyId) {
                  direction = DIRECTION_FORWARD;
                } else if (currentView.historyId !== hist.historyId) {
                  direction = DIRECTION_ENTER;
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  } else {
                    tmp = getHistoryById(tmp.parentHistoryId);
                    if (tmp && tmp.historyId === hist.historyId) {
                      direction = DIRECTION_EXIT;
                    }
                  }
                }
              } else {
                action = ACTION_INITIAL_VIEW;
              }
              if (stateChangeCounter < 2) {
                direction = DIRECTION_NONE;
              }
              viewHistory.views[viewId] = this.createView({
                viewId: viewId,
                index: hist.stack.length,
                historyId: hist.historyId,
                backViewId: (currentView && currentView.viewId ? currentView.viewId : null),
                forwardViewId: null,
                stateId: currentStateId,
                stateName: this.currentStateName(),
                stateParams: getCurrentStateParams(),
                url: url,
                canSwipeBack: canSwipeBack(ele, viewLocals)
              });
              hist.stack.push(viewHistory.views[viewId]);
            }
            $timeout.cancel(nextViewExpireTimer);
            if (nextViewOptions) {
              if (nextViewOptions.disableAnimate)
                direction = DIRECTION_NONE;
              if (nextViewOptions.disableBack)
                viewHistory.views[viewId].backViewId = null;
              if (nextViewOptions.historyRoot) {
                for (x = 0; x < hist.stack.length; x++) {
                  if (hist.stack[x].viewId === viewId) {
                    hist.stack[x].index = 0;
                    hist.stack[x].backViewId = hist.stack[x].forwardViewId = null;
                  } else {
                    delete viewHistory.views[hist.stack[x].viewId];
                  }
                }
                hist.stack = [viewHistory.views[viewId]];
              }
              nextViewOptions = null;
            }
            setNavViews(viewId);
            if (viewHistory.backView && historyId == viewHistory.backView.historyId && currentStateId == viewHistory.backView.stateId && url == viewHistory.backView.url) {
              for (x = 0; x < hist.stack.length; x++) {
                if (hist.stack[x].viewId == viewId) {
                  action = 'dupNav';
                  direction = DIRECTION_NONE;
                  if (x > 0) {
                    hist.stack[x - 1].forwardViewId = null;
                  }
                  viewHistory.forwardView = null;
                  viewHistory.currentView.index = viewHistory.backView.index;
                  viewHistory.currentView.backViewId = viewHistory.backView.backViewId;
                  viewHistory.backView = getBackView(viewHistory.backView);
                  hist.stack.splice(x, 1);
                  break;
                }
              }
            }
            void 0;
            hist.cursor = viewHistory.currentView.index;
            return {
              viewId: viewId,
              action: action,
              direction: direction,
              historyId: historyId,
              enableBack: this.enabledBack(viewHistory.currentView),
              isHistoryRoot: (viewHistory.currentView.index === 0),
              ele: ele
            };
          },
          registerHistory: function(scope) {
            scope.$historyId = ionic.Utils.nextUid();
          },
          createView: function(data) {
            var newView = new View();
            return newView.initialize(data);
          },
          getViewById: getViewById,
          viewHistory: function() {
            return viewHistory;
          },
          currentView: function(view) {
            if (arguments.length) {
              viewHistory.currentView = view;
            }
            return viewHistory.currentView;
          },
          currentHistoryId: function() {
            return viewHistory.currentView ? viewHistory.currentView.historyId : null;
          },
          currentTitle: function(val) {
            if (viewHistory.currentView) {
              if (arguments.length) {
                viewHistory.currentView.title = val;
              }
              return viewHistory.currentView.title;
            }
          },
          backView: function(view) {
            if (arguments.length) {
              viewHistory.backView = view;
            }
            return viewHistory.backView;
          },
          backTitle: function(view) {
            var backView = (view && getViewById(view.backViewId)) || viewHistory.backView;
            return backView && backView.title;
          },
          forwardView: function(view) {
            if (arguments.length) {
              viewHistory.forwardView = view;
            }
            return viewHistory.forwardView;
          },
          currentStateName: function() {
            return ($state && $state.current ? $state.current.name : null);
          },
          isCurrentStateNavView: function(navView) {
            return !!($state && $state.current && $state.current.views && $state.current.views[navView]);
          },
          goToHistoryRoot: function(historyId) {
            if (historyId) {
              var hist = getHistoryById(historyId);
              if (hist && hist.stack.length) {
                if (viewHistory.currentView && viewHistory.currentView.viewId === hist.stack[0].viewId) {
                  return;
                }
                forcedNav = {
                  viewId: hist.stack[0].viewId,
                  action: ACTION_MOVE_BACK,
                  direction: DIRECTION_BACK
                };
                hist.stack[0].go();
              }
            }
          },
          goBack: function(backCount) {
            if (isDefined(backCount) && backCount !== -1) {
              if (backCount > -1)
                return;
              var currentHistory = viewHistory.histories[this.currentHistoryId()];
              var newCursor = currentHistory.cursor + backCount + 1;
              if (newCursor < 1) {
                newCursor = 1;
              }
              currentHistory.cursor = newCursor;
              setNavViews(currentHistory.stack[newCursor].viewId);
              var cursor = newCursor - 1;
              var clearStateIds = [];
              var fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
              while (fwdView) {
                clearStateIds.push(fwdView.stateId || fwdView.viewId);
                cursor++;
                if (cursor >= currentHistory.stack.length)
                  break;
                fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
              }
              var self = this;
              if (clearStateIds.length) {
                $timeout(function() {
                  self.clearCache(clearStateIds);
                }, 600);
              }
            }
            viewHistory.backView && viewHistory.backView.go();
          },
          enabledBack: function(view) {
            var backView = getBackView(view);
            return !!(backView && backView.historyId === view.historyId);
          },
          clearHistory: function() {
            var histories = viewHistory.histories,
                currentView = viewHistory.currentView;
            if (histories) {
              for (var historyId in histories) {
                if (histories[historyId].stack) {
                  histories[historyId].stack = [];
                  histories[historyId].cursor = -1;
                }
                if (currentView && currentView.historyId === historyId) {
                  currentView.backViewId = currentView.forwardViewId = null;
                  histories[historyId].stack.push(currentView);
                } else if (histories[historyId].destroy) {
                  histories[historyId].destroy();
                }
              }
            }
            for (var viewId in viewHistory.views) {
              if (viewId !== currentView.viewId) {
                delete viewHistory.views[viewId];
              }
            }
            if (currentView) {
              setNavViews(currentView.viewId);
            }
          },
          clearCache: function(stateIds) {
            $timeout(function() {
              $ionicNavViewDelegate._instances.forEach(function(instance) {
                instance.clearCache(stateIds);
              });
            });
          },
          nextViewOptions: function(opts) {
            if (arguments.length) {
              $timeout.cancel(nextViewExpireTimer);
              if (opts === null) {
                nextViewOptions = opts;
              } else {
                nextViewOptions = nextViewOptions || {};
                extend(nextViewOptions, opts);
                if (nextViewOptions.expire) {
                  nextViewExpireTimer = $timeout(function() {
                    nextViewOptions = null;
                  }, nextViewOptions.expire);
                }
              }
            }
            return nextViewOptions;
          },
          isAbstractEle: function(ele, viewLocals) {
            if (viewLocals && viewLocals.$$state && viewLocals.$$state.self['abstract']) {
              return true;
            }
            return !!(ele && (isAbstractTag(ele) || isAbstractTag(ele.children())));
          },
          isActiveScope: function(scope) {
            if (!scope)
              return false;
            var climbScope = scope;
            var currentHistoryId = this.currentHistoryId();
            var foundHistoryId;
            while (climbScope) {
              if (climbScope.$$disconnected) {
                return false;
              }
              if (!foundHistoryId && climbScope.hasOwnProperty('$historyId')) {
                foundHistoryId = true;
              }
              if (currentHistoryId) {
                if (climbScope.hasOwnProperty('$historyId') && currentHistoryId == climbScope.$historyId) {
                  return true;
                }
                if (climbScope.hasOwnProperty('$activeHistoryId')) {
                  if (currentHistoryId == climbScope.$activeHistoryId) {
                    if (climbScope.hasOwnProperty('$historyId')) {
                      return true;
                    }
                    if (!foundHistoryId) {
                      return true;
                    }
                  }
                }
              }
              if (foundHistoryId && climbScope.hasOwnProperty('$activeHistoryId')) {
                foundHistoryId = false;
              }
              climbScope = climbScope.$parent;
            }
            return currentHistoryId ? currentHistoryId == 'root' : true;
          }
        };
        function isAbstractTag(ele) {
          return ele && ele.length && /ion-side-menus|ion-tabs/i.test(ele[0].tagName);
        }
        function canSwipeBack(ele, viewLocals) {
          if (viewLocals && viewLocals.$$state && viewLocals.$$state.self.canSwipeBack === false) {
            return false;
          }
          if (ele && ele.attr('can-swipe-back') === 'false') {
            return false;
          }
          return true;
        }
      }]).run(['$rootScope', '$state', '$location', '$document', '$ionicPlatform', '$ionicHistory', 'IONIC_BACK_PRIORITY', function($rootScope, $state, $location, $document, $ionicPlatform, $ionicHistory, IONIC_BACK_PRIORITY) {
        $rootScope.$on('$ionicView.beforeEnter', function() {
          ionic.keyboard && ionic.keyboard.hide && ionic.keyboard.hide();
        });
        $rootScope.$on('$ionicHistory.change', function(e, data) {
          if (!data)
            return null;
          var viewHistory = $ionicHistory.viewHistory();
          var hist = (data.historyId ? viewHistory.histories[data.historyId] : null);
          if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {
            var view = hist.stack[hist.cursor];
            return view.go(data);
          }
          if (!data.url && data.uiSref) {
            data.url = $state.href(data.uiSref);
          }
          if (data.url) {
            if (data.url.indexOf('#') === 0) {
              data.url = data.url.replace('#', '');
            }
            if (data.url !== $location.url()) {
              $location.url(data.url);
            }
          }
        });
        $rootScope.$ionicGoBack = function(backCount) {
          $ionicHistory.goBack(backCount);
        };
        $rootScope.$on('$ionicView.afterEnter', function(ev, data) {
          if (data && data.title) {
            $document[0].title = data.title;
          }
        });
        function onHardwareBackButton(e) {
          var backView = $ionicHistory.backView();
          if (backView) {
            backView.go();
          } else {
            ionic.Platform.exitApp();
          }
          e.preventDefault();
          return false;
        }
        $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.view);
      }]);
      IonicModule.provider('$ionicConfig', function() {
        var provider = this;
        provider.platform = {};
        var PLATFORM = 'platform';
        var configProperties = {
          views: {
            maxCache: PLATFORM,
            forwardCache: PLATFORM,
            transition: PLATFORM,
            swipeBackEnabled: PLATFORM,
            swipeBackHitWidth: PLATFORM
          },
          navBar: {
            alignTitle: PLATFORM,
            positionPrimaryButtons: PLATFORM,
            positionSecondaryButtons: PLATFORM,
            transition: PLATFORM
          },
          backButton: {
            icon: PLATFORM,
            text: PLATFORM,
            previousTitleText: PLATFORM
          },
          form: {
            checkbox: PLATFORM,
            toggle: PLATFORM
          },
          scrolling: {jsScrolling: PLATFORM},
          tabs: {
            style: PLATFORM,
            position: PLATFORM
          },
          templates: {maxPrefetch: PLATFORM},
          platform: {}
        };
        createConfig(configProperties, provider, '');
        setPlatformConfig('default', {
          views: {
            maxCache: 10,
            forwardCache: false,
            transition: 'ios',
            swipeBackEnabled: true,
            swipeBackHitWidth: 45
          },
          navBar: {
            alignTitle: 'center',
            positionPrimaryButtons: 'left',
            positionSecondaryButtons: 'right',
            transition: 'view'
          },
          backButton: {
            icon: 'ion-ios-arrow-back',
            text: 'Back',
            previousTitleText: true
          },
          form: {
            checkbox: 'circle',
            toggle: 'large'
          },
          scrolling: {jsScrolling: true},
          tabs: {
            style: 'standard',
            position: 'bottom'
          },
          templates: {maxPrefetch: 30}
        });
        setPlatformConfig('ios', {});
        setPlatformConfig('android', {
          views: {
            transition: 'android',
            swipeBackEnabled: false
          },
          navBar: {
            alignTitle: 'left',
            positionPrimaryButtons: 'right',
            positionSecondaryButtons: 'right'
          },
          backButton: {
            icon: 'ion-android-arrow-back',
            text: false,
            previousTitleText: false
          },
          form: {
            checkbox: 'square',
            toggle: 'small'
          },
          tabs: {
            style: 'striped',
            position: 'top'
          }
        });
        setPlatformConfig('windowsphone', {});
        provider.transitions = {
          views: {},
          navBar: {}
        };
        provider.transitions.views.ios = function(enteringEle, leavingEle, direction, shouldAnimate) {
          function setStyles(ele, opacity, x, boxShadowOpacity) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
            css.opacity = opacity;
            if (boxShadowOpacity > -1) {
              css.boxShadow = '0 0 10px rgba(0,0,0,' + (d.shouldAnimate ? boxShadowOpacity * 0.45 : 0.3) + ')';
            }
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
            ionic.DomUtil.cachedStyles(ele, css);
          }
          var d = {
            run: function(step) {
              if (direction == 'forward') {
                setStyles(enteringEle, 1, (1 - step) * 99, 1 - step);
                setStyles(leavingEle, (1 - 0.1 * step), step * -33, -1);
              } else if (direction == 'back') {
                setStyles(enteringEle, (1 - 0.1 * (1 - step)), (1 - step) * -33, -1);
                setStyles(leavingEle, 1, step * 100, 1 - step);
              } else {
                setStyles(enteringEle, 1, 0, -1);
                setStyles(leavingEle, 0, 0, -1);
              }
            },
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
          return d;
        };
        provider.transitions.navBar.ios = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
          function setStyles(ctrl, opacity, titleX, backTextX) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : '0ms';
            css.opacity = opacity === 1 ? '' : opacity;
            ctrl.setCss('buttons-left', css);
            ctrl.setCss('buttons-right', css);
            ctrl.setCss('back-button', css);
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + backTextX + 'px,0,0)';
            ctrl.setCss('back-text', css);
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + titleX + 'px,0,0)';
            ctrl.setCss('title', css);
          }
          function enter(ctrlA, ctrlB, step) {
            if (!ctrlA || !ctrlB)
              return;
            var titleX = (ctrlA.titleTextX() + ctrlA.titleWidth()) * (1 - step);
            var backTextX = (ctrlB && (ctrlB.titleTextX() - ctrlA.backButtonTextLeft()) * (1 - step)) || 0;
            setStyles(ctrlA, step, titleX, backTextX);
          }
          function leave(ctrlA, ctrlB, step) {
            if (!ctrlA || !ctrlB)
              return;
            var titleX = (-(ctrlA.titleTextX() - ctrlB.backButtonTextLeft()) - (ctrlA.titleLeftRight())) * step;
            setStyles(ctrlA, 1 - step, titleX, 0);
          }
          var d = {
            run: function(step) {
              var enteringHeaderCtrl = enteringHeaderBar.controller();
              var leavingHeaderCtrl = leavingHeaderBar && leavingHeaderBar.controller();
              if (d.direction == 'back') {
                leave(enteringHeaderCtrl, leavingHeaderCtrl, 1 - step);
                enter(leavingHeaderCtrl, enteringHeaderCtrl, 1 - step);
              } else {
                enter(enteringHeaderCtrl, leavingHeaderCtrl, step);
                leave(leavingHeaderCtrl, enteringHeaderCtrl, step);
              }
            },
            direction: direction,
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
          return d;
        };
        provider.transitions.views.android = function(enteringEle, leavingEle, direction, shouldAnimate) {
          shouldAnimate = shouldAnimate && (direction == 'forward' || direction == 'back');
          function setStyles(ele, x) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
            ionic.DomUtil.cachedStyles(ele, css);
          }
          var d = {
            run: function(step) {
              if (direction == 'forward') {
                setStyles(enteringEle, (1 - step) * 99);
                setStyles(leavingEle, step * -100);
              } else if (direction == 'back') {
                setStyles(enteringEle, (1 - step) * -100);
                setStyles(leavingEle, step * 100);
              } else {
                setStyles(enteringEle, 0);
                setStyles(leavingEle, 0);
              }
            },
            shouldAnimate: shouldAnimate
          };
          return d;
        };
        provider.transitions.navBar.android = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
          function setStyles(ctrl, opacity) {
            if (!ctrl)
              return;
            var css = {};
            css.opacity = opacity === 1 ? '' : opacity;
            ctrl.setCss('buttons-left', css);
            ctrl.setCss('buttons-right', css);
            ctrl.setCss('back-button', css);
            ctrl.setCss('back-text', css);
            ctrl.setCss('title', css);
          }
          return {
            run: function(step) {
              setStyles(enteringHeaderBar.controller(), step);
              setStyles(leavingHeaderBar && leavingHeaderBar.controller(), 1 - step);
            },
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
        };
        provider.transitions.views.none = function(enteringEle, leavingEle) {
          return {
            run: function(step) {
              provider.transitions.views.android(enteringEle, leavingEle, false, false).run(step);
            },
            shouldAnimate: false
          };
        };
        provider.transitions.navBar.none = function(enteringHeaderBar, leavingHeaderBar) {
          return {
            run: function(step) {
              provider.transitions.navBar.ios(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
              provider.transitions.navBar.android(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
            },
            shouldAnimate: false
          };
        };
        function setPlatformConfig(platformName, platformConfigs) {
          configProperties.platform[platformName] = platformConfigs;
          provider.platform[platformName] = {};
          addConfig(configProperties, configProperties.platform[platformName]);
          createConfig(configProperties.platform[platformName], provider.platform[platformName], '');
        }
        function addConfig(configObj, platformObj) {
          for (var n in configObj) {
            if (n != PLATFORM && configObj.hasOwnProperty(n)) {
              if (angular.isObject(configObj[n])) {
                if (!isDefined(platformObj[n])) {
                  platformObj[n] = {};
                }
                addConfig(configObj[n], platformObj[n]);
              } else if (!isDefined(platformObj[n])) {
                platformObj[n] = null;
              }
            }
          }
        }
        function createConfig(configObj, providerObj, platformPath) {
          forEach(configObj, function(value, namespace) {
            if (angular.isObject(configObj[namespace])) {
              providerObj[namespace] = {};
              createConfig(configObj[namespace], providerObj[namespace], platformPath + '.' + namespace);
            } else {
              providerObj[namespace] = function(newValue) {
                if (arguments.length) {
                  configObj[namespace] = newValue;
                  return providerObj;
                }
                if (configObj[namespace] == PLATFORM) {
                  var platformConfig = stringObj(configProperties.platform, ionic.Platform.platform() + platformPath + '.' + namespace);
                  if (platformConfig || platformConfig === false) {
                    return platformConfig;
                  }
                  return stringObj(configProperties.platform, 'default' + platformPath + '.' + namespace);
                }
                return configObj[namespace];
              };
            }
          });
        }
        function stringObj(obj, str) {
          str = str.split(".");
          for (var i = 0; i < str.length; i++) {
            if (obj && isDefined(obj[str[i]])) {
              obj = obj[str[i]];
            } else {
              return null;
            }
          }
          return obj;
        }
        provider.setPlatformConfig = setPlatformConfig;
        provider.$get = function() {
          return provider;
        };
      }).config(['$compileProvider', function($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|tel|ftp|mailto|file|ghttps?|ms-appx|x-wmapp0):/);
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|tel|ftp|file|blob|ms-appx|x-wmapp0):|data:image\//);
      }]);
      var LOADING_TPL = '<div class="loading-container">' + '<div class="loading">' + '</div>' + '</div>';
      var LOADING_HIDE_DEPRECATED = '$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().';
      var LOADING_SHOW_DEPRECATED = '$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().';
      var LOADING_SET_DEPRECATED = '$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: \'my content\' }).';
      IonicModule.constant('$ionicLoadingConfig', {template: '<ion-spinner></ion-spinner>'}).factory('$ionicLoading', ['$ionicLoadingConfig', '$ionicBody', '$ionicTemplateLoader', '$ionicBackdrop', '$timeout', '$q', '$log', '$compile', '$ionicPlatform', '$rootScope', 'IONIC_BACK_PRIORITY', function($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform, $rootScope, IONIC_BACK_PRIORITY) {
        var loaderInstance;
        var deregisterBackAction = noop;
        var deregisterStateListener1 = noop;
        var deregisterStateListener2 = noop;
        var loadingShowDelay = $q.when();
        return {
          show: showLoader,
          hide: hideLoader,
          _getLoader: getLoader
        };
        function getLoader() {
          if (!loaderInstance) {
            loaderInstance = $ionicTemplateLoader.compile({
              template: LOADING_TPL,
              appendTo: $ionicBody.get()
            }).then(function(self) {
              self.show = function(options) {
                var templatePromise = options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : $q.when(options.template || options.content || '');
                self.scope = options.scope || self.scope;
                if (!self.isShown) {
                  self.hasBackdrop = !options.noBackdrop && options.showBackdrop !== false;
                  if (self.hasBackdrop) {
                    $ionicBackdrop.retain();
                    $ionicBackdrop.getElement().addClass('backdrop-loading');
                  }
                }
                if (options.duration) {
                  $timeout.cancel(self.durationTimeout);
                  self.durationTimeout = $timeout(angular.bind(self, self.hide), +options.duration);
                }
                deregisterBackAction();
                deregisterBackAction = $ionicPlatform.registerBackButtonAction(noop, IONIC_BACK_PRIORITY.loading);
                templatePromise.then(function(html) {
                  if (html) {
                    var loading = self.element.children();
                    loading.html(html);
                    $compile(loading.contents())(self.scope);
                  }
                  if (self.isShown) {
                    self.element.addClass('visible');
                    ionic.requestAnimationFrame(function() {
                      if (self.isShown) {
                        self.element.addClass('active');
                        $ionicBody.addClass('loading-active');
                      }
                    });
                  }
                });
                self.isShown = true;
              };
              self.hide = function() {
                deregisterBackAction();
                if (self.isShown) {
                  if (self.hasBackdrop) {
                    $ionicBackdrop.release();
                    $ionicBackdrop.getElement().removeClass('backdrop-loading');
                  }
                  self.element.removeClass('active');
                  $ionicBody.removeClass('loading-active');
                  setTimeout(function() {
                    !self.isShown && self.element.removeClass('visible');
                  }, 200);
                }
                $timeout.cancel(self.durationTimeout);
                self.isShown = false;
              };
              return self;
            });
          }
          return loaderInstance;
        }
        function showLoader(options) {
          options = extend({}, $ionicLoadingConfig || {}, options || {});
          var delay = options.delay || options.showDelay || 0;
          deregisterStateListener1();
          deregisterStateListener2();
          if (options.hideOnStateChange) {
            deregisterStateListener1 = $rootScope.$on('$stateChangeSuccess', hideLoader);
            deregisterStateListener2 = $rootScope.$on('$stateChangeError', hideLoader);
          }
          $timeout.cancel(loadingShowDelay);
          loadingShowDelay = $timeout(noop, delay);
          loadingShowDelay.then(getLoader).then(function(loader) {
            return loader.show(options);
          });
          return {
            hide: function deprecatedHide() {
              $log.error(LOADING_HIDE_DEPRECATED);
              return hideLoader.apply(this, arguments);
            },
            show: function deprecatedShow() {
              $log.error(LOADING_SHOW_DEPRECATED);
              return showLoader.apply(this, arguments);
            },
            setContent: function deprecatedSetContent(content) {
              $log.error(LOADING_SET_DEPRECATED);
              return getLoader().then(function(loader) {
                loader.show({template: content});
              });
            }
          };
        }
        function hideLoader() {
          deregisterStateListener1();
          deregisterStateListener2();
          $timeout.cancel(loadingShowDelay);
          getLoader().then(function(loader) {
            loader.hide();
          });
        }
      }]);
      IonicModule.factory('$ionicModal', ['$rootScope', '$ionicBody', '$compile', '$timeout', '$ionicPlatform', '$ionicTemplateLoader', '$$q', '$log', '$ionicClickBlock', '$window', 'IONIC_BACK_PRIORITY', function($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $$q, $log, $ionicClickBlock, $window, IONIC_BACK_PRIORITY) {
        var ModalView = ionic.views.Modal.inherit({
          initialize: function(opts) {
            ionic.views.Modal.prototype.initialize.call(this, opts);
            this.animation = opts.animation || 'slide-in-up';
          },
          show: function(target) {
            var self = this;
            if (self.scope.$$destroyed) {
              $log.error('Cannot call ' + self.viewType + '.show() after remove(). Please create a new ' + self.viewType + ' instance.');
              return $$q.when();
            }
            $ionicClickBlock.show(600);
            var modalEl = jqLite(self.modalEl);
            self.el.classList.remove('hide');
            $timeout(function() {
              if (!self._isShown)
                return;
              $ionicBody.addClass(self.viewType + '-open');
            }, 400, false);
            if (!self.el.parentElement) {
              modalEl.addClass(self.animation);
              $ionicBody.append(self.el);
            }
            var scrollCtrl = modalEl.data('$$ionicScrollController');
            scrollCtrl && scrollCtrl.resize();
            if (target && self.positionView) {
              self.positionView(target, modalEl);
              self._onWindowResize = function() {
                if (self._isShown)
                  self.positionView(target, modalEl);
              };
              ionic.on('resize', self._onWindowResize, window);
            }
            modalEl.addClass('ng-enter active').removeClass('ng-leave ng-leave-active');
            self._isShown = true;
            self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(self.hardwareBackButtonClose ? angular.bind(self, self.hide) : noop, IONIC_BACK_PRIORITY.modal);
            ionic.views.Modal.prototype.show.call(self);
            $timeout(function() {
              if (!self._isShown)
                return;
              modalEl.addClass('ng-enter-active');
              ionic.trigger('resize');
              self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.shown', self);
              self.el.classList.add('active');
              self.scope.$broadcast('$ionicHeader.align');
            }, 20);
            return $timeout(function() {
              if (!self._isShown)
                return;
              self.$el.on('click', function(e) {
                if (self.backdropClickToClose && e.target === self.el) {
                  self.hide();
                }
              });
            }, 400);
          },
          hide: function() {
            var self = this;
            var modalEl = jqLite(self.modalEl);
            $ionicClickBlock.show(600);
            self.el.classList.remove('active');
            modalEl.addClass('ng-leave');
            $timeout(function() {
              if (self._isShown)
                return;
              modalEl.addClass('ng-leave-active').removeClass('ng-enter ng-enter-active active');
            }, 20, false);
            self.$el.off('click');
            self._isShown = false;
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.hidden', self);
            self._deregisterBackButton && self._deregisterBackButton();
            ionic.views.Modal.prototype.hide.call(self);
            if (self.positionView) {
              ionic.off('resize', self._onWindowResize, window);
            }
            return $timeout(function() {
              $ionicBody.removeClass(self.viewType + '-open');
              self.el.classList.add('hide');
            }, self.hideDelay || 320);
          },
          remove: function() {
            var self = this;
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.removed', self);
            return self.hide().then(function() {
              self.scope.$destroy();
              self.$el.remove();
            });
          },
          isShown: function() {
            return !!this._isShown;
          }
        });
        var createModal = function(templateString, options) {
          var scope = options.scope && options.scope.$new() || $rootScope.$new(true);
          options.viewType = options.viewType || 'modal';
          extend(scope, {
            $hasHeader: false,
            $hasSubheader: false,
            $hasFooter: false,
            $hasSubfooter: false,
            $hasTabs: false,
            $hasTabsTop: false
          });
          var element = $compile('<ion-' + options.viewType + '>' + templateString + '</ion-' + options.viewType + '>')(scope);
          options.$el = element;
          options.el = element[0];
          options.modalEl = options.el.querySelector('.' + options.viewType);
          var modal = new ModalView(options);
          modal.scope = scope;
          if (!options.scope) {
            scope[options.viewType] = modal;
          }
          return modal;
        };
        return {
          fromTemplate: function(templateString, options) {
            var modal = createModal(templateString, options || {});
            return modal;
          },
          fromTemplateUrl: function(url, options, _) {
            var cb;
            if (angular.isFunction(options)) {
              cb = options;
              options = _;
            }
            return $ionicTemplateLoader.load(url).then(function(templateString) {
              var modal = createModal(templateString, options || {});
              cb && cb(modal);
              return modal;
            });
          }
        };
      }]);
      IonicModule.service('$ionicNavBarDelegate', ionic.DelegateService(['align', 'showBackButton', 'showBar', 'title', 'changeTitle', 'setTitle', 'getTitle', 'back', 'getPreviousTitle']));
      IonicModule.service('$ionicNavViewDelegate', ionic.DelegateService(['clearCache']));
      IonicModule.constant('IONIC_BACK_PRIORITY', {
        view: 100,
        sideMenu: 150,
        modal: 200,
        actionSheet: 300,
        popup: 400,
        loading: 500
      }).provider('$ionicPlatform', function() {
        return {$get: ['$q', function($q) {
            var self = {
              onHardwareBackButton: function(cb) {
                ionic.Platform.ready(function() {
                  document.addEventListener('backbutton', cb, false);
                });
              },
              offHardwareBackButton: function(fn) {
                ionic.Platform.ready(function() {
                  document.removeEventListener('backbutton', fn);
                });
              },
              $backButtonActions: {},
              registerBackButtonAction: function(fn, priority, actionId) {
                if (!self._hasBackButtonHandler) {
                  self.$backButtonActions = {};
                  self.onHardwareBackButton(self.hardwareBackButtonClick);
                  self._hasBackButtonHandler = true;
                }
                var action = {
                  id: (actionId ? actionId : ionic.Utils.nextUid()),
                  priority: (priority ? priority : 0),
                  fn: fn
                };
                self.$backButtonActions[action.id] = action;
                return function() {
                  delete self.$backButtonActions[action.id];
                };
              },
              hardwareBackButtonClick: function(e) {
                var priorityAction,
                    actionId;
                for (actionId in self.$backButtonActions) {
                  if (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) {
                    priorityAction = self.$backButtonActions[actionId];
                  }
                }
                if (priorityAction) {
                  priorityAction.fn(e);
                  return priorityAction;
                }
              },
              is: function(type) {
                return ionic.Platform.is(type);
              },
              on: function(type, cb) {
                ionic.Platform.ready(function() {
                  document.addEventListener(type, cb, false);
                });
                return function() {
                  ionic.Platform.ready(function() {
                    document.removeEventListener(type, cb);
                  });
                };
              },
              ready: function(cb) {
                var q = $q.defer();
                ionic.Platform.ready(function() {
                  q.resolve();
                  cb && cb();
                });
                return q.promise;
              }
            };
            return self;
          }]};
      });
      IonicModule.factory('$ionicPopover', ['$ionicModal', '$ionicPosition', '$document', '$window', function($ionicModal, $ionicPosition, $document, $window) {
        var POPOVER_BODY_PADDING = 6;
        var POPOVER_OPTIONS = {
          viewType: 'popover',
          hideDelay: 1,
          animation: 'none',
          positionView: positionView
        };
        function positionView(target, popoverEle) {
          var targetEle = jqLite(target.target || target);
          var buttonOffset = $ionicPosition.offset(targetEle);
          var popoverWidth = popoverEle.prop('offsetWidth');
          var popoverHeight = popoverEle.prop('offsetHeight');
          var bodyWidth = $window.innerWidth;
          var bodyHeight = $window.innerHeight;
          var popoverCSS = {left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2};
          var arrowEle = jqLite(popoverEle[0].querySelector('.popover-arrow'));
          if (popoverCSS.left < POPOVER_BODY_PADDING) {
            popoverCSS.left = POPOVER_BODY_PADDING;
          } else if (popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth) {
            popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING;
          }
          if (buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight && buttonOffset.top - popoverHeight > 0) {
            popoverCSS.top = buttonOffset.top - popoverHeight;
            popoverEle.addClass('popover-bottom');
          } else {
            popoverCSS.top = buttonOffset.top + buttonOffset.height;
            popoverEle.removeClass('popover-bottom');
          }
          arrowEle.css({left: buttonOffset.left + buttonOffset.width / 2 - arrowEle.prop('offsetWidth') / 2 - popoverCSS.left + 'px'});
          popoverEle.css({
            top: popoverCSS.top + 'px',
            left: popoverCSS.left + 'px',
            marginLeft: '0',
            opacity: '1'
          });
        }
        return {
          fromTemplate: function(templateString, options) {
            return $ionicModal.fromTemplate(templateString, ionic.Utils.extend(POPOVER_OPTIONS, options || {}));
          },
          fromTemplateUrl: function(url, options) {
            return $ionicModal.fromTemplateUrl(url, ionic.Utils.extend(POPOVER_OPTIONS, options || {}));
          }
        };
      }]);
      var POPUP_TPL = '<div class="popup-container" ng-class="cssClass">' + '<div class="popup">' + '<div class="popup-head">' + '<h3 class="popup-title" ng-bind-html="title"></h3>' + '<h5 class="popup-sub-title" ng-bind-html="subTitle" ng-if="subTitle"></h5>' + '</div>' + '<div class="popup-body">' + '</div>' + '<div class="popup-buttons" ng-show="buttons.length">' + '<button ng-repeat="button in buttons" ng-click="$buttonTapped(button, $event)" class="button" ng-class="button.type || \'button-default\'" ng-bind-html="button.text"></button>' + '</div>' + '</div>' + '</div>';
      IonicModule.factory('$ionicPopup', ['$ionicTemplateLoader', '$ionicBackdrop', '$q', '$timeout', '$rootScope', '$ionicBody', '$compile', '$ionicPlatform', 'IONIC_BACK_PRIORITY', function($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform, IONIC_BACK_PRIORITY) {
        var config = {stackPushDelay: 75};
        var popupStack = [];
        var $ionicPopup = {
          show: showPopup,
          alert: showAlert,
          confirm: showConfirm,
          prompt: showPrompt,
          _createPopup: createPopup,
          _popupStack: popupStack
        };
        return $ionicPopup;
        function createPopup(options) {
          options = extend({
            scope: null,
            title: '',
            buttons: []
          }, options || {});
          var self = {};
          self.scope = (options.scope || $rootScope).$new();
          self.element = jqLite(POPUP_TPL);
          self.responseDeferred = $q.defer();
          $ionicBody.get().appendChild(self.element[0]);
          $compile(self.element)(self.scope);
          extend(self.scope, {
            title: options.title,
            buttons: options.buttons,
            subTitle: options.subTitle,
            cssClass: options.cssClass,
            $buttonTapped: function(button, event) {
              var result = (button.onTap || noop)(event);
              event = event.originalEvent || event;
              if (!event.defaultPrevented) {
                self.responseDeferred.resolve(result);
              }
            }
          });
          $q.when(options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : (options.template || options.content || '')).then(function(template) {
            var popupBody = jqLite(self.element[0].querySelector('.popup-body'));
            if (template) {
              popupBody.html(template);
              $compile(popupBody.contents())(self.scope);
            } else {
              popupBody.remove();
            }
          });
          self.show = function() {
            if (self.isShown || self.removed)
              return;
            self.isShown = true;
            ionic.requestAnimationFrame(function() {
              if (!self.isShown)
                return;
              self.element.removeClass('popup-hidden');
              self.element.addClass('popup-showing active');
              focusInput(self.element);
            });
          };
          self.hide = function(callback) {
            callback = callback || noop;
            if (!self.isShown)
              return callback();
            self.isShown = false;
            self.element.removeClass('active');
            self.element.addClass('popup-hidden');
            $timeout(callback, 250, false);
          };
          self.remove = function() {
            if (self.removed)
              return;
            self.hide(function() {
              self.element.remove();
              self.scope.$destroy();
            });
            self.removed = true;
          };
          return self;
        }
        function onHardwareBackButton() {
          var last = popupStack[popupStack.length - 1];
          last && last.responseDeferred.resolve();
        }
        function showPopup(options) {
          var popup = $ionicPopup._createPopup(options);
          var showDelay = 0;
          if (popupStack.length > 0) {
            popupStack[popupStack.length - 1].hide();
            showDelay = config.stackPushDelay;
          } else {
            $ionicBody.addClass('popup-open');
            $ionicBackdrop.retain();
            $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.popup);
          }
          popup.responseDeferred.promise.close = function popupClose(result) {
            if (!popup.removed)
              popup.responseDeferred.resolve(result);
          };
          popup.responseDeferred.notify({close: popup.responseDeferred.close});
          doShow();
          return popup.responseDeferred.promise;
          function doShow() {
            popupStack.push(popup);
            $timeout(popup.show, showDelay, false);
            popup.responseDeferred.promise.then(function(result) {
              var index = popupStack.indexOf(popup);
              if (index !== -1) {
                popupStack.splice(index, 1);
              }
              if (popupStack.length > 0) {
                popupStack[popupStack.length - 1].show();
              } else {
                $ionicBackdrop.release();
                $timeout(function() {
                  if (!popupStack.length) {
                    $ionicBody.removeClass('popup-open');
                  }
                }, 400, false);
                ($ionicPopup._backButtonActionDone || noop)();
              }
              popup.remove();
              return result;
            });
          }
        }
        function focusInput(element) {
          var focusOn = element[0].querySelector('[autofocus]');
          if (focusOn) {
            focusOn.focus();
          }
        }
        function showAlert(opts) {
          return showPopup(extend({buttons: [{
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return true;
              }
            }]}, opts || {}));
        }
        function showConfirm(opts) {
          return showPopup(extend({buttons: [{
              text: opts.cancelText || 'Cancel',
              type: opts.cancelType || 'button-default',
              onTap: function() {
                return false;
              }
            }, {
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return true;
              }
            }]}, opts || {}));
        }
        function showPrompt(opts) {
          var scope = $rootScope.$new(true);
          scope.data = {};
          var text = '';
          if (opts.template && /<[a-z][\s\S]*>/i.test(opts.template) === false) {
            text = '<span>' + opts.template + '</span>';
            delete opts.template;
          }
          return showPopup(extend({
            template: text + '<input ng-model="data.response" type="' + (opts.inputType || 'text') + '" placeholder="' + (opts.inputPlaceholder || '') + '">',
            scope: scope,
            buttons: [{
              text: opts.cancelText || 'Cancel',
              type: opts.cancelType || 'button-default',
              onTap: function() {}
            }, {
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return scope.data.response || '';
              }
            }]
          }, opts || {}));
        }
      }]);
      IonicModule.factory('$ionicPosition', ['$document', '$window', function($document, $window) {
        function getStyle(el, cssprop) {
          if (el.currentStyle) {
            return el.currentStyle[cssprop];
          } else if ($window.getComputedStyle) {
            return $window.getComputedStyle(el)[cssprop];
          }
          return el.style[cssprop];
        }
        function isStaticPositioned(element) {
          return (getStyle(element, 'position') || 'static') === 'static';
        }
        var parentOffsetEl = function(element) {
          var docDomEl = $document[0];
          var offsetParent = element.offsetParent || docDomEl;
          while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || docDomEl;
        };
        return {
          position: function(element) {
            var elBCR = this.offset(element);
            var offsetParentBCR = {
              top: 0,
              left: 0
            };
            var offsetParentEl = parentOffsetEl(element[0]);
            if (offsetParentEl != $document[0]) {
              offsetParentBCR = this.offset(jqLite(offsetParentEl));
              offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
              offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
            }
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
              width: boundingClientRect.width || element.prop('offsetWidth'),
              height: boundingClientRect.height || element.prop('offsetHeight'),
              top: elBCR.top - offsetParentBCR.top,
              left: elBCR.left - offsetParentBCR.left
            };
          },
          offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
              width: boundingClientRect.width || element.prop('offsetWidth'),
              height: boundingClientRect.height || element.prop('offsetHeight'),
              top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
              left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
          }
        };
      }]);
      IonicModule.service('$ionicScrollDelegate', ionic.DelegateService(['resize', 'scrollTop', 'scrollBottom', 'scrollTo', 'scrollBy', 'zoomTo', 'zoomBy', 'getScrollPosition', 'anchorScroll', 'freezeScroll', 'freezeAllScrolls', 'getScrollView']));
      IonicModule.service('$ionicSideMenuDelegate', ionic.DelegateService(['toggleLeft', 'toggleRight', 'getOpenRatio', 'isOpen', 'isOpenLeft', 'isOpenRight', 'canDragContent', 'edgeDragThreshold']));
      IonicModule.service('$ionicSlideBoxDelegate', ionic.DelegateService(['update', 'slide', 'select', 'enableSlide', 'previous', 'next', 'stop', 'autoPlay', 'start', 'currentIndex', 'selected', 'slidesCount', 'count', 'loop']));
      IonicModule.service('$ionicTabsDelegate', ionic.DelegateService(['select', 'selectedIndex']));
      (function() {
        var templatesToCache = [];
        IonicModule.factory('$ionicTemplateCache', ['$http', '$templateCache', '$timeout', function($http, $templateCache, $timeout) {
          var toCache = templatesToCache,
              hasRun;
          function $ionicTemplateCache(templates) {
            if (typeof templates === 'undefined') {
              return run();
            }
            if (isString(templates)) {
              templates = [templates];
            }
            forEach(templates, function(template) {
              toCache.push(template);
            });
            if (hasRun) {
              run();
            }
          }
          function run() {
            var template;
            $ionicTemplateCache._runCount++;
            hasRun = true;
            if (toCache.length === 0)
              return;
            var i = 0;
            while (i < 4 && (template = toCache.pop())) {
              if (isString(template))
                $http.get(template, {cache: $templateCache});
              i++;
            }
            if (toCache.length) {
              $timeout(run, 1000);
            }
          }
          $ionicTemplateCache._runCount = 0;
          return $ionicTemplateCache;
        }]).config(['$stateProvider', '$ionicConfigProvider', function($stateProvider, $ionicConfigProvider) {
          var stateProviderState = $stateProvider.state;
          $stateProvider.state = function(stateName, definition) {
            if (typeof definition === 'object') {
              var enabled = definition.prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
              if (enabled && isString(definition.templateUrl))
                templatesToCache.push(definition.templateUrl);
              if (angular.isObject(definition.views)) {
                for (var key in definition.views) {
                  enabled = definition.views[key].prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
                  if (enabled && isString(definition.views[key].templateUrl))
                    templatesToCache.push(definition.views[key].templateUrl);
                }
              }
            }
            return stateProviderState.call($stateProvider, stateName, definition);
          };
        }]).run(['$ionicTemplateCache', function($ionicTemplateCache) {
          $ionicTemplateCache();
        }]);
      })();
      IonicModule.factory('$ionicTemplateLoader', ['$compile', '$controller', '$http', '$q', '$rootScope', '$templateCache', function($compile, $controller, $http, $q, $rootScope, $templateCache) {
        return {
          load: fetchTemplate,
          compile: loadAndCompile
        };
        function fetchTemplate(url) {
          return $http.get(url, {cache: $templateCache}).then(function(response) {
            return response.data && response.data.trim();
          });
        }
        function loadAndCompile(options) {
          options = extend({
            template: '',
            templateUrl: '',
            scope: null,
            controller: null,
            locals: {},
            appendTo: null
          }, options || {});
          var templatePromise = options.templateUrl ? this.load(options.templateUrl) : $q.when(options.template);
          return templatePromise.then(function(template) {
            var controller;
            var scope = options.scope || $rootScope.$new();
            var element = jqLite('<div>').html(template).contents();
            if (options.controller) {
              controller = $controller(options.controller, extend(options.locals, {$scope: scope}));
              element.children().data('$ngControllerController', controller);
            }
            if (options.appendTo) {
              jqLite(options.appendTo).append(element);
            }
            $compile(element)(scope);
            return {
              element: element,
              scope: scope
            };
          });
        }
      }]);
      IonicModule.factory('$ionicViewService', ['$ionicHistory', '$log', function($ionicHistory, $log) {
        function warn(oldMethod, newMethod) {
          $log.warn('$ionicViewService' + oldMethod + ' is deprecated, please use $ionicHistory' + newMethod + ' instead: http://ionicframework.com/docs/nightly/api/service/$ionicHistory/');
        }
        warn('', '');
        var methodsMap = {
          getCurrentView: 'currentView',
          getBackView: 'backView',
          getForwardView: 'forwardView',
          getCurrentStateName: 'currentStateName',
          nextViewOptions: 'nextViewOptions',
          clearHistory: 'clearHistory'
        };
        forEach(methodsMap, function(newMethod, oldMethod) {
          methodsMap[oldMethod] = function() {
            warn('.' + oldMethod, '.' + newMethod);
            return $ionicHistory[newMethod].apply(this, arguments);
          };
        });
        return methodsMap;
      }]);
      IonicModule.factory('$ionicViewSwitcher', ['$timeout', '$document', '$q', '$ionicClickBlock', '$ionicConfig', '$ionicNavBarDelegate', function($timeout, $document, $q, $ionicClickBlock, $ionicConfig, $ionicNavBarDelegate) {
        var TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
        var DATA_NO_CACHE = '$noCache';
        var DATA_DESTROY_ELE = '$destroyEle';
        var DATA_ELE_IDENTIFIER = '$eleId';
        var DATA_VIEW_ACCESSED = '$accessed';
        var DATA_FALLBACK_TIMER = '$fallbackTimer';
        var DATA_VIEW = '$viewData';
        var NAV_VIEW_ATTR = 'nav-view';
        var VIEW_STATUS_ACTIVE = 'active';
        var VIEW_STATUS_CACHED = 'cached';
        var VIEW_STATUS_STAGED = 'stage';
        var transitionCounter = 0;
        var nextTransition,
            nextDirection;
        ionic.transition = ionic.transition || {};
        ionic.transition.isActive = false;
        var isActiveTimer;
        var cachedAttr = ionic.DomUtil.cachedAttr;
        var transitionPromises = [];
        var defaultTimeout = 1100;
        var ionicViewSwitcher = {
          create: function(navViewCtrl, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
            var enteringEle,
                leavingEle;
            var transitionId = ++transitionCounter;
            var alreadyInDom;
            var switcher = {
              init: function(registerData, callback) {
                ionicViewSwitcher.isTransitioning(true);
                switcher.loadViewElements(registerData);
                switcher.render(registerData, function() {
                  callback && callback();
                });
              },
              loadViewElements: function(registerData) {
                var x,
                    l,
                    viewEle;
                var viewElements = navViewCtrl.getViewElements();
                var enteringEleIdentifier = getViewElementIdentifier(viewLocals, enteringView);
                var navViewActiveEleId = navViewCtrl.activeEleId();
                for (x = 0, l = viewElements.length; x < l; x++) {
                  viewEle = viewElements.eq(x);
                  if (viewEle.data(DATA_ELE_IDENTIFIER) === enteringEleIdentifier) {
                    if (viewEle.data(DATA_NO_CACHE)) {
                      viewEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier + ionic.Utils.nextUid());
                      viewEle.data(DATA_DESTROY_ELE, true);
                    } else {
                      enteringEle = viewEle;
                    }
                  } else if (isDefined(navViewActiveEleId) && viewEle.data(DATA_ELE_IDENTIFIER) === navViewActiveEleId) {
                    leavingEle = viewEle;
                  }
                  if (enteringEle && leavingEle)
                    break;
                }
                alreadyInDom = !!enteringEle;
                if (!alreadyInDom) {
                  enteringEle = registerData.ele || ionicViewSwitcher.createViewEle(viewLocals);
                  enteringEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier);
                }
                if (renderEnd) {
                  navViewCtrl.activeEleId(enteringEleIdentifier);
                }
                registerData.ele = null;
              },
              render: function(registerData, callback) {
                if (alreadyInDom) {
                  ionic.Utils.reconnectScope(enteringEle.scope());
                } else {
                  navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                  var enteringData = getTransitionData(viewLocals, enteringEle, registerData.direction, enteringView);
                  var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                  transitionFn(enteringEle, null, enteringData.direction, true).run(0);
                  enteringEle.data(DATA_VIEW, {
                    viewId: enteringData.viewId,
                    historyId: enteringData.historyId,
                    stateName: enteringData.stateName,
                    stateParams: enteringData.stateParams
                  });
                  if (viewState(viewLocals).cache === false || viewState(viewLocals).cache === 'false' || enteringEle.attr('cache-view') == 'false' || $ionicConfig.views.maxCache() === 0) {
                    enteringEle.data(DATA_NO_CACHE, true);
                  }
                  var viewScope = navViewCtrl.appendViewElement(enteringEle, viewLocals);
                  delete enteringData.direction;
                  delete enteringData.transition;
                  viewScope.$emit('$ionicView.loaded', enteringData);
                }
                enteringEle.data(DATA_VIEW_ACCESSED, Date.now());
                callback && callback();
              },
              transition: function(direction, enableBack, allowAnimate) {
                var deferred;
                var enteringData = getTransitionData(viewLocals, enteringEle, direction, enteringView);
                var leavingData = extend(extend({}, enteringData), getViewData(leavingView));
                enteringData.transitionId = leavingData.transitionId = transitionId;
                enteringData.fromCache = !!alreadyInDom;
                enteringData.enableBack = !!enableBack;
                enteringData.renderStart = renderStart;
                enteringData.renderEnd = renderEnd;
                cachedAttr(enteringEle.parent(), 'nav-view-transition', enteringData.transition);
                cachedAttr(enteringEle.parent(), 'nav-view-direction', enteringData.direction);
                $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                var viewTransition = transitionFn(enteringEle, leavingEle, enteringData.direction, enteringData.shouldAnimate && allowAnimate && renderEnd);
                if (viewTransition.shouldAnimate) {
                  enteringEle.on(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                  enteringEle.data(DATA_FALLBACK_TIMER, $timeout(transitionComplete, defaultTimeout));
                  $ionicClickBlock.show(defaultTimeout);
                }
                if (renderStart) {
                  switcher.emit('before', enteringData, leavingData);
                  navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                  viewTransition.run(0);
                }
                if (renderEnd) {
                  deferred = $q.defer();
                  transitionPromises.push(deferred.promise);
                }
                if (renderStart && renderEnd) {
                  $timeout(onReflow, 16);
                } else if (!renderEnd) {
                  navViewAttr(enteringEle, 'entering');
                  navViewAttr(leavingEle, 'leaving');
                  return {
                    run: viewTransition.run,
                    cancel: function(shouldAnimate) {
                      if (shouldAnimate) {
                        enteringEle.on(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                        enteringEle.data(DATA_FALLBACK_TIMER, $timeout(cancelTransition, defaultTimeout));
                        $ionicClickBlock.show(defaultTimeout);
                      } else {
                        cancelTransition();
                      }
                      viewTransition.shouldAnimate = shouldAnimate;
                      viewTransition.run(0);
                      viewTransition = null;
                    }
                  };
                } else if (renderEnd) {
                  onReflow();
                }
                function onReflow() {
                  navViewAttr(enteringEle, viewTransition.shouldAnimate ? 'entering' : VIEW_STATUS_ACTIVE);
                  navViewAttr(leavingEle, viewTransition.shouldAnimate ? 'leaving' : VIEW_STATUS_CACHED);
                  viewTransition.run(1);
                  $ionicNavBarDelegate._instances.forEach(function(instance) {
                    instance.triggerTransitionStart(transitionId);
                  });
                  if (!viewTransition.shouldAnimate) {
                    transitionComplete();
                  }
                }
                function completeOnTransitionEnd(ev) {
                  if (ev.target !== this)
                    return;
                  transitionComplete();
                }
                function transitionComplete() {
                  if (transitionComplete.x)
                    return;
                  transitionComplete.x = true;
                  enteringEle.off(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                  $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                  leavingEle && $timeout.cancel(leavingEle.data(DATA_FALLBACK_TIMER));
                  switcher.emit('after', enteringData, leavingData);
                  deferred && deferred.resolve(navViewCtrl);
                  if (transitionId === transitionCounter) {
                    $q.all(transitionPromises).then(ionicViewSwitcher.transitionEnd);
                    switcher.cleanup(enteringData);
                  }
                  $ionicNavBarDelegate._instances.forEach(function(instance) {
                    instance.triggerTransitionEnd();
                  });
                  nextTransition = nextDirection = enteringView = leavingView = enteringEle = leavingEle = null;
                }
                function cancelOnTransitionEnd(ev) {
                  if (ev.target !== this)
                    return;
                  cancelTransition();
                }
                function cancelTransition() {
                  navViewAttr(enteringEle, VIEW_STATUS_CACHED);
                  navViewAttr(leavingEle, VIEW_STATUS_ACTIVE);
                  enteringEle.off(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                  $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                  ionicViewSwitcher.transitionEnd([navViewCtrl]);
                }
              },
              emit: function(step, enteringData, leavingData) {
                var scope = enteringEle.scope();
                if (scope) {
                  scope.$emit('$ionicView.' + step + 'Enter', enteringData);
                  if (step == 'after') {
                    scope.$emit('$ionicView.enter', enteringData);
                  }
                }
                if (leavingEle) {
                  scope = leavingEle.scope();
                  if (scope) {
                    scope.$emit('$ionicView.' + step + 'Leave', leavingData);
                    if (step == 'after') {
                      scope.$emit('$ionicView.leave', leavingData);
                    }
                  }
                } else if (scope && leavingData && leavingData.viewId) {
                  scope.$emit('$ionicNavView.' + step + 'Leave', leavingData);
                  if (step == 'after') {
                    scope.$emit('$ionicNavView.leave', leavingData);
                  }
                }
              },
              cleanup: function(transData) {
                if (leavingEle && transData.direction == 'back' && !$ionicConfig.views.forwardCache()) {
                  destroyViewEle(leavingEle);
                }
                var viewElements = navViewCtrl.getViewElements();
                var viewElementsLength = viewElements.length;
                var x,
                    viewElement;
                var removeOldestAccess = (viewElementsLength - 1) > $ionicConfig.views.maxCache();
                var removableEle;
                var oldestAccess = Date.now();
                for (x = 0; x < viewElementsLength; x++) {
                  viewElement = viewElements.eq(x);
                  if (removeOldestAccess && viewElement.data(DATA_VIEW_ACCESSED) < oldestAccess) {
                    oldestAccess = viewElement.data(DATA_VIEW_ACCESSED);
                    removableEle = viewElements.eq(x);
                  } else if (viewElement.data(DATA_DESTROY_ELE) && navViewAttr(viewElement) != VIEW_STATUS_ACTIVE) {
                    destroyViewEle(viewElement);
                  }
                }
                destroyViewEle(removableEle);
                if (enteringEle.data(DATA_NO_CACHE)) {
                  enteringEle.data(DATA_DESTROY_ELE, true);
                }
              },
              enteringEle: function() {
                return enteringEle;
              },
              leavingEle: function() {
                return leavingEle;
              }
            };
            return switcher;
          },
          transitionEnd: function(navViewCtrls) {
            forEach(navViewCtrls, function(navViewCtrl) {
              navViewCtrl.transitionEnd();
            });
            ionicViewSwitcher.isTransitioning(false);
            $ionicClickBlock.hide();
            transitionPromises = [];
          },
          nextTransition: function(val) {
            nextTransition = val;
          },
          nextDirection: function(val) {
            nextDirection = val;
          },
          isTransitioning: function(val) {
            if (arguments.length) {
              ionic.transition.isActive = !!val;
              $timeout.cancel(isActiveTimer);
              if (val) {
                isActiveTimer = $timeout(function() {
                  ionicViewSwitcher.isTransitioning(false);
                }, 999);
              }
            }
            return ionic.transition.isActive;
          },
          createViewEle: function(viewLocals) {
            var containerEle = $document[0].createElement('div');
            if (viewLocals && viewLocals.$template) {
              containerEle.innerHTML = viewLocals.$template;
              if (containerEle.children.length === 1) {
                containerEle.children[0].classList.add('pane');
                return jqLite(containerEle.children[0]);
              }
            }
            containerEle.className = "pane";
            return jqLite(containerEle);
          },
          viewEleIsActive: function(viewEle, isActiveAttr) {
            navViewAttr(viewEle, isActiveAttr ? VIEW_STATUS_ACTIVE : VIEW_STATUS_CACHED);
          },
          getTransitionData: getTransitionData,
          navViewAttr: navViewAttr,
          destroyViewEle: destroyViewEle
        };
        return ionicViewSwitcher;
        function getViewElementIdentifier(locals, view) {
          if (viewState(locals)['abstract'])
            return viewState(locals).name;
          if (view)
            return view.stateId || view.viewId;
          return ionic.Utils.nextUid();
        }
        function viewState(locals) {
          return locals && locals.$$state && locals.$$state.self || {};
        }
        function getTransitionData(viewLocals, enteringEle, direction, view) {
          var state = viewState(viewLocals);
          var viewTransition = nextTransition || cachedAttr(enteringEle, 'view-transition') || state.viewTransition || $ionicConfig.views.transition() || 'ios';
          var navBarTransition = $ionicConfig.navBar.transition();
          direction = nextDirection || cachedAttr(enteringEle, 'view-direction') || state.viewDirection || direction || 'none';
          return extend(getViewData(view), {
            transition: viewTransition,
            navBarTransition: navBarTransition === 'view' ? viewTransition : navBarTransition,
            direction: direction,
            shouldAnimate: (viewTransition !== 'none' && direction !== 'none')
          });
        }
        function getViewData(view) {
          view = view || {};
          return {
            viewId: view.viewId,
            historyId: view.historyId,
            stateId: view.stateId,
            stateName: view.stateName,
            stateParams: view.stateParams
          };
        }
        function navViewAttr(ele, value) {
          if (arguments.length > 1) {
            cachedAttr(ele, NAV_VIEW_ATTR, value);
          } else {
            return cachedAttr(ele, NAV_VIEW_ATTR);
          }
        }
        function destroyViewEle(ele) {
          if (ele && ele.length) {
            var viewScope = ele.scope();
            if (viewScope) {
              viewScope.$emit('$ionicView.unloaded', ele.data(DATA_VIEW));
              viewScope.$destroy();
            }
            ele.remove();
          }
        }
      }]);
      IonicModule.config(['$provide', function($provide) {
        $provide.decorator('$compile', ['$delegate', function($compile) {
          $compile.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          };
          return $compile;
        }]);
      }]);
      IonicModule.config(['$provide', function($provide) {
        function $LocationDecorator($location, $timeout) {
          $location.__hash = $location.hash;
          $location.hash = function(value) {
            if (isDefined(value)) {
              $timeout(function() {
                var scroll = document.querySelector('.scroll-content');
                if (scroll) {
                  scroll.scrollTop = 0;
                }
              }, 0, false);
            }
            return $location.__hash(value);
          };
          return $location;
        }
        $provide.decorator('$location', ['$delegate', '$timeout', $LocationDecorator]);
      }]);
      IonicModule.controller('$ionicHeaderBar', ['$scope', '$element', '$attrs', '$q', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $q, $ionicConfig, $ionicHistory) {
        var TITLE = 'title';
        var BACK_TEXT = 'back-text';
        var BACK_BUTTON = 'back-button';
        var DEFAULT_TITLE = 'default-title';
        var PREVIOUS_TITLE = 'previous-title';
        var HIDE = 'hide';
        var self = this;
        var titleText = '';
        var previousTitleText = '';
        var titleLeft = 0;
        var titleRight = 0;
        var titleCss = '';
        var isBackEnabled = false;
        var isBackShown = true;
        var isNavBackShown = true;
        var isBackElementShown = false;
        var titleTextWidth = 0;
        self.beforeEnter = function(viewData) {
          $scope.$broadcast('$ionicView.beforeEnter', viewData);
        };
        self.title = function(newTitleText) {
          if (arguments.length && newTitleText !== titleText) {
            getEle(TITLE).innerHTML = newTitleText;
            titleText = newTitleText;
            titleTextWidth = 0;
          }
          return titleText;
        };
        self.enableBack = function(shouldEnable, disableReset) {
          if (arguments.length) {
            isBackEnabled = shouldEnable;
            if (!disableReset)
              self.updateBackButton();
          }
          return isBackEnabled;
        };
        self.showBack = function(shouldShow, disableReset) {
          if (arguments.length) {
            isBackShown = shouldShow;
            if (!disableReset)
              self.updateBackButton();
          }
          return isBackShown;
        };
        self.showNavBack = function(shouldShow) {
          isNavBackShown = shouldShow;
          self.updateBackButton();
        };
        self.updateBackButton = function() {
          var ele;
          if ((isBackShown && isNavBackShown && isBackEnabled) !== isBackElementShown) {
            isBackElementShown = isBackShown && isNavBackShown && isBackEnabled;
            ele = getEle(BACK_BUTTON);
            ele && ele.classList[isBackElementShown ? 'remove' : 'add'](HIDE);
          }
          if (isBackEnabled) {
            ele = ele || getEle(BACK_BUTTON);
            if (ele) {
              if (self.backButtonIcon !== $ionicConfig.backButton.icon()) {
                ele = getEle(BACK_BUTTON + ' .icon');
                if (ele) {
                  self.backButtonIcon = $ionicConfig.backButton.icon();
                  ele.className = 'icon ' + self.backButtonIcon;
                }
              }
              if (self.backButtonText !== $ionicConfig.backButton.text()) {
                ele = getEle(BACK_BUTTON + ' .back-text');
                if (ele) {
                  ele.textContent = self.backButtonText = $ionicConfig.backButton.text();
                }
              }
            }
          }
        };
        self.titleTextWidth = function() {
          if (!titleTextWidth) {
            var bounds = ionic.DomUtil.getTextBounds(getEle(TITLE));
            titleTextWidth = Math.min(bounds && bounds.width || 30);
          }
          return titleTextWidth;
        };
        self.titleWidth = function() {
          var titleWidth = self.titleTextWidth();
          var offsetWidth = getEle(TITLE).offsetWidth;
          if (offsetWidth < titleWidth) {
            titleWidth = offsetWidth + (titleLeft - titleRight - 5);
          }
          return titleWidth;
        };
        self.titleTextX = function() {
          return ($element[0].offsetWidth / 2) - (self.titleWidth() / 2);
        };
        self.titleLeftRight = function() {
          return titleLeft - titleRight;
        };
        self.backButtonTextLeft = function() {
          var offsetLeft = 0;
          var ele = getEle(BACK_TEXT);
          while (ele) {
            offsetLeft += ele.offsetLeft;
            ele = ele.parentElement;
          }
          return offsetLeft;
        };
        self.resetBackButton = function(viewData) {
          if ($ionicConfig.backButton.previousTitleText()) {
            var previousTitleEle = getEle(PREVIOUS_TITLE);
            if (previousTitleEle) {
              previousTitleEle.classList.remove(HIDE);
              var view = (viewData && $ionicHistory.getViewById(viewData.viewId));
              var newPreviousTitleText = $ionicHistory.backTitle(view);
              if (newPreviousTitleText !== previousTitleText) {
                previousTitleText = previousTitleEle.innerHTML = newPreviousTitleText;
              }
            }
            var defaultTitleEle = getEle(DEFAULT_TITLE);
            if (defaultTitleEle) {
              defaultTitleEle.classList.remove(HIDE);
            }
          }
        };
        self.align = function(textAlign) {
          var titleEle = getEle(TITLE);
          textAlign = textAlign || $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
          var widths = self.calcWidths(textAlign, false);
          if (isBackShown && previousTitleText && $ionicConfig.backButton.previousTitleText()) {
            var previousTitleWidths = self.calcWidths(textAlign, true);
            var availableTitleWidth = $element[0].offsetWidth - previousTitleWidths.titleLeft - previousTitleWidths.titleRight;
            if (self.titleTextWidth() <= availableTitleWidth) {
              widths = previousTitleWidths;
            }
          }
          return self.updatePositions(titleEle, widths.titleLeft, widths.titleRight, widths.buttonsLeft, widths.buttonsRight, widths.css, widths.showPrevTitle);
        };
        self.calcWidths = function(textAlign, isPreviousTitle) {
          var titleEle = getEle(TITLE);
          var backBtnEle = getEle(BACK_BUTTON);
          var x,
              y,
              z,
              b,
              c,
              d,
              childSize,
              bounds;
          var childNodes = $element[0].childNodes;
          var buttonsLeft = 0;
          var buttonsRight = 0;
          var isCountRightOfTitle;
          var updateTitleLeft = 0;
          var updateTitleRight = 0;
          var updateCss = '';
          var backButtonWidth = 0;
          for (x = 0; x < childNodes.length; x++) {
            c = childNodes[x];
            childSize = 0;
            if (c.nodeType == 1) {
              if (c === titleEle) {
                isCountRightOfTitle = true;
                continue;
              }
              if (c.classList.contains(HIDE)) {
                continue;
              }
              if (isBackShown && c === backBtnEle) {
                for (y = 0; y < c.childNodes.length; y++) {
                  b = c.childNodes[y];
                  if (b.nodeType == 1) {
                    if (b.classList.contains(BACK_TEXT)) {
                      for (z = 0; z < b.children.length; z++) {
                        d = b.children[z];
                        if (isPreviousTitle) {
                          if (d.classList.contains(DEFAULT_TITLE))
                            continue;
                          backButtonWidth += d.offsetWidth;
                        } else {
                          if (d.classList.contains(PREVIOUS_TITLE))
                            continue;
                          backButtonWidth += d.offsetWidth;
                        }
                      }
                    } else {
                      backButtonWidth += b.offsetWidth;
                    }
                  } else if (b.nodeType == 3 && b.nodeValue.trim()) {
                    bounds = ionic.DomUtil.getTextBounds(b);
                    backButtonWidth += bounds && bounds.width || 0;
                  }
                }
                childSize = backButtonWidth || c.offsetWidth;
              } else {
                childSize = c.offsetWidth;
              }
            } else if (c.nodeType == 3 && c.nodeValue.trim()) {
              bounds = ionic.DomUtil.getTextBounds(c);
              childSize = bounds && bounds.width || 0;
            }
            if (isCountRightOfTitle) {
              buttonsRight += childSize;
            } else {
              buttonsLeft += childSize;
            }
          }
          if (textAlign == 'left') {
            updateCss = 'title-left';
            if (buttonsLeft) {
              updateTitleLeft = buttonsLeft + 15;
            }
            if (buttonsRight) {
              updateTitleRight = buttonsRight + 15;
            }
          } else if (textAlign == 'right') {
            updateCss = 'title-right';
            if (buttonsLeft) {
              updateTitleLeft = buttonsLeft + 15;
            }
            if (buttonsRight) {
              updateTitleRight = buttonsRight + 15;
            }
          } else {
            var margin = Math.max(buttonsLeft, buttonsRight) + 10;
            if (margin > 10) {
              updateTitleLeft = updateTitleRight = margin;
            }
          }
          return {
            backButtonWidth: backButtonWidth,
            buttonsLeft: buttonsLeft,
            buttonsRight: buttonsRight,
            titleLeft: updateTitleLeft,
            titleRight: updateTitleRight,
            showPrevTitle: isPreviousTitle,
            css: updateCss
          };
        };
        self.updatePositions = function(titleEle, updateTitleLeft, updateTitleRight, buttonsLeft, buttonsRight, updateCss, showPreviousTitle) {
          var deferred = $q.defer();
          if (titleEle) {
            if (updateTitleLeft !== titleLeft) {
              titleEle.style.left = updateTitleLeft ? updateTitleLeft + 'px' : '';
              titleLeft = updateTitleLeft;
            }
            if (updateTitleRight !== titleRight) {
              titleEle.style.right = updateTitleRight ? updateTitleRight + 'px' : '';
              titleRight = updateTitleRight;
            }
            if (updateCss !== titleCss) {
              updateCss && titleEle.classList.add(updateCss);
              titleCss && titleEle.classList.remove(titleCss);
              titleCss = updateCss;
            }
          }
          if ($ionicConfig.backButton.previousTitleText()) {
            var prevTitle = getEle(PREVIOUS_TITLE);
            var defaultTitle = getEle(DEFAULT_TITLE);
            prevTitle && prevTitle.classList[showPreviousTitle ? 'remove' : 'add'](HIDE);
            defaultTitle && defaultTitle.classList[showPreviousTitle ? 'add' : 'remove'](HIDE);
          }
          ionic.requestAnimationFrame(function() {
            if (titleEle && titleEle.offsetWidth + 10 < titleEle.scrollWidth) {
              var minRight = buttonsRight + 5;
              var testRight = $element[0].offsetWidth - titleLeft - self.titleTextWidth() - 20;
              updateTitleRight = testRight < minRight ? minRight : testRight;
              if (updateTitleRight !== titleRight) {
                titleEle.style.right = updateTitleRight + 'px';
                titleRight = updateTitleRight;
              }
            }
            deferred.resolve();
          });
          return deferred.promise;
        };
        self.setCss = function(elementClassname, css) {
          ionic.DomUtil.cachedStyles(getEle(elementClassname), css);
        };
        var eleCache = {};
        function getEle(className) {
          if (!eleCache[className]) {
            eleCache[className] = $element[0].querySelector('.' + className);
          }
          return eleCache[className];
        }
        $scope.$on('$destroy', function() {
          for (var n in eleCache)
            eleCache[n] = null;
        });
      }]);
      IonicModule.controller('$ionInfiniteScroll', ['$scope', '$attrs', '$element', '$timeout', function($scope, $attrs, $element, $timeout) {
        var self = this;
        self.isLoading = false;
        $scope.icon = function() {
          return isDefined($attrs.icon) ? $attrs.icon : 'ion-load-d';
        };
        $scope.spinner = function() {
          return isDefined($attrs.spinner) ? $attrs.spinner : '';
        };
        $scope.$on('scroll.infiniteScrollComplete', function() {
          finishInfiniteScroll();
        });
        $scope.$on('$destroy', function() {
          if (self.scrollCtrl && self.scrollCtrl.$element)
            self.scrollCtrl.$element.off('scroll', self.checkBounds);
          if (self.scrollEl && self.scrollEl.removeEventListener) {
            self.scrollEl.removeEventListener('scroll', self.checkBounds);
          }
        });
        self.checkBounds = ionic.Utils.throttle(checkInfiniteBounds, 300);
        function onInfinite() {
          ionic.requestAnimationFrame(function() {
            $element[0].classList.add('active');
          });
          self.isLoading = true;
          $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || '');
        }
        function finishInfiniteScroll() {
          ionic.requestAnimationFrame(function() {
            $element[0].classList.remove('active');
          });
          $timeout(function() {
            if (self.jsScrolling)
              self.scrollView.resize();
            if ((self.jsScrolling && self.scrollView.__container && self.scrollView.__container.offsetHeight > 0) || !self.jsScrolling) {
              self.checkBounds();
            }
          }, 30, false);
          self.isLoading = false;
        }
        function checkInfiniteBounds() {
          if (self.isLoading)
            return;
          var maxScroll = {};
          if (self.jsScrolling) {
            maxScroll = self.getJSMaxScroll();
            var scrollValues = self.scrollView.getValues();
            if ((maxScroll.left !== -1 && scrollValues.left >= maxScroll.left) || (maxScroll.top !== -1 && scrollValues.top >= maxScroll.top)) {
              onInfinite();
            }
          } else {
            maxScroll = self.getNativeMaxScroll();
            if ((maxScroll.left !== -1 && self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth) || (maxScroll.top !== -1 && self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight)) {
              onInfinite();
            }
          }
        }
        self.getJSMaxScroll = function() {
          var maxValues = self.scrollView.getScrollMax();
          return {
            left: self.scrollView.options.scrollingX ? calculateMaxValue(maxValues.left) : -1,
            top: self.scrollView.options.scrollingY ? calculateMaxValue(maxValues.top) : -1
          };
        };
        self.getNativeMaxScroll = function() {
          var maxValues = {
            left: self.scrollEl.scrollWidth,
            top: self.scrollEl.scrollHeight
          };
          var computedStyle = window.getComputedStyle(self.scrollEl) || {};
          return {
            left: computedStyle.overflowX === 'scroll' || computedStyle.overflowX === 'auto' || self.scrollEl.style['overflow-x'] === 'scroll' ? calculateMaxValue(maxValues.left) : -1,
            top: computedStyle.overflowY === 'scroll' || computedStyle.overflowY === 'auto' || self.scrollEl.style['overflow-y'] === 'scroll' ? calculateMaxValue(maxValues.top) : -1
          };
        };
        function calculateMaxValue(maximum) {
          var distance = ($attrs.distance || '2.5%').trim();
          var isPercent = distance.indexOf('%') !== -1;
          return isPercent ? maximum * (1 - parseFloat(distance) / 100) : maximum - parseFloat(distance);
        }
        self.__finishInfiniteScroll = finishInfiniteScroll;
      }]);
      IonicModule.service('$ionicListDelegate', ionic.DelegateService(['showReorder', 'showDelete', 'canSwipeItems', 'closeOptionButtons'])).controller('$ionicList', ['$scope', '$attrs', '$ionicListDelegate', '$ionicHistory', function($scope, $attrs, $ionicListDelegate, $ionicHistory) {
        var self = this;
        var isSwipeable = true;
        var isReorderShown = false;
        var isDeleteShown = false;
        var deregisterInstance = $ionicListDelegate._registerInstance(self, $attrs.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on('$destroy', deregisterInstance);
        self.showReorder = function(show) {
          if (arguments.length) {
            isReorderShown = !!show;
          }
          return isReorderShown;
        };
        self.showDelete = function(show) {
          if (arguments.length) {
            isDeleteShown = !!show;
          }
          return isDeleteShown;
        };
        self.canSwipeItems = function(can) {
          if (arguments.length) {
            isSwipeable = !!can;
          }
          return isSwipeable;
        };
        self.closeOptionButtons = function() {
          self.listView && self.listView.clearDragEffects();
        };
      }]);
      IonicModule.controller('$ionicNavBar', ['$scope', '$element', '$attrs', '$compile', '$timeout', '$ionicNavBarDelegate', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $compile, $timeout, $ionicNavBarDelegate, $ionicConfig, $ionicHistory) {
        var CSS_HIDE = 'hide';
        var DATA_NAV_BAR_CTRL = '$ionNavBarController';
        var PRIMARY_BUTTONS = 'primaryButtons';
        var SECONDARY_BUTTONS = 'secondaryButtons';
        var BACK_BUTTON = 'backButton';
        var ITEM_TYPES = 'primaryButtons secondaryButtons leftButtons rightButtons title'.split(' ');
        var self = this;
        var headerBars = [];
        var navElementHtml = {};
        var isVisible = true;
        var queuedTransitionStart,
            queuedTransitionEnd,
            latestTransitionId;
        $element.parent().data(DATA_NAV_BAR_CTRL, self);
        var delegateHandle = $attrs.delegateHandle || 'navBar' + ionic.Utils.nextUid();
        var deregisterInstance = $ionicNavBarDelegate._registerInstance(self, delegateHandle);
        self.init = function() {
          $element.addClass('nav-bar-container');
          ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', $ionicConfig.views.transition());
          self.createHeaderBar(false);
          self.createHeaderBar(true);
          $scope.$emit('ionNavBar.init', delegateHandle);
        };
        self.createHeaderBar = function(isActive) {
          var containerEle = jqLite('<div class="nav-bar-block">');
          ionic.DomUtil.cachedAttr(containerEle, 'nav-bar', isActive ? 'active' : 'cached');
          var alignTitle = $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
          var headerBarEle = jqLite('<ion-header-bar>').addClass($attrs['class']).attr('align-title', alignTitle);
          if (isDefined($attrs.noTapScroll))
            headerBarEle.attr('no-tap-scroll', $attrs.noTapScroll);
          var titleEle = jqLite('<div class="title title-' + alignTitle + '">');
          var navEle = {};
          var lastViewItemEle = {};
          var leftButtonsEle,
              rightButtonsEle;
          navEle[BACK_BUTTON] = createNavElement(BACK_BUTTON);
          navEle[BACK_BUTTON] && headerBarEle.append(navEle[BACK_BUTTON]);
          headerBarEle.append(titleEle);
          forEach(ITEM_TYPES, function(itemType) {
            navEle[itemType] = createNavElement(itemType);
            positionItem(navEle[itemType], itemType);
          });
          for (var x = 0; x < headerBarEle[0].children.length; x++) {
            headerBarEle[0].children[x].classList.add('header-item');
          }
          containerEle.append(headerBarEle);
          $element.append($compile(containerEle)($scope.$new()));
          var headerBarCtrl = headerBarEle.data('$ionHeaderBarController');
          headerBarCtrl.backButtonIcon = $ionicConfig.backButton.icon();
          headerBarCtrl.backButtonText = $ionicConfig.backButton.text();
          var headerBarInstance = {
            isActive: isActive,
            title: function(newTitleText) {
              headerBarCtrl.title(newTitleText);
            },
            setItem: function(navBarItemEle, itemType) {
              headerBarInstance.removeItem(itemType);
              if (navBarItemEle) {
                if (itemType === 'title') {
                  headerBarInstance.title("");
                }
                positionItem(navBarItemEle, itemType);
                if (navEle[itemType]) {
                  navEle[itemType].addClass(CSS_HIDE);
                }
                lastViewItemEle[itemType] = navBarItemEle;
              } else if (navEle[itemType]) {
                navEle[itemType].removeClass(CSS_HIDE);
              }
            },
            removeItem: function(itemType) {
              if (lastViewItemEle[itemType]) {
                lastViewItemEle[itemType].scope().$destroy();
                lastViewItemEle[itemType].remove();
                lastViewItemEle[itemType] = null;
              }
            },
            containerEle: function() {
              return containerEle;
            },
            headerBarEle: function() {
              return headerBarEle;
            },
            afterLeave: function() {
              forEach(ITEM_TYPES, function(itemType) {
                headerBarInstance.removeItem(itemType);
              });
              headerBarCtrl.resetBackButton();
            },
            controller: function() {
              return headerBarCtrl;
            },
            destroy: function() {
              forEach(ITEM_TYPES, function(itemType) {
                headerBarInstance.removeItem(itemType);
              });
              containerEle.scope().$destroy();
              for (var n in navEle) {
                if (navEle[n]) {
                  navEle[n].removeData();
                  navEle[n] = null;
                }
              }
              leftButtonsEle && leftButtonsEle.removeData();
              rightButtonsEle && rightButtonsEle.removeData();
              titleEle.removeData();
              headerBarEle.removeData();
              containerEle.remove();
              containerEle = headerBarEle = titleEle = leftButtonsEle = rightButtonsEle = null;
            }
          };
          function positionItem(ele, itemType) {
            if (!ele)
              return;
            if (itemType === 'title') {
              titleEle.append(ele);
            } else if (itemType == 'rightButtons' || (itemType == SECONDARY_BUTTONS && $ionicConfig.navBar.positionSecondaryButtons() != 'left') || (itemType == PRIMARY_BUTTONS && $ionicConfig.navBar.positionPrimaryButtons() == 'right')) {
              if (!rightButtonsEle) {
                rightButtonsEle = jqLite('<div class="buttons buttons-right">');
                headerBarEle.append(rightButtonsEle);
              }
              if (itemType == SECONDARY_BUTTONS) {
                rightButtonsEle.append(ele);
              } else {
                rightButtonsEle.prepend(ele);
              }
            } else {
              if (!leftButtonsEle) {
                leftButtonsEle = jqLite('<div class="buttons buttons-left">');
                if (navEle[BACK_BUTTON]) {
                  navEle[BACK_BUTTON].after(leftButtonsEle);
                } else {
                  headerBarEle.prepend(leftButtonsEle);
                }
              }
              if (itemType == SECONDARY_BUTTONS) {
                leftButtonsEle.append(ele);
              } else {
                leftButtonsEle.prepend(ele);
              }
            }
          }
          headerBars.push(headerBarInstance);
          return headerBarInstance;
        };
        self.navElement = function(type, html) {
          if (isDefined(html)) {
            navElementHtml[type] = html;
          }
          return navElementHtml[type];
        };
        self.update = function(viewData) {
          var showNavBar = !viewData.hasHeaderBar && viewData.showNavBar;
          viewData.transition = $ionicConfig.views.transition();
          if (!showNavBar) {
            viewData.direction = 'none';
          }
          self.enable(showNavBar);
          var enteringHeaderBar = self.isInitialized ? getOffScreenHeaderBar() : getOnScreenHeaderBar();
          var leavingHeaderBar = self.isInitialized ? getOnScreenHeaderBar() : null;
          var enteringHeaderCtrl = enteringHeaderBar.controller();
          enteringHeaderCtrl.enableBack(viewData.enableBack, true);
          enteringHeaderCtrl.showBack(viewData.showBack, true);
          enteringHeaderCtrl.updateBackButton();
          self.title(viewData.title, enteringHeaderBar);
          self.showBar(showNavBar);
          if (viewData.navBarItems) {
            forEach(ITEM_TYPES, function(itemType) {
              enteringHeaderBar.setItem(viewData.navBarItems[itemType], itemType);
            });
          }
          self.transition(enteringHeaderBar, leavingHeaderBar, viewData);
          self.isInitialized = true;
          navSwipeAttr('');
        };
        self.transition = function(enteringHeaderBar, leavingHeaderBar, viewData) {
          var enteringHeaderBarCtrl = enteringHeaderBar.controller();
          var transitionFn = $ionicConfig.transitions.navBar[viewData.navBarTransition] || $ionicConfig.transitions.navBar.none;
          var transitionId = viewData.transitionId;
          enteringHeaderBarCtrl.beforeEnter(viewData);
          var navBarTransition = transitionFn(enteringHeaderBar, leavingHeaderBar, viewData.direction, viewData.shouldAnimate && self.isInitialized);
          ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', viewData.navBarTransition);
          ionic.DomUtil.cachedAttr($element, 'nav-bar-direction', viewData.direction);
          if (navBarTransition.shouldAnimate && viewData.renderEnd) {
            navBarAttr(enteringHeaderBar, 'stage');
          } else {
            navBarAttr(enteringHeaderBar, 'entering');
            navBarAttr(leavingHeaderBar, 'leaving');
          }
          enteringHeaderBarCtrl.resetBackButton(viewData);
          navBarTransition.run(0);
          self.activeTransition = {
            run: function(step) {
              navBarTransition.shouldAnimate = false;
              navBarTransition.direction = 'back';
              navBarTransition.run(step);
            },
            cancel: function(shouldAnimate, speed, cancelData) {
              navSwipeAttr(speed);
              navBarAttr(leavingHeaderBar, 'active');
              navBarAttr(enteringHeaderBar, 'cached');
              navBarTransition.shouldAnimate = shouldAnimate;
              navBarTransition.run(0);
              self.activeTransition = navBarTransition = null;
              var runApply;
              if (cancelData.showBar !== self.showBar()) {
                self.showBar(cancelData.showBar);
              }
              if (cancelData.showBackButton !== self.showBackButton()) {
                self.showBackButton(cancelData.showBackButton);
              }
              if (runApply) {
                $scope.$apply();
              }
            },
            complete: function(shouldAnimate, speed) {
              navSwipeAttr(speed);
              navBarTransition.shouldAnimate = shouldAnimate;
              navBarTransition.run(1);
              queuedTransitionEnd = transitionEnd;
            }
          };
          $timeout(enteringHeaderBarCtrl.align, 16);
          queuedTransitionStart = function() {
            if (latestTransitionId !== transitionId)
              return;
            navBarAttr(enteringHeaderBar, 'entering');
            navBarAttr(leavingHeaderBar, 'leaving');
            navBarTransition.run(1);
            queuedTransitionEnd = function() {
              if (latestTransitionId == transitionId || !navBarTransition.shouldAnimate) {
                transitionEnd();
              }
            };
            queuedTransitionStart = null;
          };
          function transitionEnd() {
            for (var x = 0; x < headerBars.length; x++) {
              headerBars[x].isActive = false;
            }
            enteringHeaderBar.isActive = true;
            navBarAttr(enteringHeaderBar, 'active');
            navBarAttr(leavingHeaderBar, 'cached');
            self.activeTransition = navBarTransition = queuedTransitionEnd = null;
          }
          queuedTransitionStart();
        };
        self.triggerTransitionStart = function(triggerTransitionId) {
          latestTransitionId = triggerTransitionId;
          queuedTransitionStart && queuedTransitionStart();
        };
        self.triggerTransitionEnd = function() {
          queuedTransitionEnd && queuedTransitionEnd();
        };
        self.showBar = function(shouldShow) {
          if (arguments.length) {
            self.visibleBar(shouldShow);
            $scope.$parent.$hasHeader = !!shouldShow;
          }
          return !!$scope.$parent.$hasHeader;
        };
        self.visibleBar = function(shouldShow) {
          if (shouldShow && !isVisible) {
            $element.removeClass(CSS_HIDE);
            self.align();
          } else if (!shouldShow && isVisible) {
            $element.addClass(CSS_HIDE);
          }
          isVisible = shouldShow;
        };
        self.enable = function(val) {
          self.visibleBar(val);
          for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
            if ($ionicNavBarDelegate._instances[x] !== self)
              $ionicNavBarDelegate._instances[x].visibleBar(false);
          }
        };
        self.showBackButton = function(shouldShow) {
          if (arguments.length) {
            for (var x = 0; x < headerBars.length; x++) {
              headerBars[x].controller().showNavBack(!!shouldShow);
            }
            $scope.$isBackButtonShown = !!shouldShow;
          }
          return $scope.$isBackButtonShown;
        };
        self.showActiveBackButton = function(shouldShow) {
          var headerBar = getOnScreenHeaderBar();
          if (headerBar) {
            if (arguments.length) {
              return headerBar.controller().showBack(shouldShow);
            }
            return headerBar.controller().showBack();
          }
        };
        self.title = function(newTitleText, headerBar) {
          if (isDefined(newTitleText)) {
            newTitleText = newTitleText || '';
            headerBar = headerBar || getOnScreenHeaderBar();
            headerBar && headerBar.title(newTitleText);
            $scope.$title = newTitleText;
            $ionicHistory.currentTitle(newTitleText);
          }
          return $scope.$title;
        };
        self.align = function(val, headerBar) {
          headerBar = headerBar || getOnScreenHeaderBar();
          headerBar && headerBar.controller().align(val);
        };
        self.hasTabsTop = function(isTabsTop) {
          $element[isTabsTop ? 'addClass' : 'removeClass']('nav-bar-tabs-top');
        };
        self.hasBarSubheader = function(isBarSubheader) {
          $element[isBarSubheader ? 'addClass' : 'removeClass']('nav-bar-has-subheader');
        };
        self.changeTitle = function(val) {
          deprecatedWarning('changeTitle(val)', 'title(val)');
          self.title(val);
        };
        self.setTitle = function(val) {
          deprecatedWarning('setTitle(val)', 'title(val)');
          self.title(val);
        };
        self.getTitle = function() {
          deprecatedWarning('getTitle()', 'title()');
          return self.title();
        };
        self.back = function() {
          deprecatedWarning('back()', '$ionicHistory.goBack()');
          $ionicHistory.goBack();
        };
        self.getPreviousTitle = function() {
          deprecatedWarning('getPreviousTitle()', '$ionicHistory.backTitle()');
          $ionicHistory.goBack();
        };
        function deprecatedWarning(oldMethod, newMethod) {
          var warn = console.warn || console.log;
          warn && warn.call(console, 'navBarController.' + oldMethod + ' is deprecated, please use ' + newMethod + ' instead');
        }
        function createNavElement(type) {
          if (navElementHtml[type]) {
            return jqLite(navElementHtml[type]);
          }
        }
        function getOnScreenHeaderBar() {
          for (var x = 0; x < headerBars.length; x++) {
            if (headerBars[x].isActive)
              return headerBars[x];
          }
        }
        function getOffScreenHeaderBar() {
          for (var x = 0; x < headerBars.length; x++) {
            if (!headerBars[x].isActive)
              return headerBars[x];
          }
        }
        function navBarAttr(ctrl, val) {
          ctrl && ionic.DomUtil.cachedAttr(ctrl.containerEle(), 'nav-bar', val);
        }
        function navSwipeAttr(val) {
          ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
        }
        $scope.$on('$destroy', function() {
          $scope.$parent.$hasHeader = false;
          $element.parent().removeData(DATA_NAV_BAR_CTRL);
          for (var x = 0; x < headerBars.length; x++) {
            headerBars[x].destroy();
          }
          $element.remove();
          $element = headerBars = null;
          deregisterInstance();
        });
      }]);
      IonicModule.controller('$ionicNavView', ['$scope', '$element', '$attrs', '$compile', '$controller', '$ionicNavBarDelegate', '$ionicNavViewDelegate', '$ionicHistory', '$ionicViewSwitcher', '$ionicConfig', '$ionicScrollDelegate', function($scope, $element, $attrs, $compile, $controller, $ionicNavBarDelegate, $ionicNavViewDelegate, $ionicHistory, $ionicViewSwitcher, $ionicConfig, $ionicScrollDelegate) {
        var DATA_ELE_IDENTIFIER = '$eleId';
        var DATA_DESTROY_ELE = '$destroyEle';
        var DATA_NO_CACHE = '$noCache';
        var VIEW_STATUS_ACTIVE = 'active';
        var VIEW_STATUS_CACHED = 'cached';
        var self = this;
        var direction;
        var isPrimary = false;
        var navBarDelegate;
        var activeEleId;
        var navViewAttr = $ionicViewSwitcher.navViewAttr;
        var disableRenderStartViewId,
            disableAnimation;
        self.scope = $scope;
        self.element = $element;
        self.init = function() {
          var navViewName = $attrs.name || '';
          var parent = $element.parent().inheritedData('$uiView');
          var parentViewName = ((parent && parent.state) ? parent.state.name : '');
          if (navViewName.indexOf('@') < 0)
            navViewName = navViewName + '@' + parentViewName;
          var viewData = {
            name: navViewName,
            state: null
          };
          $element.data('$uiView', viewData);
          var deregisterInstance = $ionicNavViewDelegate._registerInstance(self, $attrs.delegateHandle);
          $scope.$on('$destroy', function() {
            deregisterInstance();
            if (self.isSwipeFreeze) {
              $ionicScrollDelegate.freezeAllScrolls(false);
            }
          });
          $scope.$on('$ionicHistory.deselect', self.cacheCleanup);
          $scope.$on('$ionicTabs.top', onTabsTop);
          $scope.$on('$ionicSubheader', onBarSubheader);
          $scope.$on('$ionicTabs.beforeLeave', onTabsLeave);
          $scope.$on('$ionicTabs.afterLeave', onTabsLeave);
          $scope.$on('$ionicTabs.leave', onTabsLeave);
          ionic.Platform.ready(function() {
            if (ionic.Platform.isWebView() && $ionicConfig.views.swipeBackEnabled()) {
              self.initSwipeBack();
            }
          });
          return viewData;
        };
        self.register = function(viewLocals) {
          var leavingView = extend({}, $ionicHistory.currentView());
          var registerData = $ionicHistory.register($scope, viewLocals);
          self.update(registerData);
          var enteringView = $ionicHistory.getViewById(registerData.viewId) || {};
          var renderStart = (disableRenderStartViewId !== registerData.viewId);
          self.render(registerData, viewLocals, enteringView, leavingView, renderStart, true);
        };
        self.update = function(registerData) {
          isPrimary = true;
          direction = registerData.direction;
          var parentNavViewCtrl = $element.parent().inheritedData('$ionNavViewController');
          if (parentNavViewCtrl) {
            parentNavViewCtrl.isPrimary(false);
            if (direction === 'enter' || direction === 'exit') {
              parentNavViewCtrl.direction(direction);
              if (direction === 'enter') {
                direction = 'none';
              }
            }
          }
        };
        self.render = function(registerData, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
          var switcher = $ionicViewSwitcher.create(self, viewLocals, enteringView, leavingView, renderStart, renderEnd);
          switcher.init(registerData, function() {
            switcher.transition(self.direction(), registerData.enableBack, !disableAnimation);
            disableRenderStartViewId = disableAnimation = null;
          });
        };
        self.beforeEnter = function(transitionData) {
          if (isPrimary) {
            navBarDelegate = transitionData.navBarDelegate;
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            associatedNavBarCtrl && associatedNavBarCtrl.update(transitionData);
            navSwipeAttr('');
          }
        };
        self.activeEleId = function(eleId) {
          if (arguments.length) {
            activeEleId = eleId;
          }
          return activeEleId;
        };
        self.transitionEnd = function() {
          var viewElements = $element.children();
          var x,
              l,
              viewElement;
          for (x = 0, l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (viewElement.data(DATA_ELE_IDENTIFIER) === activeEleId) {
              navViewAttr(viewElement, VIEW_STATUS_ACTIVE);
            } else if (navViewAttr(viewElement) === 'leaving' || navViewAttr(viewElement) === VIEW_STATUS_ACTIVE || navViewAttr(viewElement) === VIEW_STATUS_CACHED) {
              if (viewElement.data(DATA_DESTROY_ELE) || viewElement.data(DATA_NO_CACHE)) {
                $ionicViewSwitcher.destroyViewEle(viewElement);
              } else {
                navViewAttr(viewElement, VIEW_STATUS_CACHED);
                ionic.Utils.disconnectScope(viewElement.scope());
              }
            }
          }
          navSwipeAttr('');
          if (self.isSwipeFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(false);
          }
        };
        function onTabsLeave(ev, data) {
          var viewElements = $element.children();
          var viewElement,
              viewScope;
          for (var x = 0,
              l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
              viewScope = viewElement.scope();
              viewScope && viewScope.$emit(ev.name.replace('Tabs', 'View'), data);
              break;
            }
          }
        }
        self.cacheCleanup = function() {
          var viewElements = $element.children();
          for (var x = 0,
              l = viewElements.length; x < l; x++) {
            if (viewElements.eq(x).data(DATA_DESTROY_ELE)) {
              $ionicViewSwitcher.destroyViewEle(viewElements.eq(x));
            }
          }
        };
        self.clearCache = function(stateIds) {
          var viewElements = $element.children();
          var viewElement,
              viewScope,
              x,
              l,
              y,
              eleIdentifier;
          for (x = 0, l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (stateIds) {
              eleIdentifier = viewElement.data(DATA_ELE_IDENTIFIER);
              for (y = 0; y < stateIds.length; y++) {
                if (eleIdentifier === stateIds[y]) {
                  $ionicViewSwitcher.destroyViewEle(viewElement);
                }
              }
              continue;
            }
            if (navViewAttr(viewElement) == VIEW_STATUS_CACHED) {
              $ionicViewSwitcher.destroyViewEle(viewElement);
            } else if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
              viewScope = viewElement.scope();
              viewScope && viewScope.$broadcast('$ionicView.clearCache');
            }
          }
        };
        self.getViewElements = function() {
          return $element.children();
        };
        self.appendViewElement = function(viewEle, viewLocals) {
          var linkFn = $compile(viewEle);
          $element.append(viewEle);
          var viewScope = $scope.$new();
          if (viewLocals && viewLocals.$$controller) {
            viewLocals.$scope = viewScope;
            var controller = $controller(viewLocals.$$controller, viewLocals);
            $element.children().data('$ngControllerController', controller);
          }
          linkFn(viewScope);
          return viewScope;
        };
        self.title = function(val) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.title(val);
        };
        self.enableBackButton = function(shouldEnable) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.enableBackButton(shouldEnable);
        };
        self.showBackButton = function(shouldShow) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          if (associatedNavBarCtrl) {
            if (arguments.length) {
              return associatedNavBarCtrl.showActiveBackButton(shouldShow);
            }
            return associatedNavBarCtrl.showActiveBackButton();
          }
          return true;
        };
        self.showBar = function(val) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          if (associatedNavBarCtrl) {
            if (arguments.length) {
              return associatedNavBarCtrl.showBar(val);
            }
            return associatedNavBarCtrl.showBar();
          }
          return true;
        };
        self.isPrimary = function(val) {
          if (arguments.length) {
            isPrimary = val;
          }
          return isPrimary;
        };
        self.direction = function(val) {
          if (arguments.length) {
            direction = val;
          }
          return direction;
        };
        self.initSwipeBack = function() {
          var swipeBackHitWidth = $ionicConfig.views.swipeBackHitWidth();
          var viewTransition,
              associatedNavBarCtrl,
              backView;
          var deregDragStart,
              deregDrag,
              deregRelease;
          var windowWidth,
              startDragX,
              dragPoints;
          var cancelData = {};
          function onDragStart(ev) {
            if (!isPrimary)
              return;
            startDragX = getDragX(ev);
            if (startDragX > swipeBackHitWidth)
              return;
            backView = $ionicHistory.backView();
            var currentView = $ionicHistory.currentView();
            if (!backView || backView.historyId !== currentView.historyId || currentView.canSwipeBack === false)
              return;
            if (!windowWidth)
              windowWidth = window.innerWidth;
            self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(true);
            var registerData = {direction: 'back'};
            dragPoints = [];
            cancelData = {
              showBar: self.showBar(),
              showBackButton: self.showBackButton()
            };
            var switcher = $ionicViewSwitcher.create(self, registerData, backView, currentView, true, false);
            switcher.loadViewElements(registerData);
            switcher.render(registerData);
            viewTransition = switcher.transition('back', $ionicHistory.enabledBack(backView), true);
            associatedNavBarCtrl = getAssociatedNavBarCtrl();
            deregDrag = ionic.onGesture('drag', onDrag, $element[0]);
            deregRelease = ionic.onGesture('release', onRelease, $element[0]);
          }
          function onDrag(ev) {
            if (isPrimary && viewTransition) {
              var dragX = getDragX(ev);
              dragPoints.push({
                t: Date.now(),
                x: dragX
              });
              if (dragX >= windowWidth - 15) {
                onRelease(ev);
              } else {
                var step = Math.min(Math.max(getSwipeCompletion(dragX), 0), 1);
                viewTransition.run(step);
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.run(step);
              }
            }
          }
          function onRelease(ev) {
            if (isPrimary && viewTransition && dragPoints && dragPoints.length > 1) {
              var now = Date.now();
              var releaseX = getDragX(ev);
              var startDrag = dragPoints[dragPoints.length - 1];
              for (var x = dragPoints.length - 2; x >= 0; x--) {
                if (now - startDrag.t > 200) {
                  break;
                }
                startDrag = dragPoints[x];
              }
              var isSwipingRight = (releaseX >= dragPoints[dragPoints.length - 2].x);
              var releaseSwipeCompletion = getSwipeCompletion(releaseX);
              var velocity = Math.abs(startDrag.x - releaseX) / (now - startDrag.t);
              disableRenderStartViewId = backView.viewId;
              disableAnimation = (releaseSwipeCompletion < 0.03 || releaseSwipeCompletion > 0.97);
              if (isSwipingRight && (releaseSwipeCompletion > 0.5 || velocity > 0.1)) {
                var speed = (velocity > 0.5 || velocity < 0.05 || releaseX > windowWidth - 45) ? 'fast' : 'slow';
                navSwipeAttr(disableAnimation ? '' : speed);
                backView.go();
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.complete(!disableAnimation, speed);
              } else {
                navSwipeAttr(disableAnimation ? '' : 'fast');
                disableRenderStartViewId = null;
                viewTransition.cancel(!disableAnimation);
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.cancel(!disableAnimation, 'fast', cancelData);
                disableAnimation = null;
              }
            }
            ionic.offGesture(deregDrag, 'drag', onDrag);
            ionic.offGesture(deregRelease, 'release', onRelease);
            windowWidth = viewTransition = dragPoints = null;
            self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(false);
          }
          function getDragX(ev) {
            return ionic.tap.pointerCoord(ev.gesture.srcEvent).x;
          }
          function getSwipeCompletion(dragX) {
            return (dragX - startDragX) / windowWidth;
          }
          deregDragStart = ionic.onGesture('dragstart', onDragStart, $element[0]);
          $scope.$on('$destroy', function() {
            ionic.offGesture(deregDragStart, 'dragstart', onDragStart);
            ionic.offGesture(deregDrag, 'drag', onDrag);
            ionic.offGesture(deregRelease, 'release', onRelease);
            self.element = viewTransition = associatedNavBarCtrl = null;
          });
        };
        function navSwipeAttr(val) {
          ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
        }
        function onTabsTop(ev, isTabsTop) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.hasTabsTop(isTabsTop);
        }
        function onBarSubheader(ev, isBarSubheader) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.hasBarSubheader(isBarSubheader);
        }
        function getAssociatedNavBarCtrl() {
          if (navBarDelegate) {
            for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
              if ($ionicNavBarDelegate._instances[x].$$delegateHandle == navBarDelegate) {
                return $ionicNavBarDelegate._instances[x];
              }
            }
          }
          return $element.inheritedData('$ionNavBarController');
        }
      }]);
      IonicModule.controller('$ionicRefresher', ['$scope', '$attrs', '$element', '$ionicBind', '$timeout', function($scope, $attrs, $element, $ionicBind, $timeout) {
        var self = this,
            isDragging = false,
            isOverscrolling = false,
            dragOffset = 0,
            lastOverscroll = 0,
            ptrThreshold = 60,
            activated = false,
            scrollTime = 500,
            startY = null,
            deltaY = null,
            canOverscroll = true,
            scrollParent,
            scrollChild;
        if (!isDefined($attrs.pullingIcon)) {
          $attrs.$set('pullingIcon', 'ion-android-arrow-down');
        }
        $scope.showSpinner = !isDefined($attrs.refreshingIcon) && $attrs.spinner != 'none';
        $scope.showIcon = isDefined($attrs.refreshingIcon);
        $ionicBind($scope, $attrs, {
          pullingIcon: '@',
          pullingText: '@',
          refreshingIcon: '@',
          refreshingText: '@',
          spinner: '@',
          disablePullingRotation: '@',
          $onRefresh: '&onRefresh',
          $onPulling: '&onPulling'
        });
        function handleTouchend() {
          if (!canOverscroll && !isDragging) {
            return;
          }
          startY = null;
          if (!isDragging) {
            dragOffset = 0;
            isOverscrolling = false;
            setScrollLock(false);
          } else {
            isDragging = false;
            dragOffset = 0;
            if (lastOverscroll > ptrThreshold) {
              start();
              scrollTo(ptrThreshold, scrollTime);
            } else {
              scrollTo(0, scrollTime, deactivate);
              isOverscrolling = false;
            }
          }
        }
        function handleTouchmove(e) {
          if (!canOverscroll || e.touches.length > 1) {
            return;
          }
          if (startY === null) {
            startY = parseInt(e.touches[0].screenY, 10);
          }
          if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && scrollParent.scrollTop === 0) {
            isDragging = true;
            e.preventDefault();
          }
          deltaY = parseInt(e.touches[0].screenY, 10) - startY;
          if (deltaY - dragOffset <= 0 || scrollParent.scrollTop !== 0) {
            if (isOverscrolling) {
              isOverscrolling = false;
              setScrollLock(false);
            }
            if (isDragging) {
              nativescroll(scrollParent, parseInt(deltaY - dragOffset, 10) * -1);
            }
            if (lastOverscroll !== 0) {
              overscroll(0);
            }
            return;
          } else if (deltaY > 0 && scrollParent.scrollTop === 0 && !isOverscrolling) {
            dragOffset = deltaY;
          }
          e.preventDefault();
          if (!isOverscrolling) {
            isOverscrolling = true;
            setScrollLock(true);
          }
          isDragging = true;
          overscroll(parseInt((deltaY - dragOffset) / 3, 10));
          if (!activated && lastOverscroll > ptrThreshold) {
            activated = true;
            ionic.requestAnimationFrame(activate);
          } else if (activated && lastOverscroll < ptrThreshold) {
            activated = false;
            ionic.requestAnimationFrame(deactivate);
          }
        }
        function handleScroll(e) {
          canOverscroll = (e.target.scrollTop === 0) || isDragging;
        }
        function overscroll(val) {
          scrollChild.style[ionic.CSS.TRANSFORM] = 'translateY(' + val + 'px)';
          lastOverscroll = val;
        }
        function nativescroll(target, newScrollTop) {
          target.scrollTop = newScrollTop;
          var e = document.createEvent("UIEvents");
          e.initUIEvent("scroll", true, true, window, 1);
          target.dispatchEvent(e);
        }
        function setScrollLock(enabled) {
          if (enabled) {
            ionic.requestAnimationFrame(function() {
              scrollChild.classList.add('overscroll');
              show();
            });
          } else {
            ionic.requestAnimationFrame(function() {
              scrollChild.classList.remove('overscroll');
              hide();
              deactivate();
            });
          }
        }
        $scope.$on('scroll.refreshComplete', function() {
          $timeout(function() {
            ionic.requestAnimationFrame(tail);
            scrollTo(0, scrollTime, deactivate);
            $timeout(function() {
              if (isOverscrolling) {
                isOverscrolling = false;
                setScrollLock(false);
              }
            }, scrollTime);
          }, scrollTime);
        });
        function scrollTo(Y, duration, callback) {
          var start = Date.now(),
              from = lastOverscroll;
          if (from === Y) {
            callback();
            return;
          }
          function easeOutCubic(t) {
            return (--t) * t * t + 1;
          }
          function scroll() {
            var currentTime = Date.now(),
                time = Math.min(1, ((currentTime - start) / duration)),
                easedT = easeOutCubic(time);
            overscroll(parseInt((easedT * (Y - from)) + from, 10));
            if (time < 1) {
              ionic.requestAnimationFrame(scroll);
            } else {
              if (Y < 5 && Y > -5) {
                isOverscrolling = false;
                setScrollLock(false);
              }
              callback && callback();
            }
          }
          ionic.requestAnimationFrame(scroll);
        }
        self.init = function() {
          scrollParent = $element.parent().parent()[0];
          scrollChild = $element.parent()[0];
          if (!scrollParent || !scrollParent.classList.contains('ionic-scroll') || !scrollChild || !scrollChild.classList.contains('scroll')) {
            throw new Error('Refresher must be immediate child of ion-content or ion-scroll');
          }
          ionic.on('touchmove', handleTouchmove, scrollChild);
          ionic.on('touchend', handleTouchend, scrollChild);
          ionic.on('scroll', handleScroll, scrollParent);
          $scope.$on('$destroy', destroy);
        };
        function destroy() {
          ionic.off('touchmove', handleTouchmove, scrollChild);
          ionic.off('touchend', handleTouchend, scrollChild);
          ionic.off('scroll', handleScroll, scrollParent);
          scrollParent = null;
          scrollChild = null;
        }
        self.getRefresherDomMethods = function() {
          return {
            activate: activate,
            deactivate: deactivate,
            start: start,
            show: show,
            hide: hide,
            tail: tail
          };
        };
        function activate() {
          $element[0].classList.add('active');
          $scope.$onPulling();
        }
        function deactivate() {
          $timeout(function() {
            $element.removeClass('active refreshing refreshing-tail');
            if (activated)
              activated = false;
          }, 150);
        }
        function start() {
          $element[0].classList.add('refreshing');
          $scope.$onRefresh();
        }
        function show() {
          $element[0].classList.remove('invisible');
        }
        function hide() {
          $element[0].classList.add('invisible');
        }
        function tail() {
          $element[0].classList.add('refreshing-tail');
        }
        self.__handleTouchmove = handleTouchmove;
        self.__getScrollChild = function() {
          return scrollChild;
        };
        self.__getScrollParent = function() {
          return scrollParent;
        };
      }]);
      IonicModule.controller('$ionicScroll', ['$scope', 'scrollViewOptions', '$timeout', '$window', '$location', '$document', '$ionicScrollDelegate', '$ionicHistory', function($scope, scrollViewOptions, $timeout, $window, $location, $document, $ionicScrollDelegate, $ionicHistory) {
        var self = this;
        self.__timeout = $timeout;
        self._scrollViewOptions = scrollViewOptions;
        self.isNative = function() {
          return !!scrollViewOptions.nativeScrolling;
        };
        var element = self.element = scrollViewOptions.el;
        var $element = self.$element = jqLite(element);
        var scrollView;
        if (self.isNative()) {
          scrollView = self.scrollView = new ionic.views.ScrollNative(scrollViewOptions);
        } else {
          scrollView = self.scrollView = new ionic.views.Scroll(scrollViewOptions);
        }
        ($element.parent().length ? $element.parent() : $element).data('$$ionicScrollController', self);
        var deregisterInstance = $ionicScrollDelegate._registerInstance(self, scrollViewOptions.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        if (!isDefined(scrollViewOptions.bouncing)) {
          ionic.Platform.ready(function() {
            if (scrollView.options) {
              scrollView.options.bouncing = true;
              if (ionic.Platform.isAndroid()) {
                scrollView.options.bouncing = false;
                scrollView.options.deceleration = 0.95;
              }
            }
          });
        }
        var resize = angular.bind(scrollView, scrollView.resize);
        angular.element($window).on('resize', resize);
        var scrollFunc = function(e) {
          var detail = (e.originalEvent || e).detail || {};
          $scope.$onScroll && $scope.$onScroll({
            event: e,
            scrollTop: detail.scrollTop || 0,
            scrollLeft: detail.scrollLeft || 0
          });
        };
        $element.on('scroll', scrollFunc);
        $scope.$on('$destroy', function() {
          deregisterInstance();
          scrollView && scrollView.__cleanup && scrollView.__cleanup();
          angular.element($window).off('resize', resize);
          $element.off('scroll', scrollFunc);
          scrollView = self.scrollView = scrollViewOptions = self._scrollViewOptions = scrollViewOptions.el = self._scrollViewOptions.el = $element = self.$element = element = null;
        });
        $timeout(function() {
          scrollView && scrollView.run && scrollView.run();
        });
        self.getScrollView = function() {
          return scrollView;
        };
        self.getScrollPosition = function() {
          return scrollView.getValues();
        };
        self.resize = function() {
          return $timeout(resize, 0, false).then(function() {
            $element && $element.triggerHandler('scroll-resize');
          });
        };
        self.scrollTop = function(shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollTo(0, 0, !!shouldAnimate);
          });
        };
        self.scrollBottom = function(shouldAnimate) {
          self.resize().then(function() {
            var max = scrollView.getScrollMax();
            scrollView.scrollTo(max.left, max.top, !!shouldAnimate);
          });
        };
        self.scrollTo = function(left, top, shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollTo(left, top, !!shouldAnimate);
          });
        };
        self.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {
          self.resize().then(function() {
            scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);
          });
        };
        self.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {
          self.resize().then(function() {
            scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);
          });
        };
        self.scrollBy = function(left, top, shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollBy(left, top, !!shouldAnimate);
          });
        };
        self.anchorScroll = function(shouldAnimate) {
          self.resize().then(function() {
            var hash = $location.hash();
            var elm = hash && $document[0].getElementById(hash);
            if (!(hash && elm)) {
              scrollView.scrollTo(0, 0, !!shouldAnimate);
              return;
            }
            var curElm = elm;
            var scrollLeft = 0,
                scrollTop = 0;
            do {
              if (curElm !== null)
                scrollLeft += curElm.offsetLeft;
              if (curElm !== null)
                scrollTop += curElm.offsetTop;
              curElm = curElm.offsetParent;
            } while (curElm.attributes != self.element.attributes && curElm.offsetParent);
            scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);
          });
        };
        self.freezeScroll = scrollView.freeze;
        self.freezeAllScrolls = function(shouldFreeze) {
          for (var i = 0; i < $ionicScrollDelegate._instances.length; i++) {
            $ionicScrollDelegate._instances[i].freezeScroll(shouldFreeze);
          }
        };
        self._setRefresher = function(refresherScope, refresherElement, refresherMethods) {
          self.refresher = refresherElement;
          var refresherHeight = self.refresher.clientHeight || 60;
          scrollView.activatePullToRefresh(refresherHeight, refresherMethods);
        };
      }]);
      IonicModule.controller('$ionicSideMenus', ['$scope', '$attrs', '$ionicSideMenuDelegate', '$ionicPlatform', '$ionicBody', '$ionicHistory', '$ionicScrollDelegate', 'IONIC_BACK_PRIORITY', function($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody, $ionicHistory, $ionicScrollDelegate, IONIC_BACK_PRIORITY) {
        var self = this;
        var rightShowing,
            leftShowing,
            isDragging;
        var startX,
            lastX,
            offsetX,
            isAsideExposed;
        var enableMenuWithBackViews = true;
        self.$scope = $scope;
        self.initialize = function(options) {
          self.left = options.left;
          self.right = options.right;
          self.setContent(options.content);
          self.dragThresholdX = options.dragThresholdX || 10;
          $ionicHistory.registerHistory(self.$scope);
        };
        self.setContent = function(content) {
          if (content) {
            self.content = content;
            self.content.onDrag = function(e) {
              self._handleDrag(e);
            };
            self.content.endDrag = function(e) {
              self._endDrag(e);
            };
          }
        };
        self.isOpenLeft = function() {
          return self.getOpenAmount() > 0;
        };
        self.isOpenRight = function() {
          return self.getOpenAmount() < 0;
        };
        self.toggleLeft = function(shouldOpen) {
          if (isAsideExposed || !self.left.isEnabled)
            return;
          var openAmount = self.getOpenAmount();
          if (arguments.length === 0) {
            shouldOpen = openAmount <= 0;
          }
          self.content.enableAnimation();
          if (!shouldOpen) {
            self.openPercentage(0);
          } else {
            self.openPercentage(100);
          }
        };
        self.toggleRight = function(shouldOpen) {
          if (isAsideExposed || !self.right.isEnabled)
            return;
          var openAmount = self.getOpenAmount();
          if (arguments.length === 0) {
            shouldOpen = openAmount >= 0;
          }
          self.content.enableAnimation();
          if (!shouldOpen) {
            self.openPercentage(0);
          } else {
            self.openPercentage(-100);
          }
        };
        self.toggle = function(side) {
          if (side == 'right') {
            self.toggleRight();
          } else {
            self.toggleLeft();
          }
        };
        self.close = function() {
          self.openPercentage(0);
        };
        self.getOpenAmount = function() {
          return self.content && self.content.getTranslateX() || 0;
        };
        self.getOpenRatio = function() {
          var amount = self.getOpenAmount();
          if (amount >= 0) {
            return amount / self.left.width;
          }
          return amount / self.right.width;
        };
        self.isOpen = function() {
          return self.getOpenAmount() !== 0;
        };
        self.getOpenPercentage = function() {
          return self.getOpenRatio() * 100;
        };
        self.openPercentage = function(percentage) {
          var p = percentage / 100;
          if (self.left && percentage >= 0) {
            self.openAmount(self.left.width * p);
          } else if (self.right && percentage < 0) {
            self.openAmount(self.right.width * p);
          }
          $ionicBody.enableClass((percentage !== 0), 'menu-open');
          freezeAllScrolls(false);
        };
        function freezeAllScrolls(shouldFreeze) {
          if (shouldFreeze && !self.isScrollFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);
          } else if (!shouldFreeze && self.isScrollFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(false);
          }
          self.isScrollFreeze = shouldFreeze;
        }
        self.openAmount = function(amount) {
          var maxLeft = self.left && self.left.width || 0;
          var maxRight = self.right && self.right.width || 0;
          if (!(self.left && self.left.isEnabled) && amount > 0) {
            self.content.setTranslateX(0);
            return;
          }
          if (!(self.right && self.right.isEnabled) && amount < 0) {
            self.content.setTranslateX(0);
            return;
          }
          if (leftShowing && amount > maxLeft) {
            self.content.setTranslateX(maxLeft);
            return;
          }
          if (rightShowing && amount < -maxRight) {
            self.content.setTranslateX(-maxRight);
            return;
          }
          self.content.setTranslateX(amount);
          if (amount >= 0) {
            leftShowing = true;
            rightShowing = false;
            if (amount > 0) {
              self.right && self.right.pushDown && self.right.pushDown();
              self.left && self.left.bringUp && self.left.bringUp();
            }
          } else {
            rightShowing = true;
            leftShowing = false;
            self.right && self.right.bringUp && self.right.bringUp();
            self.left && self.left.pushDown && self.left.pushDown();
          }
        };
        self.snapToRest = function(e) {
          self.content.enableAnimation();
          isDragging = false;
          var ratio = self.getOpenRatio();
          if (ratio === 0) {
            self.openPercentage(0);
            return;
          }
          var velocityThreshold = 0.3;
          var velocityX = e.gesture.velocityX;
          var direction = e.gesture.direction;
          if (ratio > 0 && ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
            self.openPercentage(0);
          } else if (ratio > 0.5 && direction == 'left' && velocityX < velocityThreshold) {
            self.openPercentage(100);
          } else if (ratio < 0 && ratio > -0.5 && direction == 'left' && velocityX < velocityThreshold) {
            self.openPercentage(0);
          } else if (ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
            self.openPercentage(-100);
          } else if (direction == 'right' && ratio >= 0 && (ratio >= 0.5 || velocityX > velocityThreshold)) {
            self.openPercentage(100);
          } else if (direction == 'left' && ratio <= 0 && (ratio <= -0.5 || velocityX > velocityThreshold)) {
            self.openPercentage(-100);
          } else {
            self.openPercentage(0);
          }
        };
        self.enableMenuWithBackViews = function(val) {
          if (arguments.length) {
            enableMenuWithBackViews = !!val;
          }
          return enableMenuWithBackViews;
        };
        self.isAsideExposed = function() {
          return !!isAsideExposed;
        };
        self.exposeAside = function(shouldExposeAside) {
          if (!(self.left && self.left.isEnabled) && !(self.right && self.right.isEnabled))
            return;
          self.close();
          isAsideExposed = shouldExposeAside;
          if (self.left && self.left.isEnabled) {
            self.content.setMarginLeft(isAsideExposed ? self.left.width : 0);
          } else if (self.right && self.right.isEnabled) {
            self.content.setMarginRight(isAsideExposed ? self.right.width : 0);
          }
          self.$scope.$emit('$ionicExposeAside', isAsideExposed);
        };
        self.activeAsideResizing = function(isResizing) {
          $ionicBody.enableClass(isResizing, 'aside-resizing');
        };
        self._endDrag = function(e) {
          freezeAllScrolls(false);
          if (isAsideExposed)
            return;
          if (isDragging) {
            self.snapToRest(e);
          }
          startX = null;
          lastX = null;
          offsetX = null;
        };
        self._handleDrag = function(e) {
          if (isAsideExposed || !$scope.dragContent)
            return;
          if (!startX) {
            startX = e.gesture.touches[0].pageX;
            lastX = startX;
          } else {
            lastX = e.gesture.touches[0].pageX;
          }
          if (!isDragging && Math.abs(lastX - startX) > self.dragThresholdX) {
            startX = lastX;
            isDragging = true;
            self.content.disableAnimation();
            offsetX = self.getOpenAmount();
          }
          if (isDragging) {
            self.openAmount(offsetX + (lastX - startX));
            freezeAllScrolls(true);
          }
        };
        self.canDragContent = function(canDrag) {
          if (arguments.length) {
            $scope.dragContent = !!canDrag;
          }
          return $scope.dragContent;
        };
        self.edgeThreshold = 25;
        self.edgeThresholdEnabled = false;
        self.edgeDragThreshold = function(value) {
          if (arguments.length) {
            if (isNumber(value) && value > 0) {
              self.edgeThreshold = value;
              self.edgeThresholdEnabled = true;
            } else {
              self.edgeThresholdEnabled = !!value;
            }
          }
          return self.edgeThresholdEnabled;
        };
        self.isDraggableTarget = function(e) {
          var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen();
          var startX = e.gesture.startEvent && e.gesture.startEvent.center && e.gesture.startEvent.center.pageX;
          var dragIsWithinBounds = !shouldOnlyAllowEdgeDrag || startX <= self.edgeThreshold || startX >= self.content.element.offsetWidth - self.edgeThreshold;
          var backView = $ionicHistory.backView();
          var menuEnabled = enableMenuWithBackViews ? true : !backView;
          if (!menuEnabled) {
            var currentView = $ionicHistory.currentView() || {};
            return backView.historyId !== currentView.historyId;
          }
          return ($scope.dragContent || self.isOpen()) && dragIsWithinBounds && !e.gesture.srcEvent.defaultPrevented && menuEnabled && !e.target.tagName.match(/input|textarea|select|object|embed/i) && !e.target.isContentEditable && !(e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll') == 'true');
        };
        $scope.sideMenuContentTranslateX = 0;
        var deregisterBackButtonAction = noop;
        var closeSideMenu = angular.bind(self, self.close);
        $scope.$watch(function() {
          return self.getOpenAmount() !== 0;
        }, function(isOpen) {
          deregisterBackButtonAction();
          if (isOpen) {
            deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(closeSideMenu, IONIC_BACK_PRIORITY.sideMenu);
          }
        });
        var deregisterInstance = $ionicSideMenuDelegate._registerInstance(self, $attrs.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on('$destroy', function() {
          deregisterInstance();
          deregisterBackButtonAction();
          self.$scope = null;
          if (self.content) {
            self.content.element = null;
            self.content = null;
          }
          freezeAllScrolls(false);
        });
        self.initialize({
          left: {width: 275},
          right: {width: 275}
        });
      }]);
      (function(ionic) {
        var TRANSLATE32 = 'translate(32,32)';
        var STROKE_OPACITY = 'stroke-opacity';
        var ROUND = 'round';
        var INDEFINITE = 'indefinite';
        var DURATION = '750ms';
        var NONE = 'none';
        var SHORTCUTS = {
          a: 'animate',
          an: 'attributeName',
          at: 'animateTransform',
          c: 'circle',
          da: 'stroke-dasharray',
          os: 'stroke-dashoffset',
          f: 'fill',
          lc: 'stroke-linecap',
          rc: 'repeatCount',
          sw: 'stroke-width',
          t: 'transform',
          v: 'values'
        };
        var SPIN_ANIMATION = {
          v: '0,32,32;360,32,32',
          an: 'transform',
          type: 'rotate',
          rc: INDEFINITE,
          dur: DURATION
        };
        function createSvgElement(tagName, data, parent, spinnerName) {
          var ele = document.createElement(SHORTCUTS[tagName] || tagName);
          var k,
              x,
              y;
          for (k in data) {
            if (angular.isArray(data[k])) {
              for (x = 0; x < data[k].length; x++) {
                if (data[k][x].fn) {
                  for (y = 0; y < data[k][x].t; y++) {
                    createSvgElement(k, data[k][x].fn(y, spinnerName), ele, spinnerName);
                  }
                } else {
                  createSvgElement(k, data[k][x], ele, spinnerName);
                }
              }
            } else {
              setSvgAttribute(ele, k, data[k]);
            }
          }
          parent.appendChild(ele);
        }
        function setSvgAttribute(ele, k, v) {
          ele.setAttribute(SHORTCUTS[k] || k, v);
        }
        function animationValues(strValues, i) {
          var values = strValues.split(';');
          var back = values.slice(i);
          var front = values.slice(0, values.length - back.length);
          values = back.concat(front).reverse();
          return values.join(';') + ';' + values[0];
        }
        var IOS_SPINNER = {
          sw: 4,
          lc: ROUND,
          line: [{
            fn: function(i, spinnerName) {
              return {
                y1: spinnerName == 'ios' ? 17 : 12,
                y2: spinnerName == 'ios' ? 29 : 20,
                t: TRANSLATE32 + ' rotate(' + (30 * i + (i < 6 ? 180 : -180)) + ')',
                a: [{
                  fn: function() {
                    return {
                      an: STROKE_OPACITY,
                      dur: DURATION,
                      v: animationValues('0;.1;.15;.25;.35;.45;.55;.65;.7;.85;1', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 12
          }]
        };
        var spinners = {
          android: {c: [{
              sw: 6,
              da: 128,
              os: 82,
              r: 26,
              cx: 32,
              cy: 32,
              f: NONE
            }]},
          ios: IOS_SPINNER,
          'ios-small': IOS_SPINNER,
          bubbles: {
            sw: 0,
            c: [{
              fn: function(i) {
                return {
                  cx: 24 * Math.cos(2 * Math.PI * i / 8),
                  cy: 24 * Math.sin(2 * Math.PI * i / 8),
                  t: TRANSLATE32,
                  a: [{
                    fn: function() {
                      return {
                        an: 'r',
                        dur: DURATION,
                        v: animationValues('1;2;3;4;5;6;7;8', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 8
            }]
          },
          circles: {c: [{
              fn: function(i) {
                return {
                  r: 5,
                  cx: 24 * Math.cos(2 * Math.PI * i / 8),
                  cy: 24 * Math.sin(2 * Math.PI * i / 8),
                  t: TRANSLATE32,
                  sw: 0,
                  a: [{
                    fn: function() {
                      return {
                        an: 'fill-opacity',
                        dur: DURATION,
                        v: animationValues('.3;.3;.3;.4;.7;.85;.9;1', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 8
            }]},
          crescent: {c: [{
              sw: 4,
              da: 128,
              os: 82,
              r: 26,
              cx: 32,
              cy: 32,
              f: NONE,
              at: [SPIN_ANIMATION]
            }]},
          dots: {c: [{
              fn: function(i) {
                return {
                  cx: 16 + (16 * i),
                  cy: 32,
                  sw: 0,
                  a: [{
                    fn: function() {
                      return {
                        an: 'fill-opacity',
                        dur: DURATION,
                        v: animationValues('.5;.6;.8;1;.8;.6;.5', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: 'r',
                        dur: DURATION,
                        v: animationValues('4;5;6;5;4;3;3', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 3
            }]},
          lines: {
            sw: 7,
            lc: ROUND,
            line: [{
              fn: function(i) {
                return {
                  x1: 10 + (i * 14),
                  x2: 10 + (i * 14),
                  a: [{
                    fn: function() {
                      return {
                        an: 'y1',
                        dur: DURATION,
                        v: animationValues('16;18;28;18;16', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: 'y2',
                        dur: DURATION,
                        v: animationValues('48;44;36;46;48', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: STROKE_OPACITY,
                        dur: DURATION,
                        v: animationValues('1;.8;.5;.4;1', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 4
            }]
          },
          ripple: {
            f: NONE,
            'fill-rule': 'evenodd',
            sw: 3,
            circle: [{
              fn: function(i) {
                return {
                  cx: 32,
                  cy: 32,
                  a: [{
                    fn: function() {
                      return {
                        an: 'r',
                        begin: (i * -1) + 's',
                        dur: '2s',
                        v: '0;24',
                        keyTimes: '0;1',
                        keySplines: '0.1,0.2,0.3,1',
                        calcMode: 'spline',
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: STROKE_OPACITY,
                        begin: (i * -1) + 's',
                        dur: '2s',
                        v: '.2;1;.2;0',
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 2
            }]
          },
          spiral: {
            defs: [{linearGradient: [{
                id: 'sGD',
                gradientUnits: 'userSpaceOnUse',
                x1: 55,
                y1: 46,
                x2: 2,
                y2: 46,
                stop: [{
                  offset: 0.1,
                  class: 'stop1'
                }, {
                  offset: 1,
                  class: 'stop2'
                }]
              }]}],
            g: [{
              sw: 4,
              lc: ROUND,
              f: NONE,
              path: [{
                stroke: 'url(#sGD)',
                d: 'M4,32 c0,15,12,28,28,28c8,0,16-4,21-9'
              }, {d: 'M60,32 C60,16,47.464,4,32,4S4,16,4,32'}],
              at: [SPIN_ANIMATION]
            }]
          }
        };
        var animations = {android: function(ele) {
            var rIndex = 0;
            var rotateCircle = 0;
            var startTime;
            var svgEle = ele.querySelector('g');
            var circleEle = ele.querySelector('circle');
            function run() {
              var v = easeInOutCubic(Date.now() - startTime, 650);
              var scaleX = 1;
              var translateX = 0;
              var dasharray = (188 - (58 * v));
              var dashoffset = (182 - (182 * v));
              if (rIndex % 2) {
                scaleX = -1;
                translateX = -64;
                dasharray = (128 - (-58 * v));
                dashoffset = (182 * v);
              }
              var rotateLine = [0, -101, -90, -11, -180, 79, -270, -191][rIndex];
              setSvgAttribute(circleEle, 'da', Math.max(Math.min(dasharray, 188), 128));
              setSvgAttribute(circleEle, 'os', Math.max(Math.min(dashoffset, 182), 0));
              setSvgAttribute(circleEle, 't', 'scale(' + scaleX + ',1) translate(' + translateX + ',0) rotate(' + rotateLine + ',32,32)');
              rotateCircle += 4.1;
              if (rotateCircle > 359)
                rotateCircle = 0;
              setSvgAttribute(svgEle, 't', 'rotate(' + rotateCircle + ',32,32)');
              if (v >= 1) {
                rIndex++;
                if (rIndex > 7)
                  rIndex = 0;
                startTime = Date.now();
              }
              ionic.requestAnimationFrame(run);
            }
            return function() {
              startTime = Date.now();
              run();
            };
          }};
        function easeInOutCubic(t, c) {
          t /= c / 2;
          if (t < 1)
            return 1 / 2 * t * t * t;
          t -= 2;
          return 1 / 2 * (t * t * t + 2);
        }
        IonicModule.controller('$ionicSpinner', ['$element', '$attrs', function($element, $attrs) {
          var spinnerName,
              spinner;
          this.init = function() {
            var override = null;
            if (ionic.Platform.platform() === 'windowsphone') {
              override = 'android';
            }
            spinnerName = $attrs.icon || override || ionic.Platform.platform();
            spinner = spinners[spinnerName];
            if (!spinner) {
              spinnerName = 'ios';
              spinner = spinners.ios;
            }
            var container = document.createElement('div');
            createSvgElement('svg', {
              viewBox: '0 0 64 64',
              g: [spinners[spinnerName]]
            }, container, spinnerName);
            $element.html(container.innerHTML);
            this.start();
            return spinnerName;
          };
          this.start = function() {
            animations[spinnerName] && animations[spinnerName]($element[0])();
          };
        }]);
      })(ionic);
      IonicModule.controller('$ionicTab', ['$scope', '$ionicHistory', '$attrs', '$location', '$state', function($scope, $ionicHistory, $attrs, $location, $state) {
        this.$scope = $scope;
        this.hrefMatchesState = function() {
          return $attrs.href && $location.path().indexOf($attrs.href.replace(/^#/, '').replace(/\/$/, '')) === 0;
        };
        this.srefMatchesState = function() {
          return $attrs.uiSref && $state.includes($attrs.uiSref.split('(')[0]);
        };
        this.navNameMatchesState = function() {
          return this.navViewName && $ionicHistory.isCurrentStateNavView(this.navViewName);
        };
        this.tabMatchesState = function() {
          return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();
        };
      }]);
      IonicModule.controller('$ionicTabs', ['$scope', '$element', '$ionicHistory', function($scope, $element, $ionicHistory) {
        var self = this;
        var selectedTab = null;
        var previousSelectedTab = null;
        var selectedTabIndex;
        self.tabs = [];
        self.selectedIndex = function() {
          return self.tabs.indexOf(selectedTab);
        };
        self.selectedTab = function() {
          return selectedTab;
        };
        self.previousSelectedTab = function() {
          return previousSelectedTab;
        };
        self.add = function(tab) {
          $ionicHistory.registerHistory(tab);
          self.tabs.push(tab);
        };
        self.remove = function(tab) {
          var tabIndex = self.tabs.indexOf(tab);
          if (tabIndex === -1) {
            return;
          }
          if (tab.$tabSelected) {
            self.deselect(tab);
            if (self.tabs.length === 1) {} else {
              var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;
              self.select(self.tabs[newTabIndex]);
            }
          }
          self.tabs.splice(tabIndex, 1);
        };
        self.deselect = function(tab) {
          if (tab.$tabSelected) {
            previousSelectedTab = selectedTab;
            selectedTab = selectedTabIndex = null;
            tab.$tabSelected = false;
            (tab.onDeselect || noop)();
            tab.$broadcast && tab.$broadcast('$ionicHistory.deselect');
          }
        };
        self.select = function(tab, shouldEmitEvent) {
          var tabIndex;
          if (isNumber(tab)) {
            tabIndex = tab;
            if (tabIndex >= self.tabs.length)
              return;
            tab = self.tabs[tabIndex];
          } else {
            tabIndex = self.tabs.indexOf(tab);
          }
          if (arguments.length === 1) {
            shouldEmitEvent = !!(tab.navViewName || tab.uiSref);
          }
          if (selectedTab && selectedTab.$historyId == tab.$historyId) {
            if (shouldEmitEvent) {
              $ionicHistory.goToHistoryRoot(tab.$historyId);
            }
          } else if (selectedTabIndex !== tabIndex) {
            forEach(self.tabs, function(tab) {
              self.deselect(tab);
            });
            selectedTab = tab;
            selectedTabIndex = tabIndex;
            if (self.$scope && self.$scope.$parent) {
              self.$scope.$parent.$activeHistoryId = tab.$historyId;
            }
            tab.$tabSelected = true;
            (tab.onSelect || noop)();
            if (shouldEmitEvent) {
              $scope.$emit('$ionicHistory.change', {
                type: 'tab',
                tabIndex: tabIndex,
                historyId: tab.$historyId,
                navViewName: tab.navViewName,
                hasNavView: !!tab.navViewName,
                title: tab.title,
                url: tab.href,
                uiSref: tab.uiSref
              });
            }
          }
        };
        self.hasActiveScope = function() {
          for (var x = 0; x < self.tabs.length; x++) {
            if ($ionicHistory.isActiveScope(self.tabs[x])) {
              return true;
            }
          }
          return false;
        };
      }]);
      IonicModule.controller('$ionicView', ['$scope', '$element', '$attrs', '$compile', '$rootScope', function($scope, $element, $attrs, $compile, $rootScope) {
        var self = this;
        var navElementHtml = {};
        var navViewCtrl;
        var navBarDelegateHandle;
        var hasViewHeaderBar;
        var deregisters = [];
        var viewTitle;
        var deregIonNavBarInit = $scope.$on('ionNavBar.init', function(ev, delegateHandle) {
          ev.stopPropagation();
          navBarDelegateHandle = delegateHandle;
        });
        self.init = function() {
          deregIonNavBarInit();
          var modalCtrl = $element.inheritedData('$ionModalController');
          navViewCtrl = $element.inheritedData('$ionNavViewController');
          if (!navViewCtrl || modalCtrl)
            return;
          $scope.$on('$ionicView.beforeEnter', self.beforeEnter);
          $scope.$on('$ionicView.afterEnter', afterEnter);
          $scope.$on('$ionicView.beforeLeave', deregisterFns);
        };
        self.beforeEnter = function(ev, transData) {
          if (transData && !transData.viewNotified) {
            transData.viewNotified = true;
            if (!$rootScope.$$phase)
              $scope.$digest();
            viewTitle = isDefined($attrs.viewTitle) ? $attrs.viewTitle : $attrs.title;
            var navBarItems = {};
            for (var n in navElementHtml) {
              navBarItems[n] = generateNavBarItem(navElementHtml[n]);
            }
            navViewCtrl.beforeEnter(extend(transData, {
              title: viewTitle,
              showBack: !attrTrue('hideBackButton'),
              navBarItems: navBarItems,
              navBarDelegate: navBarDelegateHandle || null,
              showNavBar: !attrTrue('hideNavBar'),
              hasHeaderBar: !!hasViewHeaderBar
            }));
            deregisterFns();
          }
        };
        function afterEnter() {
          var viewTitleAttr = isDefined($attrs.viewTitle) && 'viewTitle' || isDefined($attrs.title) && 'title';
          if (viewTitleAttr) {
            titleUpdate($attrs[viewTitleAttr]);
            deregisters.push($attrs.$observe(viewTitleAttr, titleUpdate));
          }
          if (isDefined($attrs.hideBackButton)) {
            deregisters.push($scope.$watch($attrs.hideBackButton, function(val) {
              navViewCtrl.showBackButton(!val);
            }));
          }
          if (isDefined($attrs.hideNavBar)) {
            deregisters.push($scope.$watch($attrs.hideNavBar, function(val) {
              navViewCtrl.showBar(!val);
            }));
          }
        }
        function titleUpdate(newTitle) {
          if (isDefined(newTitle) && newTitle !== viewTitle) {
            viewTitle = newTitle;
            navViewCtrl.title(viewTitle);
          }
        }
        function deregisterFns() {
          for (var x = 0; x < deregisters.length; x++) {
            deregisters[x]();
          }
          deregisters = [];
        }
        function generateNavBarItem(html) {
          if (html) {
            return $compile(html)($scope.$new());
          }
        }
        function attrTrue(key) {
          return !!$scope.$eval($attrs[key]);
        }
        self.navElement = function(type, html) {
          navElementHtml[type] = html;
        };
      }]);
      IonicModule.directive('ionActionSheet', ['$document', function($document) {
        return {
          restrict: 'E',
          scope: true,
          replace: true,
          link: function($scope, $element) {
            var keyUp = function(e) {
              if (e.which == 27) {
                $scope.cancel();
                $scope.$apply();
              }
            };
            var backdropClick = function(e) {
              if (e.target == $element[0]) {
                $scope.cancel();
                $scope.$apply();
              }
            };
            $scope.$on('$destroy', function() {
              $element.remove();
              $document.unbind('keyup', keyUp);
            });
            $document.bind('keyup', keyUp);
            $element.bind('click', backdropClick);
          },
          template: '<div class="action-sheet-backdrop">' + '<div class="action-sheet-wrapper">' + '<div class="action-sheet" ng-class="{\'action-sheet-has-icons\': $actionSheetHasIcon}">' + '<div class="action-sheet-group action-sheet-options">' + '<div class="action-sheet-title" ng-if="titleText" ng-bind-html="titleText"></div>' + '<button class="button action-sheet-option" ng-click="buttonClicked($index)" ng-repeat="b in buttons" ng-bind-html="b.text"></button>' + '<button class="button destructive action-sheet-destructive" ng-if="destructiveText" ng-click="destructiveButtonClicked()" ng-bind-html="destructiveText"></button>' + '</div>' + '<div class="action-sheet-group action-sheet-cancel" ng-if="cancelText">' + '<button class="button" ng-click="cancel()" ng-bind-html="cancelText"></button>' + '</div>' + '</div>' + '</div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionCheckbox', ['$ionicConfig', function($ionicConfig) {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<label class="item item-checkbox">' + '<div class="checkbox checkbox-input-hidden disable-pointer-events">' + '<input type="checkbox">' + '<i class="checkbox-icon"></i>' + '</div>' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '</label>',
          compile: function(element, attr) {
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-checked': attr.ngChecked,
              'ng-disabled': attr.ngDisabled,
              'ng-true-value': attr.ngTrueValue,
              'ng-false-value': attr.ngFalseValue,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            var checkboxWrapper = element[0].querySelector('.checkbox');
            checkboxWrapper.classList.add('checkbox-' + $ionicConfig.form.checkbox());
          }
        };
      }]);
      IonicModule.directive('collectionRepeat', CollectionRepeatDirective).factory('$ionicCollectionManager', RepeatManagerFactory);
      var ONE_PX_TRANSPARENT_IMG_SRC = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
      var WIDTH_HEIGHT_REGEX = /height:.*?px;\s*width:.*?px/;
      var DEFAULT_RENDER_BUFFER = 3;
      CollectionRepeatDirective.$inject = ['$ionicCollectionManager', '$parse', '$window', '$$rAF', '$rootScope', '$timeout'];
      function CollectionRepeatDirective($ionicCollectionManager, $parse, $window, $$rAF, $rootScope, $timeout) {
        return {
          restrict: 'A',
          priority: 1000,
          transclude: 'element',
          $$tlb: true,
          require: '^^$ionicScroll',
          link: postLink
        };
        function postLink(scope, element, attr, scrollCtrl, transclude) {
          var scrollView = scrollCtrl.scrollView;
          var node = element[0];
          var containerNode = angular.element('<div class="collection-repeat-container">')[0];
          node.parentNode.replaceChild(containerNode, node);
          if (scrollView.options.scrollingX && scrollView.options.scrollingY) {
            throw new Error("collection-repeat expected a parent x or y scrollView, not " + "an xy scrollView.");
          }
          var repeatExpr = attr.collectionRepeat;
          var match = repeatExpr.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
          if (!match) {
            throw new Error("collection-repeat expected expression in form of '_item_ in " + "_collection_[ track by _id_]' but got '" + attr.collectionRepeat + "'.");
          }
          var keyExpr = match[1];
          var listExpr = match[2];
          var listGetter = $parse(listExpr);
          var heightData = {};
          var widthData = {};
          var computedStyleDimensions = {};
          var data = [];
          var repeatManager;
          var renderBufferExpr = attr.itemRenderBuffer || attr.collectionBufferSize;
          var renderBuffer = angular.isDefined(renderBufferExpr) ? parseInt(renderBufferExpr) : DEFAULT_RENDER_BUFFER;
          var heightExpr = attr.itemHeight || attr.collectionItemHeight;
          var widthExpr = attr.itemWidth || attr.collectionItemWidth;
          var afterItemsContainer = initAfterItemsContainer();
          var changeValidator = makeChangeValidator();
          initDimensions();
          scrollCtrl.$element.on('scroll-resize', refreshDimensions);
          angular.element($window).on('resize', onResize);
          var unlistenToExposeAside = $rootScope.$on('$ionicExposeAside', ionic.animationFrameThrottle(function() {
            scrollCtrl.scrollView.resize();
            onResize();
          }));
          $timeout(refreshDimensions, 0, false);
          function onResize() {
            if (changeValidator.resizeRequiresRefresh(scrollView.__clientWidth, scrollView.__clientHeight)) {
              refreshDimensions();
            }
          }
          scope.$watchCollection(listGetter, function(newValue) {
            data = newValue || (newValue = []);
            if (!angular.isArray(newValue)) {
              throw new Error("collection-repeat expected an array for '" + listExpr + "', " + "but got a " + typeof value);
            }
            scope.$$postDigest(function() {
              getRepeatManager().setData(data);
              if (changeValidator.dataChangeRequiresRefresh(data))
                refreshDimensions();
            });
          });
          scope.$on('$destroy', function() {
            angular.element($window).off('resize', onResize);
            unlistenToExposeAside();
            scrollCtrl.$element && scrollCtrl.$element.off('scroll-resize', refreshDimensions);
            computedStyleNode && computedStyleNode.parentNode && computedStyleNode.parentNode.removeChild(computedStyleNode);
            computedStyleScope && computedStyleScope.$destroy();
            computedStyleScope = computedStyleNode = null;
            repeatManager && repeatManager.destroy();
            repeatManager = null;
          });
          function makeChangeValidator() {
            var self;
            return (self = {
              dataLength: 0,
              width: 0,
              height: 0,
              resizeRequiresRefresh: function(newWidth, newHeight) {
                var requiresRefresh = self.dataLength && newWidth && newHeight && (newWidth !== self.width || newHeight !== self.height);
                self.width = newWidth;
                self.height = newHeight;
                return !!requiresRefresh;
              },
              dataChangeRequiresRefresh: function(newData) {
                var requiresRefresh = newData.length > 0 || newData.length < self.dataLength;
                self.dataLength = newData.length;
                return !!requiresRefresh;
              }
            });
          }
          function getRepeatManager() {
            return repeatManager || (repeatManager = new $ionicCollectionManager({
              afterItemsNode: afterItemsContainer[0],
              containerNode: containerNode,
              heightData: heightData,
              widthData: widthData,
              forceRefreshImages: !!(isDefined(attr.forceRefreshImages) && attr.forceRefreshImages !== 'false'),
              keyExpression: keyExpr,
              renderBuffer: renderBuffer,
              scope: scope,
              scrollView: scrollCtrl.scrollView,
              transclude: transclude
            }));
          }
          function initAfterItemsContainer() {
            var container = angular.element(scrollView.__content.querySelector('.collection-repeat-after-container'));
            if (!container.length) {
              var elementIsAfterRepeater = false;
              var afterNodes = [].filter.call(scrollView.__content.childNodes, function(node) {
                if (ionic.DomUtil.contains(node, containerNode)) {
                  elementIsAfterRepeater = true;
                  return false;
                }
                return elementIsAfterRepeater;
              });
              container = angular.element('<span class="collection-repeat-after-container">');
              if (scrollView.options.scrollingX) {
                container.addClass('horizontal');
              }
              container.append(afterNodes);
              scrollView.__content.appendChild(container[0]);
            }
            return container;
          }
          function initDimensions() {
            if (heightExpr) {
              parseDimensionAttr(heightExpr, heightData);
            } else {
              heightData.computed = true;
            }
            if (widthExpr) {
              parseDimensionAttr(widthExpr, widthData);
            } else {
              widthData.computed = true;
            }
          }
          function refreshDimensions() {
            var hasData = data.length > 0;
            if (hasData && (heightData.computed || widthData.computed)) {
              computeStyleDimensions();
            }
            if (hasData && heightData.computed) {
              heightData.value = computedStyleDimensions.height;
              if (!heightData.value) {
                throw new Error('collection-repeat tried to compute the height of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-height" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
              }
            } else if (!heightData.dynamic && heightData.getValue) {
              heightData.value = heightData.getValue();
            }
            if (hasData && widthData.computed) {
              widthData.value = computedStyleDimensions.width;
              if (!widthData.value) {
                throw new Error('collection-repeat tried to compute the width of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-width" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
              }
            } else if (!widthData.dynamic && widthData.getValue) {
              widthData.value = widthData.getValue();
            }
            getRepeatManager().refreshLayout();
          }
          function parseDimensionAttr(attrValue, dimensionData) {
            if (!attrValue)
              return;
            var parsedValue;
            try {
              parsedValue = $parse(attrValue);
            } catch (e) {
              if (attrValue.trim().match(/\d+(px|%)$/)) {
                attrValue = '"' + attrValue + '"';
              }
              parsedValue = $parse(attrValue);
            }
            var constantAttrValue = attrValue.replace(/(\'|\"|px|%)/g, '').trim();
            var isConstant = constantAttrValue.length && !/([a-zA-Z]|\$|:|\?)/.test(constantAttrValue);
            dimensionData.attrValue = attrValue;
            if (isConstant) {
              var intValue = parseInt(parsedValue());
              if (attrValue.indexOf('%') > -1) {
                var decimalValue = intValue / 100;
                dimensionData.getValue = dimensionData === heightData ? function() {
                  return Math.floor(decimalValue * scrollView.__clientHeight);
                } : function() {
                  return Math.floor(decimalValue * scrollView.__clientWidth);
                };
              } else {
                dimensionData.value = intValue;
              }
            } else {
              dimensionData.dynamic = true;
              dimensionData.getValue = dimensionData === heightData ? function heightGetter(scope, locals) {
                var result = parsedValue(scope, locals);
                if (result.charAt && result.charAt(result.length - 1) === '%') {
                  return Math.floor(parseInt(result) / 100 * scrollView.__clientHeight);
                }
                return parseInt(result);
              } : function widthGetter(scope, locals) {
                var result = parsedValue(scope, locals);
                if (result.charAt && result.charAt(result.length - 1) === '%') {
                  return Math.floor(parseInt(result) / 100 * scrollView.__clientWidth);
                }
                return parseInt(result);
              };
            }
          }
          var computedStyleNode;
          var computedStyleScope;
          function computeStyleDimensions() {
            if (!computedStyleNode) {
              transclude(computedStyleScope = scope.$new(), function(clone) {
                clone[0].removeAttribute('collection-repeat');
                computedStyleNode = clone[0];
              });
            }
            computedStyleScope[keyExpr] = (listGetter(scope) || [])[0];
            if (!$rootScope.$$phase)
              computedStyleScope.$digest();
            containerNode.appendChild(computedStyleNode);
            var style = $window.getComputedStyle(computedStyleNode);
            computedStyleDimensions.width = parseInt(style.width);
            computedStyleDimensions.height = parseInt(style.height);
            containerNode.removeChild(computedStyleNode);
          }
        }
      }
      RepeatManagerFactory.$inject = ['$rootScope', '$window', '$$rAF'];
      function RepeatManagerFactory($rootScope, $window, $$rAF) {
        var EMPTY_DIMENSION = {
          primaryPos: 0,
          secondaryPos: 0,
          primarySize: 0,
          secondarySize: 0,
          rowPrimarySize: 0
        };
        return function RepeatController(options) {
          var afterItemsNode = options.afterItemsNode;
          var containerNode = options.containerNode;
          var forceRefreshImages = options.forceRefreshImages;
          var heightData = options.heightData;
          var widthData = options.widthData;
          var keyExpression = options.keyExpression;
          var renderBuffer = options.renderBuffer;
          var scope = options.scope;
          var scrollView = options.scrollView;
          var transclude = options.transclude;
          var data = [];
          var getterLocals = {};
          var heightFn = heightData.getValue || function() {
            return heightData.value;
          };
          var heightGetter = function(index, value) {
            getterLocals[keyExpression] = value;
            getterLocals.$index = index;
            return heightFn(scope, getterLocals);
          };
          var widthFn = widthData.getValue || function() {
            return widthData.value;
          };
          var widthGetter = function(index, value) {
            getterLocals[keyExpression] = value;
            getterLocals.$index = index;
            return widthFn(scope, getterLocals);
          };
          var isVertical = !!scrollView.options.scrollingY;
          var isGridView = isVertical ? (widthData.dynamic || widthData.value !== scrollView.__clientWidth) : (heightData.dynamic || heightData.value !== scrollView.__clientHeight);
          var isStaticView = !heightData.dynamic && !widthData.dynamic;
          var PRIMARY = 'PRIMARY';
          var SECONDARY = 'SECONDARY';
          var TRANSLATE_TEMPLATE_STR = isVertical ? 'translate3d(SECONDARYpx,PRIMARYpx,0)' : 'translate3d(PRIMARYpx,SECONDARYpx,0)';
          var WIDTH_HEIGHT_TEMPLATE_STR = isVertical ? 'height: PRIMARYpx; width: SECONDARYpx;' : 'height: SECONDARYpx; width: PRIMARYpx;';
          var estimatedHeight;
          var estimatedWidth;
          var repeaterBeforeSize = 0;
          var repeaterAfterSize = 0;
          var renderStartIndex = -1;
          var renderEndIndex = -1;
          var renderAfterBoundary = -1;
          var renderBeforeBoundary = -1;
          var itemsPool = [];
          var itemsLeaving = [];
          var itemsEntering = [];
          var itemsShownMap = {};
          var nextItemId = 0;
          var scrollViewSetDimensions = isVertical ? function() {
            scrollView.setDimensions(null, null, null, view.getContentSize(), true);
          } : function() {
            scrollView.setDimensions(null, null, view.getContentSize(), null, true);
          };
          var view = isVertical ? new VerticalViewType() : new HorizontalViewType();
          (isGridView ? GridViewType : ListViewType).call(view);
          (isStaticView ? StaticViewType : DynamicViewType).call(view);
          var contentSizeStr = isVertical ? 'getContentHeight' : 'getContentWidth';
          var originalGetContentSize = scrollView.options[contentSizeStr];
          scrollView.options[contentSizeStr] = angular.bind(view, view.getContentSize);
          scrollView.__$callback = scrollView.__callback;
          scrollView.__callback = function(transformLeft, transformTop, zoom, wasResize) {
            var scrollValue = view.getScrollValue();
            if (renderStartIndex === -1 || scrollValue + view.scrollPrimarySize > renderAfterBoundary || scrollValue < renderBeforeBoundary) {
              render();
            }
            scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);
          };
          var isLayoutReady = false;
          var isDataReady = false;
          this.refreshLayout = function() {
            if (data.length) {
              estimatedHeight = heightGetter(0, data[0]);
              estimatedWidth = widthGetter(0, data[0]);
            } else {
              estimatedHeight = 100;
              estimatedWidth = 100;
            }
            var style = getComputedStyle(afterItemsNode) || {};
            var firstStyle = afterItemsNode.firstElementChild && getComputedStyle(afterItemsNode.firstElementChild) || {};
            var lastStyle = afterItemsNode.lastElementChild && getComputedStyle(afterItemsNode.lastElementChild) || {};
            repeaterAfterSize = (parseInt(style[isVertical ? 'height' : 'width']) || 0) + (firstStyle && parseInt(firstStyle[isVertical ? 'marginTop' : 'marginLeft']) || 0) + (lastStyle && parseInt(lastStyle[isVertical ? 'marginBottom' : 'marginRight']) || 0);
            repeaterBeforeSize = 0;
            var current = containerNode;
            do {
              repeaterBeforeSize += current[isVertical ? 'offsetTop' : 'offsetLeft'];
            } while (ionic.DomUtil.contains(scrollView.__content, current = current.offsetParent));
            var containerPrevNode = containerNode.previousElementSibling;
            var beforeStyle = containerPrevNode ? $window.getComputedStyle(containerPrevNode) : {};
            var beforeMargin = parseInt(beforeStyle[isVertical ? 'marginBottom' : 'marginRight'] || 0);
            containerNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, -beforeMargin).replace(SECONDARY, 0);
            repeaterBeforeSize -= beforeMargin;
            if (!scrollView.__clientHeight || !scrollView.__clientWidth) {
              scrollView.__clientWidth = scrollView.__container.clientWidth;
              scrollView.__clientHeight = scrollView.__container.clientHeight;
            }
            (view.onRefreshLayout || angular.noop)();
            view.refreshDirection();
            scrollViewSetDimensions();
            if (!isLayoutReady) {
              var poolSize = Math.max(20, renderBuffer * 3);
              for (var i = 0; i < poolSize; i++) {
                itemsPool.push(new RepeatItem());
              }
            }
            isLayoutReady = true;
            if (isLayoutReady && isDataReady) {
              if (scrollView.__scrollLeft > scrollView.__maxScrollLeft || scrollView.__scrollTop > scrollView.__maxScrollTop) {
                scrollView.resize();
              }
              forceRerender(true);
            }
          };
          this.setData = function(newData) {
            data = newData;
            (view.onRefreshData || angular.noop)();
            isDataReady = true;
          };
          this.destroy = function() {
            render.destroyed = true;
            itemsPool.forEach(function(item) {
              item.scope.$destroy();
              item.scope = item.element = item.node = item.images = null;
            });
            itemsPool.length = itemsEntering.length = itemsLeaving.length = 0;
            itemsShownMap = {};
            scrollView.options[contentSizeStr] = originalGetContentSize;
            scrollView.__callback = scrollView.__$callback;
            scrollView.resize();
            (view.onDestroy || angular.noop)();
          };
          function forceRerender() {
            return render(true);
          }
          function render(forceRerender) {
            if (render.destroyed)
              return;
            var i;
            var ii;
            var item;
            var dim;
            var scope;
            var scrollValue = view.getScrollValue();
            var scrollValueEnd = scrollValue + view.scrollPrimarySize;
            view.updateRenderRange(scrollValue, scrollValueEnd);
            renderStartIndex = Math.max(0, renderStartIndex - renderBuffer);
            renderEndIndex = Math.min(data.length - 1, renderEndIndex + renderBuffer);
            for (i in itemsShownMap) {
              if (i < renderStartIndex || i > renderEndIndex) {
                item = itemsShownMap[i];
                delete itemsShownMap[i];
                itemsLeaving.push(item);
                item.isShown = false;
              }
            }
            for (i = renderStartIndex; i <= renderEndIndex; i++) {
              if (i >= data.length || (itemsShownMap[i] && !forceRerender))
                continue;
              item = itemsShownMap[i] || (itemsShownMap[i] = itemsLeaving.length ? itemsLeaving.pop() : itemsPool.length ? itemsPool.shift() : new RepeatItem());
              itemsEntering.push(item);
              item.isShown = true;
              scope = item.scope;
              scope.$index = i;
              scope[keyExpression] = data[i];
              scope.$first = (i === 0);
              scope.$last = (i === (data.length - 1));
              scope.$middle = !(scope.$first || scope.$last);
              scope.$odd = !(scope.$even = (i & 1) === 0);
              if (scope.$$disconnected)
                ionic.Utils.reconnectScope(item.scope);
              dim = view.getDimensions(i);
              if (item.secondaryPos !== dim.secondaryPos || item.primaryPos !== dim.primaryPos) {
                item.node.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, (item.primaryPos = dim.primaryPos)).replace(SECONDARY, (item.secondaryPos = dim.secondaryPos));
              }
              if (item.secondarySize !== dim.secondarySize || item.primarySize !== dim.primarySize) {
                item.node.style.cssText = item.node.style.cssText.replace(WIDTH_HEIGHT_REGEX, WIDTH_HEIGHT_TEMPLATE_STR.replace(PRIMARY, (item.primarySize = dim.primarySize) + 1).replace(SECONDARY, (item.secondarySize = dim.secondarySize)));
              }
            }
            if (renderEndIndex === data.length - 1) {
              dim = view.getDimensions(data.length - 1) || EMPTY_DIMENSION;
              afterItemsNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, dim.primaryPos + dim.primarySize).replace(SECONDARY, 0);
            }
            while (itemsLeaving.length) {
              item = itemsLeaving.pop();
              item.scope.$broadcast('$collectionRepeatLeave');
              ionic.Utils.disconnectScope(item.scope);
              itemsPool.push(item);
              item.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
              item.primaryPos = item.secondaryPos = null;
            }
            if (forceRefreshImages) {
              for (i = 0, ii = itemsEntering.length; i < ii && (item = itemsEntering[i]); i++) {
                if (!item.images)
                  continue;
                for (var j = 0,
                    jj = item.images.length,
                    img; j < jj && (img = item.images[j]); j++) {
                  var src = img.src;
                  img.src = ONE_PX_TRANSPARENT_IMG_SRC;
                  img.src = src;
                }
              }
            }
            if (forceRerender) {
              var rootScopePhase = $rootScope.$$phase;
              while (itemsEntering.length) {
                item = itemsEntering.pop();
                if (!rootScopePhase)
                  item.scope.$digest();
              }
            } else {
              digestEnteringItems();
            }
          }
          function digestEnteringItems() {
            var item;
            if (digestEnteringItems.running)
              return;
            digestEnteringItems.running = true;
            $$rAF(function process() {
              var rootScopePhase = $rootScope.$$phase;
              while (itemsEntering.length) {
                item = itemsEntering.pop();
                if (item.isShown) {
                  if (!rootScopePhase)
                    item.scope.$digest();
                }
              }
              digestEnteringItems.running = false;
            });
          }
          function RepeatItem() {
            var self = this;
            this.scope = scope.$new();
            this.id = 'item' + (nextItemId++);
            transclude(this.scope, function(clone) {
              self.element = clone;
              self.element.data('$$collectionRepeatItem', self);
              self.node = clone[0];
              self.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
              self.node.style.cssText += ' height: 0px; width: 0px;';
              ionic.Utils.disconnectScope(self.scope);
              containerNode.appendChild(self.node);
              self.images = clone[0].getElementsByTagName('img');
            });
          }
          function VerticalViewType() {
            this.getItemPrimarySize = heightGetter;
            this.getItemSecondarySize = widthGetter;
            this.getScrollValue = function() {
              return Math.max(0, Math.min(scrollView.__scrollTop - repeaterBeforeSize, scrollView.__maxScrollTop - repeaterBeforeSize - repeaterAfterSize));
            };
            this.refreshDirection = function() {
              this.scrollPrimarySize = scrollView.__clientHeight;
              this.scrollSecondarySize = scrollView.__clientWidth;
              this.estimatedPrimarySize = estimatedHeight;
              this.estimatedSecondarySize = estimatedWidth;
              this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientWidth / estimatedWidth) || 1;
            };
          }
          function HorizontalViewType() {
            this.getItemPrimarySize = widthGetter;
            this.getItemSecondarySize = heightGetter;
            this.getScrollValue = function() {
              return Math.max(0, Math.min(scrollView.__scrollLeft - repeaterBeforeSize, scrollView.__maxScrollLeft - repeaterBeforeSize - repeaterAfterSize));
            };
            this.refreshDirection = function() {
              this.scrollPrimarySize = scrollView.__clientWidth;
              this.scrollSecondarySize = scrollView.__clientHeight;
              this.estimatedPrimarySize = estimatedWidth;
              this.estimatedSecondarySize = estimatedHeight;
              this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientHeight / estimatedHeight) || 1;
            };
          }
          function GridViewType() {
            this.getEstimatedSecondaryPos = function(index) {
              return (index % this.estimatedItemsAcross) * this.estimatedSecondarySize;
            };
            this.getEstimatedPrimaryPos = function(index) {
              return Math.floor(index / this.estimatedItemsAcross) * this.estimatedPrimarySize;
            };
            this.getEstimatedIndex = function(scrollValue) {
              return Math.floor(scrollValue / this.estimatedPrimarySize) * this.estimatedItemsAcross;
            };
          }
          function ListViewType() {
            this.getEstimatedSecondaryPos = function() {
              return 0;
            };
            this.getEstimatedPrimaryPos = function(index) {
              return index * this.estimatedPrimarySize;
            };
            this.getEstimatedIndex = function(scrollValue) {
              return Math.floor((scrollValue) / this.estimatedPrimarySize);
            };
          }
          function StaticViewType() {
            this.getContentSize = function() {
              return this.getEstimatedPrimaryPos(data.length - 1) + this.estimatedPrimarySize + repeaterBeforeSize + repeaterAfterSize;
            };
            var dim = {};
            this.getDimensions = function(index) {
              dim.primaryPos = this.getEstimatedPrimaryPos(index);
              dim.secondaryPos = this.getEstimatedSecondaryPos(index);
              dim.primarySize = this.estimatedPrimarySize;
              dim.secondarySize = this.estimatedSecondarySize;
              return dim;
            };
            this.updateRenderRange = function(scrollValue, scrollValueEnd) {
              renderStartIndex = Math.max(0, this.getEstimatedIndex(scrollValue));
              renderEndIndex = Math.min(data.length - 1, this.getEstimatedIndex(scrollValueEnd) + this.estimatedItemsAcross - 1);
              renderBeforeBoundary = Math.max(0, this.getEstimatedPrimaryPos(renderStartIndex));
              renderAfterBoundary = this.getEstimatedPrimaryPos(renderEndIndex) + this.estimatedPrimarySize;
            };
          }
          function DynamicViewType() {
            var self = this;
            var debouncedScrollViewSetDimensions = ionic.debounce(scrollViewSetDimensions, 25, true);
            var calculateDimensions = isGridView ? calculateDimensionsGrid : calculateDimensionsList;
            var dimensionsIndex;
            var dimensions = [];
            function calculateDimensionsList(toIndex) {
              var i,
                  prevDimension,
                  dim;
              for (i = Math.max(0, dimensionsIndex); i <= toIndex && (dim = dimensions[i]); i++) {
                prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
                dim.primarySize = self.getItemPrimarySize(i, data[i]);
                dim.secondarySize = self.scrollSecondarySize;
                dim.primaryPos = prevDimension.primaryPos + prevDimension.primarySize;
                dim.secondaryPos = 0;
              }
            }
            function calculateDimensionsGrid(toIndex) {
              var i,
                  prevDimension,
                  dim;
              for (i = Math.max(dimensionsIndex, 0); i <= toIndex && (dim = dimensions[i]); i++) {
                prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
                dim.secondarySize = Math.min(self.getItemSecondarySize(i, data[i]), self.scrollSecondarySize);
                dim.secondaryPos = prevDimension.secondaryPos + prevDimension.secondarySize;
                if (i === 0 || dim.secondaryPos + dim.secondarySize > self.scrollSecondarySize) {
                  dim.secondaryPos = 0;
                  dim.primarySize = self.getItemPrimarySize(i, data[i]);
                  dim.primaryPos = prevDimension.primaryPos + prevDimension.rowPrimarySize;
                  dim.rowStartIndex = i;
                  dim.rowPrimarySize = dim.primarySize;
                } else {
                  dim.primarySize = self.getItemPrimarySize(i, data[i]);
                  dim.primaryPos = prevDimension.primaryPos;
                  dim.rowStartIndex = prevDimension.rowStartIndex;
                  dimensions[dim.rowStartIndex].rowPrimarySize = dim.rowPrimarySize = Math.max(dimensions[dim.rowStartIndex].rowPrimarySize, dim.primarySize);
                  dim.rowPrimarySize = Math.max(dim.primarySize, dim.rowPrimarySize);
                }
              }
            }
            this.getContentSize = function() {
              var dim = dimensions[dimensionsIndex] || EMPTY_DIMENSION;
              return ((dim.primaryPos + dim.primarySize) || 0) + this.getEstimatedPrimaryPos(data.length - dimensionsIndex - 1) + repeaterBeforeSize + repeaterAfterSize;
            };
            this.onDestroy = function() {
              dimensions.length = 0;
            };
            this.onRefreshData = function() {
              var i;
              var ii;
              for (i = dimensions.length, ii = data.length; i < ii; i++) {
                dimensions.push({});
              }
              dimensionsIndex = -1;
            };
            this.onRefreshLayout = function() {
              dimensionsIndex = -1;
            };
            this.getDimensions = function(index) {
              index = Math.min(index, data.length - 1);
              if (dimensionsIndex < index) {
                if (index > data.length * 0.9) {
                  calculateDimensions(data.length - 1);
                  dimensionsIndex = data.length - 1;
                  scrollViewSetDimensions();
                } else {
                  calculateDimensions(index);
                  dimensionsIndex = index;
                  debouncedScrollViewSetDimensions();
                }
              }
              return dimensions[index];
            };
            var oldRenderStartIndex = -1;
            var oldScrollValue = -1;
            this.updateRenderRange = function(scrollValue, scrollValueEnd) {
              var i;
              var len;
              var dim;
              this.getDimensions(this.getEstimatedIndex(scrollValueEnd) * 2);
              if (oldRenderStartIndex === -1 || scrollValue === 0) {
                i = 0;
              } else if (scrollValue >= oldScrollValue) {
                for (i = oldRenderStartIndex, len = data.length; i < len; i++) {
                  if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize >= scrollValue) {
                    break;
                  }
                }
              } else {
                for (i = oldRenderStartIndex; i >= 0; i--) {
                  if ((dim = this.getDimensions(i)) && dim.primaryPos <= scrollValue) {
                    i = isGridView ? dim.rowStartIndex : i;
                    break;
                  }
                }
              }
              renderStartIndex = Math.min(Math.max(0, i), data.length - 1);
              renderBeforeBoundary = renderStartIndex !== -1 ? this.getDimensions(renderStartIndex).primaryPos : -1;
              var lastRowDim;
              for (i = renderStartIndex + 1, len = data.length; i < len; i++) {
                if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize > scrollValueEnd) {
                  if (isGridView) {
                    lastRowDim = dim;
                    while (i < len - 1 && (dim = this.getDimensions(i + 1)).primaryPos === lastRowDim.primaryPos) {
                      i++;
                    }
                  }
                  break;
                }
              }
              renderEndIndex = Math.min(i, data.length - 1);
              renderAfterBoundary = renderEndIndex !== -1 ? ((dim = this.getDimensions(renderEndIndex)).primaryPos + (dim.rowPrimarySize || dim.primarySize)) : -1;
              oldScrollValue = scrollValue;
              oldRenderStartIndex = renderStartIndex;
            };
          }
        };
      }
      IonicModule.directive('ionContent', ['$timeout', '$controller', '$ionicBind', '$ionicConfig', function($timeout, $controller, $ionicBind, $ionicConfig) {
        return {
          restrict: 'E',
          require: '^?ionNavView',
          scope: true,
          priority: 800,
          compile: function(element, attr) {
            var innerElement;
            var scrollCtrl;
            element.addClass('scroll-content ionic-scroll');
            if (attr.scroll != 'false') {
              innerElement = jqLite('<div class="scroll"></div>');
              innerElement.append(element.contents());
              element.append(innerElement);
            } else {
              element.addClass('scroll-content-false');
            }
            var nativeScrolling = attr.overflowScroll === "true" || !$ionicConfig.scrolling.jsScrolling();
            if (nativeScrolling) {
              nativeScrolling = !element[0].querySelector('[collection-repeat]');
            }
            return {pre: prelink};
            function prelink($scope, $element, $attr) {
              var parentScope = $scope.$parent;
              $scope.$watch(function() {
                return (parentScope.$hasHeader ? ' has-header' : '') + (parentScope.$hasSubheader ? ' has-subheader' : '') + (parentScope.$hasFooter ? ' has-footer' : '') + (parentScope.$hasSubfooter ? ' has-subfooter' : '') + (parentScope.$hasTabs ? ' has-tabs' : '') + (parentScope.$hasTabsTop ? ' has-tabs-top' : '');
              }, function(className, oldClassName) {
                $element.removeClass(oldClassName);
                $element.addClass(className);
              });
              $scope.$hasHeader = $scope.$hasSubheader = $scope.$hasFooter = $scope.$hasSubfooter = $scope.$hasTabs = $scope.$hasTabsTop = false;
              $ionicBind($scope, $attr, {
                $onScroll: '&onScroll',
                $onScrollComplete: '&onScrollComplete',
                hasBouncing: '@',
                padding: '@',
                direction: '@',
                scrollbarX: '@',
                scrollbarY: '@',
                startX: '@',
                startY: '@',
                scrollEventInterval: '@'
              });
              $scope.direction = $scope.direction || 'y';
              if (isDefined($attr.padding)) {
                $scope.$watch($attr.padding, function(newVal) {
                  (innerElement || $element).toggleClass('padding', !!newVal);
                });
              }
              if ($attr.scroll === "false") {} else {
                var scrollViewOptions = {};
                if (nativeScrolling) {
                  $element.addClass('overflow-scroll');
                  scrollViewOptions = {
                    el: $element[0],
                    delegateHandle: attr.delegateHandle,
                    startX: $scope.$eval($scope.startX) || 0,
                    startY: $scope.$eval($scope.startY) || 0,
                    nativeScrolling: true
                  };
                } else {
                  scrollViewOptions = {
                    el: $element[0],
                    delegateHandle: attr.delegateHandle,
                    locking: (attr.locking || 'true') === 'true',
                    bouncing: $scope.$eval($scope.hasBouncing),
                    startX: $scope.$eval($scope.startX) || 0,
                    startY: $scope.$eval($scope.startY) || 0,
                    scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                    scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                    scrollingX: $scope.direction.indexOf('x') >= 0,
                    scrollingY: $scope.direction.indexOf('y') >= 0,
                    scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,
                    scrollingComplete: onScrollComplete
                  };
                }
                scrollCtrl = $controller('$ionicScroll', {
                  $scope: $scope,
                  scrollViewOptions: scrollViewOptions
                });
                $scope.$on('$destroy', function() {
                  if (scrollViewOptions) {
                    scrollViewOptions.scrollingComplete = noop;
                    delete scrollViewOptions.el;
                  }
                  innerElement = null;
                  $element = null;
                  attr.$$element = null;
                });
              }
              function onScrollComplete() {
                $scope.$onScrollComplete({
                  scrollTop: scrollCtrl.scrollView.__scrollTop,
                  scrollLeft: scrollCtrl.scrollView.__scrollLeft
                });
              }
            }
          }
        };
      }]);
      IonicModule.directive('exposeAsideWhen', ['$window', function($window) {
        return {
          restrict: 'A',
          require: '^ionSideMenus',
          link: function($scope, $element, $attr, sideMenuCtrl) {
            function checkAsideExpose() {
              var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;
              sideMenuCtrl.exposeAside($window.matchMedia(mq).matches);
              sideMenuCtrl.activeAsideResizing(false);
            }
            function onResize() {
              sideMenuCtrl.activeAsideResizing(true);
              debouncedCheck();
            }
            var debouncedCheck = ionic.debounce(function() {
              $scope.$apply(checkAsideExpose);
            }, 300, false);
            $scope.$evalAsync(checkAsideExpose);
            ionic.on('resize', onResize, $window);
            $scope.$on('$destroy', function() {
              ionic.off('resize', onResize, $window);
            });
          }
        };
      }]);
      var GESTURE_DIRECTIVES = 'onHold onTap onDoubleTap onTouch onRelease onDrag onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft'.split(' ');
      GESTURE_DIRECTIVES.forEach(function(name) {
        IonicModule.directive(name, gestureDirective(name));
      });
      function gestureDirective(directiveName) {
        return ['$ionicGesture', '$parse', function($ionicGesture, $parse) {
          var eventType = directiveName.substr(2).toLowerCase();
          return function(scope, element, attr) {
            var fn = $parse(attr[directiveName]);
            var listener = function(ev) {
              scope.$apply(function() {
                fn(scope, {$event: ev});
              });
            };
            var gesture = $ionicGesture.on(eventType, listener, element);
            scope.$on('$destroy', function() {
              $ionicGesture.off(gesture, eventType, listener);
            });
          };
        }];
      }
      IonicModule.directive('ionHeaderBar', tapScrollToTopDirective()).directive('ionHeaderBar', headerFooterBarDirective(true)).directive('ionFooterBar', headerFooterBarDirective(false));
      function tapScrollToTopDirective() {
        return ['$ionicScrollDelegate', function($ionicScrollDelegate) {
          return {
            restrict: 'E',
            link: function($scope, $element, $attr) {
              if ($attr.noTapScroll == 'true') {
                return;
              }
              ionic.on('tap', onTap, $element[0]);
              $scope.$on('$destroy', function() {
                ionic.off('tap', onTap, $element[0]);
              });
              function onTap(e) {
                var depth = 3;
                var current = e.target;
                while (depth-- && current) {
                  if (current.classList.contains('button') || current.tagName.match(/input|textarea|select/i) || current.isContentEditable) {
                    return;
                  }
                  current = current.parentNode;
                }
                var touch = e.gesture && e.gesture.touches[0] || e.detail.touches[0];
                var bounds = $element[0].getBoundingClientRect();
                if (ionic.DomUtil.rectContains(touch.pageX, touch.pageY, bounds.left, bounds.top - 20, bounds.left + bounds.width, bounds.top + bounds.height)) {
                  $ionicScrollDelegate.scrollTop(true);
                }
              }
            }
          };
        }];
      }
      function headerFooterBarDirective(isHeader) {
        return ['$document', '$timeout', function($document, $timeout) {
          return {
            restrict: 'E',
            controller: '$ionicHeaderBar',
            compile: function(tElement) {
              tElement.addClass(isHeader ? 'bar bar-header' : 'bar bar-footer');
              $timeout(function() {
                if (isHeader && $document[0].getElementsByClassName('tabs-top').length)
                  tElement.addClass('has-tabs-top');
              });
              return {pre: prelink};
              function prelink($scope, $element, $attr, ctrl) {
                if (isHeader) {
                  $scope.$watch(function() {
                    return $element[0].className;
                  }, function(value) {
                    var isShown = value.indexOf('ng-hide') === -1;
                    var isSubheader = value.indexOf('bar-subheader') !== -1;
                    $scope.$hasHeader = isShown && !isSubheader;
                    $scope.$hasSubheader = isShown && isSubheader;
                    $scope.$emit('$ionicSubheader', $scope.$hasSubheader);
                  });
                  $scope.$on('$destroy', function() {
                    delete $scope.$hasHeader;
                    delete $scope.$hasSubheader;
                  });
                  ctrl.align();
                  $scope.$on('$ionicHeader.align', function() {
                    ionic.requestAnimationFrame(function() {
                      ctrl.align();
                    });
                  });
                } else {
                  $scope.$watch(function() {
                    return $element[0].className;
                  }, function(value) {
                    var isShown = value.indexOf('ng-hide') === -1;
                    var isSubfooter = value.indexOf('bar-subfooter') !== -1;
                    $scope.$hasFooter = isShown && !isSubfooter;
                    $scope.$hasSubfooter = isShown && isSubfooter;
                  });
                  $scope.$on('$destroy', function() {
                    delete $scope.$hasFooter;
                    delete $scope.$hasSubfooter;
                  });
                  $scope.$watch('$hasTabs', function(val) {
                    $element.toggleClass('has-tabs', !!val);
                  });
                }
              }
            }
          };
        }];
      }
      IonicModule.directive('ionInfiniteScroll', ['$timeout', function($timeout) {
        return {
          restrict: 'E',
          require: ['?^$ionicScroll', 'ionInfiniteScroll'],
          template: function($element, $attrs) {
            if ($attrs.icon)
              return '<i class="icon {{icon()}} icon-refreshing {{scrollingType}}"></i>';
            return '<ion-spinner icon="{{spinner()}}"></ion-spinner>';
          },
          scope: true,
          controller: '$ionInfiniteScroll',
          link: function($scope, $element, $attrs, ctrls) {
            var infiniteScrollCtrl = ctrls[1];
            var scrollCtrl = infiniteScrollCtrl.scrollCtrl = ctrls[0];
            var jsScrolling = infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative();
            if (jsScrolling) {
              infiniteScrollCtrl.scrollView = scrollCtrl.scrollView;
              $scope.scrollingType = 'js-scrolling';
              scrollCtrl.$element.on('scroll', infiniteScrollCtrl.checkBounds);
            } else {
              var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, 'overflow-scroll');
              infiniteScrollCtrl.scrollEl = scrollEl;
              if (!scrollEl) {
                throw 'Infinite scroll must be used inside a scrollable div';
              }
              infiniteScrollCtrl.scrollEl.addEventListener('scroll', infiniteScrollCtrl.checkBounds);
            }
            var doImmediateCheck = isDefined($attrs.immediateCheck) ? $scope.$eval($attrs.immediateCheck) : true;
            if (doImmediateCheck) {
              $timeout(function() {
                infiniteScrollCtrl.checkBounds();
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionItem', ['$$rAF', function($$rAF) {
        return {
          restrict: 'E',
          controller: ['$scope', '$element', function($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
          }],
          scope: true,
          compile: function($element, $attrs) {
            var isAnchor = isDefined($attrs.href) || isDefined($attrs.ngHref) || isDefined($attrs.uiSref);
            var isComplexItem = isAnchor || /ion-(delete|option|reorder)-button/i.test($element.html());
            if (isComplexItem) {
              var innerElement = jqLite(isAnchor ? '<a></a>' : '<div></div>');
              innerElement.addClass('item-content');
              if (isDefined($attrs.href) || isDefined($attrs.ngHref)) {
                innerElement.attr('ng-href', '{{$href()}}');
                if (isDefined($attrs.target)) {
                  innerElement.attr('target', '{{$target()}}');
                }
              }
              innerElement.append($element.contents());
              $element.addClass('item item-complex').append(innerElement);
            } else {
              $element.addClass('item');
            }
            return function link($scope, $element, $attrs) {
              $scope.$href = function() {
                return $attrs.href || $attrs.ngHref;
              };
              $scope.$target = function() {
                return $attrs.target;
              };
              var content = $element[0].querySelector('.item-content');
              if (content) {
                $scope.$on('$collectionRepeatLeave', function() {
                  if (content && content.$$ionicOptionsOpen) {
                    content.style[ionic.CSS.TRANSFORM] = '';
                    content.style[ionic.CSS.TRANSITION] = 'none';
                    $$rAF(function() {
                      content.style[ionic.CSS.TRANSITION] = '';
                    });
                    content.$$ionicOptionsOpen = false;
                  }
                });
              }
            };
          }
        };
      }]);
      var ITEM_TPL_DELETE_BUTTON = '<div class="item-left-edit item-delete enable-pointer-events">' + '</div>';
      IonicModule.directive('ionDeleteButton', function() {
        function stopPropagation(ev) {
          ev.stopPropagation();
        }
        return {
          restrict: 'E',
          require: ['^^ionItem', '^?ionList'],
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
            return function($scope, $element, $attr, ctrls) {
              var itemCtrl = ctrls[0];
              var listCtrl = ctrls[1];
              var container = jqLite(ITEM_TPL_DELETE_BUTTON);
              container.append($element);
              itemCtrl.$element.append(container).addClass('item-left-editable');
              $element.on('click', stopPropagation);
              init();
              $scope.$on('$ionic.reconnectScope', init);
              function init() {
                listCtrl = listCtrl || $element.controller('ionList');
                if (listCtrl && listCtrl.showDelete()) {
                  container.addClass('visible active');
                }
              }
            };
          }
        };
      });
      IonicModule.directive('itemFloatingLabel', function() {
        return {
          restrict: 'C',
          link: function(scope, element) {
            var el = element[0];
            var input = el.querySelector('input, textarea');
            var inputLabel = el.querySelector('.input-label');
            if (!input || !inputLabel)
              return;
            var onInput = function() {
              if (input.value) {
                inputLabel.classList.add('has-input');
              } else {
                inputLabel.classList.remove('has-input');
              }
            };
            input.addEventListener('input', onInput);
            var ngModelCtrl = jqLite(input).controller('ngModel');
            if (ngModelCtrl) {
              ngModelCtrl.$render = function() {
                input.value = ngModelCtrl.$viewValue || '';
                onInput();
              };
            }
            scope.$on('$destroy', function() {
              input.removeEventListener('input', onInput);
            });
          }
        };
      });
      var ITEM_TPL_OPTION_BUTTONS = '<div class="item-options invisible">' + '</div>';
      IonicModule.directive('ionOptionButton', [function() {
        function stopPropagation(e) {
          e.stopPropagation();
        }
        return {
          restrict: 'E',
          require: '^ionItem',
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button', true);
            return function($scope, $element, $attr, itemCtrl) {
              if (!itemCtrl.optionsContainer) {
                itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS);
                itemCtrl.$element.append(itemCtrl.optionsContainer);
              }
              itemCtrl.optionsContainer.append($element);
              itemCtrl.$element.addClass('item-right-editable');
              $element.on('click', stopPropagation);
            };
          }
        };
      }]);
      var ITEM_TPL_REORDER_BUTTON = '<div data-prevent-scroll="true" class="item-right-edit item-reorder enable-pointer-events">' + '</div>';
      IonicModule.directive('ionReorderButton', ['$parse', function($parse) {
        return {
          restrict: 'E',
          require: ['^ionItem', '^?ionList'],
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
            $element[0].setAttribute('data-prevent-scroll', true);
            return function($scope, $element, $attr, ctrls) {
              var itemCtrl = ctrls[0];
              var listCtrl = ctrls[1];
              var onReorderFn = $parse($attr.onReorder);
              $scope.$onReorder = function(oldIndex, newIndex) {
                onReorderFn($scope, {
                  $fromIndex: oldIndex,
                  $toIndex: newIndex
                });
              };
              if (!$attr.ngClick && !$attr.onClick && !$attr.onclick) {
                $element[0].onclick = function(e) {
                  e.stopPropagation();
                  return false;
                };
              }
              var container = jqLite(ITEM_TPL_REORDER_BUTTON);
              container.append($element);
              itemCtrl.$element.append(container).addClass('item-right-editable');
              if (listCtrl && listCtrl.showReorder()) {
                container.addClass('visible active');
              }
            };
          }
        };
      }]);
      IonicModule.directive('keyboardAttach', function() {
        return function(scope, element) {
          ionic.on('native.keyboardshow', onShow, window);
          ionic.on('native.keyboardhide', onHide, window);
          ionic.on('native.showkeyboard', onShow, window);
          ionic.on('native.hidekeyboard', onHide, window);
          var scrollCtrl;
          function onShow(e) {
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              return;
            }
            var keyboardHeight = e.keyboardHeight || e.detail.keyboardHeight;
            element.css('bottom', keyboardHeight + "px");
            scrollCtrl = element.controller('$ionicScroll');
            if (scrollCtrl) {
              scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + "px";
            }
          }
          function onHide() {
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              return;
            }
            element.css('bottom', '');
            if (scrollCtrl) {
              scrollCtrl.scrollView.__container.style.bottom = '';
            }
          }
          scope.$on('$destroy', function() {
            ionic.off('native.keyboardshow', onShow, window);
            ionic.off('native.keyboardhide', onHide, window);
            ionic.off('native.showkeyboard', onShow, window);
            ionic.off('native.hidekeyboard', onHide, window);
          });
        };
      });
      function keyboardAttachGetClientHeight(element) {
        return element.clientHeight;
      }
      IonicModule.directive('ionList', ['$timeout', function($timeout) {
        return {
          restrict: 'E',
          require: ['ionList', '^?$ionicScroll'],
          controller: '$ionicList',
          compile: function($element, $attr) {
            var listEl = jqLite('<div class="list">').append($element.contents()).addClass($attr.type);
            $element.append(listEl);
            return function($scope, $element, $attrs, ctrls) {
              var listCtrl = ctrls[0];
              var scrollCtrl = ctrls[1];
              $timeout(init);
              function init() {
                var listView = listCtrl.listView = new ionic.views.ListView({
                  el: $element[0],
                  listEl: $element.children()[0],
                  scrollEl: scrollCtrl && scrollCtrl.element,
                  scrollView: scrollCtrl && scrollCtrl.scrollView,
                  onReorder: function(el, oldIndex, newIndex) {
                    var itemScope = jqLite(el).scope();
                    if (itemScope && itemScope.$onReorder) {
                      $timeout(function() {
                        itemScope.$onReorder(oldIndex, newIndex);
                      });
                    }
                  },
                  canSwipe: function() {
                    return listCtrl.canSwipeItems();
                  }
                });
                $scope.$on('$destroy', function() {
                  if (listView) {
                    listView.deregister && listView.deregister();
                    listView = null;
                  }
                });
                if (isDefined($attr.canSwipe)) {
                  $scope.$watch('!!(' + $attr.canSwipe + ')', function(value) {
                    listCtrl.canSwipeItems(value);
                  });
                }
                if (isDefined($attr.showDelete)) {
                  $scope.$watch('!!(' + $attr.showDelete + ')', function(value) {
                    listCtrl.showDelete(value);
                  });
                }
                if (isDefined($attr.showReorder)) {
                  $scope.$watch('!!(' + $attr.showReorder + ')', function(value) {
                    listCtrl.showReorder(value);
                  });
                }
                $scope.$watch(function() {
                  return listCtrl.showDelete();
                }, function(isShown, wasShown) {
                  if (!isShown && !wasShown) {
                    return;
                  }
                  if (isShown)
                    listCtrl.closeOptionButtons();
                  listCtrl.canSwipeItems(!isShown);
                  $element.children().toggleClass('list-left-editing', isShown);
                  $element.toggleClass('disable-pointer-events', isShown);
                  var deleteButton = jqLite($element[0].getElementsByClassName('item-delete'));
                  setButtonShown(deleteButton, listCtrl.showDelete);
                });
                $scope.$watch(function() {
                  return listCtrl.showReorder();
                }, function(isShown, wasShown) {
                  if (!isShown && !wasShown) {
                    return;
                  }
                  if (isShown)
                    listCtrl.closeOptionButtons();
                  listCtrl.canSwipeItems(!isShown);
                  $element.children().toggleClass('list-right-editing', isShown);
                  $element.toggleClass('disable-pointer-events', isShown);
                  var reorderButton = jqLite($element[0].getElementsByClassName('item-reorder'));
                  setButtonShown(reorderButton, listCtrl.showReorder);
                });
                function setButtonShown(el, shown) {
                  shown() && el.addClass('visible') || el.removeClass('active');
                  ionic.requestAnimationFrame(function() {
                    shown() && el.addClass('active') || el.removeClass('visible');
                  });
                }
              }
            };
          }
        };
      }]);
      IonicModule.directive('menuClose', ['$ionicHistory', function($ionicHistory) {
        return {
          restrict: 'AC',
          link: function($scope, $element) {
            $element.bind('click', function() {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              if (sideMenuCtrl) {
                $ionicHistory.nextViewOptions({
                  historyRoot: true,
                  disableAnimate: true,
                  expire: 300
                });
                sideMenuCtrl.close();
              }
            });
          }
        };
      }]);
      IonicModule.directive('menuToggle', function() {
        return {
          restrict: 'AC',
          link: function($scope, $element, $attr) {
            $scope.$on('$ionicView.beforeEnter', function(ev, viewData) {
              if (viewData.enableBack) {
                var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
                if (!sideMenuCtrl.enableMenuWithBackViews()) {
                  $element.addClass('hide');
                }
              } else {
                $element.removeClass('hide');
              }
            });
            $element.bind('click', function() {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              sideMenuCtrl && sideMenuCtrl.toggle($attr.menuToggle);
            });
          }
        };
      });
      IonicModule.directive('ionModal', [function() {
        return {
          restrict: 'E',
          transclude: true,
          replace: true,
          controller: [function() {}],
          template: '<div class="modal-backdrop">' + '<div class="modal-backdrop-bg"></div>' + '<div class="modal-wrapper" ng-transclude></div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionModalView', function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.addClass('modal');
          }
        };
      });
      IonicModule.directive('ionNavBackButton', ['$ionicConfig', '$document', function($ionicConfig, $document) {
        return {
          restrict: 'E',
          require: '^ionNavBar',
          compile: function(tElement, tAttrs) {
            var buttonEle = $document[0].createElement('button');
            for (var n in tAttrs.$attr) {
              buttonEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
            }
            if (!tAttrs.ngClick) {
              buttonEle.setAttribute('ng-click', '$ionicGoBack()');
            }
            buttonEle.className = 'button back-button hide buttons ' + (tElement.attr('class') || '');
            buttonEle.innerHTML = tElement.html() || '';
            var childNode;
            var hasIcon = hasIconClass(tElement[0]);
            var hasInnerText;
            var hasButtonText;
            var hasPreviousTitle;
            for (var x = 0; x < tElement[0].childNodes.length; x++) {
              childNode = tElement[0].childNodes[x];
              if (childNode.nodeType === 1) {
                if (hasIconClass(childNode)) {
                  hasIcon = true;
                } else if (childNode.classList.contains('default-title')) {
                  hasButtonText = true;
                } else if (childNode.classList.contains('previous-title')) {
                  hasPreviousTitle = true;
                }
              } else if (!hasInnerText && childNode.nodeType === 3) {
                hasInnerText = !!childNode.nodeValue.trim();
              }
            }
            function hasIconClass(ele) {
              return /ion-|icon/.test(ele.className);
            }
            var defaultIcon = $ionicConfig.backButton.icon();
            if (!hasIcon && defaultIcon && defaultIcon !== 'none') {
              buttonEle.innerHTML = '<i class="icon ' + defaultIcon + '"></i> ' + buttonEle.innerHTML;
              buttonEle.className += ' button-clear';
            }
            if (!hasInnerText) {
              var buttonTextEle = $document[0].createElement('span');
              buttonTextEle.className = 'back-text';
              if (!hasButtonText && $ionicConfig.backButton.text()) {
                buttonTextEle.innerHTML += '<span class="default-title">' + $ionicConfig.backButton.text() + '</span>';
              }
              if (!hasPreviousTitle && $ionicConfig.backButton.previousTitleText()) {
                buttonTextEle.innerHTML += '<span class="previous-title"></span>';
              }
              buttonEle.appendChild(buttonTextEle);
            }
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attr, navBarCtrl) {
                navBarCtrl.navElement('backButton', buttonEle.outerHTML);
                buttonEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('ionNavBar', function() {
        return {
          restrict: 'E',
          controller: '$ionicNavBar',
          scope: true,
          link: function($scope, $element, $attr, ctrl) {
            ctrl.init();
          }
        };
      });
      IonicModule.directive('ionNavButtons', ['$document', function($document) {
        return {
          require: '^ionNavBar',
          restrict: 'E',
          compile: function(tElement, tAttrs) {
            var side = 'left';
            if (/^primary|secondary|right$/i.test(tAttrs.side || '')) {
              side = tAttrs.side.toLowerCase();
            }
            var spanEle = $document[0].createElement('span');
            spanEle.className = side + '-buttons';
            spanEle.innerHTML = tElement.html();
            var navElementType = side + 'Buttons';
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attrs, navBarCtrl) {
                var parentViewCtrl = $element.parent().data('$ionViewController');
                if (parentViewCtrl) {
                  parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                } else {
                  navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                }
                spanEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('navDirection', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
        return {
          restrict: 'A',
          priority: 1000,
          link: function($scope, $element, $attr) {
            $element.bind('click', function() {
              $ionicViewSwitcher.nextDirection($attr.navDirection);
            });
          }
        };
      }]);
      IonicModule.directive('ionNavTitle', ['$document', function($document) {
        return {
          require: '^ionNavBar',
          restrict: 'E',
          compile: function(tElement, tAttrs) {
            var navElementType = 'title';
            var spanEle = $document[0].createElement('span');
            for (var n in tAttrs.$attr) {
              spanEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
            }
            spanEle.classList.add('nav-bar-title');
            spanEle.innerHTML = tElement.html();
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attrs, navBarCtrl) {
                var parentViewCtrl = $element.parent().data('$ionViewController');
                if (parentViewCtrl) {
                  parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                } else {
                  navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                }
                spanEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('navTransition', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
        return {
          restrict: 'A',
          priority: 1000,
          link: function($scope, $element, $attr) {
            $element.bind('click', function() {
              $ionicViewSwitcher.nextTransition($attr.navTransition);
            });
          }
        };
      }]);
      IonicModule.directive('ionNavView', ['$state', '$ionicConfig', function($state, $ionicConfig) {
        return {
          restrict: 'E',
          terminal: true,
          priority: 2000,
          transclude: true,
          controller: '$ionicNavView',
          compile: function(tElement, tAttrs, transclude) {
            tElement.addClass('view-container');
            ionic.DomUtil.cachedAttr(tElement, 'nav-view-transition', $ionicConfig.views.transition());
            return function($scope, $element, $attr, navViewCtrl) {
              var latestLocals;
              transclude($scope, function(clone) {
                $element.append(clone);
              });
              var viewData = navViewCtrl.init();
              $scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              $scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function updateView(firstTime) {
                var viewLocals = $state.$current && $state.$current.locals[viewData.name];
                if (!viewLocals || (!firstTime && viewLocals === latestLocals))
                  return;
                latestLocals = viewLocals;
                viewData.state = viewLocals.$$state;
                navViewCtrl.register(viewLocals);
              }
            };
          }
        };
      }]);
      IonicModule.config(['$provide', function($provide) {
        $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
          $delegate.shift();
          return $delegate;
        }]);
      }]).factory('$ionicNgClick', ['$parse', function($parse) {
        return function(scope, element, clickExpr) {
          var clickHandler = angular.isFunction(clickExpr) ? clickExpr : $parse(clickExpr);
          element.on('click', function(event) {
            scope.$apply(function() {
              clickHandler(scope, {$event: (event)});
            });
          });
          element.onclick = noop;
        };
      }]).directive('ngClick', ['$ionicNgClick', function($ionicNgClick) {
        return function(scope, element, attr) {
          $ionicNgClick(scope, element, attr.ngClick);
        };
      }]).directive('ionStopEvent', function() {
        return {
          restrict: 'A',
          link: function(scope, element, attr) {
            element.bind(attr.ionStopEvent, eventStopPropagation);
          }
        };
      });
      function eventStopPropagation(e) {
        e.stopPropagation();
      }
      IonicModule.directive('ionPane', function() {
        return {
          restrict: 'E',
          link: function(scope, element) {
            element.addClass('pane');
          }
        };
      });
      IonicModule.directive('ionPopover', [function() {
        return {
          restrict: 'E',
          transclude: true,
          replace: true,
          controller: [function() {}],
          template: '<div class="popover-backdrop">' + '<div class="popover-wrapper" ng-transclude></div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionPopoverView', function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.append(jqLite('<div class="popover-arrow">'));
            element.addClass('popover');
          }
        };
      });
      IonicModule.directive('ionRadio', function() {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<label class="item item-radio">' + '<input type="radio" name="radio-group">' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' + '</label>',
          compile: function(element, attr) {
            if (attr.icon) {
              element.children().eq(2).removeClass('ion-checkmark').addClass(attr.icon);
            }
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'value': attr.value,
              'disabled': attr.disabled,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-disabled': attr.ngDisabled,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            return function(scope, element, attr) {
              scope.getValue = function() {
                return scope.ngValue || attr.value;
              };
            };
          }
        };
      });
      IonicModule.directive('ionRefresher', [function() {
        return {
          restrict: 'E',
          replace: true,
          require: ['?^$ionicScroll', 'ionRefresher'],
          controller: '$ionicRefresher',
          template: '<div class="scroll-refresher invisible" collection-repeat-ignore>' + '<div class="ionic-refresher-content" ' + 'ng-class="{\'ionic-refresher-with-text\': pullingText || refreshingText}">' + '<div class="icon-pulling" ng-class="{\'pulling-rotation-disabled\':disablePullingRotation}">' + '<i class="icon {{pullingIcon}}"></i>' + '</div>' + '<div class="text-pulling" ng-bind-html="pullingText"></div>' + '<div class="icon-refreshing">' + '<ion-spinner ng-if="showSpinner" icon="{{spinner}}"></ion-spinner>' + '<i ng-if="showIcon" class="icon {{refreshingIcon}}"></i>' + '</div>' + '<div class="text-refreshing" ng-bind-html="refreshingText"></div>' + '</div>' + '</div>',
          link: function($scope, $element, $attrs, ctrls) {
            var scrollCtrl = ctrls[0],
                refresherCtrl = ctrls[1];
            if (!scrollCtrl || scrollCtrl.isNative()) {
              refresherCtrl.init();
            } else {
              $element[0].classList.add('js-scrolling');
              scrollCtrl._setRefresher($scope, $element[0], refresherCtrl.getRefresherDomMethods());
              $scope.$on('scroll.refreshComplete', function() {
                $scope.$evalAsync(function() {
                  scrollCtrl.scrollView.finishPullToRefresh();
                });
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionScroll', ['$timeout', '$controller', '$ionicBind', function($timeout, $controller, $ionicBind) {
        return {
          restrict: 'E',
          scope: true,
          controller: function() {},
          compile: function(element) {
            element.addClass('scroll-view ionic-scroll');
            var innerElement = jqLite('<div class="scroll"></div>');
            innerElement.append(element.contents());
            element.append(innerElement);
            return {pre: prelink};
            function prelink($scope, $element, $attr) {
              $ionicBind($scope, $attr, {
                direction: '@',
                paging: '@',
                $onScroll: '&onScroll',
                scroll: '@',
                scrollbarX: '@',
                scrollbarY: '@',
                zooming: '@',
                minZoom: '@',
                maxZoom: '@'
              });
              $scope.direction = $scope.direction || 'y';
              if (isDefined($attr.padding)) {
                $scope.$watch($attr.padding, function(newVal) {
                  innerElement.toggleClass('padding', !!newVal);
                });
              }
              if ($scope.$eval($scope.paging) === true) {
                innerElement.addClass('scroll-paging');
              }
              if (!$scope.direction) {
                $scope.direction = 'y';
              }
              var isPaging = $scope.$eval($scope.paging) === true;
              var scrollViewOptions = {
                el: $element[0],
                delegateHandle: $attr.delegateHandle,
                locking: ($attr.locking || 'true') === 'true',
                bouncing: $scope.$eval($attr.hasBouncing),
                paging: isPaging,
                scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                scrollingX: $scope.direction.indexOf('x') >= 0,
                scrollingY: $scope.direction.indexOf('y') >= 0,
                zooming: $scope.$eval($scope.zooming) === true,
                maxZoom: $scope.$eval($scope.maxZoom) || 3,
                minZoom: $scope.$eval($scope.minZoom) || 0.5,
                preventDefault: true
              };
              if (isPaging) {
                scrollViewOptions.speedMultiplier = 0.8;
                scrollViewOptions.bouncing = false;
              }
              $controller('$ionicScroll', {
                $scope: $scope,
                scrollViewOptions: scrollViewOptions
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSideMenu', function() {
        return {
          restrict: 'E',
          require: '^ionSideMenus',
          scope: true,
          compile: function(element, attr) {
            angular.isUndefined(attr.isEnabled) && attr.$set('isEnabled', 'true');
            angular.isUndefined(attr.width) && attr.$set('width', '275');
            element.addClass('menu menu-' + attr.side);
            return function($scope, $element, $attr, sideMenuCtrl) {
              $scope.side = $attr.side || 'left';
              var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({
                width: attr.width,
                el: $element[0],
                isEnabled: true
              });
              $scope.$watch($attr.width, function(val) {
                var numberVal = +val;
                if (numberVal && numberVal == val) {
                  sideMenu.setWidth(+val);
                }
              });
              $scope.$watch($attr.isEnabled, function(val) {
                sideMenu.setIsEnabled(!!val);
              });
            };
          }
        };
      });
      IonicModule.directive('ionSideMenuContent', ['$timeout', '$ionicGesture', '$window', function($timeout, $ionicGesture, $window) {
        return {
          restrict: 'EA',
          require: '^ionSideMenus',
          scope: true,
          compile: function(element, attr) {
            element.addClass('menu-content pane');
            return {pre: prelink};
            function prelink($scope, $element, $attr, sideMenuCtrl) {
              var startCoord = null;
              var primaryScrollAxis = null;
              if (isDefined(attr.dragContent)) {
                $scope.$watch(attr.dragContent, function(value) {
                  sideMenuCtrl.canDragContent(value);
                });
              } else {
                sideMenuCtrl.canDragContent(true);
              }
              if (isDefined(attr.edgeDragThreshold)) {
                $scope.$watch(attr.edgeDragThreshold, function(value) {
                  sideMenuCtrl.edgeDragThreshold(value);
                });
              }
              function onContentTap(gestureEvt) {
                if (sideMenuCtrl.getOpenAmount() !== 0) {
                  sideMenuCtrl.close();
                  gestureEvt.gesture.srcEvent.preventDefault();
                  startCoord = null;
                  primaryScrollAxis = null;
                } else if (!startCoord) {
                  startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                }
              }
              function onDragX(e) {
                if (!sideMenuCtrl.isDraggableTarget(e))
                  return;
                if (getPrimaryScrollAxis(e) == 'x') {
                  sideMenuCtrl._handleDrag(e);
                  e.gesture.srcEvent.preventDefault();
                }
              }
              function onDragY(e) {
                if (getPrimaryScrollAxis(e) == 'x') {
                  e.gesture.srcEvent.preventDefault();
                }
              }
              function onDragRelease(e) {
                sideMenuCtrl._endDrag(e);
                startCoord = null;
                primaryScrollAxis = null;
              }
              function getPrimaryScrollAxis(gestureEvt) {
                if (primaryScrollAxis) {
                  return primaryScrollAxis;
                }
                if (gestureEvt && gestureEvt.gesture) {
                  if (!startCoord) {
                    startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                  } else {
                    var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                    var xDistance = Math.abs(endCoord.x - startCoord.x);
                    var yDistance = Math.abs(endCoord.y - startCoord.y);
                    var scrollAxis = (xDistance < yDistance ? 'y' : 'x');
                    if (Math.max(xDistance, yDistance) > 30) {
                      primaryScrollAxis = scrollAxis;
                    }
                    return scrollAxis;
                  }
                }
                return 'y';
              }
              var content = {
                element: element[0],
                onDrag: function() {},
                endDrag: function() {},
                getTranslateX: function() {
                  return $scope.sideMenuContentTranslateX || 0;
                },
                setTranslateX: ionic.animationFrameThrottle(function(amount) {
                  var xTransform = content.offsetX + amount;
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + xTransform + 'px,0,0)';
                  $timeout(function() {
                    $scope.sideMenuContentTranslateX = amount;
                  });
                }),
                setMarginLeft: ionic.animationFrameThrottle(function(amount) {
                  if (amount) {
                    amount = parseInt(amount, 10);
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amount + 'px,0,0)';
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amount;
                  } else {
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                }),
                setMarginRight: ionic.animationFrameThrottle(function(amount) {
                  if (amount) {
                    amount = parseInt(amount, 10);
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amount;
                  } else {
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                }),
                enableAnimation: function() {
                  $scope.animationEnabled = true;
                  $element[0].classList.add('menu-animated');
                },
                disableAnimation: function() {
                  $scope.animationEnabled = false;
                  $element[0].classList.remove('menu-animated');
                },
                offsetX: 0
              };
              sideMenuCtrl.setContent(content);
              var gestureOpts = {stop_browser_behavior: false};
              if (ionic.DomUtil.getParentOrSelfWithClass($element[0], 'overflow-scroll')) {
                gestureOpts.prevent_default_directions = ['left', 'right'];
              }
              var contentTapGesture = $ionicGesture.on('tap', onContentTap, $element, gestureOpts);
              var dragRightGesture = $ionicGesture.on('dragright', onDragX, $element, gestureOpts);
              var dragLeftGesture = $ionicGesture.on('dragleft', onDragX, $element, gestureOpts);
              var dragUpGesture = $ionicGesture.on('dragup', onDragY, $element, gestureOpts);
              var dragDownGesture = $ionicGesture.on('dragdown', onDragY, $element, gestureOpts);
              var releaseGesture = $ionicGesture.on('release', onDragRelease, $element, gestureOpts);
              $scope.$on('$destroy', function() {
                if (content) {
                  content.element = null;
                  content = null;
                }
                $ionicGesture.off(dragLeftGesture, 'dragleft', onDragX);
                $ionicGesture.off(dragRightGesture, 'dragright', onDragX);
                $ionicGesture.off(dragUpGesture, 'dragup', onDragY);
                $ionicGesture.off(dragDownGesture, 'dragdown', onDragY);
                $ionicGesture.off(releaseGesture, 'release', onDragRelease);
                $ionicGesture.off(contentTapGesture, 'tap', onContentTap);
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSideMenus', ['$ionicBody', function($ionicBody) {
        return {
          restrict: 'ECA',
          controller: '$ionicSideMenus',
          compile: function(element, attr) {
            attr.$set('class', (attr['class'] || '') + ' view');
            return {pre: prelink};
            function prelink($scope, $element, $attrs, ctrl) {
              ctrl.enableMenuWithBackViews($scope.$eval($attrs.enableMenuWithBackViews));
              $scope.$on('$ionicExposeAside', function(evt, isAsideExposed) {
                if (!$scope.$exposeAside)
                  $scope.$exposeAside = {};
                $scope.$exposeAside.active = isAsideExposed;
                $ionicBody.enableClass(isAsideExposed, 'aside-open');
              });
              $scope.$on('$ionicView.beforeEnter', function(ev, d) {
                if (d.historyId) {
                  $scope.$activeHistoryId = d.historyId;
                }
              });
              $scope.$on('$destroy', function() {
                $ionicBody.removeClass('menu-open', 'aside-open');
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSlideBox', ['$timeout', '$compile', '$ionicSlideBoxDelegate', '$ionicHistory', '$ionicScrollDelegate', function($timeout, $compile, $ionicSlideBoxDelegate, $ionicHistory, $ionicScrollDelegate) {
        return {
          restrict: 'E',
          replace: true,
          transclude: true,
          scope: {
            autoPlay: '=',
            doesContinue: '@',
            slideInterval: '@',
            showPager: '@',
            pagerClick: '&',
            disableScroll: '@',
            onSlideChanged: '&',
            activeSlide: '=?'
          },
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var _this = this;
            var continuous = $scope.$eval($scope.doesContinue) === true;
            var shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : false;
            var slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4000 : 0;
            var slider = new ionic.views.Slider({
              el: $element[0],
              auto: slideInterval,
              continuous: continuous,
              startSlide: $scope.activeSlide,
              slidesChanged: function() {
                $scope.currentSlide = slider.currentIndex();
                $timeout(function() {});
              },
              callback: function(slideIndex) {
                $scope.currentSlide = slideIndex;
                $scope.onSlideChanged({
                  index: $scope.currentSlide,
                  $index: $scope.currentSlide
                });
                $scope.$parent.$broadcast('slideBox.slideChanged', slideIndex);
                $scope.activeSlide = slideIndex;
                $timeout(function() {});
              },
              onDrag: function() {
                freezeAllScrolls(true);
              },
              onDragEnd: function() {
                freezeAllScrolls(false);
              }
            });
            function freezeAllScrolls(shouldFreeze) {
              if (shouldFreeze && !_this.isScrollFreeze) {
                $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);
              } else if (!shouldFreeze && _this.isScrollFreeze) {
                $ionicScrollDelegate.freezeAllScrolls(false);
              }
              _this.isScrollFreeze = shouldFreeze;
            }
            slider.enableSlide($scope.$eval($attrs.disableScroll) !== true);
            $scope.$watch('activeSlide', function(nv) {
              if (isDefined(nv)) {
                slider.slide(nv);
              }
            });
            $scope.$on('slideBox.nextSlide', function() {
              slider.next();
            });
            $scope.$on('slideBox.prevSlide', function() {
              slider.prev();
            });
            $scope.$on('slideBox.setSlide', function(e, index) {
              slider.slide(index);
            });
            this.__slider = slider;
            var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(slider, $attrs.delegateHandle, function() {
              return $ionicHistory.isActiveScope($scope);
            });
            $scope.$on('$destroy', function() {
              deregisterInstance();
              slider.kill();
            });
            this.slidesCount = function() {
              return slider.slidesCount();
            };
            this.onPagerClick = function(index) {
              void 0;
              $scope.pagerClick({index: index});
            };
            $timeout(function() {
              slider.load();
            });
          }],
          template: '<div class="slider">' + '<div class="slider-slides" ng-transclude>' + '</div>' + '</div>',
          link: function($scope, $element, $attr) {
            if (!isDefined($attr.showPager)) {
              $scope.showPager = true;
              getPager().toggleClass('hide', !true);
            }
            $attr.$observe('showPager', function(show) {
              show = $scope.$eval(show);
              getPager().toggleClass('hide', !show);
            });
            var pager;
            function getPager() {
              if (!pager) {
                var childScope = $scope.$new();
                pager = jqLite('<ion-pager></ion-pager>');
                $element.append(pager);
                pager = $compile(pager)(childScope);
              }
              return pager;
            }
          }
        };
      }]).directive('ionSlide', function() {
        return {
          restrict: 'E',
          require: '^ionSlideBox',
          compile: function(element) {
            element.addClass('slider-slide');
          }
        };
      }).directive('ionPager', function() {
        return {
          restrict: 'E',
          replace: true,
          require: '^ionSlideBox',
          template: '<div class="slider-pager"><span class="slider-pager-page" ng-repeat="slide in numSlides() track by $index" ng-class="{active: $index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
          link: function($scope, $element, $attr, slideBox) {
            var selectPage = function(index) {
              var children = $element[0].children;
              var length = children.length;
              for (var i = 0; i < length; i++) {
                if (i == index) {
                  children[i].classList.add('active');
                } else {
                  children[i].classList.remove('active');
                }
              }
            };
            $scope.pagerClick = function(index) {
              slideBox.onPagerClick(index);
            };
            $scope.numSlides = function() {
              return new Array(slideBox.slidesCount());
            };
            $scope.$watch('currentSlide', function(v) {
              selectPage(v);
            });
          }
        };
      });
      IonicModule.directive('ionSpinner', function() {
        return {
          restrict: 'E',
          controller: '$ionicSpinner',
          link: function($scope, $element, $attrs, ctrl) {
            var spinnerName = ctrl.init();
            $element.addClass('spinner spinner-' + spinnerName);
          }
        };
      });
      IonicModule.directive('ionTab', ['$compile', '$ionicConfig', '$ionicBind', '$ionicViewSwitcher', function($compile, $ionicConfig, $ionicBind, $ionicViewSwitcher) {
        function attrStr(k, v) {
          return isDefined(v) ? ' ' + k + '="' + v + '"' : '';
        }
        return {
          restrict: 'E',
          require: ['^ionTabs', 'ionTab'],
          controller: '$ionicTab',
          scope: true,
          compile: function(element, attr) {
            var tabNavTemplate = '<ion-tab-nav' + attrStr('ng-click', attr.ngClick) + attrStr('title', attr.title) + attrStr('icon', attr.icon) + attrStr('icon-on', attr.iconOn) + attrStr('icon-off', attr.iconOff) + attrStr('badge', attr.badge) + attrStr('badge-style', attr.badgeStyle) + attrStr('hidden', attr.hidden) + attrStr('disabled', attr.disabled) + attrStr('class', attr['class']) + '></ion-tab-nav>';
            var tabContentEle = document.createElement('div');
            for (var x = 0; x < element[0].children.length; x++) {
              tabContentEle.appendChild(element[0].children[x].cloneNode(true));
            }
            var childElementCount = tabContentEle.childElementCount;
            element.empty();
            var navViewName,
                isNavView;
            if (childElementCount) {
              if (tabContentEle.children[0].tagName === 'ION-NAV-VIEW') {
                navViewName = tabContentEle.children[0].getAttribute('name');
                tabContentEle.children[0].classList.add('view-container');
                isNavView = true;
              }
              if (childElementCount === 1) {
                tabContentEle = tabContentEle.children[0];
              }
              if (!isNavView)
                tabContentEle.classList.add('pane');
              tabContentEle.classList.add('tab-content');
            }
            return function link($scope, $element, $attr, ctrls) {
              var childScope;
              var childElement;
              var tabsCtrl = ctrls[0];
              var tabCtrl = ctrls[1];
              var isTabContentAttached = false;
              $scope.$tabSelected = false;
              $ionicBind($scope, $attr, {
                onSelect: '&',
                onDeselect: '&',
                title: '@',
                uiSref: '@',
                href: '@'
              });
              tabsCtrl.add($scope);
              $scope.$on('$destroy', function() {
                if (!$scope.$tabsDestroy) {
                  tabsCtrl.remove($scope);
                }
                tabNavElement.isolateScope().$destroy();
                tabNavElement.remove();
                tabNavElement = tabContentEle = childElement = null;
              });
              $element[0].removeAttribute('title');
              if (navViewName) {
                tabCtrl.navViewName = $scope.navViewName = navViewName;
              }
              $scope.$on('$stateChangeSuccess', selectIfMatchesState);
              selectIfMatchesState();
              function selectIfMatchesState() {
                if (tabCtrl.tabMatchesState()) {
                  tabsCtrl.select($scope, false);
                }
              }
              var tabNavElement = jqLite(tabNavTemplate);
              tabNavElement.data('$ionTabsController', tabsCtrl);
              tabNavElement.data('$ionTabController', tabCtrl);
              tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope));
              function tabSelected(isSelected) {
                if (isSelected && childElementCount) {
                  if (!isTabContentAttached) {
                    childScope = $scope.$new();
                    childElement = jqLite(tabContentEle);
                    $ionicViewSwitcher.viewEleIsActive(childElement, true);
                    tabsCtrl.$element.append(childElement);
                    $compile(childElement)(childScope);
                    isTabContentAttached = true;
                  }
                  $ionicViewSwitcher.viewEleIsActive(childElement, true);
                } else if (isTabContentAttached && childElement) {
                  if ($ionicConfig.views.maxCache() > 0) {
                    $ionicViewSwitcher.viewEleIsActive(childElement, false);
                  } else {
                    destroyTab();
                  }
                }
              }
              function destroyTab() {
                childScope && childScope.$destroy();
                isTabContentAttached && childElement && childElement.remove();
                tabContentEle.innerHTML = '';
                isTabContentAttached = childScope = childElement = null;
              }
              $scope.$watch('$tabSelected', tabSelected);
              $scope.$on('$ionicView.afterEnter', function() {
                $ionicViewSwitcher.viewEleIsActive(childElement, $scope.$tabSelected);
              });
              $scope.$on('$ionicView.clearCache', function() {
                if (!$scope.$tabSelected) {
                  destroyTab();
                }
              });
            };
          }
        };
      }]);
      IonicModule.directive('ionTabNav', [function() {
        return {
          restrict: 'E',
          replace: true,
          require: ['^ionTabs', '^ionTab'],
          template: '<a ng-class="{\'tab-item-active\': isTabActive(), \'has-badge\':badge, \'tab-hidden\':isHidden()}" ' + ' ng-disabled="disabled()" class="tab-item">' + '<span class="badge {{badgeStyle}}" ng-if="badge">{{badge}}</span>' + '<i class="icon {{getIconOn()}}" ng-if="getIconOn() && isTabActive()"></i>' + '<i class="icon {{getIconOff()}}" ng-if="getIconOff() && !isTabActive()"></i>' + '<span class="tab-title" ng-bind-html="title"></span>' + '</a>',
          scope: {
            title: '@',
            icon: '@',
            iconOn: '@',
            iconOff: '@',
            badge: '=',
            hidden: '@',
            disabled: '&',
            badgeStyle: '@',
            'class': '@'
          },
          link: function($scope, $element, $attrs, ctrls) {
            var tabsCtrl = ctrls[0],
                tabCtrl = ctrls[1];
            $element[0].removeAttribute('title');
            $scope.selectTab = function(e) {
              e.preventDefault();
              tabsCtrl.select(tabCtrl.$scope, true);
            };
            if (!$attrs.ngClick) {
              $element.on('click', function(event) {
                $scope.$apply(function() {
                  $scope.selectTab(event);
                });
              });
            }
            $scope.isHidden = function() {
              if ($attrs.hidden === 'true' || $attrs.hidden === true)
                return true;
              return false;
            };
            $scope.getIconOn = function() {
              return $scope.iconOn || $scope.icon;
            };
            $scope.getIconOff = function() {
              return $scope.iconOff || $scope.icon;
            };
            $scope.isTabActive = function() {
              return tabsCtrl.selectedTab() === tabCtrl.$scope;
            };
          }
        };
      }]);
      IonicModule.directive('ionTabs', ['$ionicTabsDelegate', '$ionicConfig', function($ionicTabsDelegate, $ionicConfig) {
        return {
          restrict: 'E',
          scope: true,
          controller: '$ionicTabs',
          compile: function(tElement) {
            var innerElement = jqLite('<div class="tab-nav tabs">');
            innerElement.append(tElement.contents());
            tElement.append(innerElement).addClass('tabs-' + $ionicConfig.tabs.position() + ' tabs-' + $ionicConfig.tabs.style());
            return {
              pre: prelink,
              post: postLink
            };
            function prelink($scope, $element, $attr, tabsCtrl) {
              var deregisterInstance = $ionicTabsDelegate._registerInstance(tabsCtrl, $attr.delegateHandle, tabsCtrl.hasActiveScope);
              tabsCtrl.$scope = $scope;
              tabsCtrl.$element = $element;
              tabsCtrl.$tabsElement = jqLite($element[0].querySelector('.tabs'));
              $scope.$watch(function() {
                return $element[0].className;
              }, function(value) {
                var isTabsTop = value.indexOf('tabs-top') !== -1;
                var isHidden = value.indexOf('tabs-item-hide') !== -1;
                $scope.$hasTabs = !isTabsTop && !isHidden;
                $scope.$hasTabsTop = isTabsTop && !isHidden;
                $scope.$emit('$ionicTabs.top', $scope.$hasTabsTop);
              });
              function emitLifecycleEvent(ev, data) {
                ev.stopPropagation();
                var previousSelectedTab = tabsCtrl.previousSelectedTab();
                if (previousSelectedTab) {
                  previousSelectedTab.$broadcast(ev.name.replace('NavView', 'Tabs'), data);
                }
              }
              $scope.$on('$ionicNavView.beforeLeave', emitLifecycleEvent);
              $scope.$on('$ionicNavView.afterLeave', emitLifecycleEvent);
              $scope.$on('$ionicNavView.leave', emitLifecycleEvent);
              $scope.$on('$destroy', function() {
                $scope.$tabsDestroy = true;
                deregisterInstance();
                tabsCtrl.$tabsElement = tabsCtrl.$element = tabsCtrl.$scope = innerElement = null;
                delete $scope.$hasTabs;
                delete $scope.$hasTabsTop;
              });
            }
            function postLink($scope, $element, $attr, tabsCtrl) {
              if (!tabsCtrl.selectedTab()) {
                tabsCtrl.select(0);
              }
            }
          }
        };
      }]);
      IonicModule.directive('ionToggle', ['$timeout', '$ionicConfig', function($timeout, $ionicConfig) {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<div class="item item-toggle">' + '<div ng-transclude></div>' + '<label class="toggle">' + '<input type="checkbox">' + '<div class="track">' + '<div class="handle"></div>' + '</div>' + '</label>' + '</div>',
          compile: function(element, attr) {
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-checked': attr.ngChecked,
              'ng-disabled': attr.ngDisabled,
              'ng-true-value': attr.ngTrueValue,
              'ng-false-value': attr.ngFalseValue,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            if (attr.toggleClass) {
              element[0].getElementsByTagName('label')[0].classList.add(attr.toggleClass);
            }
            element.addClass('toggle-' + $ionicConfig.form.toggle());
            return function($scope, $element) {
              var el = $element[0].getElementsByTagName('label')[0];
              var checkbox = el.children[0];
              var track = el.children[1];
              var handle = track.children[0];
              var ngModelController = jqLite(checkbox).controller('ngModel');
              $scope.toggle = new ionic.views.Toggle({
                el: el,
                track: track,
                checkbox: checkbox,
                handle: handle,
                onChange: function() {
                  if (ngModelController) {
                    ngModelController.$setViewValue(checkbox.checked);
                    $scope.$apply();
                  }
                }
              });
              $scope.$on('$destroy', function() {
                $scope.toggle.destroy();
              });
            };
          }
        };
      }]);
      IonicModule.directive('ionView', function() {
        return {
          restrict: 'EA',
          priority: 1000,
          controller: '$ionicView',
          compile: function(tElement) {
            tElement.addClass('pane');
            tElement[0].removeAttribute('title');
            return function link($scope, $element, $attrs, viewCtrl) {
              viewCtrl.init();
            };
          }
        };
      });
    })();
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:baobab@1.1.1/src/helpers.js", ["npm:baobab@1.1.1/src/type.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var type = require("npm:baobab@1.1.1/src/type.js");
  function arrayOf(o) {
    return Array.prototype.slice.call(o);
  }
  function before(decorator, fn) {
    return function() {
      decorator.apply(null, arguments);
      fn.apply(null, arguments);
    };
  }
  function splice(array, index, nb) {
    var elements = arrayOf(arguments).slice(3);
    return array.slice(0, index).concat(elements).concat(array.slice(index + nb));
  }
  function shallowMerge(o1, o2) {
    var o = {},
        k;
    for (k in o1)
      o[k] = o1[k];
    for (k in o2)
      o[k] = o2[k];
    return o;
  }
  function cloneRegexp(re) {
    var pattern = re.source,
        flags = '';
    if (re.global)
      flags += 'g';
    if (re.multiline)
      flags += 'm';
    if (re.ignoreCase)
      flags += 'i';
    if (re.sticky)
      flags += 'y';
    if (re.unicode)
      flags += 'u';
    return new RegExp(pattern, flags);
  }
  function cloner(deep, item) {
    if (!item || typeof item !== 'object' || item instanceof Error || ('ArrayBuffer' in global && item instanceof ArrayBuffer))
      return item;
    if (type.Array(item)) {
      if (deep) {
        var i,
            l,
            a = [];
        for (i = 0, l = item.length; i < l; i++)
          a.push(deepClone(item[i]));
        return a;
      } else {
        return item.slice(0);
      }
    }
    if (type.Date(item))
      return new Date(item.getTime());
    if (item instanceof RegExp)
      return cloneRegexp(item);
    if (type.Object(item)) {
      var k,
          o = {};
      if (item.constructor && item.constructor !== Object)
        o = Object.create(item.constructor.prototype);
      for (k in item)
        if (item.hasOwnProperty(k))
          o[k] = deep ? deepClone(item[k]) : item[k];
      return o;
    }
    return item;
  }
  var shallowClone = cloner.bind(null, false),
      deepClone = cloner.bind(null, true);
  function freezer(deep, o) {
    if (typeof o !== 'object')
      return;
    Object.freeze(o);
    if (!deep)
      return;
    if (Array.isArray(o)) {
      var i,
          l;
      for (i = 0, l = o.length; i < l; i++)
        deepFreeze(o[i]);
    } else {
      var p,
          k;
      for (k in o) {
        p = o[k];
        if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p))
          continue;
        deepFreeze(p);
      }
    }
  }
  var freeze = Object.freeze ? freezer.bind(null, false) : Function.prototype,
      deepFreeze = Object.freeze ? freezer.bind(null, true) : Function.prototype;
  function compose(fn1, fn2) {
    return function(arg) {
      return fn2(fn1(arg));
    };
  }
  function first(a, fn) {
    var i,
        l;
    for (i = 0, l = a.length; i < l; i++) {
      if (fn(a[i]))
        return a[i];
    }
    return;
  }
  function index(a, fn) {
    var i,
        l;
    for (i = 0, l = a.length; i < l; i++) {
      if (fn(a[i]))
        return i;
    }
    return -1;
  }
  function compare(object, spec) {
    var ok = true,
        k;
    if (!object) {
      return false;
    }
    for (k in spec) {
      if (type.Object(spec[k])) {
        ok = ok && compare(object[k], spec[k]);
      } else if (type.Array(spec[k])) {
        ok = ok && !!~spec[k].indexOf(object[k]);
      } else {
        if (object[k] !== spec[k])
          return false;
      }
    }
    return ok;
  }
  function firstByComparison(object, spec) {
    return first(object, function(e) {
      return compare(e, spec);
    });
  }
  function indexByComparison(object, spec) {
    return index(object, function(e) {
      return compare(e, spec);
    });
  }
  function getIn(object, path, tree) {
    path = path || [];
    var c = object,
        p,
        i,
        l;
    for (i = 0, l = path.length; i < l; i++) {
      if (!c)
        return;
      if (typeof path[i] === 'function') {
        if (!type.Array(c))
          return;
        c = first(c, path[i]);
      } else if (typeof path[i] === 'object') {
        if (tree && '$cursor' in path[i]) {
          if (!type.Path(path[i].$cursor))
            throw Error('baobab.getIn: $cursor path must be an array.');
          p = tree.get(path[i].$cursor);
          c = c[p];
        } else if (!type.Array(c)) {
          return;
        } else {
          c = firstByComparison(c, path[i]);
        }
      } else {
        c = c[path[i]];
      }
    }
    return c;
  }
  function solvePath(object, path, tree) {
    var solvedPath = [],
        c = object,
        idx,
        i,
        l;
    for (i = 0, l = path.length; i < l; i++) {
      if (!c)
        return null;
      if (typeof path[i] === 'function') {
        if (!type.Array(c))
          return;
        idx = index(c, path[i]);
        solvedPath.push(idx);
        c = c[idx];
      } else if (typeof path[i] === 'object') {
        if (tree && '$cursor' in path[i]) {
          if (!type.Path(path[i].$cursor))
            throw Error('baobab.getIn: $cursor path must be an array.');
          p = tree.get(path[i].$cursor);
          solvedPath.push(p);
          c = c[p];
        } else if (!type.Array(c)) {
          return;
        } else {
          idx = indexByComparison(c, path[i]);
          solvedPath.push(idx);
          c = c[idx];
        }
      } else {
        solvedPath.push(path[i]);
        c = c[path[i]] || {};
      }
    }
    return solvedPath;
  }
  function solveUpdate(log, paths) {
    var i,
        j,
        k,
        l,
        m,
        n,
        p,
        c,
        s;
    for (i = 0, l = paths.length; i < l; i++) {
      p = paths[i];
      if (!p.length)
        return true;
      for (j = 0, m = log.length; j < m; j++) {
        c = log[j];
        if (!c.length)
          return true;
        for (k = 0, n = c.length; k < n; k++) {
          s = c[k];
          if (s != p[k])
            break;
          if (k + 1 === n || k + 1 === p.length)
            return true;
        }
      }
    }
    return false;
  }
  function pathObject(path, spec) {
    var l = path.length,
        o = {},
        c = o,
        i;
    if (!l)
      o = spec;
    for (i = 0; i < l; i++) {
      c[path[i]] = (i + 1 === l) ? spec : {};
      c = c[path[i]];
    }
    return o;
  }
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }
  function archive(size) {
    var records = [];
    return {
      add: function(record) {
        records.unshift(record);
        if (records.length > size)
          records.length = size;
      },
      back: function(steps) {
        var record = records[steps - 1];
        if (record)
          records = records.slice(steps);
        return record;
      },
      get: function() {
        return records;
      }
    };
  }
  module.exports = {
    archive: archive,
    arrayOf: arrayOf,
    before: before,
    freeze: freeze,
    deepClone: deepClone,
    deepFreeze: deepFreeze,
    shallowClone: shallowClone,
    shallowMerge: shallowMerge,
    compose: compose,
    getIn: getIn,
    inherits: inherits,
    pathObject: pathObject,
    solvePath: solvePath,
    solveUpdate: solveUpdate,
    splice: splice
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0/lib/qr-encode.js", ["npm:qr-encode@0.3.0/lib/qr.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var qrcode = require("npm:qr-encode@0.3.0/lib/qr.js");
  function QR(text, opts) {
    text = text || '';
    opts = opts || {};
    var type = opts.type || 4;
    var level = opts.level || 'L';
    var size = opts.size || 4;
    var margin = opts.margin || 0;
    var qr = qrcode(type, level);
    qr.addData(text);
    qr.make();
    return qr.createImgSrc(size, margin);
  }
  QR.prototype.level = function(level) {
    this._level = level;
    return this;
  };
  module.exports = QR;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.1.js", ["github:jspm/nodelibs-process@0.1.1/index.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@0.9.17/library/modules/es6.object.assign.js", ["npm:core-js@0.9.17/library/modules/$.def.js", "npm:core-js@0.9.17/library/modules/$.assign.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@0.9.17/library/modules/$.def.js");
  $def($def.S, 'Object', {assign: require("npm:core-js@0.9.17/library/modules/$.assign.js")});
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var pki = forge.pki;
    var p12 = forge.pkcs12 = forge.pkcs12 || {};
    var contentInfoValidator = {
      name: 'ContentInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'ContentInfo.contentType',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'contentType'
      }, {
        name: 'ContentInfo.content',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: 'content'
      }]
    };
    var pfxValidator = {
      name: 'PFX',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PFX.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }, contentInfoValidator, {
        name: 'PFX.macData',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: 'mac',
        value: [{
          name: 'PFX.macData.mac',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'PFX.macData.mac.digestAlgorithm',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: 'PFX.macData.mac.digestAlgorithm.algorithm',
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: 'macAlgorithm'
            }, {
              name: 'PFX.macData.mac.digestAlgorithm.parameters',
              tagClass: asn1.Class.UNIVERSAL,
              captureAsn1: 'macAlgorithmParameters'
            }]
          }, {
            name: 'PFX.macData.mac.digest',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: 'macDigest'
          }]
        }, {
          name: 'PFX.macData.macSalt',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: 'macSalt'
        }, {
          name: 'PFX.macData.iterations',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          optional: true,
          capture: 'macIterations'
        }]
      }]
    };
    var safeBagValidator = {
      name: 'SafeBag',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'SafeBag.bagId',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'bagId'
      }, {
        name: 'SafeBag.bagValue',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: 'bagValue'
      }, {
        name: 'SafeBag.bagAttributes',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: 'bagAttributes'
      }]
    };
    var attributeValidator = {
      name: 'Attribute',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'Attribute.attrId',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'oid'
      }, {
        name: 'Attribute.attrValues',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: 'values'
      }]
    };
    var certBagValidator = {
      name: 'CertBag',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'CertBag.certId',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'certId'
      }, {
        name: 'CertBag.certValue',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        value: [{
          name: 'CertBag.certValue[0]',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: 'cert'
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result = [];
      for (var i = 0; i < safeContents.length; i++) {
        for (var j = 0; j < safeContents[i].safeBags.length; j++) {
          var bag = safeContents[i].safeBags[j];
          if (bagType !== undefined && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result.push(bag);
          }
        }
      }
      return result;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === 'string') {
        password = strict;
        strict = true;
      } else if (strict === undefined) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#12 PFX. ' + 'ASN.1 object is not an PKCS#12 PFX.');
        error.errors = error;
        throw error;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        getBags: function(filter) {
          var rval = {};
          var localKeyId;
          if ('localKeyId' in filter) {
            localKeyId = filter.localKeyId;
          } else if ('localKeyIdHex' in filter) {
            localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
          }
          if (localKeyId === undefined && !('friendlyName' in filter) && 'bagType' in filter) {
            rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);
          }
          if (localKeyId !== undefined) {
            rval.localKeyId = _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, filter.bagType);
          }
          if ('friendlyName' in filter) {
            rval.friendlyName = _getBagsByAttribute(pfx.safeContents, 'friendlyName', filter.friendlyName, filter.bagType);
          }
          return rval;
        },
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(pfx.safeContents, 'friendlyName', friendlyName, bagType);
        },
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, bagType);
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error = new Error('PKCS#12 PFX of version other than 3 not supported.');
        error.version = capture.version.charCodeAt(0);
        throw error;
      }
      if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
        var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');
        error.oid = asn1.derToOid(capture.contentType);
        throw error;
      }
      var data = capture.content.value[0];
      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
        throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');
      }
      data = _decodePkcs7Data(data);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki.oids.sha1:
            md = forge.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki.oids.sha256:
            md = forge.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki.oids.sha384:
            md = forge.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki.oids.sha512:
            md = forge.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki.oids.md5:
            md = forge.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);
        }
        var macSalt = new forge.util.ByteBuffer(capture.macSalt);
        var macIterations = (('macIterations' in capture) ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);
        var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);
        var mac = forge.hmac.create();
        mac.start(md, macKey);
        mac.update(data.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error('PKCS#12 MAC could not be verified. Invalid password?');
        }
      }
      _decodeAuthenticatedSafe(pfx, data.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data) {
      if (data.composed || data.constructed) {
        var value = forge.util.createBuffer();
        for (var i = 0; i < data.value.length; ++i) {
          value.putBytes(data.value[i].value);
        }
        data.composed = data.constructed = false;
        data.value = value.getBytes();
      }
      return data;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' + 'SEQUENCE OF ContentInfo');
      }
      for (var i = 0; i < authSafe.value.length; i++) {
        var contentInfo = authSafe.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error = new Error('Cannot read ContentInfo.');
          error.errors = errors;
          throw error;
        }
        var obj = {encrypted: false};
        var safeContents = null;
        var data = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki.oids.data:
            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
              throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');
            }
            safeContents = _decodePkcs7Data(data).value;
            break;
          case pki.oids.encryptedData:
            safeContents = _decryptSafeContents(data, password);
            obj.encrypted = true;
            break;
          default:
            var error = new Error('Unsupported PKCS#12 contentType.');
            error.contentType = asn1.derToOid(capture.contentType);
            throw error;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
        var error = new Error('Cannot read EncryptedContentInfo.');
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki.oids.data) {
        var error = new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');
        error.oid = oid;
        throw error;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error('Failed to decrypt PKCS#12 SafeContents.');
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');
      }
      var res = [];
      for (var i = 0; i < safeContents.value.length; i++) {
        var safeBag = safeContents.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error = new Error('Cannot read SafeBag.');
          error.errors = errors;
          throw error;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator,
            decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');
            }
          case pki.oids.keyBag:
            try {
              bag.key = pki.privateKeyFromAsn1(bagAsn1);
            } catch (e) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          case pki.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                var error = new Error('Unsupported certificate type, only X.509 supported.');
                error.oid = asn1.derToOid(capture.certId);
                throw error;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki.certificateFromAsn1(certAsn1, true);
              } catch (e) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error = new Error('Unsupported PKCS#12 SafeBag type.');
            error.oid = bag.type;
            throw error;
        }
        if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error = new Error('Cannot read PKCS#12 ' + validator.name);
          error.errors = errors;
          throw error;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== undefined) {
        for (var i = 0; i < attributes.length; ++i) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
            var error = new Error('Cannot read PKCS#12 BagAttribute.');
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki.oids[oid] === undefined) {
            continue;
          }
          decodedAttrs[pki.oids[oid]] = [];
          for (var j = 0; j < capture.values.length; ++j) {
            decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key, cert, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';
      if (!('useMac' in options)) {
        options.useMac = true;
      }
      if (!('localKeyId' in options)) {
        options.localKeyId = null;
      }
      if (!('generateLocalKeyId' in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === 'string') {
            pairedCert = pki.certificateFromPem(pairedCert);
          }
          var sha1 = forge.md.sha1.create();
          sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha1.digest().getBytes();
        } else {
          localKeyId = forge.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));
      }
      if ('friendlyName' in options) {
        attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert !== null) {
        if (forge.util.isArray(cert)) {
          chain = cert;
        } else {
          chain = [cert];
        }
      }
      var certSafeBags = [];
      for (var i = 0; i < chain.length; ++i) {
        cert = chain[i];
        if (typeof cert === 'string') {
          cert = pki.certificateFromPem(cert);
        }
        var certBagAttrs = (i === 0) ? bagAttrs : undefined;
        var certAsn1 = pki.certificateToAsn1(cert);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]), certBagAttrs]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);
        var certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);
        contents.push(certCI);
      }
      var keyBag = null;
      if (key !== null) {
        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pkAsn1]), bagAttrs]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pki.encryptPrivateKeyInfo(pkAsn1, password, options)]), bagAttrs]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);
        contents.push(keyCI);
      }
      var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);
      var macData;
      if (options.useMac) {
        var sha1 = forge.md.sha1.create();
        var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));
        var count = options.count;
        var key = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge.hmac.create();
        mac.start(sha1, key);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]), macData]);
    };
    p12.generateKey = forge.pbe.generatePkcs12Key;
  }
  var name = 'pkcs12';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pkcs12.js", ["require", "module", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/hmac.js", "npm:node-forge@0.6.30/js/oids.js", "npm:node-forge@0.6.30/js/pkcs7asn1.js", "npm:node-forge@0.6.30/js/pbe.js", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/rsa.js", "npm:node-forge@0.6.30/js/sha1.js", "npm:node-forge@0.6.30/js/util.js", "npm:node-forge@0.6.30/js/x509.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
System.registerDynamic("github:driftyco/ionic@1.0.0.js", ["github:driftyco/ionic@1.0.0/release/js/ionic-angular.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:driftyco/ionic@1.0.0/release/js/ionic-angular.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@1.1.1/src/cursor.js", ["npm:emmett@3.0.1.js", "npm:baobab@1.1.1/src/helpers.js", "npm:baobab@1.1.1/defaults.js", "npm:baobab@1.1.1/src/type.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var EventEmitter = require("npm:emmett@3.0.1.js"),
      helpers = require("npm:baobab@1.1.1/src/helpers.js"),
      defaults = require("npm:baobab@1.1.1/defaults.js"),
      type = require("npm:baobab@1.1.1/src/type.js");
  function Cursor(tree, path, hash) {
    var self = this;
    EventEmitter.call(this);
    path = path || [];
    this._identity = '[object Cursor]';
    this._additionnalPaths = [];
    this.tree = tree;
    this.path = path;
    this.hash = hash;
    this.archive = null;
    this.recording = false;
    this.undoing = false;
    this.complex = type.ComplexPath(path);
    this.solvedPath = path;
    if (this.complex)
      this.solvedPath = helpers.solvePath(this.tree.data, path, this.tree);
    if (this.complex)
      path.forEach(function(step) {
        if (type.Object(step) && '$cursor' in step)
          this._additionnalPaths.push(step.$cursor);
      }, this);
    this.relevant = this.get(false) !== undefined;
    function update(previousData) {
      var record = helpers.getIn(previousData, self.solvedPath, self.tree);
      if (self.recording && !self.undoing) {
        self.archive.add(record);
      }
      self.undoing = false;
      return self.emit('update', {
        data: self.get(false),
        previousData: record
      });
    }
    this.updateHandler = function(e) {
      var log = e.data.log,
          previousData = e.data.previousData,
          shouldFire = false,
          c,
          p,
          l,
          m,
          i,
          j;
      if (self.complexPath)
        self.solvedPath = helpers.solvePath(self.tree.data, self.path, self.tree);
      if (!self.path.length)
        return update(previousData);
      if (self.solvedPath)
        shouldFire = helpers.solveUpdate(log, [self.solvedPath].concat(self._additionnalPaths));
      var data = self.get(false) !== undefined;
      if (self.relevant) {
        if (data && shouldFire) {
          update(previousData);
        } else if (!data) {
          self.emit('irrelevant');
          self.relevant = false;
        }
      } else {
        if (data && shouldFire) {
          self.emit('relevant');
          update(previousData);
          self.relevant = true;
        }
      }
    };
    var bound = false;
    this._lazyBind = function() {
      if (bound)
        return;
      bound = true;
      self.tree.on('update', self.updateHandler);
    };
    this.on = helpers.before(this._lazyBind, this.on.bind(this));
    this.once = helpers.before(this._lazyBind, this.once.bind(this));
    if (this.complexPath)
      this._lazyBind();
  }
  helpers.inherits(Cursor, EventEmitter);
  Cursor.prototype.isRoot = function() {
    return !this.path.length;
  };
  Cursor.prototype.isLeaf = function() {
    return type.Primitive(this.get(false));
  };
  Cursor.prototype.isBranch = function() {
    return !this.isLeaf() && !this.isRoot();
  };
  Cursor.prototype.root = function() {
    return this.tree.root;
  };
  Cursor.prototype.select = function(path) {
    if (arguments.length > 1)
      path = helpers.arrayOf(arguments);
    if (!type.Path(path))
      throw Error('baobab.Cursor.select: invalid path.');
    return this.tree.select(this.path.concat(path));
  };
  Cursor.prototype.up = function() {
    if (this.solvedPath && this.solvedPath.length)
      return this.tree.select(this.path.slice(0, -1));
    else
      return null;
  };
  Cursor.prototype.left = function() {
    var last = +this.solvedPath[this.solvedPath.length - 1];
    if (isNaN(last))
      throw Error('baobab.Cursor.left: cannot go left on a non-list type.');
    return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;
  };
  Cursor.prototype.leftmost = function() {
    var last = +this.solvedPath[this.solvedPath.length - 1];
    if (isNaN(last))
      throw Error('baobab.Cursor.leftmost: cannot go left on a non-list type.');
    return this.tree.select(this.solvedPath.slice(0, -1).concat(0));
  };
  Cursor.prototype.right = function() {
    var last = +this.solvedPath[this.solvedPath.length - 1];
    if (isNaN(last))
      throw Error('baobab.Cursor.right: cannot go right on a non-list type.');
    if (last + 1 === this.up().get(false).length)
      return null;
    return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));
  };
  Cursor.prototype.rightmost = function() {
    var last = +this.solvedPath[this.solvedPath.length - 1];
    if (isNaN(last))
      throw Error('baobab.Cursor.right: cannot go right on a non-list type.');
    var list = this.up().get(false);
    return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));
  };
  Cursor.prototype.down = function() {
    var last = +this.solvedPath[this.solvedPath.length - 1];
    if (!(this.get(false) instanceof Array))
      return null;
    return this.tree.select(this.solvedPath.concat(0));
  };
  Cursor.prototype.map = function(fn, scope) {
    var array = this.get(false),
        l = arguments.length;
    if (!type.Array(array))
      throw Error('baobab.Cursor.map: cannot map a non-list type.');
    return array.map(function(item, i) {
      return fn.call(l > 1 ? scope : this, this.select(i), i);
    }, this);
  };
  Cursor.prototype.get = function(path) {
    var skipEvent = false;
    if (path === false) {
      path = [];
      skipEvent = true;
    }
    if (arguments.length > 1)
      path = helpers.arrayOf(arguments);
    var fullPath = this.solvedPath.concat([].concat(path || path === 0 ? path : []));
    var data = helpers.getIn(this.tree.data, fullPath, this.tree);
    if (!skipEvent)
      this.tree.emit('get', {
        path: fullPath,
        data: data
      });
    return data;
  };
  function pathPolymorphism(method, allowedType, key, val) {
    if (arguments.length > 5)
      throw Error('baobab.Cursor.' + method + ': too many arguments.');
    if (method === 'unset') {
      val = true;
      if (arguments.length === 2)
        key = [];
    } else if (arguments.length < 4) {
      val = key;
      key = [];
    }
    if (!type.Path(key))
      throw Error('baobab.Cursor.' + method + ': invalid path "' + key + '".');
    if (method === 'splice' && !type.Splicer(val)) {
      if (type.Array(val))
        val = [val];
      else
        throw Error('baobab.Cursor.splice: incorrect value.');
    }
    if (allowedType && !allowedType(val))
      throw Error('baobab.Cursor.' + method + ': incorrect value.');
    var path = [].concat(key),
        solvedPath = helpers.solvePath(this.get(false), path, this.tree);
    if (!solvedPath)
      throw Error('baobab.Cursor.' + method + ': could not solve dynamic path.');
    var leaf = {};
    leaf['$' + method] = val;
    var spec = helpers.pathObject(solvedPath, leaf);
    return spec;
  }
  function makeUpdateMethod(command, type) {
    Cursor.prototype[command] = function() {
      var spec = pathPolymorphism.bind(this, command, type).apply(this, arguments);
      return this.update(spec, true);
    };
  }
  makeUpdateMethod('set');
  makeUpdateMethod('apply', type.Function);
  makeUpdateMethod('chain', type.Function);
  makeUpdateMethod('push');
  makeUpdateMethod('unshift');
  makeUpdateMethod('merge', type.Object);
  makeUpdateMethod('splice');
  Cursor.prototype.unset = function(key) {
    if (key === undefined && this.isRoot())
      throw Error('baobab.Cursor.unset: cannot remove root node.');
    var spec = pathPolymorphism.bind(this, 'unset', null).apply(this, arguments);
    return this.update(spec, true);
  };
  Cursor.prototype.update = function(spec, skipMerge) {
    if (!type.Object(spec))
      throw Error('baobab.Cursor.update: invalid specifications.');
    this.tree.stack(helpers.pathObject(this.solvedPath, spec), skipMerge);
    return this;
  };
  Cursor.prototype.startRecording = function(maxRecords) {
    maxRecords = maxRecords || 5;
    if (maxRecords < 1)
      throw Error('baobab.Cursor.startRecording: invalid maximum number of records.');
    if (this.archive)
      return this;
    this._lazyBind();
    this.archive = helpers.archive(maxRecords);
    this.recording = true;
    return this;
  };
  Cursor.prototype.stopRecording = function() {
    this.recording = false;
    return this;
  };
  Cursor.prototype.undo = function(steps) {
    steps = steps || 1;
    if (!this.recording)
      throw Error('baobab.Cursor.undo: cursor is not recording.');
    if (!type.PositiveInteger(steps))
      throw Error('baobab.Cursor.undo: expecting a positive integer.');
    var record = this.archive.back(steps);
    if (!record)
      throw Error('baobab.Cursor.undo: cannot find a relevant record (' + steps + ' back).');
    this.undoing = true;
    return this.set(record);
  };
  Cursor.prototype.hasHistory = function() {
    return !!(this.archive && this.archive.get().length);
  };
  Cursor.prototype.getHistory = function() {
    return this.archive ? this.archive.get() : [];
  };
  Cursor.prototype.clearHistory = function() {
    this.archive = null;
    return this;
  };
  Cursor.prototype.release = function() {
    this.tree.off('update', this.updateHandler);
    if (this.hash)
      delete this.tree._cursors[this.hash];
    delete this.tree;
    delete this.path;
    delete this.solvedPath;
    delete this.archive;
    this.kill();
  };
  Cursor.prototype.toJSON = function() {
    return this.get();
  };
  Cursor.prototype.toString = function() {
    return this._identity;
  };
  module.exports = Cursor;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-encode@0.3.0.js", ["npm:qr-encode@0.3.0/lib/qr-encode.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:qr-encode@0.3.0/lib/qr-encode.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ramda@0.11.0/dist/ramda.js", ["github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      'use strict';
      var __ = {ramda: 'placeholder'};
      var _add = function _add(a, b) {
        return a + b;
      };
      var _all = function _all(fn, list) {
        var idx = -1;
        while (++idx < list.length) {
          if (!fn(list[idx])) {
            return false;
          }
        }
        return true;
      };
      var _any = function _any(fn, list) {
        var idx = -1;
        while (++idx < list.length) {
          if (fn(list[idx])) {
            return true;
          }
        }
        return false;
      };
      var _assoc = function _assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
          result[p] = obj[p];
        }
        result[prop] = val;
        return result;
      };
      var _compose = function _compose(f, g) {
        return function() {
          return f.call(this, g.apply(this, arguments));
        };
      };
      var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = -1;
        while (++idx < len1) {
          result[result.length] = set1[idx];
        }
        idx = -1;
        while (++idx < len2) {
          result[result.length] = set2[idx];
        }
        return result;
      };
      var _containsWith = function _containsWith(pred, x, list) {
        var idx = -1,
            len = list.length;
        while (++idx < len) {
          if (pred(x, list[idx])) {
            return true;
          }
        }
        return false;
      };
      var _createMaxMinBy = function _createMaxMinBy(comparator) {
        return function(valueComputer, list) {
          if (!(list && list.length > 0)) {
            return;
          }
          var idx = 0,
              winner = list[idx],
              computedWinner = valueComputer(winner),
              computedCurrent;
          while (++idx < list.length) {
            computedCurrent = valueComputer(list[idx]);
            if (comparator(computedCurrent, computedWinner)) {
              computedWinner = computedCurrent;
              winner = list[idx];
            }
          }
          return winner;
        };
      };
      var _curry1 = function _curry1(fn) {
        return function f1(a) {
          if (arguments.length === 0) {
            return f1;
          } else if (a === __) {
            return f1;
          } else {
            return fn(a);
          }
        };
      };
      var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
          var n = arguments.length;
          if (n === 0) {
            return f2;
          } else if (n === 1 && a === __) {
            return f2;
          } else if (n === 1) {
            return _curry1(function(b) {
              return fn(a, b);
            });
          } else if (n === 2 && a === __ && b === __) {
            return f2;
          } else if (n === 2 && a === __) {
            return _curry1(function(a) {
              return fn(a, b);
            });
          } else if (n === 2 && b === __) {
            return _curry1(function(b) {
              return fn(a, b);
            });
          } else {
            return fn(a, b);
          }
        };
      };
      var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
          var n = arguments.length;
          if (n === 0) {
            return f3;
          } else if (n === 1 && a === __) {
            return f3;
          } else if (n === 1) {
            return _curry2(function(b, c) {
              return fn(a, b, c);
            });
          } else if (n === 2 && a === __ && b === __) {
            return f3;
          } else if (n === 2 && a === __) {
            return _curry2(function(a, c) {
              return fn(a, b, c);
            });
          } else if (n === 2 && b === __) {
            return _curry2(function(b, c) {
              return fn(a, b, c);
            });
          } else if (n === 2) {
            return _curry1(function(c) {
              return fn(a, b, c);
            });
          } else if (n === 3 && a === __ && b === __ && c === __) {
            return f3;
          } else if (n === 3 && a === __ && b === __) {
            return _curry2(function(a, b) {
              return fn(a, b, c);
            });
          } else if (n === 3 && a === __ && c === __) {
            return _curry2(function(a, c) {
              return fn(a, b, c);
            });
          } else if (n === 3 && b === __ && c === __) {
            return _curry2(function(b, c) {
              return fn(a, b, c);
            });
          } else if (n === 3 && a === __) {
            return _curry1(function(a) {
              return fn(a, b, c);
            });
          } else if (n === 3 && b === __) {
            return _curry1(function(b) {
              return fn(a, b, c);
            });
          } else if (n === 3 && c === __) {
            return _curry1(function(c) {
              return fn(a, b, c);
            });
          } else {
            return fn(a, b, c);
          }
        };
      };
      var _dissoc = function _dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
          if (p !== prop) {
            result[p] = obj[p];
          }
        }
        return result;
      };
      var _filter = function _filter(fn, list) {
        var idx = -1,
            len = list.length,
            result = [];
        while (++idx < len) {
          if (fn(list[idx])) {
            result[result.length] = list[idx];
          }
        }
        return result;
      };
      var _filterIndexed = function _filterIndexed(fn, list) {
        var idx = -1,
            len = list.length,
            result = [];
        while (++idx < len) {
          if (fn(list[idx], idx, list)) {
            result[result.length] = list[idx];
          }
        }
        return result;
      };
      var _forEach = function _forEach(fn, list) {
        var idx = -1,
            len = list.length;
        while (++idx < len) {
          fn(list[idx]);
        }
        return list;
      };
      var _functionsWith = function _functionsWith(fn) {
        return function(obj) {
          return _filter(function(key) {
            return typeof obj[key] === 'function';
          }, fn(obj));
        };
      };
      var _gt = function _gt(a, b) {
        return a > b;
      };
      var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      };
      var _indexOf = function _indexOf(list, item, from) {
        var idx = 0,
            len = list.length;
        if (typeof from == 'number') {
          idx = from < 0 ? Math.max(0, len + from) : from;
        }
        while (idx < len) {
          if (list[idx] === item) {
            return idx;
          }
          ++idx;
        }
        return -1;
      };
      var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
      };
      var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
      };
      var _isThenable = function _isThenable(value) {
        return value != null && value === Object(value) && typeof value.then === 'function';
      };
      var _lastIndexOf = function _lastIndexOf(list, item, from) {
        var idx = list.length;
        if (typeof from == 'number') {
          idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
        }
        while (--idx >= 0) {
          if (list[idx] === item) {
            return idx;
          }
        }
        return -1;
      };
      var _lt = function _lt(a, b) {
        return a < b;
      };
      var _map = function _map(fn, list) {
        var idx = -1,
            len = list.length,
            result = [];
        while (++idx < len) {
          result[idx] = fn(list[idx]);
        }
        return result;
      };
      var _multiply = function _multiply(a, b) {
        return a * b;
      };
      var _nth = function _nth(n, list) {
        return n < 0 ? list[list.length + n] : list[n];
      };
      var _pairWith = function _pairWith(fn) {
        return function(obj) {
          return _map(function(key) {
            return [key, obj[key]];
          }, fn(obj));
        };
      };
      var _path = function _path(paths, obj) {
        if (obj == null || paths.length === 0) {
          return;
        } else {
          var val = obj;
          for (var idx = 0,
              len = paths.length; idx < len && val != null; idx += 1) {
            val = val[paths[idx]];
          }
          return val;
        }
      };
      var _pickAll = function _pickAll(names, obj) {
        var copy = {};
        _forEach(function(name) {
          copy[name] = obj[name];
        }, names);
        return copy;
      };
      var _prepend = function _prepend(el, list) {
        return _concat([el], list);
      };
      var _reduce = function _reduce(fn, acc, list) {
        var idx = -1,
            len = list.length;
        while (++idx < len) {
          acc = fn(acc, list[idx]);
        }
        return acc;
      };
      var _satisfiesSpec = function _satisfiesSpec(spec, parsedSpec, testObj) {
        if (spec === testObj) {
          return true;
        }
        if (testObj == null) {
          return false;
        }
        parsedSpec.fn = parsedSpec.fn || [];
        parsedSpec.obj = parsedSpec.obj || [];
        var key,
            val,
            idx = -1,
            fnLen = parsedSpec.fn.length,
            j = -1,
            objLen = parsedSpec.obj.length;
        while (++idx < fnLen) {
          key = parsedSpec.fn[idx];
          val = spec[key];
          if (!(key in testObj)) {
            return false;
          }
          if (!val(testObj[key], testObj)) {
            return false;
          }
        }
        while (++j < objLen) {
          key = parsedSpec.obj[j];
          if (spec[key] !== testObj[key]) {
            return false;
          }
        }
        return true;
      };
      var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
          case 1:
            return _slice(args, 0, args.length);
          case 2:
            return _slice(args, from, args.length);
          default:
            var length = Math.max(0, to - from),
                list = [],
                idx = -1;
            while (++idx < length) {
              list[idx] = args[from + idx];
            }
            return list;
        }
      };
      var add = _curry2(_add);
      var all = _curry2(_all);
      var always = _curry1(function always(val) {
        return function() {
          return val;
        };
      });
      var and = _curry2(function and(f, g) {
        return function _and() {
          return f.apply(this, arguments) && g.apply(this, arguments);
        };
      });
      var any = _curry2(_any);
      var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
      });
      var arity = _curry2(function(n, fn) {
        switch (n) {
          case 0:
            return function() {
              return fn.apply(this, arguments);
            };
          case 1:
            return function(a0) {
              void a0;
              return fn.apply(this, arguments);
            };
          case 2:
            return function(a0, a1) {
              void a1;
              return fn.apply(this, arguments);
            };
          case 3:
            return function(a0, a1, a2) {
              void a2;
              return fn.apply(this, arguments);
            };
          case 4:
            return function(a0, a1, a2, a3) {
              void a3;
              return fn.apply(this, arguments);
            };
          case 5:
            return function(a0, a1, a2, a3, a4) {
              void a4;
              return fn.apply(this, arguments);
            };
          case 6:
            return function(a0, a1, a2, a3, a4, a5) {
              void a5;
              return fn.apply(this, arguments);
            };
          case 7:
            return function(a0, a1, a2, a3, a4, a5, a6) {
              void a6;
              return fn.apply(this, arguments);
            };
          case 8:
            return function(a0, a1, a2, a3, a4, a5, a6, a7) {
              void a7;
              return fn.apply(this, arguments);
            };
          case 9:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              void a8;
              return fn.apply(this, arguments);
            };
          case 10:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              void a9;
              return fn.apply(this, arguments);
            };
          default:
            throw new Error('First argument to arity must be a non-negative integer no greater than ten');
        }
      });
      var assoc = _curry3(_assoc);
      var bind = _curry2(function bind(fn, thisObj) {
        return arity(fn.length, function() {
          return fn.apply(thisObj, arguments);
        });
      });
      var comparator = _curry1(function comparator(pred) {
        return function(a, b) {
          return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
      });
      var cond = function cond() {
        var pairs = arguments;
        return function() {
          var idx = -1;
          while (++idx < pairs.length) {
            if (pairs[idx][0].apply(this, arguments)) {
              return pairs[idx][1].apply(this, arguments);
            }
          }
        };
      };
      var containsWith = _curry3(_containsWith);
      var countBy = _curry2(function countBy(fn, list) {
        var counts = {};
        var len = list.length;
        var idx = -1;
        while (++idx < len) {
          var key = fn(list[idx]);
          counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
        }
        return counts;
      });
      var createMapEntry = _curry2(function(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
      });
      var curryN = _curry2(function curryN(length, fn) {
        return arity(length, function() {
          var n = arguments.length;
          var shortfall = length - n;
          var idx = n;
          while (idx--) {
            if (arguments[idx] === __) {
              shortfall += 1;
            }
          }
          if (shortfall <= 0) {
            return fn.apply(this, arguments);
          } else {
            var initialArgs = _slice(arguments);
            return curryN(shortfall, function() {
              var currentArgs = _slice(arguments);
              var combinedArgs = [];
              var idx = -1;
              while (++idx < n) {
                var val = initialArgs[idx];
                combinedArgs[idx] = val === __ ? currentArgs.shift() : val;
              }
              return fn.apply(this, combinedArgs.concat(currentArgs));
            });
          }
        });
      });
      var dec = add(-1);
      var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null ? d : v;
      });
      var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = -1;
        var firstLen = first.length;
        var containsPred = containsWith(pred);
        while (++idx < firstLen) {
          if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {
            out[idx] = first[idx];
          }
        }
        return out;
      });
      var dissoc = _curry2(_dissoc);
      var divide = _curry2(function divide(a, b) {
        return a / b;
      });
      var dropWhile = _curry2(function dropWhile(pred, list) {
        var idx = -1,
            len = list.length;
        while (++idx < len && pred(list[idx])) {}
        return _slice(list, idx);
      });
      var eq = _curry2(function eq(a, b) {
        if (a === 0) {
          return 1 / a === 1 / b;
        } else {
          return a === b || a !== a && b !== b;
        }
      });
      var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return obj1[prop] === obj2[prop];
      });
      var filterIndexed = _curry2(_filterIndexed);
      var find = _curry2(function find(fn, list) {
        var idx = -1;
        var len = list.length;
        while (++idx < len) {
          if (fn(list[idx])) {
            return list[idx];
          }
        }
      });
      var findIndex = _curry2(function findIndex(fn, list) {
        var idx = -1;
        var len = list.length;
        while (++idx < len) {
          if (fn(list[idx])) {
            return idx;
          }
        }
        return -1;
      });
      var findLast = _curry2(function findLast(fn, list) {
        var idx = list.length;
        while (idx--) {
          if (fn(list[idx])) {
            return list[idx];
          }
        }
      });
      var findLastIndex = _curry2(function findLastIndex(fn, list) {
        var idx = list.length;
        while (idx--) {
          if (fn(list[idx])) {
            return idx;
          }
        }
        return -1;
      });
      var forEach = _curry2(_forEach);
      var forEachIndexed = _curry2(function forEachIndexed(fn, list) {
        var idx = -1,
            len = list.length;
        while (++idx < len) {
          fn(list[idx], idx, list);
        }
        return list;
      });
      var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = -1,
            len = pairs.length,
            out = {};
        while (++idx < len) {
          if (_isArray(pairs[idx]) && pairs[idx].length) {
            out[pairs[idx][0]] = pairs[idx][1];
          }
        }
        return out;
      });
      var gt = _curry2(_gt);
      var gte = _curry2(function gte(a, b) {
        return a >= b;
      });
      var has = _curry2(_has);
      var hasIn = _curry2(function(prop, obj) {
        return prop in obj;
      });
      var identity = _curry1(function identity(x) {
        return x;
      });
      var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return function _ifElse() {
          return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        };
      });
      var inc = add(1);
      var indexOf = _curry2(function indexOf(target, list) {
        return _indexOf(list, target);
      });
      var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
      });
      var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
      });
      var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
          return true;
        }
        if (!x) {
          return false;
        }
        if (typeof x !== 'object') {
          return false;
        }
        if (x instanceof String) {
          return false;
        }
        if (x.nodeType === 1) {
          return !!x.length;
        }
        if (x.length === 0) {
          return true;
        }
        if (x.length > 0) {
          return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
      });
      var isEmpty = _curry1(function isEmpty(list) {
        return Object(list).length === 0;
      });
      var isNil = _curry1(function isNil(x) {
        return x == null;
      });
      var isSet = _curry1(function isSet(list) {
        var len = list.length;
        var idx = -1;
        while (++idx < len) {
          if (_indexOf(list, list[idx], idx + 1) >= 0) {
            return false;
          }
        }
        return true;
      });
      var keysIn = _curry1(function keysIn(obj) {
        var prop,
            ks = [];
        for (prop in obj) {
          ks[ks.length] = prop;
        }
        return ks;
      });
      var lastIndexOf = _curry2(function lastIndexOf(target, list) {
        return _lastIndexOf(list, target);
      });
      var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
      });
      var lens = _curry2(function lens(get, set) {
        var lns = function(a) {
          return get(a);
        };
        lns.set = _curry2(set);
        lns.map = _curry2(function(fn, a) {
          return set(fn(get(a)), a);
        });
        return lns;
      });
      var lensOn = _curry3(function lensOn(get, set, obj) {
        var lns = function() {
          return get(obj);
        };
        lns.set = set;
        lns.map = function(fn) {
          return set(fn(get(obj)));
        };
        return lns;
      });
      var lt = _curry2(_lt);
      var lte = _curry2(function lte(a, b) {
        return a <= b;
      });
      var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = -1,
            len = list.length,
            result = [],
            tuple = [acc];
        while (++idx < len) {
          tuple = fn(tuple[0], list[idx]);
          result[idx] = tuple[1];
        }
        return [tuple[0], result];
      });
      var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length,
            result = [],
            tuple = [acc];
        while (idx--) {
          tuple = fn(tuple[0], list[idx]);
          result[idx] = tuple[1];
        }
        return [tuple[0], result];
      });
      var mapIndexed = _curry2(function mapIndexed(fn, list) {
        var idx = -1,
            len = list.length,
            result = [];
        while (++idx < len) {
          result[idx] = fn(list[idx], idx, list);
        }
        return result;
      });
      var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
          return NaN;
        }
        if (!_isInteger(p) || p < 1) {
          return NaN;
        }
        return (m % p + p) % p;
      });
      var maxBy = _curry2(_createMaxMinBy(_gt));
      var memoize = function() {
        var repr = function(x) {
          return x + '::' + Object.prototype.toString.call(x);
        };
        var serialize = function(args) {
          return args.length + ':{' + _map(repr, args).join(',') + '}';
        };
        return _curry1(function memoize(fn) {
          var cache = {};
          return function() {
            var key = serialize(arguments);
            if (!_has(key, cache)) {
              cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
          };
        });
      }();
      var minBy = _curry2(_createMaxMinBy(_lt));
      var modulo = _curry2(function modulo(a, b) {
        return a % b;
      });
      var multiply = _curry2(_multiply);
      var nAry = _curry2(function(n, fn) {
        switch (n) {
          case 0:
            return function() {
              return fn.call(this);
            };
          case 1:
            return function(a0) {
              return fn.call(this, a0);
            };
          case 2:
            return function(a0, a1) {
              return fn.call(this, a0, a1);
            };
          case 3:
            return function(a0, a1, a2) {
              return fn.call(this, a0, a1, a2);
            };
          case 4:
            return function(a0, a1, a2, a3) {
              return fn.call(this, a0, a1, a2, a3);
            };
          case 5:
            return function(a0, a1, a2, a3, a4) {
              return fn.call(this, a0, a1, a2, a3, a4);
            };
          case 6:
            return function(a0, a1, a2, a3, a4, a5) {
              return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
          case 7:
            return function(a0, a1, a2, a3, a4, a5, a6) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
          case 8:
            return function(a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
          case 9:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
          case 10:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
          default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
      });
      var negate = _curry1(function negate(n) {
        return -n;
      });
      var not = _curry1(function not(f) {
        return function() {
          return !f.apply(this, arguments);
        };
      });
      var nth = _curry2(_nth);
      var nthArg = _curry1(function nthArg(n) {
        return function() {
          return _nth(n, arguments);
        };
      });
      var of = _curry1(function of(x) {
        return [x];
      });
      var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
          if (_indexOf(names, prop) < 0) {
            result[prop] = obj[prop];
          }
        }
        return result;
      });
      var once = _curry1(function once(fn) {
        var called = false,
            result;
        return function() {
          if (called) {
            return result;
          }
          called = true;
          result = fn.apply(this, arguments);
          return result;
        };
      });
      var or = _curry2(function or(f, g) {
        return function _or() {
          return f.apply(this, arguments) || g.apply(this, arguments);
        };
      });
      var partition = _curry2(function partition(pred, list) {
        return _reduce(function(acc, elt) {
          var xs = acc[pred(elt) ? 0 : 1];
          xs[xs.length] = elt;
          return acc;
        }, [[], []], list);
      });
      var path = _curry2(_path);
      var pathEq = _curry3(function pathEq(path, val, obj) {
        return _path(path, obj) === val;
      });
      var pick = _curry2(function pick(names, obj) {
        var result = {};
        for (var prop in obj) {
          if (_indexOf(names, prop) >= 0) {
            result[prop] = obj[prop];
          }
        }
        return result;
      });
      var pickAll = _curry2(_pickAll);
      var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
          if (test(obj[prop], prop, obj)) {
            result[prop] = obj[prop];
          }
        }
        return result;
      });
      var prepend = _curry2(_prepend);
      var prop = _curry2(function prop(p, obj) {
        return obj[p];
      });
      var propEq = _curry3(function propEq(name, val, obj) {
        return obj[name] === val;
      });
      var propOr = _curry3(function propOr(val, p, obj) {
        return _has(p, obj) ? obj[p] : val;
      });
      var props = _curry2(function props(ps, obj) {
        var len = ps.length,
            out = [],
            idx = -1;
        while (++idx < len) {
          out[idx] = obj[ps[idx]];
        }
        return out;
      });
      var range = _curry2(function range(from, to) {
        if (from >= to) {
          return [];
        }
        var idx = 0,
            result = [];
        while (from < to) {
          result[idx] = from++;
          idx += 1;
        }
        return result;
      });
      var reduce = _curry3(_reduce);
      var reduceIndexed = _curry3(function reduceIndexed(fn, acc, list) {
        var idx = -1,
            len = list.length;
        while (++idx < len) {
          acc = fn(acc, list[idx], idx, list);
        }
        return acc;
      });
      var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length;
        while (idx--) {
          acc = fn(acc, list[idx]);
        }
        return acc;
      });
      var reduceRightIndexed = _curry3(function reduceRightIndexed(fn, acc, list) {
        var idx = list.length;
        while (idx--) {
          acc = fn(acc, list[idx], idx, list);
        }
        return acc;
      });
      var rejectIndexed = _curry2(function rejectIndexed(fn, list) {
        return _filterIndexed(not(fn), list);
      });
      var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
      });
      var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
      });
      var reverse = _curry1(function reverse(list) {
        return _slice(list).reverse();
      });
      var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0,
            len = list.length + 1,
            result = [acc];
        while (++idx < len) {
          acc = fn(acc, list[idx - 1]);
          result[idx] = acc;
        }
        return result;
      });
      var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function(a, b) {
          var aa = fn(a);
          var bb = fn(b);
          return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
      });
      var strIndexOf = _curry2(function strIndexOf(c, str) {
        return str.indexOf(c);
      });
      var strLastIndexOf = _curry2(function(c, str) {
        return str.lastIndexOf(c);
      });
      var subtract = _curry2(function subtract(a, b) {
        return a - b;
      });
      var sum = reduce(_add, 0);
      var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
      });
      var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var list = new Array(len);
        var idx = 0;
        while (idx < len) {
          list[idx] = fn(idx);
          idx += 1;
        }
        return list;
      });
      var toPairsIn = _curry1(_pairWith(keysIn));
      var trim = function() {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
          return _curry1(function trim(str) {
            var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
            var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
            return str.replace(beginRx, '').replace(endRx, '');
          });
        } else {
          return _curry1(function trim(str) {
            return str.trim();
          });
        }
      }();
      var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
      });
      var unapply = _curry1(function unapply(fn) {
        return function() {
          return fn(_slice(arguments));
        };
      });
      var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
      });
      var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
          result[result.length] = pair[0];
          pair = fn(pair[1]);
        }
        return result;
      });
      var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = -1,
            len = list.length;
        var result = [],
            item;
        while (++idx < len) {
          item = list[idx];
          if (!_containsWith(pred, item, result)) {
            result[result.length] = item;
          }
        }
        return result;
      });
      var valuesIn = _curry1(function valuesIn(obj) {
        var prop,
            vs = [];
        for (prop in obj) {
          vs[vs.length] = obj[prop];
        }
        return vs;
      });
      var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function() {
          return wrapper.apply(this, _concat([fn], arguments));
        });
      });
      var xprod = _curry2(function xprod(a, b) {
        var idx = -1;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (++idx < ilen) {
          j = -1;
          while (++j < jlen) {
            result[result.length] = [a[idx], b[j]];
          }
        }
        return result;
      });
      var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = -1;
        var len = Math.min(a.length, b.length);
        while (++idx < len) {
          rv[idx] = [a[idx], b[idx]];
        }
        return rv;
      });
      var zipObj = _curry2(function zipObj(keys, values) {
        var idx = -1,
            len = keys.length,
            out = {};
        while (++idx < len) {
          out[keys[idx]] = values[idx];
        }
        return out;
      });
      var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [],
            idx = -1,
            len = Math.min(a.length, b.length);
        while (++idx < len) {
          rv[idx] = fn(a[idx], b[idx]);
        }
        return rv;
      });
      var F = always(false);
      var I = identity;
      var T = always(true);
      var _append = function _append(el, list) {
        return _concat(list, [el]);
      };
      var _assocPath = function _assocPath(path, val, obj) {
        switch (path.length) {
          case 0:
            return obj;
          case 1:
            return _assoc(path[0], val, obj);
          default:
            return _assoc(path[0], _assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
      };
      var _baseCopy = function _baseCopy(value, refFrom, refTo) {
        var copy = function copy(copiedValue) {
          var len = refFrom.length;
          var idx = -1;
          while (++idx < len) {
            if (value === refFrom[idx]) {
              return refTo[idx];
            }
          }
          refFrom[idx + 1] = value;
          refTo[idx + 1] = copiedValue;
          for (var key in value) {
            copiedValue[key] = _baseCopy(value[key], refFrom, refTo);
          }
          return copiedValue;
        };
        switch (type(value)) {
          case 'Object':
            return copy({});
          case 'Array':
            return copy([]);
          case 'Date':
            return new Date(value);
          default:
            return value;
        }
      };
      var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function() {
          var length = arguments.length;
          if (length === 0) {
            return fn();
          }
          var obj = arguments[length - 1];
          return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
      };
      var _composeP = function _composeP(f, g) {
        return function() {
          var context = this;
          var value = g.apply(this, arguments);
          if (_isThenable(value)) {
            return value.then(function(result) {
              return f.call(context, result);
            });
          } else {
            return f.call(this, value);
          }
        };
      };
      var _contains = function _contains(a, list) {
        return _indexOf(list, a) >= 0;
      };
      var _createComposer = function _createComposer(composeFunction) {
        return function() {
          var idx = arguments.length - 1;
          var fn = arguments[idx];
          var length = fn.length;
          while (idx--) {
            fn = composeFunction(arguments[idx], fn);
          }
          return arity(length, fn);
        };
      };
      var _createMaxMin = function _createMaxMin(comparator, initialVal) {
        return _curry1(function(list) {
          var idx = -1,
              winner = initialVal,
              computed;
          while (++idx < list.length) {
            computed = +list[idx];
            if (comparator(computed, winner)) {
              winner = computed;
            }
          }
          return winner;
        });
      };
      var _createPartialApplicator = function _createPartialApplicator(concat) {
        return function(fn) {
          var args = _slice(arguments, 1);
          return arity(Math.max(0, fn.length - args.length), function() {
            return fn.apply(this, concat(args, arguments));
          });
        };
      };
      var _dissocPath = function _dissocPath(path, obj) {
        switch (path.length) {
          case 0:
            return obj;
          case 1:
            return _dissoc(path[0], obj);
          default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : _assoc(head, _dissocPath(tail, obj[head]), obj);
        }
      };
      var _hasMethod = function _hasMethod(methodName, obj) {
        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
      };
      var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
          var value,
              result = [],
              idx = -1,
              j,
              ilen = list.length,
              jlen;
          while (++idx < ilen) {
            if (isArrayLike(list[idx])) {
              value = recursive ? flatt(list[idx]) : list[idx];
              j = -1;
              jlen = value.length;
              while (++j < jlen) {
                result[result.length] = value[j];
              }
            } else {
              result[result.length] = list[idx];
            }
          }
          return result;
        };
      };
      var _pluck = function _pluck(p, list) {
        return _map(prop(p), list);
      };
      var append = _curry2(_append);
      var assocPath = _curry3(_assocPath);
      var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
      });
      var clone = _curry1(function clone(value) {
        return _baseCopy(value, [], []);
      });
      var compose = _createComposer(_compose);
      var composeP = _createComposer(_composeP);
      var concat = _curry2(function(set1, set2) {
        if (_isArray(set2)) {
          return _concat(set1, set2);
        } else if (_hasMethod('concat', set1)) {
          return set1.concat(set2);
        } else {
          throw new TypeError('can\'t concat ' + typeof set1);
        }
      });
      var contains = _curry2(_contains);
      var converge = curryN(3, function(after) {
        var fns = _slice(arguments, 1);
        return function() {
          var args = arguments;
          return after.apply(this, _map(function(fn) {
            return fn.apply(this, args);
          }, fns));
        };
      });
      var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
      });
      var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = -1;
        var firstLen = first.length;
        while (++idx < firstLen) {
          if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
            out[out.length] = first[idx];
          }
        }
        return out;
      });
      var dissocPath = _curry2(_dissocPath);
      var drop = _curry2(_checkForMethod('drop', function drop(n, list) {
        return n < list.length ? _slice(list, n) : [];
      }));
      var empty = _curry1(function empty(x) {
        return _hasMethod('empty', x) ? x.empty() : [];
      });
      var filter = _curry2(_checkForMethod('filter', _filter));
      var flatten = _curry1(_makeFlat(true));
      var flip = _curry1(function flip(fn) {
        return curry(function(a, b) {
          var args = _slice(arguments);
          args[0] = b;
          args[1] = a;
          return fn.apply(this, args);
        });
      });
      var func = curry(function func(funcName, obj) {
        return obj[funcName].apply(obj, _slice(arguments, 2));
      });
      var functionsIn = _curry1(_functionsWith(keysIn));
      var get = prop;
      var groupBy = _curry2(function groupBy(fn, list) {
        return _reduce(function(acc, elt) {
          var key = fn(elt);
          acc[key] = _append(elt, acc[key] || (acc[key] = []));
          return acc;
        }, {}, list);
      });
      var head = nth(0);
      var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_append(elt, _slice(list, 0, idx)), _slice(list, idx));
      });
      var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var results = [],
            idx = -1;
        while (++idx < list1.length) {
          if (_containsWith(pred, list1[idx], list2)) {
            results[results.length] = list1[idx];
          }
        }
        return uniqWith(pred, results);
      });
      var invoker = curry(function invoker(arity, method) {
        var initialArgs = _slice(arguments, 2);
        var len = arity - initialArgs.length;
        return curryN(len + 1, function() {
          var target = arguments[len];
          var args = initialArgs.concat(_slice(arguments, 0, len));
          return target[method].apply(target, args);
        });
      });
      var join = invoker(1, 'join');
      var keys = function() {
        var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
        var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
        return _curry1(function keys(obj) {
          if (Object(obj) !== obj) {
            return [];
          }
          if (Object.keys) {
            return Object.keys(obj);
          }
          var prop,
              ks = [],
              nIdx;
          for (prop in obj) {
            if (_has(prop, obj)) {
              ks[ks.length] = prop;
            }
          }
          if (hasEnumBug) {
            nIdx = nonEnumerableProps.length;
            while (nIdx--) {
              prop = nonEnumerableProps[nIdx];
              if (_has(prop, obj) && !_contains(prop, ks)) {
                ks[ks.length] = prop;
              }
            }
          }
          return ks;
        });
      }();
      var last = nth(-1);
      var map = _curry2(_checkForMethod('map', _map));
      var mapObj = _curry2(function mapObject(fn, obj) {
        return _reduce(function(acc, key) {
          acc[key] = fn(obj[key]);
          return acc;
        }, {}, keys(obj));
      });
      var mapObjIndexed = _curry2(function mapObjectIndexed(fn, obj) {
        return _reduce(function(acc, key) {
          acc[key] = fn(obj[key], key, obj);
          return acc;
        }, {}, keys(obj));
      });
      var match = invoker(1, 'match');
      var max = _createMaxMin(_gt, -Infinity);
      var min = _createMaxMin(_lt, Infinity);
      var partial = curry(_createPartialApplicator(_concat));
      var partialRight = curry(_createPartialApplicator(flip(_concat)));
      var pipe = function pipe() {
        return compose.apply(this, reverse(arguments));
      };
      var pipeP = function pipeP() {
        return composeP.apply(this, reverse(arguments));
      };
      var pluck = _curry2(_pluck);
      var prependTo = flip(_prepend);
      var product = reduce(_multiply, 1);
      var propOf = flip(prop);
      var reject = _curry2(function reject(fn, list) {
        return filter(not(fn), list);
      });
      var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
      });
      var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, xs) {
        return Array.prototype.slice.call(xs, fromIndex, toIndex);
      }));
      var sort = _curry2(function sort(comparator, list) {
        return clone(list).sort(comparator);
      });
      var split = invoker(1, 'split');
      var substring = invoker(2, 'substring');
      var substringFrom = flip(substring)(void 0);
      var substringTo = substring(0);
      var tail = _checkForMethod('tail', function(list) {
        return _slice(list, 1);
      });
      var take = _curry2(_checkForMethod('take', function(n, list) {
        return _slice(list, 0, Math.min(n, list.length));
      }));
      var takeWhile = _curry2(_checkForMethod('takeWhile', function(fn, list) {
        var idx = -1,
            len = list.length;
        while (++idx < len && fn(list[idx])) {}
        return _slice(list, 0, idx);
      }));
      var toLower = invoker(0, 'toLowerCase');
      var toPairs = _curry1(_pairWith(keys));
      var toUpper = invoker(0, 'toUpperCase');
      var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
      });
      var uniq = _curry1(function uniq(list) {
        var idx = -1,
            len = list.length;
        var result = [],
            item;
        while (++idx < len) {
          item = list[idx];
          if (!_contains(item, result)) {
            result[result.length] = item;
          }
        }
        return result;
      });
      var unnest = _curry1(_makeFlat(false));
      var useWith = curry(function useWith(fn) {
        var transformers = _slice(arguments, 1);
        var tlen = transformers.length;
        return curry(arity(tlen, function() {
          var args = [],
              idx = -1;
          while (++idx < tlen) {
            args[idx] = transformers[idx](arguments[idx]);
          }
          return fn.apply(this, args.concat(_slice(arguments, tlen)));
        }));
      });
      var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = -1;
        while (++idx < len) {
          vals[idx] = obj[props[idx]];
        }
        return vals;
      });
      var where = _curry2(function where(spec, testObj) {
        var parsedSpec = groupBy(function(key) {
          return typeof spec[key] === 'function' ? 'fn' : 'obj';
        }, keys(spec));
        return _satisfiesSpec(spec, parsedSpec, testObj);
      });
      var _ap = function _ap(fns, vs) {
        return _hasMethod('ap', fns) ? fns.ap(vs) : _reduce(function(acc, fn) {
          return _concat(acc, _map(fn, vs));
        }, [], fns);
      };
      var _eqDeep = function _eqDeep(a, b, stackA, stackB) {
        var typeA = type(a);
        if (typeA !== type(b)) {
          return false;
        }
        if (eq(a, b)) {
          return true;
        }
        if (typeA == 'RegExp') {
          return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;
        }
        if (Object(a) === a) {
          if (typeA === 'Date' && a.getTime() != b.getTime()) {
            return false;
          }
          var keysA = keys(a);
          if (keysA.length !== keys(b).length) {
            return false;
          }
          var idx = stackA.length;
          while (idx--) {
            if (stackA[idx] === a) {
              return stackB[idx] === b;
            }
          }
          stackA[stackA.length] = a;
          stackB[stackB.length] = b;
          idx = keysA.length;
          while (idx--) {
            var key = keysA[idx];
            if (!_has(key, b) || !_eqDeep(b[key], a[key], stackA, stackB)) {
              return false;
            }
          }
          stackA.pop();
          stackB.pop();
          return true;
        }
        return false;
      };
      var _extend = function _extend(destination, other) {
        var props = keys(other),
            idx = -1,
            length = props.length;
        while (++idx < length) {
          destination[props[idx]] = other[props[idx]];
        }
        return destination;
      };
      var _predicateWrap = function _predicateWrap(predPicker) {
        return function(preds) {
          var predIterator = function() {
            var args = arguments;
            return predPicker(function(predicate) {
              return predicate.apply(null, args);
            }, preds);
          };
          return arguments.length > 1 ? predIterator.apply(null, _slice(arguments, 1)) : arity(max(_pluck('length', preds)), predIterator);
        };
      };
      var allPass = curry(_predicateWrap(_all));
      var anyPass = curry(_predicateWrap(_any));
      var ap = _curry2(_ap);
      var appendTo = flip(_append);
      var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
      });
      var chain = _curry2(_checkForMethod('chain', function chain(f, list) {
        return unnest(_map(f, list));
      }));
      var charAt = invoker(1, 'charAt');
      var charCodeAt = invoker(1, 'charCodeAt');
      var commuteMap = _curry3(function commuteMap(fn, of, list) {
        function consF(acc, ftor) {
          return _ap(_map(append, fn(ftor)), acc);
        }
        return _reduce(consF, of([]), list);
      });
      var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
          throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
          return function() {
            return new Fn();
          };
        }
        return curry(nAry(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
          switch (arguments.length) {
            case 1:
              return new Fn($0);
            case 2:
              return new Fn($0, $1);
            case 3:
              return new Fn($0, $1, $2);
            case 4:
              return new Fn($0, $1, $2, $3);
            case 5:
              return new Fn($0, $1, $2, $3, $4);
            case 6:
              return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
              return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
          }
        }));
      });
      var eqDeep = _curry2(function eqDeep(a, b) {
        return _eqDeep(a, b, [], []);
      });
      var evolve = _curry2(function evolve(transformations, object) {
        return _extend(_extend({}, object), mapObjIndexed(function(fn, key) {
          return fn(object[key]);
        }, transformations));
      });
      var functions = _curry1(_functionsWith(keys));
      var init = slice(0, -1);
      var installTo = _curry1(function(obj) {
        return _extend(obj, R);
      });
      var intersection = _curry2(function intersection(list1, list2) {
        return uniq(_filter(flip(_contains)(list1), list2));
      });
      var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = -1;
        var out = {};
        while (++idx < len) {
          var key = props[idx];
          var val = obj[key];
          var list = _has(val, out) ? out[val] : out[val] = [];
          list[list.length] = key;
        }
        return out;
      });
      var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = -1;
        var out = {};
        while (++idx < len) {
          var key = props[idx];
          out[obj[key]] = key;
        }
        return out;
      });
      var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function() {
          return _reduce(_ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
      });
      var merge = _curry2(function merge(a, b) {
        return _extend(_extend({}, a), b);
      });
      var mergeAll = _curry1(function mergeAll(list) {
        return reduce(merge, {}, list);
      });
      var project = useWith(_map, pickAll, identity);
      var union = _curry2(compose(uniq, _concat));
      var commute = commuteMap(map(identity));
      var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
      });
      var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
      });
      var R = {
        F: F,
        I: I,
        T: T,
        __: __,
        add: add,
        all: all,
        allPass: allPass,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        append: append,
        appendTo: appendTo,
        apply: apply,
        arity: arity,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        call: call,
        chain: chain,
        charAt: charAt,
        charCodeAt: charCodeAt,
        clone: clone,
        commute: commute,
        commuteMap: commuteMap,
        comparator: comparator,
        compose: compose,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        containsWith: containsWith,
        converge: converge,
        countBy: countBy,
        createMapEntry: createMapEntry,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropWhile: dropWhile,
        empty: empty,
        eq: eq,
        eqDeep: eqDeep,
        eqProps: eqProps,
        evolve: evolve,
        filter: filter,
        filterIndexed: filterIndexed,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        forEachIndexed: forEachIndexed,
        fromPairs: fromPairs,
        func: func,
        functions: functions,
        functionsIn: functionsIn,
        get: get,
        groupBy: groupBy,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        installTo: installTo,
        intersection: intersection,
        intersectionWith: intersectionWith,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        isSet: isSet,
        join: join,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensOn: lensOn,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapIndexed: mapIndexed,
        mapObj: mapObj,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        not: not,
        nth: nth,
        nthArg: nthArg,
        of: of,
        omit: omit,
        once: once,
        or: or,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        prependTo: prependTo,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propOf: propOf,
        propOr: propOr,
        props: props,
        range: range,
        reduce: reduce,
        reduceIndexed: reduceIndexed,
        reduceRight: reduceRight,
        reduceRightIndexed: reduceRightIndexed,
        reject: reject,
        rejectIndexed: rejectIndexed,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        strIndexOf: strIndexOf,
        strLastIndexOf: strLastIndexOf,
        substring: substring,
        substringFrom: substringFrom,
        substringTo: substringTo,
        subtract: subtract,
        sum: sum,
        tail: tail,
        take: take,
        takeWhile: takeWhile,
        tap: tap,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toUpper: toUpper,
        trim: trim,
        type: type,
        unapply: unapply,
        unary: unary,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqWith: uniqWith,
        unnest: unnest,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        where: where,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
      };
      if (typeof exports === 'object') {
        module.exports = R;
      } else if (typeof define === 'function' && define.amd) {
        define(function() {
          return R;
        });
      } else {
        this.R = R;
      }
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@0.9.17/library/fn/object/assign.js", ["npm:core-js@0.9.17/library/modules/es6.object.assign.js", "npm:core-js@0.9.17/library/modules/$.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.17/library/modules/es6.object.assign.js");
  module.exports = require("npm:core-js@0.9.17/library/modules/$.js").core.Object.assign;
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    pki.pemToDer = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert PEM to DER; PEM is encrypted.');
      }
      return forge.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'PRIVATE KEY' && msg.type !== 'RSA PRIVATE KEY') {
        var error = new Error('Could not convert private key from PEM; PEM ' + 'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert private key from PEM; PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key, maxline) {
      var msg = {
        type: 'RSA PRIVATE KEY',
        body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.privateKeyInfoToPem = function(pki, maxline) {
      var msg = {
        type: 'PRIVATE KEY',
        body: asn1.toDer(pki).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
  }
  var name = 'pki';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/pki.js", ["require", "module", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/oids.js", "npm:node-forge@0.6.30/js/pbe.js", "npm:node-forge@0.6.30/js/pem.js", "npm:node-forge@0.6.30/js/pbkdf2.js", "npm:node-forge@0.6.30/js/pkcs12.js", "npm:node-forge@0.6.30/js/pss.js", "npm:node-forge@0.6.30/js/rsa.js", "npm:node-forge@0.6.30/js/util.js", "npm:node-forge@0.6.30/js/x509.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
System.registerDynamic("npm:baobab@1.1.1/src/baobab.js", ["npm:baobab@1.1.1/src/cursor.js", "npm:emmett@3.0.1.js", "npm:baobab@1.1.1/src/facet.js", "npm:baobab@1.1.1/src/helpers.js", "npm:baobab@1.1.1/src/update.js", "npm:baobab@1.1.1/src/merge.js", "npm:baobab@1.1.1/defaults.js", "npm:baobab@1.1.1/src/type.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Cursor = require("npm:baobab@1.1.1/src/cursor.js"),
      EventEmitter = require("npm:emmett@3.0.1.js"),
      Facet = require("npm:baobab@1.1.1/src/facet.js"),
      helpers = require("npm:baobab@1.1.1/src/helpers.js"),
      update = require("npm:baobab@1.1.1/src/update.js"),
      merge = require("npm:baobab@1.1.1/src/merge.js"),
      defaults = require("npm:baobab@1.1.1/defaults.js"),
      type = require("npm:baobab@1.1.1/src/type.js");
  var uniqid = (function() {
    var i = 0;
    return function() {
      return i++;
    };
  })();
  function Baobab(initialData, opts) {
    if (arguments.length < 1)
      initialData = {};
    if (!(this instanceof Baobab))
      return new Baobab(initialData, opts);
    if (!type.Object(initialData) && !type.Array(initialData))
      throw Error('Baobab: invalid data.');
    EventEmitter.call(this);
    this.options = helpers.shallowMerge(defaults, opts);
    this._transaction = {};
    this._future = undefined;
    this._cursors = {};
    this._identity = '[object Baobab]';
    this.log = [];
    this.previousData = null;
    this.data = initialData;
    this.root = this.select();
    this.facets = {};
    if (this.options.immutable)
      helpers.deepFreeze(this.data);
    function bootstrap(name) {
      this[name] = function() {
        var r = this.root[name].apply(this.root, arguments);
        return r instanceof Cursor ? this : r;
      };
    }
    ['apply', 'chain', 'get', 'merge', 'push', 'set', 'splice', 'unset', 'unshift', 'update'].forEach(bootstrap.bind(this));
    if (!type.Object(this.options.facets))
      throw Error('Baobab: invalid facets.');
    for (var k in this.options.facets)
      this.addFacet(k, this.options.facets[k]);
  }
  helpers.inherits(Baobab, EventEmitter);
  Baobab.prototype.addFacet = function(name, definition, args) {
    this.facets[name] = this.createFacet(definition, args);
    return this;
  };
  Baobab.prototype.createFacet = function(definition, args) {
    return new Facet(this, definition, args);
  };
  Baobab.prototype.select = function(path) {
    path = path || [];
    if (arguments.length > 1)
      path = helpers.arrayOf(arguments);
    if (!type.Path(path))
      throw Error('Baobab.select: invalid path.');
    path = [].concat(path);
    var hash = path.map(function(step) {
      if (type.Function(step) || type.Object(step))
        return '$' + uniqid() + '$';
      else
        return step;
    }).join('||');
    var cursor;
    if (!this._cursors[hash]) {
      cursor = new Cursor(this, path, hash);
      this._cursors[hash] = cursor;
    } else {
      cursor = this._cursors[hash];
    }
    this.emit('select', {
      path: path,
      cursor: cursor
    });
    return cursor;
  };
  Baobab.prototype.stack = function(spec, skipMerge) {
    var self = this;
    if (!type.Object(spec))
      throw Error('Baobab.update: wrong specification.');
    if (!this.previousData)
      this.previousData = this.data;
    if (this.options.syncwrite) {
      var result = update(this.data, spec, this.options);
      this.data = result.data;
      this.log = [].concat(this.log).concat(result.log);
    } else {
      this._transaction = (skipMerge && !Object.keys(this._transaction).length) ? spec : merge(this._transaction, spec);
    }
    if (!this.options.autoCommit)
      return this;
    if (!this.options.asynchronous)
      return this.commit();
    if (!this._future)
      this._future = setTimeout(self.commit.bind(self, null), 0);
    return this;
  };
  Baobab.prototype.commit = function() {
    if (this._future)
      this._future = clearTimeout(this._future);
    if (!this.options.syncwrite) {
      var result = update(this.data, this._transaction, this.options);
      this.data = result.data;
      this.log = result.log;
    }
    this._transaction = {};
    var validate = this.options.validate,
        behavior = this.options.validationBehavior;
    if (typeof validate === 'function') {
      var error = validate.call(this, this.previousData, this.data, this.log);
      if (error instanceof Error) {
        this.emit('invalid', {error: error});
        if (behavior === 'rollback') {
          this.data = this.previousData;
          return this;
        }
      }
    }
    this.emit('update', {
      log: this.log,
      previousData: this.previousData,
      data: this.data
    });
    this.log = [];
    this.previousData = null;
    return this;
  };
  Baobab.prototype.release = function() {
    var k;
    delete this.data;
    delete this._transaction;
    for (k in this._cursors)
      this._cursors[k].release();
    delete this._cursors;
    for (k in this.facets)
      this.facets[k].release();
    delete this.facets;
    this.kill();
  };
  Baobab.prototype.toJSON = function() {
    return this.get();
  };
  Baobab.prototype.toString = function() {
    return this._identity;
  };
  module.exports = Baobab;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ramda@0.11.0.js", ["npm:ramda@0.11.0/dist/ramda.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:ramda@0.11.0/dist/ramda.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.5.8/core-js/object/assign.js", ["npm:core-js@0.9.17/library/fn/object/assign.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.17/library/fn/object/assign.js"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var prf_TLS1 = function(secret, label, seed, length) {
      var rval = forge.util.createBuffer();
      var idx = (secret.length >> 1);
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai = forge.util.createBuffer();
      var hmac = forge.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length / 16);
      var sha1itr = Math.ceil(length / 20);
      hmac.start('MD5', s1);
      var md5bytes = forge.util.createBuffer();
      ai.putBytes(seed);
      for (var i = 0; i < md5itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        md5bytes.putBuffer(hmac.digest());
      }
      hmac.start('SHA1', s2);
      var sha1bytes = forge.util.createBuffer();
      ai.clear();
      ai.putBytes(seed);
      for (var i = 0; i < sha1itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        sha1bytes.putBuffer(hmac.digest());
      }
      rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length));
      return rval;
    };
    var prf_sha256 = function(secret, label, seed, length) {};
    var hmac_sha1 = function(key, seqNum, record) {
      var hmac = forge.hmac.create();
      hmac.start('SHA1', key);
      var b = forge.util.createBuffer();
      b.putInt32(seqNum[0]);
      b.putInt32(seqNum[1]);
      b.putByte(record.type);
      b.putByte(record.version.major);
      b.putByte(record.version.minor);
      b.putInt16(record.length);
      b.putBytes(record.fragment.bytes());
      hmac.update(b.getBytes());
      return hmac.digest().getBytes();
    };
    var deflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.deflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {}
      return rval;
    };
    var inflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.inflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {}
      return rval;
    };
    var readVector = function(b, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b.getByte();
          break;
        case 2:
          len = b.getInt16();
          break;
        case 3:
          len = b.getInt24();
          break;
        case 4:
          len = b.getInt32();
          break;
      }
      return forge.util.createBuffer(b.getBytes(len));
    };
    var writeVector = function(b, lenBytes, v) {
      b.putInt(v.length(), lenBytes << 3);
      b.putBuffer(v);
    };
    var tls = {};
    tls.Versions = {
      TLS_1_0: {
        major: 3,
        minor: 1
      },
      TLS_1_1: {
        major: 3,
        minor: 2
      },
      TLS_1_2: {
        major: 3,
        minor: 3
      }
    };
    tls.SupportedVersions = [tls.Versions.TLS_1_1, tls.Versions.TLS_1_0];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {tls_prf_sha256: 0};
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key in tls.CipherSuites) {
        var cs = tls.CipherSuites[key];
        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c, record) {
      var ignore = (!c.open && c.entity === tls.ConnectionEnd.client);
      if (!ignore) {
        c.error(c, {
          message: 'Unexpected message. Received TLS record out of order.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c, record, length) {
      if (!c.handshaking && c.handshakes > 0) {
        tls.queue(c, tls.createAlert(c, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c);
      }
      c.process();
    };
    tls.parseHelloMessage = function(c, record, length) {
      var msg = null;
      var client = (c.entity === tls.ConnectionEnd.client);
      if (length < 38) {
        c.error(c, {
          message: client ? 'Invalid ServerHello message. Message too short.' : 'Invalid ClientHello message. Message too short.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b = record.fragment;
        var remaining = b.length();
        msg = {
          version: {
            major: b.getByte(),
            minor: b.getByte()
          },
          random: forge.util.createBuffer(b.getBytes(32)),
          session_id: readVector(b, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b.getBytes(2);
          msg.compression_method = b.getByte();
        } else {
          msg.cipher_suites = readVector(b, 2);
          msg.compression_methods = readVector(b, 1);
        }
        remaining = length - (remaining - b.length());
        if (remaining > 0) {
          var exts = readVector(b, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i = 0; i < msg.extensions.length; ++i) {
              var ext = msg.extensions[i];
              if (ext.type[0] === 0x00 && ext.type[1] === 0x00) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0x00) {
                    break;
                  }
                  c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());
                }
              }
            }
          }
        }
        if (c.session.version) {
          if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
            return c.error(c, {
              message: 'TLS version change is disallowed during renegotiation.',
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c.session.cipherSuite === null) {
          return c.error(c, {
            message: 'No cipher suites in common.',
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c.session.compressionMethod = msg.compression_method;
        } else {
          c.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c, msg) {
      var client = (c.entity === tls.ConnectionEnd.client);
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c.session.sp = {
        entity: c.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      if (msg.version.minor <= c.version.minor) {
        c.version.minor = msg.version.minor;
      } else {
        return c.error(c, {
          message: 'Incompatible TLS version.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c.session.version = c.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c.session.id) {
        c.expect = SCC;
        c.session.resuming = true;
        c.session.sp.server_random = msg.random.bytes();
      } else {
        c.expect = SCE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.session.id = sessionId;
      c.process();
    };
    tls.handleClientHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c.sessionCache) {
        session = c.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = '';
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = '';
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge.random.getBytes(32);
      }
      c.session.id = sessionId;
      c.session.clientHelloVersion = msg.version;
      c.session.sp = {};
      if (session) {
        c.version = c.session.version = session.version;
        c.session.sp = session.sp;
      } else {
        var version;
        for (var i = 1; i < tls.SupportedVersions.length; ++i) {
          version = tls.SupportedVersions[i];
          if (version.minor <= msg.version.minor) {
            break;
          }
        }
        c.version = {
          major: version.major,
          minor: version.minor
        };
        c.session.version = c.version;
      }
      if (session !== null) {
        c.expect = CCC;
        c.session.resuming = true;
        c.session.sp.client_random = msg.random.bytes();
      } else {
        c.expect = (c.verifyClient !== false) ? CCE : CKE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.open = true;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c)
      }));
      if (c.session.resuming) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      } else {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        }));
        if (!c.fail) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c)
          }));
          if (c.verifyClient !== false) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c)
            }));
          }
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c)
          }));
        }
      }
      tls.flush(c);
      c.process();
    };
    tls.handleCertificate = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: 'Invalid Certificate message. Message too short.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {certificate_list: readVector(b, 3)};
      var cert,
          asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert = readVector(msg.certificate_list, 3);
          asn1 = forge.asn1.fromDer(cert);
          cert = forge.pki.certificateFromAsn1(asn1, true);
          certs.push(cert);
        }
      } catch (ex) {
        return c.error(c, {
          message: 'Could not parse certificate list.',
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = (c.entity === tls.ConnectionEnd.client);
      if ((client || c.verifyClient === true) && certs.length === 0) {
        c.error(c, {
          message: client ? 'No server certificate provided.' : 'No client certificate provided.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c.session.serverCertificate = certs[0];
        } else {
          c.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c, certs)) {
          c.expect = client ? SKE : CKE;
        }
      }
      c.process();
    };
    tls.handleServerKeyExchange = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: 'Invalid key parameters. Only RSA is supported.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c.expect = SCR;
      c.process();
    };
    tls.handleClientKeyExchange = function(c, record, length) {
      if (length < 48) {
        return c.error(c, {
          message: 'Invalid key parameters. Only RSA is supported.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b = record.fragment;
      var msg = {enc_pre_master_secret: readVector(b, 2).getBytes()};
      var privateKey = null;
      if (c.getPrivateKey) {
        try {
          privateKey = c.getPrivateKey(c, c.session.serverCertificate);
          privateKey = forge.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c.error(c, {
            message: 'Could not get private key.',
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c.error(c, {
          message: 'No private key set.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version = c.session.clientHelloVersion;
        if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error('TLS version rollback attack detected.');
        }
      } catch (ex) {
        sp.pre_master_secret = forge.random.getBytes(48);
      }
      c.expect = CCC;
      if (c.session.clientCertificate !== null) {
        c.expect = CCV;
      }
      c.process();
    };
    tls.handleCertificateRequest = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: 'Invalid CertificateRequest. Message too short.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {
        certificate_types: readVector(b, 1),
        certificate_authorities: readVector(b, 2)
      };
      c.session.certificateRequest = msg;
      c.expect = SHD;
      c.process();
    };
    tls.handleCertificateVerify = function(c, record, length) {
      if (length < 2) {
        return c.error(c, {
          message: 'Invalid CertificateVerify. Message too short.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var msg = {signature: readVector(b, 2).getBytes()};
      var verify = forge.util.createBuffer();
      verify.putBuffer(c.session.md5.digest());
      verify.putBuffer(c.session.sha1.digest());
      verify = verify.getBytes();
      try {
        var cert = c.session.clientCertificate;
        if (!cert.publicKey.verify(verify, msg.signature, 'NONE')) {
          throw new Error('CertificateVerify signature does not match.');
        }
        c.session.md5.update(msgBytes);
        c.session.sha1.update(msgBytes);
      } catch (ex) {
        return c.error(c, {
          message: 'Bad signature in CertificateVerify.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c.expect = CCC;
      c.process();
    };
    tls.handleServerHelloDone = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: 'Invalid ServerHelloDone message. Invalid length.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c.serverCertificate === null) {
        var error = {
          message: 'No server certificate provided. Not enough security.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c.verify(c, error.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === 'object' && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
            } else if (typeof ret === 'number') {
              error.alert.description = ret;
            }
          }
          return c.error(c, error);
        }
      }
      if (c.session.certificateRequest !== null) {
        record = tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        });
        tls.queue(c, record);
      }
      record = tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c)
      });
      tls.queue(c, record);
      c.expect = SER;
      var callback = function(c, signature) {
        if (c.session.certificateRequest !== null && c.session.clientCertificate !== null) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c, signature)
          }));
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
        c.expect = SCC;
        tls.flush(c);
        c.process();
      };
      if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
        return callback(c, null);
      }
      tls.getClientSignature(c, callback);
    };
    tls.handleChangeCipherSpec = function(c, record) {
      if (record.fragment.getByte() !== 0x01) {
        return c.error(c, {
          message: 'Invalid ChangeCipherSpec message received.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = (c.entity === tls.ConnectionEnd.client);
      if ((c.session.resuming && client) || (!c.session.resuming && !client)) {
        c.state.pending = tls.createConnectionState(c);
      }
      c.state.current.read = c.state.pending.read;
      if ((!c.session.resuming && client) || (c.session.resuming && !client)) {
        c.state.pending = null;
      }
      c.expect = client ? SFI : CFI;
      c.process();
    };
    tls.handleFinished = function(c, record, length) {
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var vd = record.fragment.getBytes();
      b = forge.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = (c.entity === tls.ConnectionEnd.client);
      var label = client ? 'server finished' : 'client finished';
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      if (b.getBytes() !== vd) {
        return c.error(c, {
          message: 'Invalid verify_data in Finished message.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c.session.md5.update(msgBytes);
      c.session.sha1.update(msgBytes);
      if ((c.session.resuming && client) || (!c.session.resuming && !client)) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.current.write = c.state.pending.write;
        c.state.pending = null;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      }
      c.expect = client ? SAD : CAD;
      c.handshaking = false;
      ++c.handshakes;
      c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
      tls.flush(c);
      c.isConnected = true;
      c.connected(c);
      c.process();
    };
    tls.handleAlert = function(c, record) {
      var b = record.fragment;
      var alert = {
        level: b.getByte(),
        description: b.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = 'Connection closed.';
          break;
        case tls.Alert.Description.unexpected_message:
          msg = 'Unexpected message.';
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = 'Bad record MAC.';
          break;
        case tls.Alert.Description.decryption_failed:
          msg = 'Decryption failed.';
          break;
        case tls.Alert.Description.record_overflow:
          msg = 'Record overflow.';
          break;
        case tls.Alert.Description.decompression_failure:
          msg = 'Decompression failed.';
          break;
        case tls.Alert.Description.handshake_failure:
          msg = 'Handshake failure.';
          break;
        case tls.Alert.Description.bad_certificate:
          msg = 'Bad certificate.';
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = 'Unsupported certificate.';
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = 'Certificate revoked.';
          break;
        case tls.Alert.Description.certificate_expired:
          msg = 'Certificate expired.';
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = 'Certificate unknown.';
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = 'Illegal parameter.';
          break;
        case tls.Alert.Description.unknown_ca:
          msg = 'Unknown certificate authority.';
          break;
        case tls.Alert.Description.access_denied:
          msg = 'Access denied.';
          break;
        case tls.Alert.Description.decode_error:
          msg = 'Decode error.';
          break;
        case tls.Alert.Description.decrypt_error:
          msg = 'Decrypt error.';
          break;
        case tls.Alert.Description.export_restriction:
          msg = 'Export restriction.';
          break;
        case tls.Alert.Description.protocol_version:
          msg = 'Unsupported protocol version.';
          break;
        case tls.Alert.Description.insufficient_security:
          msg = 'Insufficient security.';
          break;
        case tls.Alert.Description.internal_error:
          msg = 'Internal error.';
          break;
        case tls.Alert.Description.user_canceled:
          msg = 'User canceled.';
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = 'Renegotiation not supported.';
          break;
        default:
          msg = 'Unknown error.';
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c.close();
      }
      c.error(c, {
        message: msg,
        send: false,
        origin: (c.entity === tls.ConnectionEnd.client) ? 'server' : 'client',
        alert: alert
      });
      c.process();
    };
    tls.handleHandshake = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length = b.getInt24();
      if (length > b.length()) {
        c.fragmented = record;
        record.fragment = forge.util.createBuffer();
        b.read -= 4;
        return c.process();
      }
      c.fragmented = null;
      b.read -= 4;
      var bytes = b.bytes(length + 4);
      b.read += 4;
      if (type in hsTable[c.entity][c.expect]) {
        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
          c.handshaking = true;
          c.session = {
            version: null,
            extensions: {server_name: {serverNameList: []}},
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
        }
        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
          c.session.md5.update(bytes);
          c.session.sha1.update(bytes);
        }
        hsTable[c.entity][c.expect][type](c, record, length);
      } else {
        tls.handleUnexpected(c, record);
      }
    };
    tls.handleApplicationData = function(c, record) {
      c.data.putBuffer(record.fragment);
      c.dataReady(c);
      c.process();
    };
    tls.handleHeartbeat = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length = b.getInt16();
      var payload = b.getBytes(length);
      if (type === tls.HeartbeatMessageType.heartbeat_request) {
        if (c.handshaking || length > payload.length) {
          return c.process();
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload)
        }));
        tls.flush(c);
      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c.expectedHeartbeatPayload) {
          return c.process();
        }
        if (c.heartbeatReceived) {
          c.heartbeatReceived(c, forge.util.createBuffer(payload));
        }
      }
      c.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var CER = 7;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R2 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [[__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [R0, R1, __, __, R4], [__, R1, R2, __, R4], [__, R1, R2, R3, R4], [__, R1, R2, __, R4]];
    ctTable[tls.ConnectionEnd.server] = [[__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [R0, R1, __, __, R4], [__, R1, R2, __, R4], [__, R1, R2, R3, R4], [__, R1, R2, __, R4]];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H2 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [[__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [[__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]];
    tls.generateKeys = function(c, sp) {
      var prf = prf_TLS1;
      var random = sp.client_random + sp.server_random;
      if (!c.session.resuming) {
        sp.master_secret = prf(sp.pre_master_secret, 'master secret', random, 48).bytes();
        sp.pre_master_secret = null;
      }
      random = sp.server_random + sp.client_random;
      var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = (c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor);
      if (tls10) {
        length += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, 'key expansion', random, length);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c) {
      var client = (c.entity === tls.ConnectionEnd.client);
      var createMode = function() {
        var mode = {
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode.sequenceNumber[1] === 0xFFFFFFFF) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }
        };
        return mode;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c.error(c, {
            message: 'Could not decrypt record or bad MAC.',
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c, record, state.read)) {
          c.error(c, {
            message: 'Could not decompress record.',
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c.fail;
      };
      state.write.update = function(c, record) {
        if (!state.write.compressFunction(c, record, state.write)) {
          c.error(c, {
            message: 'Could not compress record.',
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c.error(c, {
            message: 'Could not encrypt record.',
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c.fail;
      };
      if (c.session) {
        var sp = c.session.sp;
        c.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c.session.cipherSuite.initConnectionState(state, c, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error('Unsupported compression algorithm.');
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d = new Date();
      var utc = +d + d.getTimezoneOffset() * 60000;
      var rval = forge.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c.version.major,
          minor: c.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c, alert) {
      var b = forge.util.createBuffer();
      b.putByte(alert.level);
      b.putByte(alert.description);
      return tls.createRecord(c, {
        type: tls.ContentType.alert,
        data: b
      });
    };
    tls.createClientHello = function(c) {
      c.session.clientHelloVersion = {
        major: c.version.major,
        minor: c.version.minor
      };
      var cipherSuites = forge.util.createBuffer();
      for (var i = 0; i < c.cipherSuites.length; ++i) {
        var cs = c.cipherSuites[i];
        cipherSuites.putByte(cs.id[0]);
        cipherSuites.putByte(cs.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge.util.createBuffer();
      if (c.virtualHost) {
        var ext = forge.util.createBuffer();
        ext.putByte(0x00);
        ext.putByte(0x00);
        var serverName = forge.util.createBuffer();
        serverName.putByte(0x00);
        writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
        var snList = forge.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.client_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c) {
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.server_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      rval.putByte(c.session.cipherSuite.id[0]);
      rval.putByte(c.session.cipherSuite.id[1]);
      rval.putByte(c.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c) {
      var client = (c.entity === tls.ConnectionEnd.client);
      var cert = null;
      if (c.getCertificate) {
        var hint;
        if (client) {
          hint = c.session.certificateRequest;
        } else {
          hint = c.session.extensions.server_name.serverNameList;
        }
        cert = c.getCertificate(c, hint);
      }
      var certList = forge.util.createBuffer();
      if (cert !== null) {
        try {
          if (!forge.util.isArray(cert)) {
            cert = [cert];
          }
          var asn1 = null;
          for (var i = 0; i < cert.length; ++i) {
            var msg = forge.pem.decode(cert[i])[0];
            if (msg.type !== 'CERTIFICATE' && msg.type !== 'X509 CERTIFICATE' && msg.type !== 'TRUSTED CERTIFICATE') {
              var error = new Error('Could not convert certificate from PEM; PEM ' + 'header type is not "CERTIFICATE", "X509 CERTIFICATE", or ' + '"TRUSTED CERTIFICATE".');
              error.headerType = msg.type;
              throw error;
            }
            if (msg.procType && msg.procType.type === 'ENCRYPTED') {
              throw new Error('Could not convert certificate from PEM; PEM is encrypted.');
            }
            var der = forge.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert = forge.pki.certificateFromAsn1(asn1);
          if (client) {
            c.session.clientCertificate = cert;
          } else {
            c.session.serverCertificate = cert;
          }
        } catch (ex) {
          return c.error(c, {
            message: 'Could not send certificate list.',
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length = 3 + certList.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c) {
      var b = forge.util.createBuffer();
      b.putByte(c.session.clientHelloVersion.major);
      b.putByte(c.session.clientHelloVersion.minor);
      b.putBytes(forge.random.getBytes(46));
      var sp = c.session.sp;
      sp.pre_master_secret = b.getBytes();
      var key = c.session.serverCertificate.publicKey;
      b = key.encrypt(sp.pre_master_secret);
      var length = b.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length);
      rval.putInt16(b.length);
      rval.putBytes(b);
      return rval;
    };
    tls.createServerKeyExchange = function(c) {
      var length = 0;
      var rval = forge.util.createBuffer();
      if (length > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length);
      }
      return rval;
    };
    tls.getClientSignature = function(c, callback) {
      var b = forge.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      b = b.getBytes();
      c.getSignature = c.getSignature || function(c, b, callback) {
        var privateKey = null;
        if (c.getPrivateKey) {
          try {
            privateKey = c.getPrivateKey(c, c.session.clientCertificate);
            privateKey = forge.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c.error(c, {
              message: 'Could not get private key.',
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c.error(c, {
            message: 'No private key set.',
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b = privateKey.sign(b, null);
        }
        callback(c, b);
      };
      c.getSignature(c, b, callback);
    };
    tls.createCertificateVerify = function(c, signature) {
      var length = signature.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c) {
      var certTypes = forge.util.createBuffer();
      certTypes.putByte(0x01);
      var cAs = forge.util.createBuffer();
      for (var key in c.caStore.certs) {
        var cert = c.caStore.certs[key];
        var dn = forge.pki.distinguishedNameToAsn1(cert.subject);
        cAs.putBuffer(forge.asn1.toDer(dn));
      }
      var length = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c) {
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge.util.createBuffer();
      rval.putByte(0x01);
      return rval;
    };
    tls.createFinished = function(c) {
      var b = forge.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = (c.entity === tls.ConnectionEnd.client);
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? 'client finished' : 'server finished';
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b.length());
      rval.putBuffer(b);
      return rval;
    };
    tls.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === 'undefined') {
        payloadLength = payload.length;
      }
      var rval = forge.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c, record) {
      if (!record) {
        return;
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes = record.fragment.bytes();
        c.session.md5.update(bytes);
        c.session.sha1.update(bytes);
        bytes = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data = record.fragment.bytes();
        while (data.length > tls.MaxFragment) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
          }));
          data = data.slice(tls.MaxFragment);
        }
        if (data.length > 0) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge.util.createBuffer(data)
          }));
        }
      }
      for (var i = 0; i < records.length && !c.fail; ++i) {
        var rec = records[i];
        var s = c.state.current.write;
        if (s.update(c, rec)) {
          c.records.push(rec);
        }
      }
    };
    tls.flush = function(c) {
      for (var i = 0; i < c.records.length; ++i) {
        var record = c.records[i];
        c.tlsData.putByte(record.type);
        c.tlsData.putByte(record.version.major);
        c.tlsData.putByte(record.version.minor);
        c.tlsData.putInt16(record.fragment.length());
        c.tlsData.putBuffer(c.records[i].fragment);
      }
      c.records = [];
      return c.tlsDataReady(c);
    };
    var _certErrorToAlertDesc = function(error) {
      switch (error) {
        case true:
          return true;
        case forge.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge.pki.certificateError.unknown_ca;
        default:
          return forge.pki.certificateError.bad_certificate;
      }
    };
    tls.verifyCertificateChain = function(c, chain) {
      try {
        forge.pki.verifyCertificateChain(c.caStore, chain, function verify(vfd, depth, chain) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c.verify(c, vfd, depth, chain);
          if (ret !== true) {
            if (typeof ret === 'object' && !forge.util.isArray(ret)) {
              var error = new Error('The application rejected the certificate.');
              error.send = true;
              error.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
              throw error;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        });
      } catch (ex) {
        var err = ex;
        if (typeof err !== 'object' || forge.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!('send' in err)) {
          err.send = true;
        }
        if (!('alert' in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c.error(c, err);
      }
      return !c.fail;
    };
    tls.createSessionCache = function(cache, capacity) {
      var rval = null;
      if (cache && cache.getSession && cache.setSession && cache.order) {
        rval = cache;
      } else {
        rval = {};
        rval.cache = cache || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key in cache) {
          if (rval.order.length <= capacity) {
            rval.order.push(key);
          } else {
            delete cache[key];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key = null;
          if (sessionId) {
            key = forge.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key = rval.order[0];
          }
          if (key !== null && key in rval.cache) {
            session = rval.cache[key];
            delete rval.cache[key];
            for (var i in rval.order) {
              if (rval.order[i] === key) {
                rval.order.splice(i, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key = rval.order.shift();
            delete rval.cache[key];
          }
          var key = forge.util.bytesToHex(sessionId);
          rval.order.push(key);
          rval.cache[key] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge.util.isArray(options.caStore)) {
          caStore = forge.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key]);
        }
      }
      var entity = (options.server || false) ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c = {
        version: {
          major: tls.Version.major,
          minor: tls.Version.minor
        },
        entity: entity,
        sessionId: options.sessionId,
        caStore: caStore,
        sessionCache: sessionCache,
        cipherSuites: cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn, vfd, dpth, cts) {
          return vfd;
        },
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge.util.createBuffer(),
        tlsData: forge.util.createBuffer(),
        data: forge.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function(c, ex) {
          ex.origin = ex.origin || ((c.entity === tls.ConnectionEnd.client) ? 'client' : 'server');
          if (ex.send) {
            tls.queue(c, tls.createAlert(c, ex.alert));
            tls.flush(c);
          }
          var fatal = (ex.fatal !== false);
          if (fatal) {
            c.fail = true;
          }
          options.error(c, ex);
          if (fatal) {
            c.close(false);
          }
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c.reset = function(clearFail) {
        c.version = {
          major: tls.Version.major,
          minor: tls.Version.minor
        };
        c.record = null;
        c.session = null;
        c.peerCertificate = null;
        c.state = {
          pending: null,
          current: null
        };
        c.expect = (c.entity === tls.ConnectionEnd.client) ? SHE : CHE;
        c.fragmented = null;
        c.records = [];
        c.open = false;
        c.handshakes = 0;
        c.handshaking = false;
        c.isConnected = false;
        c.fail = !(clearFail || typeof(clearFail) === 'undefined');
        c.input.clear();
        c.tlsData.clear();
        c.data.clear();
        c.state.current = tls.createConnectionState(c);
      };
      c.reset();
      var _update = function(c, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers = ctTable[c.entity][c.expect];
        if (aligned in handlers) {
          handlers[aligned](c, record);
        } else {
          tls.handleUnexpected(c, record);
        }
      };
      var _readRecordHeader = function(c) {
        var rval = 0;
        var b = c.input;
        var len = b.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c.record = {
            type: b.getByte(),
            version: {
              major: b.getByte(),
              minor: b.getByte()
            },
            length: b.getInt16(),
            fragment: forge.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = (c.record.version.major === c.version.major);
          if (compatibleVersion && c.session && c.session.version) {
            compatibleVersion = (c.record.version.minor === c.version.minor);
          }
          if (!compatibleVersion) {
            c.error(c, {
              message: 'Incompatible TLS version.',
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c) {
        var rval = 0;
        var b = c.input;
        var len = b.length();
        if (len < c.record.length) {
          rval = c.record.length - len;
        } else {
          c.record.fragment.putBytes(b.getBytes(c.record.length));
          b.compact();
          var s = c.state.current.read;
          if (s.update(c, c.record)) {
            if (c.fragmented !== null) {
              if (c.fragmented.type === c.record.type) {
                c.fragmented.fragment.putBuffer(c.record.fragment);
                c.record = c.fragmented;
              } else {
                c.error(c, {
                  message: 'Invalid fragmented record.',
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c.record.ready = true;
          }
        }
        return rval;
      };
      c.handshake = function(sessionId) {
        if (c.entity !== tls.ConnectionEnd.client) {
          c.error(c, {
            message: 'Cannot initiate handshake as a server.',
            fatal: false
          });
        } else if (c.handshaking) {
          c.error(c, {
            message: 'Handshake already in progress.',
            fatal: false
          });
        } else {
          if (c.fail && !c.open && c.handshakes === 0) {
            c.fail = false;
          }
          c.handshaking = true;
          sessionId = sessionId || '';
          var session = null;
          if (sessionId.length > 0) {
            if (c.sessionCache) {
              session = c.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = '';
            }
          }
          if (sessionId.length === 0 && c.sessionCache) {
            session = c.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
          if (session) {
            c.version = session.version;
            c.session.sp = session.sp;
          }
          c.session.sp.client_random = tls.createRandom().getBytes();
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c)
          }));
          tls.flush(c);
        }
      };
      c.process = function(data) {
        var rval = 0;
        if (data) {
          c.input.putBytes(data);
        }
        if (!c.fail) {
          if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
            c.record = null;
          }
          if (c.record === null) {
            rval = _readRecordHeader(c);
          }
          if (!c.fail && c.record !== null && !c.record.ready) {
            rval = _readRecord(c);
          }
          if (!c.fail && c.record !== null && c.record.ready) {
            _update(c, c.record);
          }
        }
        return rval;
      };
      c.prepare = function(data) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.application_data,
          data: forge.util.createBuffer(data)
        }));
        return tls.flush(c);
      };
      c.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === 'undefined') {
          payloadLength = payload.length;
        }
        c.expectedHeartbeatPayload = payload;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)
        }));
        return tls.flush(c);
      };
      c.close = function(clearFail) {
        if (!c.fail && c.sessionCache && c.session) {
          var session = {
            id: c.session.id,
            version: c.session.version,
            sp: c.session.sp
          };
          session.sp.keys = null;
          c.sessionCache.setSession(session.id, session);
        }
        if (c.open) {
          c.open = false;
          c.input.clear();
          if (c.isConnected || c.handshaking) {
            c.isConnected = c.handshaking = false;
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c);
          }
          c.closed(c);
        }
        c.reset(clearFail);
      };
      return c;
    };
    forge.tls = forge.tls || {};
    for (var key in tls) {
      if (typeof tls[key] !== 'function') {
        forge.tls[key] = tls[key];
      }
    }
    forge.tls.prf_tls1 = prf_TLS1;
    forge.tls.hmac_sha1 = hmac_sha1;
    forge.tls.createSessionCache = tls.createSessionCache;
    forge.tls.createConnection = tls.createConnection;
  }
  var name = 'tls';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/tls.js", ["require", "module", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/hmac.js", "npm:node-forge@0.6.30/js/md.js", "npm:node-forge@0.6.30/js/pem.js", "npm:node-forge@0.6.30/js/pki.js", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
System.registerDynamic("npm:baobab@1.1.1/index.js", ["npm:baobab@1.1.1/src/baobab.js", "npm:baobab@1.1.1/src/cursor.js", "npm:baobab@1.1.1/src/facet.js", "npm:baobab@1.1.1/src/helpers.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Baobab = require("npm:baobab@1.1.1/src/baobab.js"),
      Cursor = require("npm:baobab@1.1.1/src/cursor.js"),
      Facet = require("npm:baobab@1.1.1/src/facet.js"),
      helpers = require("npm:baobab@1.1.1/src/helpers.js");
  Object.defineProperty(Baobab, 'version', {value: '1.1.1'});
  Baobab.Cursor = Cursor;
  Baobab.Facet = Facet;
  Baobab.getIn = helpers.getIn;
  module.exports = Baobab;
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var tls = forge.tls;
    tls.CipherSuites['TLS_RSA_WITH_AES_128_CBC_SHA'] = {
      id: [0x00, 0x2f],
      name: 'TLS_RSA_WITH_AES_128_CBC_SHA',
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState: initConnectionState
    };
    tls.CipherSuites['TLS_RSA_WITH_AES_256_CBC_SHA'] = {
      id: [0x00, 0x35],
      name: 'TLS_RSA_WITH_AES_256_CBC_SHA',
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState: initConnectionState
    };
    function initConnectionState(state, c, sp) {
      var client = (c.entity === forge.tls.ConnectionEnd.client);
      state.read.cipherState = {
        init: false,
        cipher: forge.cipher.createDecipher('AES-CBC', client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge.cipher.createCipher('AES-CBC', client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = forge.random.getBytesSync(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({iv: iv});
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
      if (!decrypt) {
        var padding = blockSize - (input.length() % blockSize);
        input.fillWithByte(padding - 1, padding);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
      var rval = true;
      if (decrypt) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
          rval = rval && (output.at(i) == paddingLength);
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    var count = 0;
    function decrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      ++count;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({iv: iv});
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s.macLength;
      var mac = '';
      for (var i = 0; i < macLen; ++i) {
        mac += String.fromCharCode(0);
      }
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
      s.updateSequenceNumber();
      rval = (mac2 === mac) && rval;
      return rval;
    }
  }
  var name = 'aesCipherSuites';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/aesCipherSuites.js", ["require", "module", "npm:node-forge@0.6.30/js/aes.js", "npm:node-forge@0.6.30/js/tls.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
System.registerDynamic("npm:baobab@1.1.1.js", ["npm:baobab@1.1.1/index.js"], true, function(require, exports, module) {
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:baobab@1.1.1/index.js");
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  var name = 'forge';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {disableNativeCode: false};
      }
      return;
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      });
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge;
    };
    module.exports.disableNativeCode = false;
    module.exports(module.exports);
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.30/js/forge.js", ["require", "module", "npm:node-forge@0.6.30/js/aes.js", "npm:node-forge@0.6.30/js/aesCipherSuites.js", "npm:node-forge@0.6.30/js/asn1.js", "npm:node-forge@0.6.30/js/cipher.js", "npm:node-forge@0.6.30/js/cipherModes.js", "npm:node-forge@0.6.30/js/debug.js", "npm:node-forge@0.6.30/js/des.js", "npm:node-forge@0.6.30/js/hmac.js", "npm:node-forge@0.6.30/js/kem.js", "npm:node-forge@0.6.30/js/log.js", "npm:node-forge@0.6.30/js/md.js", "npm:node-forge@0.6.30/js/mgf1.js", "npm:node-forge@0.6.30/js/pbkdf2.js", "npm:node-forge@0.6.30/js/pem.js", "npm:node-forge@0.6.30/js/pkcs7.js", "npm:node-forge@0.6.30/js/pkcs1.js", "npm:node-forge@0.6.30/js/pkcs12.js", "npm:node-forge@0.6.30/js/pki.js", "npm:node-forge@0.6.30/js/prime.js", "npm:node-forge@0.6.30/js/prng.js", "npm:node-forge@0.6.30/js/pss.js", "npm:node-forge@0.6.30/js/random.js", "npm:node-forge@0.6.30/js/rc2.js", "npm:node-forge@0.6.30/js/ssh.js", "npm:node-forge@0.6.30/js/task.js", "npm:node-forge@0.6.30/js/tls.js", "npm:node-forge@0.6.30/js/util.js"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:node-forge@0.6.30.js", ["npm:node-forge@0.6.30/js/forge.js"], function(main) {
  return main;
});

_removeDefine();
})();
System.register('services/contacts/contacts-service.js', [], function (_export) {
  'use strict';

  _export('default', contacts);

  function contacts($q, R, state, network) {
    var invite = function inviteContact(contactId) {
      var userInfo = state.cloud.identity.get('userInfo');
      var contactChannel = network.createContactChannel(userInfo.id, contactId);

      var existingContact = state.cloud.contacts.get([contactId, 'userInfo']);

      var contact = existingContact || {
        id: contactId,
        displayName: 'Invite Pending',
        email: 'unknown-user@toc-messenger.io'
      };

      var MAX_ATTEMPTS = 3;
      var attemptCount = 0;

      var recursivelySendInvite = function recursivelySendInvite() {
        return network.sendInvite(contactId, userInfo)['catch'](function (error) {
          if (error !== 'timeout') {
            return $q.reject(error);
          }

          attemptCount++;
          if (attemptCount === MAX_ATTEMPTS) {
            return $q.reject('Invite request has timed out.');
          }

          return recursivelySendInvite();
        });
      };

      return recursivelySendInvite().then(function () {
        return state.save(state.cloud.contacts, [contactId, 'userInfo'], contact);
      }).then(function () {
        return state.save(state.cloud.network, ['channels', contactChannel.id, 'channelInfo'], contactChannel);
      }).then(function () {
        return network.initializeChannel(contactChannel);
      });
    };

    var initialize = function initializeContacts() {
      var contactsCursor = state.cloud.contacts;

      R.pipe(R.keys, R.forEach(function (contactId) {
        return contactsCursor.set([contactId, 'statusId'], 0);
      }))(contactsCursor.get());

      return $q.when();
    };

    return {
      invite: invite,
      initialize: initialize
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('services/state/state-service.js', [], function (_export) {
  'use strict';

  _export('default', state);

  function state($rootScope, $q, $window, storage, R, Baobab, notification) {
    var getStatePath = R.split(storage.KEY_SEPARATOR);

    var stateService = {};

    //DEBUG
    $window.tocState = stateService;
    $window.baobab = Baobab;

    stateService.tree = new Baobab({
      memory: {},
      local: {},
      cloudUnencrypted: {},
      cloud: {}
    });

    //TODO: test baobab event batching and tweak manual commit timing
    stateService.tree.on('update', function () {
      return setTimeout(function () {
        return $rootScope.$apply();
      });
    });

    stateService.version = '0.3.0';

    // local application state persisted in-memory only
    stateService.memory = {
      cursor: stateService.tree.select(['memory'])
    };

    // local application state persisted in localStorage
    stateService.local = {
      cursor: stateService.tree.select(['local'])
    };

    // unencrypted application state persisted in indexedDB with remoteStorage
    stateService.cloudUnencrypted = {
      cursor: stateService.tree.select(['cloudUnencrypted'])
    };

    // encrypted application state persisted in indexedDB with remoteStorage
    stateService.cloud = {
      cursor: stateService.tree.select(['cloud'])
    };

    var initializeUserCursors = function initializeUserCursors(userId) {
      stateService.local.identity = stateService.local.cursor.select([userId, 'identity']);

      stateService.cloudUnencrypted.identity = stateService.cloudUnencrypted.cursor.select([userId, 'identity']);
      stateService.cloudUnencrypted.state = stateService.cloudUnencrypted.cursor.select([userId, 'state']);

      stateService.cloud.identity = stateService.cloud.cursor.select([userId, 'identity']);
      stateService.cloud.contacts = stateService.cloud.cursor.select([userId, 'contacts']);
      stateService.cloud.network = stateService.cloud.cursor.select([userId, 'network']);
      stateService.cloud.channels = stateService.cloud.cursor.select([userId, 'channels']);
    };

    var destroyUserCursors = function destroyUserCursors() {
      stateService.local.identity = undefined;

      stateService.cloudUnencrypted.identity = undefined;
      stateService.cloudUnencrypted.state = undefined;

      stateService.cloud.identity = undefined;
      stateService.cloud.contacts = undefined;
      stateService.cloud.network = undefined;
      stateService.cloud.channels = undefined;
    };

    var saveVolatile = function saveVolatile(cursor, relativePath, object) {
      return $q.when().then(function () {
        if (cursor.get() === undefined) {
          cursor.tree.set(cursor.path, {});
          cursor.tree.commit();
        }

        cursor.set(relativePath, object);
        return object;
      })['catch'](function (error) {
        return notification.error(error, 'State Save Error');
      });
    };

    var savePersistent = function savePersistent(cursor, relativePath, object, store) {
      var storageKey = storage.getStorageKey(R.concat(R.drop(1, cursor.path), relativePath));

      return store.storeObject(storageKey, object).then(function (object) {
        //FIXME: workaround for setting nonexistant cursors
        // this can't be very performant
        if (cursor.get() === undefined) {
          cursor.tree.set(cursor.path, {});
          cursor.tree.commit();
        }

        cursor.set(relativePath, object);
        return object;
      })['catch'](function (error) {
        return notification.error(error, 'State Save Error');
      });
    };

    var removeVolatile = function removeVolatile(cursor, relativePath) {
      if (cursor.get() === undefined) {
        return $q.when();
      }

      return $q.when().then(function () {
        cursor.unset(relativePath);
        return relativePath;
      })['catch'](function (error) {
        return notification.error(error, 'State Delete Error');
      });
    };

    var removePersistent = function removePersistent(cursor, relativePath, store) {
      var storageKey = storage.getStorageKey(R.concat(R.drop(1, cursor.path), relativePath));

      if (cursor.get() === undefined) {
        return $q.when();
      }

      return store.removeObject(storageKey).then(function (key) {
        cursor.unset(relativePath);
        return key;
      })['catch'](function (error) {
        return notification.error(error, 'State Delete Error');
      });
    };

    var addListener = function addListener(cursor, handleUpdate, scope, options) {
      if (!options || !options.skipInitialize) {
        handleUpdate();
      }

      cursor.on('update', handleUpdate);

      if (scope) {
        scope.$on('destroy', function () {
          return cursor.off('update', handleUpdate);
        });
      }
    };

    var handleChangeCloud = function handleChangeCloud(event) {
      if (event.oldValue === event.newValue) {
        return;
      }

      stateService.cloud.cursor.set(getStatePath(event.relativePath), event.newValue);
    };

    var handleChangeCloudUnencrypted = function handleChangeCloudUnencrypted(event) {
      if (event.oldValue === event.newValue) {
        return;
      }

      stateService.cloudUnencrypted.cursor.set(getStatePath(event.relativePath), event.newValue);
    };

    var initializeStore = function initializeStore(stateModule) {
      return stateModule.store.getAllObjects().then(function (keyObjectPairs) {
        R.forEach(function (keyObjectPair) {
          return stateModule.cursor.set(getStatePath(keyObjectPair[0]), keyObjectPair[1]);
        })(keyObjectPairs);
        stateModule.cursor.tree.commit();
        return keyObjectPairs;
      });
    };

    var initializeLocal = function initializeLocal() {
      return initializeStore(stateService.local);
    };

    var initializeCloud = function initializeCloud() {
      return initializeStore(stateService.cloud);
    };

    var initializeCloudUnencrypted = function initializeCloudUnencrypted() {
      return initializeStore(stateService.cloudUnencrypted);
    };

    stateService.initializeUserCursors = initializeUserCursors;
    stateService.destroyUserCursors = destroyUserCursors;

    stateService.memory.save = saveVolatile;
    stateService.local.save = savePersistent;
    stateService.cloudUnencrypted.save = savePersistent;
    stateService.cloud.save = savePersistent;

    stateService.memory.remove = removeVolatile;
    stateService.local.remove = removePersistent;
    stateService.cloudUnencrypted.remove = removePersistent;
    stateService.cloud.remove = removePersistent;

    stateService.addListener = addListener;
    stateService.cloud.initialize = initializeCloud;

    var save = function save(cursor, relativePath, object) {
      var stateModule = stateService[cursor.path[0]];
      return stateModule.save(cursor, relativePath, object, stateModule.store);
    };

    var remove = function remove(cursor, relativePath) {
      var stateModule = stateService[cursor.path[0]];
      return stateModule.remove(cursor, relativePath, stateModule.store);
    };

    var initialize = function initialize() {
      storage.initialize();

      stateService.local.store = storage.local;
      stateService.cloudUnencrypted.store = storage.cloudUnencrypted;
      stateService.cloud.store = storage.cloud;

      storage.cloud.onChange(handleChangeCloud);
      storage.cloudUnencrypted.onChange(handleChangeCloudUnencrypted);
      return initializeLocal().then(function () {
        return initializeCloudUnencrypted();
      });
    };

    stateService.save = save;
    stateService.remove = remove;
    stateService.initialize = initialize;

    return stateService;
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('services/identity/identity-service.js', [], function (_export) {
  'use strict';

  _export('default', identity);

  function identity($q, state, R, cryptography) {
    var create = function createIdentity(sessionInfo, userInfo, options) {
      var userCredentials = {
        id: sessionInfo.id,
        password: userInfo.password
      };

      var newUserInfo = {
        id: sessionInfo.id,
        displayName: userInfo.displayName,
        email: userInfo.email
      };

      var savedCredentials = undefined;

      try {
        savedCredentials = cryptography.initialize(userCredentials);
        newUserInfo.challenge = cryptography.encrypt(userCredentials.id);
        cryptography.decrypt(newUserInfo.challenge);
      } catch (error) {
        cryptography.destroy();
        return $q.reject(error);
      }

      if (options.staySignedIn) {
        state.save(state.local.identity, ['savedCredentials'], savedCredentials);
      }

      return $q.when(newUserInfo);
    };

    var authenticate = function authenticateIdentity(userCredentials, options) {
      var challenge = state.cloudUnencrypted.identity.get(['userInfo']).challenge;

      var savedCredentials = undefined;

      try {
        savedCredentials = cryptography.initialize(userCredentials);
        cryptography.decrypt(challenge);
      } catch (error) {
        cryptography.destroy();
        return $q.reject('identity: wrong password');
      }

      if (options.staySignedIn) {
        state.save(state.local.identity, ['savedCredentials'], savedCredentials);
      }

      return $q.when(userCredentials);
    };

    var restore = function restoreIdentity(rememberedUser) {
      try {
        cryptography.restore(rememberedUser.savedCredentials);
        cryptography.decrypt(rememberedUser.userInfo.challenge);
      } catch (error) {
        cryptography.destroy();
        return $q.reject('identity: wrong saved credentials');
      }

      return $q.when(rememberedUser.userInfo);
    };

    var initialize = function initializeIdentity(userId) {
      state.initializeUserCursors(userId);
      return $q.when();
      // return state.save(
      //   state.memory.cursors.identity,
      //   ['currentUser'],
      //   userId
      // );
    };

    var destroy = function destroyIdentity() {
      state.destroyUserCursors();
      return $q.when();
      // return state.remove(
      //   state.memory.cursors.identity,
      //   ['currentUser']
      // );
    };

    return {
      create: create,
      authenticate: authenticate,
      restore: restore,
      initialize: initialize,
      destroy: destroy
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('services/navigation/navigation-service.js', [], function (_export) {
  'use strict';

  _export('default', navigation);

  function navigation($state, R) {
    var privateStates = ['app.home', 'app.channel'];

    var publicStates = ['app.signin', 'app.signup'];

    var isPrivateState = function isPrivateState(stateName) {
      var stateIncludes = stateName ? function (otherState) {
        return stateName.startsWith(otherState);
      } : $state.includes;

      return R.any(stateIncludes)(privateStates);
    };

    var isPublicState = function isPrivateState(stateName) {
      var stateIncludes = stateName ? function (otherState) {
        return stateName.startsWith(otherState);
      } : $state.includes;

      return R.any(stateIncludes)(publicStates);
    };

    return {
      isPrivateState: isPrivateState,
      isPublicState: isPublicState
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('services/network/network-service.js', [], function (_export) {
  'use strict';

  _export('default', network);

  function network($q, $window, $interval, R, state, telehash, notification) {
    var CHANNEL_ID_PREFIX = 'toc-';
    var INVITE_CHANNEL_ID = CHANNEL_ID_PREFIX + 'invite';

    var activeSession = undefined;

    var checkSession = function checkSession(session) {
      if (session) {
        return;
      }

      throw new Error('network: no active session');
    };

    var generateContactChannelId = function generateContactChannelId(userId, contactId) {
      var channelId = userId > contactId ? userId + '-' + contactId : contactId + '-' + userId;

      return CHANNEL_ID_PREFIX + channelId;
    };

    var generateGroupChannelId = function generateGroupChannelId(userId, channelName) {
      var channelId = userId + channelName;

      return CHANNEL_ID_PREFIX + channelId;
    };

    var createContactChannel = function createContactChannel(userId, contactId) {
      var channelId = generateContactChannelId(userId, contactId);

      var channel = {
        id: channelId,
        contactIds: [contactId]
      };

      return channel;
    };

    var handleInvite = function handleInvite(invitePayload) {
      var contactInfo = invitePayload;

      var userId = state.cloud.identity.get(['userInfo']).id;

      var channel = createContactChannel(userId, contactInfo.id);

      var existingChannel = state.cloud.network.get(['channels', channel.id, 'channelInfo']);

      var statusId = 1; //online

      channel.pendingAccept = !existingChannel;

      return state.save(state.cloud.network, ['channels', channel.id, 'channelInfo'], channel).then(function () {
        return state.save(state.cloud.contacts, [contactInfo.id, 'userInfo'], contactInfo);
      }).then(function () {
        return state.save(state.cloud.contacts, [contactInfo.id, 'statusId'], statusId);
      });
    };

    var handleStatus = function handleStatus(statusPayload, contactId) {
      var statusId = statusPayload;

      var contactCursor = state.cloud.contacts.select([contactId]);

      var currentContactStatus = contactCursor.get(['statusId']);

      if (currentContactStatus === statusId) {
        return $q.when();
      }

      return state.save(state.cloud.contacts, [contactId, 'statusId'], statusId);
    };

    var handleMessage = function handleMessage(messagePayload, sentTime, receivedTime, contactId, channelId) {
      var messageId = sentTime + '-' + contactId;

      var messageContent = messagePayload.c;
      var receivedLogicalClock = messagePayload.l;

      var message = {
        id: messageId,
        //TODO: find main contact userId from sender userId
        sender: contactId,
        receivedTime: receivedTime,
        sentTime: sentTime,
        logicalClock: receivedLogicalClock,
        content: messageContent
      };

      var channelCursor = state.cloud.network.select(['channels', channelId]);

      var existingLogicalClock = channelCursor.get('logicalClock');

      var currentLogicalClock = receivedLogicalClock >= existingLogicalClock ? receivedLogicalClock : existingLogicalClock;

      return state.save(channelCursor, ['logicalClock'], currentLogicalClock + 1).then(function () {
        return state.save(channelCursor, ['messages', messageId, 'messageInfo'], message);
      }).then(function () {
        var activeChannelId = state.cloud.network.get(['activeChannelId']);
        if (activeChannelId === channelId && channelCursor.get(['viewingLatest'])) {
          return $q.when();
        }

        var contactName = state.cloud.contacts.get([contactId, 'userInfo', 'displayName']);

        return notification.success(message.content, contactName + ' just said:');
      });
    };

    var listen = function listen(channelInfo) {
      var session = arguments[1] === undefined ? activeSession : arguments[1];

      var handlePacket = function handlePacket(error, packet, channel, callback) {
        var handledPacket = function handledPacket() {
          if (error) {
            return $q.reject(error);
          }

          callback(true);
          channel.send({ js: { a: {
                s: packet.from.sentAt,
                r: packet.from.recvAt
              } } });

          if (packet.js.a !== undefined) {
            return $q.when();
          } else if (packet.js.i !== undefined) {
            return handleInvite(packet.js.i);
          } else if (packet.js.s !== undefined) {
            return handleStatus(packet.js.s, packet.from.hashname);
          } else if (packet.js.m !== undefined) {
            //TODO: implement toast on new message arrival
            return handleMessage(packet.js.m, packet.from.sentAt, packet.from.recvAt, packet.from.hashname, channel.type.substr(1) //remove leading underscore
            );
          } else {
            return $q.reject('Unrecognized packet format: ' + JSON.stringify(packet.js));
          }
        };

        return handledPacket()['catch'](function (error) {
          return notification.error(error, 'Network Listen Error');
        });
      };

      try {
        checkSession(session);
        var listenResult = session.listen(channelInfo.id, handlePacket);
        return $q.when(listenResult);
      } catch (error) {
        return $q.reject(error);
      }
    };

    var send = function send(channelInfo, payload) {
      var session = arguments[2] === undefined ? activeSession : arguments[2];

      var sentMessage = $q.defer();

      var handleAcknowledgement = function handleAcknowledgement(error, packet, channel, callback) {
        if (error) {
          return sentMessage.reject(error);
        }

        callback(true);
        var acknowledgement = packet.js.a;
        if (acknowledgement) {
          return sentMessage.resolve(acknowledgement);
        } else {
          channel.send({ js: { a: {
                s: packet.from.sentAt,
                r: packet.from.recvAt
              } } });
          return sentMessage.resolve(packet.from.sentAt);
        }
      };

      try {
        checkSession(session);
        session.start(channelInfo.contactIds[0], channelInfo.id, { js: payload }, handleAcknowledgement);
      } catch (error) {
        sentMessage.reject(error);
      }

      return sentMessage.promise;
    };

    var handleSendTimeout = function handleSendTimeout(error, contactId, contactStatusId) {
      if (error !== 'timeout') {
        return $q.reject(error);
      }

      var contactCursor = state.cloud.contacts.select([contactId]);

      // do not change status back to offline if contact was already offline
      // or if contact status has been updated since message was sent
      var currentContactStatusId = contactCursor.get(['statusId']);
      if (currentContactStatusId === 0 || currentContactStatusId !== contactStatusId) {
        return $q.reject(error);
      }

      return state.save(state.cloud.contacts, [contactId, 'statusId'], 0);
    };

    var sendInvite = function sendInvite(contactId, userInfo) {
      var inviteChannel = {
        id: INVITE_CHANNEL_ID,
        contactIds: [contactId]
      };

      var payload = {
        i: userInfo
      };

      return send(inviteChannel, payload);
    };

    var sendStatus = function sendStatus(contactId, statusId) {
      var userId = state.cloud.identity.get().userInfo.id;
      var contactChannel = createContactChannel(userId, contactId);

      var payload = {
        s: statusId
      };

      var contactCursor = state.cloud.contacts.select([contactId]);

      var previousContactStatusId = contactCursor.get(['statusId']);

      if (previousContactStatusId === undefined) {
        return $q.when();
      }

      return send(contactChannel, payload)['catch'](function (error) {
        return handleSendTimeout(error, contactId, previousContactStatusId);
      });
    };

    var sendMessage = function sendMessage(channelInfo, messageContent, logicalClock) {
      if (!messageContent || !logicalClock) {
        return $q.reject('Invalid message format.');
      }

      var payload = {
        m: {
          c: messageContent,
          l: logicalClock
        }
      };

      var handleMessageAck = function handleMessageAck(acknowledgement) {
        var sentTime = acknowledgement.s;
        var receivedTime = acknowledgement.r;

        var userId = state.cloud.identity.get().userInfo.id;
        var messageId = sentTime + '-' + userId;

        var message = {
          id: messageId,
          //TODO: find main contact userId from sender userId for multi-signon
          sender: userId,
          receivedTime: receivedTime,
          sentTime: sentTime,
          logicalClock: logicalClock,
          content: messageContent
        };

        return state.save(state.cloud.network.select(['channels', channelInfo.id, 'messages']), [messageId, 'messageInfo'], message);
      };

      var contactId = channelInfo.contactIds[0];

      var previousContactStatusId = state.cloud.contacts.select([contactId]).get(['statusId']);

      if (previousContactStatusId === undefined) {
        return $q.when();
      }

      return send(channelInfo, payload).then(handleMessageAck)['catch'](function (error) {
        return handleSendTimeout(error, contactId, previousContactStatusId);
      });
    };

    var initializeChannel = function initializeChannel(channelInfo) {
      if (channelInfo.contactIds.length !== 1) {
        return $q.reject('Group chat not supported yet.');
      }

      return listen(channelInfo)['catch'](function (error) {
        return notification.error(error, 'Network Listen Error');
      }).then(function () {
        var sendStatusUpdate = function sendStatusUpdate() {
          return sendStatus(channelInfo.contactIds[0], 1)['catch'](function (error) {
            if (error === 'timeout') {
              return $q.when();
            }

            return notification.error(error, 'Status Update Error');
          });
        };

        sendStatusUpdate();
        $interval(sendStatusUpdate, 15000);

        return $q.when();
      }).then(function () {
        var channelCursor = state.cloud.network.select(['channels', channelInfo.id]);

        var logicalClock = channelCursor.get('logicalClock');

        if (logicalClock) {
          return $q.when();
        }

        logicalClock = 0;
        return state.save(channelCursor, ['logicalClock'], logicalClock);
      });
    };

    var initializeChannels = function initializeChannels() {
      var channels = state.cloud.network.get(['channels']);

      R.pipe(R.values, R.map(R.prop('channelInfo')), R.forEach(initializeChannel))(channels);

      $window.onbeforeunload = function () {
        var contactsCursor = state.cloud.contacts;

        R.pipe(R.keys, R.forEach(function (contactId) {
          return sendStatus(contactId, 0);
        }))(contactsCursor.get());
      };

      return $q.when();
    };

    var initialize = function initializeNetwork(keypair) {
      var deferredSession = $q.defer();

      var telehashKeypair = {};
      if (keypair) {
        telehashKeypair.id = keypair;
      }

      try {
        telehash.init(telehashKeypair, function initializeTelehash(error, telehashSession) {
          if (error) {
            return deferredSession.reject(error);
          }

          return deferredSession.resolve(telehashSession);
        });
      } catch (error) {
        return $q.reject(error);
      }

      return deferredSession.promise.then(function (telehashSession) {
        var sessionInfo = {
          id: telehashSession.hashname,
          keypair: telehashSession.id
        };

        activeSession = telehashSession;
        //DEBUG
        window.tocSession = activeSession;

        listen({ id: INVITE_CHANNEL_ID });

        return sessionInfo;
      });
    };

    return {
      INVITE_CHANNEL_ID: INVITE_CHANNEL_ID,
      createContactChannel: createContactChannel,
      listen: listen,
      send: send,
      sendInvite: sendInvite,
      sendStatus: sendStatus,
      sendMessage: sendMessage,
      initializeChannel: initializeChannel,
      initializeChannels: initializeChannels,
      initialize: initialize
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register("services/notification/notification-service.js", [], function (_export) {
  "use strict";

  _export("default", notification);

  function notification($q, $log, angularToastr) {
    var createToastrAsync = function createToastrPromise(toastrFunction) {
      return function (message, title) {
        $log.debug(title);
        $log.debug(message.message || message);
        return $q.when(toastrFunction(message.message || message, title));
      };
    };

    return {
      error: createToastrAsync(angularToastr.error),
      success: createToastrAsync(angularToastr.success),
      info: createToastrAsync(angularToastr.info),
      warning: createToastrAsync(angularToastr.warning)
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('services/cryptography/cryptography-service.js', [], function (_export) {
  'use strict';

  _export('default', cryptography);

  function cryptography($q, forge) {
    //TODO: add user setting to disable encryption
    var cachedCredentials = undefined;

    // for encryption + authentication with a single key
    var AES_ENCRYPTION_MODE = 'AES-GCM';

    var AES_KEY_STRENGTH = 128;

    // From Forge docs:
    // Note: a key size of 16 bytes will use AES-128, 24 => AES-192, 32 => AES-256
    var PBKDF2_KEY_LENGTH = AES_KEY_STRENGTH / 8;

    // Could probably afford to use more
    var PBKDF2_ITERATIONS = 10000;

    var HMAC_DIGEST_ALGORITHM = 'sha256';

    var ENCRYPTED_OBJECT = {
      name: 'tocEncryptedObject',
      //TODO: use JSON Schema URI for versioning
      schema: {
        type: 'object',
        properties: {
          ct: {
            type: 'string'
          },
          tag: {
            type: 'string'
          },
          iv: {
            type: 'string'
          }
        },
        required: ['ct', 'tag', 'iv']
      }
    };

    var UNENCRYPTED_OBJECT = {
      name: 'tocUnencryptedObject',
      schema: {
        type: 'object',
        properties: {
          pt: {
            type: 'string'
          }
        },
        required: ['pt']
      }
    };

    // replaces forwardslash in base64 string for use in paths for indexeddb
    var escapeBase64 = function escapeBase64(base64) {
      return base64.replace(/\//g, '.');
    };

    var unescapeBase64 = function unescapeBase64(base64) {
      return base64.replace(/\./g, '/');
    };

    var checkCredentials = function checkCredentials(credentials) {
      if (credentials && credentials.key) {
        return;
      }
      //FIXME: Throw error object instead?
      throw new Error('cryptography: mising credentials');
    };

    var getHmac = function getHmac(object) {
      var credentials = arguments[1] === undefined ? cachedCredentials : arguments[1];

      checkCredentials(credentials);

      var plaintext = JSON.stringify(object);

      var hmac = forge.hmac.create();

      hmac.start(HMAC_DIGEST_ALGORITHM, credentials.key);
      hmac.update(plaintext);

      return hmac.digest().getBytes();
    };

    var encryptBase = function encryptBase(object, ivBytes) {
      var credentials = arguments[2] === undefined ? cachedCredentials : arguments[2];

      checkCredentials(credentials);

      var plaintext = JSON.stringify(object);

      var cipher = forge.cipher.createCipher(AES_ENCRYPTION_MODE, credentials.key);

      cipher.start({ iv: ivBytes });
      cipher.update(forge.util.createBuffer(plaintext));
      cipher.finish();

      var iv = forge.util.encode64(ivBytes);
      var ct = forge.util.encode64(cipher.output.getBytes());
      var tag = forge.util.encode64(cipher.mode.tag.getBytes());

      return { iv: iv, ct: ct, tag: tag };
    };

    // Hand-rolled deterministic encryption scheme.
    // TODO: replace with something standard like SIV-AES
    var encryptDeterministic = function encryptDeterministic(object) {
      var credentials = arguments[1] === undefined ? cachedCredentials : arguments[1];

      var ivBytes = getHmac(object);

      return encryptBase(object, ivBytes, credentials);
    };

    var encrypt = function encrypt(object) {
      var credentials = arguments[1] === undefined ? cachedCredentials : arguments[1];

      var ivBytes = forge.random.getBytesSync(16);

      return encryptBase(object, ivBytes, credentials);
    };

    var decrypt = function decrypt(encryptedObject) {
      var credentials = arguments[1] === undefined ? cachedCredentials : arguments[1];

      checkCredentials(credentials);

      var ciphertext = forge.util.decode64(encryptedObject.ct);
      var iv = forge.util.decode64(encryptedObject.iv);
      var tag = forge.util.decode64(encryptedObject.tag);

      var decipher = forge.cipher.createDecipher(AES_ENCRYPTION_MODE, credentials.key);

      decipher.start({
        iv: forge.util.createBuffer(iv),
        tag: forge.util.createBuffer(tag)
      });

      decipher.update(forge.util.createBuffer(ciphertext));

      var result = decipher.finish();

      if (!result) {
        throw new Error('cryptography: decryption failed');
      }

      return JSON.parse(decipher.output.getBytes());
    };

    var deriveCredentials = function deriveCredentials(userCredentials) {
      var salt = forge.util.hexToBytes(userCredentials.id);
      var key = forge.pkcs5.pbkdf2(userCredentials.password, salt, PBKDF2_ITERATIONS, PBKDF2_KEY_LENGTH);

      return { key: key };
    };

    var isInitialized = function isInitialized() {
      return cachedCredentials !== undefined;
    };

    var initialize = function initializeCryptography(userCredentials) {
      cachedCredentials = deriveCredentials(userCredentials);
      return cachedCredentials;
    };

    var restore = function restoreCryptography(savedCredentials) {
      cachedCredentials = savedCredentials;
      return savedCredentials;
    };

    var destroy = function destroyCryptography() {
      cachedCredentials = undefined;
    };

    return {
      ENCRYPTED_OBJECT: ENCRYPTED_OBJECT,
      UNENCRYPTED_OBJECT: UNENCRYPTED_OBJECT,
      escapeBase64: escapeBase64,
      unescapeBase64: unescapeBase64,
      getHmac: getHmac,
      encryptDeterministic: encryptDeterministic,
      encrypt: encrypt,
      decrypt: decrypt,
      deriveCredentials: deriveCredentials,
      isInitialized: isInitialized,
      initialize: initialize,
      restore: restore,
      destroy: destroy
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register("services/time/time-service.js", [], function (_export) {
  "use strict";

  _export("default", time);

  function time(moment) {
    return moment;
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('views/channel/channel-controller.js', [], function (_export) {
  'use strict';

  _export('default', ChannelController);

  function ChannelController($q, $stateParams, state, network, notification, $scope) {
    var _this = this;

    this.channelId = $stateParams.channelId;

    var channelCursor = state.cloud.network.select(['channels', this.channelId]);

    var contactCursor = state.cloud.contacts;

    this.contact = contactCursor.get(channelCursor.get(['channelInfo', 'contactIds'])[0]);
    var updateTitle = function updateTitle() {
      _this.title = _this.contact.userInfo.displayName;
    };

    state.addListener(contactCursor, updateTitle, $scope);

    var updateContact = function updateContact() {
      _this.contact = contactCursor.get(
      //TODO: refactor data dependency between contacts and channels
      channelCursor.get(['channelInfo', 'contactIds'])[0]);
    };

    state.addListener(contactCursor, updateContact, $scope);
    state.addListener(channelCursor, updateContact, $scope, {
      skipInitialize: true
    });

    this.message = '';
    //TODO: add to offline message queue instead of blocking further input
    this.send = function () {
      var MAX_ATTEMPTS = 3;
      var attemptCount = 0;
      var recursivelySendMessage = function recursivelySendMessage() {
        var logicalClock = channelCursor.get(['logicalClock']);

        return network.sendMessage(channelCursor.get(['channelInfo']), _this.message, logicalClock + 1).then(function () {
          var currentLogicalClock = channelCursor.get(['logicalClock']);

          return state.save(channelCursor, ['logicalClock'], currentLogicalClock + 1);
        })['catch'](function (error) {
          if (error !== 'timeout') {
            return $q.reject(error);
          }

          attemptCount++;
          if (attemptCount === MAX_ATTEMPTS) {
            return $q.reject('Message sending has timed out.');
          }

          return recursivelySendMessage();
        });
      };

      _this.sending = recursivelySendMessage().then(function () {
        _this.message = '';
        return $q.when();
      })['catch'](function (error) {
        return notification.error(error, 'Message Delivery Error');
      });

      return _this.sending;
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('views/home/home-controller.js', [], function (_export) {
  'use strict';

  _export('default', HomeController);

  function HomeController(state, identity, network, notification, $ionicPopup, $q, $window, storage, $scope) {
    var _this = this;

    var activeChannelId = state.cloud.network.get(['activeChannelId']);

    if (activeChannelId !== 'home') {
      state.save(state.cloud.network, ['activeChannelId'], 'home');
    }

    var currentUserCursor = state.cloud.identity;
    var updateCurrentUser = function updateCurrentUser() {
      _this.currentUser = currentUserCursor.get();
    };

    state.addListener(currentUserCursor, updateCurrentUser, $scope);

    //FIXME: this should probably go into state.memory if possible
    this.isStorageConnected = storage.isConnected;

    this.showSignoutConfirm = function showSignoutConfirm() {
      var signoutPopup = $ionicPopup.confirm({
        title: 'Sign Out',
        template: 'Are you sure?',
        okText: 'Sign out',
        okType: 'button-assertive button-outline'
      });

      signoutPopup.then(function (response) {
        if (!response) {
          return;
        }

        return state.remove(state.local.identity, ['savedCredentials']).then(function () {
          return $q.when($window.location.reload());
        })['catch'](function (error) {
          return notification.error(error, 'Signout Error');
        });
      });
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register("views/welcome/welcome-controller.js", [], function (_export) {
  "use strict";

  _export("default", WelcomeController);

  function WelcomeController(state, R, storage, $scope) {
    var _this = this;

    this.isStorageConnected = storage.isConnected;

    var savedUsersCursor = state.cloudUnencrypted.cursor;
    var updateSavedUsers = function updateSavedUsers() {
      _this.users = R.keys(savedUsersCursor.get()).length;
    };

    state.addListener(savedUsersCursor, updateSavedUsers, $scope);
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register("views/cloud/cloud-controller.js", [], function (_export) {
  "use strict";

  _export("default", CloudController);

  function CloudController(storage) {
    this.isConnected = storage.isConnected;
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('components/auto-focus/auto-focus-directive.js', [], function (_export) {
  //workaround for transition performance issues with ionic navigation + autofocus

  'use strict';

  _export('default', tocAutoFocus);

  function tocAutoFocus($timeout, notification) {
    return {
      restrict: 'A',
      link: function linkAutoFocus(scope, element) {
        try {
          $timeout(function () {
            return element[0].focus();
          }, 500);
        } catch (error) {
          notification.error(error, 'AutoFocus Error');
        }
      }
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('components/qr-image/qr-image-directive.js', [], function (_export) {
  'use strict';

  _export('default', tocQrImage);

  function tocQrImage(qrEncode, notification) {
    return {
      restrict: 'E',
      link: function linkQrImage(scope, element, attrs) {
        //TODO: persist qr code dataURI
        try {
          var data = attrs.data;
          var dataURI = qrEncode(data, { type: 7, size: 9, level: 'H' });
          var qrImage = new Image();
          qrImage.src = dataURI;
          element[0].appendChild(qrImage);
        } catch (error) {
          notification.error(error, 'ID QRCode Encoding Error');
        }
      }
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('components/spinner-button/spinner-button-directive.js', [], function (_export) {
  'use strict';

  _export('default', tocSpinnerButton);

  function tocSpinnerButton($timeout, notification) {
    return {
      restrict: 'A',
      scope: {
        loadingPromise: '='
      },
      link: function linkSpinnerButton(scope, element) {
        try {
          (function () {
            var SPIN_DURATION = 750;

            var spinnerElement = element.find('ion-spinner');
            var iconElement = element.find('i');
            var buttonElement = element;

            spinnerElement.toggleClass('toc-hidden');

            spinnerElement.toggleClass('toc-fadeout');
            iconElement.toggleClass('toc-fadein');
            var spinning = false;

            var toggleSpin = function toggleSpin() {
              spinning = !spinning;

              spinnerElement.toggleClass('toc-fadeout');
              iconElement.toggleClass('toc-fadeout');

              $timeout(function () {
                spinnerElement.toggleClass('toc-hidden');
                iconElement.toggleClass('toc-hidden');
                //FIXME: fadein afterwards doesnt work
                // spinnerElement.toggleClass('toc-fadein');
                // iconElement.toggleClass('toc-fadein');
              }, SPIN_DURATION);

              if (spinning) {
                buttonElement.attr('disabled', 'true');
              } else {
                buttonElement.removeAttr('disabled');
              }
            };

            scope.$watch('loadingPromise', function (loadingPromise) {
              if (!loadingPromise) {
                return;
              }
              var spinStartTime = Date.now();
              toggleSpin();

              loadingPromise.then(function () {
                var spinEndTime = Date.now();

                var spinElapsedTime = (spinStartTime - spinEndTime) % SPIN_DURATION;

                $timeout(function () {
                  toggleSpin();
                }, SPIN_DURATION - spinElapsedTime);
              });
            });
          })();
        } catch (error) {
          notification.error(error, 'Spinner Button Error');
        }
      }
    };
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register("components/signin-form/signin-form-service.js", [], function (_export) {
  "use strict";

  _export("default", signinForm);

  function signinForm() {
    return {};
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('app-run.js', [], function (_export) {
  'use strict';

  _export('default', runApp);

  function runApp($state, $rootScope, R, state, identity, contacts, network, notification, $q, $ionicPlatform, $location, $ionicHistory, $timeout, navigation, storage) {
    $ionicPlatform.ready(function () {
      // Hide the accessory bar by default
      // Remove this to show the accessory bar above the keyboard for form inputs
      if (window.cordova && window.cordova.plugins.Keyboard) {
        window.cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
      }
      if (window.StatusBar) {
        // org.apache.cordova.statusbar required
        window.StatusBar.styleDefault();
      }
    });

    // redirect to app.welcome if identity has not been initialized
    $rootScope.$on('$stateChangeStart', function (event, toState) {
      var doRedirect = undefined;
      var redirectStateName = undefined;

      if (state.cloud.identity && state.cloud.identity.get()) {
        doRedirect = navigation.isPublicState(toState.name);
        redirectStateName = 'app.home';
      } else {
        doRedirect = navigation.isPrivateState(toState.name);
        redirectStateName = 'app.welcome';
      }

      if (!doRedirect) {
        return;
      }

      event.preventDefault();
      return $state.go(redirectStateName);
    });

    storage.prepare().then(function () {
      return state.initialize();
    }).then(function () {
      var localUsers = state.local.cursor.get();

      var rememberedIdUserPair = undefined;

      if (R.keys(localUsers).length !== 0) {
        rememberedIdUserPair = R.pipe(R.toPairs, R.map(function (idUserPair) {
          return [idUserPair[0], R.prop('identity')(idUserPair[1])];
        }), R.find(function (idUserPair) {
          return idUserPair[1].savedCredentials;
        }))(localUsers);
      }

      if (!rememberedIdUserPair) {
        //TODO: refactor pattern into navigation service
        // along with other instances of $state
        if (!$state.is('app.welcome')) {
          $ionicHistory.nextViewOptions({
            historyRoot: true,
            disableBack: true,
            disableAnimate: true
          });
        }

        return $state.go('app.welcome')
        //workaround for too early initialization
        .then(function () {
          return $timeout(function () {
            return $ionicHistory.clearCache();
          }, 0);
        });
      }

      var rememberedUser = state.cloudUnencrypted.cursor.get([rememberedIdUserPair[0], 'identity']);

      rememberedUser.savedCredentials = rememberedIdUserPair[1].savedCredentials;

      return identity.initialize(rememberedUser.userInfo.id).then(function () {
        return identity.restore(rememberedUser);
      }).then(function () {
        return state.cloud.initialize(rememberedUser.userInfo.id);
      }).then(function () {
        return contacts.initialize();
      }).then(function () {
        var sessionInfo = state.cloud.network.get(['sessions', rememberedUser.userInfo.id, 'sessionInfo']);

        return network.initialize(sessionInfo.keypair).then(function () {
          return network.initializeChannels();
        });
      }).then(function () {
        if (!navigation.isPrivateState()) {
          if (!$state.is('app.home')) {
            $ionicHistory.nextViewOptions({
              historyRoot: true,
              disableBack: true
            });
          }

          return $state.go('app.home');
        }

        var activeChannelId = state.cloud.network.get(['activeChannelId']);

        if (activeChannelId === 'home') {
          if (!$state.is('app.home')) {
            $ionicHistory.nextViewOptions({
              historyRoot: true,
              disableBack: true
            });
          }

          return $state.go('app.home');
        }

        if (!$state.includes('app.channel')) {
          $ionicHistory.nextViewOptions({
            historyRoot: true,
            disableBack: true
          });
        }

        return $state.go('app.channel', { channelId: activeChannelId });
      }).then(function () {
        return state.save(state.cloudUnencrypted.identity, ['latestSession'], Date.now());
      })['catch'](function (error) {
        return notification.error(error, 'Authentication Error').then(function () {
          return identity.destroy();
        });
      });
    });
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register("app-controller.js", [], function (_export) {
  "use strict";

  _export("default", AppController);

  function AppController(navigation) {
    this.isPrivateState = navigation.isPrivateState;
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.register('services/state/state.js', ['github:angular/bower-angular@1.4.1.js', 'services/storage/storage.js', 'services/state/state-service.js'], function (_export) {
    'use strict';

    var angular, storage, service;
    return {
        setters: [function (_githubAngularBowerAngular141Js) {
            angular = _githubAngularBowerAngular141Js['default'];
        }, function (_servicesStorageStorageJs) {
            storage = _servicesStorageStorageJs['default'];
        }, function (_servicesStateStateServiceJs) {
            service = _servicesStateStateServiceJs['default'];
        }],
        execute: function () {
            _export('default', angular.module('toc.services.state', [storage.name]).factory(service.name, service));
        }
    };
});

System.register('services/navigation/navigation.js', ['github:angular/bower-angular@1.4.1.js', 'services/navigation/navigation-service.js'], function (_export) {
  'use strict';

  var angular, service;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_servicesNavigationNavigationServiceJs) {
      service = _servicesNavigationNavigationServiceJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.services.navigation', []).factory(service.name, service));
    }
  };
});

System.register('libraries/telehash/telehash.js', ['github:angular/bower-angular@1.4.1.js', 'libraries/telehash/telehash-library.js'], function (_export) {
  'use strict';

  var angular, th;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_librariesTelehashTelehashLibraryJs) {
      th = _librariesTelehashTelehashLibraryJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.telehash', []).factory('telehash', function () {
        return telehash;
      }));
    }
  };
});

System.register('views/channel/channel-config.js', ['views/channel/channel.html!github:systemjs/plugin-text@0.0.2.js', 'views/channel/channel-controller.js'], function (_export) {
  'use strict';

  var template, controller;

  _export('default', configHome);

  function configHome($stateProvider) {
    $stateProvider.state('app.channel', {
      url: '/channel/{channelId:string}',
      template: template,
      controller: controller.name + ' as channelView'
    });
  }

  return {
    setters: [function (_viewsChannelChannelHtmlGithubSystemjsPluginText002Js) {
      template = _viewsChannelChannelHtmlGithubSystemjsPluginText002Js['default'];
    }, function (_viewsChannelChannelControllerJs) {
      controller = _viewsChannelChannelControllerJs['default'];
    }],
    execute: function () {}
  };
});

System.register('views/home/home-config.js', ['views/home/home.html!github:systemjs/plugin-text@0.0.2.js', 'views/home/home-controller.js'], function (_export) {
  'use strict';

  var template, controller;

  _export('default', configHome);

  function configHome($stateProvider) {
    $stateProvider.state('app.home', {
      url: '/home',
      template: template,
      controller: controller.name + ' as homeView'
    });
  }

  return {
    setters: [function (_viewsHomeHomeHtmlGithubSystemjsPluginText002Js) {
      template = _viewsHomeHomeHtmlGithubSystemjsPluginText002Js['default'];
    }, function (_viewsHomeHomeControllerJs) {
      controller = _viewsHomeHomeControllerJs['default'];
    }],
    execute: function () {}
  };
});

System.register('views/welcome/welcome-config.js', ['views/welcome/welcome.html!github:systemjs/plugin-text@0.0.2.js', 'views/welcome/welcome-controller.js'], function (_export) {
  'use strict';

  var template, controller;

  _export('default', configWelcome);

  function configWelcome($stateProvider) {
    $stateProvider.state('app.welcome', {
      url: '/welcome',
      template: template,
      controller: controller.name + ' as welcomeView'
    });
  }

  return {
    setters: [function (_viewsWelcomeWelcomeHtmlGithubSystemjsPluginText002Js) {
      template = _viewsWelcomeWelcomeHtmlGithubSystemjsPluginText002Js['default'];
    }, function (_viewsWelcomeWelcomeControllerJs) {
      controller = _viewsWelcomeWelcomeControllerJs['default'];
    }],
    execute: function () {}
  };
});

System.register('views/signin/signin-config.js', ['views/signin/signin.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', configSignin);

  function configSignin($stateProvider) {
    $stateProvider.state('app.signin', {
      url: '/signin',
      template: template
    });
  }

  return {
    setters: [function (_viewsSigninSigninHtmlGithubSystemjsPluginText002Js) {
      template = _viewsSigninSigninHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('views/signup/signup-config.js', ['views/signup/signup.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', configSignup);

  function configSignup($stateProvider) {
    $stateProvider.state('app.signup', {
      url: '/signup',
      template: template
    });
  }

  return {
    setters: [function (_viewsSignupSignupHtmlGithubSystemjsPluginText002Js) {
      template = _viewsSignupSignupHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('views/cloud/cloud-config.js', ['views/cloud/cloud.html!github:systemjs/plugin-text@0.0.2.js', 'views/cloud/cloud-controller.js'], function (_export) {
  'use strict';

  var template, controller;

  _export('default', configCloud);

  function configCloud($stateProvider) {
    $stateProvider.state('app.cloud', {
      url: '/cloud',
      template: template,
      controller: controller.name + ' as cloudView'
    });
  }

  return {
    setters: [function (_viewsCloudCloudHtmlGithubSystemjsPluginText002Js) {
      template = _viewsCloudCloudHtmlGithubSystemjsPluginText002Js['default'];
    }, function (_viewsCloudCloudControllerJs) {
      controller = _viewsCloudCloudControllerJs['default'];
    }],
    execute: function () {}
  };
});

System.register('components/header/header-directive.js', ['components/header/header.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', tocHeader);

  function tocHeader() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'header',
      controller: function HeaderController($state, state, navigation) {
        this.isPrivateState = navigation.isPrivateState;
      }
    };
  }

  return {
    setters: [function (_componentsHeaderHeaderHtmlGithubSystemjsPluginText002Js) {
      template = _componentsHeaderHeaderHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('components/auto-focus/auto-focus.js', ['github:angular/bower-angular@1.4.1.js', 'components/auto-focus/auto-focus-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsAutoFocusAutoFocusDirectiveJs) {
      directive = _componentsAutoFocusAutoFocusDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.auto-focus', []).directive(directive.name, directive));
    }
  };
});

System.register('components/channel-list/channel-list-directive.js', ['components/channel-list/channel-list.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', tocChannelList);

  function tocChannelList() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'channelList',
      controller: function ChannelListController($q, $state, state, contacts, notification, $ionicHistory, $scope) {
        var _this = this;

        this.channelId = $state.params.channelId;

        var identityCursor = state.cloud.identity;
        var updateUserInfo = function updateUserInfo() {
          _this.userInfo = identityCursor.get('userInfo');
        };

        state.addListener(identityCursor, updateUserInfo, $scope);

        var networkCursor = state.cloud.network;
        var channelsCursor = networkCursor.select(['channels']);
        var updateChannels = function updateChannels() {
          _this.channels = channelsCursor.get();
        };

        state.addListener(channelsCursor, updateChannels, $scope);

        var contactsCursor = state.cloud.contacts;
        var updateContacts = function updateContacts() {
          _this.contacts = contactsCursor.get();
        };

        state.addListener(contactsCursor, updateContacts, $scope);

        this.inviteId = '';
        this.invite = function () {
          _this.inviting = contacts.invite(_this.inviteId).then(function () {
            _this.inviteId = '';
            return $q.when();
          })['catch'](function (error) {
            return notification.error(error, 'Contact Invite Send Error');
          });

          return _this.inviting;
        };

        this.invitesAccepting = {};

        this.acceptInvite = function (channelInfo) {
          _this.invitesAccepting[channelInfo.id] = contacts.invite(channelInfo.contactIds[0])['catch'](function (error) {
            return notification.error(error, 'Contact Invite Accept Error');
          });
          return _this.invitesAccepting[channelInfo.id];
        };

        this.goToChannel = function goToChannel(channelId) {
          var activeChannelId = state.cloud.network.get(['activeChannelId']);

          if (activeChannelId !== channelId) {
            state.save(state.cloud.network, ['activeChannelId'], channelId);
          }

          $ionicHistory.nextViewOptions({
            disableBack: true,
            disableAnimate: true
          });

          return $state.go('app.channel', { channelId: channelId });
        };

        this.goToHome = function goToHome() {
          var activeChannelId = state.cloud.network.get(['activeChannelId']);

          if (activeChannelId !== 'home') {
            state.save(state.cloud.network, ['activeChannelId'], 'home');
          }

          $ionicHistory.nextViewOptions({
            disableBack: true,
            disableAnimate: true
          });

          return $state.go('app.home');
        };
      }
    };
  }

  return {
    setters: [function (_componentsChannelListChannelListHtmlGithubSystemjsPluginText002Js) {
      template = _componentsChannelListChannelListHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('components/message-list/message-list-directive.js', ['components/message-list/message-list.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', tocMessageList);

  function tocMessageList(state, R, $ionicScrollDelegate) {
    return {
      restrict: 'E',
      template: template,
      scope: {
        channelId: '@'
      },
      link: function linkMessageList(scope) {
        var messagesCursor = state.cloud.network.select(['channels', scope.channelId, 'messages']);

        $ionicScrollDelegate.scrollBottom(false);

        var updateMessageListPosition = function updateMessageListPosition() {
          var scrollView = $ionicScrollDelegate.getScrollView();

          if (scrollView.__scrollTop !== scrollView.__maxScrollTop) {
            return;
          }

          $ionicScrollDelegate.scrollBottom(true);

          var messages = messagesCursor.get();

          R.pipe(R.values,
          //FIXME: figure out why R.not doesnt work here
          // R.filter(R.pipe(R.prop('isRead'), R.not),
          R.filter(R.pipe(R.prop('isRead'), function (bool) {
            return !bool;
          })), R.forEach(function (message) {
            return state.save(messagesCursor, [message.messageInfo.id, 'isRead'], true);
          }))(messages);
        };

        state.addListener(messagesCursor, updateMessageListPosition, scope, {
          skipInitialize: true
        });
      },
      controllerAs: 'messageList',
      controller: function MessageListController($scope, $state, $interval) {
        var _this = this;

        //TODO: clean up this whole thing (refactor message functions to service)
        // add state listeners and cleanup on destroy
        var channelsCursor = state.cloud.network.select('channels');

        var contactsCursor = state.cloud.contacts;
        var updateContacts = function updateContacts() {
          _this.contacts = contactsCursor.get();
        };

        state.addListener(contactsCursor, updateContacts, $scope);

        var identityCursor = state.cloud.identity;
        var updateUserInfo = function updateUserInfo() {
          _this.userInfo = identityCursor.get(['userInfo']);
        };

        state.addListener(identityCursor, updateUserInfo, $scope);

        var getMessageList = function getMessageList(messages) {
          return R.pipe(R.values, R.sort(function (message1, message2) {
            if (message1.messageInfo.logicalClock === message2.messageInfo.logicalClock) {
              return message1.messageInfo.id > message2.messageInfo.id ? 1 : -1;
            }

            return message1.messageInfo.logicalClock > message2.messageInfo.logicalClock ? 1 : -1;
          }), R.reduce(function (groupedMessages, message) {
            var messageVm = message.messageInfo;
            messageVm.isRead = message.isRead;

            if (groupedMessages.length === 0) {
              groupedMessages.push([messageVm]);
              return groupedMessages;
            }

            var latestGroup = groupedMessages[groupedMessages.length - 1];

            if (latestGroup[0].sender === messageVm.sender) {
              latestGroup.push(messageVm);
            } else {
              groupedMessages.push([messageVm]);
            }

            return groupedMessages;
          }, []))(messages);
        };

        var messagesCursor = state.cloud.network.select(['channels', $scope.channelId, 'messages']);
        var updateGroupedMessages = function updateGroupedMessages() {
          _this.groupedMessages = getMessageList(messagesCursor.get());
        };

        state.addListener(messagesCursor, updateGroupedMessages, $scope);

        $interval(function () {
          //Updates unread messages based on scroll position
          //TODO: write a more performant version of this
          var scrollView = $ionicScrollDelegate.getScrollView();

          if (scrollView.__scrollTop !== scrollView.__maxScrollTop) {
            if (!channelsCursor.get([$scope.channelId, 'viewingLatest'])) {
              return;
            }

            return state.save(channelsCursor, [$scope.channelId, 'viewingLatest'], false);
          }

          var messages = messagesCursor.get();

          R.pipe(R.values,
          //FIXME: figure out why R.not doesnt work here
          // R.filter(R.pipe(R.prop('isRead'), R.not),
          R.filter(R.pipe(R.prop('isRead'), function (bool) {
            return !bool;
          })), R.forEach(function (message) {
            return state.save(messagesCursor, [message.messageInfo.id, 'isRead'], true);
          }))(messages);

          if (channelsCursor.get([$scope.channelId, 'viewingLatest'])) {
            return;
          }
          state.save(channelsCursor, [$scope.channelId, 'viewingLatest'], true);
        }, 3000);
      }
    };
  }

  return {
    setters: [function (_componentsMessageListMessageListHtmlGithubSystemjsPluginText002Js) {
      template = _componentsMessageListMessageListHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('components/qr-image/qr-image.js', ['github:angular/bower-angular@1.4.1.js', 'components/qr-image/qr-image-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsQrImageQrImageDirectiveJs) {
      directive = _componentsQrImageQrImageDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.qr-image', []).directive(directive.name, directive));
    }
  };
});

System.register('components/spinner-button/spinner-button.js', ['github:angular/bower-angular@1.4.1.js', 'components/spinner-button/spinner-button-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsSpinnerButtonSpinnerButtonDirectiveJs) {
      directive = _componentsSpinnerButtonSpinnerButtonDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.spinner-button', []).directive(directive.name, directive));
    }
  };
});

System.register('components/signup-form/signup-form-directive.js', ['components/signup-form/signup-form.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', tocSignupForm);

  function tocSignupForm() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'signupForm',
      controller: function SignupFormController($q, $state, state, identity, network, notification, storage, $ionicHistory, $scope) {
        var _this2 = this;

        this.goBack = function goBack() {
          $ionicHistory.goBack();
        };

        this.newUser = {
          displayName: '',
          email: '',
          password: '',
          passwordConfirmation: ''
        };

        this.staySignedIn = false;

        this.createUser = function createUser(userInfo) {
          var _this = this;

          if (!userInfo.displayName) {
            userInfo.displayName = 'Anonymous';
          }

          this.signingUp = network.initialize().then(function (sessionInfo) {
            var options = {
              staySignedIn: _this.staySignedIn
            };

            return identity.initialize(sessionInfo.id).then(function () {
              return network.initializeChannels();
            }).then(function () {
              return identity.create(sessionInfo, userInfo, options);
            }).then(function (newUserInfo) {
              return state.save(state.cloudUnencrypted.identity, ['userInfo'], newUserInfo).then(function () {
                return state.cloud.initialize(newUserInfo.id);
              }).then(function () {
                return state.save(state.cloud.identity, ['userInfo'], newUserInfo);
              });
            }).then(function () {
              return state.save(state.cloud.network, ['sessions', sessionInfo.id, 'sessionInfo'], sessionInfo);
            });
          }).then(function () {
            $ionicHistory.nextViewOptions({
              historyRoot: true,
              disableBack: true
            });

            return $state.go('app.home');
          }).then(function () {
            return state.save(state.cloudUnencrypted.identity, ['latestSession'], Date.now());
          })['catch'](function (error) {
            return notification.error(error, 'User Creation Error').then(function () {
              return identity.destroy();
            });
          });

          return this.signingUp;
        };

        var savedUsersCursor = state.cloudUnencrypted.cursor;
        var updateSavedUsers = function updateSavedUsers() {
          _this2.users = savedUsersCursor.get();
        };

        state.addListener(savedUsersCursor, updateSavedUsers, $scope);
      }
    };
  }

  return {
    setters: [function (_componentsSignupFormSignupFormHtmlGithubSystemjsPluginText002Js) {
      template = _componentsSignupFormSignupFormHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('components/signin-form/signin-form-directive.js', ['components/signin-form/signin-form.html!github:systemjs/plugin-text@0.0.2.js', 'components/signin-form/signin-form-user-list.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template, userListTemplate;

  _export('default', tocSigninForm);

  function tocSigninForm() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'signinForm',
      controller: function SigninFormController($q, $state, $scope, state, identity, network, contacts, notification, signinForm, R, $ionicModal, $ionicHistory) {
        var _this = this;

        //TODO: refactor into state service .memory
        this.model = signinForm;

        this.goBack = function goBack() {
          $ionicHistory.goBack();
        };

        var savedUsersCursor = state.cloudUnencrypted.cursor;

        var updateSavedUsers = function updateSavedUsers() {
          _this.model.users = R.mapObj(R.prop('identity'))(savedUsersCursor.get());
          _this.model.userList = R.pipe(R.values, R.sortBy(function (user) {
            return user.latestSession ? user.latestSession * -1 : 0;
          }))(_this.model.users);
        };

        state.addListener(savedUsersCursor, updateSavedUsers, $scope);

        this.model.selectedUser = this.model.userList[0] ? this.model.userList[0].userInfo.id : undefined;
        this.model.password = '';
        this.model.staySignedIn = false;

        this.signIn = function (userCredentials) {
          var options = {
            staySignedIn: this.model.staySignedIn
          };

          this.signingIn = identity.initialize(userCredentials.id).then(function () {
            return identity.authenticate(userCredentials, options);
          }).then(function () {
            return state.cloud.initialize(userCredentials.id);
          }).then(function () {
            return contacts.initialize();
          }).then(function () {
            var sessionInfo = state.cloud.network.get(['sessions', userCredentials.id, 'sessionInfo']);

            return network.initialize(sessionInfo.keypair).then(function () {
              return network.initializeChannels();
            });
          }).then(function () {
            return state.save(state.cloudUnencrypted.identity, ['latestSession'], Date.now());
          }).then(function () {
            $ionicHistory.nextViewOptions({
              historyRoot: true,
              disableBack: true
            });

            return $state.go('app.home');
          })['catch'](function (error) {
            return notification.error(error, 'Authentication Error').then(function () {
              return identity.destroy();
            });
          });

          return this.signingIn;
        };

        $scope.model = signinForm;
        $scope.userListModal = $ionicModal.fromTemplate(userListTemplate, {
          scope: $scope,
          animation: 'slide-in-up'
        });

        this.userListModal = $scope.userListModal;
      }
    };
  }

  return {
    setters: [function (_componentsSigninFormSigninFormHtmlGithubSystemjsPluginText002Js) {
      template = _componentsSigninFormSigninFormHtmlGithubSystemjsPluginText002Js['default'];
    }, function (_componentsSigninFormSigninFormUserListHtmlGithubSystemjsPluginText002Js) {
      userListTemplate = _componentsSigninFormSigninFormUserListHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('components/cloud-connect-form/cloud-connect-form-directive.js', ['components/cloud-connect-form/cloud-connect-form.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', tocCloudConnectForm);

  function tocCloudConnectForm() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'cloudConnectForm',
      controller: function CloudConnectFormController($ionicHistory, $ionicPopup, $scope, notification, storage) {
        this.goBack = function goBack() {
          $ionicHistory.goBack();
        };

        this.selectedService = 'remotestorage';

        $scope.remoteStorage = {
          email: ''
        };

        $scope.submitRemoteStorageEmail = function (email) {
          if (!email) {
            //TODO: actually do validation here
            return notification.error('Please enter a valid email.', 'Validation Error');
          }

          storage.connect(email);
        };

        this.services = {
          'remotestorage': {
            id: 'remotestorage',
            name: 'remoteStorage',
            description: 'Use remoteStorage to store your data.',
            img: 'remotestorage.svg',
            connect: function connect() {
              var remoteStoragePopup = $ionicPopup.show({
                template: '\n                <form ng-submit="submitRemoteStorageEmail(remoteStorage.email)"\n                  novalidate>\n                  <input type="email" placeholder="Your remoteStorage email."\n                    ng-model="remoteStorage.email" toc-auto-focus>\n                </form>',
                title: 'RemoteStorage Email',
                scope: $scope,
                buttons: [{
                  text: 'Cancel',
                  type: 'button-outline button-calm'
                }, {
                  text: 'Connect',
                  type: 'button-outline button-balanced',
                  onTap: function onTap(event) {
                    if (!$scope.remoteStorage.email) {
                      event.preventDefault();
                    }

                    $scope.submitRemoteStorageEmail($scope.remoteStorage.email);
                  }
                }]
              });
            }
          },
          'dropbox': {
            id: 'dropbox',
            name: 'Dropbox',
            description: 'Use Dropbox to store your data. (Coming soon)',
            img: 'dropbox.svg',
            connect: function connectDropbox() {}
          },
          'googledrive': {
            id: 'googledrive',
            name: 'Google Drive',
            description: 'Use Google Drive to store your data. (Coming soon)',
            img: 'googledrive.svg',
            connect: function connectGoogledrive() {}
          }
        };

        this.serviceList = [this.services['remotestorage'], this.services['dropbox'], this.services['googledrive']];
      }
    };
  }

  return {
    setters: [function (_componentsCloudConnectFormCloudConnectFormHtmlGithubSystemjsPluginText002Js) {
      template = _componentsCloudConnectFormCloudConnectFormHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('components/cloud-manage-form/cloud-manage-form-directive.js', ['components/cloud-manage-form/cloud-manage-form.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', tocCloudManageForm);

  function tocCloudManageForm() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'cloudManageForm',
      controller: function CloudManageFormController() {}
    };
  }

  return {
    setters: [function (_componentsCloudManageFormCloudManageFormHtmlGithubSystemjsPluginText002Js) {
      template = _componentsCloudManageFormCloudManageFormHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('app-config.js', ['app.html!github:systemjs/plugin-text@0.0.2.js'], function (_export) {
  'use strict';

  var template;

  _export('default', configApp);

  function configApp($stateProvider, $urlRouterProvider, $ionicConfigProvider) {
    $ionicConfigProvider.tabs.position('bottom');
    $ionicConfigProvider.backButton.previousTitleText(false);
    $ionicConfigProvider.views.transition('android');
    // $ionicConfigProvider.views.maxCache(0);

    $stateProvider.state('app', {
      url: '/app',
      abstract: true,
      template: template
    });

    //OAuth token matching
    //http://localhost:8100/#access_token=a4fe6044356f389b512a9bd223816caa&state=%2Fapp%2Fhome
    // $urlRouterProvider.when(/#access_token=/)
    // $stateProvider.state('auth', {
    //   url: '/'
    // });
    // if none of the above states are matched, use this as the fallback
    //$urlRouterProvider.otherwise('/app/welcome');
  }

  return {
    setters: [function (_appHtmlGithubSystemjsPluginText002Js) {
      template = _appHtmlGithubSystemjsPluginText002Js['default'];
    }],
    execute: function () {}
  };
});

System.register('libraries/remote-storage/remote-storage.js', ['github:angular/bower-angular@1.4.1.js', 'npm:remotestoragejs@0.11.2.js'], function (_export) {
  'use strict';

  var angular, remoteStorage;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_npmRemotestoragejs0112Js) {
      remoteStorage = _npmRemotestoragejs0112Js['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.remote-storage', []).factory('remoteStorage', function () {
        return remoteStorage;
      }));
    }
  };
});

System.register('services/identity/identity.js', ['github:angular/bower-angular@1.4.1.js', 'services/storage/storage.js', 'services/state/state.js', 'services/identity/identity-service.js'], function (_export) {
    'use strict';

    var angular, storage, state, service;
    return {
        setters: [function (_githubAngularBowerAngular141Js) {
            angular = _githubAngularBowerAngular141Js['default'];
        }, function (_servicesStorageStorageJs) {
            storage = _servicesStorageStorageJs['default'];
        }, function (_servicesStateStateJs) {
            state = _servicesStateStateJs['default'];
        }, function (_servicesIdentityIdentityServiceJs) {
            service = _servicesIdentityIdentityServiceJs['default'];
        }],
        execute: function () {
            _export('default', angular.module('toc.services.identity', [storage.name, state.name]).factory(service.name, service));
        }
    };
});

System.register('services/network/network.js', ['github:angular/bower-angular@1.4.1.js', 'libraries/telehash/telehash.js', 'services/state/state.js', 'services/network/network-service.js'], function (_export) {
    'use strict';

    var angular, telehash, state, service;
    return {
        setters: [function (_githubAngularBowerAngular141Js) {
            angular = _githubAngularBowerAngular141Js['default'];
        }, function (_librariesTelehashTelehashJs) {
            telehash = _librariesTelehashTelehashJs['default'];
        }, function (_servicesStateStateJs) {
            state = _servicesStateStateJs['default'];
        }, function (_servicesNetworkNetworkServiceJs) {
            service = _servicesNetworkNetworkServiceJs['default'];
        }],
        execute: function () {
            _export('default', angular.module('toc.services.network', [telehash.name, state.name]).factory(service.name, service));
        }
    };
});

System.register('libraries/angular-toastr/angular-toastr.js', ['github:angular/bower-angular@1.4.1.js', 'npm:angular-toastr@1.3.1.js'], function (_export) {
  'use strict';

  var angular;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_npmAngularToastr131Js) {}],
    execute: function () {
      _export('default', angular.module('toc.libraries.angular-toastr', ['toastr']).factory('angularToastr', function (toastr) {
        return toastr;
      }));
    }
  };
});

System.register('libraries/moment/moment.js', ['github:angular/bower-angular@1.4.1.js', 'npm:moment@2.10.3.js'], function (_export) {
  'use strict';

  var angular, moment;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_npmMoment2103Js) {
      moment = _npmMoment2103Js['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.moment', []).factory('moment', function () {
        return moment;
      }));
    }
  };
});

System.register('views/channel/channel.js', ['github:angular/bower-angular@1.4.1.js', 'views/channel/channel-config.js', 'views/channel/channel-controller.js'], function (_export) {
  'use strict';

  var angular, config, controller;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_viewsChannelChannelConfigJs) {
      config = _viewsChannelChannelConfigJs['default'];
    }, function (_viewsChannelChannelControllerJs) {
      controller = _viewsChannelChannelControllerJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.views.channel', []).config(config).controller(controller.name, controller));
    }
  };
});

System.register('views/home/home.js', ['github:angular/bower-angular@1.4.1.js', 'views/home/home-config.js', 'views/home/home-controller.js'], function (_export) {
  'use strict';

  var angular, config, controller;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_viewsHomeHomeConfigJs) {
      config = _viewsHomeHomeConfigJs['default'];
    }, function (_viewsHomeHomeControllerJs) {
      controller = _viewsHomeHomeControllerJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.views.home', []).config(config).controller(controller.name, controller));

      // .factory(service.name, service);
    }
  };
});

System.register('views/welcome/welcome.js', ['github:angular/bower-angular@1.4.1.js', 'views/welcome/welcome-config.js', 'views/welcome/welcome-controller.js'], function (_export) {
  'use strict';

  var angular, config, controller;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_viewsWelcomeWelcomeConfigJs) {
      config = _viewsWelcomeWelcomeConfigJs['default'];
    }, function (_viewsWelcomeWelcomeControllerJs) {
      controller = _viewsWelcomeWelcomeControllerJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.views.welcome', []).config(config).controller(controller.name, controller));
    }
  };
});

System.register('views/signin/signin.js', ['github:angular/bower-angular@1.4.1.js', 'views/signin/signin-config.js'], function (_export) {
  'use strict';

  var angular, config;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_viewsSigninSigninConfigJs) {
      config = _viewsSigninSigninConfigJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.views.signin', []).config(config));
    }
  };
});

System.register('views/signup/signup.js', ['github:angular/bower-angular@1.4.1.js', 'views/signup/signup-config.js'], function (_export) {
  'use strict';

  var angular, config;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_viewsSignupSignupConfigJs) {
      config = _viewsSignupSignupConfigJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.views.signup', []).config(config));
    }
  };
});

System.register('views/cloud/cloud.js', ['github:angular/bower-angular@1.4.1.js', 'views/cloud/cloud-config.js', 'views/cloud/cloud-controller.js'], function (_export) {
  'use strict';

  var angular, config, controller;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_viewsCloudCloudConfigJs) {
      config = _viewsCloudCloudConfigJs['default'];
    }, function (_viewsCloudCloudControllerJs) {
      controller = _viewsCloudCloudControllerJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.views.cloud', []).config(config).controller(controller.name, controller));
    }
  };
});

System.register('components/header/header.js', ['github:angular/bower-angular@1.4.1.js', 'components/header/header-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsHeaderHeaderDirectiveJs) {
      directive = _componentsHeaderHeaderDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.header', []).directive(directive.name, directive));
    }
  };
});

System.register('components/channel-list/channel-list.js', ['github:angular/bower-angular@1.4.1.js', 'components/channel-list/channel-list-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsChannelListChannelListDirectiveJs) {
      directive = _componentsChannelListChannelListDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.channel-list', []).directive(directive.name, directive));
    }
  };
});

System.register('components/message-list/message-list.js', ['github:angular/bower-angular@1.4.1.js', 'components/message-list/message-list-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsMessageListMessageListDirectiveJs) {
      directive = _componentsMessageListMessageListDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.message-list', []).directive(directive.name, directive));
    }
  };
});

System.register('components/signup-form/signup-form.js', ['github:angular/bower-angular@1.4.1.js', 'components/signup-form/signup-form-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsSignupFormSignupFormDirectiveJs) {
      directive = _componentsSignupFormSignupFormDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.signup-form', []).directive(directive.name, directive));
    }
  };
});

System.register('components/signin-form/signin-form.js', ['github:angular/bower-angular@1.4.1.js', 'components/signin-form/signin-form-directive.js', 'components/signin-form/signin-form-service.js'], function (_export) {
  'use strict';

  var angular, directive, service;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsSigninFormSigninFormDirectiveJs) {
      directive = _componentsSigninFormSigninFormDirectiveJs['default'];
    }, function (_componentsSigninFormSigninFormServiceJs) {
      service = _componentsSigninFormSigninFormServiceJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.signin-form', []).directive(directive.name, directive).factory(service.name, service));
    }
  };
});

System.register('components/cloud-connect-form/cloud-connect-form.js', ['github:angular/bower-angular@1.4.1.js', 'components/cloud-connect-form/cloud-connect-form-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsCloudConnectFormCloudConnectFormDirectiveJs) {
      directive = _componentsCloudConnectFormCloudConnectFormDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.cloud-connect-form', []).directive(directive.name, directive));
    }
  };
});

System.register('components/cloud-manage-form/cloud-manage-form.js', ['github:angular/bower-angular@1.4.1.js', 'components/cloud-manage-form/cloud-manage-form-directive.js'], function (_export) {
  'use strict';

  var angular, directive;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsCloudManageFormCloudManageFormDirectiveJs) {
      directive = _componentsCloudManageFormCloudManageFormDirectiveJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components.cloud-manage-form', []).directive(directive.name, directive));
    }
  };
});

System.register('services/notification/notification.js', ['github:angular/bower-angular@1.4.1.js', 'libraries/angular-toastr/angular-toastr.js', 'services/state/state.js', 'services/notification/notification-service.js'], function (_export) {
  'use strict';

  var angular, angularToastr, state, service;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_librariesAngularToastrAngularToastrJs) {
      angularToastr = _librariesAngularToastrAngularToastrJs['default'];
    }, function (_servicesStateStateJs) {
      state = _servicesStateStateJs['default'];
    }, function (_servicesNotificationNotificationServiceJs) {
      service = _servicesNotificationNotificationServiceJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.services.notification', [angularToastr.name, state.name]).config(function (toastrConfig) {
        angular.extend(toastrConfig, {
          allowHtml: false,
          closeButton: false,
          closeHtml: '<button><i class="icon ion-close"></i></button>',
          containerId: 'toast-container',
          extendedTimeOut: 1000,
          iconClasses: {
            error: 'toast-error ion-close-circled',
            info: 'toast-info ion-ios-information',
            success: 'toast-success ion-checkmark-circled',
            warning: 'toast-warning ion-android-warning'
          },
          maxOpened: 0,
          messageClass: 'toast-message',
          newestOnTop: false,
          onHidden: null,
          onShown: null,
          positionClass: 'toast-top-right',
          tapToDismiss: true,
          target: 'body',
          timeOut: 5000,
          titleClass: 'toast-title',
          toastClass: 'toast'
        });
      }).factory(service.name, service));
    }
  };
});

System.register('services/time/time.js', ['github:angular/bower-angular@1.4.1.js', 'libraries/moment/moment.js', 'services/time/time-service.js'], function (_export) {
    'use strict';

    var angular, moment, service;
    return {
        setters: [function (_githubAngularBowerAngular141Js) {
            angular = _githubAngularBowerAngular141Js['default'];
        }, function (_librariesMomentMomentJs) {
            moment = _librariesMomentMomentJs['default'];
        }, function (_servicesTimeTimeServiceJs) {
            service = _servicesTimeTimeServiceJs['default'];
        }],
        execute: function () {
            _export('default', angular.module('toc.services.time', [moment.name]).factory(service.name, service));
        }
    };
});

System.register('views/views.js', ['github:angular/bower-angular@1.4.1.js', 'views/channel/channel.js', 'views/home/home.js', 'views/welcome/welcome.js', 'views/signin/signin.js', 'views/signup/signup.js', 'views/cloud/cloud.js'], function (_export) {
  'use strict';

  var angular, channel, home, welcome, signin, signup, cloud;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_viewsChannelChannelJs) {
      channel = _viewsChannelChannelJs['default'];
    }, function (_viewsHomeHomeJs) {
      home = _viewsHomeHomeJs['default'];
    }, function (_viewsWelcomeWelcomeJs) {
      welcome = _viewsWelcomeWelcomeJs['default'];
    }, function (_viewsSigninSigninJs) {
      signin = _viewsSigninSigninJs['default'];
    }, function (_viewsSignupSignupJs) {
      signup = _viewsSignupSignupJs['default'];
    }, function (_viewsCloudCloudJs) {
      cloud = _viewsCloudCloudJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.views', [channel.name, home.name, welcome.name, signin.name, signup.name, cloud.name]));
    }
  };
});

System.register('components/components.js', ['github:angular/bower-angular@1.4.1.js', 'components/header/header.js', 'components/auto-focus/auto-focus.js', 'components/channel-list/channel-list.js', 'components/message-list/message-list.js', 'components/qr-image/qr-image.js', 'components/spinner-button/spinner-button.js', 'components/signup-form/signup-form.js', 'components/signin-form/signin-form.js', 'components/cloud-connect-form/cloud-connect-form.js', 'components/cloud-manage-form/cloud-manage-form.js'], function (_export) {
  'use strict';

  var angular, header, autoFocus, channelList, messageList, qrImage, spinnerButton, signupForm, signinForm, cloudConnectForm, cloudManageForm;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_componentsHeaderHeaderJs) {
      header = _componentsHeaderHeaderJs['default'];
    }, function (_componentsAutoFocusAutoFocusJs) {
      autoFocus = _componentsAutoFocusAutoFocusJs['default'];
    }, function (_componentsChannelListChannelListJs) {
      channelList = _componentsChannelListChannelListJs['default'];
    }, function (_componentsMessageListMessageListJs) {
      messageList = _componentsMessageListMessageListJs['default'];
    }, function (_componentsQrImageQrImageJs) {
      qrImage = _componentsQrImageQrImageJs['default'];
    }, function (_componentsSpinnerButtonSpinnerButtonJs) {
      spinnerButton = _componentsSpinnerButtonSpinnerButtonJs['default'];
    }, function (_componentsSignupFormSignupFormJs) {
      signupForm = _componentsSignupFormSignupFormJs['default'];
    }, function (_componentsSigninFormSigninFormJs) {
      signinForm = _componentsSigninFormSigninFormJs['default'];
    }, function (_componentsCloudConnectFormCloudConnectFormJs) {
      cloudConnectForm = _componentsCloudConnectFormCloudConnectFormJs['default'];
    }, function (_componentsCloudManageFormCloudManageFormJs) {
      cloudManageForm = _componentsCloudManageFormCloudManageFormJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components', [header.name, autoFocus.name, channelList.name, messageList.name, qrImage.name, spinnerButton.name, signupForm.name, signinForm.name, cloudConnectForm.name, cloudManageForm.name]));
    }
  };
});

System.register('libraries/ionic/ionic.js', ['github:driftyco/ionic@1.0.0.js'], function (_export) {
  'use strict';

  return {
    setters: [function (_githubDriftycoIonic100Js) {}],
    execute: function () {}
  };
});

System.register('libraries/qr-encode/qr-encode.js', ['github:angular/bower-angular@1.4.1.js', 'npm:qr-encode@0.3.0.js'], function (_export) {
  'use strict';

  var angular, qrEncode;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_npmQrEncode030Js) {
      qrEncode = _npmQrEncode030Js['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.qr-encode', []).factory('qrEncode', function () {
        return qrEncode;
      }));
    }
  };
});

System.register('libraries/ramda/ramda.js', ['github:angular/bower-angular@1.4.1.js', 'npm:ramda@0.11.0.js'], function (_export) {
  'use strict';

  var angular, R;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_npmRamda0110Js) {
      R = _npmRamda0110Js['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.ramda', []).factory('R', function () {
        return R;
      }));
    }
  };
});

System.register('services/storage/storage-service.js', ['npm:babel-runtime@5.5.8/core-js/object/assign.js'], function (_export) {
  var _Object$assign;

  function storage($window, $q, remoteStorage, cryptography, R, notification) {
    //FIXME: storage usage is extremely high due to really long keys + storing
    // crypto settings with each item/key
    var DEFAULT_ACCESS_LEVEL = 'rw';
    var STORAGE_MODULE_PREFIX = 'toc-state-';
    var KEY_SEPARATOR = '.';

    var getStorageKey = R.join(KEY_SEPARATOR);

    var connect = function connect(email) {
      return remoteStorage.remoteStorage.connect(email);
    };

    var isConnected = function isConnected() {
      return remoteStorage.remoteStorage.connected;
    };

    var prepare = function prepareStorage() {
      var deferredStorageReady = $q.defer();

      remoteStorage.remoteStorage.on('ready', function () {
        return deferredStorageReady.resolve();
      });

      return deferredStorageReady.promise;
    };

    var enableLog = remoteStorage.remoteStorage.enableLog;

    var enableCaching = function enableCaching() {
      var path = arguments[0] === undefined ? '/' : arguments[0];

      remoteStorage.remoteStorage.caching.enable(path);
    };

    var claimAccess = function claimAccess(moduleName) {
      var accessLevel = arguments[1] === undefined ? DEFAULT_ACCESS_LEVEL : arguments[1];

      remoteStorage.remoteStorage.access.claim(STORAGE_MODULE_PREFIX + moduleName, accessLevel);
    };

    var buildModule = function buildModule(privateClient) {
      privateClient.declareType(cryptography.ENCRYPTED_OBJECT.name, cryptography.ENCRYPTED_OBJECT.schema);

      var storeObject = function storeObject(key, object) {
        var encryptedObject = cryptography.encrypt(object);
        var encryptedKey = cryptography.escapeBase64(JSON.stringify(cryptography.encryptDeterministic(key)));

        return $q.when(privateClient.storeObject(cryptography.ENCRYPTED_OBJECT.name, encryptedKey, encryptedObject)).then(function () {
          return object;
        });
      };

      var getObject = function getObject(key) {
        var encryptedKey = cryptography.escapeBase64(JSON.stringify(cryptography.encryptDeterministic(key)));

        return $q.when(privateClient.getObject(encryptedKey, false)).then(cryptography.decrypt);
      };

      var removeObject = function removeObject(key) {
        var encryptedKey = cryptography.escapeBase64(JSON.stringify(cryptography.encryptDeterministic(key)));

        return $q.when(privateClient.remove(encryptedKey)).then(function () {
          return key;
        });
      };

      var getAllObjects = function getAllObjects() {
        //all encrypted paths are under root
        var key = '';

        return $q.when(privateClient.getAll(key, false)).then(function (encryptedKeyObjectMap) {
          var decryptedKeyObjectPairs = R.pipe(R.toPairs, R.map(function (encryptedKeyObjectPair) {
            var decryptedKeyObjectPair = undefined;

            try {
              decryptedKeyObjectPair = [cryptography.decrypt(JSON.parse(cryptography.unescapeBase64(encryptedKeyObjectPair[0]))), cryptography.decrypt(encryptedKeyObjectPair[1])];
            } catch (error) {
              // Assuming failed decryption indicates data belonging to
              // a different account and filter out
              if (error.message === 'cryptography: decryption failed') {
                return undefined;
              }

              notification.error(error.message, 'Storage Get Error');
              return undefined;
            }

            return decryptedKeyObjectPair;
          }), R.filter(function (keyObjectPair) {
            return keyObjectPair !== undefined;
          }))(encryptedKeyObjectMap);

          return decryptedKeyObjectPairs;
        });
      };

      var onChange = function onChange(handleChange) {
        privateClient.on('change', function handleStorageChange(event) {
          if (!cryptography.isInitialized()) {
            return;
          }

          try {
            var decryptedEvent = _Object$assign({}, event);

            decryptedEvent.relativePath = event.relativePath ? cryptography.decrypt(JSON.parse(cryptography.unescapeBase64(event.relativePath))) : event.relativePath;

            decryptedEvent.newValue = event.newValue ? cryptography.decrypt(event.newValue) : event.newValue;

            decryptedEvent.oldValue = event.oldValue ? cryptography.decrypt(event.oldValue) : event.oldValue;

            handleChange(decryptedEvent);
          } catch (error) {
            // Assuming failed decryption indicates data belonging to
            // a different account and ignore
            if (error.message === 'cryptography: decryption failed') {
              return;
            }

            return notification.error(error.message, 'Storage Sync Error');
          }
        });
      };

      var initialize = function initialize() {
        privateClient.cache('');
      };

      return {
        exports: {
          storeObject: storeObject,
          getObject: getObject,
          removeObject: removeObject,
          getAllObjects: getAllObjects,
          onChange: onChange,
          initialize: initialize
        }
      };
    };

    var buildModuleUnencrypted = function buildModuleUnencrypted(privateClient) {
      privateClient.declareType(cryptography.UNENCRYPTED_OBJECT.name, cryptography.UNENCRYPTED_OBJECT.schema);

      var storeObject = function storeObject(key, object) {
        var unencryptedObject = {
          pt: JSON.stringify(object)
        };

        return $q.when(privateClient.storeObject(cryptography.UNENCRYPTED_OBJECT.name, key, unencryptedObject)).then(function () {
          return object;
        });
      };

      var getObject = function getObject(key) {
        return $q.when(privateClient.getObject(key, false)).then(function (unencryptedObject) {
          return JSON.parse(unencryptedObject.pt);
        });
      };

      var removeObject = function removeObject(key) {
        return $q.when(privateClient.remove(key)).then(function () {
          return key;
        });
      };

      var getAllObjects = function getAllObjects() {
        //all encrypted paths are under root
        var key = '';

        return $q.when(privateClient.getAll(key, false)).then(function (keyObjectMap) {
          var keyObjectPairs = R.pipe(R.toPairs, R.map(function (keyObjectPair) {
            return [keyObjectPair[0], JSON.parse(keyObjectPair[1].pt)];
          }))(keyObjectMap);

          return keyObjectPairs;
        });
      };

      var onChange = function onChange(handleChange) {
        privateClient.on('change', function handleStorageChange(event) {
          var unwrappedEvent = _Object$assign({}, event);

          unwrappedEvent.newValue = event.newValue ? JSON.parse(event.newValue.pt) : event.newValue;

          unwrappedEvent.oldValue = event.oldValue ? JSON.parse(event.oldValue.pt) : event.oldValue;

          handleChange(unwrappedEvent);
        });
      };

      var initialize = function initialize() {
        privateClient.cache('');
      };

      return {
        exports: {
          storeObject: storeObject,
          getObject: getObject,
          removeObject: removeObject,
          getAllObjects: getAllObjects,
          onChange: onChange,
          initialize: initialize
        }
      };
    };

    var createLocal = function createLocal() {
      var moduleName = arguments[0] === undefined ? 'local' : arguments[0];

      var KEY_PREFIX = STORAGE_MODULE_PREFIX + moduleName + KEY_SEPARATOR;

      var getObject = function getObjectLocal(key) {
        var object = JSON.parse($window.localStorage.getItem(KEY_PREFIX + key));
        return $q.when(object);
      };

      var getObjectSync = function getObjectSyncLocal(key) {
        return JSON.parse($window.localStorage.getItem(KEY_PREFIX + key));
      };

      var removeObject = function removeObjectLocal(key) {
        $window.localStorage.removeItem(KEY_PREFIX + key);
        return $q.when(key);
      };

      var getAllObjects = function getAllObjectsLocal() {
        var objects = R.pipe(R.keys, R.filter(function (key) {
          return key.startsWith(KEY_PREFIX);
        }), R.map(function (key) {
          return [key.substr(KEY_PREFIX.length), getObjectSync(key.substr(KEY_PREFIX.length))];
        }))($window.localStorage);

        return $q.when(objects);
      };

      var storeObject = function storeObjectLocal(key, object) {
        $window.localStorage.setItem(KEY_PREFIX + key, JSON.stringify(object));
        return $q.when(object);
      };

      var storeObjectSync = function storeObjectLocalSync(key, object) {
        $window.localStorage.setItem(KEY_PREFIX + key, JSON.stringify(object));
        return object;
      };

      return {
        getObject: getObject,
        getObjectSync: getObjectSync,
        removeObject: removeObject,
        getAllObjects: getAllObjects,
        storeObject: storeObject,
        storeObjectSync: storeObjectSync
      };
    };

    var createCloud = function createCloud() {
      var moduleName = arguments[0] === undefined ? 'cloud' : arguments[0];

      remoteStorage.RemoteStorage.defineModule(STORAGE_MODULE_PREFIX + moduleName, buildModule);

      return remoteStorage.remoteStorage[STORAGE_MODULE_PREFIX + moduleName];
    };

    var createCloudUnencrypted = function createCloudUnencrypted() {
      var moduleName = arguments[0] === undefined ? 'cloud-unencrypted' : arguments[0];

      remoteStorage.RemoteStorage.defineModule(STORAGE_MODULE_PREFIX + moduleName, buildModuleUnencrypted);

      return remoteStorage.remoteStorage[STORAGE_MODULE_PREFIX + moduleName];
    };

    var storageService = {
      KEY_SEPARATOR: KEY_SEPARATOR,
      prepare: prepare,
      getStorageKey: getStorageKey,
      connect: connect,
      isConnected: isConnected,
      claimAccess: claimAccess,
      createLocal: createLocal,
      createCloud: createCloud,
      createCloudUnencrypted: createCloudUnencrypted
    };

    var initialize = function initialize() {
      enableLog();
      enableCaching();

      storageService.local = createLocal();
      storageService.cloud = createCloud();
      storageService.cloud.initialize();
      storageService.cloudUnencrypted = createCloudUnencrypted();
      storageService.cloudUnencrypted.initialize();

      claimAccess('cloud');
      claimAccess('cloud-unencrypted');
    };

    storageService.initialize = initialize;

    return storageService;
  }

  return {
    setters: [function (_npmBabelRuntime558CoreJsObjectAssignJs) {
      _Object$assign = _npmBabelRuntime558CoreJsObjectAssignJs['default'];
    }],
    execute: function () {
      'use strict';

      _export('default', storage);
    }
  };
});

System.register('services/storage/storage.js', ['github:angular/bower-angular@1.4.1.js', 'libraries/remote-storage/remote-storage.js', 'services/storage/storage-service.js'], function (_export) {
    'use strict';

    var angular, remoteStorage, service;
    return {
        setters: [function (_githubAngularBowerAngular141Js) {
            angular = _githubAngularBowerAngular141Js['default'];
        }, function (_librariesRemoteStorageRemoteStorageJs) {
            remoteStorage = _librariesRemoteStorageRemoteStorageJs['default'];
        }, function (_servicesStorageStorageServiceJs) {
            service = _servicesStorageStorageServiceJs['default'];
        }],
        execute: function () {
            _export('default', angular.module('toc.services.storage', [remoteStorage.name]).factory(service.name, service));
        }
    };
});

System.register('libraries/baobab/baobab.js', ['github:angular/bower-angular@1.4.1.js', 'npm:baobab@1.1.1.js'], function (_export) {
  'use strict';

  var angular, Baobab;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_npmBaobab111Js) {
      Baobab = _npmBaobab111Js['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.baobab', []).factory('Baobab', function () {
        return Baobab;
      }));
    }
  };
});

System.register('services/contacts/contacts.js', ['github:angular/bower-angular@1.4.1.js', 'libraries/ramda/ramda.js', 'services/storage/storage.js', 'services/contacts/contacts-service.js'], function (_export) {
    'use strict';

    var angular, ramda, storage, service;
    return {
        setters: [function (_githubAngularBowerAngular141Js) {
            angular = _githubAngularBowerAngular141Js['default'];
        }, function (_librariesRamdaRamdaJs) {
            ramda = _librariesRamdaRamdaJs['default'];
        }, function (_servicesStorageStorageJs) {
            storage = _servicesStorageStorageJs['default'];
        }, function (_servicesContactsContactsServiceJs) {
            service = _servicesContactsContactsServiceJs['default'];
        }],
        execute: function () {
            _export('default', angular.module('toc.services.contacts', [ramda.name, storage.name]).factory(service.name, service));
        }
    };
});

System.register('libraries/libraries.js', ['github:angular/bower-angular@1.4.1.js', 'libraries/ionic/ionic.js', 'libraries/baobab/baobab.js', 'libraries/angular-toastr/angular-toastr.js', 'libraries/moment/moment.js', 'libraries/ramda/ramda.js', 'libraries/remote-storage/remote-storage.js', 'libraries/qr-encode/qr-encode.js', 'libraries/forge/forge.js', 'libraries/telehash/telehash.js'], function (_export) {
  'use strict';

  var angular, Baobab, angularToastr, moment, ramda, remoteStorage, qrEncode, forge, telehash;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_librariesIonicIonicJs) {}, function (_librariesBaobabBaobabJs) {
      Baobab = _librariesBaobabBaobabJs['default'];
    }, function (_librariesAngularToastrAngularToastrJs) {
      angularToastr = _librariesAngularToastrAngularToastrJs['default'];
    }, function (_librariesMomentMomentJs) {
      moment = _librariesMomentMomentJs['default'];
    }, function (_librariesRamdaRamdaJs) {
      ramda = _librariesRamdaRamdaJs['default'];
    }, function (_librariesRemoteStorageRemoteStorageJs) {
      remoteStorage = _librariesRemoteStorageRemoteStorageJs['default'];
    }, function (_librariesQrEncodeQrEncodeJs) {
      qrEncode = _librariesQrEncodeQrEncodeJs['default'];
    }, function (_librariesForgeForgeJs) {
      forge = _librariesForgeForgeJs['default'];
    }, function (_librariesTelehashTelehashJs) {
      telehash = _librariesTelehashTelehashJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries', [angularToastr.name, Baobab.name, forge.name, moment.name, ramda.name, remoteStorage.name, qrEncode.name, telehash.name]));
    }
  };
});

System.register('libraries/forge/forge.js', ['github:angular/bower-angular@1.4.1.js', 'npm:node-forge@0.6.30.js'], function (_export) {
  'use strict';

  var angular, forge;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_npmNodeForge0630Js) {
      forge = _npmNodeForge0630Js['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.forge', []).factory('forge', function () {
        return forge;
      }));
    }
  };
});

System.register('services/cryptography/cryptography.js', ['github:angular/bower-angular@1.4.1.js', 'libraries/forge/forge.js', 'services/cryptography/cryptography-service.js'], function (_export) {
    'use strict';

    var angular, forge, service;
    return {
        setters: [function (_githubAngularBowerAngular141Js) {
            angular = _githubAngularBowerAngular141Js['default'];
        }, function (_librariesForgeForgeJs) {
            forge = _librariesForgeForgeJs['default'];
        }, function (_servicesCryptographyCryptographyServiceJs) {
            service = _servicesCryptographyCryptographyServiceJs['default'];
        }],
        execute: function () {
            _export('default', angular.module('toc.services.cryptography', [forge.name]).factory(service.name, service));
        }
    };
});

System.register('services/services.js', ['github:angular/bower-angular@1.4.1.js', 'services/contacts/contacts.js', 'services/identity/identity.js', 'services/navigation/navigation.js', 'services/network/network.js', 'services/notification/notification.js', 'services/storage/storage.js', 'services/cryptography/cryptography.js', 'services/state/state.js', 'services/time/time.js'], function (_export) {
  'use strict';

  // import contacts from './contacts/contacts';
  var angular, contacts, identity, navigation, network, notification, storage, cryptography, state, time;
  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_servicesContactsContactsJs) {
      contacts = _servicesContactsContactsJs['default'];
    }, function (_servicesIdentityIdentityJs) {
      identity = _servicesIdentityIdentityJs['default'];
    }, function (_servicesNavigationNavigationJs) {
      navigation = _servicesNavigationNavigationJs['default'];
    }, function (_servicesNetworkNetworkJs) {
      network = _servicesNetworkNetworkJs['default'];
    }, function (_servicesNotificationNotificationJs) {
      notification = _servicesNotificationNotificationJs['default'];
    }, function (_servicesStorageStorageJs) {
      storage = _servicesStorageStorageJs['default'];
    }, function (_servicesCryptographyCryptographyJs) {
      cryptography = _servicesCryptographyCryptographyJs['default'];
    }, function (_servicesStateStateJs) {
      state = _servicesStateStateJs['default'];
    }, function (_servicesTimeTimeJs) {
      time = _servicesTimeTimeJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.services', [
      // contacts.name,
      contacts.name, identity.name, navigation.name, network.name, notification.name, storage.name, cryptography.name, state.name, time.name]));
    }
  };
});

System.register('app.js', ['github:angular/bower-angular@1.4.1.js', 'app.css!github:systemjs/plugin-css@0.1.12.js', 'services/services.js', 'libraries/libraries.js', 'views/views.js', 'components/components.js', 'app-run.js', 'app-config.js', 'app-controller.js'], function (_export) {
  'use strict';

  var angular, services, libraries, views, components, run, config, controller, appName;

  _export('initialize', initialize);

  function initialize() {
    angular.element(document).ready(function bootstrap() {
      angular.bootstrap(document.querySelector('[data-toc-app]'), [appName]);
    });
  }

  return {
    setters: [function (_githubAngularBowerAngular141Js) {
      angular = _githubAngularBowerAngular141Js['default'];
    }, function (_appCssGithubSystemjsPluginCss0112Js) {}, function (_servicesServicesJs) {
      services = _servicesServicesJs['default'];
    }, function (_librariesLibrariesJs) {
      libraries = _librariesLibrariesJs['default'];
    }, function (_viewsViewsJs) {
      views = _viewsViewsJs['default'];
    }, function (_componentsComponentsJs) {
      components = _componentsComponentsJs['default'];
    }, function (_appRunJs) {
      run = _appRunJs['default'];
    }, function (_appConfigJs) {
      config = _appConfigJs['default'];
    }, function (_appControllerJs) {
      controller = _appControllerJs['default'];
    }],
    execute: function () {
      appName = 'toc';

      _export('default', angular.module(appName, ['ionic', services.name, libraries.name, views.name, components.name]).config(config).run(run).controller(controller.name, controller));
    }
  };
});

System.register('app.css!github:systemjs/plugin-css@0.1.12.js', [], false, function() {});
(function(c){var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
("@charset \"UTF-8\";/*!\n  Ionicons, v2.0.1\n  Created by Ben Sperry for the Ionic Framework, http://ionicons.com/\n  https://twitter.com/benjsperry  https://twitter.com/ionicframework\n  MIT License: https://github.com/driftyco/ionicons\n\n  Android-style icons originally built by Googles\n  Material Design Icons: https://github.com/google/material-design-icons\n  used under CC BY http://creativecommons.org/licenses/by/4.0/\n  Modified icons to fit ionicons grid from original.\n*/#toast-container *,*,:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box}.ionic-body,.scroll,body{-moz-text-size-adjust:none}.scroll-bar-indicator,.toast.ng-enter,.toast.ng-leave{transition:opacity .3s linear}.backdrop,.ng-animate .scroll-bar{visibility:hidden}.tabs,ion-infinite-scroll{-webkit-box-orient:horizontal}.popup-container.active .popup,.popup-container.popup-hidden .popup{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}.bar .title,.tab-item{white-space:nowrap;text-overflow:ellipsis}.disable-user-behavior,.ionic-body,a,body,img{-webkit-user-drag:none}.disable-user-behavior,.ionic-body,a,body{-webkit-tap-highlight-color:transparent}.disable-user-behavior,.ionic-body,.scroll,body{-webkit-touch-callout:none}.bar,.ionic-body,.scroll,body,html{user-select:none;-ms-user-select:none;-moz-user-select:none}.bar,.disable-user-behavior,.ionic-body,.scroll,body,html{-webkit-user-select:none}.block,.block:after,.button-bar.button-bar-inline:after,.button-block:after,.clearfix:after{clear:both}.popup-buttons,.popup-container .popup,.tabs,.toc-flex-container,ion-infinite-scroll{-webkit-box-direction:normal}.toast-title{font-weight:700}.toast-message{-ms-word-wrap:break-word;word-wrap:break-word}.toast-message a,.toast-message label{color:#fff}.toast-message a:hover{color:#ccc;text-decoration:none}.toast-close-button{position:relative;right:-.3em;top:-.3em;float:right;font-size:20px;font-weight:700;color:#fff;-webkit-text-shadow:0 1px 0 #fff;text-shadow:0 1px 0 #fff;opacity:.8;-ms-filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=80);filter:alpha(opacity=80)}.toast-close-button:focus,.toast-close-button:hover{color:#000;text-decoration:none;cursor:pointer;opacity:.4;-ms-filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=40);filter:alpha(opacity=40)}button.toast-close-button{padding:0;cursor:pointer;background:0 0;border:0;-webkit-appearance:none}.toast-top-center{top:0;right:0;width:100%}.toast-bottom-center{bottom:0;right:0;width:100%}.toast-top-full-width{top:0;right:0;width:100%}.toast-bottom-full-width{bottom:0;right:0;width:100%}.toast-top-left{top:12px;left:12px}.toast-top-right{right:12px}.toast-bottom-right{right:12px;bottom:12px}.toast-bottom-left{bottom:12px;left:12px}#toast-container{position:fixed;z-index:999999}#toast-container *{box-sizing:border-box}hr,input[type=search]{-moz-box-sizing:content-box;box-sizing:content-box}#toast-container>div{position:relative;margin:0 0 6px;-moz-border-radius:3px;-webkit-border-radius:3px;background-position:15px center;background-repeat:no-repeat;-moz-box-shadow:0 0 12px #999;-webkit-box-shadow:0 0 12px #999;color:#fff;opacity:.8;-ms-filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=80);filter:alpha(opacity=80)}#toast-container>:hover{-moz-box-shadow:0 0 12px #000;-webkit-box-shadow:0 0 12px #000;box-shadow:0 0 12px #000;opacity:1;-ms-filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);filter:alpha(opacity=100);cursor:pointer}#toast-container>.toast-info{background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGwSURBVEhLtZa9SgNBEMc9sUxxRcoUKSzSWIhXpFMhhYWFhaBg4yPYiWCXZxBLERsLRS3EQkEfwCKdjWJAwSKCgoKCcudv4O5YLrt7EzgXhiU3/4+b2ckmwVjJSpKkQ6wAi4gwhT+z3wRBcEz0yjSseUTrcRyfsHsXmD0AmbHOC9Ii8VImnuXBPglHpQ5wwSVM7sNnTG7Za4JwDdCjxyAiH3nyA2mtaTJufiDZ5dCaqlItILh1NHatfN5skvjx9Z38m69CgzuXmZgVrPIGE763Jx9qKsRozWYw6xOHdER+nn2KkO+Bb+UV5CBN6WC6QtBgbRVozrahAbmm6HtUsgtPC19tFdxXZYBOfkbmFJ1VaHA1VAHjd0pp70oTZzvR+EVrx2Ygfdsq6eu55BHYR8hlcki+n+kERUFG8BrA0BwjeAv2M8WLQBtcy+SD6fNsmnB3AlBLrgTtVW1c2QN4bVWLATaIS60J2Du5y1TiJgjSBvFVZgTmwCU+dAZFoPxGEEs8nyHC9Bwe2GvEJv2WXZb0vjdyFT4Cxk3e/kIqlOGoVLwwPevpYHT+00T+hWwXDf4AJAOUqWcDhbwAAAAASUVORK5CYII=')!important}#toast-container>.toast-error{background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHOSURBVEhLrZa/SgNBEMZzh0WKCClSCKaIYOED+AAKeQQLG8HWztLCImBrYadgIdY+gIKNYkBFSwu7CAoqCgkkoGBI/E28PdbLZmeDLgzZzcx83/zZ2SSXC1j9fr+I1Hq93g2yxH4iwM1vkoBWAdxCmpzTxfkN2RcyZNaHFIkSo10+8kgxkXIURV5HGxTmFuc75B2RfQkpxHG8aAgaAFa0tAHqYFfQ7Iwe2yhODk8+J4C7yAoRTWI3w/4klGRgR4lO7Rpn9+gvMyWp+uxFh8+H+ARlgN1nJuJuQAYvNkEnwGFck18Er4q3egEc/oO+mhLdKgRyhdNFiacC0rlOCbhNVz4H9FnAYgDBvU3QIioZlJFLJtsoHYRDfiZoUyIxqCtRpVlANq0EU4dApjrtgezPFad5S19Wgjkc0hNVnuF4HjVA6C7QrSIbylB+oZe3aHgBsqlNqKYH48jXyJKMuAbiyVJ8KzaB3eRc0pg9VwQ4niFryI68qiOi3AbjwdsfnAtk0bCjTLJKr6mrD9g8iq/S/B81hguOMlQTnVyG40wAcjnmgsCNESDrjme7wfftP4P7SP4N3CJZdvzoNyGq2c/HWOXJGsvVg+RA/k2MC/wN6I2YA2Pt8GkAAAAASUVORK5CYII=')!important}#toast-container>.toast-success{background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADsSURBVEhLY2AYBfQMgf///3P8+/evAIgvA/FsIF+BavYDDWMBGroaSMMBiE8VC7AZDrIFaMFnii3AZTjUgsUUWUDA8OdAH6iQbQEhw4HyGsPEcKBXBIC4ARhex4G4BsjmweU1soIFaGg/WtoFZRIZdEvIMhxkCCjXIVsATV6gFGACs4Rsw0EGgIIH3QJYJgHSARQZDrWAB+jawzgs+Q2UO49D7jnRSRGoEFRILcdmEMWGI0cm0JJ2QpYA1RDvcmzJEWhABhD/pqrL0S0CWuABKgnRki9lLseS7g2AlqwHWQSKH4oKLrILpRGhEQCw2LiRUIa4lwAAAABJRU5ErkJggg==')!important}#toast-container>.toast-warning{background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGYSURBVEhL5ZSvTsNQFMbXZGICMYGYmJhAQIJAICYQPAACiSDB8AiICQQJT4CqQEwgJvYASAQCiZiYmJhAIBATCARJy+9rTsldd8sKu1M0+dLb057v6/lbq/2rK0mS/TRNj9cWNAKPYIJII7gIxCcQ51cvqID+GIEX8ASG4B1bK5gIZFeQfoJdEXOfgX4QAQg7kH2A65yQ87lyxb27sggkAzAuFhbbg1K2kgCkB1bVwyIR9m2L7PRPIhDUIXgGtyKw575yz3lTNs6X4JXnjV+LKM/m3MydnTbtOKIjtz6VhCBq4vSm3ncdrD2lk0VgUXSVKjVDJXJzijW1RQdsU7F77He8u68koNZTz8Oz5yGa6J3H3lZ0xYgXBK2QymlWWA+RWnYhskLBv2vmE+hBMCtbA7KX5drWyRT/2JsqZ2IvfB9Y4bWDNMFbJRFmC9E74SoS0CqulwjkC0+5bpcV1CZ8NMej4pjy0U+doDQsGyo1hzVJttIjhQ7GnBtRFN1UarUlH8F3xict+HY07rEzoUGPlWcjRFRr4/gChZgc3ZL2d8oAAAAASUVORK5CYII=')!important}#toast-container.toast-bottom-center>div,#toast-container.toast-top-center>div{width:300px;margin:auto}#toast-container.toast-bottom-full-width>div,#toast-container.toast-top-full-width>div{width:96%;margin:auto}.toast{background-color:#030303}.toast-success{background-color:#51a351}.toast-error{background-color:#bd362f}.toast-info{background-color:#2f96b4}.toast-warning{background-color:#f89406}.toast-progress{position:absolute;left:0;bottom:0;height:4px;background-color:#000;opacity:.4;-ms-filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=40);filter:alpha(opacity=40)}.content,sub,sup{position:relative}.toast{opacity:1!important}.toast.ng-enter{opacity:0!important}.toast.ng-enter.ng-enter-active{opacity:1!important}.toast.ng-leave{opacity:1}.toast.ng-leave.ng-leave-active{opacity:0!important}@media all and (max-width:240px){#toast-container>div{padding:8px 8px 8px 50px;width:11em}#toast-container .toast-close-button{right:-.2em;top:-.2em}}@media all and (min-width:241px)and (max-width:480px){#toast-container>div{padding:8px 8px 8px 50px;width:18em}#toast-container .toast-close-button{right:-.2em;top:-.2em}}@media all and (min-width:481px)and (max-width:768px){#toast-container>div{padding:15px 15px 15px 50px;width:25em}}@font-face{font-family:Ionicons;src:url(assets/fonts/ionicons/ionicons.eot?v=2.0.1);src:url(assets/fonts/ionicons/ionicons.eot?v=2.0.1#iefix)format(\"embedded-opentype\"),url(assets/fonts/ionicons/ionicons.ttf?v=2.0.1)format(\"truetype\"),url(assets/fonts/ionicons/ionicons.woff?v=2.0.1)format(\"woff\"),url(assets/fonts/ionicons/ionicons.woff)format(\"woff\"),url(assets/fonts/ionicons/ionicons.svg?v=2.0.1#Ionicons)format(\"svg\");font-weight:400;font-style:normal}.ion,.ion-alert-circled:before,.ion-alert:before,.ion-android-add-circle:before,.ion-android-add:before,.ion-android-alarm-clock:before,.ion-android-alert:before,.ion-android-apps:before,.ion-android-archive:before,.ion-android-arrow-back:before,.ion-android-arrow-down:before,.ion-android-arrow-dropdown-circle:before,.ion-android-arrow-dropdown:before,.ion-android-arrow-dropleft-circle:before,.ion-android-arrow-dropleft:before,.ion-android-arrow-dropright-circle:before,.ion-android-arrow-dropright:before,.ion-android-arrow-dropup-circle:before,.ion-android-arrow-dropup:before,.ion-android-arrow-forward:before,.ion-android-arrow-up:before,.ion-android-attach:before,.ion-android-bar:before,.ion-android-bicycle:before,.ion-android-boat:before,.ion-android-bookmark:before,.ion-android-bulb:before,.ion-android-bus:before,.ion-android-calendar:before,.ion-android-call:before,.ion-android-camera:before,.ion-android-cancel:before,.ion-android-car:before,.ion-android-cart:before,.ion-android-chat:before,.ion-android-checkbox-blank:before,.ion-android-checkbox-outline-blank:before,.ion-android-checkbox-outline:before,.ion-android-checkbox:before,.ion-android-checkmark-circle:before,.ion-android-clipboard:before,.ion-android-close:before,.ion-android-cloud-circle:before,.ion-android-cloud-done:before,.ion-android-cloud-outline:before,.ion-android-cloud:before,.ion-android-color-palette:before,.ion-android-compass:before,.ion-android-contact:before,.ion-android-contacts:before,.ion-android-contract:before,.ion-android-create:before,.ion-android-delete:before,.ion-android-desktop:before,.ion-android-document:before,.ion-android-done-all:before,.ion-android-done:before,.ion-android-download:before,.ion-android-drafts:before,.ion-android-exit:before,.ion-android-expand:before,.ion-android-favorite-outline:before,.ion-android-favorite:before,.ion-android-film:before,.ion-android-folder-open:before,.ion-android-folder:before,.ion-android-funnel:before,.ion-android-globe:before,.ion-android-hand:before,.ion-android-hangout:before,.ion-android-happy:before,.ion-android-home:before,.ion-android-image:before,.ion-android-laptop:before,.ion-android-list:before,.ion-android-locate:before,.ion-android-lock:before,.ion-android-mail:before,.ion-android-map:before,.ion-android-menu:before,.ion-android-microphone-off:before,.ion-android-microphone:before,.ion-android-more-horizontal:before,.ion-android-more-vertical:before,.ion-android-navigate:before,.ion-android-notifications-none:before,.ion-android-notifications-off:before,.ion-android-notifications:before,.ion-android-open:before,.ion-android-options:before,.ion-android-people:before,.ion-android-person-add:before,.ion-android-person:before,.ion-android-phone-landscape:before,.ion-android-phone-portrait:before,.ion-android-pin:before,.ion-android-plane:before,.ion-android-playstore:before,.ion-android-print:before,.ion-android-radio-button-off:before,.ion-android-radio-button-on:before,.ion-android-refresh:before,.ion-android-remove-circle:before,.ion-android-remove:before,.ion-android-restaurant:before,.ion-android-sad:before,.ion-android-search:before,.ion-android-send:before,.ion-android-settings:before,.ion-android-share-alt:before,.ion-android-share:before,.ion-android-star-half:before,.ion-android-star-outline:before,.ion-android-star:before,.ion-android-stopwatch:before,.ion-android-subway:before,.ion-android-sunny:before,.ion-android-sync:before,.ion-android-textsms:before,.ion-android-time:before,.ion-android-train:before,.ion-android-unlock:before,.ion-android-upload:before,.ion-android-volume-down:before,.ion-android-volume-mute:before,.ion-android-volume-off:before,.ion-android-volume-up:before,.ion-android-walk:before,.ion-android-warning:before,.ion-android-watch:before,.ion-android-wifi:before,.ion-aperture:before,.ion-archive:before,.ion-arrow-down-a:before,.ion-arrow-down-b:before,.ion-arrow-down-c:before,.ion-arrow-expand:before,.ion-arrow-graph-down-left:before,.ion-arrow-graph-down-right:before,.ion-arrow-graph-up-left:before,.ion-arrow-graph-up-right:before,.ion-arrow-left-a:before,.ion-arrow-left-b:before,.ion-arrow-left-c:before,.ion-arrow-move:before,.ion-arrow-resize:before,.ion-arrow-return-left:before,.ion-arrow-return-right:before,.ion-arrow-right-a:before,.ion-arrow-right-b:before,.ion-arrow-right-c:before,.ion-arrow-shrink:before,.ion-arrow-swap:before,.ion-arrow-up-a:before,.ion-arrow-up-b:before,.ion-arrow-up-c:before,.ion-asterisk:before,.ion-at:before,.ion-backspace-outline:before,.ion-backspace:before,.ion-bag:before,.ion-battery-charging:before,.ion-battery-empty:before,.ion-battery-full:before,.ion-battery-half:before,.ion-battery-low:before,.ion-beaker:before,.ion-beer:before,.ion-bluetooth:before,.ion-bonfire:before,.ion-bookmark:before,.ion-bowtie:before,.ion-briefcase:before,.ion-bug:before,.ion-calculator:before,.ion-calendar:before,.ion-camera:before,.ion-card:before,.ion-cash:before,.ion-chatbox-working:before,.ion-chatbox:before,.ion-chatboxes:before,.ion-chatbubble-working:before,.ion-chatbubble:before,.ion-chatbubbles:before,.ion-checkmark-circled:before,.ion-checkmark-round:before,.ion-checkmark:before,.ion-chevron-down:before,.ion-chevron-left:before,.ion-chevron-right:before,.ion-chevron-up:before,.ion-clipboard:before,.ion-clock:before,.ion-close-circled:before,.ion-close-round:before,.ion-close:before,.ion-closed-captioning:before,.ion-cloud:before,.ion-code-download:before,.ion-code-working:before,.ion-code:before,.ion-coffee:before,.ion-compass:before,.ion-compose:before,.ion-connection-bars:before,.ion-contrast:before,.ion-crop:before,.ion-cube:before,.ion-disc:before,.ion-document-text:before,.ion-document:before,.ion-drag:before,.ion-earth:before,.ion-easel:before,.ion-edit:before,.ion-egg:before,.ion-eject:before,.ion-email-unread:before,.ion-email:before,.ion-erlenmeyer-flask-bubbles:before,.ion-erlenmeyer-flask:before,.ion-eye-disabled:before,.ion-eye:before,.ion-female:before,.ion-filing:before,.ion-film-marker:before,.ion-fireball:before,.ion-flag:before,.ion-flame:before,.ion-flash-off:before,.ion-flash:before,.ion-folder:before,.ion-fork-repo:before,.ion-fork:before,.ion-forward:before,.ion-funnel:before,.ion-gear-a:before,.ion-gear-b:before,.ion-grid:before,.ion-hammer:before,.ion-happy-outline:before,.ion-happy:before,.ion-headphone:before,.ion-heart-broken:before,.ion-heart:before,.ion-help-buoy:before,.ion-help-circled:before,.ion-help:before,.ion-home:before,.ion-icecream:before,.ion-image:before,.ion-images:before,.ion-information-circled:before,.ion-information:before,.ion-ionic:before,.ion-ios-alarm-outline:before,.ion-ios-alarm:before,.ion-ios-albums-outline:before,.ion-ios-albums:before,.ion-ios-americanfootball-outline:before,.ion-ios-americanfootball:before,.ion-ios-analytics-outline:before,.ion-ios-analytics:before,.ion-ios-arrow-back:before,.ion-ios-arrow-down:before,.ion-ios-arrow-forward:before,.ion-ios-arrow-left:before,.ion-ios-arrow-right:before,.ion-ios-arrow-thin-down:before,.ion-ios-arrow-thin-left:before,.ion-ios-arrow-thin-right:before,.ion-ios-arrow-thin-up:before,.ion-ios-arrow-up:before,.ion-ios-at-outline:before,.ion-ios-at:before,.ion-ios-barcode-outline:before,.ion-ios-barcode:before,.ion-ios-baseball-outline:before,.ion-ios-baseball:before,.ion-ios-basketball-outline:before,.ion-ios-basketball:before,.ion-ios-bell-outline:before,.ion-ios-bell:before,.ion-ios-body-outline:before,.ion-ios-body:before,.ion-ios-bolt-outline:before,.ion-ios-bolt:before,.ion-ios-book-outline:before,.ion-ios-book:before,.ion-ios-bookmarks-outline:before,.ion-ios-bookmarks:before,.ion-ios-box-outline:before,.ion-ios-box:before,.ion-ios-briefcase-outline:before,.ion-ios-briefcase:before,.ion-ios-browsers-outline:before,.ion-ios-browsers:before,.ion-ios-calculator-outline:before,.ion-ios-calculator:before,.ion-ios-calendar-outline:before,.ion-ios-calendar:before,.ion-ios-camera-outline:before,.ion-ios-camera:before,.ion-ios-cart-outline:before,.ion-ios-cart:before,.ion-ios-chatboxes-outline:before,.ion-ios-chatboxes:before,.ion-ios-chatbubble-outline:before,.ion-ios-chatbubble:before,.ion-ios-checkmark-empty:before,.ion-ios-checkmark-outline:before,.ion-ios-checkmark:before,.ion-ios-circle-filled:before,.ion-ios-circle-outline:before,.ion-ios-clock-outline:before,.ion-ios-clock:before,.ion-ios-close-empty:before,.ion-ios-close-outline:before,.ion-ios-close:before,.ion-ios-cloud-download-outline:before,.ion-ios-cloud-download:before,.ion-ios-cloud-outline:before,.ion-ios-cloud-upload-outline:before,.ion-ios-cloud-upload:before,.ion-ios-cloud:before,.ion-ios-cloudy-night-outline:before,.ion-ios-cloudy-night:before,.ion-ios-cloudy-outline:before,.ion-ios-cloudy:before,.ion-ios-cog-outline:before,.ion-ios-cog:before,.ion-ios-color-filter-outline:before,.ion-ios-color-filter:before,.ion-ios-color-wand-outline:before,.ion-ios-color-wand:before,.ion-ios-compose-outline:before,.ion-ios-compose:before,.ion-ios-contact-outline:before,.ion-ios-contact:before,.ion-ios-copy-outline:before,.ion-ios-copy:before,.ion-ios-crop-strong:before,.ion-ios-crop:before,.ion-ios-download-outline:before,.ion-ios-download:before,.ion-ios-drag:before,.ion-ios-email-outline:before,.ion-ios-email:before,.ion-ios-eye-outline:before,.ion-ios-eye:before,.ion-ios-fastforward-outline:before,.ion-ios-fastforward:before,.ion-ios-filing-outline:before,.ion-ios-filing:before,.ion-ios-film-outline:before,.ion-ios-film:before,.ion-ios-flag-outline:before,.ion-ios-flag:before,.ion-ios-flame-outline:before,.ion-ios-flame:before,.ion-ios-flask-outline:before,.ion-ios-flask:before,.ion-ios-flower-outline:before,.ion-ios-flower:before,.ion-ios-folder-outline:before,.ion-ios-folder:before,.ion-ios-football-outline:before,.ion-ios-football:before,.ion-ios-game-controller-a-outline:before,.ion-ios-game-controller-a:before,.ion-ios-game-controller-b-outline:before,.ion-ios-game-controller-b:before,.ion-ios-gear-outline:before,.ion-ios-gear:before,.ion-ios-glasses-outline:before,.ion-ios-glasses:before,.ion-ios-grid-view-outline:before,.ion-ios-grid-view:before,.ion-ios-heart-outline:before,.ion-ios-heart:before,.ion-ios-help-empty:before,.ion-ios-help-outline:before,.ion-ios-help:before,.ion-ios-home-outline:before,.ion-ios-home:before,.ion-ios-infinite-outline:before,.ion-ios-infinite:before,.ion-ios-information-empty:before,.ion-ios-information-outline:before,.ion-ios-information:before,.ion-ios-ionic-outline:before,.ion-ios-keypad-outline:before,.ion-ios-keypad:before,.ion-ios-lightbulb-outline:before,.ion-ios-lightbulb:before,.ion-ios-list-outline:before,.ion-ios-list:before,.ion-ios-location-outline:before,.ion-ios-location:before,.ion-ios-locked-outline:before,.ion-ios-locked:before,.ion-ios-loop-strong:before,.ion-ios-loop:before,.ion-ios-medical-outline:before,.ion-ios-medical:before,.ion-ios-medkit-outline:before,.ion-ios-medkit:before,.ion-ios-mic-off:before,.ion-ios-mic-outline:before,.ion-ios-mic:before,.ion-ios-minus-empty:before,.ion-ios-minus-outline:before,.ion-ios-minus:before,.ion-ios-monitor-outline:before,.ion-ios-monitor:before,.ion-ios-moon-outline:before,.ion-ios-moon:before,.ion-ios-more-outline:before,.ion-ios-more:before,.ion-ios-musical-note:before,.ion-ios-musical-notes:before,.ion-ios-navigate-outline:before,.ion-ios-navigate:before,.ion-ios-nutrition-outline:before,.ion-ios-nutrition:before,.ion-ios-paper-outline:before,.ion-ios-paper:before,.ion-ios-paperplane-outline:before,.ion-ios-paperplane:before,.ion-ios-partlysunny-outline:before,.ion-ios-partlysunny:before,.ion-ios-pause-outline:before,.ion-ios-pause:before,.ion-ios-paw-outline:before,.ion-ios-paw:before,.ion-ios-people-outline:before,.ion-ios-people:before,.ion-ios-person-outline:before,.ion-ios-person:before,.ion-ios-personadd-outline:before,.ion-ios-personadd:before,.ion-ios-photos-outline:before,.ion-ios-photos:before,.ion-ios-pie-outline:before,.ion-ios-pie:before,.ion-ios-pint-outline:before,.ion-ios-pint:before,.ion-ios-play-outline:before,.ion-ios-play:before,.ion-ios-plus-empty:before,.ion-ios-plus-outline:before,.ion-ios-plus:before,.ion-ios-pricetag-outline:before,.ion-ios-pricetag:before,.ion-ios-pricetags-outline:before,.ion-ios-pricetags:before,.ion-ios-printer-outline:before,.ion-ios-printer:before,.ion-ios-pulse-strong:before,.ion-ios-pulse:before,.ion-ios-rainy-outline:before,.ion-ios-rainy:before,.ion-ios-recording-outline:before,.ion-ios-recording:before,.ion-ios-redo-outline:before,.ion-ios-redo:before,.ion-ios-refresh-empty:before,.ion-ios-refresh-outline:before,.ion-ios-refresh:before,.ion-ios-reload:before,.ion-ios-reverse-camera-outline:before,.ion-ios-reverse-camera:before,.ion-ios-rewind-outline:before,.ion-ios-rewind:before,.ion-ios-rose-outline:before,.ion-ios-rose:before,.ion-ios-search-strong:before,.ion-ios-search:before,.ion-ios-settings-strong:before,.ion-ios-settings:before,.ion-ios-shuffle-strong:before,.ion-ios-shuffle:before,.ion-ios-skipbackward-outline:before,.ion-ios-skipbackward:before,.ion-ios-skipforward-outline:before,.ion-ios-skipforward:before,.ion-ios-snowy:before,.ion-ios-speedometer-outline:before,.ion-ios-speedometer:before,.ion-ios-star-half:before,.ion-ios-star-outline:before,.ion-ios-star:before,.ion-ios-stopwatch-outline:before,.ion-ios-stopwatch:before,.ion-ios-sunny-outline:before,.ion-ios-sunny:before,.ion-ios-telephone-outline:before,.ion-ios-telephone:before,.ion-ios-tennisball-outline:before,.ion-ios-tennisball:before,.ion-ios-thunderstorm-outline:before,.ion-ios-thunderstorm:before,.ion-ios-time-outline:before,.ion-ios-time:before,.ion-ios-timer-outline:before,.ion-ios-timer:before,.ion-ios-toggle-outline:before,.ion-ios-toggle:before,.ion-ios-trash-outline:before,.ion-ios-trash:before,.ion-ios-undo-outline:before,.ion-ios-undo:before,.ion-ios-unlocked-outline:before,.ion-ios-unlocked:before,.ion-ios-upload-outline:before,.ion-ios-upload:before,.ion-ios-videocam-outline:before,.ion-ios-videocam:before,.ion-ios-volume-high:before,.ion-ios-volume-low:before,.ion-ios-wineglass-outline:before,.ion-ios-wineglass:before,.ion-ios-world-outline:before,.ion-ios-world:before,.ion-ipad:before,.ion-iphone:before,.ion-ipod:before,.ion-jet:before,.ion-key:before,.ion-knife:before,.ion-laptop:before,.ion-leaf:before,.ion-levels:before,.ion-lightbulb:before,.ion-link:before,.ion-load-a:before,.ion-load-b:before,.ion-load-c:before,.ion-load-d:before,.ion-location:before,.ion-lock-combination:before,.ion-locked:before,.ion-log-in:before,.ion-log-out:before,.ion-loop:before,.ion-magnet:before,.ion-male:before,.ion-man:before,.ion-map:before,.ion-medkit:before,.ion-merge:before,.ion-mic-a:before,.ion-mic-b:before,.ion-mic-c:before,.ion-minus-circled:before,.ion-minus-round:before,.ion-minus:before,.ion-model-s:before,.ion-monitor:before,.ion-more:before,.ion-mouse:before,.ion-music-note:before,.ion-navicon-round:before,.ion-navicon:before,.ion-navigate:before,.ion-network:before,.ion-no-smoking:before,.ion-nuclear:before,.ion-outlet:before,.ion-paintbrush:before,.ion-paintbucket:before,.ion-paper-airplane:before,.ion-paperclip:before,.ion-pause:before,.ion-person-add:before,.ion-person-stalker:before,.ion-person:before,.ion-pie-graph:before,.ion-pin:before,.ion-pinpoint:before,.ion-pizza:before,.ion-plane:before,.ion-planet:before,.ion-play:before,.ion-playstation:before,.ion-plus-circled:before,.ion-plus-round:before,.ion-plus:before,.ion-podium:before,.ion-pound:before,.ion-power:before,.ion-pricetag:before,.ion-pricetags:before,.ion-printer:before,.ion-pull-request:before,.ion-qr-scanner:before,.ion-quote:before,.ion-radio-waves:before,.ion-record:before,.ion-refresh:before,.ion-reply-all:before,.ion-reply:before,.ion-ribbon-a:before,.ion-ribbon-b:before,.ion-sad-outline:before,.ion-sad:before,.ion-scissors:before,.ion-search:before,.ion-settings:before,.ion-share:before,.ion-shuffle:before,.ion-skip-backward:before,.ion-skip-forward:before,.ion-social-android-outline:before,.ion-social-android:before,.ion-social-angular-outline:before,.ion-social-angular:before,.ion-social-apple-outline:before,.ion-social-apple:before,.ion-social-bitcoin-outline:before,.ion-social-bitcoin:before,.ion-social-buffer-outline:before,.ion-social-buffer:before,.ion-social-chrome-outline:before,.ion-social-chrome:before,.ion-social-codepen-outline:before,.ion-social-codepen:before,.ion-social-css3-outline:before,.ion-social-css3:before,.ion-social-designernews-outline:before,.ion-social-designernews:before,.ion-social-dribbble-outline:before,.ion-social-dribbble:before,.ion-social-dropbox-outline:before,.ion-social-dropbox:before,.ion-social-euro-outline:before,.ion-social-euro:before,.ion-social-facebook-outline:before,.ion-social-facebook:before,.ion-social-foursquare-outline:before,.ion-social-foursquare:before,.ion-social-freebsd-devil:before,.ion-social-github-outline:before,.ion-social-github:before,.ion-social-google-outline:before,.ion-social-google:before,.ion-social-googleplus-outline:before,.ion-social-googleplus:before,.ion-social-hackernews-outline:before,.ion-social-hackernews:before,.ion-social-html5-outline:before,.ion-social-html5:before,.ion-social-instagram-outline:before,.ion-social-instagram:before,.ion-social-javascript-outline:before,.ion-social-javascript:before,.ion-social-linkedin-outline:before,.ion-social-linkedin:before,.ion-social-markdown:before,.ion-social-nodejs:before,.ion-social-octocat:before,.ion-social-pinterest-outline:before,.ion-social-pinterest:before,.ion-social-python:before,.ion-social-reddit-outline:before,.ion-social-reddit:before,.ion-social-rss-outline:before,.ion-social-rss:before,.ion-social-sass:before,.ion-social-skype-outline:before,.ion-social-skype:before,.ion-social-snapchat-outline:before,.ion-social-snapchat:before,.ion-social-tumblr-outline:before,.ion-social-tumblr:before,.ion-social-tux:before,.ion-social-twitch-outline:before,.ion-social-twitch:before,.ion-social-twitter-outline:before,.ion-social-twitter:before,.ion-social-usd-outline:before,.ion-social-usd:before,.ion-social-vimeo-outline:before,.ion-social-vimeo:before,.ion-social-whatsapp-outline:before,.ion-social-whatsapp:before,.ion-social-windows-outline:before,.ion-social-windows:before,.ion-social-wordpress-outline:before,.ion-social-wordpress:before,.ion-social-yahoo-outline:before,.ion-social-yahoo:before,.ion-social-yen-outline:before,.ion-social-yen:before,.ion-social-youtube-outline:before,.ion-social-youtube:before,.ion-soup-can-outline:before,.ion-soup-can:before,.ion-speakerphone:before,.ion-speedometer:before,.ion-spoon:before,.ion-star:before,.ion-stats-bars:before,.ion-steam:before,.ion-stop:before,.ion-thermometer:before,.ion-thumbsdown:before,.ion-thumbsup:before,.ion-toggle-filled:before,.ion-toggle:before,.ion-transgender:before,.ion-trash-a:before,.ion-trash-b:before,.ion-trophy:before,.ion-tshirt-outline:before,.ion-tshirt:before,.ion-umbrella:before,.ion-university:before,.ion-unlocked:before,.ion-upload:before,.ion-usb:before,.ion-videocamera:before,.ion-volume-high:before,.ion-volume-low:before,.ion-volume-medium:before,.ion-volume-mute:before,.ion-wand:before,.ion-waterdrop:before,.ion-wifi:before,.ion-wineglass:before,.ion-woman:before,.ion-wrench:before,.ion-xbox:before,.ionicons{display:inline-block;font-family:Ionicons;speak:none;font-style:normal;font-weight:400;font-variant:normal;text-transform:none;text-rendering:auto;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.ion-alert:before{content:\"\"}.ion-alert-circled:before{content:\"\"}.ion-android-add:before{content:\"\"}.ion-android-add-circle:before{content:\"\"}.ion-android-alarm-clock:before{content:\"\"}.ion-android-alert:before{content:\"\"}.ion-android-apps:before{content:\"\"}.ion-android-archive:before{content:\"\"}.ion-android-arrow-back:before{content:\"\"}.ion-android-arrow-down:before{content:\"\"}.ion-android-arrow-dropdown:before{content:\"\"}.ion-android-arrow-dropdown-circle:before{content:\"\"}.ion-android-arrow-dropleft:before{content:\"\"}.ion-android-arrow-dropleft-circle:before{content:\"\"}.ion-android-arrow-dropright:before{content:\"\"}.ion-android-arrow-dropright-circle:before{content:\"\"}.ion-android-arrow-dropup:before{content:\"\"}.ion-android-arrow-dropup-circle:before{content:\"\"}.ion-android-arrow-forward:before{content:\"\"}.ion-android-arrow-up:before{content:\"\"}.ion-android-attach:before{content:\"\"}.ion-android-bar:before{content:\"\"}.ion-android-bicycle:before{content:\"\"}.ion-android-boat:before{content:\"\"}.ion-android-bookmark:before{content:\"\"}.ion-android-bulb:before{content:\"\"}.ion-android-bus:before{content:\"\"}.ion-android-calendar:before{content:\"\"}.ion-android-call:before{content:\"\"}.ion-android-camera:before{content:\"\"}.ion-android-cancel:before{content:\"\"}.ion-android-car:before{content:\"\"}.ion-android-cart:before{content:\"\"}.ion-android-chat:before{content:\"\"}.ion-android-checkbox:before{content:\"\"}.ion-android-checkbox-blank:before{content:\"\"}.ion-android-checkbox-outline:before{content:\"\"}.ion-android-checkbox-outline-blank:before{content:\"\"}.ion-android-checkmark-circle:before{content:\"\"}.ion-android-clipboard:before{content:\"\"}.ion-android-close:before{content:\"\"}.ion-android-cloud:before{content:\"\"}.ion-android-cloud-circle:before{content:\"\"}.ion-android-cloud-done:before{content:\"\"}.ion-android-cloud-outline:before{content:\"\"}.ion-android-color-palette:before{content:\"\"}.ion-android-compass:before{content:\"\"}.ion-android-contact:before{content:\"\"}.ion-android-contacts:before{content:\"\"}.ion-android-contract:before{content:\"\"}.ion-android-create:before{content:\"\"}.ion-android-delete:before{content:\"\"}.ion-android-desktop:before{content:\"\"}.ion-android-document:before{content:\"\"}.ion-android-done:before{content:\"\"}.ion-android-done-all:before{content:\"\"}.ion-android-download:before{content:\"\"}.ion-android-drafts:before{content:\"\"}.ion-android-exit:before{content:\"\"}.ion-android-expand:before{content:\"\"}.ion-android-favorite:before{content:\"\"}.ion-android-favorite-outline:before{content:\"\"}.ion-android-film:before{content:\"\"}.ion-android-folder:before{content:\"\"}.ion-android-folder-open:before{content:\"\"}.ion-android-funnel:before{content:\"\"}.ion-android-globe:before{content:\"\"}.ion-android-hand:before{content:\"\"}.ion-android-hangout:before{content:\"\"}.ion-android-happy:before{content:\"\"}.ion-android-home:before{content:\"\"}.ion-android-image:before{content:\"\"}.ion-android-laptop:before{content:\"\"}.ion-android-list:before{content:\"\"}.ion-android-locate:before{content:\"\"}.ion-android-lock:before{content:\"\"}.ion-android-mail:before{content:\"\"}.ion-android-map:before{content:\"\"}.ion-android-menu:before{content:\"\"}.ion-android-microphone:before{content:\"\"}.ion-android-microphone-off:before{content:\"\"}.ion-android-more-horizontal:before{content:\"\"}.ion-android-more-vertical:before{content:\"\"}.ion-android-navigate:before{content:\"\"}.ion-android-notifications:before{content:\"\"}.ion-android-notifications-none:before{content:\"\"}.ion-android-notifications-off:before{content:\"\"}.ion-android-open:before{content:\"\"}.ion-android-options:before{content:\"\"}.ion-android-people:before{content:\"\"}.ion-android-person:before{content:\"\"}.ion-android-person-add:before{content:\"\"}.ion-android-phone-landscape:before{content:\"\"}.ion-android-phone-portrait:before{content:\"\"}.ion-android-pin:before{content:\"\"}.ion-android-plane:before{content:\"\"}.ion-android-playstore:before{content:\"\"}.ion-android-print:before{content:\"\"}.ion-android-radio-button-off:before{content:\"\"}.ion-android-radio-button-on:before{content:\"\"}.ion-android-refresh:before{content:\"\"}.ion-android-remove:before{content:\"\"}.ion-android-remove-circle:before{content:\"\"}.ion-android-restaurant:before{content:\"\"}.ion-android-sad:before{content:\"\"}.ion-android-search:before{content:\"\"}.ion-android-send:before{content:\"\"}.ion-android-settings:before{content:\"\"}.ion-android-share:before{content:\"\"}.ion-android-share-alt:before{content:\"\"}.ion-android-star:before{content:\"\"}.ion-android-star-half:before{content:\"\"}.ion-android-star-outline:before{content:\"\"}.ion-android-stopwatch:before{content:\"\"}.ion-android-subway:before{content:\"\"}.ion-android-sunny:before{content:\"\"}.ion-android-sync:before{content:\"\"}.ion-android-textsms:before{content:\"\"}.ion-android-time:before{content:\"\"}.ion-android-train:before{content:\"\"}.ion-android-unlock:before{content:\"\"}.ion-android-upload:before{content:\"\"}.ion-android-volume-down:before{content:\"\"}.ion-android-volume-mute:before{content:\"\"}.ion-android-volume-off:before{content:\"\"}.ion-android-volume-up:before{content:\"\"}.ion-android-walk:before{content:\"\"}.ion-android-warning:before{content:\"\"}.ion-android-watch:before{content:\"\"}.ion-android-wifi:before{content:\"\"}.ion-aperture:before{content:\"\"}.ion-archive:before{content:\"\"}.ion-arrow-down-a:before{content:\"\"}.ion-arrow-down-b:before{content:\"\"}.ion-arrow-down-c:before{content:\"\"}.ion-arrow-expand:before{content:\"\"}.ion-arrow-graph-down-left:before{content:\"\"}.ion-arrow-graph-down-right:before{content:\"\"}.ion-arrow-graph-up-left:before{content:\"\"}.ion-arrow-graph-up-right:before{content:\"\"}.ion-arrow-left-a:before{content:\"\"}.ion-arrow-left-b:before{content:\"\"}.ion-arrow-left-c:before{content:\"\"}.ion-arrow-move:before{content:\"\"}.ion-arrow-resize:before{content:\"\"}.ion-arrow-return-left:before{content:\"\"}.ion-arrow-return-right:before{content:\"\"}.ion-arrow-right-a:before{content:\"\"}.ion-arrow-right-b:before{content:\"\"}.ion-arrow-right-c:before{content:\"\"}.ion-arrow-shrink:before{content:\"\"}.ion-arrow-swap:before{content:\"\"}.ion-arrow-up-a:before{content:\"\"}.ion-arrow-up-b:before{content:\"\"}.ion-arrow-up-c:before{content:\"\"}.ion-asterisk:before{content:\"\"}.ion-at:before{content:\"\"}.ion-backspace:before{content:\"\"}.ion-backspace-outline:before{content:\"\"}.ion-bag:before{content:\"\"}.ion-battery-charging:before{content:\"\"}.ion-battery-empty:before{content:\"\"}.ion-battery-full:before{content:\"\"}.ion-battery-half:before{content:\"\"}.ion-battery-low:before{content:\"\"}.ion-beaker:before{content:\"\"}.ion-beer:before{content:\"\"}.ion-bluetooth:before{content:\"\"}.ion-bonfire:before{content:\"\"}.ion-bookmark:before{content:\"\"}.ion-bowtie:before{content:\"\"}.ion-briefcase:before{content:\"\"}.ion-bug:before{content:\"\"}.ion-calculator:before{content:\"\"}.ion-calendar:before{content:\"\"}.ion-camera:before{content:\"\"}.ion-card:before{content:\"\"}.ion-cash:before{content:\"\"}.ion-chatbox:before{content:\"\"}.ion-chatbox-working:before{content:\"\"}.ion-chatboxes:before{content:\"\"}.ion-chatbubble:before{content:\"\"}.ion-chatbubble-working:before{content:\"\"}.ion-chatbubbles:before{content:\"\"}.ion-checkmark:before{content:\"\"}.ion-checkmark-circled:before{content:\"\"}.ion-checkmark-round:before{content:\"\"}.ion-chevron-down:before{content:\"\"}.ion-chevron-left:before{content:\"\"}.ion-chevron-right:before{content:\"\"}.ion-chevron-up:before{content:\"\"}.ion-clipboard:before{content:\"\"}.ion-clock:before{content:\"\"}.ion-close:before{content:\"\"}.ion-close-circled:before{content:\"\"}.ion-close-round:before{content:\"\"}.ion-closed-captioning:before{content:\"\"}.ion-cloud:before{content:\"\"}.ion-code:before{content:\"\"}.ion-code-download:before{content:\"\"}.ion-code-working:before{content:\"\"}.ion-coffee:before{content:\"\"}.ion-compass:before{content:\"\"}.ion-compose:before{content:\"\"}.ion-connection-bars:before{content:\"\"}.ion-contrast:before{content:\"\"}.ion-crop:before{content:\"\"}.ion-cube:before{content:\"\"}.ion-disc:before{content:\"\"}.ion-document:before{content:\"\"}.ion-document-text:before{content:\"\"}.ion-drag:before{content:\"\"}.ion-earth:before{content:\"\"}.ion-easel:before{content:\"\"}.ion-edit:before{content:\"\"}.ion-egg:before{content:\"\"}.ion-eject:before{content:\"\"}.ion-email:before{content:\"\"}.ion-email-unread:before{content:\"\"}.ion-erlenmeyer-flask:before{content:\"\"}.ion-erlenmeyer-flask-bubbles:before{content:\"\"}.ion-eye:before{content:\"\"}.ion-eye-disabled:before{content:\"\"}.ion-female:before{content:\"\"}.ion-filing:before{content:\"\"}.ion-film-marker:before{content:\"\"}.ion-fireball:before{content:\"\"}.ion-flag:before{content:\"\"}.ion-flame:before{content:\"\"}.ion-flash:before{content:\"\"}.ion-flash-off:before{content:\"\"}.ion-folder:before{content:\"\"}.ion-fork:before{content:\"\"}.ion-fork-repo:before{content:\"\"}.ion-forward:before{content:\"\"}.ion-funnel:before{content:\"\"}.ion-gear-a:before{content:\"\"}.ion-gear-b:before{content:\"\"}.ion-grid:before{content:\"\"}.ion-hammer:before{content:\"\"}.ion-happy:before{content:\"\"}.ion-happy-outline:before{content:\"\"}.ion-headphone:before{content:\"\"}.ion-heart:before{content:\"\"}.ion-heart-broken:before{content:\"\"}.ion-help:before{content:\"\"}.ion-help-buoy:before{content:\"\"}.ion-help-circled:before{content:\"\"}.ion-home:before{content:\"\"}.ion-icecream:before{content:\"\"}.ion-image:before{content:\"\"}.ion-images:before{content:\"\"}.ion-information:before{content:\"\"}.ion-information-circled:before{content:\"\"}.ion-ionic:before{content:\"\"}.ion-ios-alarm:before{content:\"\"}.ion-ios-alarm-outline:before{content:\"\"}.ion-ios-albums:before{content:\"\"}.ion-ios-albums-outline:before{content:\"\"}.ion-ios-americanfootball:before{content:\"\"}.ion-ios-americanfootball-outline:before{content:\"\"}.ion-ios-analytics:before{content:\"\"}.ion-ios-analytics-outline:before{content:\"\"}.ion-ios-arrow-back:before{content:\"\"}.ion-ios-arrow-down:before{content:\"\"}.ion-ios-arrow-forward:before{content:\"\"}.ion-ios-arrow-left:before{content:\"\"}.ion-ios-arrow-right:before{content:\"\"}.ion-ios-arrow-thin-down:before{content:\"\"}.ion-ios-arrow-thin-left:before{content:\"\"}.ion-ios-arrow-thin-right:before{content:\"\"}.ion-ios-arrow-thin-up:before{content:\"\"}.ion-ios-arrow-up:before{content:\"\"}.ion-ios-at:before{content:\"\"}.ion-ios-at-outline:before{content:\"\"}.ion-ios-barcode:before{content:\"\"}.ion-ios-barcode-outline:before{content:\"\"}.ion-ios-baseball:before{content:\"\"}.ion-ios-baseball-outline:before{content:\"\"}.ion-ios-basketball:before{content:\"\"}.ion-ios-basketball-outline:before{content:\"\"}.ion-ios-bell:before{content:\"\"}.ion-ios-bell-outline:before{content:\"\"}.ion-ios-body:before{content:\"\"}.ion-ios-body-outline:before{content:\"\"}.ion-ios-bolt:before{content:\"\"}.ion-ios-bolt-outline:before{content:\"\"}.ion-ios-book:before{content:\"\"}.ion-ios-book-outline:before{content:\"\"}.ion-ios-bookmarks:before{content:\"\"}.ion-ios-bookmarks-outline:before{content:\"\"}.ion-ios-box:before{content:\"\"}.ion-ios-box-outline:before{content:\"\"}.ion-ios-briefcase:before{content:\"\"}.ion-ios-briefcase-outline:before{content:\"\"}.ion-ios-browsers:before{content:\"\"}.ion-ios-browsers-outline:before{content:\"\"}.ion-ios-calculator:before{content:\"\"}.ion-ios-calculator-outline:before{content:\"\"}.ion-ios-calendar:before{content:\"\"}.ion-ios-calendar-outline:before{content:\"\"}.ion-ios-camera:before{content:\"\"}.ion-ios-camera-outline:before{content:\"\"}.ion-ios-cart:before{content:\"\"}.ion-ios-cart-outline:before{content:\"\"}.ion-ios-chatboxes:before{content:\"\"}.ion-ios-chatboxes-outline:before{content:\"\"}.ion-ios-chatbubble:before{content:\"\"}.ion-ios-chatbubble-outline:before{content:\"\"}.ion-ios-checkmark:before{content:\"\"}.ion-ios-checkmark-empty:before{content:\"\"}.ion-ios-checkmark-outline:before{content:\"\"}.ion-ios-circle-filled:before{content:\"\"}.ion-ios-circle-outline:before{content:\"\"}.ion-ios-clock:before{content:\"\"}.ion-ios-clock-outline:before{content:\"\"}.ion-ios-close:before{content:\"\"}.ion-ios-close-empty:before{content:\"\"}.ion-ios-close-outline:before{content:\"\"}.ion-ios-cloud:before{content:\"\"}.ion-ios-cloud-download:before{content:\"\"}.ion-ios-cloud-download-outline:before{content:\"\"}.ion-ios-cloud-outline:before{content:\"\"}.ion-ios-cloud-upload:before{content:\"\"}.ion-ios-cloud-upload-outline:before{content:\"\"}.ion-ios-cloudy:before{content:\"\"}.ion-ios-cloudy-night:before{content:\"\"}.ion-ios-cloudy-night-outline:before{content:\"\"}.ion-ios-cloudy-outline:before{content:\"\"}.ion-ios-cog:before{content:\"\"}.ion-ios-cog-outline:before{content:\"\"}.ion-ios-color-filter:before{content:\"\"}.ion-ios-color-filter-outline:before{content:\"\"}.ion-ios-color-wand:before{content:\"\"}.ion-ios-color-wand-outline:before{content:\"\"}.ion-ios-compose:before{content:\"\"}.ion-ios-compose-outline:before{content:\"\"}.ion-ios-contact:before{content:\"\"}.ion-ios-contact-outline:before{content:\"\"}.ion-ios-copy:before{content:\"\"}.ion-ios-copy-outline:before{content:\"\"}.ion-ios-crop:before{content:\"\"}.ion-ios-crop-strong:before{content:\"\"}.ion-ios-download:before{content:\"\"}.ion-ios-download-outline:before{content:\"\"}.ion-ios-drag:before{content:\"\"}.ion-ios-email:before{content:\"\"}.ion-ios-email-outline:before{content:\"\"}.ion-ios-eye:before{content:\"\"}.ion-ios-eye-outline:before{content:\"\"}.ion-ios-fastforward:before{content:\"\"}.ion-ios-fastforward-outline:before{content:\"\"}.ion-ios-filing:before{content:\"\"}.ion-ios-filing-outline:before{content:\"\"}.ion-ios-film:before{content:\"\"}.ion-ios-film-outline:before{content:\"\"}.ion-ios-flag:before{content:\"\"}.ion-ios-flag-outline:before{content:\"\"}.ion-ios-flame:before{content:\"\"}.ion-ios-flame-outline:before{content:\"\"}.ion-ios-flask:before{content:\"\"}.ion-ios-flask-outline:before{content:\"\"}.ion-ios-flower:before{content:\"\"}.ion-ios-flower-outline:before{content:\"\"}.ion-ios-folder:before{content:\"\"}.ion-ios-folder-outline:before{content:\"\"}.ion-ios-football:before{content:\"\"}.ion-ios-football-outline:before{content:\"\"}.ion-ios-game-controller-a:before{content:\"\"}.ion-ios-game-controller-a-outline:before{content:\"\"}.ion-ios-game-controller-b:before{content:\"\"}.ion-ios-game-controller-b-outline:before{content:\"\"}.ion-ios-gear:before{content:\"\"}.ion-ios-gear-outline:before{content:\"\"}.ion-ios-glasses:before{content:\"\"}.ion-ios-glasses-outline:before{content:\"\"}.ion-ios-grid-view:before{content:\"\"}.ion-ios-grid-view-outline:before{content:\"\"}.ion-ios-heart:before{content:\"\"}.ion-ios-heart-outline:before{content:\"\"}.ion-ios-help:before{content:\"\"}.ion-ios-help-empty:before{content:\"\"}.ion-ios-help-outline:before{content:\"\"}.ion-ios-home:before{content:\"\"}.ion-ios-home-outline:before{content:\"\"}.ion-ios-infinite:before{content:\"\"}.ion-ios-infinite-outline:before{content:\"\"}.ion-ios-information:before{content:\"\"}.ion-ios-information-empty:before{content:\"\"}.ion-ios-information-outline:before{content:\"\"}.ion-ios-ionic-outline:before{content:\"\"}.ion-ios-keypad:before{content:\"\"}.ion-ios-keypad-outline:before{content:\"\"}.ion-ios-lightbulb:before{content:\"\"}.ion-ios-lightbulb-outline:before{content:\"\"}.ion-ios-list:before{content:\"\"}.ion-ios-list-outline:before{content:\"\"}.ion-ios-location:before{content:\"\"}.ion-ios-location-outline:before{content:\"\"}.ion-ios-locked:before{content:\"\"}.ion-ios-locked-outline:before{content:\"\"}.ion-ios-loop:before{content:\"\"}.ion-ios-loop-strong:before{content:\"\"}.ion-ios-medical:before{content:\"\"}.ion-ios-medical-outline:before{content:\"\"}.ion-ios-medkit:before{content:\"\"}.ion-ios-medkit-outline:before{content:\"\"}.ion-ios-mic:before{content:\"\"}.ion-ios-mic-off:before{content:\"\"}.ion-ios-mic-outline:before{content:\"\"}.ion-ios-minus:before{content:\"\"}.ion-ios-minus-empty:before{content:\"\"}.ion-ios-minus-outline:before{content:\"\"}.ion-ios-monitor:before{content:\"\"}.ion-ios-monitor-outline:before{content:\"\"}.ion-ios-moon:before{content:\"\"}.ion-ios-moon-outline:before{content:\"\"}.ion-ios-more:before{content:\"\"}.ion-ios-more-outline:before{content:\"\"}.ion-ios-musical-note:before{content:\"\"}.ion-ios-musical-notes:before{content:\"\"}.ion-ios-navigate:before{content:\"\"}.ion-ios-navigate-outline:before{content:\"\"}.ion-ios-nutrition:before{content:\"\"}.ion-ios-nutrition-outline:before{content:\"\"}.ion-ios-paper:before{content:\"\"}.ion-ios-paper-outline:before{content:\"\"}.ion-ios-paperplane:before{content:\"\"}.ion-ios-paperplane-outline:before{content:\"\"}.ion-ios-partlysunny:before{content:\"\"}.ion-ios-partlysunny-outline:before{content:\"\"}.ion-ios-pause:before{content:\"\"}.ion-ios-pause-outline:before{content:\"\"}.ion-ios-paw:before{content:\"\"}.ion-ios-paw-outline:before{content:\"\"}.ion-ios-people:before{content:\"\"}.ion-ios-people-outline:before{content:\"\"}.ion-ios-person:before{content:\"\"}.ion-ios-person-outline:before{content:\"\"}.ion-ios-personadd:before{content:\"\"}.ion-ios-personadd-outline:before{content:\"\"}.ion-ios-photos:before{content:\"\"}.ion-ios-photos-outline:before{content:\"\"}.ion-ios-pie:before{content:\"\"}.ion-ios-pie-outline:before{content:\"\"}.ion-ios-pint:before{content:\"\"}.ion-ios-pint-outline:before{content:\"\"}.ion-ios-play:before{content:\"\"}.ion-ios-play-outline:before{content:\"\"}.ion-ios-plus:before{content:\"\"}.ion-ios-plus-empty:before{content:\"\"}.ion-ios-plus-outline:before{content:\"\"}.ion-ios-pricetag:before{content:\"\"}.ion-ios-pricetag-outline:before{content:\"\"}.ion-ios-pricetags:before{content:\"\"}.ion-ios-pricetags-outline:before{content:\"\"}.ion-ios-printer:before{content:\"\"}.ion-ios-printer-outline:before{content:\"\"}.ion-ios-pulse:before{content:\"\"}.ion-ios-pulse-strong:before{content:\"\"}.ion-ios-rainy:before{content:\"\"}.ion-ios-rainy-outline:before{content:\"\"}.ion-ios-recording:before{content:\"\"}.ion-ios-recording-outline:before{content:\"\"}.ion-ios-redo:before{content:\"\"}.ion-ios-redo-outline:before{content:\"\"}.ion-ios-refresh:before{content:\"\"}.ion-ios-refresh-empty:before{content:\"\"}.ion-ios-refresh-outline:before{content:\"\"}.ion-ios-reload:before{content:\"\"}.ion-ios-reverse-camera:before{content:\"\"}.ion-ios-reverse-camera-outline:before{content:\"\"}.ion-ios-rewind:before{content:\"\"}.ion-ios-rewind-outline:before{content:\"\"}.ion-ios-rose:before{content:\"\"}.ion-ios-rose-outline:before{content:\"\"}.ion-ios-search:before{content:\"\"}.ion-ios-search-strong:before{content:\"\"}.ion-ios-settings:before{content:\"\"}.ion-ios-settings-strong:before{content:\"\"}.ion-ios-shuffle:before{content:\"\"}.ion-ios-shuffle-strong:before{content:\"\"}.ion-ios-skipbackward:before{content:\"\"}.ion-ios-skipbackward-outline:before{content:\"\"}.ion-ios-skipforward:before{content:\"\"}.ion-ios-skipforward-outline:before{content:\"\"}.ion-ios-snowy:before{content:\"\"}.ion-ios-speedometer:before{content:\"\"}.ion-ios-speedometer-outline:before{content:\"\"}.ion-ios-star:before{content:\"\"}.ion-ios-star-half:before{content:\"\"}.ion-ios-star-outline:before{content:\"\"}.ion-ios-stopwatch:before{content:\"\"}.ion-ios-stopwatch-outline:before{content:\"\"}.ion-ios-sunny:before{content:\"\"}.ion-ios-sunny-outline:before{content:\"\"}.ion-ios-telephone:before{content:\"\"}.ion-ios-telephone-outline:before{content:\"\"}.ion-ios-tennisball:before{content:\"\"}.ion-ios-tennisball-outline:before{content:\"\"}.ion-ios-thunderstorm:before{content:\"\"}.ion-ios-thunderstorm-outline:before{content:\"\"}.ion-ios-time:before{content:\"\"}.ion-ios-time-outline:before{content:\"\"}.ion-ios-timer:before{content:\"\"}.ion-ios-timer-outline:before{content:\"\"}.ion-ios-toggle:before{content:\"\"}.ion-ios-toggle-outline:before{content:\"\"}.ion-ios-trash:before{content:\"\"}.ion-ios-trash-outline:before{content:\"\"}.ion-ios-undo:before{content:\"\"}.ion-ios-undo-outline:before{content:\"\"}.ion-ios-unlocked:before{content:\"\"}.ion-ios-unlocked-outline:before{content:\"\"}.ion-ios-upload:before{content:\"\"}.ion-ios-upload-outline:before{content:\"\"}.ion-ios-videocam:before{content:\"\"}.ion-ios-videocam-outline:before{content:\"\"}.ion-ios-volume-high:before{content:\"\"}.ion-ios-volume-low:before{content:\"\"}.ion-ios-wineglass:before{content:\"\"}.ion-ios-wineglass-outline:before{content:\"\"}.ion-ios-world:before{content:\"\"}.ion-ios-world-outline:before{content:\"\"}.ion-ipad:before{content:\"\"}.ion-iphone:before{content:\"\"}.ion-ipod:before{content:\"\"}.ion-jet:before{content:\"\"}.ion-key:before{content:\"\"}.ion-knife:before{content:\"\"}.ion-laptop:before{content:\"\"}.ion-leaf:before{content:\"\"}.ion-levels:before{content:\"\"}.ion-lightbulb:before{content:\"\"}.ion-link:before{content:\"\"}.ion-load-a:before{content:\"\"}.ion-load-b:before{content:\"\"}.ion-load-c:before{content:\"\"}.ion-load-d:before{content:\"\"}.ion-location:before{content:\"\"}.ion-lock-combination:before{content:\"\"}.ion-locked:before{content:\"\"}.ion-log-in:before{content:\"\"}.ion-log-out:before{content:\"\"}.ion-loop:before{content:\"\"}.ion-magnet:before{content:\"\"}.ion-male:before{content:\"\"}.ion-man:before{content:\"\"}.ion-map:before{content:\"\"}.ion-medkit:before{content:\"\"}.ion-merge:before{content:\"\"}.ion-mic-a:before{content:\"\"}.ion-mic-b:before{content:\"\"}.ion-mic-c:before{content:\"\"}.ion-minus:before{content:\"\"}.ion-minus-circled:before{content:\"\"}.ion-minus-round:before{content:\"\"}.ion-model-s:before{content:\"\"}.ion-monitor:before{content:\"\"}.ion-more:before{content:\"\"}.ion-mouse:before{content:\"\"}.ion-music-note:before{content:\"\"}.ion-navicon:before{content:\"\"}.ion-navicon-round:before{content:\"\"}.ion-navigate:before{content:\"\"}.ion-network:before{content:\"\"}.ion-no-smoking:before{content:\"\"}.ion-nuclear:before{content:\"\"}.ion-outlet:before{content:\"\"}.ion-paintbrush:before{content:\"\"}.ion-paintbucket:before{content:\"\"}.ion-paper-airplane:before{content:\"\"}.ion-paperclip:before{content:\"\"}.ion-pause:before{content:\"\"}.ion-person:before{content:\"\"}.ion-person-add:before{content:\"\"}.ion-person-stalker:before{content:\"\"}.ion-pie-graph:before{content:\"\"}.ion-pin:before{content:\"\"}.ion-pinpoint:before{content:\"\"}.ion-pizza:before{content:\"\"}.ion-plane:before{content:\"\"}.ion-planet:before{content:\"\"}.ion-play:before{content:\"\"}.ion-playstation:before{content:\"\"}.ion-plus:before{content:\"\"}.ion-plus-circled:before{content:\"\"}.ion-plus-round:before{content:\"\"}.ion-podium:before{content:\"\"}.ion-pound:before{content:\"\"}.ion-power:before{content:\"\"}.ion-pricetag:before{content:\"\"}.ion-pricetags:before{content:\"\"}.ion-printer:before{content:\"\"}.ion-pull-request:before{content:\"\"}.ion-qr-scanner:before{content:\"\"}.ion-quote:before{content:\"\"}.ion-radio-waves:before{content:\"\"}.ion-record:before{content:\"\"}.ion-refresh:before{content:\"\"}.ion-reply:before{content:\"\"}.ion-reply-all:before{content:\"\"}.ion-ribbon-a:before{content:\"\"}.ion-ribbon-b:before{content:\"\"}.ion-sad:before{content:\"\"}.ion-sad-outline:before{content:\"\"}.ion-scissors:before{content:\"\"}.ion-search:before{content:\"\"}.ion-settings:before{content:\"\"}.ion-share:before{content:\"\"}.ion-shuffle:before{content:\"\"}.ion-skip-backward:before{content:\"\"}.ion-skip-forward:before{content:\"\"}.ion-social-android:before{content:\"\"}.ion-social-android-outline:before{content:\"\"}.ion-social-angular:before{content:\"\"}.ion-social-angular-outline:before{content:\"\"}.ion-social-apple:before{content:\"\"}.ion-social-apple-outline:before{content:\"\"}.ion-social-bitcoin:before{content:\"\"}.ion-social-bitcoin-outline:before{content:\"\"}.ion-social-buffer:before{content:\"\"}.ion-social-buffer-outline:before{content:\"\"}.ion-social-chrome:before{content:\"\"}.ion-social-chrome-outline:before{content:\"\"}.ion-social-codepen:before{content:\"\"}.ion-social-codepen-outline:before{content:\"\"}.ion-social-css3:before{content:\"\"}.ion-social-css3-outline:before{content:\"\"}.ion-social-designernews:before{content:\"\"}.ion-social-designernews-outline:before{content:\"\"}.ion-social-dribbble:before{content:\"\"}.ion-social-dribbble-outline:before{content:\"\"}.ion-social-dropbox:before{content:\"\"}.ion-social-dropbox-outline:before{content:\"\"}.ion-social-euro:before{content:\"\"}.ion-social-euro-outline:before{content:\"\"}.ion-social-facebook:before{content:\"\"}.ion-social-facebook-outline:before{content:\"\"}.ion-social-foursquare:before{content:\"\"}.ion-social-foursquare-outline:before{content:\"\"}.ion-social-freebsd-devil:before{content:\"\"}.ion-social-github:before{content:\"\"}.ion-social-github-outline:before{content:\"\"}.ion-social-google:before{content:\"\"}.ion-social-google-outline:before{content:\"\"}.ion-social-googleplus:before{content:\"\"}.ion-social-googleplus-outline:before{content:\"\"}.ion-social-hackernews:before{content:\"\"}.ion-social-hackernews-outline:before{content:\"\"}.ion-social-html5:before{content:\"\"}.ion-social-html5-outline:before{content:\"\"}.ion-social-instagram:before{content:\"\"}.ion-social-instagram-outline:before{content:\"\"}.ion-social-javascript:before{content:\"\"}.ion-social-javascript-outline:before{content:\"\"}.ion-social-linkedin:before{content:\"\"}.ion-social-linkedin-outline:before{content:\"\"}.ion-social-markdown:before{content:\"\"}.ion-social-nodejs:before{content:\"\"}.ion-social-octocat:before{content:\"\"}.ion-social-pinterest:before{content:\"\"}.ion-social-pinterest-outline:before{content:\"\"}.ion-social-python:before{content:\"\"}.ion-social-reddit:before{content:\"\"}.ion-social-reddit-outline:before{content:\"\"}.ion-social-rss:before{content:\"\"}.ion-social-rss-outline:before{content:\"\"}.ion-social-sass:before{content:\"\"}.ion-social-skype:before{content:\"\"}.ion-social-skype-outline:before{content:\"\"}.ion-social-snapchat:before{content:\"\"}.ion-social-snapchat-outline:before{content:\"\"}.ion-social-tumblr:before{content:\"\"}.ion-social-tumblr-outline:before{content:\"\"}.ion-social-tux:before{content:\"\"}.ion-social-twitch:before{content:\"\"}.ion-social-twitch-outline:before{content:\"\"}.ion-social-twitter:before{content:\"\"}.ion-social-twitter-outline:before{content:\"\"}.ion-social-usd:before{content:\"\"}.ion-social-usd-outline:before{content:\"\"}.ion-social-vimeo:before{content:\"\"}.ion-social-vimeo-outline:before{content:\"\"}.ion-social-whatsapp:before{content:\"\"}.ion-social-whatsapp-outline:before{content:\"\"}.ion-social-windows:before{content:\"\"}.ion-social-windows-outline:before{content:\"\"}.ion-social-wordpress:before{content:\"\"}.ion-social-wordpress-outline:before{content:\"\"}.ion-social-yahoo:before{content:\"\"}.ion-social-yahoo-outline:before{content:\"\"}.ion-social-yen:before{content:\"\"}.ion-social-yen-outline:before{content:\"\"}.ion-social-youtube:before{content:\"\"}.ion-social-youtube-outline:before{content:\"\"}.ion-soup-can:before{content:\"\"}.ion-soup-can-outline:before{content:\"\"}.ion-speakerphone:before{content:\"\"}.ion-speedometer:before{content:\"\"}.ion-spoon:before{content:\"\"}.ion-star:before{content:\"\"}.ion-stats-bars:before{content:\"\"}.ion-steam:before{content:\"\"}.ion-stop:before{content:\"\"}.ion-thermometer:before{content:\"\"}.ion-thumbsdown:before{content:\"\"}.ion-thumbsup:before{content:\"\"}.ion-toggle:before{content:\"\"}.ion-toggle-filled:before{content:\"\"}.ion-transgender:before{content:\"\"}.ion-trash-a:before{content:\"\"}.ion-trash-b:before{content:\"\"}.ion-trophy:before{content:\"\"}.ion-tshirt:before{content:\"\"}.ion-tshirt-outline:before{content:\"\"}.ion-umbrella:before{content:\"\"}.ion-university:before{content:\"\"}.ion-unlocked:before{content:\"\"}.ion-upload:before{content:\"\"}.ion-usb:before{content:\"\"}.ion-videocamera:before{content:\"\"}.ion-volume-high:before{content:\"\"}.ion-volume-low:before{content:\"\"}.ion-volume-medium:before{content:\"\"}.ion-volume-mute:before{content:\"\"}.ion-wand:before{content:\"\"}.ion-waterdrop:before{content:\"\"}.ion-wifi:before{content:\"\"}.ion-wineglass:before{content:\"\"}.ion-woman:before{content:\"\"}.ion-wrench:before{content:\"\"}.ion-xbox:before{content:\"\"}a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;vertical-align:baseline;font:inherit;font-size:100%}address,cite{font-style:normal}ol,ul{list-style:none}blockquote,q{quotes:none}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none!important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;overflow:hidden;-ms-touch-action:pan-y;touch-action:pan-y}.ionic-body,.scroll,body{-webkit-text-size-adjust:none}:focus,a,a:active,a:focus,a:hover,button,button:focus{outline:0}a[href]:hover{cursor:pointer}b,strong{font-weight:700}dfn{font-style:italic}hr{height:0}code,kbd,pre,samp{font-size:1em;font-family:monospace,serif}.h1,.h2,.h3,.h4,.h5,.h6,.ionic-body,.tab-item,body,button,h1,h2,h3,h4,h5,h6,input,select,textarea{font-family:\"Helvetica Neue\",Roboto,\"Segoe UI\",sans-serif}pre{white-space:pre-wrap}q{quotes:\"\\201C\" \"\\201D\" \"\\2018\" \"\\2019\"}sub,sup{vertical-align:baseline;font-size:75%;line-height:0}sup{top:-.5em}sub{bottom:-.25em}fieldset{margin:0 2px;padding:.35em .625em .75em;border:1px solid silver}button,input,select,textarea{margin:0;outline-offset:0;outline-style:none;outline-width:0;-webkit-font-smoothing:inherit;background-image:none}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{cursor:pointer;-webkit-appearance:button}button[disabled],html input[disabled]{cursor:default}input[type=search]{-webkit-box-sizing:content-box;-webkit-appearance:textfield}.item-input .button-bar,.item-input input{-webkit-border-radius:0;border-radius:0;appearance:none}*,.bar,.toggle .track,:after,:before{box-sizing:border-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}textarea{overflow:auto}.scroll-content,.scroll-view{margin-top:-1px;overflow:hidden}table{border-spacing:0;border-collapse:collapse}.ionic-body,body{-webkit-font-smoothing:antialiased;font-smoothing:antialiased;text-size-adjust:none;top:0;right:0;bottom:0;left:0;overflow:hidden;margin:0;padding:0;color:#000;word-wrap:break-word;font-size:14px;line-height:20px;text-rendering:optimizeLegibility;-webkit-backface-visibility:hidden;-ms-content-zooming:none}body.grade-b,body.grade-c{text-rendering:auto}.scroll-content{position:absolute;top:0;right:0;bottom:0;left:0;padding-top:1px;margin-bottom:-1px;width:auto;height:auto}.menu .scroll-content.scroll-content-false{z-index:11}.scroll-view{position:relative;display:block}.scroll{text-size-adjust:none;-webkit-transform-origin:left top;transform-origin:left top}@-ms-viewport{width:device-width}.scroll-bar{position:absolute;z-index:9999}.pane,.view{z-index:1}.scroll-bar-h{right:2px;bottom:3px;left:2px;height:3px}.scroll-bar-h .scroll-bar-indicator{height:100%}.scroll-bar-v{top:2px;right:3px;bottom:2px;width:3px}.scroll-bar-v .scroll-bar-indicator{width:100%}.scroll-bar-indicator{position:absolute;border-radius:4px;background:rgba(0,0,0,.3);opacity:1;-webkit-transition:opacity .3s linear}.backdrop,.scroll-bar-indicator.scroll-bar-fade-out{opacity:0}.platform-android .scroll-bar-indicator{border-radius:0}.grade-b .scroll-bar-indicator,.grade-c .scroll-bar-indicator{background:#aaa}.grade-b .scroll-bar-indicator.scroll-bar-fade-out,.grade-c .scroll-bar-indicator.scroll-bar-fade-out{-webkit-transition:none;transition:none}ion-infinite-scroll{height:60px;width:100%;display:block;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-moz-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}ion-infinite-scroll .icon{font-size:30px;color:#666}ion-infinite-scroll .icon:before,ion-infinite-scroll .spinner{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}ion-infinite-scroll:not(.active) .icon:before,ion-infinite-scroll:not(.active) .spinner{-webkit-transform:translate3d(-1000px,0,0);transform:translate3d(-1000px,0,0)}.overflow-scroll .scroll,.pane{-webkit-transform:translate3d(0,0,0)}.overflow-scroll{overflow-x:hidden;overflow-y:scroll;-webkit-overflow-scrolling:touch;top:0;right:0;bottom:0;left:0;position:absolute}.action-sheet,.action-sheet-group,.bar .title,.menu,.modal,.pane,.tab-item,.view{overflow:hidden}.overflow-scroll .scroll{position:static;height:100%}.has-header{top:44px}.no-header{top:0}.has-subheader{top:88px}.has-tabs-top{top:93px}.has-header.has-subheader.has-tabs-top{top:137px}.has-footer{bottom:44px}.has-subfooter{bottom:88px}.bar-footer.has-tabs,.has-tabs{bottom:49px}.bar-footer.has-tabs.pane,.has-tabs.pane{bottom:49px;height:auto}.has-footer.has-tabs{bottom:93px}.pane{transform:translate3d(0,0,0);-webkit-transition-duration:0;transition-duration:0}.pane,.view{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;height:100%;background-color:#fff}.view-container{position:absolute;display:block;width:100%;height:100%}p{margin:0 0 10px}small{font-size:85%}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{color:#000;font-weight:500;line-height:1.2}.h1 small,.h2 small,.h3 small,.h4 small,.h5 small,.h6 small,h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:400;line-height:1}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1:first-child,.h2:first-child,.h3:first-child,h1:first-child,h2:first-child,h3:first-child{margin-top:0}.h1+.h1,.h1+.h2,.h1+.h3,.h1+h1,.h1+h2,.h1+h3,.h2+.h1,.h2+.h2,.h2+.h3,.h2+h1,.h2+h2,.h2+h3,.h3+.h1,.h3+.h2,.h3+.h3,.h3+h1,.h3+h2,.h3+h3,h1+.h1,h1+.h2,h1+.h3,h1+h1,h1+h2,h1+h3,h2+.h1,h2+.h2,h2+.h3,h2+h1,h2+h2,h2+h3,h3+.h1,h3+.h2,h3+.h3,h3+h1,h3+h2,h3+h3{margin-top:10px}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}.h1 small,h1 small{font-size:24px}.h2 small,h2 small{font-size:18px}.h3 small,.h4 small,h3 small,h4 small{font-size:14px}dl{margin-bottom:20px}dd,dt{line-height:1.42857}dt{font-weight:700}blockquote{margin:0 0 20px;padding:10px 20px;border-left:5px solid gray}blockquote p{font-weight:300;font-size:17.5px;line-height:1.25}.action-sheet-cancel .button,.bar .title{font-weight:500}blockquote p:last-child{margin-bottom:0}blockquote small{display:block;line-height:1.42857}blockquote small:before{content:'\\2014 \\00A0'}blockquote:after,blockquote:before,q:after,q:before{content:\"\"}address{display:block;margin-bottom:20px;line-height:1.42857}a.subdued{padding-right:10px;color:#888;text-decoration:none}a.subdued:hover{text-decoration:none}a.subdued:last-child{padding-right:0}.action-sheet-backdrop{-webkit-transition:background-color 150ms ease-in-out;transition:background-color 150ms ease-in-out;position:fixed;top:0;left:0;z-index:11;width:100%;height:100%;background-color:transparent}.action-sheet-backdrop.active{background-color:rgba(0,0,0,.4)}.action-sheet-wrapper{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0);-webkit-transition:all cubic-bezier(.36,.66,.04,1)500ms;transition:all cubic-bezier(.36,.66,.04,1)500ms;position:absolute;bottom:0;left:0;right:0;width:100%;max-width:500px;margin:auto}.action-sheet-up,.bar,.tabs{transform:translate3d(0,0,0);-webkit-transform:translate3d(0,0,0)}.action-sheet{margin-left:8px;margin-right:8px;width:auto;z-index:11}.backdrop,.bar,.tabs{width:100%}.action-sheet .button{display:block;padding:1px;width:100%;border-radius:0;border-color:#d1d3d6;background-color:transparent;color:#007aff;font-size:21px}.action-sheet .button:hover{color:#007aff}.action-sheet .button.destructive,.action-sheet .button.destructive:hover{color:#ff3b30}.action-sheet .button.activated,.action-sheet .button.active{box-shadow:none;border-color:#d1d3d6;color:#007aff;background:#e4e5e7}.action-sheet-has-icons .icon{position:absolute;left:16px}.action-sheet-title{padding:16px;color:#8f8f8f;text-align:center;font-size:13px}.action-sheet-group{margin-bottom:8px;border-radius:4px;background-color:#fff}.action-sheet-group .button{border-width:1px 0 0}.action-sheet-group .button:first-child:last-child,.bar{border-width:0}.action-sheet-options{background:#f1f2f3}.action-sheet-open,.action-sheet-open.modal-open .modal{pointer-events:none}.action-sheet-open .action-sheet-backdrop{pointer-events:auto}.menu-open .menu-content .pane,.menu-open .menu-content .scroll-content,.modal-backdrop-bg,.modal-open{pointer-events:none}.platform-android .action-sheet-backdrop.active{background-color:rgba(0,0,0,.2)}.platform-android .action-sheet{margin:0}.platform-android .action-sheet .action-sheet-title,.platform-android .action-sheet .button{text-align:left;border-color:transparent;font-size:16px;color:inherit}.platform-android .action-sheet .action-sheet-title{font-size:14px;padding:16px;color:#666}.platform-android .action-sheet .button.activated,.platform-android .action-sheet .button.active{background:#e8e8e8}.platform-android .action-sheet-group{margin:0;border-radius:0;background-color:#fafafa}.platform-android .action-sheet-cancel{display:none}.platform-android .action-sheet-has-icons .button{padding-left:56px}.backdrop{position:fixed;top:0;left:0;z-index:11;height:100%;background-color:rgba(0,0,0,.4);-webkit-transition:.1s opacity linear;transition:.1s opacity linear}.bar,.bar .title,.bar-footer.item-input-inset,.nav-bar-block,.tabs{position:absolute}.backdrop.visible{visibility:visible}.backdrop.active{opacity:1}.bar{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;right:0;left:0;z-index:9;padding:5px;height:44px;border-style:solid;border-top:1px solid transparent;border-bottom:1px solid #ddd;background-color:#fff;background-size:0}@media (min--moz-device-pixel-ratio:1.5),(-webkit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5),(min-resolution:144dpi),(min-resolution:1.5dppx){.bar{border:none;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);background-position:bottom;background-size:100% 1px;background-repeat:no-repeat}}.bar.bar-clear{border:none;background:0 0;color:#fff}.bar.bar-clear .button,.bar.bar-clear .title{color:#fff}.bar.bar-light,.bar.bar-light .title,.bar.bar-stable .title{color:#444}.bar.item-input-inset .item-input-wrapper{margin-top:-1px}.bar.item-input-inset .item-input-wrapper input{padding-left:8px;width:94%;height:28px;background:0 0}.bar.bar-light{border-color:#ddd;background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%)}.bar.bar-light.bar-footer{background-image:linear-gradient(180deg,#ddd,#ddd 50%,transparent 50%)}.bar.bar-stable{border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444}.bar.bar-assertive,.bar.bar-assertive .title,.bar.bar-balanced .title,.bar.bar-calm,.bar.bar-calm .title,.bar.bar-dark,.bar.bar-dark .title,.bar.bar-energized,.bar.bar-energized .title,.bar.bar-positive,.bar.bar-positive .title,.bar.bar-royal,.bar.bar-royal .title{color:#fff}.bar.bar-stable.bar-footer{background-image:linear-gradient(180deg,#b2b2b2,#b2b2b2 50%,transparent 50%)}.bar.bar-positive{border-color:#0c60ee;background-color:#387ef5;background-image:linear-gradient(0deg,#0c60ee,#0c60ee 50%,transparent 50%)}.bar.bar-positive.bar-footer{background-image:linear-gradient(180deg,#0c60ee,#0c60ee 50%,transparent 50%)}.bar.bar-calm{border-color:#0a9dc7;background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9dc7,#0a9dc7 50%,transparent 50%)}.bar.bar-calm.bar-footer{background-image:linear-gradient(180deg,#0a9dc7,#0a9dc7 50%,transparent 50%)}.bar.bar-assertive{border-color:#e42112;background-color:#ef473a;background-image:linear-gradient(0deg,#e42112,#e42112 50%,transparent 50%)}.bar.bar-assertive.bar-footer{background-image:linear-gradient(180deg,#e42112,#e42112 50%,transparent 50%)}.bar.bar-balanced{border-color:#28a54c;background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);color:#fff}.bar.bar-balanced.bar-footer{background-image:linear-gradient(180deg,#28a54c,#0c60ee 50%,transparent 50%)}.bar.bar-energized{border-color:#e6b500;background-color:#ffc900;background-image:linear-gradient(0deg,#e6b500,#e6b500 50%,transparent 50%)}.bar.bar-energized.bar-footer{background-image:linear-gradient(180deg,#e6b500,#e6b500 50%,transparent 50%)}.bar.bar-royal{border-color:#6b46e5;background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%)}.bar.bar-royal.bar-footer{background-image:linear-gradient(180deg,#6b46e5,#6b46e5 50%,transparent 50%)}.bar.bar-dark{border-color:#111;background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%)}.bar.bar-dark.bar-footer{background-image:linear-gradient(180deg,#111,#111 50%,transparent 50%)}.bar .title{top:0;right:0;left:0;z-index:0;margin:0 10px;min-width:30px;height:43px;text-align:center;font-size:17px;line-height:44px}.bar .title.title-left{text-align:left}.bar .title.title-right{text-align:right}.bar .title a{color:inherit}.bar .button{z-index:1;padding:0 8px;min-width:initial;min-height:31px;font-weight:400;font-size:13px;line-height:32px}.bar .button .icon:before,.bar .button.button-icon:before,.bar .button.icon-left:before,.bar .button.icon-right:before,.bar .button.icon:before{padding-right:2px;padding-left:2px;font-size:20px;line-height:32px}.bar .button.button-icon{font-size:17px}.bar .button.button-icon .icon:before,.bar .button.button-icon.icon-left:before,.bar .button.button-icon.icon-right:before,.bar .button.button-icon:before{vertical-align:top;font-size:32px;line-height:32px}.bar .button.button-clear{padding-right:2px;padding-left:2px;font-weight:300;font-size:17px}.bar .button.button-clear .icon:before,.bar .button.button-clear.icon-left:before,.bar .button.button-clear.icon-right:before,.bar .button.button-clear.icon:before{font-size:32px;line-height:32px}.bar .button.back-button{display:block;margin-right:5px;padding:0;white-space:nowrap;font-weight:400}.bar .button.back-button.activated,.bar .button.back-button.active{opacity:.2}.bar .button-bar>.button,.bar .buttons>.button{min-height:31px;line-height:32px}.menu,.modal{min-height:100%}.bar .button+.button-bar,.bar .button-bar+.button{margin-left:5px}.bar .buttons,.bar .buttons.primary-buttons,.bar .buttons.secondary-buttons{display:inherit}.bar .buttons span{display:inline-block}.bar .buttons-left span{margin-right:5px;display:inherit}.bar .buttons-right span{margin-left:5px;display:inherit}.bar .buttons.pull-right,.bar .title+.button:last-child,.bar .title+.buttons,.bar>.button+.button:last-child,.bar>.button.pull-right{position:absolute;top:5px;right:5px;bottom:5px}.platform-android .nav-bar-has-subheader .bar{background-image:none}.platform-android .bar .back-button .icon:before{font-size:24px}.platform-android .bar .title{font-size:19px;line-height:44px}.bar-light .button{border-color:#ddd;background-color:#fff;color:#444}.bar-light .button:hover{color:#444;text-decoration:none}.bar-light .button.activated,.bar-light .button.active{border-color:#ccc;background-color:#fafafa;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-light .button.button-clear,.bar-light .button.button-icon{border-color:transparent;background:0 0}.bar-light .button.button-clear{box-shadow:none;color:#444;font-size:17px}.bar-stable .button{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.bar-stable .button:hover{color:#444;text-decoration:none}.bar-stable .button.activated,.bar-stable .button.active{border-color:#a2a2a2;background-color:#e5e5e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-stable .button.button-clear,.bar-stable .button.button-icon{border-color:transparent;background:0 0}.bar-stable .button.button-clear{box-shadow:none;color:#444;font-size:17px}.bar-positive .button{border-color:#0c60ee;background-color:#387ef5;color:#fff}.bar-positive .button:hover{color:#fff;text-decoration:none}.bar-positive .button.activated,.bar-positive .button.active{border-color:#0c60ee;background-color:#0c60ee;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-positive .button.button-clear,.bar-positive .button.button-icon{border-color:transparent;background:0 0}.bar-positive .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-calm .button{border-color:#0a9dc7;background-color:#11c1f3;color:#fff}.bar-calm .button:hover{color:#fff;text-decoration:none}.bar-calm .button.activated,.bar-calm .button.active{border-color:#0a9dc7;background-color:#0a9dc7;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-calm .button.button-clear,.bar-calm .button.button-icon{border-color:transparent;background:0 0}.bar-calm .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-assertive .button{border-color:#e42112;background-color:#ef473a;color:#fff}.bar-assertive .button:hover{color:#fff;text-decoration:none}.bar-assertive .button.activated,.bar-assertive .button.active{border-color:#e42112;background-color:#e42112;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-assertive .button.button-clear,.bar-assertive .button.button-icon{border-color:transparent;background:0 0}.bar-assertive .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-balanced .button{border-color:#28a54c;background-color:#33cd5f;color:#fff}.bar-balanced .button:hover{color:#fff;text-decoration:none}.bar-balanced .button.activated,.bar-balanced .button.active{border-color:#28a54c;background-color:#28a54c;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-balanced .button.button-clear,.bar-balanced .button.button-icon{border-color:transparent;background:0 0}.bar-balanced .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-energized .button{border-color:#e6b500;background-color:#ffc900;color:#fff}.bar-energized .button:hover{color:#fff;text-decoration:none}.bar-energized .button.activated,.bar-energized .button.active{border-color:#e6b500;background-color:#e6b500;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-energized .button.button-clear,.bar-energized .button.button-icon{border-color:transparent;background:0 0}.bar-energized .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-royal .button{border-color:#6b46e5;background-color:#886aea;color:#fff}.bar-royal .button:hover{color:#fff;text-decoration:none}.bar-royal .button.activated,.bar-royal .button.active{border-color:#6b46e5;background-color:#6b46e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-royal .button.button-clear,.bar-royal .button.button-icon{border-color:transparent;background:0 0}.bar-royal .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-dark .button{border-color:#111;background-color:#444;color:#fff}.bar-dark .button:hover{color:#fff;text-decoration:none}.bar-dark .button.activated,.bar-dark .button.active{border-color:#000;background-color:#262626;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-dark .button.button-clear,.bar-dark .button.button-icon{border-color:transparent;background:0 0}.bar-dark .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-header{top:0;border-top-width:0;border-bottom-width:1px}.bar-footer,.tabs{border-top-width:1px}.bar-header.has-tabs-top,.tabs-top .bar-header{border-bottom-width:0;background-image:none}.bar-footer{bottom:0;border-bottom-width:0;background-position:top;height:44px}.bar-tabs{padding:0}.bar-subheader{top:44px;display:block;height:44px}.bar-subfooter{bottom:44px;display:block;height:44px}.nav-bar-block{top:0;right:0;left:0;z-index:9}.bar .back-button.hide,.bar .buttons .hide{display:none}.nav-bar-tabs-top .bar{background-image:none}.tabs{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:horizontal;-moz-flex-direction:horizontal;-ms-flex-direction:horizontal;flex-direction:horizontal;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444;bottom:0;z-index:5;height:49px;border-style:solid;background-size:0;line-height:49px}.tabs .tab-item .badge{background-color:#444;color:#f8f8f8}@media (min--moz-device-pixel-ratio:1.5),(-webkit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5),(min-resolution:144dpi),(min-resolution:1.5dppx){.tabs{padding-top:2px;border-top:none!important;border-bottom:none;background-position:top;background-size:100% 1px;background-repeat:no-repeat}}.tabs-light>.tabs,.tabs.tabs-light{border-color:#ddd;background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);color:#444}.tabs-light>.tabs .tab-item .badge,.tabs.tabs-light .tab-item .badge{background-color:#444;color:#fff}.tabs-stable>.tabs,.tabs.tabs-stable{border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444}.tabs-stable>.tabs .tab-item .badge,.tabs.tabs-stable .tab-item .badge{background-color:#444;color:#f8f8f8}.tabs-positive>.tabs,.tabs.tabs-positive{border-color:#0c60ee;background-color:#387ef5;background-image:linear-gradient(0deg,#0c60ee,#0c60ee 50%,transparent 50%);color:#fff}.tabs-positive>.tabs .tab-item .badge,.tabs.tabs-positive .tab-item .badge{background-color:#fff;color:#387ef5}.tabs-calm>.tabs,.tabs.tabs-calm{border-color:#0a9dc7;background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9dc7,#0a9dc7 50%,transparent 50%);color:#fff}.tabs-calm>.tabs .tab-item .badge,.tabs.tabs-calm .tab-item .badge{background-color:#fff;color:#11c1f3}.tabs-assertive>.tabs,.tabs.tabs-assertive{border-color:#e42112;background-color:#ef473a;background-image:linear-gradient(0deg,#e42112,#e42112 50%,transparent 50%);color:#fff}.tabs-assertive>.tabs .tab-item .badge,.tabs.tabs-assertive .tab-item .badge{background-color:#fff;color:#ef473a}.tabs-balanced>.tabs,.tabs.tabs-balanced{border-color:#28a54c;background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);color:#fff}.tabs-balanced>.tabs .tab-item .badge,.tabs.tabs-balanced .tab-item .badge{background-color:#fff;color:#33cd5f}.tabs-energized>.tabs,.tabs.tabs-energized{border-color:#e6b500;background-color:#ffc900;background-image:linear-gradient(0deg,#e6b500,#e6b500 50%,transparent 50%);color:#fff}.tabs-energized>.tabs .tab-item .badge,.tabs.tabs-energized .tab-item .badge{background-color:#fff;color:#ffc900}.tabs-royal>.tabs,.tabs.tabs-royal{border-color:#6b46e5;background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%);color:#fff}.tabs-royal>.tabs .tab-item .badge,.tabs.tabs-royal .tab-item .badge{background-color:#fff;color:#886aea}.tabs-dark>.tabs,.tabs.tabs-dark{border-color:#111;background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%);color:#fff}.tabs-striped .tabs,.tabs-striped.tabs-light .tabs{background-color:#fff}.tabs-dark>.tabs .tab-item .badge,.tabs.tabs-dark .tab-item .badge{background-color:#fff;color:#444}.tabs-striped .tabs{background-image:none;border:none;border-bottom:1px solid #ddd;padding-top:2px}.tabs-striped .tab-item.activated,.tabs-striped .tab-item.active,.tabs-striped .tab-item.tab-item-active{margin-top:-2px;border-style:solid;border-width:2px 0 0;border-color:#444}.tabs-striped .tab-item.activated .badge,.tabs-striped .tab-item.active .badge,.tabs-striped .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-light .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-light .tab-item .badge{opacity:.4}.tabs-striped.tabs-light .tab-item.activated,.tabs-striped.tabs-light .tab-item.active,.tabs-striped.tabs-light .tab-item.tab-item-active{margin-top:-2px;color:#444;border-style:solid;border-width:2px 0 0;border-color:#444}.tabs-striped.tabs-stable .tabs{background-color:#f8f8f8}.tabs-striped.tabs-stable .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-stable .tab-item .badge{opacity:.4}.tabs-striped.tabs-stable .tab-item.activated,.tabs-striped.tabs-stable .tab-item.active,.tabs-striped.tabs-stable .tab-item.tab-item-active{margin-top:-2px;color:#444;border-style:solid;border-width:2px 0 0;border-color:#444}.tabs-striped.tabs-positive .tabs{background-color:#387ef5}.tabs-striped.tabs-positive .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-positive .tab-item .badge{opacity:.4}.tabs-striped.tabs-positive .tab-item.activated,.tabs-striped.tabs-positive .tab-item.active,.tabs-striped.tabs-positive .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-calm .tabs{background-color:#11c1f3}.tabs-striped.tabs-calm .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-calm .tab-item .badge{opacity:.4}.tabs-striped.tabs-calm .tab-item.activated,.tabs-striped.tabs-calm .tab-item.active,.tabs-striped.tabs-calm .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-assertive .tabs{background-color:#ef473a}.tabs-striped.tabs-assertive .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-assertive .tab-item .badge{opacity:.4}.tabs-striped.tabs-assertive .tab-item.activated,.tabs-striped.tabs-assertive .tab-item.active,.tabs-striped.tabs-assertive .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-balanced .tabs{background-color:#33cd5f}.tabs-striped.tabs-balanced .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-balanced .tab-item .badge{opacity:.4}.tabs-striped.tabs-balanced .tab-item.activated,.tabs-striped.tabs-balanced .tab-item.active,.tabs-striped.tabs-balanced .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-energized .tabs{background-color:#ffc900}.tabs-striped.tabs-energized .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-energized .tab-item .badge{opacity:.4}.tabs-striped.tabs-energized .tab-item.activated,.tabs-striped.tabs-energized .tab-item.active,.tabs-striped.tabs-energized .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-royal .tabs{background-color:#886aea}.tabs-striped.tabs-royal .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-royal .tab-item .badge{opacity:.4}.tabs-striped.tabs-royal .tab-item.activated,.tabs-striped.tabs-royal .tab-item.active,.tabs-striped.tabs-royal .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-dark .tabs{background-color:#444}.tabs-striped.tabs-dark .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-dark .tab-item .badge{opacity:.4}.tabs-striped.tabs-dark .tab-item.activated,.tabs-striped.tabs-dark .tab-item.active,.tabs-striped.tabs-dark .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.item,.item.item-light{background-color:#fff;border-color:#ddd}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-background-light .tabs{background-color:#fff;background-image:none}.tabs-striped.tabs-background-stable .tabs{background-color:#f8f8f8;background-image:none}.tabs-striped.tabs-background-positive .tabs{background-color:#387ef5;background-image:none}.tabs-striped.tabs-background-calm .tabs{background-color:#11c1f3;background-image:none}.tabs-striped.tabs-background-assertive .tabs{background-color:#ef473a;background-image:none}.tabs-striped.tabs-background-balanced .tabs{background-color:#33cd5f;background-image:none}.tabs-striped.tabs-background-energized .tabs{background-color:#ffc900;background-image:none}.tabs-striped.tabs-background-royal .tabs{background-color:#886aea;background-image:none}.tabs-striped.tabs-background-dark .tabs{background-color:#444;background-image:none}.tabs-striped.tabs-color-light .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-color-light .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-light .tab-item.activated,.tabs-striped.tabs-color-light .tab-item.active,.tabs-striped.tabs-color-light .tab-item.tab-item-active{margin-top:-2px;color:#fff;border:0 solid #fff;border-top-width:2px}.tabs-striped.tabs-color-light .tab-item.activated .badge,.tabs-striped.tabs-color-light .tab-item.active .badge,.tabs-striped.tabs-color-light .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-stable .tab-item{color:rgba(248,248,248,.4);opacity:1}.tabs-striped.tabs-color-stable .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-stable .tab-item.activated,.tabs-striped.tabs-color-stable .tab-item.active,.tabs-striped.tabs-color-stable .tab-item.tab-item-active{margin-top:-2px;color:#f8f8f8;border:0 solid #f8f8f8;border-top-width:2px}.tabs-striped.tabs-color-stable .tab-item.activated .badge,.tabs-striped.tabs-color-stable .tab-item.active .badge,.tabs-striped.tabs-color-stable .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-positive .tab-item{color:rgba(56,126,245,.4);opacity:1}.tabs-striped.tabs-color-positive .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-positive .tab-item.activated,.tabs-striped.tabs-color-positive .tab-item.active,.tabs-striped.tabs-color-positive .tab-item.tab-item-active{margin-top:-2px;color:#387ef5;border:0 solid #387ef5;border-top-width:2px}.tabs-striped.tabs-color-positive .tab-item.activated .badge,.tabs-striped.tabs-color-positive .tab-item.active .badge,.tabs-striped.tabs-color-positive .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-calm .tab-item{color:rgba(17,193,243,.4);opacity:1}.tabs-striped.tabs-color-calm .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-calm .tab-item.activated,.tabs-striped.tabs-color-calm .tab-item.active,.tabs-striped.tabs-color-calm .tab-item.tab-item-active{margin-top:-2px;color:#11c1f3;border:0 solid #11c1f3;border-top-width:2px}.tabs-striped.tabs-color-calm .tab-item.activated .badge,.tabs-striped.tabs-color-calm .tab-item.active .badge,.tabs-striped.tabs-color-calm .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-assertive .tab-item{color:rgba(239,71,58,.4);opacity:1}.tabs-striped.tabs-color-assertive .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-assertive .tab-item.activated,.tabs-striped.tabs-color-assertive .tab-item.active,.tabs-striped.tabs-color-assertive .tab-item.tab-item-active{margin-top:-2px;color:#ef473a;border:0 solid #ef473a;border-top-width:2px}.tabs-striped.tabs-color-assertive .tab-item.activated .badge,.tabs-striped.tabs-color-assertive .tab-item.active .badge,.tabs-striped.tabs-color-assertive .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-balanced .tab-item{color:rgba(51,205,95,.4);opacity:1}.tabs-striped.tabs-color-balanced .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-balanced .tab-item.activated,.tabs-striped.tabs-color-balanced .tab-item.active,.tabs-striped.tabs-color-balanced .tab-item.tab-item-active{margin-top:-2px;color:#33cd5f;border:0 solid #33cd5f;border-top-width:2px}.tabs-striped.tabs-color-balanced .tab-item.activated .badge,.tabs-striped.tabs-color-balanced .tab-item.active .badge,.tabs-striped.tabs-color-balanced .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-energized .tab-item{color:rgba(255,201,0,.4);opacity:1}.tabs-striped.tabs-color-energized .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-energized .tab-item.activated,.tabs-striped.tabs-color-energized .tab-item.active,.tabs-striped.tabs-color-energized .tab-item.tab-item-active{margin-top:-2px;color:#ffc900;border:0 solid #ffc900;border-top-width:2px}.tabs-striped.tabs-color-energized .tab-item.activated .badge,.tabs-striped.tabs-color-energized .tab-item.active .badge,.tabs-striped.tabs-color-energized .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-royal .tab-item{color:rgba(136,106,234,.4);opacity:1}.tabs-striped.tabs-color-royal .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-royal .tab-item.activated,.tabs-striped.tabs-color-royal .tab-item.active,.tabs-striped.tabs-color-royal .tab-item.tab-item-active{margin-top:-2px;color:#886aea;border:0 solid #886aea;border-top-width:2px}.tabs-striped.tabs-color-royal .tab-item.activated .badge,.tabs-striped.tabs-color-royal .tab-item.active .badge,.tabs-striped.tabs-color-royal .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-dark .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-color-dark .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-dark .tab-item.activated,.tabs-striped.tabs-color-dark .tab-item.active,.tabs-striped.tabs-color-dark .tab-item.tab-item-active{margin-top:-2px;color:#444;border:0 solid #444;border-top-width:2px}.card .item:first-child,.popover .item:first-child{border-top:0}.tabs-striped.tabs-color-dark .tab-item.activated .badge,.tabs-striped.tabs-color-dark .tab-item.active .badge,.tabs-striped.tabs-color-dark .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-background-light .tabs,.tabs-background-light>.tabs{background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);border-color:#ddd}.tabs-background-stable .tabs,.tabs-background-stable>.tabs{background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);border-color:#b2b2b2}.tabs-background-positive .tabs,.tabs-background-positive>.tabs{background-color:#387ef5;background-image:linear-gradient(0deg,#0c60ee,#0c60ee 50%,transparent 50%);border-color:#0c60ee}.tabs-background-calm .tabs,.tabs-background-calm>.tabs{background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9dc7,#0a9dc7 50%,transparent 50%);border-color:#0a9dc7}.tabs-background-assertive .tabs,.tabs-background-assertive>.tabs{background-color:#ef473a;background-image:linear-gradient(0deg,#e42112,#e42112 50%,transparent 50%);border-color:#e42112}.tabs-background-balanced .tabs,.tabs-background-balanced>.tabs{background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);border-color:#28a54c}.tabs-background-energized .tabs,.tabs-background-energized>.tabs{background-color:#ffc900;background-image:linear-gradient(0deg,#e6b500,#e6b500 50%,transparent 50%);border-color:#e6b500}.tabs-background-royal .tabs,.tabs-background-royal>.tabs{background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%);border-color:#6b46e5}.tabs-background-dark .tabs,.tabs-background-dark>.tabs{background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%);border-color:#111}.tabs-color-light .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-color-light .tab-item .badge{opacity:.4}.tabs-color-light .tab-item.activated,.tabs-color-light .tab-item.active,.tabs-color-light .tab-item.tab-item-active{color:#fff;border:0 solid #fff}.tabs-color-light .tab-item.activated .badge,.tabs-color-light .tab-item.active .badge,.tabs-color-light .tab-item.tab-item-active .badge{opacity:1}.tabs-color-stable .tab-item{color:rgba(248,248,248,.4);opacity:1}.tabs-color-stable .tab-item .badge{opacity:.4}.tabs-color-stable .tab-item.activated,.tabs-color-stable .tab-item.active,.tabs-color-stable .tab-item.tab-item-active{color:#f8f8f8;border:0 solid #f8f8f8}.tabs-color-stable .tab-item.activated .badge,.tabs-color-stable .tab-item.active .badge,.tabs-color-stable .tab-item.tab-item-active .badge{opacity:1}.tabs-color-positive .tab-item{color:rgba(56,126,245,.4);opacity:1}.tabs-color-positive .tab-item .badge{opacity:.4}.tabs-color-positive .tab-item.activated,.tabs-color-positive .tab-item.active,.tabs-color-positive .tab-item.tab-item-active{color:#387ef5;border:0 solid #387ef5}.tabs-color-positive .tab-item.activated .badge,.tabs-color-positive .tab-item.active .badge,.tabs-color-positive .tab-item.tab-item-active .badge{opacity:1}.tabs-color-calm .tab-item{color:rgba(17,193,243,.4);opacity:1}.tabs-color-calm .tab-item .badge{opacity:.4}.tabs-color-calm .tab-item.activated,.tabs-color-calm .tab-item.active,.tabs-color-calm .tab-item.tab-item-active{color:#11c1f3;border:0 solid #11c1f3}.tabs-color-calm .tab-item.activated .badge,.tabs-color-calm .tab-item.active .badge,.tabs-color-calm .tab-item.tab-item-active .badge{opacity:1}.tabs-color-assertive .tab-item{color:rgba(239,71,58,.4);opacity:1}.tabs-color-assertive .tab-item .badge{opacity:.4}.tabs-color-assertive .tab-item.activated,.tabs-color-assertive .tab-item.active,.tabs-color-assertive .tab-item.tab-item-active{color:#ef473a;border:0 solid #ef473a}.tabs-color-assertive .tab-item.activated .badge,.tabs-color-assertive .tab-item.active .badge,.tabs-color-assertive .tab-item.tab-item-active .badge{opacity:1}.tabs-color-balanced .tab-item{color:rgba(51,205,95,.4);opacity:1}.tabs-color-balanced .tab-item .badge{opacity:.4}.tabs-color-balanced .tab-item.activated,.tabs-color-balanced .tab-item.active,.tabs-color-balanced .tab-item.tab-item-active{color:#33cd5f;border:0 solid #33cd5f}.tabs-color-balanced .tab-item.activated .badge,.tabs-color-balanced .tab-item.active .badge,.tabs-color-balanced .tab-item.tab-item-active .badge{opacity:1}.tabs-color-energized .tab-item{color:rgba(255,201,0,.4);opacity:1}.tabs-color-energized .tab-item .badge{opacity:.4}.tabs-color-energized .tab-item.activated,.tabs-color-energized .tab-item.active,.tabs-color-energized .tab-item.tab-item-active{color:#ffc900;border:0 solid #ffc900}.tabs-color-energized .tab-item.activated .badge,.tabs-color-energized .tab-item.active .badge,.tabs-color-energized .tab-item.tab-item-active .badge{opacity:1}.tabs-color-royal .tab-item{color:rgba(136,106,234,.4);opacity:1}.tabs-color-royal .tab-item .badge{opacity:.4}.tabs-color-royal .tab-item.activated,.tabs-color-royal .tab-item.active,.tabs-color-royal .tab-item.tab-item-active{color:#886aea;border:0 solid #886aea}.tabs-color-royal .tab-item.activated .badge,.tabs-color-royal .tab-item.active .badge,.tabs-color-royal .tab-item.tab-item-active .badge{opacity:1}.tabs-color-dark .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-color-dark .tab-item .badge{opacity:.4}.tabs-color-dark .tab-item.activated,.tabs-color-dark .tab-item.active,.tabs-color-dark .tab-item.tab-item-active{color:#444;border:0 solid #444}.tabs-color-dark .tab-item.activated .badge,.tabs-color-dark .tab-item.active .badge,.tabs-color-dark .tab-item.tab-item-active .badge{opacity:1}ion-tabs.tabs-color-active-light .tab-item{color:#444}ion-tabs.tabs-color-active-light .tab-item.activated,ion-tabs.tabs-color-active-light .tab-item.active,ion-tabs.tabs-color-active-light .tab-item.tab-item-active{color:#fff}ion-tabs.tabs-color-active-stable .tab-item{color:#444}ion-tabs.tabs-color-active-stable .tab-item.activated,ion-tabs.tabs-color-active-stable .tab-item.active,ion-tabs.tabs-color-active-stable .tab-item.tab-item-active{color:#f8f8f8}ion-tabs.tabs-color-active-positive .tab-item{color:#444}ion-tabs.tabs-color-active-positive .tab-item.activated,ion-tabs.tabs-color-active-positive .tab-item.active,ion-tabs.tabs-color-active-positive .tab-item.tab-item-active{color:#387ef5}ion-tabs.tabs-color-active-calm .tab-item{color:#444}ion-tabs.tabs-color-active-calm .tab-item.activated,ion-tabs.tabs-color-active-calm .tab-item.active,ion-tabs.tabs-color-active-calm .tab-item.tab-item-active{color:#11c1f3}ion-tabs.tabs-color-active-assertive .tab-item{color:#444}ion-tabs.tabs-color-active-assertive .tab-item.activated,ion-tabs.tabs-color-active-assertive .tab-item.active,ion-tabs.tabs-color-active-assertive .tab-item.tab-item-active{color:#ef473a}ion-tabs.tabs-color-active-balanced .tab-item{color:#444}ion-tabs.tabs-color-active-balanced .tab-item.activated,ion-tabs.tabs-color-active-balanced .tab-item.active,ion-tabs.tabs-color-active-balanced .tab-item.tab-item-active{color:#33cd5f}ion-tabs.tabs-color-active-energized .tab-item{color:#444}ion-tabs.tabs-color-active-energized .tab-item.activated,ion-tabs.tabs-color-active-energized .tab-item.active,ion-tabs.tabs-color-active-energized .tab-item.tab-item-active{color:#ffc900}ion-tabs.tabs-color-active-royal .tab-item{color:#444}ion-tabs.tabs-color-active-royal .tab-item.activated,ion-tabs.tabs-color-active-royal .tab-item.active,ion-tabs.tabs-color-active-royal .tab-item.tab-item-active{color:#886aea}ion-tabs.tabs-color-active-dark .tab-item{color:#fff}ion-tabs.tabs-color-active-dark .tab-item.activated,ion-tabs.tabs-color-active-dark .tab-item.active,ion-tabs.tabs-color-active-dark .tab-item.tab-item-active{color:#444}.tabs-top.tabs-striped{padding-bottom:0}.tabs-top.tabs-striped .tab-item{background:0 0;-webkit-transition:color .1s ease;-moz-transition:color .1s ease;-ms-transition:color .1s ease;-o-transition:color .1s ease;transition:color .1s ease}.menu,.modal{background-color:#fff}.tabs-top.tabs-striped .tab-item.activated,.tabs-top.tabs-striped .tab-item.active,.tabs-top.tabs-striped .tab-item.tab-item-active{margin-top:1px;border-width:0 0 2px!important;border-style:solid}.tabs-top.tabs-striped .tab-item.activated>.badge,.tabs-top.tabs-striped .tab-item.activated>i,.tabs-top.tabs-striped .tab-item.active>.badge,.tabs-top.tabs-striped .tab-item.active>i,.tabs-top.tabs-striped .tab-item.tab-item-active>.badge,.tabs-top.tabs-striped .tab-item.tab-item-active>i{margin-top:-1px}.tabs-top.tabs-striped .tab-item .badge{-webkit-transition:color .2s ease;-moz-transition:color .2s ease;-ms-transition:color .2s ease;-o-transition:color .2s ease;transition:color .2s ease}.tabs-top>.tabs,.tabs.tabs-top{top:44px;padding-top:0;background-position:bottom;border-top-width:0;border-bottom-width:1px}.card .item:last-child,.popover .item:last-child{border-bottom:0}.tabs-top>.tabs .tab-item.activated .badge,.tabs-top>.tabs .tab-item.active .badge,.tabs-top>.tabs .tab-item.tab-item-active .badge,.tabs.tabs-top .tab-item.activated .badge,.tabs.tabs-top .tab-item.active .badge,.tabs.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-top~.bar-header{border-bottom-width:0}.tab-item{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;max-width:150px;height:100%;color:inherit;text-align:center;text-decoration:none;font-weight:400;font-size:14px;opacity:.7}.tab-item:hover{cursor:pointer}.tab-item.tab-hidden,.tabs-item-hide>.tabs,.tabs.tabs-item-hide{display:none}.tabs-icon-bottom.tabs .tab-item,.tabs-icon-bottom>.tabs .tab-item,.tabs-icon-top.tabs .tab-item,.tabs-icon-top>.tabs .tab-item{font-size:10px;line-height:14px}.tab-item .icon{display:block;margin:0 auto;height:32px;font-size:32px}.tabs-icon-left.tabs .tab-item,.tabs-icon-left>.tabs .tab-item,.tabs-icon-right.tabs .tab-item,.tabs-icon-right>.tabs .tab-item{font-size:10px}.tabs-icon-left.tabs .tab-item .icon,.tabs-icon-left>.tabs .tab-item .icon,.tabs-icon-right.tabs .tab-item .icon,.tabs-icon-right>.tabs .tab-item .icon{display:inline-block;vertical-align:top;margin-top:-.1em}.tabs-icon-left.tabs .tab-item .icon:before,.tabs-icon-left>.tabs .tab-item .icon:before,.tabs-icon-right.tabs .tab-item .icon:before,.tabs-icon-right>.tabs .tab-item .icon:before{font-size:24px;line-height:49px}.tabs-icon-left.tabs .tab-item .icon,.tabs-icon-left>.tabs .tab-item .icon{padding-right:3px}.tabs-icon-right.tabs .tab-item .icon,.tabs-icon-right>.tabs .tab-item .icon{padding-left:3px}.tabs-icon-only.tabs .icon,.tabs-icon-only>.tabs .icon{line-height:inherit}.tab-item.has-badge{position:relative}.tab-item .badge{position:absolute;top:4%;right:33%;right:calc(50% - 26px);padding:1px 6px;height:auto;font-size:12px;line-height:16px}.tab-item.activated,.tab-item.active,.tab-item.tab-item-active{opacity:1}.tab-item.activated.tab-item-light,.tab-item.active.tab-item-light,.tab-item.tab-item-active.tab-item-light{color:#fff}.tab-item.activated.tab-item-stable,.tab-item.active.tab-item-stable,.tab-item.tab-item-active.tab-item-stable{color:#f8f8f8}.tab-item.activated.tab-item-positive,.tab-item.active.tab-item-positive,.tab-item.tab-item-active.tab-item-positive{color:#387ef5}.tab-item.activated.tab-item-calm,.tab-item.active.tab-item-calm,.tab-item.tab-item-active.tab-item-calm{color:#11c1f3}.tab-item.activated.tab-item-assertive,.tab-item.active.tab-item-assertive,.tab-item.tab-item-active.tab-item-assertive{color:#ef473a}.tab-item.activated.tab-item-balanced,.tab-item.active.tab-item-balanced,.tab-item.tab-item-active.tab-item-balanced{color:#33cd5f}.tab-item.activated.tab-item-energized,.tab-item.active.tab-item-energized,.tab-item.tab-item-active.tab-item-energized{color:#ffc900}.tab-item.activated.tab-item-royal,.tab-item.active.tab-item-royal,.tab-item.tab-item-active.tab-item-royal{color:#886aea}.tab-item.activated.tab-item-dark,.tab-item.active.tab-item-dark,.tab-item.tab-item-active.tab-item-dark{color:#444}.item.tabs{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;padding:0}.item.tabs .icon:before{position:relative}.tab-item.disabled,.tab-item[disabled]{opacity:.4;cursor:default;pointer-events:none}.menu{position:absolute;top:0;bottom:0;z-index:0;max-height:100%;width:275px}.menu .scroll-content{z-index:10}.menu .bar-header{z-index:11}.menu-content{-webkit-transform:none;transform:none;box-shadow:-1px 0 2px rgba(0,0,0,.2),1px 0 2px rgba(0,0,0,.2)}.grade-b .menu-content,.grade-c .menu-content{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;right:-1px;left:-1px;border-right:1px solid #ccc;border-left:1px solid #ccc;box-shadow:none}.menu-left{left:0}.menu-right{right:0}.aside-open.aside-resizing .menu-right{display:none}.menu-animated{-webkit-transition:-webkit-transform 200ms ease;transition:transform 200ms ease}.modal-backdrop,.modal-backdrop-bg{position:fixed;top:0;left:0;z-index:10;width:100%;height:100%}.modal{display:block;position:absolute;top:0;z-index:10;width:100%}@media (min-width:680px){.modal{top:20%;right:20%;bottom:20%;left:20%;min-height:240px;width:60%}.modal.ng-leave-active{bottom:0}.platform-ios.platform-cordova .modal-wrapper .modal .bar-header:not(.bar-subheader){height:44px}.platform-ios.platform-cordova .modal-wrapper .modal .bar-header:not(.bar-subheader)>*{margin-top:0}.platform-ios.platform-cordova .modal-wrapper .modal .bar-subheader,.platform-ios.platform-cordova .modal-wrapper .modal .has-header,.platform-ios.platform-cordova .modal-wrapper .modal .tabs-top>.tabs,.platform-ios.platform-cordova .modal-wrapper .modal .tabs.tabs-top{top:44px}.platform-ios.platform-cordova .modal-wrapper .modal .has-subheader{top:88px}.platform-ios.platform-cordova .modal-wrapper .modal .has-header.has-tabs-top{top:93px}.platform-ios.platform-cordova .modal-wrapper .modal .has-header.has-subheader.has-tabs-top{top:137px}.modal-backdrop-bg{-webkit-transition:opacity 300ms ease-in-out;transition:opacity 300ms ease-in-out;background-color:#000;opacity:0}.active .modal-backdrop-bg{opacity:.5}}.modal-open .modal,.modal-open .modal-backdrop{pointer-events:auto}.modal-open.loading-active .modal,.modal-open.loading-active .modal-backdrop,.popover-open{pointer-events:none}.popover-backdrop{position:fixed;top:0;left:0;z-index:10;width:100%;height:100%;background-color:transparent}.popover-backdrop.active{background-color:rgba(0,0,0,.1)}.popover{position:absolute;top:25%;left:50%;z-index:10;display:block;margin-top:12px;margin-left:-110px;height:280px;width:220px;background-color:#fff;box-shadow:0 1px 3px rgba(0,0,0,.4);opacity:0}.popover.popover-bottom{margin-top:-12px}.popover,.popover .bar-header{border-radius:2px}.popover .scroll-content{z-index:1;margin:2px 0}.popover .bar-header{border-bottom-right-radius:0;border-bottom-left-radius:0}.popover .has-header{border-top-right-radius:0;border-top-left-radius:0}.popover-arrow{display:none}.platform-ios .popover{box-shadow:0 0 40px rgba(0,0,0,.08);border-radius:10px}.platform-ios .popover .bar-header{-webkit-border-top-right-radius:10px;border-top-right-radius:10px;-webkit-border-top-left-radius:10px;border-top-left-radius:10px}.platform-ios .popover .scroll-content{margin:8px 0;border-radius:10px}.platform-ios .popover .scroll-content.has-header{margin-top:0}.platform-ios .popover-arrow{position:absolute;display:block;top:-17px;width:30px;height:19px;overflow:hidden}.platform-ios .popover-arrow:after{position:absolute;top:12px;left:5px;width:20px;height:20px;background-color:#fff;border-radius:3px;content:'';-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.platform-ios .popover-bottom .popover-arrow{top:auto;bottom:-10px}.platform-ios .popover-bottom .popover-arrow:after{top:-6px}.platform-android .popover{margin-top:-32px;background-color:#fafafa;box-shadow:0 2px 6px rgba(0,0,0,.35)}.platform-android .popover .item{border-color:#fafafa;background-color:#fafafa;color:#4d4d4d}.platform-android .popover.popover-bottom{margin-top:32px}.platform-android .popover-backdrop,.platform-android .popover-backdrop.active{background-color:transparent}.popover-open .popover,.popover-open .popover-backdrop{pointer-events:auto}.popover-open.loading-active .popover,.popover-open.loading-active .popover-backdrop,.popup-open,.popup-open.modal-open .modal{pointer-events:none}@media (min-width:680px){.popover{width:360px}}.popup-container{position:absolute;top:0;left:0;bottom:0;right:0;background:0 0;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;z-index:12;visibility:hidden}.popup-container.popup-showing{visibility:visible}.popup-container.popup-hidden .popup{-webkit-animation-name:scaleOut;animation-name:scaleOut;-webkit-animation-duration:.1s;animation-duration:.1s;-webkit-animation-fill-mode:both;animation-fill-mode:both}.popup-container.active .popup{-webkit-animation-name:superScaleIn;animation-name:superScaleIn;-webkit-animation-duration:.2s;animation-duration:.2s;-webkit-animation-fill-mode:both;animation-fill-mode:both}.popup-container .popup{width:250px;max-width:100%;max-height:90%;border-radius:0;background-color:#fff;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-flex-direction:column;-moz-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.popup-container input,.popup-container textarea{width:100%}.popup-head{padding:15px 10px;border-bottom:1px solid #eee;text-align:center}.popup-title{margin:0;padding:0;font-size:15px}.popup-sub-title{margin:5px 0 0;padding:0;font-weight:400;font-size:11px}.popup-body{padding:10px;overflow:auto}.popup-buttons{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-flex-direction:row;-moz-flex-direction:row;-ms-flex-direction:row;flex-direction:row;padding:10px;min-height:65px}.popup-buttons .button{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;min-height:45px;border-radius:0;line-height:20px;margin-right:5px}.popup-buttons .button:last-child{margin-right:0}.popup-open .popup,.popup-open .popup-backdrop{pointer-events:auto}.loading-container{position:absolute;left:0;top:0;right:0;bottom:0;z-index:13;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;-webkit-transition:.2s opacity linear;transition:.2s opacity linear;visibility:hidden;opacity:0}.loading-container:not(.visible) .icon{display:none}.loading-container.visible{visibility:visible}.loading-container.active{opacity:1}.loading-container .loading{padding:20px;border-radius:5px;background-color:rgba(0,0,0,.7);color:#fff;text-align:center;text-overflow:ellipsis;font-size:15px}.item,.item h2{font-size:16px}.loading-container .loading h1,.loading-container .loading h2,.loading-container .loading h3,.loading-container .loading h4,.loading-container .loading h5,.loading-container .loading h6{color:#fff}.item{color:#444;position:relative;z-index:2;display:block;margin:-1px;padding:16px;border-width:1px;border-style:solid}.item h2{margin:0 0 2px;font-weight:400}.item h3{margin:0 0 4px;font-size:14px}.item h4{margin:0 0 4px;font-size:12px}.item h5,.item h6{margin:0 0 3px;font-size:10px}.item p{color:#666;font-size:14px;margin-bottom:2px}.item h1:last-child,.item h2:last-child,.item h3:last-child,.item h4:last-child,.item h5:last-child,.item h6:last-child,.item p:last-child{margin-bottom:0}.item .badge{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;position:absolute;top:16px;right:32px}.item.item-button-right .badge{right:67px}.item.item-divider .badge{top:8px}.item .badge+.badge{margin-right:5px}.item.item-light{color:#444}.item.item-stable{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.item.item-positive{border-color:#0c60ee;background-color:#387ef5;color:#fff}.item.item-calm{border-color:#0a9dc7;background-color:#11c1f3;color:#fff}.item.item-assertive{border-color:#e42112;background-color:#ef473a;color:#fff}.item.item-balanced{border-color:#28a54c;background-color:#33cd5f;color:#fff}.item.item-energized{border-color:#e6b500;background-color:#ffc900;color:#fff}.item.item-royal{border-color:#6b46e5;background-color:#886aea;color:#fff}.item.item-dark{border-color:#111;background-color:#444;color:#fff}.item[ng-click]:hover{cursor:pointer}.item-borderless,.list-borderless .item{border-width:0}.item .item-content.activated,.item .item-content.active,.item-complex.activated .item-content,.item-complex.active .item-content,.item.activated,.item.active{border-color:#ccc;background-color:#D9D9D9}.item .item-content.activated.item-light,.item .item-content.active.item-light,.item-complex.activated .item-content.item-light,.item-complex.active .item-content.item-light,.item.activated.item-light,.item.active.item-light{border-color:#ccc;background-color:#fafafa}.item .item-content.activated.item-stable,.item .item-content.active.item-stable,.item-complex.activated .item-content.item-stable,.item-complex.active .item-content.item-stable,.item.activated.item-stable,.item.active.item-stable{border-color:#a2a2a2;background-color:#e5e5e5}.item .item-content.activated.item-positive,.item .item-content.active.item-positive,.item-complex.activated .item-content.item-positive,.item-complex.active .item-content.item-positive,.item.activated.item-positive,.item.active.item-positive{border-color:#0c60ee;background-color:#0c60ee}.item .item-content.activated.item-calm,.item .item-content.active.item-calm,.item-complex.activated .item-content.item-calm,.item-complex.active .item-content.item-calm,.item.activated.item-calm,.item.active.item-calm{border-color:#0a9dc7;background-color:#0a9dc7}.item .item-content.activated.item-assertive,.item .item-content.active.item-assertive,.item-complex.activated .item-content.item-assertive,.item-complex.active .item-content.item-assertive,.item.activated.item-assertive,.item.active.item-assertive{border-color:#e42112;background-color:#e42112}.item .item-content.activated.item-balanced,.item .item-content.active.item-balanced,.item-complex.activated .item-content.item-balanced,.item-complex.active .item-content.item-balanced,.item.activated.item-balanced,.item.active.item-balanced{border-color:#28a54c;background-color:#28a54c}.item .item-content.activated.item-energized,.item .item-content.active.item-energized,.item-complex.activated .item-content.item-energized,.item-complex.active .item-content.item-energized,.item.activated.item-energized,.item.active.item-energized{border-color:#e6b500;background-color:#e6b500}.item .item-content.activated.item-royal,.item .item-content.active.item-royal,.item-complex.activated .item-content.item-royal,.item-complex.active .item-content.item-royal,.item.activated.item-royal,.item.active.item-royal{border-color:#6b46e5;background-color:#6b46e5}.item .item-content.activated.item-dark,.item .item-content.active.item-dark,.item-complex.activated .item-content.item-dark,.item-complex.active .item-content.item-dark,.item.activated.item-dark,.item.active.item-dark{border-color:#000;background-color:#262626}.item,.item h1,.item h2,.item h3,.item h4,.item h5,.item h6,.item p,.item-content,.item-content h1,.item-content h2,.item-content h3,.item-content h4,.item-content h5,.item-content h6,.item-content p{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}a.item{color:inherit;text-decoration:none}a.item:focus,a.item:hover{text-decoration:none}.item-complex,a.item.item-complex,button.item.item-complex{padding:0}.item-complex .item-content,.item-radio .item-content{position:relative;z-index:2;padding:16px 49px 16px 16px;border:none;background-color:#fff}a.item-content{display:block;color:inherit;text-decoration:none}.item-body h1,.item-body h2,.item-body h3,.item-body h4,.item-body h5,.item-body h6,.item-body p,.item-complex.item-text-wrap,.item-complex.item-text-wrap .item-content,.item-complex.item-text-wrap h1,.item-complex.item-text-wrap h2,.item-complex.item-text-wrap h3,.item-complex.item-text-wrap h4,.item-complex.item-text-wrap h5,.item-complex.item-text-wrap h6,.item-complex.item-text-wrap p,.item-text-wrap,.item-text-wrap .item,.item-text-wrap .item-content,.item-text-wrap h1,.item-text-wrap h2,.item-text-wrap h3,.item-text-wrap h4,.item-text-wrap h5,.item-text-wrap h6,.item-text-wrap p{overflow:visible;white-space:normal}.item-complex.item-light>.item-content{border-color:#ddd;background-color:#fff;color:#444}.item-complex.item-light>.item-content.active,.item-complex.item-light>.item-content:active{border-color:#ccc;background-color:#fafafa}.item-complex.item-stable>.item-content{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.item-complex.item-stable>.item-content.active,.item-complex.item-stable>.item-content:active{border-color:#a2a2a2;background-color:#e5e5e5}.item-complex.item-positive>.item-content{border-color:#0c60ee;background-color:#387ef5;color:#fff}.item-complex.item-positive>.item-content.active,.item-complex.item-positive>.item-content:active{border-color:#0c60ee;background-color:#0c60ee}.item-complex.item-calm>.item-content{border-color:#0a9dc7;background-color:#11c1f3;color:#fff}.item-complex.item-calm>.item-content.active,.item-complex.item-calm>.item-content:active{border-color:#0a9dc7;background-color:#0a9dc7}.item-complex.item-assertive>.item-content{border-color:#e42112;background-color:#ef473a;color:#fff}.item-complex.item-assertive>.item-content.active,.item-complex.item-assertive>.item-content:active{border-color:#e42112;background-color:#e42112}.item-complex.item-balanced>.item-content{border-color:#28a54c;background-color:#33cd5f;color:#fff}.item-complex.item-balanced>.item-content.active,.item-complex.item-balanced>.item-content:active{border-color:#28a54c;background-color:#28a54c}.item-complex.item-energized>.item-content{border-color:#e6b500;background-color:#ffc900;color:#fff}.item-complex.item-energized>.item-content.active,.item-complex.item-energized>.item-content:active{border-color:#e6b500;background-color:#e6b500}.item-complex.item-royal>.item-content{border-color:#6b46e5;background-color:#886aea;color:#fff}.item-complex.item-royal>.item-content.active,.item-complex.item-royal>.item-content:active{border-color:#6b46e5;background-color:#6b46e5}.item-complex.item-dark>.item-content{border-color:#111;background-color:#444;color:#fff}.item-complex.item-dark>.item-content.active,.item-complex.item-dark>.item-content:active{border-color:#000;background-color:#262626}.item-icon-left .icon,.item-icon-right .icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:0;height:100%;font-size:32px}.item-icon-left .icon:before,.item-icon-right .icon:before{display:block;width:32px;text-align:center}.item .fill-icon{min-width:30px;min-height:30px;font-size:28px}.item-icon-left{padding-left:54px}.item-icon-left .icon{left:11px}.item-complex.item-icon-left{padding-left:0}.item-complex.item-icon-left .item-content{padding-left:54px}.item-icon-right{padding-right:54px}.item-icon-right .icon{right:11px}.item-complex.item-icon-right{padding-right:0}.item-complex.item-icon-right .item-content{padding-right:54px}.item-icon-left.item-icon-right .icon:first-child{right:auto}.item-icon-left .item-delete .icon,.item-icon-left.item-icon-right .icon:last-child{left:auto}.item-icon-left .icon-accessory,.item-icon-right .icon-accessory{color:#ccc;font-size:16px}.item-icon-left .icon-accessory{left:3px}.item-icon-right .icon-accessory{right:3px}.item-button-left{padding-left:72px}.item-button-left .item-content>.button,.item-button-left>.button{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:8px;left:11px;min-width:34px;min-height:34px;font-size:18px;line-height:32px}.item-button-left .item-content>.button .icon:before,.item-button-left>.button .icon:before{position:relative;left:auto;width:auto;line-height:31px}.item-button-left .item-content>.button>.button,.item-button-left>.button>.button{margin:0 2px;min-height:34px;font-size:18px;line-height:32px}.item-button-right,a.item.item-button-right,button.item.item-button-right{padding-right:80px}.item-button-right .item-content>.button,.item-button-right .item-content>.buttons,.item-button-right>.button,.item-button-right>.buttons{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:8px;right:16px;min-width:34px;min-height:34px;font-size:18px;line-height:32px}.item-button-right .item-content>.button .icon:before,.item-button-right .item-content>.buttons .icon:before,.item-button-right>.button .icon:before,.item-button-right>.buttons .icon:before{position:relative;left:auto;width:auto;line-height:31px}.item-button-right .item-content>.button>.button,.item-button-right .item-content>.buttons>.button,.item-button-right>.button>.button,.item-button-right>.buttons>.button{margin:0 2px;min-width:34px;min-height:34px;font-size:18px;line-height:32px}.item-avatar,.item-avatar .item-content,.item-avatar-left,.item-avatar-left .item-content{padding-left:72px;min-height:72px}.item-avatar .item-content .item-image,.item-avatar .item-content>img:first-child,.item-avatar .item-image,.item-avatar-left .item-content .item-image,.item-avatar-left .item-content>img:first-child,.item-avatar-left .item-image,.item-avatar-left>img:first-child,.item-avatar>img:first-child{position:absolute;top:16px;left:16px;max-width:40px;max-height:40px;width:100%;height:100%;border-radius:50%}.item-avatar-right,.item-avatar-right .item-content{padding-right:72px;min-height:72px}.item-avatar-right .item-content .item-image,.item-avatar-right .item-content>img:first-child,.item-avatar-right .item-image,.item-avatar-right>img:first-child{position:absolute;top:16px;right:16px;max-width:40px;max-height:40px;width:100%;height:100%;border-radius:50%}.item-thumbnail-left,.item-thumbnail-left .item-content{padding-top:8px;padding-left:106px;min-height:100px}.item-thumbnail-left .item-content .item-image,.item-thumbnail-left .item-content>img:first-child,.item-thumbnail-left .item-image,.item-thumbnail-left>img:first-child{position:absolute;top:10px;left:10px;max-width:80px;max-height:80px;width:100%;height:100%}.item-avatar-left.item-complex,.item-avatar.item-complex,.item-thumbnail-left.item-complex{padding-top:0;padding-left:0}.item-thumbnail-right,.item-thumbnail-right .item-content{padding-top:8px;padding-right:106px;min-height:100px}.item-thumbnail-right .item-content .item-image,.item-thumbnail-right .item-content>img:first-child,.item-thumbnail-right .item-image,.item-thumbnail-right>img:first-child{position:absolute;top:10px;right:10px;max-width:80px;max-height:80px;width:100%;height:100%}.item-avatar-right.item-complex,.item-thumbnail-right.item-complex{padding-top:0;padding-right:0}.item-image{padding:0;text-align:center}.item-image .list-img,.item-image img:first-child{width:100%;vertical-align:middle}.item-body{overflow:auto;padding:16px;text-overflow:inherit;white-space:normal}.item-body h1,.item-body h2,.item-body h3,.item-body h4,.item-body h5,.item-body h6,.item-body p{margin-top:16px;margin-bottom:16px}.item-divider{padding-top:8px;padding-bottom:8px;min-height:30px;background-color:#f5f5f5;color:#222;font-weight:500}.item-divider-ios,.platform-ios .item-divider-platform{padding-top:26px;text-transform:uppercase;font-weight:300;font-size:13px;background-color:#efeff4;color:#555}.item-divider-android,.platform-android .item-divider-platform{font-weight:300;font-size:13px}.item-note{float:right;color:#aaa;font-size:14px}.item-left-editable .item-content,.item-right-editable .item-content{-webkit-transition-duration:250ms;transition-duration:250ms;-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition-property:-webkit-transform;-moz-transition-property:-moz-transform;transition-property:transform}.item-left-editing.item-left-editable .item-content,.list-left-editing .item-left-editable .item-content{-webkit-transform:translate3d(50px,0,0);transform:translate3d(50px,0,0)}.item-remove-animate.ng-leave{-webkit-transition-duration:300ms;transition-duration:300ms}.item-remove-animate.ng-leave .item-content,.item-remove-animate.ng-leave:last-of-type{-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:ease-in;transition-timing-function:ease-in;-webkit-transition-property:all;transition-property:all}.item-remove-animate.ng-leave.ng-leave-active .item-content{opacity:0;-webkit-transform:translate3d(-100%,0,0)!important;transform:translate3d(-100%,0,0)!important}.item-remove-animate.ng-leave.ng-leave-active:last-of-type{opacity:0}.item-remove-animate.ng-leave.ng-leave-active~ion-item:not(.ng-leave){-webkit-transform:translate3d(0,-webkit-calc(-100% + 1px),0);transform:translate3d(0,calc(-100% + 1px),0);-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(.25,.81,.24,1);transition-timing-function:cubic-bezier(.25,.81,.24,1);-webkit-transition-property:all;transition-property:all}.item-left-edit{-webkit-transition:all ease-in-out 125ms;transition:all ease-in-out 125ms;position:absolute;top:0;left:0;z-index:0;width:50px;height:100%;line-height:100%;display:none;opacity:0;-webkit-transform:translate3d(-21px,0,0);transform:translate3d(-21px,0,0)}.item-left-edit .button{height:100%}.item-left-edit .button.icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:0;height:100%}.item-left-edit.visible{display:block}.item-left-edit.visible.active{opacity:1;-webkit-transform:translate3d(8px,0,0);transform:translate3d(8px,0,0)}.list-left-editing .item-left-edit{-webkit-transition-delay:125ms;transition-delay:125ms}.item-delete .button.icon{color:#ef473a;font-size:24px}.item-delete .button.icon:hover{opacity:.7}.item-right-edit{-webkit-transition:all ease-in-out 250ms;transition:all ease-in-out 250ms;position:absolute;top:0;right:0;z-index:3;width:75px;height:100%;background:inherit;padding-left:20px;display:block;opacity:0;-webkit-transform:translate3d(75px,0,0);transform:translate3d(75px,0,0)}.item-right-edit .button{min-width:50px;height:100%}.item-right-edit .button.icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:0;height:100%;font-size:32px}.item-right-edit.visible{display:block}.item-right-edit.visible.active{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.item-reorder .button.icon{color:#444;font-size:32px}.item-reordering{position:absolute;left:0;top:0;z-index:9;width:100%;box-shadow:0 0 10px 0 #aaa}.item-reordering .item-reorder{z-index:9}.item-placeholder{opacity:.7}.item-options{position:absolute;top:0;right:0;z-index:1;height:100%}.button .badge,.list,.slider,.slider-slide,.slider-slides{position:relative}.item-options .button{height:100%;border:none;border-radius:0;display:-webkit-inline-box;display:-webkit-inline-flex;display:-moz-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}.item-options .button:before{margin:0 auto}.list{padding-top:1px;padding-bottom:1px;padding-left:0;margin-bottom:20px}.list:last-child{margin-bottom:0}.list:last-child.card{margin-bottom:40px}.list-header{margin-top:20px;padding:5px 15px;background-color:transparent;color:#222;font-weight:700}.card.list .list-item{padding-right:1px;padding-left:1px}.card,.list-inset{overflow:hidden;margin:20px 10px;border-radius:0;background-color:#fff}.card .item,.list-inset .item,.padding .card,.padding .list-inset,.padding-horizontal>.list .item,.padding>.list .item{margin-right:0;margin-left:0}.card{padding-top:1px;padding-bottom:1px;box-shadow:0 1px 3px rgba(0,0,0,.3)}.card .item{border-left:0;border-right:0}.card .item:first-child,.card .item:first-child .item-content,.list-inset .item:first-child,.list-inset .item:first-child .item-content,.padding>.list .item:first-child,.padding>.list .item:first-child .item-content{border-top-left-radius:0;border-top-right-radius:0}.card .item:last-child,.card .item:last-child .item-content,.list-inset .item:last-child,.list-inset .item:last-child .item-content,.padding>.list .item:last-child,.padding>.list .item:last-child .item-content{border-bottom-right-radius:0;border-bottom-left-radius:0}.card .item:last-child,.list-inset .item:last-child{margin-bottom:-1px}.card .item.item-input input,.list-inset .item.item-input input,.padding-horizontal>.list .item.item-input input,.padding>.list .item.item-input input{padding-right:44px}.padding-left>.list .item{margin-left:0}.padding-right>.list .item{margin-right:0}.badge{background-color:transparent;color:#AAA;z-index:1;display:inline-block;padding:3px 8px;min-width:10px;border-radius:10px;vertical-align:baseline;text-align:center;white-space:nowrap;font-weight:700;font-size:14px;line-height:16px}.badge:empty{display:none}.badge.badge-light,.tabs .tab-item .badge.badge-light{background-color:#fff;color:#444}.badge.badge-stable,.tabs .tab-item .badge.badge-stable{background-color:#f8f8f8;color:#444}.badge.badge-positive,.tabs .tab-item .badge.badge-positive{background-color:#387ef5;color:#fff}.badge.badge-calm,.tabs .tab-item .badge.badge-calm{background-color:#11c1f3;color:#fff}.badge.badge-assertive,.tabs .tab-item .badge.badge-assertive{background-color:#ef473a;color:#fff}.badge.badge-balanced,.tabs .tab-item .badge.badge-balanced{background-color:#33cd5f;color:#fff}.badge.badge-energized,.tabs .tab-item .badge.badge-energized{background-color:#ffc900;color:#fff}.badge.badge-royal,.tabs .tab-item .badge.badge-royal{background-color:#886aea;color:#fff}.badge.badge-dark,.tabs .tab-item .badge.badge-dark{background-color:#444;color:#fff}.button .badge{top:-1px}.slider{visibility:hidden;overflow:hidden}.slider-slides{height:100%}.slider-slide{display:block;float:left;width:100%;height:100%;vertical-align:top}.slider-slide-image>img{width:100%}.slider-pager{position:absolute;bottom:20px;z-index:1;width:100%;height:15px;text-align:center}.slider-pager .slider-pager-page{display:inline-block;margin:0 3px;width:15px;color:#000;text-decoration:none;opacity:.3}.scroll-refresher .icon-refreshing,.scroll-refresher .text-refreshing,.scroll-refresher.active.refreshing .icon-pulling,.scroll-refresher.active.refreshing .text-pulling{display:none}.slider-pager .slider-pager-page.active{-webkit-transition:opacity .4s ease-in;transition:opacity .4s ease-in;opacity:1}.scroll-refresher{position:absolute;top:-60px;right:0;left:0;overflow:hidden;margin:auto;height:60px}.scroll-refresher .ionic-refresher-content{position:absolute;bottom:15px;left:0;width:100%;color:#666;text-align:center;font-size:30px}.scroll-refresher .ionic-refresher-content .text-pulling,.scroll-refresher .ionic-refresher-content .text-refreshing{font-size:16px;line-height:16px}.scroll-refresher .ionic-refresher-content.ionic-refresher-with-text{bottom:10px}.scroll-refresher .icon-pulling,.scroll-refresher .icon-refreshing{width:100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.scroll-refresher .icon-pulling{-webkit-animation-name:refresh-spin-back;animation-name:refresh-spin-back;-webkit-animation-duration:200ms;animation-duration:200ms;-webkit-animation-timing-function:linear;animation-timing-function:linear;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-transform:translate3d(0,0,0)rotate(0);transform:translate3d(0,0,0)rotate(0)}.scroll-refresher .icon-refreshing{-webkit-animation-duration:1.5s;animation-duration:1.5s}.scroll-refresher.active .icon-pulling:not(.pulling-rotation-disabled){-webkit-animation-name:refresh-spin;animation-name:refresh-spin;-webkit-transform:translate3d(0,0,0)rotate(-180deg);transform:translate3d(0,0,0)rotate(-180deg)}.scroll-refresher.active.refreshing{-webkit-transition:transform .2s;transition:transform .2s;-webkit-transform:scale(1,1);transform:scale(1,1)}.item-floating-label .input-label,.item-floating-label .input-label.has-input{-webkit-transition:opacity .15s ease-in,top .2s linear;transition:opacity .15s ease-in,top .2s linear}.scroll-refresher.active.refreshing .icon-refreshing,.scroll-refresher.active.refreshing .text-refreshing,legend{display:block}.scroll-refresher.active.refreshing.refreshing-tail{-webkit-transform:scale(0,0);transform:scale(0,0)}.overflow-scroll>.scroll{-webkit-overflow-scrolling:touch;width:100%}.overflow-scroll>.scroll.overscroll{position:fixed}@-webkit-keyframes refresh-spin{0%{-webkit-transform:translate3d(0,0,0)rotate(0)}100%{-webkit-transform:translate3d(0,0,0)rotate(180deg)}}@keyframes refresh-spin{0%{transform:translate3d(0,0,0)rotate(0)}100%{transform:translate3d(0,0,0)rotate(180deg)}}@-webkit-keyframes refresh-spin-back{0%{-webkit-transform:translate3d(0,0,0)rotate(180deg)}100%{-webkit-transform:translate3d(0,0,0)rotate(0)}}@keyframes refresh-spin-back{0%{transform:translate3d(0,0,0)rotate(180deg)}100%{transform:translate3d(0,0,0)rotate(0)}}.spinner{stroke:#444;fill:#444}.spinner svg{width:28px;height:28px}.spinner.spinner-light{stroke:#fff;fill:#fff}.spinner.spinner-stable{stroke:#f8f8f8;fill:#f8f8f8}.spinner.spinner-positive{stroke:#387ef5;fill:#387ef5}.spinner.spinner-calm{stroke:#11c1f3;fill:#11c1f3}.spinner.spinner-balanced{stroke:#33cd5f;fill:#33cd5f}.spinner.spinner-assertive{stroke:#ef473a;fill:#ef473a}.spinner.spinner-energized{stroke:#ffc900;fill:#ffc900}.spinner.spinner-royal{stroke:#886aea;fill:#886aea}.spinner.spinner-dark{stroke:#444;fill:#444}.spinner-android{stroke:#4b8bf4}.spinner-ios,.spinner-ios-small{stroke:#69717d}.spinner-spiral .stop1{stop-color:#fff;stop-opacity:0}.spinner-spiral.spinner-light .stop1{stop-color:#444}.spinner-spiral.spinner-light .stop2{stop-color:#fff}.spinner-spiral.spinner-stable .stop2{stop-color:#f8f8f8}.spinner-spiral.spinner-positive .stop2{stop-color:#387ef5}.spinner-spiral.spinner-calm .stop2{stop-color:#11c1f3}.spinner-spiral.spinner-balanced .stop2{stop-color:#33cd5f}.spinner-spiral.spinner-assertive .stop2{stop-color:#ef473a}.spinner-spiral.spinner-energized .stop2{stop-color:#ffc900}.spinner-spiral.spinner-royal .stop2{stop-color:#886aea}.spinner-spiral.spinner-dark .stop2{stop-color:#444}form{margin:0 0 1.42857}legend{margin-bottom:1.42857;padding:0;width:100%;border:1px solid #ddd;color:#444;font-size:21px;line-height:2.85714}legend small{color:#f8f8f8;font-size:1.07143}button,input,label,select,textarea{font-weight:400;font-size:14px;line-height:1.42857}.item-input{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:relative;overflow:hidden;padding:6px 0 5px 16px}.item-input input{-webkit-box-flex:1;-webkit-flex:1 220px;-moz-box-flex:1;-moz-flex:1 220px;-ms-flex:1 220px;flex:1 220px;-webkit-appearance:none;-moz-appearance:none;margin:0;padding-right:24px;background-color:transparent}.item-input .button .icon{-webkit-box-flex:0;-webkit-flex:0 0 24px;-moz-box-flex:0;-moz-flex:0 0 24px;-ms-flex:0 0 24px;flex:0 0 24px;position:static;display:inline-block;height:auto;text-align:center;font-size:16px}.item-input .button-bar{-webkit-box-flex:1;-webkit-flex:1 0 220px;-moz-box-flex:1;-moz-flex:1 0 220px;-ms-flex:1 0 220px;flex:1 0 220px;-webkit-appearance:none;-moz-appearance:none}.item-input .icon{min-width:14px}.platform-windowsphone .item-input input{flex-shrink:1}.item-input-inset,.range{-webkit-box-align:center}.item-input-inset{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:relative;overflow:hidden;padding:10.67px}.item-input-wrapper{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex:1 0;-moz-box-flex:1;-moz-flex:1 0;-ms-flex:1 0;flex:1 0;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;-webkit-border-radius:4px;padding-right:8px;padding-left:8px;background:#eee}.item-input-inset .item-input-wrapper input{padding-left:4px;height:29px;background:0 0;line-height:18px}.item-input-wrapper~.button{margin-left:10.67px}.input-label{display:table;padding:7px 10px 7px 0;max-width:200px;width:35%;color:#444;font-size:16px}.placeholder-icon{color:#aaa}.placeholder-icon:first-child{padding-right:6px}.placeholder-icon:last-child{padding-left:6px}.item-stacked-label{display:block;background-color:transparent;box-shadow:none}.item-stacked-label .icon,.item-stacked-label .input-label{display:inline-block;padding:4px 0 0;vertical-align:middle}.item-stacked-label input,.item-stacked-label textarea{-webkit-border-radius:2px;border-radius:2px;padding:4px 8px 3px 0;border:none;background-color:#fff}.item-stacked-label input{overflow:hidden;height:46px}.item-floating-label{display:block;background-color:transparent;box-shadow:none}.item-floating-label .input-label{position:relative;padding:5px 0 0;opacity:0;top:10px}.item-floating-label .input-label.has-input{opacity:1;top:0}input[type=search],input[type=text],input[type=password],input[type=datetime],input[type=datetime-local],input[type=date],input[type=month],input[type=time],input[type=week],input[type=number],input[type=email],input[type=url],input[type=tel],input[type=color],textarea{display:block;padding-top:2px;padding-left:0;height:34px;color:#111;vertical-align:middle;font-size:14px;line-height:16px;border:0}.platform-android input[type=datetime-local],.platform-android input[type=date],.platform-android input[type=month],.platform-android input[type=time],.platform-android input[type=week],.platform-ios input[type=datetime-local],.platform-ios input[type=date],.platform-ios input[type=month],.platform-ios input[type=time],.platform-ios input[type=week]{padding-top:8px}.item-input input,.item-input textarea{width:100%}textarea{padding-left:0;height:auto}textarea::-moz-placeholder{color:#aaa}textarea:-ms-input-placeholder{color:#aaa}textarea::-webkit-input-placeholder{color:#aaa;text-indent:-3px}input[type=radio],input[type=checkbox]{margin:0;line-height:normal}.item-input input[type=button],.item-input input[type=reset],.item-input input[type=submit],.item-input input[type=radio],.item-input input[type=checkbox],.item-input input[type=file],.item-input input[type=image]{width:auto}input[type=file]{line-height:34px}.cloned-text-input+input,.cloned-text-input+textarea,.previous-input-focus{position:absolute!important;left:-9999px;width:200px}input::-moz-placeholder,textarea::-moz-placeholder{color:#aaa}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#aaa}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#aaa;text-indent:0}input[disabled],input[readonly]:not(.cloned-text-input),select[disabled],select[readonly],textarea[disabled],textarea[readonly]:not(.cloned-text-input){background-color:#f8f8f8;cursor:not-allowed}.button,.checkbox,.item-radio:hover,.item-select select,.toggle .track{cursor:pointer}input[type=radio][disabled],input[type=radio][readonly],input[type=checkbox][disabled],input[type=checkbox][readonly]{background-color:transparent}.checkbox{position:relative;display:inline-block;padding:7px}.checkbox .checkbox-icon:before,.checkbox input:before{border-color:#ddd}.checkbox input:checked+.checkbox-icon:before,.checkbox input:checked:before{background:#387ef5;border-color:#387ef5}.checkbox-light .checkbox-icon:before,.checkbox-light input:before{border-color:#ddd}.checkbox-light input:checked+.checkbox-icon:before,.checkbox-light input:checked:before{background:#ddd;border-color:#ddd}.checkbox-stable .checkbox-icon:before,.checkbox-stable input:before{border-color:#b2b2b2}.checkbox-stable input:checked+.checkbox-icon:before,.checkbox-stable input:checked:before{background:#b2b2b2;border-color:#b2b2b2}.checkbox-positive .checkbox-icon:before,.checkbox-positive input:before{border-color:#387ef5}.checkbox-positive input:checked+.checkbox-icon:before,.checkbox-positive input:checked:before{background:#387ef5;border-color:#387ef5}.checkbox-calm .checkbox-icon:before,.checkbox-calm input:before{border-color:#11c1f3}.checkbox-calm input:checked+.checkbox-icon:before,.checkbox-calm input:checked:before{background:#11c1f3;border-color:#11c1f3}.checkbox-assertive .checkbox-icon:before,.checkbox-assertive input:before{border-color:#ef473a}.checkbox-assertive input:checked+.checkbox-icon:before,.checkbox-assertive input:checked:before{background:#ef473a;border-color:#ef473a}.checkbox-balanced .checkbox-icon:before,.checkbox-balanced input:before{border-color:#33cd5f}.checkbox-balanced input:checked+.checkbox-icon:before,.checkbox-balanced input:checked:before{background:#33cd5f;border-color:#33cd5f}.checkbox-energized .checkbox-icon:before,.checkbox-energized input:before{border-color:#ffc900}.checkbox-energized input:checked+.checkbox-icon:before,.checkbox-energized input:checked:before{background:#ffc900;border-color:#ffc900}.checkbox-royal .checkbox-icon:before,.checkbox-royal input:before{border-color:#886aea}.checkbox-royal input:checked+.checkbox-icon:before,.checkbox-royal input:checked:before{background:#886aea;border-color:#886aea}.checkbox-dark .checkbox-icon:before,.checkbox-dark input:before{border-color:#444}.checkbox-dark input:checked+.checkbox-icon:before,.checkbox-dark input:checked:before{background:#444;border-color:#444}.checkbox input:disabled+.checkbox-icon:before,.checkbox input:disabled:before{border-color:#ddd}.checkbox input:disabled:checked+.checkbox-icon:before,.checkbox input:disabled:checked:before{background:#ddd}.checkbox.checkbox-input-hidden input{display:none!important}.checkbox input,.checkbox-icon{position:relative;width:28px;height:28px;display:block;border:0;background:0 0;cursor:pointer;-webkit-appearance:none}.checkbox input:before,.checkbox-icon:before{display:table;width:100%;height:100%;border-width:1px;border-style:solid;border-radius:28px;background:#fff;content:' ';-webkit-transition:background-color 20ms ease-in-out;transition:background-color 20ms ease-in-out}.checkbox input:checked:before,input:checked+.checkbox-icon:before{border-width:2px}.checkbox input:after,.checkbox-icon:after{-webkit-transition:opacity .05s ease-in-out;transition:opacity .05s ease-in-out;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);position:absolute;top:33%;left:25%;display:table;width:14px;height:6px;border:1px solid #fff;border-top:0;border-right:0;content:' ';opacity:0}.checkbox-square .checkbox-icon:before,.checkbox-square input:before,.platform-android .checkbox-platform .checkbox-icon:before,.platform-android .checkbox-platform input:before{border-radius:2px;width:72%;height:72%;margin-top:14%;margin-left:14%;border-width:2px}.checkbox-square .checkbox-icon:after,.checkbox-square input:after,.platform-android .checkbox-platform .checkbox-icon:after,.platform-android .checkbox-platform input:after{border-width:2px;top:19%;left:25%;width:13px;height:7px}.grade-c .checkbox input:after,.grade-c .checkbox-icon:after{-webkit-transform:rotate(0);transform:rotate(0);top:3px;left:4px;border:none;color:#fff;content:'\\2713';font-weight:700;font-size:20px}.checkbox input:checked:after,input:checked+.checkbox-icon:after{opacity:1}.item-checkbox{padding-left:60px}.item-checkbox.active{box-shadow:none}.item-checkbox .checkbox{position:absolute;top:50%;right:8px;left:8px;z-index:3;margin-top:-21px}.item-checkbox.item-checkbox-right{padding-right:60px;padding-left:16px}.item-checkbox-right .checkbox input,.item-checkbox-right .checkbox-icon{float:right}.item-toggle{pointer-events:none}.toggle{position:relative;display:inline-block;pointer-events:auto;margin:-5px;padding:5px}.toggle input:checked+.track{border-color:#4cd964;background-color:#4cd964}.toggle.dragging .handle{background-color:#f2f2f2!important}.toggle.toggle-light input:checked+.track{border-color:#ddd;background-color:#ddd}.toggle.toggle-stable input:checked+.track{border-color:#b2b2b2;background-color:#b2b2b2}.toggle.toggle-positive input:checked+.track{border-color:#387ef5;background-color:#387ef5}.toggle.toggle-calm input:checked+.track{border-color:#11c1f3;background-color:#11c1f3}.toggle.toggle-assertive input:checked+.track{border-color:#ef473a;background-color:#ef473a}.toggle.toggle-balanced input:checked+.track{border-color:#33cd5f;background-color:#33cd5f}.toggle.toggle-energized input:checked+.track{border-color:#ffc900;background-color:#ffc900}.toggle.toggle-royal input:checked+.track{border-color:#886aea;background-color:#886aea}.toggle.toggle-dark input:checked+.track{border-color:#444;background-color:#444}.toggle input{display:none}.toggle .track{-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition-duration:.3s;transition-duration:.3s;-webkit-transition-property:background-color,border;transition-property:background-color,border;display:inline-block;width:51px;height:31px;border:2px solid #e6e6e6;border-radius:20px;background-color:#fff;content:' ';pointer-events:none}.platform-android4_2 .toggle .track{-webkit-background-clip:padding-box}.toggle .handle{-webkit-transition:.3s cubic-bezier(0,1.1,1,1.1);transition:.3s cubic-bezier(0,1.1,1,1.1);-webkit-transition-property:background-color,transform;transition-property:background-color,transform;position:absolute;display:block;width:27px;height:27px;border-radius:27px;background-color:#fff;top:7px;left:7px;box-shadow:0 2px 7px rgba(0,0,0,.35),0 1px 1px rgba(0,0,0,.15)}.button-clear,.button-icon,.button-outline{-webkit-transition:opacity .1s}.toggle .handle:before{position:absolute;top:-4px;left:-21.5px;padding:18.5px 34px;content:\" \"}.toggle input:checked+.track .handle{-webkit-transform:translate3d(20px,0,0);transform:translate3d(20px,0,0);background-color:#fff}.item-toggle.active{box-shadow:none}.item-toggle,.item-toggle.item-complex .item-content{padding-right:99px}.item-toggle.item-complex{padding-right:0}.item-toggle .toggle{position:absolute;top:10px;right:16px;z-index:3}.toggle input:disabled+.track{opacity:.6}.toggle-small .track{border:0;width:34px;height:15px;background:#9e9e9e}.toggle-small input:checked+.track{background:rgba(0,150,137,.5)}.toggle-small .handle{top:2px;left:4px;width:21px;height:21px;box-shadow:0 2px 5px rgba(0,0,0,.25)}.toggle-small input:checked+.track .handle{-webkit-transform:translate3d(16px,0,0);transform:translate3d(16px,0,0);background:#009689}.toggle-small.item-toggle .toggle{top:19px}.toggle-small .toggle-light input:checked+.track{background-color:rgba(221,221,221,.5)}.toggle-small .toggle-light input:checked+.track .handle{background-color:#ddd}.toggle-small .toggle-stable input:checked+.track{background-color:rgba(178,178,178,.5)}.toggle-small .toggle-stable input:checked+.track .handle{background-color:#b2b2b2}.toggle-small .toggle-positive input:checked+.track{background-color:rgba(56,126,245,.5)}.toggle-small .toggle-positive input:checked+.track .handle{background-color:#387ef5}.toggle-small .toggle-calm input:checked+.track{background-color:rgba(17,193,243,.5)}.toggle-small .toggle-calm input:checked+.track .handle{background-color:#11c1f3}.toggle-small .toggle-assertive input:checked+.track{background-color:rgba(239,71,58,.5)}.toggle-small .toggle-assertive input:checked+.track .handle{background-color:#ef473a}.toggle-small .toggle-balanced input:checked+.track{background-color:rgba(51,205,95,.5)}.toggle-small .toggle-balanced input:checked+.track .handle{background-color:#33cd5f}.toggle-small .toggle-energized input:checked+.track{background-color:rgba(255,201,0,.5)}.toggle-small .toggle-energized input:checked+.track .handle{background-color:#ffc900}.toggle-small .toggle-royal input:checked+.track{background-color:rgba(136,106,234,.5)}.toggle-small .toggle-royal input:checked+.track .handle{background-color:#886aea}.toggle-small .toggle-dark input:checked+.track{background-color:rgba(68,68,68,.5)}.toggle-small .toggle-dark input:checked+.track .handle{background-color:#444}.item-radio{padding:0}.item-radio .item-content{padding-right:64px}.item-radio .radio-icon{position:absolute;top:0;right:0;z-index:3;visibility:hidden;padding:14px;height:100%;font-size:24px}.item-radio input{position:absolute;left:-9999px}.item-radio input:checked~.item-content{background:#f7f7f7}.item-radio input:checked~.radio-icon{visibility:visible}.block:after,.invisible{visibility:hidden}.platform-android.grade-b .item-radio,.platform-android.grade-c .item-radio{-webkit-animation:androidCheckedbugfix infinite 1s}@-webkit-keyframes androidCheckedbugfix{from,to{padding:0}}.range input{overflow:hidden;margin-top:5px;margin-bottom:5px;padding-right:2px;padding-left:1px;width:auto;height:43px;outline:0;background:-webkit-gradient(linear,50% 0,50% 100%,color-stop(0,#ccc),color-stop(100%,#ccc))center no-repeat;background:linear-gradient(to right,#ccc 0,#ccc 100%)center no-repeat;background-size:99% 2px;-webkit-appearance:none}.range input::-webkit-slider-thumb{position:relative;width:28px;height:28px;border-radius:50%;background-color:#fff;box-shadow:0 0 2px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2);cursor:pointer;-webkit-appearance:none;border:0}.range input::-webkit-slider-thumb:before{position:absolute;top:13px;left:-2001px;width:2000px;height:2px;background:#444;content:' '}.range input::-webkit-slider-thumb:after{position:absolute;top:-15px;left:-15px;padding:30px;content:' '}.range input::-ms-track{background:0 0;border-color:transparent;border-width:11px 0 16px;color:transparent;margin-top:20px}.range input::-ms-thumb{width:28px;height:28px;border-radius:50%;background-color:#fff;border-color:#fff;box-shadow:0 0 2px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2);margin-left:1px;margin-right:1px;outline:0}.range input::-ms-fill-lower{height:2px;background:#444}.range input::-ms-fill-upper{height:2px;background:#ccc}.range{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;padding:2px 11px}.range.range-light input::-webkit-slider-thumb:before{background:#ddd}.range.range-light input::-ms-fill-lower{background:#ddd}.range.range-stable input::-webkit-slider-thumb:before{background:#b2b2b2}.range.range-stable input::-ms-fill-lower{background:#b2b2b2}.range.range-positive input::-webkit-slider-thumb:before{background:#387ef5}.range.range-positive input::-ms-fill-lower{background:#387ef5}.range.range-calm input::-webkit-slider-thumb:before{background:#11c1f3}.range.range-calm input::-ms-fill-lower{background:#11c1f3}.range.range-balanced input::-webkit-slider-thumb:before{background:#33cd5f}.range.range-balanced input::-ms-fill-lower{background:#33cd5f}.range.range-assertive input::-webkit-slider-thumb:before{background:#ef473a}.range.range-assertive input::-ms-fill-lower{background:#ef473a}.range.range-energized input::-webkit-slider-thumb:before{background:#ffc900}.range.range-energized input::-ms-fill-lower{background:#ffc900}.range.range-royal input::-webkit-slider-thumb:before{background:#886aea}.range.range-royal input::-ms-fill-lower{background:#886aea}.range.range-dark input::-webkit-slider-thumb:before{background:#444}.range.range-dark input::-ms-fill-lower{background:#444}.range .icon{-webkit-box-flex:0;-webkit-flex:0;-moz-box-flex:0;-moz-flex:0;-ms-flex:0;flex:0;display:block;min-width:24px;text-align:center;font-size:24px}.range input{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;margin-right:10px;margin-left:10px}.range-label{-webkit-box-flex:0;-webkit-flex:0 0 auto;-moz-box-flex:0;-moz-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;display:block;white-space:nowrap}.range-label:first-child{padding-left:5px}.range input+.range-label{padding-right:5px;padding-left:0}.platform-windowsphone .range input{height:auto}.item-select{position:relative}.item-select select{-webkit-appearance:none;-moz-appearance:none;appearance:none;position:absolute;top:0;bottom:0;right:0;padding:14px 48px 16px 16px;max-width:65%;border:none;background:#fff;color:#333;text-indent:.01px;text-overflow:'';white-space:nowrap;font-size:14px;direction:rtl}.item-select select::-ms-expand{display:none}.item-select option{direction:ltr}.item-select:after{position:absolute;top:50%;right:16px;margin-top:-3px;width:0;height:0;border-top:5px solid;border-right:5px solid transparent;border-left:5px solid transparent;color:#999;content:\"\";pointer-events:none}.button-full>button.button,button.button-block,button.button-full,input.button.button-block,progress{width:100%}.item-select.item-light select{background:#fff;color:#444}.item-select.item-stable select{background:#f8f8f8;color:#444}.item-select.item-stable .input-label,.item-select.item-stable:after{color:#656565}.item-select.item-positive select{background:#387ef5;color:#fff}.item-select.item-positive .input-label,.item-select.item-positive:after{color:#fff}.item-select.item-calm select{background:#11c1f3;color:#fff}.item-select.item-calm .input-label,.item-select.item-calm:after{color:#fff}.item-select.item-assertive select{background:#ef473a;color:#fff}.item-select.item-assertive .input-label,.item-select.item-assertive:after{color:#fff}.item-select.item-balanced select{background:#33cd5f;color:#fff}.item-select.item-balanced .input-label,.item-select.item-balanced:after{color:#fff}.item-select.item-energized select{background:#ffc900;color:#fff}.item-select.item-energized .input-label,.item-select.item-energized:after{color:#fff}.item-select.item-royal select{background:#886aea;color:#fff}.item-select.item-royal .input-label,.item-select.item-royal:after{color:#fff}.item-select.item-dark select{background:#444;color:#fff}.item-select.item-dark .input-label,.item-select.item-dark:after{color:#fff}select[multiple],select[size]{height:auto}progress{display:block;margin:15px auto}.button{border-color:#b2b2b2;background-color:#f8f8f8;color:#444;position:relative;display:inline-block;margin:0;padding:0 12px;min-width:52px;min-height:47px;border-width:1px;border-style:solid;border-radius:0;vertical-align:top;text-align:center;text-overflow:ellipsis;font-size:16px;line-height:42px}.button:hover{color:#444;text-decoration:none}.button.activated,.button.active{border-color:#a2a2a2;background-color:#e5e5e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button:after{position:absolute;top:-6px;right:-6px;bottom:-6px;left:-6px;content:' '}.button .icon{vertical-align:top;pointer-events:none}.button .icon:before,.button.icon-left:before,.button.icon-right:before,.button.icon:before{display:inline-block;padding:0 0 1px;vertical-align:inherit;font-size:24px;line-height:41px;pointer-events:none}.button.icon-left:before{float:left;padding-right:.2em;padding-left:0}.button.icon-right:before{float:right;padding-right:0;padding-left:.2em}.button.button-block,.button.button-full{margin-top:10px;margin-bottom:10px}.button.button-light{border-color:#ddd;background-color:#fff;color:#444}.button.button-light:hover{color:#444;text-decoration:none}.button.button-light.activated,.button.button-light.active{border-color:#ccc;background-color:#fafafa;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-light.button-clear,.button.button-light.button-icon{border-color:transparent;background:0 0}.button.button-light.button-clear{box-shadow:none;color:#ddd}.button.button-light.button-outline{border-color:#ddd;background:0 0;color:#ddd}.button.button-light.button-outline.activated,.button.button-light.button-outline.active{background-color:#ddd;box-shadow:none;color:#fff}.button.button-stable{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.button.button-stable:hover{color:#444;text-decoration:none}.button.button-stable.activated,.button.button-stable.active{border-color:#a2a2a2;background-color:#e5e5e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-stable.button-clear,.button.button-stable.button-icon{border-color:transparent;background:0 0}.button.button-stable.button-clear{box-shadow:none;color:#b2b2b2}.button.button-stable.button-outline{border-color:#b2b2b2;background:0 0;color:#b2b2b2}.button.button-stable.button-outline.activated,.button.button-stable.button-outline.active{background-color:#b2b2b2;box-shadow:none;color:#fff}.button.button-positive{border-color:#0c60ee;background-color:#387ef5;color:#fff}.button.button-positive:hover{color:#fff;text-decoration:none}.button.button-positive.activated,.button.button-positive.active{border-color:#0c60ee;background-color:#0c60ee;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-positive.button-clear,.button.button-positive.button-icon{border-color:transparent;background:0 0}.button.button-positive.button-clear{box-shadow:none;color:#387ef5}.button.button-positive.button-outline{border-color:#387ef5;background:0 0;color:#387ef5}.button.button-positive.button-outline.activated,.button.button-positive.button-outline.active{background-color:#387ef5;box-shadow:none;color:#fff}.button.button-calm{border-color:#0a9dc7;background-color:#11c1f3;color:#fff}.button.button-calm:hover{color:#fff;text-decoration:none}.button.button-calm.activated,.button.button-calm.active{border-color:#0a9dc7;background-color:#0a9dc7;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-calm.button-clear,.button.button-calm.button-icon{border-color:transparent;background:0 0}.button.button-calm.button-clear{box-shadow:none;color:#11c1f3}.button.button-calm.button-outline{border-color:#11c1f3;background:0 0;color:#11c1f3}.button.button-calm.button-outline.activated,.button.button-calm.button-outline.active{background-color:#11c1f3;box-shadow:none;color:#fff}.button.button-assertive{border-color:#e42112;background-color:#ef473a;color:#fff}.button.button-assertive:hover{color:#fff;text-decoration:none}.button.button-assertive.activated,.button.button-assertive.active{border-color:#e42112;background-color:#e42112;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-assertive.button-clear,.button.button-assertive.button-icon{border-color:transparent;background:0 0}.button.button-assertive.button-clear{box-shadow:none;color:#ef473a}.button.button-assertive.button-outline{border-color:#ef473a;background:0 0;color:#ef473a}.button.button-assertive.button-outline.activated,.button.button-assertive.button-outline.active{background-color:#ef473a;box-shadow:none;color:#fff}.button.button-balanced{border-color:#28a54c;background-color:#33cd5f;color:#fff}.button.button-balanced:hover{color:#fff;text-decoration:none}.button.button-balanced.activated,.button.button-balanced.active{border-color:#28a54c;background-color:#28a54c;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-balanced.button-clear,.button.button-balanced.button-icon{border-color:transparent;background:0 0}.button.button-balanced.button-clear{box-shadow:none;color:#33cd5f}.button.button-balanced.button-outline{border-color:#33cd5f;background:0 0;color:#33cd5f}.button.button-balanced.button-outline.activated,.button.button-balanced.button-outline.active{background-color:#33cd5f;box-shadow:none;color:#fff}.button.button-energized{border-color:#e6b500;background-color:#ffc900;color:#fff}.button.button-energized:hover{color:#fff;text-decoration:none}.button.button-energized.activated,.button.button-energized.active{border-color:#e6b500;background-color:#e6b500;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-energized.button-clear,.button.button-energized.button-icon{border-color:transparent;background:0 0}.button.button-energized.button-clear{box-shadow:none;color:#ffc900}.button.button-energized.button-outline{border-color:#ffc900;background:0 0;color:#ffc900}.button.button-energized.button-outline.activated,.button.button-energized.button-outline.active{background-color:#ffc900;box-shadow:none;color:#fff}.button.button-royal{border-color:#6b46e5;background-color:#886aea;color:#fff}.button.button-royal:hover{color:#fff;text-decoration:none}.button.button-royal.activated,.button.button-royal.active{border-color:#6b46e5;background-color:#6b46e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-royal.button-clear,.button.button-royal.button-icon{border-color:transparent;background:0 0}.button.button-royal.button-clear{box-shadow:none;color:#886aea}.button.button-royal.button-outline{border-color:#886aea;background:0 0;color:#886aea}.button.button-royal.button-outline.activated,.button.button-royal.button-outline.active{background-color:#886aea;box-shadow:none;color:#fff}.button.button-dark{border-color:#111;background-color:#444;color:#fff}.button.button-dark:hover{color:#fff;text-decoration:none}.button.button-dark.activated,.button.button-dark.active{border-color:#000;background-color:#262626;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-dark.button-clear,.button.button-dark.button-icon{border-color:transparent;background:0 0}.button.button-dark.button-clear{box-shadow:none;color:#444}.button.button-dark.button-outline{border-color:#444;background:0 0;color:#444}.button.button-dark.button-outline.activated,.button.button-dark.button-outline.active{background-color:#444;box-shadow:none;color:#fff}.button-small{padding:2px 4px 1px;min-width:28px;min-height:30px;font-size:12px;line-height:26px}.button-small .icon:before,.button-small.icon-left:before,.button-small.icon-right:before,.button-small.icon:before{font-size:16px;line-height:19px;margin-top:3px}.button-large{padding:0 16px;min-width:68px;min-height:59px;font-size:20px;line-height:53px}.button-large .icon:before,.button-large.icon-left:before,.button-large.icon-right:before,.button-large.icon:before{padding-bottom:2px;font-size:32px;line-height:51px}.button-icon{transition:opacity .1s;padding:0 6px;min-width:initial;border-color:transparent;background:0 0}.button-icon.button.activated,.button-icon.button.active{border-color:transparent;background:0 0;box-shadow:none;opacity:.3}.button-icon .icon:before,.button-icon.icon:before{font-size:32px}.button-clear{transition:opacity .1s;padding:0 6px;max-height:42px;border-color:transparent;background:0 0;box-shadow:none}.button-clear.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#b2b2b2}.button-clear.button-icon{border-color:transparent;background:0 0}.button-clear.activated,.button-clear.active{opacity:.3}.button-outline{transition:opacity .1s;background:0 0;box-shadow:none}.button-outline.button-outline{border-color:#b2b2b2;background:0 0;color:#b2b2b2}.button-outline.button-outline.activated,.button-outline.button-outline.active{background-color:#b2b2b2;box-shadow:none;color:#fff}.padding>.button.button-block:first-child{margin-top:0}.button-block{display:block;clear:both}.button-full,.button-full>.button{display:block;margin-right:0;margin-left:0;border-right-width:0;border-left-width:0;border-radius:0}a.button{text-decoration:none}a.button .icon:before,a.button.icon-left:before,a.button.icon-right:before,a.button.icon:before{margin-top:2px}.button.disabled,.button[disabled]{opacity:.4;cursor:default!important;pointer-events:none}.button-bar{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;width:100%}.button-bar.button-bar-inline{display:block;width:auto}.button-bar.button-bar-inline:after,.button-bar.button-bar-inline:before{display:table;content:\"\";line-height:0}.button-bar.button-bar-inline>.button{width:auto;display:inline-block;float:left}.button-bar>.button{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;overflow:hidden;padding:0 16px;width:0;border-width:1px 0 1px 1px;border-radius:0;text-align:center;text-overflow:ellipsis;white-space:nowrap}.col,.full-image,.row{width:100%}.button-bar>.button .icon:before,.button-bar>.button:before{line-height:44px}.button-bar>.button:first-child{border-radius:0}.button-bar>.button:last-child{border-right-width:1px;border-radius:0}.row{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;padding:5px}.row-wrap{-webkit-flex-wrap:wrap;-moz-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.row-no-padding,.row-no-padding>.col{padding:0}.row+.row{margin-top:-5px;padding-top:0}.col{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;padding:5px}.row-top{-webkit-box-align:start;-ms-flex-align:start;-webkit-align-items:flex-start;-moz-align-items:flex-start;align-items:flex-start}.row-bottom{-webkit-box-align:end;-ms-flex-align:end;-webkit-align-items:flex-end;-moz-align-items:flex-end;align-items:flex-end}.row-center{-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}.row-stretch{-webkit-box-align:stretch;-ms-flex-align:stretch;-webkit-align-items:stretch;-moz-align-items:stretch;align-items:stretch}.row-baseline{-webkit-box-align:baseline;-ms-flex-align:baseline;-webkit-align-items:baseline;-moz-align-items:baseline;align-items:baseline}.col-top{-webkit-align-self:flex-start;-moz-align-self:flex-start;-ms-flex-item-align:start;align-self:flex-start}.col-bottom{-webkit-align-self:flex-end;-moz-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end}.col-center{-webkit-align-self:center;-moz-align-self:center;-ms-flex-item-align:center;align-self:center}.col-10,.col-20{-webkit-box-flex:0}.col-offset-10{margin-left:10%}.col-offset-20{margin-left:20%}.col-offset-25{margin-left:25%}.col-offset-33,.col-offset-34{margin-left:33.3333%}.col-offset-50{margin-left:50%}.col-offset-66,.col-offset-67{margin-left:66.6666%}.col-offset-75{margin-left:75%}.col-offset-80{margin-left:80%}.col-offset-90{margin-left:90%}.col-10{-webkit-flex:0 0 10%;-moz-box-flex:0;-moz-flex:0 0 10%;-ms-flex:0 0 10%;flex:0 0 10%;max-width:10%}.col-20{-webkit-flex:0 0 20%;-moz-box-flex:0;-moz-flex:0 0 20%;-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.col-25{-webkit-box-flex:0;-webkit-flex:0 0 25%;-moz-box-flex:0;-moz-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-33,.col-34{-webkit-box-flex:0;-webkit-flex:0 0 33.3333%;-moz-box-flex:0;-moz-flex:0 0 33.3333%;-ms-flex:0 0 33.3333%;flex:0 0 33.3333%;max-width:33.3333%}.col-50{-webkit-box-flex:0;-webkit-flex:0 0 50%;-moz-box-flex:0;-moz-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-66,.col-67{-webkit-box-flex:0;-webkit-flex:0 0 66.6666%;-moz-box-flex:0;-moz-flex:0 0 66.6666%;-ms-flex:0 0 66.6666%;flex:0 0 66.6666%;max-width:66.6666%}.col-75,.col-80{-webkit-box-flex:0}.col-75{-webkit-flex:0 0 75%;-moz-box-flex:0;-moz-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-80{-webkit-flex:0 0 80%;-moz-box-flex:0;-moz-flex:0 0 80%;-ms-flex:0 0 80%;flex:0 0 80%;max-width:80%}.col-90{-webkit-box-flex:0;-webkit-flex:0 0 90%;-moz-box-flex:0;-moz-flex:0 0 90%;-ms-flex:0 0 90%;flex:0 0 90%;max-width:90%}@media (max-width:567px){.responsive-sm{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-sm .col,.responsive-sm .col-10,.responsive-sm .col-20,.responsive-sm .col-25,.responsive-sm .col-33,.responsive-sm .col-34,.responsive-sm .col-50,.responsive-sm .col-66,.responsive-sm .col-67,.responsive-sm .col-75,.responsive-sm .col-80,.responsive-sm .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}@media (max-width:767px){.responsive-md{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-md .col,.responsive-md .col-10,.responsive-md .col-20,.responsive-md .col-25,.responsive-md .col-33,.responsive-md .col-34,.responsive-md .col-50,.responsive-md .col-66,.responsive-md .col-67,.responsive-md .col-75,.responsive-md .col-80,.responsive-md .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}@media (max-width:1023px){.responsive-lg{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-lg .col,.responsive-lg .col-10,.responsive-lg .col-20,.responsive-lg .col-25,.responsive-lg .col-33,.responsive-lg .col-34,.responsive-lg .col-50,.responsive-lg .col-66,.responsive-lg .col-67,.responsive-lg .col-75,.responsive-lg .col-80,.responsive-lg .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}.hide{display:none}.opacity-hide{opacity:0}.grade-b .opacity-hide,.grade-c .opacity-hide{opacity:1;display:none}.show{display:block}.opacity-show{opacity:1}.keyboard-open .hide-on-keyboard-open{display:none}.keyboard-open .bar-footer.hide-on-keyboard-open+.pane .has-footer,.keyboard-open .tabs.hide-on-keyboard-open+.pane .has-tabs{bottom:0}.inline{display:inline-block}.disable-pointer-events{pointer-events:none}.enable-pointer-events{pointer-events:auto}.disable-user-behavior{-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:none;-ms-content-zooming:none}.click-block{position:absolute;top:0;right:0;bottom:0;left:0;opacity:0;z-index:99999;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);overflow:hidden}.click-block-hide{-webkit-transform:translate3d(-9999px,0,0);transform:translate3d(-9999px,0,0)}.no-resize{resize:none}.block{display:block}.block:after{display:block;height:0;content:\".\"}.clearfix:after,.clearfix:before{display:table;content:\"\";line-height:0}.padding{padding:10px}.padding-top,.padding-vertical{padding-top:10px}.padding-horizontal,.padding-right{padding-right:10px}.padding-bottom,.padding-vertical{padding-bottom:10px}.padding-horizontal,.padding-left{padding-left:10px}.iframe-wrapper{position:fixed;-webkit-overflow-scrolling:touch;overflow:scroll}.iframe-wrapper iframe{height:100%;width:100%}.rounded{border-radius:4px}.item-input-wrapper,.toc-square-avatar .item-content>img:first-child{border-radius:0}.light,a.light{color:#fff}.light-bg{background-color:#fff}.light-border{border-color:#ddd}.stable,a.stable{color:#f8f8f8}.stable-bg{background-color:#f8f8f8}.stable-border{border-color:#b2b2b2}.positive,a.positive{color:#387ef5}.positive-bg{background-color:#387ef5}.positive-border{border-color:#0c60ee}.calm,a.calm{color:#11c1f3}.calm-bg{background-color:#11c1f3}.calm-border{border-color:#0a9dc7}.assertive,a.assertive{color:#ef473a}.assertive-bg{background-color:#ef473a}.assertive-border{border-color:#e42112}.balanced,a.balanced{color:#33cd5f}.balanced-bg{background-color:#33cd5f}.balanced-border{border-color:#28a54c}.energized,a.energized{color:#ffc900}.energized-bg{background-color:#ffc900}.energized-border{border-color:#e6b500}.royal,a.royal{color:#886aea}.royal-bg{background-color:#886aea}.royal-border{border-color:#6b46e5}.dark,a.dark{color:#444}.dark-bg{background-color:#444}.dark-border{border-color:#111}[collection-repeat]{left:0!important;top:0!important;position:absolute!important;z-index:1}.collection-repeat-container{position:relative;z-index:1}.collection-repeat-after-container{z-index:0;display:block}.collection-repeat-after-container.horizontal{display:inline-block}.ng-cloak,.ng-hide:not(.ng-hide-animate),.x-ng-cloak,[data-ng-cloak],[ng-cloak],[ng\\:cloak],[x-ng-cloak]{display:none!important}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader){height:64px}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader).item-input-inset .item-input-wrapper{margin-top:19px!important}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader)>*{margin-top:20px}.platform-ios.platform-cordova:not(.fullscreen) .bar-subheader,.platform-ios.platform-cordova:not(.fullscreen) .has-header,.platform-ios.platform-cordova:not(.fullscreen) .tabs-top>.tabs,.platform-ios.platform-cordova:not(.fullscreen) .tabs.tabs-top{top:64px}.platform-ios.platform-cordova:not(.fullscreen) .has-subheader{top:108px}.platform-ios.platform-cordova:not(.fullscreen) .has-header.has-tabs-top{top:113px}.platform-ios.platform-cordova:not(.fullscreen) .has-header.has-subheader.has-tabs-top{top:157px}.platform-ios.platform-cordova.status-bar-hide{margin-bottom:20px}@media (orientation:landscape){.platform-ios.platform-browser.platform-ipad{position:fixed}}.platform-c:not(.enable-transitions) *{-webkit-transition:none!important;transition:none!important}.slide-in-up{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}.slide-in-up.ng-enter,.slide-in-up>.ng-enter{-webkit-transition:all cubic-bezier(.1,.7,.1,1)400ms;transition:all cubic-bezier(.1,.7,.1,1)400ms}.slide-in-up.ng-enter-active,.slide-in-up>.ng-enter-active{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.slide-in-up.ng-leave,.slide-in-up>.ng-leave{-webkit-transition:all ease-in-out 250ms;transition:all ease-in-out 250ms}@-webkit-keyframes scaleOut{from{-webkit-transform:scale(1);opacity:1}to{-webkit-transform:scale(.8);opacity:0}}@keyframes scaleOut{from{transform:scale(1);opacity:1}to{transform:scale(.8);opacity:0}}@-webkit-keyframes superScaleIn{from{-webkit-transform:scale(1.2);opacity:0}to{-webkit-transform:scale(1);opacity:1}}@keyframes superScaleIn{from{transform:scale(1.2);opacity:0}to{transform:scale(1);opacity:1}}[nav-view-transition=ios] [nav-view=entering],[nav-view-transition=ios] [nav-view=leaving]{-webkit-transition-duration:500ms;transition-duration:500ms;-webkit-transition-timing-function:cubic-bezier(.36,.66,.04,1);transition-timing-function:cubic-bezier(.36,.66,.04,1);-webkit-transition-property:opacity,-webkit-transform,box-shadow;transition-property:opacity,transform,box-shadow}[nav-view-transition=ios][nav-view-direction=forward],[nav-view-transition=ios][nav-view-direction=back]{background-color:#000}[nav-bar-transition=ios] [nav-bar=entering] .bar,[nav-bar-transition=ios] [nav-bar=active] .bar,[nav-bar-transition=android] [nav-bar=entering] .bar,[nav-bar-transition=android] [nav-bar=active] .bar{background:0 0}[nav-view-transition=ios] [nav-view=active],[nav-view-transition=ios][nav-view-direction=forward] [nav-view=entering],[nav-view-transition=ios][nav-view-direction=back] [nav-view=leaving]{z-index:3}[nav-view-transition=ios][nav-view-direction=forward] [nav-view=leaving],[nav-view-transition=ios][nav-view-direction=back] [nav-view=entering]{z-index:2}[nav-bar-transition=ios] .back-text,[nav-bar-transition=ios] .buttons,[nav-bar-transition=ios] .title{-webkit-transition-duration:500ms;transition-duration:500ms;-webkit-transition-timing-function:cubic-bezier(.36,.66,.04,1);transition-timing-function:cubic-bezier(.36,.66,.04,1);-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,transform}[nav-bar-transition=ios] [nav-bar=entering],[nav-bar-transition=ios] [nav-bar=active]{z-index:10}[nav-bar-transition=ios] [nav-bar=cached]{display:block}[nav-bar-transition=ios] [nav-bar=cached] .header-item{display:none}[nav-view-transition=android] [nav-view=entering],[nav-view-transition=android] [nav-view=leaving]{-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(.4,.6,.2,1);transition-timing-function:cubic-bezier(.4,.6,.2,1);-webkit-transition-property:-webkit-transform;transition-property:transform}[nav-view-transition=android] [nav-view=active],[nav-view-transition=android][nav-view-direction=forward] [nav-view=entering],[nav-view-transition=android][nav-view-direction=back] [nav-view=leaving]{z-index:3}[nav-view-transition=android][nav-view-direction=forward] [nav-view=leaving],[nav-view-transition=android][nav-view-direction=back] [nav-view=entering]{z-index:2}[nav-bar-transition=android] .buttons,[nav-bar-transition=android] .title{-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(.4,.6,.2,1);transition-timing-function:cubic-bezier(.4,.6,.2,1);-webkit-transition-property:opacity;transition-property:opacity}[nav-bar-transition=android] [nav-bar=entering],[nav-bar-transition=android] [nav-bar=active]{z-index:10}[nav-bar-transition=android] [nav-bar=cached]{display:block}[nav-bar-transition=android] [nav-bar=cached] .header-item,[nav-bar=cached],[nav-view=cached]{display:none}[nav-swipe=fast] .back-text,[nav-swipe=fast] .buttons,[nav-swipe=fast] .title,[nav-swipe=fast] [nav-view]{-webkit-transition-duration:50ms;transition-duration:50ms;-webkit-transition-timing-function:linear;transition-timing-function:linear}[nav-swipe=slow] .back-text,[nav-swipe=slow] .buttons,[nav-swipe=slow] .title,[nav-swipe=slow] [nav-view]{-webkit-transition-duration:160ms;transition-duration:160ms;-webkit-transition-timing-function:linear;transition-timing-function:linear}[nav-view=stage]{opacity:0;-webkit-transition-duration:0;transition-duration:0}[nav-bar=stage] .back-text,[nav-bar=stage] .buttons,[nav-bar=stage] .title{position:absolute;opacity:0;-webkit-transition-duration:0s;transition-duration:0s}.button,.button[disabled],.toc-fadein,.toc-fadeout{transition:opacity .75s ease-in}.toast-top-right{top:56px}#toast-container>div{display:flex;align-items:center;border-radius:0;box-shadow:0 1px 3px rgba(0,0,0,.3);padding:12px;overflow:hidden;width:250px}#toast-container>div>div{display:inline-block}#toast-container>div:hover{box-shadow:0 1px 3px rgba(0,0,0,.5)}#toast-container>div:before{font-size:24px;margin:0 12px 0 6px}#toast-container>div .toast-message,#toast-container>div .toast-title{max-width:180px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}#toast-container>.toast-error{background-image:none!important;background-color:#ef473a}#toast-container>.toast-success{background-image:none!important;background-color:#33cd5f}#toast-container>.toast-info{background-image:none!important;background-color:#11c1f3}#toast-container>.toast-warning{background-image:none!important;background-color:#ffc900}.toc-qr-image-container img:first-child{width:inherit;max-width:100%}.toc-send-spinner svg{height:32px;width:32px}button[toc-spinner-button] .spinner svg{vertical-align:middle}p.toc-message.toc-unread-message{font-weight:700}p.toc-message-content{white-space:normal;overflow:initial;text-overflow:initial;padding:0}p.toc-message-timestamp{padding:0;text-align:right}.button{opacity:1}.scroll{height:100%}.toc-flex-container{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-flex-direction:column;-moz-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100%}.toc-flex-content{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;z-index:1}.toc-flex-footer{background-color:#fff;z-index:2}.toc-hidden{display:none}.toc-fadein{opacity:1}.toc-fadeout{opacity:0}");