"bundle";
System.registerDynamic("github:angular/bower-angular@1.4.7/angular", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.4.7/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
          return false;
        }
        var length = "length" in Object(obj) && obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
          return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === 'number' && length > 0 && (length - 1) in obj;
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;
      function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(","),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
          throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (isTypedArray(destination)) {
          throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
        }
        if (!destination) {
          destination = source;
          if (isObject(source)) {
            var index;
            if (stackSource && (index = stackSource.indexOf(source)) !== -1) {
              return stackDest[index];
            }
            if (isArray(source)) {
              return copy(source, [], stackSource, stackDest);
            } else if (isTypedArray(source)) {
              destination = new source.constructor(source);
            } else if (isDate(source)) {
              destination = new Date(source.getTime());
            } else if (isRegExp(source)) {
              destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              destination.lastIndex = source.lastIndex;
            } else if (isFunction(source.cloneNode)) {
              destination = source.cloneNode(true);
            } else {
              var emptyObject = Object.create(getPrototypeOf(source));
              return copy(source, emptyObject, stackSource, stackDest);
            }
            if (stackDest) {
              stackSource.push(source);
              stackDest.push(destination);
            }
          }
        } else {
          if (source === destination)
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          stackSource = stackSource || [];
          stackDest = stackDest || [];
          if (isObject(source)) {
            stackSource.push(source);
            stackDest.push(destination);
          }
          var result,
              key;
          if (isArray(source)) {
            destination.length = 0;
            for (var i = 0; i < source.length; i++) {
              destination.push(copy(source[i], null, stackSource, stackDest));
            }
          } else {
            var h = destination.$$hashKey;
            if (isArray(destination)) {
              destination.length = 0;
            } else {
              forEach(destination, function(value, key) {
                delete destination[key];
              });
            }
            if (isBlankObject(source)) {
              for (key in source) {
                destination[key] = copy(source[key], null, stackSource, stackDest);
              }
            } else if (source && typeof source.hasOwnProperty === 'function') {
              for (key in source) {
                if (source.hasOwnProperty(key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            } else {
              for (key in source) {
                if (hasOwnProperty.call(source, key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            }
            setHashKey(destination, h);
          }
        }
        return destination;
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2))
                return false;
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key]))
                    return false;
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2))
                return false;
              return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              return isRegExp(o2) ? o1.toString() == o2.toString() : false;
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                  continue;
                if (!equals(o1[key], o2[key]))
                  return false;
                keySet[key] = true;
              }
              for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (typeof obj === 'undefined')
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      var skipDestroyOnNextJQueryCleanData;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            if (!skipDestroyOnNextJQueryCleanData) {
              for (var i = 0,
                  elem; (elem = elems[i]) != null; i++) {
                events = jQuery._data(elem, "events");
                if (events && events.$destroy) {
                  jQuery(elem).triggerHandler('$destroy');
                }
              }
            } else {
              skipDestroyOnNextJQueryCleanData = false;
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.4.7',
        major: 1,
        minor: 4,
        dot: 7,
        codeName: 'dark-luminescence'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$CoreAnimateRunnerProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          forEach(type.split(' '), function(type) {
            if (isDefined(fn)) {
              var listenerFns = events[type];
              arrayRemove(listenerFns || [], fn);
              if (listenerFns && listenerFns.length > 0) {
                return;
              }
            }
            removeEventListenerFn(element, type, handle);
            delete events[type];
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              eventFns[i].call(element, event);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          while (i--) {
            type = types[i];
            var eventFns = events[type];
            if (!eventFns) {
              events[type] = [];
              if (type === 'mouseenter' || type === 'mouseleave') {
                jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                  var target = this,
                      related = event.relatedTarget;
                  if (!related || (related !== target && !target.contains(related))) {
                    handle(event, type);
                  }
                });
              } else {
                if (type !== '$destroy') {
                  addEventListenerFn(element, type, handle);
                }
              }
              eventFns = events[type];
            }
            eventFns.push(fn);
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          wrapNode = jqLite(wrapNode).eq(0).clone()[0];
          var parent = element.parentNode;
          if (parent) {
            parent.replaceChild(wrapNode, element);
          }
          wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(FN_ARGS);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            fnText,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              fnText = fn.toString().replace(STRIP_COMMENTS, '');
              argDecl = fnText.match(FN_ARGS);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }));
        forEach(loadModules(modulesToLoad), function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName),
                length,
                i,
                key;
            for (i = 0, length = $inject.length; i < length; i++) {
              key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            if (isArray(fn)) {
              fn = fn[length];
            }
            return fn.apply(self, args);
          }
          function instantiate(Type, locals, serviceName) {
            var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
            var returnedValue = invoke(Type, instance, locals, serviceName);
            return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateRunnerProvider = function() {
        this.$get = ['$q', '$$rAF', function($q, $$rAF) {
          function AnimateRunner() {}
          AnimateRunner.all = noop;
          AnimateRunner.chain = noop;
          AnimateRunner.prototype = {
            end: noop,
            cancel: noop,
            resume: noop,
            pause: noop,
            complete: noop,
            then: function(pass, fail) {
              return $q(function(resolve) {
                $$rAF(function() {
                  resolve();
                });
              }).then(pass, fail);
            }
          };
          return AnimateRunner;
        }];
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              return new $$AnimateRunner();
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', function($$rAF, $q) {
          var RAFPromise = function() {};
          RAFPromise.prototype = {
            done: function(cancel) {
              this.defer && this.defer[cancel === true ? 'reject' : 'resolve']();
            },
            end: function() {
              this.done();
            },
            cancel: function() {
              this.done(true);
            },
            getPromise: function() {
              if (!this.defer) {
                this.defer = $q.defer();
              }
              return this.defer.promise;
            },
            then: function(f1, f2) {
              return this.getPromise().then(f1, f2);
            },
            'catch': function(f1) {
              return this.getPromise()['catch'](f1);
            },
            'finally': function(f1) {
              return this.getPromise()['finally'](f1);
            }
          };
          return function(element, options) {
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new RAFPromise();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                close();
                if (!closed) {
                  runner.done();
                }
                closed = true;
              });
              return runner;
            }
            function close() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || pendingLocation) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = {},
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = {},
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = {};
                size = 0;
                lruHash = {};
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
          var Attributes = function(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          };
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && key === 'href') || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  this.$$element.attr(attrName, value);
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            forEach($compileNodes, function(node, index) {
              if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
              }
            });
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                    var destroyBindings = nodeLinkFn.$$destroyBindings;
                    if (destroyBindings) {
                      nodeLinkFn.$$destroyBindings = null;
                      childScope.$on('$destroyed', destroyBindings);
                    }
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            };
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
                  if (directiveIsMultiElement(directiveNName)) {
                    if (ngAttrName === directiveNName + 'Start') {
                      attrStartName = name;
                      attrEndName = name.substr(0, name.length - 5) + 'end';
                      name = name.substr(0, name.length - 6);
                    }
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  $compileNode.empty();
                  childTranscludeFn = compile($template, transcludeFn);
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective) {
                    markDirectivesAsIsolate(templateDirectives);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
              var value;
              if (isString(require)) {
                var match = require.match(REQUIRE_PREFIX_REGEXP);
                var name = require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                  $element = $element.parent();
                } else {
                  value = elementControllers && elementControllers[name];
                  value = value && value.instance;
                }
                if (!value) {
                  var dataName = '$' + name + 'Controller';
                  value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                  throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                }
              } else if (isArray(require)) {
                value = [];
                for (var i = 0,
                    ii = require.length; i < ii; i++) {
                  value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                }
              }
              return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
              var elementControllers = createMap();
              for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                  $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                  $element: $element,
                  $attrs: attrs,
                  $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                if (!hasElementTranscludeDirective) {
                  $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
              }
              return elementControllers;
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
              var i,
                  ii,
                  linkFn,
                  controller,
                  isolateScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope);
              }
              if (elementControllers) {
                var scopeDirective = newIsolateScopeDirective || newScopeDirective;
                var bindings;
                var controllerForBindings;
                if (scopeDirective && elementControllers[scopeDirective.name]) {
                  bindings = scopeDirective.$$bindings.bindToController;
                  controller = elementControllers[scopeDirective.name];
                  if (controller && controller.identifier && bindings) {
                    controllerForBindings = controller;
                    thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective);
                  }
                }
                for (i in elementControllers) {
                  controller = elementControllers[i];
                  var controllerResult = controller();
                  if (controllerResult !== controller.instance) {
                    controller.instance = controllerResult;
                    $element.data('$' + i + 'Controller', controllerResult);
                    if (controller === controllerForBindings) {
                      thisLinkFn.$$destroyBindings();
                      thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
                    }
                  }
                }
              }
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
          function markDirectivesAsIsolate(directives) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {$$isolateScope: true});
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectivesAsIsolate(templateDirectives);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            fragment.appendChild(firstElementToRemove);
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite(newNode).data(jqLite(firstElementToRemove).data());
              if (!jQuery) {
                delete jqLite.cache[firstElementToRemove[jqLite.expando]];
              } else {
                skipDestroyOnNextJQueryCleanData = true;
                jQuery.cleanData([firstElementToRemove]);
              }
            }
            for (var k = 1,
                kk = elementsToRemove.length; k < kk; k++) {
              var element = elementsToRemove[k];
              jqLite(element).remove();
              fragment.appendChild(element);
              delete elementsToRemove[k];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
            var onNewScopeDestroyed;
            forEach(bindings, function(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value)) {
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  if (isString(attrs[attrName])) {
                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                  }
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  var unwatch;
                  if (definition.collection) {
                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  onNewScopeDestroyed = (onNewScopeDestroyed || []);
                  onNewScopeDestroyed.push(unwatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            var destroyBindings = onNewScopeDestroyed ? function destroyBindings() {
              for (var i = 0,
                  ii = onNewScopeDestroyed.length; i < ii; ++i) {
                onNewScopeDestroyed[i]();
              }
            } : noop;
            if (newScope && destroyBindings !== noop) {
              newScope.$on('$destroy', destroyBindings);
              return noop;
            }
            return destroyBindings;
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v, k) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!angular.isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              if (!response.data) {
                resp.data = response.data;
              } else {
                resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              }
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', function($rootScope, $window, $q, $$q) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = setInterval(function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = beginsWith(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name, fullExpression) {
        name = name + '';
        if (!isString(name)) {
          throw $parseMinErr('iseccst', 'Cannot convert object to primitive value! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.constants.hasOwnProperty(this.peek().text)) {
            primary = copy(this.constants[this.consume().text]);
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        constants: {
          'true': {
            type: AST.Literal,
            value: true
          },
          'false': {
            type: AST.Literal,
            value: false
          },
          'null': {
            type: AST.Literal,
            value: null
          },
          'undefined': {
            type: AST.Literal,
            value: undefined
          },
          'this': {type: AST.ThisExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ',text)');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign, inputs) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1 && lhs && !(lhs[rhs])) {
                lhs[rhs] = {};
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1 && lhs && !(lhs[right])) {
              lhs[right] = {};
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      var getterFnCacheDefault = createMap();
      var getterFnCacheExpensive = createMap();
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true
              };
          return function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return noop;
            }
          };
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              return parsedExpression(scope);
            }, function constantListener(value, old, scope) {
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              unwatch();
            }, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        function callOnce(self, resolveFn, rejectFn) {
          var called = false;
          function wrap(fn) {
            return function(value) {
              if (called)
                return;
              called = true;
              fn.call(self, value);
            };
          }
          return [wrap(resolveFn), wrap(rejectFn)];
        }
        var defer = function() {
          return new Deferred();
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
          this.resolve = simpleBind(this, this.resolve);
          this.reject = simpleBind(this, this.reject);
          this.notify = simpleBind(this, this.notify);
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then,
                fns;
            fns = callOnce(this, this.$$resolve, this.$$reject);
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, fns[0], fns[1], this.notify);
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              fns[1](e);
              exceptionHandler(e);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          if (!(this instanceof Q)) {
            return new Q(resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser', function($injector, $exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  logMsg,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            watch.fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: expr,
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $compileMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            var httpOptions = {
              cache: $templateCache,
              transformResponse: transformResponse
            };
            return $http.get(tpl, httpOptions)['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      var DECIMAL_SEP = '.';
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number))
          return '';
        var isNegative = number < 0;
        number = Math.abs(number);
        var isInfinity = number === Infinity;
        if (!isInfinity && !isFinite(number))
          return '';
        var numStr = number + '',
            formatedText = '',
            hasExponent = false,
            parts = [];
        if (isInfinity)
          formatedText = '\u221e';
        if (!isInfinity && numStr.indexOf('e') !== -1) {
          var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
          if (match && match[2] == '-' && match[3] > fractionSize + 1) {
            number = 0;
          } else {
            formatedText = numStr;
            hasExponent = true;
          }
        }
        if (!isInfinity && !hasExponent) {
          var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
          if (isUndefined(fractionSize)) {
            fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
          }
          number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
          var fraction = ('' + number).split(DECIMAL_SEP);
          var whole = fraction[0];
          fraction = fraction[1] || '';
          var i,
              pos = 0,
              lgroup = pattern.lgSize,
              group = pattern.gSize;
          if (whole.length >= (lgroup + group)) {
            pos = whole.length - lgroup;
            for (i = 0; i < pos; i++) {
              if ((pos - i) % group === 0 && i !== 0) {
                formatedText += groupSep;
              }
              formatedText += whole.charAt(i);
            }
          }
          for (i = pos; i < whole.length; i++) {
            if ((whole.length - i) % lgroup === 0 && i !== 0) {
              formatedText += groupSep;
            }
            formatedText += whole.charAt(i);
          }
          while (fraction.length < fractionSize) {
            fraction += '0';
          }
          if (fractionSize && fractionSize !== "0")
            formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
          if (fractionSize > 0 && number < 1) {
            formatedText = number.toFixed(fractionSize);
            number = parseFloat(formatedText);
            formatedText = formatedText.replace(DECIMAL_SEP, decimalSep);
          }
        }
        if (number === 0) {
          isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim);
        };
      }
      function dateStrGetter(name, shortForm) {
        return function(date, formats) {
          var value = date['get' + name]();
          var get = uppercase(shortForm ? ('SHORT' + name) : name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (!(isArrayLike(array)))
            return array;
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function(data) {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var timeout;
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', function($animate) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (/SVG/.test($element[0].toString())) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
              } else {
                parsedNgModelAssign($scope, ctrl.$modelValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function(error) {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function(ev) {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(optionValues[key], key);
                var selectValue = getTrackByValueFn(optionValues[key], locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', '?ngModel'],
          link: function(scope, selectElement, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            var multiple = attr.multiple;
            var emptyOption;
            for (var i = 0,
                children = selectElement.children(),
                ii = children.length; i < ii; i++) {
              if (children[i].value === '') {
                emptyOption = children.eq(i);
                break;
              }
            }
            var providedEmptyOption = !!emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val('?');
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var renderEmptyOption = function() {
              if (!providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              selectElement.val('');
              emptyOption.prop('selected', true);
              emptyOption.attr('selected', true);
            };
            var removeEmptyOption = function() {
              if (!providedEmptyOption) {
                emptyOption.remove();
              }
            };
            var renderUnknownOption = function() {
              selectElement.prepend(unknownOption);
              selectElement.val('?');
              unknownOption.prop('selected', true);
              unknownOption.attr('selected', true);
            };
            var removeUnknownOption = function() {
              unknownOption.remove();
            };
            if (!multiple) {
              selectCtrl.writeValue = function writeNgOptionsValue(value) {
                var option = options.getOptionFromViewValue(value);
                if (option && !option.disabled) {
                  if (selectElement[0].value !== option.selectValue) {
                    removeUnknownOption();
                    removeEmptyOption();
                    selectElement[0].value = option.selectValue;
                    option.element.selected = true;
                    option.element.setAttribute('selected', 'selected');
                  }
                } else {
                  if (value === null || providedEmptyOption) {
                    removeUnknownOption();
                    renderEmptyOption();
                  } else {
                    removeEmptyOption();
                    renderUnknownOption();
                  }
                }
              };
              selectCtrl.readValue = function readNgOptionsValue() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                if (selectedOption && !selectedOption.disabled) {
                  removeEmptyOption();
                  removeUnknownOption();
                  return options.getViewValueFromOption(selectedOption);
                }
                return null;
              };
              if (ngOptions.trackBy) {
                scope.$watch(function() {
                  return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            } else {
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
              selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                options.items.forEach(function(option) {
                  option.element.selected = false;
                });
                if (value) {
                  value.forEach(function(item) {
                    var option = options.getOptionFromViewValue(item);
                    if (option && !option.disabled)
                      option.element.selected = true;
                  });
                }
              };
              selectCtrl.readValue = function readNgOptionsMultiple() {
                var selectedValues = selectElement.val() || [],
                    selections = [];
                forEach(selectedValues, function(value) {
                  var option = options.selectValueMap[value];
                  if (option && !option.disabled)
                    selections.push(options.getViewValueFromOption(option));
                });
                return selections;
              };
              if (ngOptions.trackBy) {
                scope.$watchCollection(function() {
                  if (isArray(ngModelCtrl.$viewValue)) {
                    return ngModelCtrl.$viewValue.map(function(value) {
                      return ngOptions.getTrackByValue(value);
                    });
                  }
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            }
            if (providedEmptyOption) {
              emptyOption.remove();
              $compile(emptyOption)(scope);
              emptyOption.removeClass('ng-scope');
            } else {
              emptyOption = jqLite(optionTemplate.cloneNode(false));
            }
            updateOptions();
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function updateOptionElement(option, element) {
              option.element = element;
              element.disabled = option.disabled;
              if (option.label !== element.label) {
                element.label = option.label;
                element.textContent = option.label;
              }
              if (option.value !== element.value)
                element.value = option.selectValue;
            }
            function addOrReuseElement(parent, current, type, templateElement) {
              var element;
              if (current && lowercase(current.nodeName) === type) {
                element = current;
              } else {
                element = templateElement.cloneNode(false);
                if (!current) {
                  parent.appendChild(element);
                } else {
                  parent.insertBefore(element, current);
                }
              }
              return element;
            }
            function removeExcessElements(current) {
              var next;
              while (current) {
                next = current.nextSibling;
                jqLiteRemove(current);
                current = next;
              }
            }
            function skipEmptyAndUnknownOptions(current) {
              var emptyOption_ = emptyOption && emptyOption[0];
              var unknownOption_ = unknownOption && unknownOption[0];
              if (emptyOption_ || unknownOption_) {
                while (current && (current === emptyOption_ || current === unknownOption_ || emptyOption_ && emptyOption_.nodeType === NODE_TYPE_COMMENT)) {
                  current = current.nextSibling;
                }
              }
              return current;
            }
            function updateOptions() {
              var previousValue = options && selectCtrl.readValue();
              options = ngOptions.getOptions();
              var groupMap = {};
              var currentElement = selectElement[0].firstChild;
              if (providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              currentElement = skipEmptyAndUnknownOptions(currentElement);
              options.items.forEach(function updateOption(option) {
                var group;
                var groupElement;
                var optionElement;
                if (option.group) {
                  group = groupMap[option.group];
                  if (!group) {
                    groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                    currentElement = groupElement.nextSibling;
                    groupElement.label = option.group;
                    group = groupMap[option.group] = {
                      groupElement: groupElement,
                      currentOptionElement: groupElement.firstChild
                    };
                  }
                  optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  group.currentOptionElement = optionElement.nextSibling;
                } else {
                  optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  currentElement = optionElement.nextSibling;
                }
              });
              Object.keys(groupMap).forEach(function(key) {
                removeExcessElements(groupMap[key].currentOptionElement);
              });
              removeExcessElements(currentElement);
              ngModelCtrl.$render();
              if (!ngModelCtrl.$isEmpty(previousValue)) {
                var nextValue = selectCtrl.readValue();
                if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                  ngModelCtrl.$setViewValue(nextValue);
                  ngModelCtrl.$render();
                }
              }
            }
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, jqLite(previousNode));
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', function($animate) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if (!$transclude) {
            throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          $transclude(function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          link: function(scope, element, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            selectCtrl.ngModelCtrl = ngModelCtrl;
            ngModelCtrl.$render = function() {
              selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
            element.on('change', function() {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(selectCtrl.readValue());
              });
            });
            if (attr.multiple) {
              selectCtrl.readValue = function readMultipleValue() {
                var array = [];
                forEach(element.find('option'), function(option) {
                  if (option.selected) {
                    array.push(option.value);
                  }
                });
                return array;
              };
              selectCtrl.writeValue = function writeMultipleValue(value) {
                var items = new HashMap(value);
                forEach(element.find('option'), function(option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              var lastView,
                  lastViewRef = NaN;
              scope.$watch(function selectMultipleWatch() {
                if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                  lastView = shallowCopy(ngModelCtrl.$viewValue);
                  ngModelCtrl.$render();
                }
                lastViewRef = ngModelCtrl.$viewValue;
              });
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
            }
          }
        };
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        function chromeHack(optionElement) {
          if (optionElement[0].hasAttribute('selected')) {
            optionElement[0].selected = true;
          }
        }
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var valueInterpolated = $interpolate(attr.value, true);
            } else {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              function addOption(optionValue) {
                selectCtrl.addOption(optionValue, element);
                selectCtrl.ngModelCtrl.$render();
                chromeHack(element);
              }
              if (selectCtrl && selectCtrl.ngModelCtrl) {
                if (valueInterpolated) {
                  var oldVal;
                  attr.$observe('value', function valueAttributeObserveAction(newVal) {
                    if (isDefined(oldVal)) {
                      selectCtrl.removeOption(oldVal);
                    }
                    oldVal = newVal;
                    addOption(newVal);
                  });
                } else if (interpolateFn) {
                  scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                    attr.$set('value', newVal);
                    if (oldVal !== newVal) {
                      selectCtrl.removeOption(oldVal);
                    }
                    addOption(newVal);
                  });
                } else {
                  addOption(attr.value);
                }
                element.on('$destroy', function() {
                  selectCtrl.removeOption(attr.value);
                  selectCtrl.ngModelCtrl.$render();
                });
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        console.log('WARNING: Tried to load angular more than once.');
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular@1.4.7", ["github:angular/bower-angular@1.4.7/angular"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:angular/bower-angular@1.4.7/angular');
  global.define = __define;
  return module.exports;
});

System.register('components/auto-focus/auto-focus-directive.js', [], function (_export) {
  //workaround for transition performance issues with ionic navigation + autofocus
  'use strict';

  var directiveName;

  _export('default', tocAutoFocus);

  /*@ngInject*/
  function tocAutoFocus($timeout) {
    return {
      restrict: 'A',
      link: function linkAutoFocus(scope, element) {
        $timeout(function () {
          return element[0].focus();
        }, 500, false);
      }
    };
  }

  return {
    setters: [],
    execute: function () {
      directiveName = 'tocAutoFocus';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/auto-focus/auto-focus.js', ['github:angular/bower-angular@1.4.7', 'components/auto-focus/auto-focus-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsAutoFocusAutoFocusDirectiveJs) {
      directive = _componentsAutoFocusAutoFocusDirectiveJs['default'];
      directiveName = _componentsAutoFocusAutoFocusDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.auto-focus', []).directive(directiveName, directive));
    }
  };
});

System.register('components/auto-select/auto-select-directive.js', [], function (_export) {
  'use strict';

  var directiveName;

  _export('default', tocAutoSelect);

  /*@ngInject*/
  function tocAutoSelect($window, $log, notifications, devices) {
    return {
      restrict: 'A',
      scope: {
        notifyCopied: '@'
      },
      link: function linkAutoSelect(scope, element) {
        // Auto select interferes with tap-hold selection
        // and doesn't bring up copy dialog on cordova android
        // only enable autoselect if clipboard API is supported
        var clipboardSupported = $window.document.queryCommandSupported("copy");
        if (devices.isCordovaApp() && !clipboardSupported) {
          return;
        }

        element.bind('click', function (event) {
          event.preventDefault();
          if (element[0].select) {
            element[0].select();
          } else {
            if ($window.getSelection) {
              var selection = $window.getSelection();
              var range = $window.document.createRange();
              range.selectNodeContents(element[0]);
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }

          try {
            $window.document.execCommand('copy');
            if (scope.notifyCopied) {
              notifications.notifySystem('Copied to clipboard!');
            }
            if (element[0].select) {
              element[0].blur();
            } else {
              if ($window.getSelection) {
                var selection = $window.getSelection();
                selection.removeAllRanges();
              }
            }
          } catch (error) {
            // don't clear selection as fallback to allow users to copy manually
            $log.error(error);
          }
        });
      }
    };
  }

  return {
    setters: [],
    execute: function () {
      directiveName = 'tocAutoSelect';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/auto-select/auto-select.js', ['github:angular/bower-angular@1.4.7', 'components/auto-select/auto-select-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsAutoSelectAutoSelectDirectiveJs) {
      directive = _componentsAutoSelectAutoSelectDirectiveJs['default'];
      directiveName = _componentsAutoSelectAutoSelectDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.auto-select', []).directive(directiveName, directive));
    }
  };
});

System.register('components/equal-to/equal-to-directive.js', [], function (_export) {
  'use strict';

  var directiveName;

  _export('default', tocEqualTo);

  /*@ngInject*/
  function tocEqualTo() {
    return {
      require: 'ngModel',
      restrict: 'A',
      scope: {
        otherValue: '=tocEqualTo'
      },
      link: function link(scope, element, attributes, ngModel) {
        ngModel.$validators.equalTo = function (modelValue) {
          return modelValue === scope.otherValue;
        };

        scope.$watch('otherValue', function () {
          ngModel.$validate();
        });
      }
    };
  }

  return {
    setters: [],
    execute: function () {
      directiveName = 'tocEqualTo';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/equal-to/equal-to.js', ['github:angular/bower-angular@1.4.7', 'components/equal-to/equal-to-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsEqualToEqualToDirectiveJs) {
      directive = _componentsEqualToEqualToDirectiveJs['default'];
      directiveName = _componentsEqualToEqualToDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.equal-to', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/update-profile-modal/update-profile-modal.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-modal-view>\n  <form name=\"tocUpdateProfileForm\" id=\"toc-update-profile-form\"\n    ng-submit=\"updateProfileModal.updateProfile(tocUpdateProfileForm)\"\n    novalidate>\n  <ion-header-bar class=\"bar-positive\">\n    <h1 class=\"title\">Update Profile</h1>\n  </ion-header-bar>\n  <ion-content class=\"has-subfooter\">\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm item-clear\">\n        What would you like to change?\n      </div>\n      <div class=\"item item-avatar\">\n        <img alt=\"New avatar\" ng-src=\"{{updateProfileModal.getNewAvatar()}}\" />\n        <h2>{{updateProfileModal.userInfo.displayName || 'Anonymous'}}</h2>\n        <p>Your new user card</p>\n      </div>\n      <div class=\"item item-input item-stacked-label\">\n        <span class=\"input-label\">Your name</span>\n        <input type=\"text\" ng-model=\"updateProfileModal.userInfo.displayName\"\n          form=\"toc-update-profile-form\"\n          placeholder=\"Your friends will see this in their contact lists\">\n      </div>\n      <div class=\"item item-input item-stacked-label\">\n        <span class=\"input-label\">Your email</span>\n        <input type=\"email\" ng-model=\"updateProfileModal.userInfo.email\"\n          form=\"toc-update-profile-form\"\n          placeholder=\"Your avatar will be generated from this email\"\n          ng-model-options=\"{\n            updateOn: 'default blur',\n            debounce: { default: 1000, blur: 0}\n          }\">\n      </div>\n    </div>\n  </ion-content>\n  <div class=\"bar bar-subfooter\">\n    <div class=\"col\">\n      <button class=\"button button-block button-calm button-outline\"\n        ng-click=\"::updateProfileModal.openWindow(\n          'https://www.libravatar.org/'\n        )\">\n        Change your email avatar\n      </button>\n    </div>\n  </div>\n  <ion-footer-bar>\n    <div class=\"col\">\n      <button type=\"button\"\n        class=\"button button-block button-positive button-outline\"\n        ng-click=\"::updateProfileModal.removeModal()\">\n        Cancel\n      </button>\n    </div>\n    <div class=\"col\">\n      <button type=\"submit\" form=\"toc-update-profile-form\"\n        class=\"button button-block button-positive\">\n        Update\n      </button>\n    </div>\n  </ion-footer-bar>\n  </form>\n</ion-modal-view>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/update-profile-modal/update-profile-modal-directive.js', ['components/update-profile-modal/update-profile-modal.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocUpdateProfileModal);

  /*@ngInject*/
  function tocUpdateProfileModal() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        removeModal: '&'
      },
      controllerAs: 'updateProfileModal',
      controller: /*@ngInject*/function UpdateProfileModalController($scope, $q, $log, contacts, identity, notifications, navigation, state, R) {
        this.removeModal = $scope.removeModal;
        this.openWindow = navigation.openWindow;

        var userInfo = state.cloud.identity.get(['userInfo']);
        this.userInfo = R.assoc('version', userInfo.version + 1, userInfo);

        this.getNewAvatar = function getNewAvatar() {
          return identity.getAvatar(this.userInfo);
        };

        this.updateProfile = function updateProfile(updateProfileForm) {
          var _this = this;

          if (updateProfileForm.$invalid) {
            if (updateProfileForm.$error.email) {
              return notifications.notifySystem('Please enter a valid email.');
            }

            return notifications.notifyGenericError(updateProfileForm.$error);
          }

          return state.save(state.cloud.identity, ['userInfo'], this.userInfo).then(function () {
            return contacts.saveProfileUpdates();
          }).then(function () {
            _this.removeModal();
            return $q.when();
          })['catch'](notifications.notifyGenericError);
        };
      }
    };
  }

  return {
    setters: [function (_componentsUpdateProfileModalUpdateProfileModalHtmlGithubSystemjsPluginText002) {
      template = _componentsUpdateProfileModalUpdateProfileModalHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocUpdateProfileModal';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/update-profile-modal/update-profile-modal.js', ['github:angular/bower-angular@1.4.7', 'components/update-profile-modal/update-profile-modal-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsUpdateProfileModalUpdateProfileModalDirectiveJs) {
      directive = _componentsUpdateProfileModalUpdateProfileModalDirectiveJs['default'];
      directiveName = _componentsUpdateProfileModalUpdateProfileModalDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.update-profile-modal', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/begin-conversation-modal/begin-conversation-modal.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-positive\">\n    <h1 class=\"title\">Start a Conversation</h1>\n  </ion-header-bar>\n  <ion-content class=\"has-subfooter\">\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm item-clear\">\n        How would you like to start?\n      </div>\n      <ion-radio class=\"item-icon-left\"\n        ng-repeat=\"(id, inviteMethod) in ::beginConversationModal.inviteMethods\n          track by id\"\n        ng-model=\"beginConversationModal.inviteMethod\"\n        ng-value=\"::id\" ng-if=\"::inviteMethod.isEnabled\">\n        <i class=\"icon\" ng-class=\"::inviteMethod.icon\"></i>\n        {{::inviteMethod.text}}\n      </ion-radio>\n    </div>\n  </ion-content>\n  <div class=\"bar bar-subfooter\">\n    <div class=\"col\">\n      <button type=\"button\" ng-click=\"::beginConversationModal.showIdPopup()\"\n        class=\"button button-block button-calm button-outline\">\n        Display your ID\n      </button>\n    </div>\n  </div>\n  <ion-footer-bar>\n    <div class=\"col\">\n      <button class=\"button button-block button-positive button-outline\"\n        ng-click=\"::beginConversationModal.removeModal()\">\n        Cancel\n      </button>\n    </div>\n    <div class=\"col\">\n      <button class=\"button button-block button-positive\"\n        ng-click=\"::beginConversationModal.doInvite()\">\n        Start\n      </button>\n    </div>\n  </ion-footer-bar>\n</ion-modal-view>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/begin-conversation-modal/begin-conversation-modal-directive.js', ['components/begin-conversation-modal/begin-conversation-modal.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocBeginConversationModal);

  /*@ngInject*/
  function tocBeginConversationModal() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        removeModal: '&'
      },
      controllerAs: 'beginConversationModal',
      controller: /*@ngInject*/function BeginConversationModalController($ionicPopup, $log, $q, $window, $scope, contacts, navigation, notifications, devices, identity, state) {
        var _this = this;

        this.removeModal = $scope.removeModal;
        this.userInfo = state.cloud.identity.get().userInfo;
        this.userId = this.userInfo.id;
        this.isCordovaApp = devices.isCordovaApp();

        this.contactId = '';

        this.inviteMethod = 'enter';

        var handleInviteError = function handleInviteError(error) {
          if (error === 'contact: cannot invite self') {
            return notifications.notifySystem('Cannot invite self');
          }

          if (error === 'contact: contact already exists') {
            return notifications.notifySystem('This contact already exists');
          }

          if (error === 'contacts: qr reader cancelled' || error.message === 'contacts: qr reader cancelled') {
            return notifications.notifySystem('QR reader ran into a problem. Please try again.');
          }

          return notifications.notifyGenericError(error);
        };

        this.sendInvite = function (event) {
          if (!identity.validateId(_this.contactId)) {
            if (event) {
              event.preventDefault();
            }
            return notifications.notifySystem('Please enter a valid Toc ID.');
          }

          return contacts.saveSendingInvite(_this.contactId).then(function () {
            _this.removeModal();
            _this.contactId = '';
            return $q.when();
          })['catch'](handleInviteError);
        };

        this.inviteMethods = {
          'enter': {
            icon: 'ion-ios-compose',
            text: 'Enter someone\'s ID',
            isEnabled: true,
            doInvite: function doInvite() {
              var invitePopup = $ionicPopup.show({
                template: '\n                <form ng-submit="beginConversationModal.sendInvite()"\n                  novalidate>\n                <input type="text" placeholder="Your contact\'s user ID."\n                  ng-model="beginConversationModal.contactId" toc-auto-focus>\n                </form>\n              ',
                title: 'Enter ID',
                scope: $scope,
                buttons: [{
                  text: 'Cancel',
                  type: 'button-positive button-block button-outline'
                }, {
                  text: 'Invite',
                  type: 'button-positive button-block',
                  onTap: function onTap(event) {
                    return _this.sendInvite(event);
                  }
                }]
              });
            }
          },
          'scan': {
            icon: 'ion-camera',
            text: 'Scan a picture ID',
            isEnabled: this.isCordovaApp,
            doInvite: function doInvite() {
              var barcodeScanner = $window.cordova.plugins.barcodeScanner;
              if (_this.isCordovaApp && barcodeScanner) {
                var _ret = (function () {
                  var scanningBarcode = $q.defer();

                  barcodeScanner.scan(function (barcodeData) {
                    return scanningBarcode.resolve(barcodeData);
                  }, function (error) {
                    return scanningBarcode.reject(error);
                  });

                  return {
                    v: scanningBarcode.promise.then(function (barcodeData) {
                      if (barcodeData.cancelled) {
                        throw new Error('contacts: qr reader cancelled');
                      }
                      var contactId = barcodeData.text;
                      if (!identity.validateId(contactId)) {
                        return notifications.notifySystem('Please enter a valid Toc ID.');
                      }

                      return contacts.saveSendingInvite(contactId);
                    }).then(function () {
                      _this.removeModal();
                      return $q.when();
                    })['catch'](handleInviteError)
                  };
                })();

                if (typeof _ret === 'object') return _ret.v;
              }
            }
          },
          'email': {
            icon: 'ion-email',
            text: 'Send an invite email',
            isEnabled: true,
            doInvite: function doInvite() {
              var mailSubject = encodeURIComponent('An invite for Toc Messenger');

              var mailBody = encodeURIComponent('Join me on Toc Messenger!\n' + ('http://toc.im/?inviteid=' + _this.userId + '\n'));

              navigation.openWindow('mailto:?to=&body=' + mailBody + '&subject=' + mailSubject);

              _this.removeModal();
            }
          },
          'share': {
            icon: 'ion-share',
            text: 'Share an invite post',
            isEnabled: true,
            doInvite: function doInvite() {
              var modalTemplate = '\n              <toc-invite-post-modal class="toc-modal-container"\n                remove-modal="beginConversationModal.invitePostModal.remove()">\n              </toc-invite-post-modal>\n            ';

              var modalName = 'invitePostModal';

              return navigation.showModal(modalName, modalTemplate, _this, $scope);
            }
          }
        };

        this.doInvite = function () {
          _this.inviteMethods[_this.inviteMethod].doInvite();
        };

        this.showIdPopup = function () {
          $ionicPopup.show({
            title: 'Your ID',
            cssClass: 'toc-id-popup',
            scope: $scope,
            buttons: [{
              text: 'Done',
              type: 'button-positive button-block'
            }],
            template: '<toc-id-display></toc-id-display>'
          });
        };
      }
    };
  }

  return {
    setters: [function (_componentsBeginConversationModalBeginConversationModalHtmlGithubSystemjsPluginText002) {
      template = _componentsBeginConversationModalBeginConversationModalHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocBeginConversationModal';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/begin-conversation-modal/begin-conversation-modal.js', ['github:angular/bower-angular@1.4.7', 'components/begin-conversation-modal/begin-conversation-modal-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsBeginConversationModalBeginConversationModalDirectiveJs) {
      directive = _componentsBeginConversationModalBeginConversationModalDirectiveJs['default'];
      directiveName = _componentsBeginConversationModalBeginConversationModalDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.begin-conversation-modal', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/password-prompt-modal/password-prompt-modal.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-modal-view>\n  <form name=\"tocPasswordPromptForm\" id=\"toc-password-prompt-form\"\n    ng-submit=\"passwordPromptModal.begin(tocPasswordPromptForm)\" novalidate>\n  <ion-header-bar class=\"bar-positive\">\n    <h1 class=\"title\">\n      {{\n        passwordPromptModal.userExists ?\n          'Welcome Back to Toc Messenger' :\n          'Welcome to Toc Messenger'\n      }}\n    </h1>\n  </ion-header-bar>\n  <ion-content class=\"has-subfooter\">\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm\">\n        {{\n          passwordPromptModal.userExists ?\n            'Nice to see you again!' :\n            'First time using Toc?'\n        }}\n      </div>\n      <label class=\"item item-input item-floating-label\">\n        <span class=\"input-label\">\n          Enter your password\n        </span>\n        <input type=\"password\" form=\"toc-password-prompt-form\"\n          placeholder=\"{{\n            passwordPromptModal.userExists ?\n              'A password is all you need to continue' :\n              'A password is all you need to get started'\n          }}\"\n          ng-model=\"passwordPromptModal.password\" toc-auto-focus required>\n      </label>\n      <label class=\"item item-input item-floating-label\"\n        ng-if=\"!passwordPromptModal.userExists\">\n        <span class=\"input-label\">\n          Verify your password\n        </span>\n        <input type=\"password\" form=\"toc-password-prompt-form\"\n          placeholder=\"Enter it one more time, just in case\"\n          toc-equal-to=\"passwordPromptModal.password\"\n          ng-model=\"passwordPromptModal.passwordConfirm\" required>\n      </label>\n      <ion-toggle ng-model=\"passwordPromptModal.staySignedIn\"\n        form=\"toc-password-prompt-form\"\n        toggle-class=\"toggle-calm\" class=\"toc-stay-signed-in-toggle\">\n        Remain signed in next time?\n        <span class=\"item-note\">\n          {{\n            passwordPromptModal.staySignedIn ?\n              'We\\'ll remember you until you sign out' :\n              'We\\'ll ask for your password again'\n          }}\n        </span>\n      </ion-toggle>\n    </div>\n  </ion-content>\n  <div class=\"bar bar-subfooter\">\n    <div class=\"col\">\n      <button type=\"button\"\n        ng-click=\"passwordPromptModal.showCloudConnectModal()\"\n        class=\"button button-block button-calm button-outline\">\n        <!-- TODO: connect to different account if already connected -->\n        {{\n          passwordPromptModal.userExists ?\n            'Sync your profile' :\n            'Sync an online profile'\n        }}\n      </button>\n    </div>\n  </div>\n  <ion-footer-bar>\n    <div class=\"col\">\n      <button type=\"submit\" form=\"toc-password-prompt-form\"\n        class=\"button button-block button-positive\">\n        {{\n          passwordPromptModal.userExists ?\n            'Let\\'s continue!' :\n            'Let\\'s get started!'\n        }}\n      </button>\n    </div>\n  </ion-footer-bar>\n  </form>\n</ion-modal-view>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/password-prompt-modal/password-prompt-modal-directive.js', ['components/password-prompt-modal/password-prompt-modal.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocPasswordPromptModal);

  /*@ngInject*/
  function tocPasswordPromptModal() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        showModal: '&',
        hideModal: '&',
        removeModal: '&'
      },
      controllerAs: 'passwordPromptModal',
      controller: /*@ngInject*/function PasswordPromptModalController($scope, $ionicLoading, $ionicModal, $log, $timeout, $window, $q, session, navigation, notifications, identity, state) {
        var _this = this;

        this.removeModal = $scope.removeModal;
        this.hideModal = $scope.hideModal;
        this.showModal = $scope.showModal;

        var userExistsCursor = state.cloudUnencrypted.cryptography;
        var updateUserExists = function updateUserExists() {
          _this.userExists = userExistsCursor.get() !== undefined;
        };
        state.addListener(userExistsCursor, updateUserExists, $scope);

        var staySignedIn = state.local.session.get(['staySignedIn']);
        this.staySignedIn = staySignedIn === undefined ? true : staySignedIn;

        this.begin = function begin(passwordPromptForm) {
          var _this2 = this;

          if (passwordPromptForm.$invalid) {
            if (passwordPromptForm.$error.required && passwordPromptForm.$error.required[1]) {
              return notifications.notifySystem('Please enter a password.');
            }
            if (passwordPromptForm.$error.equalTo) {
              return notifications.notifySystem('Please ensure your passwords match.');
            }
            if (passwordPromptForm.$error.required) {
              return notifications.notifySystem('Please enter a password.');
            }

            return notifications.notifyGenericError(passwordPromptForm.$error);
          }

          var updateStaySignedIn = function updateStaySignedIn() {
            return staySignedIn === _this2.staySignedIn ? $q.when() : state.save(state.local.session, ['staySignedIn'], _this2.staySignedIn);
          };

          $window.tocResumeLoadingAnimation();
          return this.hideModal().then(function () {
            return session.start({ password: _this2.password }, _this2.staySignedIn);
          }).then(function () {
            return _this2.removeModal();
          })['catch'](function (error) {
            _this2.showModal().then(function () {
              return $window.tocPauseLoadingAnimation();
            });
            var showErrorMessage = function showErrorMessage() {
              if (error === 'identity: wrong password') {
                return notifications.notifySystem('The password you entered was incorrect.');
              }

              return notifications.notifyGenericError(error);
            };

            return $timeout(showErrorMessage, 1000, false);
          });
        };

        this.showCloudConnectModal = function showCloudConnectModal() {
          var modalTemplate = '\n          <toc-cloud-connect-modal class="toc-modal-container"\n            remove-modal="passwordPromptModal.cloudConnectModal.remove()">\n          </toc-cloud-connect-modal>\n        ';

          var modalName = 'cloudConnectModal';

          return navigation.showModal(modalName, modalTemplate, this, $scope);
        };
      }
    };
  }

  return {
    setters: [function (_componentsPasswordPromptModalPasswordPromptModalHtmlGithubSystemjsPluginText002) {
      template = _componentsPasswordPromptModalPasswordPromptModalHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocPasswordPromptModal';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/password-prompt-modal/password-prompt-modal.js', ['github:angular/bower-angular@1.4.7', 'components/password-prompt-modal/password-prompt-modal-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsPasswordPromptModalPasswordPromptModalDirectiveJs) {
      directive = _componentsPasswordPromptModalPasswordPromptModalDirectiveJs['default'];
      directiveName = _componentsPasswordPromptModalPasswordPromptModalDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.password-prompt-modal', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/channel-card/channel-card.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"toc-channel-card item item-avatar\" ng-class=\"{\n    'toc-channel-pending': channelCard.contact.statusId === -1\n  }\">\n  <img class=\"toc-channel-card-avatar\"\n    ng-src=\"{{channelCard.getAvatar(channelCard.contact.userInfo)}}\">\n  </img>\n  <div class=\"toc-channel-card-status-indicator\"\n    ng-class=\"channelCard.status\">\n  </div>\n  <h2>{{channelCard.contact.userInfo.displayName || 'Anonymous'}}</h2>\n  <p class=\"toc-channel-card-quote\" ng-class=\"{\n      'toc-channel-card-quote-unread': channelCard.channel.unreadMessageId\n    }\">\n    {{channelCard.quote}}\n  </p>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/channel-card/channel-card-directive.js', ['components/channel-card/channel-card.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocChannelCard);

  /*@ngInject*/
  function tocChannelCard() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        channelId: '@'
      },
      controllerAs: 'channelCard',
      controller: /*@ngInject*/function ChannelCardController($scope, identity, state) {
        var _this = this;

        this.getAvatar = identity.getAvatar;
        this.channelId = $scope.channelId;

        var channelCursor = state.cloud.channels.select([this.channelId]);
        var messagesCursor = state.cloud.messages.select([this.channelId]);
        var contactCursor = state.cloud.contacts;

        var updateContact = function updateContact() {
          _this.contact = contactCursor.get(_this.channel.channelInfo.contactIds[0]);
          updateStatus();
        };

        var updateStatus = function updateStatus() {
          if (_this.contact.statusId === -1) {
            _this.status = 'toc-contact-status-pending';
            return;
          }

          if (_this.contact.statusId === 0) {
            _this.status = 'toc-contact-status-offline';
            return;
          }

          if (_this.contact.statusId === 1) {
            _this.status = 'toc-contact-status-online';
            return;
          }

          _this.status = 'toc-contact-status-unknown';
        };

        var updateQuote = function updateQuote() {
          if (_this.channel.inviteStatus === 'accepting') {
            _this.quote = 'Accepting invite';
            return;
          }

          if (_this.channel.inviteStatus === 'sending') {
            _this.quote = 'Sending invite';
            return;
          }

          if (_this.channel.inviteStatus === 'sent') {
            _this.quote = 'Sent invite';
            return;
          }

          if (_this.channel.inviteStatus === 'received') {
            _this.quote = 'Received invite';
            return;
          }

          if (_this.channel.unreadMessageId) {
            _this.quote = messagesCursor.get(_this.channel.unreadMessageId).messageInfo.content;
            return;
          }

          if (_this.channel.latestMessageId) {
            _this.quote = messagesCursor.get(_this.channel.latestMessageId).messageInfo.content;
            return;
          }

          _this.quote = 'No new messages';
        };

        var updateChannel = function updateChannel() {
          _this.channel = channelCursor.get();
          updateContact();
          updateQuote();
        };

        state.addListener(channelCursor, updateChannel, $scope);
        state.addListener(contactCursor, updateContact, $scope);
      }
    };
  }

  return {
    setters: [function (_componentsChannelCardChannelCardHtmlGithubSystemjsPluginText002) {
      template = _componentsChannelCardChannelCardHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocChannelCard';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/channel-card/channel-card.js', ['github:angular/bower-angular@1.4.7', 'components/channel-card/channel-card-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsChannelCardChannelCardDirectiveJs) {
      directive = _componentsChannelCardChannelCardDirectiveJs['default'];
      directiveName = _componentsChannelCardChannelCardDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.channel-card', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/channel-list/channel-list.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-list>\n  <toc-channel-card channel-id=\"{{::id}}\"\n    ng-repeat=\"(id, channel) in channelList.channels track by id\"\n    ng-class=\"{'toc-active-view': channelList.viewId === id}\"\n    ng-click=\"channelList.handleClick(channel)\" menu-close>\n  </toc-channel-card>\n</ion-list>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/channel-list/channel-list-directive.js', ['components/channel-list/channel-list.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocChannelList);

  /*@ngInject*/
  function tocChannelList() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'channelList',
      controller: /*@ngInject*/function ChannelListController($ionicHistory, $ionicPopup, $q, $scope, $state, contacts, identity, navigation, state) {
        var _this = this;

        var viewIdCursor = state.cloud.navigation.select(['activeViewId']);
        var updateViewId = function updateViewId() {
          _this.viewId = viewIdCursor.get();
        };
        state.addListener(viewIdCursor, updateViewId, $scope);

        var channelsCursor = state.cloud.channels;
        var updateChannels = function updateChannels() {
          _this.channels = channelsCursor.get();
        };
        state.addListener(channelsCursor, updateChannels, $scope);

        var contactsCursor = state.cloud.contacts;
        var updateContacts = function updateContacts() {
          _this.contacts = contactsCursor.get();
        };
        state.addListener(contactsCursor, updateContacts, $scope);

        this.handleClick = function handleChannelClick(channel) {
          if (channel.inviteStatus === 'sent' || channel.inviteStatus === 'sending' || channel.inviteStatus === 'accepting') {
            return;
          }

          if (channel.inviteStatus === 'received') {
            return contacts.showAcceptInviteDialog(channel.channelInfo.id);
          }

          return navigation.navigate(channel.channelInfo.id);
        };

        this.goToChannel = function goToChannel(channelId) {
          return navigation.navigate(channelId);
        };
      }
    };
  }

  return {
    setters: [function (_componentsChannelListChannelListHtmlGithubSystemjsPluginText002) {
      template = _componentsChannelListChannelListHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocChannelList';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/channel-list/channel-list.js', ['github:angular/bower-angular@1.4.7', 'components/channel-list/channel-list-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsChannelListChannelListDirectiveJs) {
      directive = _componentsChannelListChannelListDirectiveJs['default'];
      directiveName = _componentsChannelListChannelListDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.channel-list', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/cloud-connect-modal/cloud-connect-modal.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-positive\">\n    <h1 class=\"title\">Connect a Storage Service</h1>\n  </ion-header-bar>\n  <ion-content class=\"has-subfooter\">\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm item-clear\">\n        Which service would you prefer?\n      </div>\n      <ion-radio class=\"item item-avatar toc-square-avatar toc-cloud-service-item\"\n        ng-repeat=\"(id, service) in ::cloudConnectModal.services track by id\"\n        ng-model=\"cloudConnectModal.selectedService\" ng-value=\"::id\">\n        <img ng-src=\"{{::service.image}}\"\n          alt=\"Icon for {{::service.name}}\" />\n        <h2>{{::service.name}}</h2>\n        <p>{{::service.description}}</p>\n      </ion-radio>\n    </div>\n  </ion-content>\n  <div class=\"bar bar-subfooter\">\n    <div class=\"col\">\n      <button class=\"button button-block button-calm button-outline\"\n        ng-click=\"::cloudConnectModal.openWindow(\n          'https://remotestorage.io/get/'\n        )\">\n        Get a storage account\n      </button>\n    </div>\n  </div>\n  <ion-footer-bar>\n    <div class=\"col\">\n      <button class=\"button button-block button-positive button-outline\"\n        ng-click=\"::cloudConnectModal.removeModal()\">\n        Cancel\n      </button>\n    </div>\n    <div class=\"col\">\n      <button class=\"button button-block button-positive\"\n        ng-click=\"::cloudConnectModal.connect()\">\n        Connect\n      </button>\n    </div>\n  </ion-footer-bar>\n</ion-modal-view>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/cloud-connect-modal/cloud-connect-modal-directive.js', ['components/cloud-connect-modal/cloud-connect-modal.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocCloudConnectModal);

  /*@ngInject*/
  function tocCloudConnectModal() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        removeModal: '&'
      },
      controllerAs: 'cloudConnectModal',
      controller: /*@ngInject*/function CloudConnectModalController($ionicPopup, $scope, $q, identity, navigation, notifications, storage, state) {
        var _this = this;

        this.removeModal = $scope.removeModal;
        this.openWindow = navigation.openWindow;

        this.selectedService = 'remotestorage';
        var userExistsCursor = state.cloudUnencrypted.cryptography;
        var updateUserExists = function updateUserExists() {
          _this.userExists = userExistsCursor.get() !== undefined;
        };
        state.addListener(userExistsCursor, updateUserExists, $scope);

        this.remoteStorageEmail = '';

        this.services = storage.SERVICES;

        var showExistingAccountPrompt = function showExistingAccountPrompt() {
          if (!_this.userExists) {
            return $q.when(true);
          }
          return $ionicPopup.confirm({
            title: 'Preparing to Sync Data',
            template: '\n              <p>Please ensure this storage account doesn\'t contain any data from a different Toc account.</p>\n            ',
            cancelType: 'button-block button-positive button-outline',
            okText: 'Sync',
            okType: 'button-block button-positive'
          });
        };

        this.connect = function () {
          switch (_this.selectedService) {
            case _this.services.remotestorage.id:
              var remoteStoragePopup = $ionicPopup.show({
                template: '\n                <form ng-submit="cloudConnectModal.submitRemoteStorageEmail()"\n                  novalidate>\n                  <input type="email" placeholder="Your remoteStorage email."\n                    ng-model="cloudConnectModal.remoteStorageEmail" toc-auto-focus>\n                </form>\n                ',
                title: 'Connect remoteStorage',
                scope: $scope,
                buttons: [{
                  text: 'Cancel',
                  type: 'button-block button-positive button-outline'
                }, {
                  text: 'Connect',
                  type: 'button-block button-positive',
                  onTap: function onTap(event) {
                    _this.submitRemoteStorageEmail(event);
                  }
                }]
              });
              break;
            // case this.services.dropbox.id:
            //   return showExistingAccountPrompt()
            //     .then((response) => {
            //       if (!response) {
            //         return;
            //       }
            //       let connectOptions = {
            //         serviceId: this.services.dropbox.id
            //       };
            //
            //       return storage.connect(connectOptions)
            //         .catch(notifications.notifyGenericError);
            //     });
            //   break;
            // case this.services.googledrive.id:
            //   return showExistingAccountPrompt()
            //     .then((response) => {
            //       if (!response) {
            //         return;
            //       }
            //       let connectOptions = {
            //         serviceId: this.services.googledrive.id
            //       };
            //
            //       return storage.connect(connectOptions)
            //         .catch(notifications.notifyGenericError);
            //     });
            //   break;
          }
        };

        this.submitRemoteStorageEmail = function (event) {
          if (!_this.remoteStorageEmail) {
            if (event) {
              event.preventDefault();
            }

            //validation is already done by angular form's email input
            // email will be undefined if it didn't pass validation
            return notifications.notifySystem('Please enter a valid email.');
          }

          showExistingAccountPrompt().then(function (response) {
            if (!response) {
              return;
            }
            var connectOptions = {
              serviceId: _this.services.remotestorage.id,
              email: _this.remoteStorageEmail
            };

            return storage.connect(connectOptions)['catch'](notifications.notifyGenericError);
          });
        };
      }
    };
  }

  return {
    setters: [function (_componentsCloudConnectModalCloudConnectModalHtmlGithubSystemjsPluginText002) {
      template = _componentsCloudConnectModalCloudConnectModalHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocCloudConnectModal';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/cloud-connect-modal/cloud-connect-modal.js', ['github:angular/bower-angular@1.4.7', 'components/cloud-connect-modal/cloud-connect-modal-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsCloudConnectModalCloudConnectModalDirectiveJs) {
      directive = _componentsCloudConnectModalCloudConnectModalDirectiveJs['default'];
      directiveName = _componentsCloudConnectModalCloudConnectModalDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.cloud-connect-modal', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/invite-post-modal/invite-post-modal.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-positive\">\n    <h1 class=\"title\">Share an Invite Post</h1>\n  </ion-header-bar>\n  <ion-content>\n    <div class=\"list\">\n      <div class=\"item item-divider item-calm item-clear\">\n        Where would you like to share it?\n      </div>\n      <ion-radio class=\"item-icon-left\"\n        ng-repeat=\"(id, shareMethod) in ::invitePostModal.shareMethods\n          track by id\"\n        ng-model=\"invitePostModal.shareMethod\"\n        ng-value=\"::id\" ng-if=\"::shareMethod.isEnabled\">\n        <i class=\"icon\" ng-class=\"::shareMethod.icon\"></i>\n        {{::shareMethod.text}}\n      </ion-radio>\n    </div>\n  </ion-content>\n  <ion-footer-bar>\n    <div class=\"col\">\n      <button class=\"button button-block button-positive button-outline\"\n        ng-click=\"::invitePostModal.removeModal()\">\n        Cancel\n      </button>\n    </div>\n    <div class=\"col\">\n      <button class=\"button button-block button-positive\"\n        ng-click=\"::invitePostModal.doShare()\">\n        Share\n      </button>\n    </div>\n  </ion-footer-bar>\n</ion-modal-view>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/invite-post-modal/invite-post-modal-directive.js', ['components/invite-post-modal/invite-post-modal.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocInvitePostModal);

  /*@ngInject*/
  function tocInvitePostModal() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        removeModal: '&'
      },
      controllerAs: 'invitePostModal',
      controller: /*@ngInject*/function InvitePostModalController($scope, $window, navigation, state) {
        var _this = this;

        this.removeModal = $scope.removeModal;

        this.shareMethod = 'email';

        this.userInfo = state.cloud.identity.get().userInfo;
        this.userId = this.userInfo.id;

        this.shareMethods = {
          'facebook': {
            icon: 'ion-social-facebook',
            text: 'Share an invite using Facebook',
            isEnabled: true,
            doShare: function doShare() {
              navigation.openWindow('http://www.facebook.com/share.php?u=' + ('http://toc.im/?inviteid=' + _this.userId));
              _this.removeModal();
            }
          },
          'googleplus': {
            icon: 'ion-social-googleplus',
            text: 'Share an invite using Google+',
            isEnabled: true,
            doShare: function doShare() {
              navigation.openWindow('https://plus.google.com/share?url=' + ('http://toc.im/?inviteid=' + _this.userId));
              _this.removeModal();
            }
          }
        };

        this.doShare = function () {
          _this.shareMethods[_this.shareMethod].doShare();
        };
      }
    };
  }

  return {
    setters: [function (_componentsInvitePostModalInvitePostModalHtmlGithubSystemjsPluginText002) {
      template = _componentsInvitePostModalInvitePostModalHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocInvitePostModal';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/invite-post-modal/invite-post-modal.js', ['github:angular/bower-angular@1.4.7', 'components/invite-post-modal/invite-post-modal-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsInvitePostModalInvitePostModalDirectiveJs) {
      directive = _componentsInvitePostModalInvitePostModalDirectiveJs['default'];
      directiveName = _componentsInvitePostModalInvitePostModalDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.invite-post-modal', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/id-display/id-display.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"list\">\n  <div class=\"item item-image\">\n    <toc-qr-image data=\"{{::idDisplay.userId}}\">\n    </toc-qr-image>\n  </div>\n  <label class=\"toc-id-input item item-input\">\n    <input type=\"text\" ng-model=\"::idDisplay.userId\"\n      readonly toc-auto-select notify-copied=\"true\">\n  </label>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/id-display/id-display-directive.js', ['components/id-display/id-display.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocIdDisplay);

  /*@ngInject*/
  function tocIdDisplay(state) {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'idDisplay',
      controller: /*@ngInject*/function IdDisplayController() {
        this.userId = state.cloud.identity.get(['userInfo', 'id']);
      },
      link: function linkIdDisplay(scope, element, attrs) {
        // FIXME: I still don't know why .find doesn't work
        var qrImage = element.children().children().children()[0];
        var idInput = element.children().children().children()[1];

        angular.element(qrImage).bind('click', function (event) {
          angular.element(idInput).triggerHandler('click');
        });
      }
    };
  }

  return {
    setters: [function (_componentsIdDisplayIdDisplayHtmlGithubSystemjsPluginText002) {
      template = _componentsIdDisplayIdDisplayHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocIdDisplay';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/id-display/id-display.js', ['github:angular/bower-angular@1.4.7', 'components/id-display/id-display-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsIdDisplayIdDisplayDirectiveJs) {
      directive = _componentsIdDisplayIdDisplayDirectiveJs['default'];
      directiveName = _componentsIdDisplayIdDisplayDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.id-display', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/message-input-area/message-input-area.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<form class=\"toc-message-input-form\"\n  id=\"toc-message-input-form-{{::messageInputArea.channelId}}\"\n  ng-submit=\"::messageInputArea.send()\" novalidate>\n  <div class=\"toc-message-input-field-container\">\n    <input class=\"toc-message-input-field\" type=\"text\" placeholder=\"Message\"\n      form=\"toc-message-input-form-{{::messageInputArea.channelId}}\"\n      ng-model=\"messageInputArea.message\" ng-trim=\"false\"\n      toc-auto-focus required>\n    </input>\n  </div>\n  <div class=\"toc-message-input-send-container\">\n    <button type=\"submit\"\n      form=\"toc-message-input-form-{{::messageInputArea.channelId}}\"\n      class=\"button button-block button-positive\">\n      Send\n    </button>\n  </div>\n</form>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/message-input-area/message-input-area-directive.js', ['components/message-input-area/message-input-area.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocMessageInputArea);

  /*@ngInject*/
  function tocMessageInputArea() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        channelId: '@'
      },
      controllerAs: 'messageInputArea',
      controller: /*@ngInject*/function MessageInputAreaController($scope, messages) {
        var _this = this;

        this.channelId = $scope.channelId;

        this.message = '';

        this.send = function () {
          var message = _this.message;
          _this.message = '';

          return messages.saveSendingMessage(_this.channelId, message);
        };
      }
    };
  }

  return {
    setters: [function (_componentsMessageInputAreaMessageInputAreaHtmlGithubSystemjsPluginText002) {
      template = _componentsMessageInputAreaMessageInputAreaHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocMessageInputArea';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/message-input-area/message-input-area.js', ['github:angular/bower-angular@1.4.7', 'components/message-input-area/message-input-area-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsMessageInputAreaMessageInputAreaDirectiveJs) {
      directive = _componentsMessageInputAreaMessageInputAreaDirectiveJs['default'];
      directiveName = _componentsMessageInputAreaMessageInputAreaDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.message-input-area', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/message-list/message-list.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"toc-message-list list\">\n  <div class=\"toc-message item item-avatar\"\n    ng-repeat=\"message in messageList.messages track by message.messageInfo.id\"\n    ng-class=\"{\n      'toc-message-avatar': messageList.isSenderSeparator(message),\n      'toc-message-simple': !messageList.isSenderSeparator(message),\n      'toc-message-user': messageList.isByUser(message),\n      'toc-message-contact': !messageList.isByUser(message)\n    }\">\n    <img ng-src=\"{{messageList.getAvatar(message)}}\"\n      alt=\"Avatar for {{messageList.getUserInfo(message).email}}\"\n      ng-if=\"messageList.isSenderSeparator(message)\" />\n    <div ng-if=\"messageList.isUnread(message)\"\n      class=\"toc-message-unread\">\n      <div class=\"toc-message-unread-marker\">\n      </div>\n    </div>\n    <div ng-if=\"messageList.isDateSeparator(message)\"\n      class=\"toc-message-datestamp\" toc-auto-select>\n      {{::messageList.getDatestamp(message)}}\n    </div>\n    <h2 toc-auto-select>\n      {{messageList.getUserInfo(message).displayName || 'Anonymous'}}\n    </h2>\n    <p class=\"toc-message-content\" toc-auto-select>\n      {{::message.messageInfo.content}}\n    </p>\n    <div ng-if=\"messageList.isMinuteSeparator(message)\"\n      ng-hide=\"messageList.isMessageSending(message)\"\n      class=\"toc-message-timestamp\" toc-auto-select>\n      {{::messageList.getTimestamp(message)}}\n    </div>\n    <div class=\"toc-message-sending-indicator\"\n      ng-if=\"messageList.isMessageSending(message)\">\n      ...\n    </div>\n  </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/message-list/message-list-directive.js', ['components/message-list/message-list.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocMessageList);

  /*@ngInject*/
  function tocMessageList($ionicScrollDelegate, $interval, devices, navigation, notifications, state, R) {
    return {
      restrict: 'E',
      template: template,
      scope: {
        channelId: '@'
      },
      link: function link(scope, element, attributes) {
        //workaround for dynamic delegate-handle on ion-content not working
        var scrollDelegate = R.find(function (delegateInstance) {
          return element.parent().parent()[0] === delegateInstance.element;
        })($ionicScrollDelegate._instances);

        var messagesCursor = state.cloud.messages.select([scope.channelId]);
        var channelCursor = state.cloud.channels.select([scope.channelId]);

        var viewingLatestCursor = channelCursor.select(['viewingLatest']);
        if (viewingLatestCursor.get()) {
          scrollDelegate.scrollBottom(true);
        }

        var scrollToLatest = function scrollToLatest() {
          if (!viewingLatestCursor.get() || !devices.isInForeground() || !navigation.isActiveView(scope.channelId)) {
            return;
          }

          scrollDelegate.scrollBottom(true);

          if (!notifications.isDismissed(scope.channelId)) {
            notifications.dismiss(scope.channelId);
          }

          if (channelCursor.get(['unreadMessageId'])) {
            state.save(channelCursor, ['unreadMessageId'], null);
          }
        };

        state.addListener(viewingLatestCursor, scrollToLatest, scope);

        var updateMessageListPosition = function updateMessageListPosition() {
          if (!navigation.isActiveView(scope.channelId) || !devices.isInForeground()) {
            return;
          }

          var scrollView = scrollDelegate.getScrollView();
          var scrollTop = scrollDelegate.getScrollPosition().top;
          var scrollMax = scrollView.getScrollMax().top;

          if (scrollTop < scrollMax) {
            return;
          }

          if (channelCursor.get(['unreadMessageId'])) {
            state.save(channelCursor, ['unreadMessageId'], null);
          }

          if (!channelCursor.get(['viewingLatest'])) {
            //changing viewingLatest will trigger scroll
            // don't need to trigger manually
            return state.save(channelCursor, ['viewingLatest'], true);
          }

          //otherwise scroll to bottom to see latest message
          scrollDelegate.scrollBottom(true);
        };

        state.addListener(messagesCursor, updateMessageListPosition, scope, {
          skipInitialize: true
        });

        $interval(function () {
          if (!navigation.isActiveView(scope.channelId) || !devices.isInForeground()) {
            return;
          }
          //Updates unread messages if scrolled to bottom
          //TODO: write a more robust version that moves unread marker granularly
          var scrollView = scrollDelegate.getScrollView();
          var scrollTop = scrollDelegate.getScrollPosition().top;
          var scrollMax = scrollView.getScrollMax().top;
          //Don't do anything if not scrolled to bottom
          if (scrollTop < scrollMax) {
            if (!channelCursor.get(['viewingLatest'])) {
              return;
            }

            return state.save(channelCursor, ['viewingLatest'], false);
          }

          //Otherwise update pointers and dismiss notification
          if (!channelCursor.get(['viewingLatest'])) {
            state.save(channelCursor, ['viewingLatest'], true);
          }

          if (channelCursor.get(['unreadMessageId'])) {
            state.save(channelCursor, ['unreadMessageId'], null);
          }

          if (!notifications.isDismissed(scope.channelId)) {
            notifications.dismiss(scope.channelId);
          }
        }, 5000, 0, false);
      },
      controllerAs: 'messageList',
      controller: /*@ngInject*/function MessageListController($scope, $state, identity, messages, time) {
        var _this = this;

        //TODO: refactor shared functionality into messages service
        //TODO: memoize what can be memoized
        this.getAvatar = identity.getAvatar;
        this.channelId = $scope.channelId;

        var messagesCursor = state.cloud.messages.select([this.channelId]);
        var channelCursor = state.cloud.channels.select([this.channelId]);

        var userCursor = state.cloud.identity.select(['userInfo']);
        var contactCursor = state.cloud.contacts.select([channelCursor.get(['channelInfo', 'contactIds'])[0], 'userInfo']);

        var updateUser = function updateUser() {
          _this.userInfo = userCursor.get();
        };
        var updateContact = function updateContact() {
          _this.contactInfo = contactCursor.get();
        };

        state.addListener(userCursor, updateUser, $scope);
        state.addListener(contactCursor, updateContact, $scope);

        var updateMessages = function updateMessages() {
          _this.messages = R.pipe(R.values, R.sort(messages.compareMessages))(messagesCursor.get());;
        };

        state.addListener(messagesCursor, updateMessages, $scope);

        this.isUnread = function (message) {
          var unreadMessageId = state.cloud.channels.get([_this.channelId, 'unreadMessageId']);

          return unreadMessageId === message.messageInfo.id;
        };

        this.isByUser = function (message) {
          if (!message) {
            return;
          }

          var senderId = message.messageInfo.senderId;

          return _this.userInfo.id === senderId;
        };

        this.isSenderSeparator = function (message) {
          var messageIndex = _this.messages.indexOf(message);
          var previousMessage = _this.messages[messageIndex - 1];

          if (!previousMessage) {
            return true;
          }

          var isSenderDifferent = message.messageInfo.senderId !== previousMessage.messageInfo.senderId;

          return isSenderDifferent;
        };

        this.isMinuteSeparator = function (message) {
          var messageIndex = _this.messages.indexOf(message);
          var previousMessage = _this.messages[messageIndex - 1];

          if (!previousMessage) {
            return true;
          }

          return time.isMinuteDifferent(message.messageInfo.sentTime, previousMessage.messageInfo.sentTime);
        };

        this.isMessageSending = function (message) {
          return message.receivedTime === undefined;
        };

        this.isDateSeparator = function (message) {
          var messageIndex = _this.messages.indexOf(message);
          var previousMessage = _this.messages[messageIndex - 1];

          if (!previousMessage) {
            return true;
          }

          if (_this.isUnread(message)) {
            return false;
          }

          return time.isDayDifferent(message.messageInfo.sentTime, previousMessage.messageInfo.sentTime);
        };

        this.getUserInfo = function (message) {
          if (!message) {
            return;
          }

          var senderId = message.messageInfo.senderId;

          if (_this.userInfo.id === senderId) {
            return _this.userInfo;
          }
          //FIXME: this wont work for group chats
          return _this.contactInfo;
        };

        this.getAvatar = function (message) {
          if (!message) {
            return;
          }

          return identity.getAvatar(_this.getUserInfo(message));
        };

        this.getTimestamp = function (message) {
          return time.getTimestamp(message.messageInfo.sentTime);
        };

        this.getDatestamp = function (message) {
          return time.getDatestamp(message.messageInfo.sentTime);
        };
      }
    };
  }

  return {
    setters: [function (_componentsMessageListMessageListHtmlGithubSystemjsPluginText002) {
      template = _componentsMessageListMessageListHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocMessageList';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/message-list/message-list.js', ['github:angular/bower-angular@1.4.7', 'components/message-list/message-list-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsMessageListMessageListDirectiveJs) {
      directive = _componentsMessageListMessageListDirectiveJs['default'];
      directiveName = _componentsMessageListMessageListDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.message-list', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/notification-card/notification-card.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-slide-box class=\"toc-notification-card-slidebox\"\n  delegate-handle=\"{{::notificationCard.notificationId}}\" show-pager=\"false\"\n  active-slide=\"1\" on-slide-changed=\"notificationCard.swipe()\">\n  <ion-slide>\n    <div class=\"toc-notification-card-swiped\"></div>\n  </ion-slide>\n  <ion-slide>\n    <div class=\"toc-notification-card item item-avatar\"\n      ng-click=\"notificationCard.click()\">\n      <img class=\"toc-notification-card-icon\"\n        ng-src=\"{{notificationCard.icon}}\">\n      </img>\n      <h2>{{notificationCard.title}}</h2>\n      <p class=\"toc-notification-card-message\">\n        {{notificationCard.message}}\n      </p>\n    </div>\n  </ion-slide>\n  <ion-slide>\n    <div class=\"toc-notification-card-swiped\"></div>\n  </ion-slide>\n</ion-slide-box>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/notification-card/notification-card-directive.js', ['components/notification-card/notification-card.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocNotificationCard);

  /*@ngInject*/
  function tocNotificationCard() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        notificationId: '@'
      },
      controllerAs: 'notificationCard',
      controller: /*@ngInject*/function NotificationCardController($scope, $ionicPopup, $timeout, $ionicSlideBoxDelegate, identity, contacts, navigation, notifications, state) {
        var _this = this;

        this.notificationId = $scope.notificationId;
        if (!this.notificationId) {
          return;
        }

        $timeout(function () {
          var slideBoxDelegate = $ionicSlideBoxDelegate.$getByHandle(_this.notificationId);

          _this.swipe = function () {
            return notifications.dismiss(_this.notificationId);
          };
        }, 0, false);

        var channelId = this.notificationId;
        var channelCursor = state.cloud.channels.select([channelId]);

        var messageIdCursor = channelCursor.select(['latestMessageId']);
        var updateMessage = function updateMessage() {
          if (channelCursor.get(['inviteStatus']) === 'received') {
            _this.message = 'New invite received!';
            return;
          }

          var messageId = messageIdCursor.get();
          if (!messageId) {
            return;
          }
          _this.message = state.cloud.messages.get([channelId, messageId, 'messageInfo', 'content']);
        };
        state.addListener(channelCursor, updateMessage, $scope);

        var contactId = channelCursor.get(['channelInfo', 'contactIds'])[0];
        var contactCursor = state.cloud.contacts.select(contactId);

        var contactInfoCursor = contactCursor.select(['userInfo']);
        var updateContactInfo = function updateContactInfo() {
          var contactInfo = contactInfoCursor.get();
          _this.icon = identity.getAvatar(contactInfo);
          _this.iconText = 'Avatar for ' + (contactInfo.displayName || 'Anonymous');
          _this.title = contactInfo.displayName || 'Anonymous';
        };
        state.addListener(contactInfoCursor, updateContactInfo, $scope);

        this.click = function () {
          if (channelCursor.get(['inviteStatus']) === 'received') {
            return contacts.showAcceptInviteDialog(channelId);
          }

          return navigation.navigate(channelId).then(function () {
            return state.save(channelCursor, ['viewingLatest'], true);
          });
        };
      }
    };
  }

  return {
    setters: [function (_componentsNotificationCardNotificationCardHtmlGithubSystemjsPluginText002) {
      template = _componentsNotificationCardNotificationCardHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocNotificationCard';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/notification-card/notification-card.js', ['github:angular/bower-angular@1.4.7', 'components/notification-card/notification-card-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsNotificationCardNotificationCardDirectiveJs) {
      directive = _componentsNotificationCardNotificationCardDirectiveJs['default'];
      directiveName = _componentsNotificationCardNotificationCardDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.notification-card', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/notification-list/notification-list.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"toc-notification-list list\">\n  <div class=\"toc-notification-list-item\"\n    ng-repeat=\"notification in notificationList.notifications track by notification.notificationInfo.id\">\n    <toc-notification-card\n      notification-id=\"{{::notification.notificationInfo.id}}\">\n    </toc-notification-card>\n  </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/notification-list/notification-list-directive.js', ['components/notification-list/notification-list.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocNotificationList);

  /*@ngInject*/
  function tocNotificationList() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'notificationList',
      controller: /*@ngInject*/function NotificationListController($scope, identity, navigation, state, R) {
        var _this = this;

        var notificationsCursor = state.cloud.notifications;
        var updateNotifications = function updateNotifications() {
          _this.notifications = R.pipe(R.values, R.reject(R.prop('dismissed')))(notificationsCursor.get() || {});
        };
        state.addListener(notificationsCursor, updateNotifications, $scope);
      }
    };
  }

  return {
    setters: [function (_componentsNotificationListNotificationListHtmlGithubSystemjsPluginText002) {
      template = _componentsNotificationListNotificationListHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocNotificationList';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/notification-list/notification-list.js', ['github:angular/bower-angular@1.4.7', 'components/notification-list/notification-list-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsNotificationListNotificationListDirectiveJs) {
      directive = _componentsNotificationListNotificationListDirectiveJs['default'];
      directiveName = _componentsNotificationListNotificationListDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.notification-list', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/notification-overlay/notification-overlay.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"bar bar-subheader toc-notification-overlay\"\n  ng-if=\"notificationOverlay.showNotificationOverlay\">\n  <toc-notification-card\n    notification-id=\"{{notificationOverlay.activeNotificationId}}\"\n    class=\"toc-notification-overlay-card\">\n  </toc-notification-card>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/notification-overlay/notification-overlay-directive.js', ['components/notification-overlay/notification-overlay.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocNotificationOverlay);

  /*@ngInject*/
  function tocNotificationOverlay() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'notificationOverlay',
      controller: /*@ngInject*/function NotificationOverlayController($scope, $timeout, $q, identity, navigation, notifications, state, R) {
        var _this = this;

        var notificationsCursor = state.cloud.notifications;

        var watchingNotifications = {};
        this.showNotificationOverlay = false;
        this.activeNotificationId = null;
        this.activeNotificationTimeout = null;

        var resetNotificationTimeout = function resetNotificationTimeout(delay) {
          if (_this.activeNotificationTimeout) {
            $timeout.cancel(_this.activeNotificationTimeout);
          }

          _this.activeNotificationTimeout = $timeout(function () {
            _this.showNotificationOverlay = false;
            _this.activeNotificationTimeout = null;
          }, delay);
        };

        var updateActiveNotification = function updateActiveNotification(event, notificationId) {
          if (!notificationId) {
            if (!event.data.currentData.notificationInfo) {
              return;
            }
            notificationId = event.data.currentData.notificationInfo.id;
          }

          if (notifications.isDismissed(notificationId)) {
            resetNotificationTimeout(0);
            return;
          }
          _this.activeNotificationId = notificationId;
          _this.showNotificationOverlay = true;
          resetNotificationTimeout(5000);
        };

        var isFirstRun = true;
        var updateListeners = function updateListeners() {
          //adds listeners for each new notificationId
          _this.notifications = R.pipe(R.keys, R.reject(R.has(R.__, watchingNotifications)), R.forEach(function (notificationId) {
            state.addListener(notificationsCursor.select([notificationId]), updateActiveNotification, $scope, { skipInitialize: true });
            watchingNotifications[notificationId] = true;
            // don't fire notifications on app init
            if (isFirstRun) {
              return;
            }
            updateActiveNotification(null, notificationId);
          }))(notificationsCursor.get() || {});

          isFirstRun = false;
        };
        state.addListener(notificationsCursor, updateListeners, $scope);
      }
    };
  }

  return {
    setters: [function (_componentsNotificationOverlayNotificationOverlayHtmlGithubSystemjsPluginText002) {
      template = _componentsNotificationOverlayNotificationOverlayHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocNotificationOverlay';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/notification-overlay/notification-overlay.js', ['github:angular/bower-angular@1.4.7', 'components/notification-overlay/notification-overlay-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsNotificationOverlayNotificationOverlayDirectiveJs) {
      directive = _componentsNotificationOverlayNotificationOverlayDirectiveJs['default'];
      directiveName = _componentsNotificationOverlayNotificationOverlayDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.notification-overlay', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/system-message-overlay/system-message-overlay.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"toc-system-message-overlay-container\">\n  <div class=\"toc-system-message-overlay card\"\n    ng-show=\"systemMessageOverlay.showSystemMessage\">\n    <div class=\"item item-text-wrap\">\n      <p>{{systemMessageOverlay.message}}</p>\n    </div>\n  </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/system-message-overlay/system-message-overlay-directive.js', ['components/system-message-overlay/system-message-overlay.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocSystemMessageOverlay);

  /*@ngInject*/
  function tocSystemMessageOverlay() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'systemMessageOverlay',
      controller: /*@ngInject*/function SystemMessageOverlayController($scope, $timeout, state) {
        var _this = this;

        var hidingSystemMessage = null;
        this.showSystemMessage = false;

        var systemMessageCursor = state.memory.notifications.select(['system', 'notificationInfo']);
        var updateSystemMessage = function updateSystemMessage() {
          _this.message = systemMessageCursor.get(['message']);
          if (!_this.message) {
            _this.showSystemMessage = false;
            return;
          }

          if (hidingSystemMessage) {
            $timeout.cancel(hidingSystemMessage);
            _this.showSystemMessage = false;
            // let existing notification animate out, then animate in new one
            return $timeout(function () {
              _this.showSystemMessage = true;
              hidingSystemMessage = $timeout(function () {
                hidingSystemMessage = null;
                _this.showSystemMessage = false;
              }, 5000);
            }, 1100);
          }

          _this.showSystemMessage = true;
          hidingSystemMessage = $timeout(function () {
            hidingSystemMessage = null;
            _this.showSystemMessage = false;
          }, 5000);
        };
        state.addListener(systemMessageCursor, updateSystemMessage, $scope);
      }
    };
  }

  return {
    setters: [function (_componentsSystemMessageOverlaySystemMessageOverlayHtmlGithubSystemjsPluginText002) {
      template = _componentsSystemMessageOverlaySystemMessageOverlayHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocSystemMessageOverlay';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/system-message-overlay/system-message-overlay.js', ['github:angular/bower-angular@1.4.7', 'components/system-message-overlay/system-message-overlay-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsSystemMessageOverlaySystemMessageOverlayDirectiveJs) {
      directive = _componentsSystemMessageOverlaySystemMessageOverlayDirectiveJs['default'];
      directiveName = _componentsSystemMessageOverlaySystemMessageOverlayDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.system-message-overlay', []).directive(directiveName, directive));
    }
  };
});

System.register('components/qr-image/qr-image-directive.js', [], function (_export) {
  'use strict';

  var directiveName;

  _export('default', tocQrImage);

  /*@ngInject*/
  function tocQrImage(qrImage, state, $compile) {
    return {
      restrict: 'E',
      link: function linkQrImage(scope, element, attrs) {
        //TODO: persist qr code dataURI
        var data = attrs.data;
        var svgString = qrImage.imageSync(data, { type: 'svg', ec_level: 'M' });
        var qrImageElement = $compile(svgString)(scope)[0];
        element[0].appendChild(qrImageElement);
      }
    };
  }

  return {
    setters: [],
    execute: function () {
      directiveName = 'tocQrImage';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/qr-image/qr-image.js', ['github:angular/bower-angular@1.4.7', 'components/qr-image/qr-image-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsQrImageQrImageDirectiveJs) {
      directive = _componentsQrImageQrImageDirectiveJs['default'];
      directiveName = _componentsQrImageQrImageDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.qr-image', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/conversations-menu/conversations-menu.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-header-bar class=\"bar-positive toc-conversations-menu-header\">\n  <h1 class=\"title\">Conversations</h1>\n</ion-header-bar>\n<div class=\"toc-conversations-menu-subheader bar bar-subheader\">\n  <toc-user-card\n    ng-class=\"{'toc-active-view': conversationsMenu.viewId === 'home'}\"\n    ng-click=\"conversationsMenu.goToHome()\" menu-close></toc-user-card>\n</div>\n<ion-content class=\"has-subheader\">\n  <toc-channel-list>\n  </toc-channel-list>\n</ion-content>\n<ion-footer-bar>\n  <div class=\"col\">\n    <button class=\"button button-block button-positive\"\n      ng-click=\"conversationsMenu.showBeginConversationModal()\">\n      Start a conversation\n    </button>\n  </div>\n</ion-footer-bar>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/conversations-menu/conversations-menu-directive.js', ['components/conversations-menu/conversations-menu.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocConversationsMenu);

  /*@ngInject*/
  function tocConversationsMenu() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'conversationsMenu',
      controller: /*@ngInject*/function ConversationsMenuController($ionicModal, $q, $scope, channels, contacts, navigation, state) {
        var _this = this;

        var viewIdCursor = state.cloud.navigation.select(['activeViewId']);
        var updateViewId = function updateViewId() {
          _this.viewId = viewIdCursor.get();
        };
        state.addListener(viewIdCursor, updateViewId, $scope);

        this.goToHome = function goToHome() {
          return navigation.navigate('home');
        };

        this.showBeginConversationModal = function showBeginConversationModal() {
          var modalTemplate = '\n          <toc-begin-conversation-modal class="toc-modal-container"\n            remove-modal="conversationsMenu.beginConversationModal.remove()">\n          </toc-begin-conversation-modal>\n        ';

          var modalName = 'beginConversationModal';

          return navigation.showModal(modalName, modalTemplate, this, $scope);
        };
      }
    };
  }

  return {
    setters: [function (_componentsConversationsMenuConversationsMenuHtmlGithubSystemjsPluginText002) {
      template = _componentsConversationsMenuConversationsMenuHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocConversationsMenu';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/conversations-menu/conversations-menu.js', ['github:angular/bower-angular@1.4.7', 'components/conversations-menu/conversations-menu-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsConversationsMenuConversationsMenuDirectiveJs) {
      directive = _componentsConversationsMenuConversationsMenuDirectiveJs['default'];
      directiveName = _componentsConversationsMenuConversationsMenuDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.conversations-menu', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/options-menu/options-menu.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-header-bar class=\"bar-positive\">\n  <h1 class=\"title\">Options</h1>\n</ion-header-bar>\n<ion-content>\n  <div class=\"list\">\n    <div class=\"item\" ng-click=\"optionsMenu.openWindow('http://toc.im')\">\n      About Toc\n    </div>\n    <div class=\"item\" ng-click=\"optionsMenu.showIdPopup()\">\n      Display your ID\n    </div>\n    <div class=\"item\" ng-click=\"optionsMenu.showCloudConnectModal()\">\n      Sync your profile\n    </div>\n    <div class=\"item\" ng-click=\"optionsMenu.showDeleteDataConfirm()\">\n      Clear local data\n    </div>\n    <div class=\"item\" ng-click=\"optionsMenu.showSignoutConfirm()\">\n      Sign out\n    </div>\n  </div>\n</ion-content>\n<ion-footer-bar>\n  <div class=\"col\">\n    <button class=\"button button-block button-positive\"\n      ng-click=\"optionsMenu.showBeginConversationModal()\">\n      Start a conversation\n    </button>\n  </div>\n</ion-footer-bar>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/options-menu/options-menu-directive.js', ['components/options-menu/options-menu.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocOptionsMenu);

  /*@ngInject*/
  function tocOptionsMenu() {
    return {
      restrict: 'E',
      template: template,
      controllerAs: 'optionsMenu',
      controller: /*@ngInject*/function OptionsMenuController($ionicPopup, $scope, navigation, session, state) {
        var _this = this;

        this.openWindow = navigation.openWindow;

        session.preparePrivate().then(function () {
          _this.userInfo = state.cloud.identity.get().userInfo;
          _this.userId = _this.userInfo.id;
        });

        this.showIdPopup = function () {
          $ionicPopup.show({
            title: 'Your ID',
            cssClass: 'toc-id-popup',
            scope: $scope,
            buttons: [{
              text: 'Done',
              type: 'button-positive button-block'
            }],
            template: '<toc-id-display></toc-id-display>'
          });
        };

        this.showBeginConversationModal = function showBeginConversationModal() {
          var modalTemplate = '\n          <toc-begin-conversation-modal class="toc-modal-container"\n            remove-modal="optionsMenu.beginConversationModal.remove()">\n          </toc-begin-conversation-modal>\n        ';

          var modalName = 'beginConversationModal';

          return navigation.showModal(modalName, modalTemplate, this, $scope);
        };

        this.showCloudConnectModal = function showCloudConnectModal() {
          var modalTemplate = '\n          <toc-cloud-connect-modal class="toc-modal-container"\n            remove-modal="optionsMenu.cloudConnectModal.remove()">\n          </toc-cloud-connect-modal>\n        ';

          var modalName = 'cloudConnectModal';

          return navigation.showModal(modalName, modalTemplate, this, $scope);
        };

        this.showDeleteDataConfirm = function showDeleteDataConfirm() {
          var deleteDataPopup = $ionicPopup.confirm({
            title: 'Clear Data',
            template: '\n            <p>All local data will be gone.</p>\n            <p>Are you absolutely sure?</p>\n          ',
            okText: 'Clear',
            okType: 'button-assertive button-block',
            cancelType: 'button-positive button-block button-outline'
          });

          deleteDataPopup.then(function (response) {
            if (!response) {
              return;
            }

            return state.destroy();
          });
        };

        this.showSignoutConfirm = function showSignoutConfirm() {
          var signoutPopup = $ionicPopup.confirm({
            title: 'Sign Out',
            template: '\n            <p>You\'ll have to sign in again.</p>\n            <p>Are you sure?</p>\n          ',
            okText: 'Sign out',
            okType: 'button-assertive button-block',
            cancelType: 'button-positive button-block button-outline'
          });

          signoutPopup.then(function (response) {
            if (!response) {
              return;
            }

            return session.destroy();
          });
        };
      }
    };
  }

  return {
    setters: [function (_componentsOptionsMenuOptionsMenuHtmlGithubSystemjsPluginText002) {
      template = _componentsOptionsMenuOptionsMenuHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocOptionsMenu';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/options-menu/options-menu.js', ['github:angular/bower-angular@1.4.7', 'components/options-menu/options-menu-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsOptionsMenuOptionsMenuDirectiveJs) {
      directive = _componentsOptionsMenuOptionsMenuDirectiveJs['default'];
      directiveName = _componentsOptionsMenuOptionsMenuDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.options-menu', []).directive(directiveName, directive));
    }
  };
});

System.register('components/spinner-button/spinner-button-directive.js', [], function (_export) {
  'use strict';

  var directiveName;

  _export('default', tocSpinnerButton);

  /*@ngInject*/
  function tocSpinnerButton($timeout) {
    return {
      restrict: 'A',
      scope: {
        loadingPromise: '='
      },
      link: function linkSpinnerButton(scope, element) {
        var SPIN_DURATION = 750;

        var spinnerElement = element.find('ion-spinner');
        var iconElement = element.find('i');
        var buttonElement = element;

        spinnerElement.toggleClass('toc-hidden');

        spinnerElement.toggleClass('toc-fadeout');
        iconElement.toggleClass('toc-fadein');
        var spinning = false;

        var toggleSpin = function toggleSpin() {
          spinning = !spinning;

          spinnerElement.toggleClass('toc-fadeout');
          iconElement.toggleClass('toc-fadeout');

          $timeout(function () {
            spinnerElement.toggleClass('toc-hidden');
            iconElement.toggleClass('toc-hidden');
            //FIXME: fadein afterwards doesnt work
            // spinnerElement.toggleClass('toc-fadein');
            // iconElement.toggleClass('toc-fadein');
          }, SPIN_DURATION);

          if (spinning) {
            buttonElement.attr('disabled', 'true');
          } else {
            buttonElement.removeAttr('disabled');
          }
        };

        scope.$watch('loadingPromise', function (loadingPromise) {
          if (!loadingPromise) {
            return;
          }
          var spinStartTime = Date.now();
          toggleSpin();

          loadingPromise.then(function () {
            var spinEndTime = Date.now();

            var spinElapsedTime = (spinStartTime - spinEndTime) % SPIN_DURATION;

            $timeout(function () {
              toggleSpin();
            }, SPIN_DURATION - spinElapsedTime);
          });
        });
      }
    };
  }

  return {
    setters: [],
    execute: function () {
      directiveName = 'tocSpinnerButton';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/spinner-button/spinner-button.js', ['github:angular/bower-angular@1.4.7', 'components/spinner-button/spinner-button-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsSpinnerButtonSpinnerButtonDirectiveJs) {
      directive = _componentsSpinnerButtonSpinnerButtonDirectiveJs['default'];
      directiveName = _componentsSpinnerButtonSpinnerButtonDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.spinner-button', []).directive(directiveName, directive));
    }
  };
});

System.registerDynamic("components/user-card/user-card.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"toc-user-card item item-avatar\"\n  ng-click=\"userCard.dismissNotifications()\">\n  <img ng-src=\"{{userCard.avatar}}\" alt=\"{{userCard.avatarText}}\" />\n  <h2>{{userCard.name}}</h2>\n  <p>\n    {{userCard.message}}\n  </p>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('components/user-card/user-card-directive.js', ['components/user-card/user-card.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var template, directiveName;

  _export('default', tocUserCard);

  /*@ngInject*/
  function tocUserCard() {
    return {
      restrict: 'E',
      template: template,
      scope: {
        message: '@',
        enableDismissNotifications: '@'
      },
      controllerAs: 'userCard',
      controller: /*@ngInject*/function UserCardController($scope, identity, R, state, session) {
        var _this = this;

        this.message = $scope.message;
        this.enableDismissNotifications = $scope.enableDismissNotifications !== undefined;

        session.preparePrivate().then(function () {
          var userInfoCursor = state.cloud.identity.select(['userInfo']);
          var updateUserInfo = function updateUserInfo() {
            var userInfo = userInfoCursor.get();
            _this.avatar = identity.getAvatar(userInfo);
            _this.name = userInfoCursor.get(['displayName']) || 'Anonymous';
            _this.avatarText = 'Avatar for ' + _this.name;
          };
          state.addListener(userInfoCursor, updateUserInfo, $scope);
        });

        if (this.message) {
          return;
        }

        var notificationsCursor = state.cloud.notifications;
        var updateSummary = function updateSummary() {
          _this.notificationCount = R.pipe(R.values, R.reject(R.prop('dismissed')))(notificationsCursor.get() || {}).length;

          if (_this.notificationCount === 0) {
            _this.message = 'No new notifications';
            return;
          }

          if (_this.enableDismissNotifications) {
            _this.message = 'Dismiss all notifications';
            return;
          }

          var hasMultipleNotifications = _this.notificationCount > 1;
          var notificationEnding = hasMultipleNotifications ? 's' : '';

          _this.message = _this.notificationCount + ' new notification' + notificationEnding;
        };
        state.addListener(notificationsCursor, updateSummary, $scope);

        if (!this.enableDismissNotifications) {
          return;
        }

        this.dismissNotifications = function () {
          R.pipe(R.values, R.reject(R.prop('dismissed')), R.forEach(function (notification) {
            state.save(notificationsCursor, [notification.notificationInfo.id, 'dismissed'], true);
          }))(notificationsCursor.get());
        };
      }
    };
  }

  return {
    setters: [function (_componentsUserCardUserCardHtmlGithubSystemjsPluginText002) {
      template = _componentsUserCardUserCardHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      directiveName = 'tocUserCard';

      _export('directiveName', directiveName);
    }
  };
});

System.register('components/user-card/user-card.js', ['github:angular/bower-angular@1.4.7', 'components/user-card/user-card-directive.js'], function (_export) {
  'use strict';

  var angular, directive, directiveName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsUserCardUserCardDirectiveJs) {
      directive = _componentsUserCardUserCardDirectiveJs['default'];
      directiveName = _componentsUserCardUserCardDirectiveJs.directiveName;
    }],
    execute: function () {
      _export('default', angular.module('toc.components.user-card', []).directive(directiveName, directive));
    }
  };
});

System.register('components/components.js', ['github:angular/bower-angular@1.4.7', 'components/auto-focus/auto-focus.js', 'components/auto-select/auto-select.js', 'components/equal-to/equal-to.js', 'components/update-profile-modal/update-profile-modal.js', 'components/begin-conversation-modal/begin-conversation-modal.js', 'components/password-prompt-modal/password-prompt-modal.js', 'components/channel-card/channel-card.js', 'components/channel-list/channel-list.js', 'components/cloud-connect-modal/cloud-connect-modal.js', 'components/invite-post-modal/invite-post-modal.js', 'components/id-display/id-display.js', 'components/message-input-area/message-input-area.js', 'components/message-list/message-list.js', 'components/notification-card/notification-card.js', 'components/notification-list/notification-list.js', 'components/notification-overlay/notification-overlay.js', 'components/system-message-overlay/system-message-overlay.js', 'components/qr-image/qr-image.js', 'components/conversations-menu/conversations-menu.js', 'components/options-menu/options-menu.js', 'components/spinner-button/spinner-button.js', 'components/user-card/user-card.js'], function (_export) {
  'use strict';

  var angular, autoFocus, autoSelect, equalTo, updateProfileModal, beginConversationModal, passwordPromptModal, channelCard, channelList, cloudConnectModal, invitePostModal, idDisplay, messageInputArea, messageList, notificationCard, notificationList, notificationOverlay, systemMessageOverlay, qrImage, conversationsMenu, optionsMenu, spinnerButton, userCard;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsAutoFocusAutoFocusJs) {
      autoFocus = _componentsAutoFocusAutoFocusJs['default'];
    }, function (_componentsAutoSelectAutoSelectJs) {
      autoSelect = _componentsAutoSelectAutoSelectJs['default'];
    }, function (_componentsEqualToEqualToJs) {
      equalTo = _componentsEqualToEqualToJs['default'];
    }, function (_componentsUpdateProfileModalUpdateProfileModalJs) {
      updateProfileModal = _componentsUpdateProfileModalUpdateProfileModalJs['default'];
    }, function (_componentsBeginConversationModalBeginConversationModalJs) {
      beginConversationModal = _componentsBeginConversationModalBeginConversationModalJs['default'];
    }, function (_componentsPasswordPromptModalPasswordPromptModalJs) {
      passwordPromptModal = _componentsPasswordPromptModalPasswordPromptModalJs['default'];
    }, function (_componentsChannelCardChannelCardJs) {
      channelCard = _componentsChannelCardChannelCardJs['default'];
    }, function (_componentsChannelListChannelListJs) {
      channelList = _componentsChannelListChannelListJs['default'];
    }, function (_componentsCloudConnectModalCloudConnectModalJs) {
      cloudConnectModal = _componentsCloudConnectModalCloudConnectModalJs['default'];
    }, function (_componentsInvitePostModalInvitePostModalJs) {
      invitePostModal = _componentsInvitePostModalInvitePostModalJs['default'];
    }, function (_componentsIdDisplayIdDisplayJs) {
      idDisplay = _componentsIdDisplayIdDisplayJs['default'];
    }, function (_componentsMessageInputAreaMessageInputAreaJs) {
      messageInputArea = _componentsMessageInputAreaMessageInputAreaJs['default'];
    }, function (_componentsMessageListMessageListJs) {
      messageList = _componentsMessageListMessageListJs['default'];
    }, function (_componentsNotificationCardNotificationCardJs) {
      notificationCard = _componentsNotificationCardNotificationCardJs['default'];
    }, function (_componentsNotificationListNotificationListJs) {
      notificationList = _componentsNotificationListNotificationListJs['default'];
    }, function (_componentsNotificationOverlayNotificationOverlayJs) {
      notificationOverlay = _componentsNotificationOverlayNotificationOverlayJs['default'];
    }, function (_componentsSystemMessageOverlaySystemMessageOverlayJs) {
      systemMessageOverlay = _componentsSystemMessageOverlaySystemMessageOverlayJs['default'];
    }, function (_componentsQrImageQrImageJs) {
      qrImage = _componentsQrImageQrImageJs['default'];
    }, function (_componentsConversationsMenuConversationsMenuJs) {
      conversationsMenu = _componentsConversationsMenuConversationsMenuJs['default'];
    }, function (_componentsOptionsMenuOptionsMenuJs) {
      optionsMenu = _componentsOptionsMenuOptionsMenuJs['default'];
    }, function (_componentsSpinnerButtonSpinnerButtonJs) {
      spinnerButton = _componentsSpinnerButtonSpinnerButtonJs['default'];
    }, function (_componentsUserCardUserCardJs) {
      userCard = _componentsUserCardUserCardJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.components', [autoFocus.name, autoSelect.name, equalTo.name, updateProfileModal.name, beginConversationModal.name, passwordPromptModal.name, channelCard.name, channelList.name, cloudConnectModal.name, invitePostModal.name, idDisplay.name, messageInputArea.name, messageList.name, notificationCard.name, notificationList.name, notificationOverlay.name, systemMessageOverlay.name, qrImage.name, conversationsMenu.name, optionsMenu.name, spinnerButton.name, userCard.name]));
    }
  };
});

System.registerDynamic("npm:emmett@3.1.1/emmett", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function() {
    'use strict';
    var __allowedOptions = {
      once: 'boolean',
      scope: 'object'
    };
    var __order = 0;
    function shallowMerge(o1, o2) {
      var o = {},
          k;
      for (k in o1)
        o[k] = o1[k];
      for (k in o2)
        o[k] = o2[k];
      return o;
    }
    function isPlainObject(v) {
      return v && typeof v === 'object' && !Array.isArray(v) && !(v instanceof Function) && !(v instanceof RegExp);
    }
    function forIn(object, fn, scope) {
      var symbols,
          k,
          i,
          l;
      for (k in object)
        fn.call(scope || null, k, object[k]);
      if (Object.getOwnPropertySymbols) {
        symbols = Object.getOwnPropertySymbols(object);
        for (i = 0, l = symbols.length; i < l; i++)
          fn.call(scope || null, symbols[i], object[symbols[i]]);
      }
    }
    var Emitter = function() {
      this._enabled = true;
      this.unbindAll();
    };
    Emitter.prototype.unbindAll = function() {
      this._handlers = {};
      this._handlersAll = [];
      this._handlersComplex = [];
      return this;
    };
    Emitter.prototype.on = function(a, b, c) {
      var i,
          l,
          k,
          event,
          eArray,
          handlersList,
          bindingObject;
      if (isPlainObject(a)) {
        forIn(a, function(name, fn) {
          this.on(name, fn, b);
        }, this);
        return this;
      }
      if (typeof a === 'function') {
        c = b;
        b = a;
        a = null;
      }
      eArray = [].concat(a);
      for (i = 0, l = eArray.length; i < l; i++) {
        event = eArray[i];
        bindingObject = {
          order: __order++,
          fn: b
        };
        if (typeof event === 'string' || typeof event === 'symbol') {
          if (!this._handlers[event])
            this._handlers[event] = [];
          handlersList = this._handlers[event];
          bindingObject.type = event;
        } else if (event instanceof RegExp) {
          handlersList = this._handlersComplex;
          bindingObject.pattern = event;
        } else if (event === null) {
          handlersList = this._handlersAll;
        } else {
          throw Error('Emitter.on: invalid event.');
        }
        for (k in c || {})
          if (__allowedOptions[k])
            bindingObject[k] = c[k];
        handlersList.push(bindingObject);
      }
      return this;
    };
    Emitter.prototype.once = function() {
      var args = Array.prototype.slice.call(arguments),
          li = args.length - 1;
      if (isPlainObject(args[li]) && args.length > 1)
        args[li] = shallowMerge(args[li], {once: true});
      else
        args.push({once: true});
      return this.on.apply(this, args);
    };
    function filter(target, fn) {
      target = target || [];
      var a = [],
          l,
          i;
      for (i = 0, l = target.length; i < l; i++)
        if (target[i].fn !== fn)
          a.push(target[i]);
      return a;
    }
    Emitter.prototype.off = function(events, fn) {
      var i,
          n,
          k,
          event;
      if (arguments.length === 1 && typeof events === 'function') {
        fn = arguments[0];
        for (k in this._handlers) {
          this._handlers[k] = filter(this._handlers[k], fn);
          if (this._handlers[k].length === 0)
            delete this._handlers[k];
        }
        this._handlersAll = filter(this._handlersAll, fn);
        this._handlersComplex = filter(this._handlersComplex, fn);
      } else if (arguments.length === 1 && (typeof events === 'string' || typeof events === 'symbol')) {
        delete this._handlers[events];
      } else if (arguments.length === 2) {
        var eArray = [].concat(events);
        for (i = 0, n = eArray.length; i < n; i++) {
          event = eArray[i];
          this._handlers[event] = filter(this._handlers[event], fn);
          if ((this._handlers[event] || []).length === 0)
            delete this._handlers[event];
        }
      } else if (isPlainObject(events)) {
        forIn(events, this.off, this);
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      var handlers = this._handlersAll || [],
          complex = false,
          h,
          i,
          l;
      if (!event)
        throw Error('Emitter.listeners: no event provided.');
      handlers = handlers.concat(this._handlers[event] || []);
      for (i = 0, l = this._handlersComplex.length; i < l; i++) {
        h = this._handlersComplex[i];
        if (~event.search(h.pattern)) {
          complex = true;
          handlers.push(h);
        }
      }
      if (this._handlersAll.length || complex)
        return handlers.sort(function(a, b) {
          return a.order - b.order;
        });
      else
        return handlers.slice(0);
    };
    Emitter.prototype.emit = function(events, data) {
      if (!this._enabled)
        return this;
      if (isPlainObject(events)) {
        forIn(events, this.emit, this);
        return this;
      }
      var eArray = [].concat(events),
          onces = [],
          event,
          parent,
          handlers,
          handler,
          i,
          j,
          l,
          m;
      for (i = 0, l = eArray.length; i < l; i++) {
        handlers = this.listeners(eArray[i]);
        for (j = 0, m = handlers.length; j < m; j++) {
          handler = handlers[j];
          event = {
            type: eArray[i],
            target: this
          };
          if (arguments.length > 1)
            event.data = data;
          handler.fn.call('scope' in handler ? handler.scope : this, event);
          if (handler.once)
            onces.push(handler);
        }
        for (j = onces.length - 1; j >= 0; j--) {
          parent = onces[j].type ? this._handlers[onces[j].type] : onces[j].pattern ? this._handlersComplex : this._handlersAll;
          parent.splice(parent.indexOf(onces[j]), 1);
        }
      }
      return this;
    };
    Emitter.prototype.kill = function() {
      this.unbindAll();
      this._handlers = null;
      this._handlersAll = null;
      this._handlersComplex = null;
      this._enabled = false;
      this.unbindAll = this.on = this.once = this.off = this.emit = this.listeners = Function.prototype;
    };
    Emitter.prototype.disable = function() {
      this._enabled = false;
      return this;
    };
    Emitter.prototype.enable = function() {
      this._enabled = true;
      return this;
    };
    Emitter.version = '3.1.1';
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports)
        exports = module.exports = Emitter;
      exports.Emitter = Emitter;
    } else if (typeof define === 'function' && define.amd)
      define('emmett', [], function() {
        return Emitter;
      });
    else
      this.Emitter = Emitter;
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:emmett@3.1.1", ["npm:emmett@3.1.1/emmett"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:emmett@3.1.1/emmett');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@2.1.0/dist/type", ["npm:baobab@2.1.0/dist/monkey"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _monkey = req('npm:baobab@2.1.0/dist/monkey');
  var type = {};
  function anyOf(target, allowed) {
    return allowed.some(function(t) {
      return type[t](target);
    });
  }
  type.array = function(target) {
    return Array.isArray(target);
  };
  type.object = function(target) {
    return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp);
  };
  type.string = function(target) {
    return typeof target === 'string';
  };
  type.number = function(target) {
    return typeof target === 'number';
  };
  type['function'] = function(target) {
    return typeof target === 'function';
  };
  type.primitive = function(target) {
    return target !== Object(target);
  };
  type.splicer = function(target) {
    if (!type.array(target) || target.length < 2)
      return false;
    return anyOf(target[0], ['number', 'function', 'object']) && type.number(target[1]);
  };
  var ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];
  type.path = function(target) {
    if (!target && target !== 0 && target !== '')
      return false;
    return [].concat(target).every(function(step) {
      return anyOf(step, ALLOWED_FOR_PATH);
    });
  };
  type.dynamicPath = function(path) {
    return path.some(function(step) {
      return type['function'](step) || type.object(step);
    });
  };
  type.monkeyPath = function(data, path) {
    var subpath = [],
        c = data,
        i = undefined,
        l = undefined;
    for (i = 0, l = path.length; i < l; i++) {
      subpath.push(path[i]);
      if (typeof c !== 'object')
        return null;
      c = c[path[i]];
      if (c instanceof _monkey.Monkey)
        return subpath;
    }
    return null;
  };
  type.lazyGetter = function(o, propertyKey) {
    var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);
    return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;
  };
  type.monkeyDefinition = function(definition) {
    if (type.object(definition)) {
      if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function(k) {
        return type.path(definition.cursors[k]);
      })))
        return null;
      else
        return 'object';
    } else if (type.array(definition)) {
      if (!type['function'](definition[definition.length - 1]) || !definition.slice(0, -1).every(function(p) {
        return type.path(p);
      }))
        return null;
      else
        return 'array';
    }
    return null;
  };
  type.watcherMapping = function(definition) {
    return type.object(definition) && Object.keys(definition).every(function(k) {
      return type.path(definition[k]);
    });
  };
  var VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'deepMerge', 'merge', 'splice', 'unset'];
  type.operationType = function(string) {
    return typeof string === 'string' && !!~VALID_OPERATIONS.indexOf(string);
  };
  exports['default'] = type;
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@2.1.0/dist/helpers", ["npm:baobab@2.1.0/dist/monkey", "npm:baobab@2.1.0/dist/type"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.arrayFrom = arrayFrom;
  exports.before = before;
  exports.coercePath = coercePath;
  exports.getIn = getIn;
  exports.makeError = makeError;
  exports.pathObject = pathObject;
  exports.solveRelativePath = solveRelativePath;
  exports.solveUpdate = solveUpdate;
  exports.splice = splice;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var _monkey = req('npm:baobab@2.1.0/dist/monkey');
  var _type = req('npm:baobab@2.1.0/dist/type');
  var _type2 = _interopRequireDefault(_type);
  var noop = Function.prototype;
  var Archive = (function() {
    function Archive(size) {
      _classCallCheck(this, Archive);
      this.size = size;
      this.records = [];
    }
    _createClass(Archive, [{
      key: 'get',
      value: function get() {
        return this.records;
      }
    }, {
      key: 'add',
      value: function add(record) {
        this.records.unshift(record);
        if (this.records.length > this.size)
          this.records.length = this.size;
        return this;
      }
    }, {
      key: 'clear',
      value: function clear() {
        this.records = [];
        return this;
      }
    }, {
      key: 'back',
      value: function back(steps) {
        var record = this.records[steps - 1];
        if (record)
          this.records = this.records.slice(steps);
        return record;
      }
    }]);
    return Archive;
  })();
  exports.Archive = Archive;
  function arrayFrom(culprit) {
    return slice(culprit);
  }
  function before(decorator, fn) {
    return function() {
      decorator.apply(null, arguments);
      fn.apply(null, arguments);
    };
  }
  function cloneRegexp(re) {
    var pattern = re.source,
        flags = '';
    if (re.global)
      flags += 'g';
    if (re.multiline)
      flags += 'm';
    if (re.ignoreCase)
      flags += 'i';
    if (re.sticky)
      flags += 'y';
    if (re.unicode)
      flags += 'u';
    return new RegExp(pattern, flags);
  }
  function cloner(deep, item) {
    if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || 'ArrayBuffer' in global && item instanceof ArrayBuffer)
      return item;
    if (_type2['default'].array(item)) {
      if (deep) {
        var i = undefined,
            l = undefined,
            a = [];
        for (i = 0, l = item.length; i < l; i++)
          a.push(cloner(true, item[i]));
        return a;
      } else {
        return slice(item);
      }
    }
    if (item instanceof Date)
      return new Date(item.getTime());
    if (item instanceof RegExp)
      return cloneRegexp(item);
    if (_type2['default'].object(item)) {
      var k = undefined,
          o = {};
      for (k in item)
        if (item.hasOwnProperty(k))
          o[k] = deep ? cloner(true, item[k]) : item[k];
      return o;
    }
    return item;
  }
  var shallowClone = cloner.bind(null, false),
      deepClone = cloner.bind(null, true);
  exports.shallowClone = shallowClone;
  exports.deepClone = deepClone;
  function coercePath(target) {
    if (target || target === 0 || target === '')
      return target;
    return [];
  }
  function compare(object, description) {
    var ok = true,
        k = undefined;
    if (!object)
      return false;
    for (k in description) {
      if (_type2['default'].object(description[k])) {
        ok = ok && compare(object[k], description[k]);
      } else if (_type2['default'].array(description[k])) {
        ok = ok && !!~description[k].indexOf(object[k]);
      } else {
        if (object[k] !== description[k])
          return false;
      }
    }
    return ok;
  }
  function freezer(deep, o) {
    if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey)
      return;
    Object.freeze(o);
    if (!deep)
      return;
    if (Array.isArray(o)) {
      var i = undefined,
          l = undefined;
      for (i = 0, l = o.length; i < l; i++)
        freezer(true, o[i]);
    } else {
      var p = undefined,
          k = undefined;
      for (k in o) {
        if (_type2['default'].lazyGetter(o, k))
          continue;
        p = o[k];
        if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p))
          continue;
        freezer(true, p);
      }
    }
  }
  var isFreezeSupported = typeof Object.freeze === 'function';
  var freeze = isFreezeSupported ? freezer.bind(null, false) : noop,
      deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;
  exports.freeze = freeze;
  exports.deepFreeze = deepFreeze;
  var notFoundObject = {
    data: undefined,
    solvedPath: null,
    exists: false
  };
  function getIn(object, path) {
    if (!path)
      return notFoundObject;
    var solvedPath = [],
        c = object,
        idx = undefined,
        i = undefined,
        l = undefined;
    for (i = 0, l = path.length; i < l; i++) {
      if (!c)
        return {
          data: undefined,
          solvedPath: path,
          exists: false
        };
      if (typeof path[i] === 'function') {
        if (!_type2['default'].array(c))
          return notFoundObject;
        idx = index(c, path[i]);
        if (!~idx)
          return notFoundObject;
        solvedPath.push(idx);
        c = c[idx];
      } else if (typeof path[i] === 'object') {
        if (!_type2['default'].array(c))
          return notFoundObject;
        idx = index(c, function(e) {
          return compare(e, path[i]);
        });
        if (!~idx)
          return notFoundObject;
        solvedPath.push(idx);
        c = c[idx];
      } else {
        solvedPath.push(path[i]);
        c = c[path[i]];
      }
    }
    return {
      data: c,
      solvedPath: solvedPath,
      exists: c !== undefined
    };
  }
  function index(a, fn) {
    var i = undefined,
        l = undefined;
    for (i = 0, l = a.length; i < l; i++) {
      if (fn(a[i]))
        return i;
    }
    return -1;
  }
  function makeError(message, data) {
    var err = new Error(message);
    for (var k in data) {
      err[k] = data[k];
    }
    return err;
  }
  function merger(deep) {
    for (var _len = arguments.length,
        objects = Array(_len > 1 ? _len - 1 : 0),
        _key = 1; _key < _len; _key++) {
      objects[_key - 1] = arguments[_key];
    }
    var o = objects[0],
        t = undefined,
        i = undefined,
        l = undefined,
        k = undefined;
    for (i = 1, l = objects.length; i < l; i++) {
      t = objects[i];
      for (k in t) {
        if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {
          o[k] = merger(true, o[k] || {}, t[k]);
        } else {
          o[k] = t[k];
        }
      }
    }
    return o;
  }
  var shallowMerge = merger.bind(null, false),
      deepMerge = merger.bind(null, true);
  exports.shallowMerge = shallowMerge;
  exports.deepMerge = deepMerge;
  function pathObject(path, leaf) {
    var l = path.length,
        o = {},
        c = o,
        i = undefined;
    if (!l)
      o = leaf;
    for (i = 0; i < l; i++) {
      c[path[i]] = i + 1 === l ? leaf : {};
      c = c[path[i]];
    }
    return o;
  }
  function slice(array) {
    var newArray = new Array(array.length),
        i = undefined,
        l = undefined;
    for (i = 0, l = array.length; i < l; i++)
      newArray[i] = array[i];
    return newArray;
  }
  function solveRelativePath(base, to) {
    var solvedPath = [];
    for (var i = 0,
        l = to.length; i < l; i++) {
      var step = to[i];
      if (step === '.') {
        if (!i)
          solvedPath = base.slice(0);
      } else if (step === '..') {
        solvedPath = (!i ? base : solvedPath).slice(0, -1);
      } else {
        solvedPath.push(step);
      }
    }
    return solvedPath;
  }
  function solveUpdate(affectedPaths, comparedPaths) {
    var i = undefined,
        j = undefined,
        k = undefined,
        l = undefined,
        m = undefined,
        n = undefined,
        p = undefined,
        c = undefined,
        s = undefined;
    for (i = 0, l = affectedPaths.length; i < l; i++) {
      p = affectedPaths[i];
      if (!p.length)
        return true;
      for (j = 0, m = comparedPaths.length; j < m; j++) {
        c = comparedPaths[j];
        if (!c || !c.length)
          return true;
        for (k = 0, n = c.length; k < n; k++) {
          s = c[k];
          if (s != p[k])
            break;
          if (k + 1 === n || k + 1 === p.length)
            return true;
        }
      }
    }
    return false;
  }
  function splice(array, startIndex, nb) {
    for (var _len2 = arguments.length,
        elements = Array(_len2 > 3 ? _len2 - 3 : 0),
        _key2 = 3; _key2 < _len2; _key2++) {
      elements[_key2 - 3] = arguments[_key2];
    }
    return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));
  }
  var uniqid = (function() {
    var i = 0;
    return function() {
      return i++;
    };
  })();
  exports.uniqid = uniqid;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@2.1.0/dist/update", ["npm:baobab@2.1.0/dist/type", "npm:baobab@2.1.0/dist/monkey", "npm:baobab@2.1.0/dist/helpers"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  exports['default'] = update;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++)
        arr2[i] = arr[i];
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  var _type = req('npm:baobab@2.1.0/dist/type');
  var _type2 = _interopRequireDefault(_type);
  var _monkey = req('npm:baobab@2.1.0/dist/monkey');
  var _helpers = req('npm:baobab@2.1.0/dist/helpers');
  function err(operation, expectedTarget, path) {
    return (0, _helpers.makeError)('Baobab.update: cannot apply the "' + operation + '" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), {path: path});
  }
  function update(data, path, operation) {
    var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
    var operationType = operation.type;
    var value = operation.value;
    var dummy = {root: data},
        dummyPath = ['root'].concat(_toConsumableArray(path));
    var p = dummy,
        currentPath = [],
        i = undefined,
        l = undefined,
        s = undefined;
    for (i = 0, l = dummyPath.length; i < l; i++) {
      s = dummyPath[i];
      if (i > 0)
        currentPath.push(s);
      if (i === l - 1) {
        if (operationType === 'set') {
          if (opts.pure && p[s] === value)
            return {node: p[s]};
          if (opts.persistent) {
            p[s] = (0, _helpers.shallowClone)(value);
          } else if (value instanceof _monkey.MonkeyDefinition) {
            Object.defineProperty(p, s, {
              value: value,
              enumerable: true,
              configurable: true
            });
          } else {
            p[s] = value;
          }
        } else if (operationType === 'monkey') {
          Object.defineProperty(p, s, {
            get: value,
            enumerable: true,
            configurable: true
          });
        } else if (operationType === 'apply') {
          var result = value(p[s]);
          if (opts.pure && result === value)
            return {node: p[s]};
          p[s] = opts.persistent ? (0, _helpers.shallowClone)(result) : result;
        } else if (operationType === 'push') {
          if (!_type2['default'].array(p[s]))
            throw err('push', 'array', currentPath);
          if (opts.persistent)
            p[s] = p[s].concat([value]);
          else
            p[s].push(value);
        } else if (operationType === 'unshift') {
          if (!_type2['default'].array(p[s]))
            throw err('unshift', 'array', currentPath);
          if (opts.persistent)
            p[s] = [value].concat(p[s]);
          else
            p[s].unshift(value);
        } else if (operationType === 'concat') {
          if (!_type2['default'].array(p[s]))
            throw err('concat', 'array', currentPath);
          if (opts.persistent)
            p[s] = p[s].concat(value);
          else
            p[s].push.apply(p[s], value);
        } else if (operationType === 'splice') {
          if (!_type2['default'].array(p[s]))
            throw err('splice', 'array', currentPath);
          if (opts.persistent)
            p[s] = _helpers.splice.apply(null, [p[s]].concat(value));
          else
            p[s].splice.apply(p[s], value);
        } else if (operationType === 'unset') {
          if (_type2['default'].object(p))
            delete p[s];
          else if (_type2['default'].array(p))
            p.splice(s, 1);
        } else if (operationType === 'merge') {
          if (!_type2['default'].object(p[s]))
            throw err('merge', 'object', currentPath);
          if (opts.persistent)
            p[s] = (0, _helpers.shallowMerge)({}, p[s], value);
          else
            p[s] = (0, _helpers.shallowMerge)(p[s], value);
        } else if (operationType === 'deepMerge') {
          if (!_type2['default'].object(p[s]))
            throw err('deepMerge', 'object', currentPath);
          if (opts.persistent)
            p[s] = (0, _helpers.deepMerge)({}, p[s], value);
          else
            p[s] = (0, _helpers.deepMerge)(p[s], value);
        }
        if (opts.immutable)
          (0, _helpers.deepFreeze)(p);
        break;
      } else if (_type2['default'].primitive(p[s])) {
        p[s] = {};
      } else if (opts.persistent) {
        p[s] = (0, _helpers.shallowClone)(p[s]);
      }
      if (opts.immutable && l > 0)
        (0, _helpers.freeze)(p);
      p = p[s];
    }
    if (_type2['default'].lazyGetter(p, s))
      return {data: dummy.root};
    return {
      data: dummy.root,
      node: p[s]
    };
  }
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@2.1.0/dist/monkey", ["npm:baobab@2.1.0/dist/type", "npm:baobab@2.1.0/dist/update", "npm:baobab@2.1.0/dist/helpers"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var _type = req('npm:baobab@2.1.0/dist/type');
  var _type2 = _interopRequireDefault(_type);
  var _update2 = req('npm:baobab@2.1.0/dist/update');
  var _update3 = _interopRequireDefault(_update2);
  var _helpers = req('npm:baobab@2.1.0/dist/helpers');
  var MonkeyDefinition = function MonkeyDefinition(definition) {
    var _this = this;
    _classCallCheck(this, MonkeyDefinition);
    var monkeyType = _type2['default'].monkeyDefinition(definition);
    if (!monkeyType)
      throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', {definition: definition});
    this.type = monkeyType;
    if (this.type === 'object') {
      this.getter = definition.get;
      this.projection = definition.cursors || {};
      this.paths = Object.keys(this.projection).map(function(k) {
        return _this.projection[k];
      });
    } else {
      this.getter = definition[definition.length - 1];
      this.projection = definition.slice(0, -1);
      this.paths = this.projection;
    }
    this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);
  };
  ;
  exports.MonkeyDefinition = MonkeyDefinition;
  var Monkey = (function() {
    function Monkey(tree, pathInTree, definition) {
      var _this2 = this;
      _classCallCheck(this, Monkey);
      this.tree = tree;
      this.path = pathInTree;
      this.definition = definition;
      this.isRecursive = false;
      var projection = definition.projection,
          relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));
      if (definition.type === 'object') {
        this.projection = Object.keys(projection).reduce(function(acc, k) {
          acc[k] = relative(projection[k]);
          return acc;
        }, {});
        this.depPaths = Object.keys(this.projection).map(function(k) {
          return _this2.projection[k];
        });
      } else {
        this.projection = projection.map(relative);
        this.depPaths = this.projection;
      }
      this.state = {killed: false};
      this.listener = function(_ref) {
        var path = _ref.data.path;
        if (_this2.state.killed)
          return;
        var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());
        if (concerned)
          _this2.update();
      };
      this.tree.on('write', this.listener);
      this.update();
    }
    _createClass(Monkey, [{
      key: 'checkRecursivity',
      value: function checkRecursivity() {
        var _this3 = this;
        this.isRecursive = this.depPaths.some(function(p) {
          return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);
        });
        if (this.isRecursive) {
          this.tree.off('write', this.listener);
          this.tree.on('write', this.listener);
        }
        return this;
      }
    }, {
      key: 'relatedPaths',
      value: function relatedPaths() {
        var _this4 = this;
        var paths = undefined;
        if (this.definition.hasDynamicPaths)
          paths = this.depPaths.map(function(p) {
            return (0, _helpers.getIn)(_this4.tree._data, p).solvedPath;
          });
        else
          paths = this.depPaths;
        if (!this.isRecursive)
          return paths;
        else
          return paths.reduce(function(accumulatedPaths, path) {
            var monkeyPath = _type2['default'].monkeyPath(_this4.tree._monkeys, path);
            if (!monkeyPath)
              return accumulatedPaths.concat([path]);
            var relatedMonkey = (0, _helpers.getIn)(_this4.tree._monkeys, monkeyPath).data;
            return accumulatedPaths.concat(relatedMonkey.relatedPaths());
          }, []);
      }
    }, {
      key: 'update',
      value: function update() {
        var deps = this.tree.project(this.projection);
        var lazyGetter = (function(tree, def, data) {
          var cache = null,
              alreadyComputed = false;
          return function() {
            if (!alreadyComputed) {
              cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);
              if (tree.options.immutable)
                (0, _helpers.deepFreeze)(cache);
              alreadyComputed = true;
            }
            return cache;
          };
        })(this.tree, this.definition, deps);
        lazyGetter.isLazyGetter = true;
        if (this.tree.options.lazyMonkeys)
          this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {
            type: 'monkey',
            value: lazyGetter
          }, this.tree.options).data;
        else
          this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {
            type: 'set',
            value: lazyGetter()
          }, this.tree.options).data;
        return this;
      }
    }, {
      key: 'release',
      value: function release() {
        this.tree.off('write', this.listener);
        this.state.killed = true;
        delete this.projection;
        delete this.depPaths;
        delete this.tree;
      }
    }]);
    return Monkey;
  })();
  exports.Monkey = Monkey;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@2.1.0/dist/cursor", ["npm:emmett@3.1.1", "npm:baobab@2.1.0/dist/monkey", "npm:baobab@2.1.0/dist/type", "npm:baobab@2.1.0/dist/helpers"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  var _get = function get(_x3, _x4, _x5) {
    var _again = true;
    _function: while (_again) {
      var object = _x3,
          property = _x4,
          receiver = _x5;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x3 = parent;
          _x4 = property;
          _x5 = receiver;
          _again = true;
          continue _function;
        }
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var _emmett = req('npm:emmett@3.1.1');
  var _emmett2 = _interopRequireDefault(_emmett);
  var _monkey = req('npm:baobab@2.1.0/dist/monkey');
  var _type = req('npm:baobab@2.1.0/dist/type');
  var _type2 = _interopRequireDefault(_type);
  var _helpers = req('npm:baobab@2.1.0/dist/helpers');
  function checkPossibilityOfDynamicTraversal(method, solvedPath) {
    if (!solvedPath)
      throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), {path: solvedPath});
  }
  var Cursor = (function(_Emitter) {
    _inherits(Cursor, _Emitter);
    function Cursor(tree, path, hash) {
      var _this = this;
      _classCallCheck(this, Cursor);
      _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);
      path = path || [];
      this._identity = '[object Cursor]';
      this._archive = null;
      this.tree = tree;
      this.path = path;
      this.hash = hash;
      this.state = {
        killed: false,
        recording: false,
        undoing: false
      };
      this._dynamicPath = _type2['default'].dynamicPath(this.path);
      this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);
      if (!this._dynamicPath)
        this.solvedPath = this.path;
      else
        this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;
      this._writeHandler = function(_ref) {
        var data = _ref.data;
        if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths()))
          return;
        _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;
      };
      var fireUpdate = function fireUpdate(previousData) {
        var self = _this;
        var eventData = Object.defineProperties({}, {
          previousData: {
            get: function get() {
              return (0, _helpers.getIn)(previousData, self.solvedPath).data;
            },
            configurable: true,
            enumerable: true
          },
          currentData: {
            get: function get() {
              return self.get();
            },
            configurable: true,
            enumerable: true
          }
        });
        if (_this.state.recording && !_this.state.undoing)
          _this.archive.add(eventData.previousData);
        _this.state.undoing = false;
        return _this.emit('update', eventData);
      };
      this._updateHandler = function(event) {
        if (_this.state.killed)
          return;
        var _event$data = event.data;
        var paths = _event$data.paths;
        var previousData = _event$data.previousData;
        var update = fireUpdate.bind(_this, previousData);
        var comparedPaths = _this._getComparedPaths();
        if ((0, _helpers.solveUpdate)(paths, comparedPaths))
          return update();
      };
      var bound = false;
      this._lazyBind = function() {
        if (bound)
          return;
        bound = true;
        if (_this._dynamicPath)
          _this.tree.on('write', _this._writeHandler);
        return _this.tree.on('update', _this._updateHandler);
      };
      if (this._dynamicPath) {
        this._lazyBind();
      } else {
        this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));
        this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));
      }
    }
    _createClass(Cursor, [{
      key: '_getComparedPaths',
      value: function _getComparedPaths() {
        var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];
        return [this.solvedPath].concat(additionalPaths);
      }
    }, {
      key: 'isRoot',
      value: function isRoot() {
        return !this.path.length;
      }
    }, {
      key: 'isLeaf',
      value: function isLeaf() {
        return _type2['default'].primitive(this._get().data);
      }
    }, {
      key: 'isBranch',
      value: function isBranch() {
        return !this.isRoot() && !this.isLeaf();
      }
    }, {
      key: 'root',
      value: function root() {
        return this.tree.select();
      }
    }, {
      key: 'select',
      value: function select(path) {
        if (arguments.length > 1)
          path = (0, _helpers.arrayFrom)(arguments);
        return this.tree.select(this.path.concat(path));
      }
    }, {
      key: 'up',
      value: function up() {
        if (!this.isRoot())
          return this.tree.select(this.path.slice(0, -1));
        else
          return null;
      }
    }, {
      key: 'down',
      value: function down() {
        checkPossibilityOfDynamicTraversal('down', this.solvedPath);
        if (!(this._get().data instanceof Array))
          throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');
        return this.tree.select(this.solvedPath.concat(0));
      }
    }, {
      key: 'left',
      value: function left() {
        checkPossibilityOfDynamicTraversal('left', this.solvedPath);
        var last = +this.solvedPath[this.solvedPath.length - 1];
        if (isNaN(last))
          throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');
        return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;
      }
    }, {
      key: 'right',
      value: function right() {
        checkPossibilityOfDynamicTraversal('right', this.solvedPath);
        var last = +this.solvedPath[this.solvedPath.length - 1];
        if (isNaN(last))
          throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');
        if (last + 1 === this.up()._get().data.length)
          return null;
        return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));
      }
    }, {
      key: 'leftmost',
      value: function leftmost() {
        checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);
        var last = +this.solvedPath[this.solvedPath.length - 1];
        if (isNaN(last))
          throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');
        return this.tree.select(this.solvedPath.slice(0, -1).concat(0));
      }
    }, {
      key: 'rightmost',
      value: function rightmost() {
        checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);
        var last = +this.solvedPath[this.solvedPath.length - 1];
        if (isNaN(last))
          throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');
        var list = this.up()._get().data;
        return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));
      }
    }, {
      key: 'map',
      value: function map(fn, scope) {
        checkPossibilityOfDynamicTraversal('map', this.solvedPath);
        var array = this._get().data,
            l = arguments.length;
        if (!_type2['default'].array(array))
          throw Error('baobab.Cursor.map: cannot map a non-list type.');
        return array.map(function(item, i) {
          return fn.call(l > 1 ? scope : this, this.select(i), i, array);
        }, this);
      }
    }, {
      key: '_get',
      value: function _get() {
        var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
        if (!_type2['default'].path(path))
          throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', {path: path});
        if (!this.solvedPath)
          return {
            data: undefined,
            solvedPath: null,
            exists: false
          };
        return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));
      }
    }, {
      key: 'exists',
      value: function exists(path) {
        path = (0, _helpers.coercePath)(path);
        if (arguments.length > 1)
          path = (0, _helpers.arrayFrom)(arguments);
        return this._get(path).exists;
      }
    }, {
      key: 'get',
      value: function get(path) {
        path = (0, _helpers.coercePath)(path);
        if (arguments.length > 1)
          path = (0, _helpers.arrayFrom)(arguments);
        var _get2 = this._get(path);
        var data = _get2.data;
        var solvedPath = _get2.solvedPath;
        this.tree.emit('get', {
          data: data,
          solvedPath: solvedPath,
          path: this.path.concat(path)
        });
        return data;
      }
    }, {
      key: 'serialize',
      value: function serialize(path) {
        path = (0, _helpers.coercePath)(path);
        if (arguments.length > 1)
          path = (0, _helpers.arrayFrom)(arguments);
        if (!_type2['default'].path(path))
          throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', {path: path});
        if (!this.solvedPath)
          return undefined;
        var fullPath = this.solvedPath.concat(path);
        var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),
            monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;
        var dropComputedData = function dropComputedData(d, m) {
          if (!_type2['default'].object(m) || !_type2['default'].object(d))
            return;
          for (var k in m) {
            if (m[k] instanceof _monkey.Monkey)
              delete d[k];
            else
              dropComputedData(d[k], m[k]);
          }
        };
        dropComputedData(data, monkeys);
        return data;
      }
    }, {
      key: 'project',
      value: function project(projection) {
        if (_type2['default'].object(projection)) {
          var data = {};
          for (var k in projection) {
            data[k] = this.get(projection[k]);
          }
          return data;
        } else if (_type2['default'].array(projection)) {
          var data = [];
          for (var i = 0,
              l = projection.length; i < l; i++) {
            data.push(this.get(projection[i]));
          }
          return data;
        }
        throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', {projection: projection});
      }
    }, {
      key: 'startRecording',
      value: function startRecording(maxRecords) {
        maxRecords = maxRecords || Infinity;
        if (maxRecords < 1)
          throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {value: maxRecords});
        if (this.archive)
          return this;
        this._lazyBind();
        this.archive = new _helpers.Archive(maxRecords);
        this.state.recording = true;
        return this;
      }
    }, {
      key: 'stopRecording',
      value: function stopRecording() {
        this.state.recording = false;
        return this;
      }
    }, {
      key: 'undo',
      value: function undo() {
        var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
        if (!this.state.recording)
          throw new Error('Baobab.Cursor.undo: cursor is not recording.');
        var record = this.archive.back(steps);
        if (!record)
          throw Error('Baobab.Cursor.undo: cannot find a relevant record.');
        this.state.undoing = true;
        this.set(record);
        return this;
      }
    }, {
      key: 'hasHistory',
      value: function hasHistory() {
        return !!(this.archive && this.archive.get().length);
      }
    }, {
      key: 'getHistory',
      value: function getHistory() {
        return this.archive ? this.archive.get() : [];
      }
    }, {
      key: 'clearHistory',
      value: function clearHistory() {
        if (this.archive)
          this.archive.clear();
        return this;
      }
    }, {
      key: 'release',
      value: function release() {
        if (this._dynamicPath)
          this.tree.off('write', this._writeHandler);
        this.tree.off('update', this._updateHandler);
        if (this.hash)
          delete this.tree._cursors[this.hash];
        delete this.tree;
        delete this.path;
        delete this.solvedPath;
        delete this.archive;
        this.kill();
        this.state.killed = true;
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.serialize();
      }
    }, {
      key: 'toString',
      value: function toString() {
        return this._identity;
      }
    }]);
    return Cursor;
  })(_emmett2['default']);
  exports['default'] = Cursor;
  function makeSetter(name, typeChecker) {
    Cursor.prototype[name] = function(path, value) {
      if (arguments.length > 2)
        throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');
      if (arguments.length === 1 && name !== 'unset') {
        value = path;
        path = [];
      }
      path = (0, _helpers.coercePath)(path);
      if (!_type2['default'].path(path))
        throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', {path: path});
      if (typeChecker && !typeChecker(value))
        throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', {
          path: path,
          value: value
        });
      var fullPath = this.solvedPath.concat(path);
      return this.tree.update(fullPath, {
        type: name,
        value: value
      });
    };
  }
  makeSetter('set');
  makeSetter('unset');
  makeSetter('apply', _type2['default']['function']);
  makeSetter('push');
  makeSetter('concat', _type2['default'].array);
  makeSetter('unshift');
  makeSetter('splice', _type2['default'].splicer);
  makeSetter('merge', _type2['default'].object);
  makeSetter('deepMerge', _type2['default'].object);
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@2.1.0/dist/watcher", ["npm:emmett@3.1.1", "npm:baobab@2.1.0/dist/cursor", "npm:baobab@2.1.0/dist/type", "npm:baobab@2.1.0/dist/helpers"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  var _get = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          continue _function;
        }
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var _emmett = req('npm:emmett@3.1.1');
  var _emmett2 = _interopRequireDefault(_emmett);
  var _cursor = req('npm:baobab@2.1.0/dist/cursor');
  var _cursor2 = _interopRequireDefault(_cursor);
  var _type = req('npm:baobab@2.1.0/dist/type');
  var _type2 = _interopRequireDefault(_type);
  var _helpers = req('npm:baobab@2.1.0/dist/helpers');
  var Watcher = (function(_Emitter) {
    _inherits(Watcher, _Emitter);
    function Watcher(tree, mapping) {
      var _this = this;
      _classCallCheck(this, Watcher);
      _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);
      this.tree = tree;
      this.mapping = null;
      this.state = {killed: false};
      this.refresh(mapping);
      this.handler = function(e) {
        if (_this.state.killed)
          return;
        var watchedPaths = _this.getWatchedPaths();
        if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths))
          return _this.emit('update');
      };
      this.tree.on('update', this.handler);
    }
    _createClass(Watcher, [{
      key: 'getWatchedPaths',
      value: function getWatchedPaths() {
        var _this2 = this;
        var rawPaths = Object.keys(this.mapping).map(function(k) {
          var v = _this2.mapping[k];
          if (v instanceof _cursor2['default'])
            return v.solvedPath;
          else
            return _this2.mapping[k];
        });
        return rawPaths.reduce(function(cp, p) {
          if (_type2['default'].dynamicPath(p))
            p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;
          if (!p)
            return cp;
          var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);
          if (monkeyPath)
            return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, p).data.relatedPaths());
          return cp.concat([p]);
        }, []);
      }
    }, {
      key: 'getCursors',
      value: function getCursors() {
        var _this3 = this;
        var cursors = {};
        Object.keys(this.mapping).forEach(function(k) {
          var path = _this3.mapping[k];
          if (path instanceof _cursor2['default'])
            cursors[k] = path;
          else
            cursors[k] = _this3.tree.select(path);
        });
        return cursors;
      }
    }, {
      key: 'refresh',
      value: function refresh(mapping) {
        if (!_type2['default'].watcherMapping(mapping))
          throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', {mapping: mapping});
        this.mapping = mapping;
        var projection = {};
        for (var k in mapping) {
          projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];
        }
        this.get = this.tree.project.bind(this.tree, projection);
      }
    }, {
      key: 'release',
      value: function release() {
        this.tree.off('update', this.handler);
        this.state.killed = true;
        this.kill();
      }
    }]);
    return Watcher;
  })(_emmett2['default']);
  exports['default'] = Watcher;
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@2.1.0/dist/baobab", ["npm:emmett@3.1.1", "npm:baobab@2.1.0/dist/cursor", "npm:baobab@2.1.0/dist/monkey", "npm:baobab@2.1.0/dist/watcher", "npm:baobab@2.1.0/dist/type", "npm:baobab@2.1.0/dist/update", "npm:baobab@2.1.0/dist/helpers"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  var _get = function get(_x3, _x4, _x5) {
    var _again = true;
    _function: while (_again) {
      var object = _x3,
          property = _x4,
          receiver = _x5;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x3 = parent;
          _x4 = property;
          _x5 = receiver;
          _again = true;
          continue _function;
        }
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj['default'] = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var _emmett = req('npm:emmett@3.1.1');
  var _emmett2 = _interopRequireDefault(_emmett);
  var _cursor = req('npm:baobab@2.1.0/dist/cursor');
  var _cursor2 = _interopRequireDefault(_cursor);
  var _monkey = req('npm:baobab@2.1.0/dist/monkey');
  var _watcher = req('npm:baobab@2.1.0/dist/watcher');
  var _watcher2 = _interopRequireDefault(_watcher);
  var _type = req('npm:baobab@2.1.0/dist/type');
  var _type2 = _interopRequireDefault(_type);
  var _update2 = req('npm:baobab@2.1.0/dist/update');
  var _update3 = _interopRequireDefault(_update2);
  var _helpers = req('npm:baobab@2.1.0/dist/helpers');
  var helpers = _interopRequireWildcard(_helpers);
  var arrayFrom = helpers.arrayFrom;
  var coercePath = helpers.coercePath;
  var deepFreeze = helpers.deepFreeze;
  var getIn = helpers.getIn;
  var makeError = helpers.makeError;
  var deepMerge = helpers.deepMerge;
  var pathObject = helpers.pathObject;
  var shallowClone = helpers.shallowClone;
  var shallowMerge = helpers.shallowMerge;
  var uniqid = helpers.uniqid;
  var DEFAULTS = {
    autoCommit: true,
    asynchronous: true,
    immutable: true,
    lazyMonkeys: true,
    persistent: true,
    pure: true,
    validate: null,
    validationBehavior: 'rollback'
  };
  function hashPath(path) {
    return '/' + path.map(function(step) {
      if (_type2['default']['function'](step) || _type2['default'].object(step))
        return '#' + uniqid() + '#';
      else
        return step;
    }).join('/');
  }
  var Baobab = (function(_Emitter) {
    _inherits(Baobab, _Emitter);
    function Baobab(initialData, opts) {
      var _this = this;
      _classCallCheck(this, Baobab);
      _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);
      if (arguments.length < 1)
        initialData = {};
      if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData))
        throw makeError('Baobab: invalid data.', {data: initialData});
      this.options = shallowMerge({}, DEFAULTS, opts);
      if (!this.options.persistent) {
        this.options.immutable = false;
        this.options.pure = false;
      }
      this._identity = '[object Baobab]';
      this._cursors = {};
      this._future = null;
      this._transaction = [];
      this._affectedPathsIndex = {};
      this._monkeys = {};
      this._previousData = null;
      this._data = initialData;
      this.root = new _cursor2['default'](this, [], '/');
      delete this.root.release;
      if (this.options.immutable)
        deepFreeze(this._data);
      var bootstrap = function bootstrap(name) {
        _this[name] = function() {
          var r = this.root[name].apply(this.root, arguments);
          return r instanceof _cursor2['default'] ? this : r;
        };
      };
      ['apply', 'concat', 'deepMerge', 'exists', 'get', 'push', 'merge', 'project', 'serialize', 'set', 'splice', 'unset', 'unshift'].forEach(bootstrap);
      this._refreshMonkeys();
      var validationError = this.validate();
      if (validationError)
        throw Error('Baobab: invalid data.', {error: validationError});
    }
    _createClass(Baobab, [{
      key: '_refreshMonkeys',
      value: function _refreshMonkeys(node, path, operation) {
        var _this2 = this;
        var clean = function clean(data) {
          var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
          if (data instanceof _monkey.Monkey) {
            data.release();
            (0, _update3['default'])(_this2._monkeys, p, {type: 'unset'}, {
              immutable: false,
              persistent: false,
              pure: false
            });
            return;
          }
          if (_type2['default'].object(data)) {
            for (var k in data) {
              clean(data[k], p.concat(k));
            }
          }
        };
        var register = [];
        var walk = function walk(data) {
          var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
          if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {
            var monkey = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);
            register.push(monkey);
            (0, _update3['default'])(_this2._monkeys, p, {
              type: 'set',
              value: monkey
            }, {
              immutable: false,
              persistent: false,
              pure: false
            });
            return;
          }
          if (_type2['default'].object(data)) {
            for (var k in data) {
              walk(data[k], p.concat(k));
            }
          }
        };
        if (!arguments.length) {
          walk(this._data);
          register.forEach(function(m) {
            return m.checkRecursivity();
          });
        } else {
          var monkeysNode = getIn(this._monkeys, path).data;
          if (monkeysNode)
            clean(monkeysNode, path);
          if (operation !== 'unset') {
            walk(node, path);
            register.forEach(function(m) {
              return m.checkRecursivity();
            });
          }
        }
        return this;
      }
    }, {
      key: 'validate',
      value: function validate(affectedPaths) {
        var _options = this.options;
        var validate = _options.validate;
        var behavior = _options.validationBehavior;
        if (typeof validate !== 'function')
          return null;
        var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);
        if (error instanceof Error) {
          if (behavior === 'rollback') {
            this._data = this._previousData;
            this._affectedPathsIndex = {};
            this._transaction = [];
            this._previousData = this._data;
          }
          this.emit('invalid', {error: error});
          return error;
        }
        return null;
      }
    }, {
      key: 'select',
      value: function select(path) {
        path = path || [];
        if (arguments.length > 1)
          path = arrayFrom(arguments);
        if (!_type2['default'].path(path))
          throw makeError('Baobab.select: invalid path.', {path: path});
        path = [].concat(path);
        var hash = hashPath(path);
        var cursor = this._cursors[hash];
        if (!cursor) {
          cursor = new _cursor2['default'](this, path, hash);
          this._cursors[hash] = cursor;
        }
        this.emit('select', {
          path: path,
          cursor: cursor
        });
        return cursor;
      }
    }, {
      key: 'update',
      value: function update(path, operation) {
        var _this3 = this;
        path = coercePath(path);
        if (!_type2['default'].operationType(operation.type))
          throw makeError('Baobab.update: unknown operation type "' + operation.type + '".', {operation: operation});
        var _getIn = getIn(this._data, path);
        var solvedPath = _getIn.solvedPath;
        var exists = _getIn.exists;
        if (!solvedPath)
          throw makeError('Baobab.update: could not solve the given path.', {path: solvedPath});
        var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);
        if (monkeyPath && solvedPath.length > monkeyPath.length)
          throw makeError('Baobab.update: attempting to update a read-only path.', {path: solvedPath});
        if (operation.type === 'unset' && !exists)
          return;
        var realOperation = operation;
        if (/merge/.test(operation.type)) {
          var monkeysNode = getIn(this._monkeys, solvedPath).data;
          if (_type2['default'].object(monkeysNode)) {
            realOperation = shallowClone(realOperation);
            if (/deep/.test(realOperation.type))
              realOperation.value = deepMerge({}, monkeysNode, realOperation.value);
            else
              realOperation.value = shallowMerge({}, monkeysNode, realOperation.value);
          }
        }
        if (!this._transaction.length)
          this._previousData = this._data;
        var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);
        var data = result.data;
        var node = result.node;
        if (!('data' in result))
          return node;
        var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);
        var hash = hashPath(affectedPath);
        this._data = data;
        this._affectedPathsIndex[hash] = true;
        this._transaction.push(_extends({}, operation, {path: affectedPath}));
        this._refreshMonkeys(node, solvedPath, operation.type);
        this.emit('write', {path: affectedPath});
        if (!this.options.autoCommit)
          return node;
        if (!this.options.asynchronous) {
          this.commit();
          return node;
        }
        if (!this._future)
          this._future = setTimeout(function() {
            return _this3.commit();
          }, 0);
        return node;
      }
    }, {
      key: 'commit',
      value: function commit() {
        if (this._future)
          this._future = clearTimeout(this._future);
        var affectedPaths = Object.keys(this._affectedPathsIndex).map(function(h) {
          return h !== '/' ? h.split('/').slice(1) : [];
        });
        var validationError = this.validate(affectedPaths);
        if (validationError)
          return this;
        var transaction = this._transaction,
            previousData = this._previousData;
        this._affectedPathsIndex = {};
        this._transaction = [];
        this._previousData = this._data;
        this.emit('update', {
          paths: affectedPaths,
          currentData: this._data,
          transaction: transaction,
          previousData: previousData
        });
        return this;
      }
    }, {
      key: 'watch',
      value: function watch(mapping) {
        return new _watcher2['default'](this, mapping);
      }
    }, {
      key: 'release',
      value: function release() {
        var k = undefined;
        this.emit('release');
        delete this.root;
        delete this._data;
        delete this._previousData;
        delete this._transaction;
        delete this._affectedPathsIndex;
        delete this._monkeys;
        for (k in this._cursors)
          this._cursors[k].release();
        delete this._cursors;
        this.kill();
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.serialize();
      }
    }, {
      key: 'toString',
      value: function toString() {
        return this._identity;
      }
    }]);
    return Baobab;
  })(_emmett2['default']);
  exports['default'] = Baobab;
  Baobab.monkey = function() {
    for (var _len = arguments.length,
        args = Array(_len),
        _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (!args.length)
      throw new Error('Baobab.monkey: missing definition.');
    if (args.length === 1)
      return new _monkey.MonkeyDefinition(args[0]);
    else
      return new _monkey.MonkeyDefinition(args);
  };
  Baobab.dynamicNode = Baobab.monkey;
  Baobab.Cursor = _cursor2['default'];
  Baobab.MonkeyDefinition = _monkey.MonkeyDefinition;
  Baobab.Monkey = _monkey.Monkey;
  Baobab.type = _type2['default'];
  Baobab.helpers = helpers;
  Object.defineProperty(Baobab, 'version', {value: '2.1.0'});
  exports['default'] = Baobab;
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:baobab@2.1.0", ["npm:baobab@2.1.0/dist/baobab"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:baobab@2.1.0/dist/baobab');
  global.define = __define;
  return module.exports;
});

System.register('libraries/baobab/baobab.js', ['github:angular/bower-angular@1.4.7', 'npm:baobab@2.1.0'], function (_export) {
  'use strict';

  var angular, Baobab;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_npmBaobab210) {
      Baobab = _npmBaobab210['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.baobab', []).factory('Baobab', /*@ngInject*/function () {
        return Baobab;
      }));
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var util = forge.util = forge.util || {};
    (function() {
      if (typeof process !== 'undefined' && process.nextTick) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === 'function') {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === 'function') {
        util.setImmediate = setImmediate;
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== 'undefined' && typeof window.postMessage === 'function') {
        var msg = 'forge.setImmediate';
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, '*');
          }
        };
        function handler(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        }
        window.addEventListener('message', handler, true);
      }
      if (typeof MutationObserver !== 'undefined') {
        var now = Date.now();
        var attr = true;
        var div = document.createElement('div');
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, {attributes: true});
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute('a', attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === '[object Array]';
    };
    util.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x) {
      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
    };
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = '';
      this.read = 0;
      if (typeof b === 'string') {
        this.data = b;
      } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
        var arr = new Uint8Array(b);
        try {
          this.data = String.fromCharCode.apply(null, arr);
        } catch (e) {
          for (var i = 0; i < arr.length; ++i) {
            this.putByte(arr[i]);
          }
        }
      } else if (b instanceof ByteStringBuffer || (typeof b === 'object' && typeof b.data === 'string' && typeof b.read === 'number')) {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF));
    };
    util.ByteStringBuffer.prototype.putInt = function(i, n) {
      var bytes = '';
      do {
        n -= 8;
        bytes += String.fromCharCode((i >> n) & 0xFF);
      } while (n > 0);
      return this.putBytes(bytes);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << (n - 1);
      }
      return this.putInt(i, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = (this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1));
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = (this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2));
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = (this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3));
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = (this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = (this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = (this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << (n - 2);
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = '';
      } else {
        rval = (this.read === 0) ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return (typeof(count) === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count));
    };
    util.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util.ByteStringBuffer.prototype.setAt = function(i, b) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = '';
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = '';
      for (var i = this.read; i < this.data.length; ++i) {
        var b = this.data.charCodeAt(i);
        if (b < 16) {
          rval += '0';
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b);
      var isArrayBufferView = util.isArrayBufferView(b);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = ('writeOffset' in options ? options.writeOffset : this.data.byteLength);
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== undefined) {
        this.putBytes(b);
      }
      if ('writeOffset' in options) {
        this.write = options.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util.isArrayBufferView(bytes)) {
        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes)) {
        var src = new Uint8Array(bytes);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.DataBuffer || (typeof bytes === 'object' && typeof bytes.read === 'number' && typeof bytes.write === 'number' && util.isArrayBufferView(bytes.data))) {
        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = 'binary';
      }
      encoding = encoding || 'binary';
      if (typeof bytes === 'string') {
        var view;
        if (encoding === 'hex') {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === 'base64') {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === 'utf8') {
          bytes = util.encodeUtf8(bytes);
          encoding = 'binary';
        }
        if (encoding === 'binary' || encoding === 'raw') {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === 'utf16') {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error('Invalid encoding: ' + encoding);
      }
      throw Error('Invalid parameter: ' + bytes);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, 'utf16');
    };
    util.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 0xFFFF);
      this.data.setInt8(this.write, i >> 16 & 0xFF);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 0xFF);
      this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i, n) {
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, (i >> n) & 0xFF);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i, n) {
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << (n - 1);
      }
      return this.putInt(i, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = (this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2));
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = (this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << (n - 2);
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = '';
      } else {
        rval = (this.read === 0) ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return (typeof(count) === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count));
    };
    util.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util.DataBuffer.prototype.setAt = function(i, b) {
      this.data.setUint8(i, b);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = '';
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b = this.data.getUint8(i);
        if (b < 16) {
          rval += '0';
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || 'utf8';
      if (encoding === 'binary' || encoding === 'raw') {
        return util.binary.raw.encode(view);
      }
      if (encoding === 'hex') {
        return util.binary.hex.encode(view);
      }
      if (encoding === 'base64') {
        return util.binary.base64.encode(view);
      }
      if (encoding === 'utf8') {
        return util.text.utf8.decode(view);
      }
      if (encoding === 'utf16') {
        return util.text.utf16.decode(view);
      }
      throw new Error('Invalid encoding: ' + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || 'raw';
      if (input !== undefined && encoding === 'utf8') {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n) {
      var s = '';
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = '';
      var b = '';
      var t = '';
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = '';
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = '';
      var i = 0;
      if (hex.length & 1 == 1) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes) {
      return util.createBuffer(bytes).toHex();
    };
    util.int32ToBytes = function(i) {
      return (String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
    };
    var _base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var _base64Idx = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
    util.encode64 = function(input, maxline) {
      var line = '';
      var output = '';
      var chr1,
          chr2,
          chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
        if (isNaN(chr2)) {
          line += '==';
        } else {
          line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
          line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + '\r\n';
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
      var output = '';
      var enc1,
          enc2,
          enc3,
          enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));
        if (enc3 !== 64) {
          output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));
          if (enc4 !== 64) {
            output += String.fromCharCode(((enc3 & 3) << 6) | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {}
    };
    util.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? (j - offset) : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0,
          j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output ? (j - offset) : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = '';
      var output = '';
      var chr1,
          chr2,
          chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
        if (isNaN(chr2)) {
          line += '==';
        } else {
          line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
          line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + '\r\n';
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
      offset = offset || 0;
      var enc1,
          enc2,
          enc3,
          enc4;
      var i = 0,
          j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = (enc1 << 2) | (enc2 >> 4);
        if (enc3 !== 64) {
          out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);
          if (enc4 !== 64) {
            out[j++] = ((enc3 & 3) << 6) | enc4;
          }
        }
      }
      return output ? (j - offset) : out.subarray(0, j);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? (j - offset) : out;
    };
    util.text.utf8.decode = function(bytes) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      var view = new Uint16Array(out);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output ? (j - offset) : out;
    };
    util.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes));
    };
    util.deflate = function(api, bytes, raw) {
      bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 0x20) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util.encode64(bytes)).rval;
      return (rval === null) ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error('WebStorage not available.');
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof(rval) !== 'undefined' && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error('WebStorage not available.');
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = (key in rval) ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty = true;
        for (var prop in obj) {
          empty = false;
          break;
        }
        if (empty) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof(location) === 'undefined') {
        location = ['web', 'flash'];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === 'flash' || type === 'both') {
            if (args[0] === null) {
              throw new Error('Flash local storage not available.');
            }
            rval = func.apply(this, args);
            done = (type === 'flash');
          }
          if (type === 'web' || type === 'both') {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util.getItem = function(api, id, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util.removeItem = function(api, id, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util.clearItems = function(api, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util.parseUrl = function(str) {
      var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
      regex.lastIndex = 0;
      var m = regex.exec(str);
      var url = (m === null) ? null : {
        full: str,
        scheme: m[1],
        host: m[2],
        port: m[3],
        path: m[4]
      };
      if (url) {
        url.fullHost = url.host;
        if (url.port) {
          if (url.port !== 80 && url.scheme === 'http') {
            url.fullHost += ':' + url.port;
          } else if (url.port !== 443 && url.scheme === 'https') {
            url.fullHost += ':' + url.port;
          }
        } else if (url.scheme === 'http') {
          url.port = 80;
        } else if (url.scheme === 'https') {
          url.port = 443;
        }
        url.full = url.scheme + '://' + url.fullHost;
      }
      return url;
    };
    var _queryVariables = null;
    util.getQueryVariables = function(query) {
      var parse = function(q) {
        var rval = {};
        var kvpairs = q.split('&');
        for (var i = 0; i < kvpairs.length; i++) {
          var pos = kvpairs[i].indexOf('=');
          var key;
          var val;
          if (pos > 0) {
            key = kvpairs[i].substring(0, pos);
            val = kvpairs[i].substring(pos + 1);
          } else {
            key = kvpairs[i];
            val = null;
          }
          if (!(key in rval)) {
            rval[key] = [];
          }
          if (!(key in Object.prototype) && val !== null) {
            rval[key].push(unescape(val));
          }
        }
        return rval;
      };
      var rval;
      if (typeof(query) === 'undefined') {
        if (_queryVariables === null) {
          if (typeof(window) !== 'undefined' && window.location && window.location.search) {
            _queryVariables = parse(window.location.search.substring(1));
          } else {
            _queryVariables = {};
          }
        }
        rval = _queryVariables;
      } else {
        rval = parse(query);
      }
      return rval;
    };
    util.parseFragment = function(fragment) {
      var fp = fragment;
      var fq = '';
      var pos = fragment.indexOf('?');
      if (pos > 0) {
        fp = fragment.substring(0, pos);
        fq = fragment.substring(pos + 1);
      }
      var path = fp.split('/');
      if (path.length > 0 && path[0] === '') {
        path.shift();
      }
      var query = (fq === '') ? {} : util.getQueryVariables(fq);
      return {
        pathString: fp,
        queryString: fq,
        path: path,
        query: query
      };
    };
    util.makeRequest = function(reqString) {
      var frag = util.parseFragment(reqString);
      var req = {
        path: frag.pathString,
        query: frag.queryString,
        getPath: function(i) {
          return (typeof(i) === 'undefined') ? frag.path : frag.path[i];
        },
        getQuery: function(k, i) {
          var rval;
          if (typeof(k) === 'undefined') {
            rval = frag.query;
          } else {
            rval = frag.query[k];
            if (rval && typeof(i) !== 'undefined') {
              rval = rval[i];
            }
          }
          return rval;
        },
        getQueryLast: function(k, _default) {
          var rval;
          var vals = req.getQuery(k);
          if (vals) {
            rval = vals[vals.length - 1];
          } else {
            rval = _default;
          }
          return rval;
        }
      };
      return req;
    };
    util.makeLink = function(path, query, fragment) {
      path = jQuery.isArray(path) ? path.join('/') : path;
      var qstr = jQuery.param(query || {});
      fragment = fragment || '';
      return path + ((qstr.length > 0) ? ('?' + qstr) : '') + ((fragment.length > 0) ? ('#' + fragment) : '');
    };
    util.setPath = function(object, keys, value) {
      if (typeof(object) === 'object' && object !== null) {
        var i = 0;
        var len = keys.length;
        while (i < len) {
          var next = keys[i++];
          if (i == len) {
            object[next] = value;
          } else {
            var hasNext = (next in object);
            if (!hasNext || (hasNext && typeof(object[next]) !== 'object') || (hasNext && object[next] === null)) {
              object[next] = {};
            }
            object = object[next];
          }
        }
      }
    };
    util.getPath = function(object, keys, _default) {
      var i = 0;
      var len = keys.length;
      var hasNext = true;
      while (hasNext && i < len && typeof(object) === 'object' && object !== null) {
        var next = keys[i++];
        hasNext = next in object;
        if (hasNext) {
          object = object[next];
        }
      }
      return (hasNext ? object : _default);
    };
    util.deletePath = function(object, keys) {
      if (typeof(object) === 'object' && object !== null) {
        var i = 0;
        var len = keys.length;
        while (i < len) {
          var next = keys[i++];
          if (i == len) {
            delete object[next];
          } else {
            if (!(next in object) || (typeof(object[next]) !== 'object') || (object[next] === null)) {
              break;
            }
            object = object[next];
          }
        }
      }
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while ((match = re.exec(format))) {
        part = format.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code = match[0][1];
        switch (code) {
          case 's':
          case 'o':
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push('<?>');
            }
            break;
          case '%':
            parts.push('%');
            break;
          default:
            parts.push('<%' + code + '?>');
        }
      }
      parts.push(format.substring(last));
      return parts.join('');
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number,
          c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === undefined ? ',' : dec_point;
      var t = thousands_sep === undefined ? '.' : thousands_sep,
          s = n < 0 ? '-' : '';
      var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';
      var j = (i.length > 3) ? i.length % 3 : 0;
      return s + (j ? i.substr(0, j) + t : '') + i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + ' KiB';
      } else {
        size = util.formatNumber(size, 0) + ' bytes';
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf('.') !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(':') !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split('.');
      if (ip.length !== 4) {
        return null;
      }
      var b = util.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(':').filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util.hexToBytes(ip[i]);
        if (bytes.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes);
      }
      return b.getBytes();
    };
    util.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util.bytesToIPv6(bytes);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes.length; ++i) {
        ip.push(bytes.charCodeAt(i));
      }
      return ip.join('.');
    };
    util.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes.length; i += 2) {
        var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
        while (hex[0] === '0' && hex !== '0') {
          hex = hex.substr(1);
        }
        if (hex === '0') {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({
              start: idx,
              end: idx
            });
          } else {
            last.end = idx;
            if ((last.end - last.start) > (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, '');
          if (group.start === 0) {
            ip.unshift('');
          }
          if (group.end === 7) {
            ip.push('');
          }
        }
      }
      return ip.join(':');
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      if ('cores' in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== 'undefined' && 'hardwareConcurrency' in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === 'undefined') {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === 'undefined') {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob(['(', function() {
        self.addEventListener('message', function(e) {
          var st = Date.now();
          var et = st + 4;
          while (Date.now() < et)
            ;
          self.postMessage({
            st: st,
            et: et
          });
        });
      }.toString(), ')()'], {type: 'application/javascript'}));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg, x) {
            return avg + x;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map(numWorkers, callback) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener('message', function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i = 0; i < numWorkers; ++i) {
                workers[i].terminate();
              }
              callback(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if ((r1.st > r2.st && r1.st < r2.et) || (r2.st > r1.st && r2.st < r1.et)) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap) {
          return Math.max(max, overlap.length);
        }, 0);
      }
    };
  }
  var name = 'util';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/util", ["require", "module"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === 'string') {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error('Unsupported algorithm: ' + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key: key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === 'string') {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error('Unsupported algorithm: ' + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key: key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name, algorithm) {
      name = name.toUpperCase();
      forge.cipher.algorithms[name] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name) {
      name = name.toUpperCase();
      if (name in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {}
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
  var name = 'cipher';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/cipher", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.cipher = forge.cipher || {};
    var modes = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = 'ECB';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {};
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = (input.length() === this.blockSize ? this.blockSize : (this.blockSize - input.length()));
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > (this.blockSize << 2)) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = 'CBC';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error('Invalid IV parameter.');
        }
        this._iv = this._prev.slice(0);
      } else if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      } else {
        this._iv = transformIV(options.iv);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = (input.length() === this.blockSize ? this.blockSize : (this.blockSize - input.length()));
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > (this.blockSize << 2)) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = 'CFB';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = 'OFB';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = 'CTR';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = 'GCM';
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 0xE1000000;
    };
    modes.gcm.prototype.start = function(options) {
      if (!('iv' in options)) {
        throw new Error('Invalid IV parameter.');
      }
      var iv = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ('additionalData' in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ('tagLength' in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== (this._tagLength / 8)) {
          throw new Error('Authentication tag does not match tag length.');
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
        }
        this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes === 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = (i / 8) | 0;
        var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;
        var ah = this._m[i][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = (i / perInt) | 0;
        var shft = ((perInt - 1 - (i % perInt)) * bits);
        tmp[idx] = (1 << (bits - 1)) << shft;
        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m[2 * i], m[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m[i];
          var m_j = m[j];
          m[i + j] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];
        }
        i *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m[i ^ half];
        m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv) {
      if (typeof iv === 'string') {
        iv = forge.util.createBuffer(iv);
      }
      if (forge.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (!forge.util.isArray(iv)) {
        iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;
    }
    function from64To32(num) {
      return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];
    }
  }
  var name = 'cipherModes';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/cipherModes", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key: key,
        output: output,
        decrypt: false,
        mode: mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key: key,
        output: null,
        decrypt: false,
        mode: mode
      });
    };
    forge.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key: key,
        output: output,
        decrypt: true,
        mode: mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key: key,
        output: null,
        decrypt: true,
        mode: mode
      });
    };
    forge.aes.Algorithm = function(name, mode) {
      if (!init) {
        initialize();
      }
      var self = this;
      self.name = name;
      self.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self._w, inBlock, outBlock, true);
          }
        }
      });
      self._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === 'string' && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error('Invalid key parameter.');
      }
      var mode = this.mode.name;
      var encryptOp = (['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm('AES-ECB', forge.cipher.modes.ecb);
    registerAlgorithm('AES-CBC', forge.cipher.modes.cbc);
    registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
    registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
    registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
    registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge.aes.Algorithm(name, mode);
      };
      forge.cipher.registerAlgorithm(name, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = (i + 128) << 1 ^ 0x11B;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0,
          ei = 0,
          e2,
          e4,
          e8,
          sx,
          sx2,
          me,
          ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ (ei << 1) ^ (ei << 2) ^ (ei << 3) ^ (ei << 4);
        sx = (sx >> 8) ^ (sx & 255) ^ 0x63;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = (sx2 << 24) ^ (sx << 16) ^ (sx << 8) ^ (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt) {
      var w = key.slice(0);
      var temp,
          iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ (rcon[iNk] << 24);
          iNk++;
        } else if (Nk > 6 && (i % Nk === 4)) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i] = w[i - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i = 0,
            wi = end - Nb; i < end; i += Nb, wi -= Nb) {
          if (i === 0 || i === (end - Nb)) {
            wnew[i] = w[wi];
            wnew[i + 1] = w[wi + 3];
            wnew[i + 2] = w[wi + 2];
            wnew[i + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt) {
      var Nr = w.length / 4 - 1;
      var m0,
          m1,
          m2,
          m3,
          sub;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a,
          b,
          c,
          d,
          a2,
          b2,
          c2;
      a = input[0] ^ w[0];
      b = input[decrypt ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt ? 1 : 3] ^ w[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = (sub[a >>> 24] << 24) ^ (sub[b >>> 16 & 255] << 16) ^ (sub[c >>> 8 & 255] << 8) ^ (sub[d & 255]) ^ w[++i];
      output[decrypt ? 3 : 1] = (sub[b >>> 24] << 24) ^ (sub[c >>> 16 & 255] << 16) ^ (sub[d >>> 8 & 255] << 8) ^ (sub[a & 255]) ^ w[++i];
      output[2] = (sub[c >>> 24] << 24) ^ (sub[d >>> 16 & 255] << 16) ^ (sub[a >>> 8 & 255] << 8) ^ (sub[b & 255]) ^ w[++i];
      output[decrypt ? 1 : 3] = (sub[d >>> 24] << 24) ^ (sub[a >>> 16 & 255] << 16) ^ (sub[b >>> 8 & 255] << 8) ^ (sub[c & 255]) ^ w[++i];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || 'CBC').toUpperCase();
      var algorithm = 'AES-' + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options) {
        var output = null;
        if (options instanceof forge.util.ByteBuffer) {
          output = options;
          options = {};
        }
        options = options || {};
        options.output = output;
        options.iv = iv;
        start.call(cipher, options);
      };
      return cipher;
    }
  }
  var name = 'aes';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/aes", ["require", "module", "npm:node-forge@0.6.35/js/cipher", "npm:node-forge@0.6.35/js/cipherModes", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.pki = forge.pki || {};
    var oids = forge.pki.oids = forge.oids = forge.oids || {};
    oids['1.2.840.113549.1.1.1'] = 'rsaEncryption';
    oids['rsaEncryption'] = '1.2.840.113549.1.1.1';
    oids['1.2.840.113549.1.1.4'] = 'md5WithRSAEncryption';
    oids['md5WithRSAEncryption'] = '1.2.840.113549.1.1.4';
    oids['1.2.840.113549.1.1.5'] = 'sha1WithRSAEncryption';
    oids['sha1WithRSAEncryption'] = '1.2.840.113549.1.1.5';
    oids['1.2.840.113549.1.1.7'] = 'RSAES-OAEP';
    oids['RSAES-OAEP'] = '1.2.840.113549.1.1.7';
    oids['1.2.840.113549.1.1.8'] = 'mgf1';
    oids['mgf1'] = '1.2.840.113549.1.1.8';
    oids['1.2.840.113549.1.1.9'] = 'pSpecified';
    oids['pSpecified'] = '1.2.840.113549.1.1.9';
    oids['1.2.840.113549.1.1.10'] = 'RSASSA-PSS';
    oids['RSASSA-PSS'] = '1.2.840.113549.1.1.10';
    oids['1.2.840.113549.1.1.11'] = 'sha256WithRSAEncryption';
    oids['sha256WithRSAEncryption'] = '1.2.840.113549.1.1.11';
    oids['1.2.840.113549.1.1.12'] = 'sha384WithRSAEncryption';
    oids['sha384WithRSAEncryption'] = '1.2.840.113549.1.1.12';
    oids['1.2.840.113549.1.1.13'] = 'sha512WithRSAEncryption';
    oids['sha512WithRSAEncryption'] = '1.2.840.113549.1.1.13';
    oids['1.3.14.3.2.7'] = 'desCBC';
    oids['desCBC'] = '1.3.14.3.2.7';
    oids['1.3.14.3.2.26'] = 'sha1';
    oids['sha1'] = '1.3.14.3.2.26';
    oids['2.16.840.1.101.3.4.2.1'] = 'sha256';
    oids['sha256'] = '2.16.840.1.101.3.4.2.1';
    oids['2.16.840.1.101.3.4.2.2'] = 'sha384';
    oids['sha384'] = '2.16.840.1.101.3.4.2.2';
    oids['2.16.840.1.101.3.4.2.3'] = 'sha512';
    oids['sha512'] = '2.16.840.1.101.3.4.2.3';
    oids['1.2.840.113549.2.5'] = 'md5';
    oids['md5'] = '1.2.840.113549.2.5';
    oids['1.2.840.113549.1.7.1'] = 'data';
    oids['data'] = '1.2.840.113549.1.7.1';
    oids['1.2.840.113549.1.7.2'] = 'signedData';
    oids['signedData'] = '1.2.840.113549.1.7.2';
    oids['1.2.840.113549.1.7.3'] = 'envelopedData';
    oids['envelopedData'] = '1.2.840.113549.1.7.3';
    oids['1.2.840.113549.1.7.4'] = 'signedAndEnvelopedData';
    oids['signedAndEnvelopedData'] = '1.2.840.113549.1.7.4';
    oids['1.2.840.113549.1.7.5'] = 'digestedData';
    oids['digestedData'] = '1.2.840.113549.1.7.5';
    oids['1.2.840.113549.1.7.6'] = 'encryptedData';
    oids['encryptedData'] = '1.2.840.113549.1.7.6';
    oids['1.2.840.113549.1.9.1'] = 'emailAddress';
    oids['emailAddress'] = '1.2.840.113549.1.9.1';
    oids['1.2.840.113549.1.9.2'] = 'unstructuredName';
    oids['unstructuredName'] = '1.2.840.113549.1.9.2';
    oids['1.2.840.113549.1.9.3'] = 'contentType';
    oids['contentType'] = '1.2.840.113549.1.9.3';
    oids['1.2.840.113549.1.9.4'] = 'messageDigest';
    oids['messageDigest'] = '1.2.840.113549.1.9.4';
    oids['1.2.840.113549.1.9.5'] = 'signingTime';
    oids['signingTime'] = '1.2.840.113549.1.9.5';
    oids['1.2.840.113549.1.9.6'] = 'counterSignature';
    oids['counterSignature'] = '1.2.840.113549.1.9.6';
    oids['1.2.840.113549.1.9.7'] = 'challengePassword';
    oids['challengePassword'] = '1.2.840.113549.1.9.7';
    oids['1.2.840.113549.1.9.8'] = 'unstructuredAddress';
    oids['unstructuredAddress'] = '1.2.840.113549.1.9.8';
    oids['1.2.840.113549.1.9.14'] = 'extensionRequest';
    oids['extensionRequest'] = '1.2.840.113549.1.9.14';
    oids['1.2.840.113549.1.9.20'] = 'friendlyName';
    oids['friendlyName'] = '1.2.840.113549.1.9.20';
    oids['1.2.840.113549.1.9.21'] = 'localKeyId';
    oids['localKeyId'] = '1.2.840.113549.1.9.21';
    oids['1.2.840.113549.1.9.22.1'] = 'x509Certificate';
    oids['x509Certificate'] = '1.2.840.113549.1.9.22.1';
    oids['1.2.840.113549.1.12.10.1.1'] = 'keyBag';
    oids['keyBag'] = '1.2.840.113549.1.12.10.1.1';
    oids['1.2.840.113549.1.12.10.1.2'] = 'pkcs8ShroudedKeyBag';
    oids['pkcs8ShroudedKeyBag'] = '1.2.840.113549.1.12.10.1.2';
    oids['1.2.840.113549.1.12.10.1.3'] = 'certBag';
    oids['certBag'] = '1.2.840.113549.1.12.10.1.3';
    oids['1.2.840.113549.1.12.10.1.4'] = 'crlBag';
    oids['crlBag'] = '1.2.840.113549.1.12.10.1.4';
    oids['1.2.840.113549.1.12.10.1.5'] = 'secretBag';
    oids['secretBag'] = '1.2.840.113549.1.12.10.1.5';
    oids['1.2.840.113549.1.12.10.1.6'] = 'safeContentsBag';
    oids['safeContentsBag'] = '1.2.840.113549.1.12.10.1.6';
    oids['1.2.840.113549.1.5.13'] = 'pkcs5PBES2';
    oids['pkcs5PBES2'] = '1.2.840.113549.1.5.13';
    oids['1.2.840.113549.1.5.12'] = 'pkcs5PBKDF2';
    oids['pkcs5PBKDF2'] = '1.2.840.113549.1.5.12';
    oids['1.2.840.113549.1.12.1.1'] = 'pbeWithSHAAnd128BitRC4';
    oids['pbeWithSHAAnd128BitRC4'] = '1.2.840.113549.1.12.1.1';
    oids['1.2.840.113549.1.12.1.2'] = 'pbeWithSHAAnd40BitRC4';
    oids['pbeWithSHAAnd40BitRC4'] = '1.2.840.113549.1.12.1.2';
    oids['1.2.840.113549.1.12.1.3'] = 'pbeWithSHAAnd3-KeyTripleDES-CBC';
    oids['pbeWithSHAAnd3-KeyTripleDES-CBC'] = '1.2.840.113549.1.12.1.3';
    oids['1.2.840.113549.1.12.1.4'] = 'pbeWithSHAAnd2-KeyTripleDES-CBC';
    oids['pbeWithSHAAnd2-KeyTripleDES-CBC'] = '1.2.840.113549.1.12.1.4';
    oids['1.2.840.113549.1.12.1.5'] = 'pbeWithSHAAnd128BitRC2-CBC';
    oids['pbeWithSHAAnd128BitRC2-CBC'] = '1.2.840.113549.1.12.1.5';
    oids['1.2.840.113549.1.12.1.6'] = 'pbewithSHAAnd40BitRC2-CBC';
    oids['pbewithSHAAnd40BitRC2-CBC'] = '1.2.840.113549.1.12.1.6';
    oids['1.2.840.113549.3.7'] = 'des-EDE3-CBC';
    oids['des-EDE3-CBC'] = '1.2.840.113549.3.7';
    oids['2.16.840.1.101.3.4.1.2'] = 'aes128-CBC';
    oids['aes128-CBC'] = '2.16.840.1.101.3.4.1.2';
    oids['2.16.840.1.101.3.4.1.22'] = 'aes192-CBC';
    oids['aes192-CBC'] = '2.16.840.1.101.3.4.1.22';
    oids['2.16.840.1.101.3.4.1.42'] = 'aes256-CBC';
    oids['aes256-CBC'] = '2.16.840.1.101.3.4.1.42';
    oids['2.5.4.3'] = 'commonName';
    oids['commonName'] = '2.5.4.3';
    oids['2.5.4.5'] = 'serialName';
    oids['serialName'] = '2.5.4.5';
    oids['2.5.4.6'] = 'countryName';
    oids['countryName'] = '2.5.4.6';
    oids['2.5.4.7'] = 'localityName';
    oids['localityName'] = '2.5.4.7';
    oids['2.5.4.8'] = 'stateOrProvinceName';
    oids['stateOrProvinceName'] = '2.5.4.8';
    oids['2.5.4.10'] = 'organizationName';
    oids['organizationName'] = '2.5.4.10';
    oids['2.5.4.11'] = 'organizationalUnitName';
    oids['organizationalUnitName'] = '2.5.4.11';
    oids['2.16.840.1.113730.1.1'] = 'nsCertType';
    oids['nsCertType'] = '2.16.840.1.113730.1.1';
    oids['2.5.29.1'] = 'authorityKeyIdentifier';
    oids['2.5.29.2'] = 'keyAttributes';
    oids['2.5.29.3'] = 'certificatePolicies';
    oids['2.5.29.4'] = 'keyUsageRestriction';
    oids['2.5.29.5'] = 'policyMapping';
    oids['2.5.29.6'] = 'subtreesConstraint';
    oids['2.5.29.7'] = 'subjectAltName';
    oids['2.5.29.8'] = 'issuerAltName';
    oids['2.5.29.9'] = 'subjectDirectoryAttributes';
    oids['2.5.29.10'] = 'basicConstraints';
    oids['2.5.29.11'] = 'nameConstraints';
    oids['2.5.29.12'] = 'policyConstraints';
    oids['2.5.29.13'] = 'basicConstraints';
    oids['2.5.29.14'] = 'subjectKeyIdentifier';
    oids['subjectKeyIdentifier'] = '2.5.29.14';
    oids['2.5.29.15'] = 'keyUsage';
    oids['keyUsage'] = '2.5.29.15';
    oids['2.5.29.16'] = 'privateKeyUsagePeriod';
    oids['2.5.29.17'] = 'subjectAltName';
    oids['subjectAltName'] = '2.5.29.17';
    oids['2.5.29.18'] = 'issuerAltName';
    oids['issuerAltName'] = '2.5.29.18';
    oids['2.5.29.19'] = 'basicConstraints';
    oids['basicConstraints'] = '2.5.29.19';
    oids['2.5.29.20'] = 'cRLNumber';
    oids['2.5.29.21'] = 'cRLReason';
    oids['2.5.29.22'] = 'expirationDate';
    oids['2.5.29.23'] = 'instructionCode';
    oids['2.5.29.24'] = 'invalidityDate';
    oids['2.5.29.25'] = 'cRLDistributionPoints';
    oids['2.5.29.26'] = 'issuingDistributionPoint';
    oids['2.5.29.27'] = 'deltaCRLIndicator';
    oids['2.5.29.28'] = 'issuingDistributionPoint';
    oids['2.5.29.29'] = 'certificateIssuer';
    oids['2.5.29.30'] = 'nameConstraints';
    oids['2.5.29.31'] = 'cRLDistributionPoints';
    oids['2.5.29.32'] = 'certificatePolicies';
    oids['2.5.29.33'] = 'policyMappings';
    oids['2.5.29.34'] = 'policyConstraints';
    oids['2.5.29.35'] = 'authorityKeyIdentifier';
    oids['2.5.29.36'] = 'policyConstraints';
    oids['2.5.29.37'] = 'extKeyUsage';
    oids['extKeyUsage'] = '2.5.29.37';
    oids['2.5.29.46'] = 'freshestCRL';
    oids['2.5.29.54'] = 'inhibitAnyPolicy';
    oids['1.3.6.1.5.5.7.3.1'] = 'serverAuth';
    oids['serverAuth'] = '1.3.6.1.5.5.7.3.1';
    oids['1.3.6.1.5.5.7.3.2'] = 'clientAuth';
    oids['clientAuth'] = '1.3.6.1.5.5.7.3.2';
    oids['1.3.6.1.5.5.7.3.3'] = 'codeSigning';
    oids['codeSigning'] = '1.3.6.1.5.5.7.3.3';
    oids['1.3.6.1.5.5.7.3.4'] = 'emailProtection';
    oids['emailProtection'] = '1.3.6.1.5.5.7.3.4';
    oids['1.3.6.1.5.5.7.3.8'] = 'timeStamping';
    oids['timeStamping'] = '1.3.6.1.5.5.7.3.8';
  }
  var name = 'oids';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/oids", ["require", "module"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1 = forge.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0x00,
      APPLICATION: 0x40,
      CONTEXT_SPECIFIC: 0x80,
      PRIVATE: 0xC0
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i = 0; i < value.length; ++i) {
          if (value[i] !== undefined) {
            tmp.push(value[i]);
          }
        }
        value = tmp;
      }
      return {
        tagClass: tagClass,
        type: type,
        constructed: constructed,
        composed: constructed || forge.util.isArray(value),
        value: value
      };
    };
    var _getValueLength = asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 0x80) {
        return undefined;
      }
      var length;
      var longForm = b2 & 0x80;
      if (!longForm) {
        length = b2;
      } else {
        length = b.getInt((b2 & 0x7F) << 3);
      }
      return length;
    };
    asn1.fromDer = function(bytes, strict) {
      if (strict === undefined) {
        strict = true;
      }
      if (typeof bytes === 'string') {
        bytes = forge.util.createBuffer(bytes);
      }
      if (bytes.length() < 2) {
        var error = new Error('Too few bytes to parse DER.');
        error.bytes = bytes.length();
        throw error;
      }
      var b1 = bytes.getByte();
      var tagClass = (b1 & 0xC0);
      var type = b1 & 0x1F;
      var length = _getValueLength(bytes);
      if (bytes.length() < length) {
        if (strict) {
          var error = new Error('Too few bytes to read ASN.1 value.');
          error.detail = bytes.length() + ' < ' + length;
          throw error;
        }
        length = bytes.length();
      }
      var value;
      var constructed = ((b1 & 0x20) === 0x20);
      var composed = constructed;
      if (!composed && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) {
        var read = bytes.read;
        var unused = bytes.getByte();
        if (unused === 0) {
          b1 = bytes.getByte();
          var tc = (b1 & 0xC0);
          if (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC) {
            try {
              var len = _getValueLength(bytes);
              composed = (len === length - (bytes.read - read));
              if (composed) {
                ++read;
                --length;
              }
            } catch (ex) {}
          }
        }
        bytes.read = read;
      }
      if (composed) {
        value = [];
        if (length === undefined) {
          for (; ; ) {
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              break;
            }
            value.push(asn1.fromDer(bytes, strict));
          }
        } else {
          var start = bytes.length();
          while (length > 0) {
            value.push(asn1.fromDer(bytes, strict));
            length -= start - bytes.length();
            start = bytes.length();
          }
        }
      } else {
        if (length === undefined) {
          if (strict) {
            throw new Error('Non-constructed ASN.1 object of indefinite length.');
          }
          length = bytes.length();
        }
        if (type === asn1.Type.BMPSTRING) {
          value = '';
          for (var i = 0; i < length; i += 2) {
            value += String.fromCharCode(bytes.getInt16());
          }
        } else {
          value = bytes.getBytes(length);
        }
      }
      return asn1.create(tagClass, type, constructed, value);
    };
    asn1.toDer = function(obj) {
      var bytes = forge.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      if (obj.composed) {
        if (obj.constructed) {
          b1 |= 0x20;
        } else {
          value.putByte(0x00);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== undefined) {
            value.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          value.putBytes(obj.value);
        }
      }
      bytes.putByte(b1);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 0x7F);
      } else {
        var len = value.length();
        var lenBytes = '';
        do {
          lenBytes += String.fromCharCode(len & 0xFF);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 0x80);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split('.');
      var bytes = forge.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last,
          valueBytes,
          value,
          b;
      for (var i = 2; i < values.length; ++i) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i], 10);
        do {
          b = value & 0x7F;
          value = value >>> 7;
          if (!last) {
            b |= 0x80;
          }
          valueBytes.push(b);
          last = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes.putByte(valueBytes[n]);
        }
      }
      return bytes;
    };
    asn1.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === 'string') {
        bytes = forge.util.createBuffer(bytes);
      }
      var b = bytes.getByte();
      oid = Math.floor(b / 40) + '.' + (b % 40);
      var value = 0;
      while (bytes.length() > 0) {
        b = bytes.getByte();
        value = value << 7;
        if (b & 0x80) {
          value += b & 0x7F;
        } else {
          oid += '.' + (value + b);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = (year >= 50) ? 1900 + year : 2000 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== '+' && c !== '-') {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === '+' || c === '-') {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 60000;
          if (c === '+') {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === 'Z') {
        isUTC = true;
      }
      var end = gentime.length - 5,
          c = gentime.charAt(end);
      if (c === '+' || c === '-') {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 60000;
        if (c === '+') {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === '.') {
        fff = parseFloat(gentime.substr(14), 10) * 1000;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === 'string') {
        return date;
      }
      var rval = '';
      var format = [];
      format.push(('' + date.getUTCFullYear()).substr(2));
      format.push('' + (date.getUTCMonth() + 1));
      format.push('' + date.getUTCDate());
      format.push('' + date.getUTCHours());
      format.push('' + date.getUTCMinutes());
      format.push('' + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += '0';
        }
        rval += format[i];
      }
      rval += 'Z';
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === 'string') {
        return date;
      }
      var rval = '';
      var format = [];
      format.push('' + date.getUTCFullYear());
      format.push('' + (date.getUTCMonth() + 1));
      format.push('' + date.getUTCDate());
      format.push('' + date.getUTCHours());
      format.push('' + date.getUTCMinutes());
      format.push('' + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += '0';
        }
        rval += format[i];
      }
      rval += 'Z';
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge.util.createBuffer();
      if (x >= -0x80 && x < 0x80) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -0x8000 && x < 0x8000) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -0x800000 && x < 0x800000) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -0x80000000 && x < 0x80000000) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error('Integer too large; max is 32-bits.');
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes) {
      if (typeof bytes === 'string') {
        bytes = forge.util.createBuffer(bytes);
      }
      var n = bytes.length() * 8;
      if (n > 32) {
        throw new Error('Integer too large; max is 32-bits.');
      }
      return bytes.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof(v.tagClass) === 'undefined') && (obj.type === v.type || typeof(v.type) === 'undefined')) {
        if (obj.constructed === v.constructed || typeof(v.constructed) === 'undefined') {
          rval = true;
          if (v.value && forge.util.isArray(v.value)) {
            var j = 0;
            for (var i = 0; rval && i < v.value.length; ++i) {
              rval = v.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                if (rval) {
                  ++j;
                } else if (v.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push('[' + v.name + '] ' + 'Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
          }
        } else if (errors) {
          errors.push('[' + v.name + '] ' + 'Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
        }
      } else if (errors) {
        if (obj.tagClass !== v.tagClass) {
          errors.push('[' + v.name + '] ' + 'Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
        }
        if (obj.type !== v.type) {
          errors.push('[' + v.name + '] ' + 'Expected type "' + v.type + '", got "' + obj.type + '"');
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = '';
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += '\n';
      }
      var indent = '';
      for (var i = 0; i < level * indentation; ++i) {
        indent += ' ';
      }
      rval += indent + 'Tag: ';
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += 'Universal:';
          break;
        case asn1.Class.APPLICATION:
          rval += 'Application:';
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += 'Context-Specific:';
          break;
        case asn1.Class.PRIVATE:
          rval += 'Private:';
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += ' (None)';
            break;
          case asn1.Type.BOOLEAN:
            rval += ' (Boolean)';
            break;
          case asn1.Type.BITSTRING:
            rval += ' (Bit string)';
            break;
          case asn1.Type.INTEGER:
            rval += ' (Integer)';
            break;
          case asn1.Type.OCTETSTRING:
            rval += ' (Octet string)';
            break;
          case asn1.Type.NULL:
            rval += ' (Null)';
            break;
          case asn1.Type.OID:
            rval += ' (Object Identifier)';
            break;
          case asn1.Type.ODESC:
            rval += ' (Object Descriptor)';
            break;
          case asn1.Type.EXTERNAL:
            rval += ' (External or Instance of)';
            break;
          case asn1.Type.REAL:
            rval += ' (Real)';
            break;
          case asn1.Type.ENUMERATED:
            rval += ' (Enumerated)';
            break;
          case asn1.Type.EMBEDDED:
            rval += ' (Embedded PDV)';
            break;
          case asn1.Type.UTF8:
            rval += ' (UTF8)';
            break;
          case asn1.Type.ROID:
            rval += ' (Relative Object Identifier)';
            break;
          case asn1.Type.SEQUENCE:
            rval += ' (Sequence)';
            break;
          case asn1.Type.SET:
            rval += ' (Set)';
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += ' (Printable String)';
            break;
          case asn1.Type.IA5String:
            rval += ' (IA5String (ASCII))';
            break;
          case asn1.Type.UTCTIME:
            rval += ' (UTC time)';
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += ' (Generalized time)';
            break;
          case asn1.Type.BMPSTRING:
            rval += ' (BMP String)';
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += '\n';
      rval += indent + 'Constructed: ' + obj.constructed + '\n';
      if (obj.composed) {
        var subvalues = 0;
        var sub = '';
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== undefined) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if ((i + 1) < obj.value.length) {
              sub += ',';
            }
          }
        }
        rval += indent + 'Sub values: ' + subvalues + sub;
      } else {
        rval += indent + 'Value: ';
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += ' (' + forge.pki.oids[oid] + ') ';
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += '0x' + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += '(' + obj.value + ') ';
          }
          rval += '0x' + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          rval += forge.util.decodeUtf8(obj.value);
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += '0x' + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += '[null]';
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
  var name = 'asn1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/asn1", ["require", "module", "npm:node-forge@0.6.35/js/util", "npm:node-forge@0.6.35/js/oids"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var md5 = forge.md5 = forge.md5 || {};
    forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
    forge.md.md5 = forge.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(16);
      var md = {
        algorithm: 'md5',
        blockLength: 64,
        digestLength: 16,
        messageLength: 0,
        messageLength64: [0, 0]
      };
      md.start = function() {
        md.messageLength = 0;
        md.messageLength64 = [0, 0];
        _input = forge.util.createBuffer();
        _state = {
          h0: 0x67452301,
          h1: 0xEFCDAB89,
          h2: 0x98BADCFE,
          h3: 0x10325476
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === 'utf8') {
          msg = forge.util.encodeUtf8(msg);
        }
        md.messageLength += msg.length;
        md.messageLength64[0] += (msg.length / 0x100000000) >>> 0;
        md.messageLength64[1] += msg.length >>> 0;
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var padBytes = forge.util.createBuffer();
        padBytes.putBytes(_input.bytes());
        padBytes.putBytes(_padding.substr(0, 64 - ((md.messageLength64[1] + 8) & 0x3F)));
        padBytes.putInt32Le(md.messageLength64[1] << 3);
        padBytes.putInt32Le((md.messageLength64[0] << 3) | (md.messageLength64[0] >>> 28));
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, padBytes);
        var rval = forge.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _g = null;
    var _r = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0x00), 64);
      _g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9];
      _r = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21];
      _k = new Array(64);
      for (var i = 0; i < 64; ++i) {
        _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000);
      }
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t,
          a,
          b,
          c,
          d,
          f,
          r,
          i;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        for (i = 0; i < 16; ++i) {
          w[i] = bytes.getInt32Le();
          f = d ^ (b & (c ^ d));
          t = (a + f + _k[i] + w[i]);
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += (t << r) | (t >>> (32 - r));
        }
        for (; i < 32; ++i) {
          f = c ^ (d & (b ^ c));
          t = (a + f + _k[i] + w[_g[i]]);
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += (t << r) | (t >>> (32 - r));
        }
        for (; i < 48; ++i) {
          f = b ^ c ^ d;
          t = (a + f + _k[i] + w[_g[i]]);
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += (t << r) | (t >>> (32 - r));
        }
        for (; i < 64; ++i) {
          f = c ^ (b | ~d);
          t = (a + f + _k[i] + w[_g[i]]);
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += (t << r) | (t >>> (32 - r));
        }
        s.h0 = (s.h0 + a) | 0;
        s.h1 = (s.h1 + b) | 0;
        s.h2 = (s.h2 + c) | 0;
        s.h3 = (s.h3 + d) | 0;
        len -= 64;
      }
    }
  }
  var name = 'md5';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/md5", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var sha1 = forge.sha1 = forge.sha1 || {};
    forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: 'sha1',
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        messageLength64: [0, 0]
      };
      md.start = function() {
        md.messageLength = 0;
        md.messageLength64 = [0, 0];
        _input = forge.util.createBuffer();
        _state = {
          h0: 0x67452301,
          h1: 0xEFCDAB89,
          h2: 0x98BADCFE,
          h3: 0x10325476,
          h4: 0xC3D2E1F0
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === 'utf8') {
          msg = forge.util.encodeUtf8(msg);
        }
        md.messageLength += msg.length;
        md.messageLength64[0] += (msg.length / 0x100000000) >>> 0;
        md.messageLength64[1] += msg.length >>> 0;
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var padBytes = forge.util.createBuffer();
        padBytes.putBytes(_input.bytes());
        padBytes.putBytes(_padding.substr(0, 64 - ((md.messageLength64[1] + 8) & 0x3F)));
        padBytes.putInt32((md.messageLength64[0] << 3) | (md.messageLength64[0] >>> 28));
        padBytes.putInt32(md.messageLength64[1] << 3);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, padBytes);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0x00), 64);
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t,
          a,
          b,
          c,
          d,
          e,
          f,
          i;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes.getInt32();
          w[i] = t;
          f = d ^ (b & (c ^ d));
          t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 20; ++i) {
          t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
          t = (t << 1) | (t >>> 31);
          w[i] = t;
          f = d ^ (b & (c ^ d));
          t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 32; ++i) {
          t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
          t = (t << 1) | (t >>> 31);
          w[i] = t;
          f = b ^ c ^ d;
          t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 40; ++i) {
          t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
          t = (t << 2) | (t >>> 30);
          w[i] = t;
          f = b ^ c ^ d;
          t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 60; ++i) {
          t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
          t = (t << 2) | (t >>> 30);
          w[i] = t;
          f = (b & c) | (d & (b ^ c));
          t = ((a << 5) | (a >>> 27)) + f + e + 0x8F1BBCDC + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        for (; i < 80; ++i) {
          t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
          t = (t << 2) | (t >>> 30);
          w[i] = t;
          f = b ^ c ^ d;
          t = ((a << 5) | (a >>> 27)) + f + e + 0xCA62C1D6 + t;
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        s.h0 = (s.h0 + a) | 0;
        s.h1 = (s.h1 + b) | 0;
        s.h2 = (s.h2 + c) | 0;
        s.h3 = (s.h3 + d) | 0;
        s.h4 = (s.h4 + e) | 0;
        len -= 64;
      }
    }
  }
  var name = 'sha1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/sha1", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var sha256 = forge.sha256 = forge.sha256 || {};
    forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: 'sha256',
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        messageLength64: [0, 0]
      };
      md.start = function() {
        md.messageLength = 0;
        md.messageLength64 = [0, 0];
        _input = forge.util.createBuffer();
        _state = {
          h0: 0x6A09E667,
          h1: 0xBB67AE85,
          h2: 0x3C6EF372,
          h3: 0xA54FF53A,
          h4: 0x510E527F,
          h5: 0x9B05688C,
          h6: 0x1F83D9AB,
          h7: 0x5BE0CD19
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === 'utf8') {
          msg = forge.util.encodeUtf8(msg);
        }
        md.messageLength += msg.length;
        md.messageLength64[0] += (msg.length / 0x100000000) >>> 0;
        md.messageLength64[1] += msg.length >>> 0;
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var padBytes = forge.util.createBuffer();
        padBytes.putBytes(_input.bytes());
        padBytes.putBytes(_padding.substr(0, 64 - ((md.messageLength64[1] + 8) & 0x3F)));
        padBytes.putInt32((md.messageLength64[0] << 3) | (md.messageLength64[0] >>> 28));
        padBytes.putInt32(md.messageLength64[1] << 3);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, padBytes);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0x00), 64);
      _k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t1,
          t2,
          s0,
          s1,
          ch,
          maj,
          i,
          a,
          b,
          c,
          d,
          e,
          f,
          g,
          h;
      var len = bytes.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w[i] = bytes.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w[i - 2];
          t1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
          t2 = w[i - 15];
          t2 = ((t2 >>> 7) | (t2 << 25)) ^ ((t2 >>> 18) | (t2 << 14)) ^ (t2 >>> 3);
          w[i] = (t1 + w[i - 7] + t2 + w[i - 16]) | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i = 0; i < 64; ++i) {
          s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
          ch = g ^ (e & (f ^ g));
          s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
          maj = (a & b) | (c & (a ^ b));
          t1 = h + s1 + ch + _k[i] + w[i];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = (d + t1) | 0;
          d = c;
          c = b;
          b = a;
          a = (t1 + t2) | 0;
        }
        s.h0 = (s.h0 + a) | 0;
        s.h1 = (s.h1 + b) | 0;
        s.h2 = (s.h2 + c) | 0;
        s.h3 = (s.h3 + d) | 0;
        s.h4 = (s.h4 + e) | 0;
        s.h5 = (s.h5 + f) | 0;
        s.h6 = (s.h6 + g) | 0;
        s.h7 = (s.h7 + h) | 0;
        len -= 64;
      }
    }
  }
  var name = 'sha256';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/sha256", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var sha512 = forge.sha512 = forge.sha512 || {};
    forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha512.create('SHA-384');
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {create: function() {
        return sha512.create('SHA-512/256');
      }};
    forge.md['sha512/256'] = forge.md.algorithms['sha512/256'] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {create: function() {
        return sha512.create('SHA-512/224');
      }};
    forge.md['sha512/224'] = forge.md.algorithms['sha512/224'] = forge.sha512.sha224;
    sha512.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === 'undefined') {
        algorithm = 'SHA-512';
      }
      if (!(algorithm in _states)) {
        throw new Error('Invalid SHA-512 algorithm: ' + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var md = {
        algorithm: algorithm.replace('-', '').toLowerCase(),
        blockLength: 128,
        digestLength: 64,
        messageLength: 0,
        messageLength128: [0, 0, 0, 0]
      };
      md.start = function() {
        md.messageLength = 0;
        md.messageLength128 = [0, 0, 0, 0];
        _input = forge.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === 'utf8') {
          msg = forge.util.encodeUtf8(msg);
        }
        md.messageLength += msg.length;
        var len = msg.length;
        len = [(len / 0x100000000) >>> 0, len >>> 0];
        for (var i = 3; i >= 0; --i) {
          md.messageLength128[i] += len[1];
          len[1] = len[0] + ((md.messageLength128[i] / 0x100000000) >>> 0);
          md.messageLength128[i] = md.messageLength128[i] >>> 0;
          len[0] = ((len[1] / 0x100000000) >>> 0);
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var padBytes = forge.util.createBuffer();
        padBytes.putBytes(_input.bytes());
        padBytes.putBytes(_padding.substr(0, 128 - ((md.messageLength128[3] + 16) & 0x7F)));
        var bitLength = [];
        for (var i = 0; i < 3; ++i) {
          bitLength[i] = ((md.messageLength128[i] << 3) | (md.messageLength128[i - 1] >>> 28));
        }
        bitLength[3] = md.messageLength128[3] << 3;
        padBytes.putInt32(bitLength[0]);
        padBytes.putInt32(bitLength[1]);
        padBytes.putInt32(bitLength[2]);
        padBytes.putInt32(bitLength[3]);
        var h = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h[i] = _h[i].slice(0);
        }
        _update(h, _w, padBytes);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === 'SHA-512') {
          hlen = h.length;
        } else if (algorithm === 'SHA-384') {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h[i][0]);
          if (i !== hlen - 1 || algorithm !== 'SHA-512/224') {
            rval.putInt32(h[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0x00), 128);
      _k = [[0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd], [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc], [0x3956c25b, 0xf348b538], [0x59f111f1, 0xb605d019], [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118], [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe], [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2], [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1], [0x9bdc06a7, 0x25c71235], [0xc19bf174, 0xcf692694], [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3], [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65], [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483], [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5], [0x983e5152, 0xee66dfab], [0xa831c66d, 0x2db43210], [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4], [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725], [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70], [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926], [0x4d2c6dfc, 0x5ac42aed], [0x53380d13, 0x9d95b3df], [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8], [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b], [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001], [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30], [0xd192e819, 0xd6ef5218], [0xd6990624, 0x5565a910], [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8], [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53], [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8], [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb], [0x5b9cca4f, 0x7763e373], [0x682e6ff3, 0xd6b2b8a3], [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60], [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec], [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9], [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b], [0xca273ece, 0xea26619c], [0xd186b8c7, 0x21c0c207], [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178], [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6], [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b], [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493], [0x3c9ebe0a, 0x15c9bebc], [0x431d67c4, 0x9c100d4c], [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a], [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]];
      _states = {};
      _states['SHA-512'] = [[0x6a09e667, 0xf3bcc908], [0xbb67ae85, 0x84caa73b], [0x3c6ef372, 0xfe94f82b], [0xa54ff53a, 0x5f1d36f1], [0x510e527f, 0xade682d1], [0x9b05688c, 0x2b3e6c1f], [0x1f83d9ab, 0xfb41bd6b], [0x5be0cd19, 0x137e2179]];
      _states['SHA-384'] = [[0xcbbb9d5d, 0xc1059ed8], [0x629a292a, 0x367cd507], [0x9159015a, 0x3070dd17], [0x152fecd8, 0xf70e5939], [0x67332667, 0xffc00b31], [0x8eb44a87, 0x68581511], [0xdb0c2e0d, 0x64f98fa7], [0x47b5481d, 0xbefa4fa4]];
      _states['SHA-512/256'] = [[0x22312194, 0xFC2BF72C], [0x9F555FA3, 0xC84C64C2], [0x2393B86B, 0x6F53B151], [0x96387719, 0x5940EABD], [0x96283EE2, 0xA88EFFE3], [0xBE5E1E25, 0x53863992], [0x2B0199FC, 0x2C85B8AA], [0x0EB72DDC, 0x81C52CA2]];
      _states['SHA-512/224'] = [[0x8C3D37C8, 0x19544DA2], [0x73E19966, 0x89DCD4D6], [0x1DFAB7AE, 0x32FF9C82], [0x679DD514, 0x582F9FCF], [0x0F6D2B69, 0x7BD44DA8], [0x77E36F73, 0x04C48942], [0x3F9D85A8, 0x6A1D36C8], [0x1112E6AD, 0x91D692A1]];
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t1_hi,
          t1_lo;
      var t2_hi,
          t2_lo;
      var s0_hi,
          s0_lo;
      var s1_hi,
          s1_lo;
      var ch_hi,
          ch_lo;
      var maj_hi,
          maj_lo;
      var a_hi,
          a_lo;
      var b_hi,
          b_lo;
      var c_hi,
          c_lo;
      var d_hi,
          d_lo;
      var e_hi,
          e_lo;
      var f_hi,
          f_lo;
      var g_hi,
          g_lo;
      var h_hi,
          h_lo;
      var i,
          hi,
          lo,
          w2,
          w7,
          w15,
          w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w[i][0] = bytes.getInt32() >>> 0;
          w[i][1] = bytes.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w2 = w[i - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = (((hi >>> 19) | (lo << 13)) ^ ((lo >>> 29) | (hi << 3)) ^ (hi >>> 6)) >>> 0;
          t1_lo = (((hi << 13) | (lo >>> 19)) ^ ((lo << 3) | (hi >>> 29)) ^ ((hi << 26) | (lo >>> 6))) >>> 0;
          w15 = w[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = (((hi >>> 1) | (lo << 31)) ^ ((hi >>> 8) | (lo << 24)) ^ (hi >>> 7)) >>> 0;
          t2_lo = (((hi << 31) | (lo >>> 1)) ^ ((hi << 24) | (lo >>> 8)) ^ ((hi << 25) | (lo >>> 7))) >>> 0;
          w7 = w[i - 7];
          w16 = w[i - 16];
          lo = (t1_lo + w7[1] + t2_lo + w16[1]);
          w[i][0] = (t1_hi + w7[0] + t2_hi + w16[0] + ((lo / 0x100000000) >>> 0)) >>> 0;
          w[i][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = (((e_hi >>> 14) | (e_lo << 18)) ^ ((e_hi >>> 18) | (e_lo << 14)) ^ ((e_lo >>> 9) | (e_hi << 23))) >>> 0;
          s1_lo = (((e_hi << 18) | (e_lo >>> 14)) ^ ((e_hi << 14) | (e_lo >>> 18)) ^ ((e_lo << 23) | (e_hi >>> 9))) >>> 0;
          ch_hi = (g_hi ^ (e_hi & (f_hi ^ g_hi))) >>> 0;
          ch_lo = (g_lo ^ (e_lo & (f_lo ^ g_lo))) >>> 0;
          s0_hi = (((a_hi >>> 28) | (a_lo << 4)) ^ ((a_lo >>> 2) | (a_hi << 30)) ^ ((a_lo >>> 7) | (a_hi << 25))) >>> 0;
          s0_lo = (((a_hi << 4) | (a_lo >>> 28)) ^ ((a_lo << 30) | (a_hi >>> 2)) ^ ((a_lo << 25) | (a_hi >>> 7))) >>> 0;
          maj_hi = ((a_hi & b_hi) | (c_hi & (a_hi ^ b_hi))) >>> 0;
          maj_lo = ((a_lo & b_lo) | (c_lo & (a_lo ^ b_lo))) >>> 0;
          lo = (h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1]);
          t1_hi = (h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + ((lo / 0x100000000) >>> 0)) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = (s0_hi + maj_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = (d_hi + t1_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = (t1_hi + t2_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = (s[0][0] + a_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = (s[1][0] + b_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = (s[2][0] + c_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = (s[3][0] + d_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = (s[4][0] + e_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = (s[5][0] + f_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = (s[6][0] + g_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = (s[7][0] + h_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
  var name = 'sha512';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/sha512", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.md = forge.md || {};
    forge.md.algorithms = {
      md5: forge.md5,
      sha1: forge.sha1,
      sha256: forge.sha256
    };
    forge.md.md5 = forge.md5;
    forge.md.sha1 = forge.sha1;
    forge.md.sha256 = forge.sha256;
  }
  var name = 'md';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/md", ["require", "module", "npm:node-forge@0.6.35/js/md5", "npm:node-forge@0.6.35/js/sha1", "npm:node-forge@0.6.35/js/sha256", "npm:node-forge@0.6.35/js/sha512"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var hmac = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === 'string') {
            md = md.toLowerCase();
            if (md in forge.md.algorithms) {
              _md = forge.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === 'string') {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key.at(i);
            _ipadding.putByte(0x36 ^ tmp);
            _opadding.putByte(0x5C ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(0x36);
              _opadding.putByte(0x5C);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
  var name = 'hmac';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/hmac", ["require", "module", "npm:node-forge@0.6.35/js/md", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var pem = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = '-----BEGIN ' + msg.type + '-----\r\n';
      var header;
      if (msg.procType) {
        header = {
          name: 'Proc-Type',
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = {
          name: 'Content-Domain',
          values: [msg.contentDomain]
        };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = {
          name: 'DEK-Info',
          values: [msg.dekInfo.algorithm]
        };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += '\r\n';
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + '\r\n';
      rval += '-----END ' + msg.type + '-----\r\n';
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var msg = {
          type: match[1],
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, '');
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = {
              name: match[1],
              values: []
            };
            var values = match[2].split(',');
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== 'Proc-Type') {
                throw new Error('Invalid PEM formatted message. The first ' + 'encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" ' + 'header must have two subfields.');
              }
              msg.procType = {
                version: values[0],
                type: values[1]
              };
            } else if (!msg.contentDomain && header.name === 'Content-Domain') {
              msg.contentDomain = values[0] || '';
            } else if (!msg.dekInfo && header.name === 'DEK-Info') {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" ' + 'header must have at least one subfield.');
              }
              msg.dekInfo = {
                algorithm: values[0],
                parameters: values[1] || null
              };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === 'ENCRYPTED' && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" ' + 'header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error('Invalid PEM formatted message.');
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ': ';
      var values = [];
      var insertSpace = function(match, $1) {
        return ' ' + $1;
      };
      for (var i = 0; i < header.values.length; ++i) {
        values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(',') + '\r\n';
      var length = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ',') {
            ++candidate;
            rval = rval.substr(0, candidate) + '\r\n ' + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + '\r\n' + insert + rval.substr(candidate + 1);
          }
          length = (i - candidate - 1);
          candidate = -1;
          ++i;
        } else if (rval[i] === ' ' || rval[i] === '\t' || rval[i] === ',') {
          candidate = i;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, '');
    }
  }
  var name = 'pem';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pem", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key: key,
        output: output,
        decrypt: false,
        mode: mode || (iv === null ? 'ECB' : 'CBC')
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key: key,
        output: null,
        decrypt: false,
        mode: mode
      });
    };
    forge.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key: key,
        output: output,
        decrypt: true,
        mode: mode || (iv === null ? 'ECB' : 'CBC')
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key: key,
        output: null,
        decrypt: true,
        mode: mode
      });
    };
    forge.des.Algorithm = function(name, mode) {
      var self = this;
      self.name = name;
      self.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self._keys, inBlock, outBlock, true);
          }
        }
      });
      self._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf('3DES') === 0) {
        if (key.length() !== 24) {
          throw new Error('Invalid Triple-DES key size: ' + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm('DES-ECB', forge.cipher.modes.ecb);
    registerAlgorithm('DES-CBC', forge.cipher.modes.cbc);
    registerAlgorithm('DES-CFB', forge.cipher.modes.cfb);
    registerAlgorithm('DES-OFB', forge.cipher.modes.ofb);
    registerAlgorithm('DES-CTR', forge.cipher.modes.ctr);
    registerAlgorithm('3DES-ECB', forge.cipher.modes.ecb);
    registerAlgorithm('3DES-CBC', forge.cipher.modes.cbc);
    registerAlgorithm('3DES-CFB', forge.cipher.modes.cfb);
    registerAlgorithm('3DES-OFB', forge.cipher.modes.ofb);
    registerAlgorithm('3DES-CTR', forge.cipher.modes.ctr);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge.des.Algorithm(name, mode);
      };
      forge.cipher.registerAlgorithm(name, factory);
    }
    var spfunction1 = [0x1010400, 0, 0x10000, 0x1010404, 0x1010004, 0x10404, 0x4, 0x10000, 0x400, 0x1010400, 0x1010404, 0x400, 0x1000404, 0x1010004, 0x1000000, 0x4, 0x404, 0x1000400, 0x1000400, 0x10400, 0x10400, 0x1010000, 0x1010000, 0x1000404, 0x10004, 0x1000004, 0x1000004, 0x10004, 0, 0x404, 0x10404, 0x1000000, 0x10000, 0x1010404, 0x4, 0x1010000, 0x1010400, 0x1000000, 0x1000000, 0x400, 0x1010004, 0x10000, 0x10400, 0x1000004, 0x400, 0x4, 0x1000404, 0x10404, 0x1010404, 0x10004, 0x1010000, 0x1000404, 0x1000004, 0x404, 0x10404, 0x1010400, 0x404, 0x1000400, 0x1000400, 0, 0x10004, 0x10400, 0, 0x1010004];
    var spfunction2 = [-0x7fef7fe0, -0x7fff8000, 0x8000, 0x108020, 0x100000, 0x20, -0x7fefffe0, -0x7fff7fe0, -0x7fffffe0, -0x7fef7fe0, -0x7fef8000, -0x80000000, -0x7fff8000, 0x100000, 0x20, -0x7fefffe0, 0x108000, 0x100020, -0x7fff7fe0, 0, -0x80000000, 0x8000, 0x108020, -0x7ff00000, 0x100020, -0x7fffffe0, 0, 0x108000, 0x8020, -0x7fef8000, -0x7ff00000, 0x8020, 0, 0x108020, -0x7fefffe0, 0x100000, -0x7fff7fe0, -0x7ff00000, -0x7fef8000, 0x8000, -0x7ff00000, -0x7fff8000, 0x20, -0x7fef7fe0, 0x108020, 0x20, 0x8000, -0x80000000, 0x8020, -0x7fef8000, 0x100000, -0x7fffffe0, 0x100020, -0x7fff7fe0, -0x7fffffe0, 0x100020, 0x108000, 0, -0x7fff8000, 0x8020, -0x80000000, -0x7fefffe0, -0x7fef7fe0, 0x108000];
    var spfunction3 = [0x208, 0x8020200, 0, 0x8020008, 0x8000200, 0, 0x20208, 0x8000200, 0x20008, 0x8000008, 0x8000008, 0x20000, 0x8020208, 0x20008, 0x8020000, 0x208, 0x8000000, 0x8, 0x8020200, 0x200, 0x20200, 0x8020000, 0x8020008, 0x20208, 0x8000208, 0x20200, 0x20000, 0x8000208, 0x8, 0x8020208, 0x200, 0x8000000, 0x8020200, 0x8000000, 0x20008, 0x208, 0x20000, 0x8020200, 0x8000200, 0, 0x200, 0x20008, 0x8020208, 0x8000200, 0x8000008, 0x200, 0, 0x8020008, 0x8000208, 0x20000, 0x8000000, 0x8020208, 0x8, 0x20208, 0x20200, 0x8000008, 0x8020000, 0x8000208, 0x208, 0x8020000, 0x20208, 0x8, 0x8020008, 0x20200];
    var spfunction4 = [0x802001, 0x2081, 0x2081, 0x80, 0x802080, 0x800081, 0x800001, 0x2001, 0, 0x802000, 0x802000, 0x802081, 0x81, 0, 0x800080, 0x800001, 0x1, 0x2000, 0x800000, 0x802001, 0x80, 0x800000, 0x2001, 0x2080, 0x800081, 0x1, 0x2080, 0x800080, 0x2000, 0x802080, 0x802081, 0x81, 0x800080, 0x800001, 0x802000, 0x802081, 0x81, 0, 0, 0x802000, 0x2080, 0x800080, 0x800081, 0x1, 0x802001, 0x2081, 0x2081, 0x80, 0x802081, 0x81, 0x1, 0x2000, 0x800001, 0x2001, 0x802080, 0x800081, 0x2001, 0x2080, 0x800000, 0x802001, 0x80, 0x800000, 0x2000, 0x802080];
    var spfunction5 = [0x100, 0x2080100, 0x2080000, 0x42000100, 0x80000, 0x100, 0x40000000, 0x2080000, 0x40080100, 0x80000, 0x2000100, 0x40080100, 0x42000100, 0x42080000, 0x80100, 0x40000000, 0x2000000, 0x40080000, 0x40080000, 0, 0x40000100, 0x42080100, 0x42080100, 0x2000100, 0x42080000, 0x40000100, 0, 0x42000000, 0x2080100, 0x2000000, 0x42000000, 0x80100, 0x80000, 0x42000100, 0x100, 0x2000000, 0x40000000, 0x2080000, 0x42000100, 0x40080100, 0x2000100, 0x40000000, 0x42080000, 0x2080100, 0x40080100, 0x100, 0x2000000, 0x42080000, 0x42080100, 0x80100, 0x42000000, 0x42080100, 0x2080000, 0, 0x40080000, 0x42000000, 0x80100, 0x2000100, 0x40000100, 0x80000, 0, 0x40080000, 0x2080100, 0x40000100];
    var spfunction6 = [0x20000010, 0x20400000, 0x4000, 0x20404010, 0x20400000, 0x10, 0x20404010, 0x400000, 0x20004000, 0x404010, 0x400000, 0x20000010, 0x400010, 0x20004000, 0x20000000, 0x4010, 0, 0x400010, 0x20004010, 0x4000, 0x404000, 0x20004010, 0x10, 0x20400010, 0x20400010, 0, 0x404010, 0x20404000, 0x4010, 0x404000, 0x20404000, 0x20000000, 0x20004000, 0x10, 0x20400010, 0x404000, 0x20404010, 0x400000, 0x4010, 0x20000010, 0x400000, 0x20004000, 0x20000000, 0x4010, 0x20000010, 0x20404010, 0x404000, 0x20400000, 0x404010, 0x20404000, 0, 0x20400010, 0x10, 0x4000, 0x20400000, 0x404010, 0x4000, 0x400010, 0x20004010, 0, 0x20404000, 0x20000000, 0x400010, 0x20004010];
    var spfunction7 = [0x200000, 0x4200002, 0x4000802, 0, 0x800, 0x4000802, 0x200802, 0x4200800, 0x4200802, 0x200000, 0, 0x4000002, 0x2, 0x4000000, 0x4200002, 0x802, 0x4000800, 0x200802, 0x200002, 0x4000800, 0x4000002, 0x4200000, 0x4200800, 0x200002, 0x4200000, 0x800, 0x802, 0x4200802, 0x200800, 0x2, 0x4000000, 0x200800, 0x4000000, 0x200800, 0x200000, 0x4000802, 0x4000802, 0x4200002, 0x4200002, 0x2, 0x200002, 0x4000000, 0x4000800, 0x200000, 0x4200800, 0x802, 0x200802, 0x4200800, 0x802, 0x4000002, 0x4200802, 0x4200000, 0x200800, 0, 0x2, 0x4200802, 0, 0x200802, 0x4200000, 0x800, 0x4000002, 0x4000800, 0x800, 0x200002];
    var spfunction8 = [0x10001040, 0x1000, 0x40000, 0x10041040, 0x10000000, 0x10001040, 0x40, 0x10000000, 0x40040, 0x10040000, 0x10041040, 0x41000, 0x10041000, 0x41040, 0x1000, 0x40, 0x10040000, 0x10000040, 0x10001000, 0x1040, 0x41000, 0x40040, 0x10040040, 0x10041000, 0x1040, 0, 0, 0x10040040, 0x10000040, 0x10001000, 0x41040, 0x40000, 0x41040, 0x40000, 0x10041000, 0x1000, 0x40, 0x10040040, 0x1000, 0x41040, 0x10001000, 0x40, 0x10000040, 0x10040000, 0x10040040, 0x10000000, 0x40000, 0x10001040, 0, 0x10041040, 0x40040, 0x10000040, 0x10040000, 0x10001000, 0x10001040, 0, 0x10041040, 0x41000, 0x41000, 0x1040, 0x1040, 0x40040, 0x10000000, 0x10041000];
    function _createKeys(key) {
      var pc2bytes0 = [0, 0x4, 0x20000000, 0x20000004, 0x10000, 0x10004, 0x20010000, 0x20010004, 0x200, 0x204, 0x20000200, 0x20000204, 0x10200, 0x10204, 0x20010200, 0x20010204],
          pc2bytes1 = [0, 0x1, 0x100000, 0x100001, 0x4000000, 0x4000001, 0x4100000, 0x4100001, 0x100, 0x101, 0x100100, 0x100101, 0x4000100, 0x4000101, 0x4100100, 0x4100101],
          pc2bytes2 = [0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808, 0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808],
          pc2bytes3 = [0, 0x200000, 0x8000000, 0x8200000, 0x2000, 0x202000, 0x8002000, 0x8202000, 0x20000, 0x220000, 0x8020000, 0x8220000, 0x22000, 0x222000, 0x8022000, 0x8222000],
          pc2bytes4 = [0, 0x40000, 0x10, 0x40010, 0, 0x40000, 0x10, 0x40010, 0x1000, 0x41000, 0x1010, 0x41010, 0x1000, 0x41000, 0x1010, 0x41010],
          pc2bytes5 = [0, 0x400, 0x20, 0x420, 0, 0x400, 0x20, 0x420, 0x2000000, 0x2000400, 0x2000020, 0x2000420, 0x2000000, 0x2000400, 0x2000020, 0x2000420],
          pc2bytes6 = [0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002, 0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002],
          pc2bytes7 = [0, 0x10000, 0x800, 0x10800, 0x20000000, 0x20010000, 0x20000800, 0x20010800, 0x20000, 0x30000, 0x20800, 0x30800, 0x20020000, 0x20030000, 0x20020800, 0x20030800],
          pc2bytes8 = [0, 0x40000, 0, 0x40000, 0x2, 0x40002, 0x2, 0x40002, 0x2000000, 0x2040000, 0x2000000, 0x2040000, 0x2000002, 0x2040002, 0x2000002, 0x2040002],
          pc2bytes9 = [0, 0x10000000, 0x8, 0x10000008, 0, 0x10000000, 0x8, 0x10000008, 0x400, 0x10000400, 0x408, 0x10000408, 0x400, 0x10000400, 0x408, 0x10000408],
          pc2bytes10 = [0, 0x20, 0, 0x20, 0x100000, 0x100020, 0x100000, 0x100020, 0x2000, 0x2020, 0x2000, 0x2020, 0x102000, 0x102020, 0x102000, 0x102020],
          pc2bytes11 = [0, 0x1000000, 0x200, 0x1000200, 0x200000, 0x1200000, 0x200200, 0x1200200, 0x4000000, 0x5000000, 0x4000200, 0x5000200, 0x4200000, 0x5200000, 0x4200200, 0x5200200],
          pc2bytes12 = [0, 0x1000, 0x8000000, 0x8001000, 0x80000, 0x81000, 0x8080000, 0x8081000, 0x10, 0x1010, 0x8000010, 0x8001010, 0x80010, 0x81010, 0x8080010, 0x8081010],
          pc2bytes13 = [0, 0x4, 0x100, 0x104, 0, 0x4, 0x100, 0x104, 0x1, 0x5, 0x101, 0x105, 0x1, 0x5, 0x101, 0x105];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0,
          tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
        right ^= tmp;
        left ^= (tmp << 4);
        tmp = ((right >>> -16) ^ left) & 0x0000ffff;
        left ^= tmp;
        right ^= (tmp << -16);
        tmp = ((left >>> 2) ^ right) & 0x33333333;
        right ^= tmp;
        left ^= (tmp << 2);
        tmp = ((right >>> -16) ^ left) & 0x0000ffff;
        left ^= tmp;
        right ^= (tmp << -16);
        tmp = ((left >>> 1) ^ right) & 0x55555555;
        right ^= tmp;
        left ^= (tmp << 1);
        tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
        left ^= tmp;
        right ^= (tmp << 8);
        tmp = ((left >>> 1) ^ right) & 0x55555555;
        right ^= tmp;
        left ^= (tmp << 1);
        tmp = (left << 8) | ((right >>> 20) & 0x000000f0);
        left = ((right << 24) | ((right << 8) & 0xff0000) | ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0));
        right = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left = (left << 2) | (left >>> 26);
            right = (right << 2) | (right >>> 26);
          } else {
            left = (left << 1) | (left >>> 27);
            right = (right << 1) | (right >>> 27);
          }
          left &= -0xf;
          right &= -0xf;
          var lefttmp = (pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf] | pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf] | pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf] | pc2bytes6[(left >>> 4) & 0xf]);
          var righttmp = (pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf] | pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf] | pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf] | pc2bytes13[(right >>> 4) & 0xf]);
          tmp = ((righttmp >>> 16) ^ lefttmp) & 0x0000ffff;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ (tmp << 16);
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = (decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2]);
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
      right ^= tmp;
      left ^= (tmp << 4);
      tmp = ((left >>> 16) ^ right) & 0x0000ffff;
      right ^= tmp;
      left ^= (tmp << 16);
      tmp = ((right >>> 2) ^ left) & 0x33333333;
      left ^= tmp;
      right ^= (tmp << 2);
      tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
      left ^= tmp;
      right ^= (tmp << 8);
      tmp = ((left >>> 1) ^ right) & 0x55555555;
      right ^= tmp;
      left ^= (tmp << 1);
      left = ((left << 1) | (left >>> 31));
      right = ((right << 1) | (right >>> 31));
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right ^ keys[i];
          var right2 = ((right >>> 4) | (right << 28)) ^ keys[i + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[(right1 >>> 24) & 0x3f] | spfunction4[(right1 >>> 16) & 0x3f] | spfunction6[(right1 >>> 8) & 0x3f] | spfunction8[right1 & 0x3f] | spfunction1[(right2 >>> 24) & 0x3f] | spfunction3[(right2 >>> 16) & 0x3f] | spfunction5[(right2 >>> 8) & 0x3f] | spfunction7[right2 & 0x3f]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = ((left >>> 1) | (left << 31));
      right = ((right >>> 1) | (right << 31));
      tmp = ((left >>> 1) ^ right) & 0x55555555;
      right ^= tmp;
      left ^= (tmp << 1);
      tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
      left ^= tmp;
      right ^= (tmp << 8);
      tmp = ((right >>> 2) ^ left) & 0x33333333;
      left ^= tmp;
      right ^= (tmp << 2);
      tmp = ((left >>> 16) ^ right) & 0x0000ffff;
      right ^= tmp;
      left ^= (tmp << 16);
      tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
      right ^= tmp;
      left ^= (tmp << 4);
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || 'CBC').toUpperCase();
      var algorithm = 'DES-' + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options) {
        var output = null;
        if (options instanceof forge.util.ByteBuffer) {
          output = options;
          options = {};
        }
        options = options || {};
        options.output = output;
        options.iv = iv;
        start.call(cipher, options);
      };
      return cipher;
    }
  }
  var name = 'des';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/des", ["require", "module", "npm:node-forge@0.6.35/js/cipher", "npm:node-forge@0.6.35/js/cipherModes", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var _nodejs = (typeof process !== 'undefined' && process.versions && process.versions.node);
    var crypto;
    if (_nodejs && !forge.disableNativeCode) {
      crypto = require('crypto');
    }
    forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === 'function') {
        callback = md;
        md = null;
      }
      if (_nodejs && !forge.disableNativeCode && crypto.pbkdf2 && (md === null || typeof md !== 'object') && (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {
        if (typeof md !== 'string') {
          md = 'sha1';
        }
        s = new Buffer(s, 'binary');
        if (!callback) {
          if (crypto.pbkdf2Sync.length === 4) {
            return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');
          }
          return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');
        }
        if (crypto.pbkdf2Sync.length === 4) {
          return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {
            if (err) {
              return callback(err);
            }
            callback(null, key.toString('binary'));
          });
        }
        return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {
          if (err) {
            return callback(err);
          }
          callback(null, key.toString('binary'));
        });
      }
      if (typeof md === 'undefined' || md === null) {
        md = forge.md.sha1.create();
      }
      if (typeof md === 'string') {
        if (!(md in forge.md.algorithms)) {
          throw new Error('Unknown hash algorithm: ' + md);
        }
        md = forge.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > (0xFFFFFFFF * hLen)) {
        var err = new Error('Derived key is too long.');
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md, p);
      var dk = '';
      var xor,
          u_c,
          u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge.util.int32ToBytes(i));
          xor = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += (i < len) ? xor : xor.substr(0, r);
        }
        return dk;
      }
      var i = 1,
          j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge.util.setImmediate(inner);
        }
        dk += (i < len) ? xor : xor.substr(0, r);
        ++i;
        outer();
      }
      outer();
    };
  }
  var name = 'pbkdf2';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pbkdf2", ["require", "module", "npm:node-forge@0.6.35/js/hmac", "npm:node-forge@0.6.35/js/md", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var _nodejs = (typeof process !== 'undefined' && process.versions && process.versions.node);
    var _crypto = null;
    if (!forge.disableNativeCode && _nodejs && !process.versions['node-webkit']) {
      _crypto = require('crypto');
    }
    var prng = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin: plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 0xfffff) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 0xfffff) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = (32 - ctx.pools[0].messageLength) << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = (32 - ctx.pools[0].messageLength) << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        var md = ctx.plugin.md.create();
        md.update(ctx.pools[0].digest().getBytes());
        ctx.pools[0].start();
        var k = 1;
        for (var i = 1; i < 32; ++i) {
          k = (k === 31) ? 0x80000000 : (k << 2);
          if (k % ctx.reseeds === 0) {
            md.update(ctx.pools[i].digest().getBytes());
            ctx.pools[i].start();
          }
        }
        var keyBytes = md.digest().getBytes();
        md.start();
        md.update(keyBytes);
        var seedBytes = md.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        if (typeof window !== 'undefined') {
          var _crypto = window.crypto || window.msCrypto;
          if (_crypto && _crypto.getRandomValues) {
            getRandomValues = function(arr) {
              return _crypto.getRandomValues(arr);
            };
          }
        }
        var b = forge.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i = 0; i < entropy.length; ++i) {
                b.putInt32(entropy[i]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== 'undefined' && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi,
              lo,
              next;
          var seed = Math.floor(Math.random() * 0x010000);
          while (b.length() < needed) {
            lo = 16807 * (seed & 0xFFFF);
            hi = 16807 * (seed >> 16);
            lo += (hi & 0x7FFF) << 16;
            lo += hi >> 15;
            lo = (lo & 0x7FFFFFFF) + (lo >> 31);
            seed = lo & 0xFFFFFFFF;
            for (var i = 0; i < 3; ++i) {
              next = seed >>> (i << 3);
              next ^= Math.floor(Math.random() * 0x0100);
              b.putByte(String.fromCharCode(next & 0xFF));
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i = 0; i < count; ++i) {
          ctx.pools[ctx.pool].update(bytes.substr(i, 1));
          ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i, n) {
        var bytes = '';
        for (var x = 0; x < n; x += 8) {
          bytes += String.fromCharCode((i >> x) & 0xFF);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener('message', listener);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener('message', listener);
            self.postMessage({forge: {prng: {needed: needed}}});
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({forge: {prng: {
                      err: err,
                      bytes: bytes
                    }}});
              });
            }
          };
          worker.addEventListener('message', listener);
        }
      };
      return ctx;
    };
  }
  var name = 'prng';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/prng", ["require", "module", "npm:node-forge@0.6.35/js/md", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    if (forge.random && forge.random.getBytes) {
      return;
    }
    (function(jQuery) {
      var prng_aes = {};
      var _prng_aes_output = new Array(4);
      var _prng_aes_buffer = forge.util.createBuffer();
      prng_aes.formatKey = function(key) {
        var tmp = forge.util.createBuffer(key);
        key = new Array(4);
        key[0] = tmp.getInt32();
        key[1] = tmp.getInt32();
        key[2] = tmp.getInt32();
        key[3] = tmp.getInt32();
        return forge.aes._expandKey(key, false);
      };
      prng_aes.formatSeed = function(seed) {
        var tmp = forge.util.createBuffer(seed);
        seed = new Array(4);
        seed[0] = tmp.getInt32();
        seed[1] = tmp.getInt32();
        seed[2] = tmp.getInt32();
        seed[3] = tmp.getInt32();
        return seed;
      };
      prng_aes.cipher = function(key, seed) {
        forge.aes._updateBlock(key, seed, _prng_aes_output, false);
        _prng_aes_buffer.putInt32(_prng_aes_output[0]);
        _prng_aes_buffer.putInt32(_prng_aes_output[1]);
        _prng_aes_buffer.putInt32(_prng_aes_output[2]);
        _prng_aes_buffer.putInt32(_prng_aes_output[3]);
        return _prng_aes_buffer.getBytes();
      };
      prng_aes.increment = function(seed) {
        ++seed[3];
        return seed;
      };
      prng_aes.md = forge.md.sha256;
      function spawnPrng() {
        var ctx = forge.prng.create(prng_aes);
        ctx.getBytes = function(count, callback) {
          return ctx.generate(count, callback);
        };
        ctx.getBytesSync = function(count) {
          return ctx.generate(count);
        };
        return ctx;
      }
      var _ctx = spawnPrng();
      var _nodejs = (typeof process !== 'undefined' && process.versions && process.versions.node);
      var getRandomValues = null;
      if (typeof window !== 'undefined') {
        var _crypto = window.crypto || window.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
      }
      if (forge.disableNativeCode || (!_nodejs && !getRandomValues)) {
        if (typeof window === 'undefined' || window.document === undefined) {}
        _ctx.collectInt(+new Date(), 32);
        if (typeof(navigator) !== 'undefined') {
          var _navBytes = '';
          for (var key in navigator) {
            try {
              if (typeof(navigator[key]) == 'string') {
                _navBytes += navigator[key];
              }
            } catch (e) {}
          }
          _ctx.collect(_navBytes);
          _navBytes = null;
        }
        if (jQuery) {
          jQuery().mousemove(function(e) {
            _ctx.collectInt(e.clientX, 16);
            _ctx.collectInt(e.clientY, 16);
          });
          jQuery().keypress(function(e) {
            _ctx.collectInt(e.charCode, 8);
          });
        }
      }
      if (!forge.random) {
        forge.random = _ctx;
      } else {
        for (var key in _ctx) {
          forge.random[key] = _ctx[key];
        }
      }
      forge.random.createInstance = spawnPrng;
    })(typeof(jQuery) !== 'undefined' ? jQuery : null);
  }
  var name = 'random';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/random", ["require", "module", "npm:node-forge@0.6.35/js/aes", "npm:node-forge@0.6.35/js/md", "npm:node-forge@0.6.35/js/prng", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var piTable = [0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d, 0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2, 0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32, 0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82, 0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc, 0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26, 0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03, 0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7, 0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a, 0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec, 0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39, 0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31, 0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9, 0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9, 0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e, 0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad];
    var s = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return ((word << bits) & 0xffff) | ((word & 0xffff) >> (16 - bits));
    };
    var ror = function(word, bits) {
      return ((word & 0xffff) >> bits) | ((word << (16 - bits)) & 0xffff);
    };
    forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === 'string') {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 0xff >> (T1 & 0x07);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[(L.at(i - 1) + L.at(i - T)) & 0xff]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher = function(key, bits, encrypt) {
      var _finish = false,
          _input = null,
          _output = null,
          _iv = null;
      var mixRound,
          mashRound;
      var i,
          j,
          K = [];
      key = forge.rc2.expandKey(key, bits);
      for (i = 0; i < 64; i++) {
        K.push(key.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);
            R[i] = rol(R[i], s[i]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[R[(i + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s[i]);
            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K[R[(i + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 0xffff);
        }
        j = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      };
      var cipher = null;
      cipher = {
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === 'string') {
              iv = forge.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([[5, mixRound], [1, mashRound], [6, mixRound], [1, mashRound], [5, mixRound]]);
          }
        },
        finish: function(pad) {
          var rval = true;
          if (encrypt) {
            if (pad) {
              rval = pad(8, _input, !encrypt);
            } else {
              var padding = (_input.length() === 8) ? 8 : (8 - _input.length());
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = (_input.length() === 0);
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
  var name = 'rc2';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/rc2", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var dbits;
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary & 0xffffff) == 0xefcafe);
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a)
          this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i++] + w.data[j] + c;
        c = Math.floor(v / 0x4000000);
        w.data[j++] = v & 0x3ffffff;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 0x7fff,
          xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 0x7fff;
        var h = this.data[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x7fff) << 15) + w.data[j] + (c & 0x3fffffff);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 0x3fffffff;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 0x3fff,
          xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 0x3fff;
        var h = this.data[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x3fff) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 0xfffffff;
      }
      return c;
    }
    if (typeof(navigator) === 'undefined') {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1 << dbits) - 1);
    BigInteger.prototype.DV = (1 << dbits);
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,
        vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c == null) ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r.data[i] = this.data[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x < 0) ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length,
          mi = false,
          sh = 0;
      while (--i >= 0) {
        var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
          this.data[this.t++] = (x >> (this.DB - sh));
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 0x80) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1,
          d,
          m = false,
          r = "",
          i = this.t;
      var p = this.DB - (i * this.DB) % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this.data[i] & ((1 << p) - 1)) << (k - p);
            d |= this.data[--i] >> (p += this.DB - k);
          } else {
            d = (this.data[i] >> (p -= k)) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return (this.s < 0) ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return (this.s < 0) ? -r : r;
      while (--i >= 0)
        if ((r = this.data[i] - a.data[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1,
          t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ (this.s & this.DM));
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i)
        r.data[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r.data[i - n] = this.data[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB),
          c = (this.s << bs) & this.DM,
          i;
      for (i = this.t - 1; i >= 0; --i) {
        r.data[i + ds + 1] = (this.data[i] >> cbs) | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r.data[i] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
        r.data[i - ds] = this.data[i] >> bs;
      }
      if (bs > 0)
        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0,
          c = 0,
          m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] - a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c < 0) ? -1 : 0;
      if (c < -1)
        r.data[i++] = this.DV + c;
      else if (c > 0)
        r.data[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(),
          y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < y.t; ++i)
        r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r.data[i + x.t] -= x.DV;
          r.data[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(),
          ts = this.s,
          ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + ((ys > 1) ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt,
          d2 = (1 << this.F1) / yt,
          e = 1 << this.F2;
      var i = r.t,
          j = i - ys,
          t = (q == null) ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = (r.data[--i] == y0) ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = (y * (2 - (x & 0xf) * y)) & 0xf;
      y = (y * (2 - (x & 0xff) * y)) & 0xff;
      y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;
      y = (y * (2 - x * y % this.DV)) % this.DV;
      return (y > 0) ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 0x7fff;
      this.mph = this.mp >> 15;
      this.um = (1 << (m.DB - 15)) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 0x7fff;
        var u0 = (j * this.mpl + (((j * this.mph + (x.data[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return ((this.t > 0) ? (this.data[0] & 1) : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 0xffffffff || e < 1)
        return BigInteger.ONE;
      var r = nbi(),
          r2 = nbi(),
          g = z.convert(this),
          i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & (1 << i)) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return ((this.data[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this.data[0];
    }
    function bnByteValue() {
      return (this.t == 0) ? this.s : (this.data[0] << 24) >> 24;
    }
    function bnShortValue() {
      return (this.t == 0) ? this.s : (this.data[0] << 16) >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || (this.t == 1 && this.data[0] <= 0))
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a),
          y = nbi(),
          z = nbi(),
          r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs),
          mi = false,
          j = 0,
          w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(),
            t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= ((1 << t) - 1);
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t,
          r = new Array();
      r[0] = this.s;
      var p = this.DB - (i * this.DB) % 8,
          d,
          k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | (this.s << (this.DB - p));
        while (i >= 0) {
          if (p < 8) {
            d = (this.data[i] & ((1 << p) - 1)) << (8 - p);
            d |= this.data[--i] >> (p += this.DB - 8);
          } else {
            d = (this.data[i] >> (p -= 8)) & 0xff;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 0x80) != 0)
            d |= -256;
          if (k == 0 && (this.s & 0x80) != (d & 0x80))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return (this.compareTo(a) == 0);
    }
    function bnMin(a) {
      return (this.compareTo(a) < 0) ? this : a;
    }
    function bnMax(a) {
      return (this.compareTo(a) > 0) ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i,
          f,
          m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r.data[i] = op(this.data[i], a.data[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r.data[i] = op(this.data[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r.data[i] = op(f, a.data[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r.data[i] = this.DM & ~this.data[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 0xffff) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 0xff) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 0xf) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0)
          return i * this.DB + lbit(this.data[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0,
          x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this.data[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return (this.s != 0);
      return ((this.data[j] & (1 << (n % this.DB))) != 0);
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0,
          c = 0,
          m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] + a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c < 0) ? -1 : 0;
      if (c > 0)
        r.data[i++] = c;
      else if (c < -1)
        r.data[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(),
          r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {}
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r.data[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a.data[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(),
          k,
          r = nbv(1),
          z;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(),
          n = 3,
          k1 = k - 1,
          km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1,
          w,
          is1 = true,
          r2 = nbi(),
          t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = (e.data[j] >> (i - k1)) & km;
        else {
          w = (e.data[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
          if (j > 0)
            w |= e.data[j - 1] >> (this.DB + i - k1);
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & (1 << i)) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = (this.s < 0) ? this.negate() : this.clone();
      var y = (a.s < 0) ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(),
          g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n,
          r = (this.s < 0) ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this.data[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this.data[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if ((this.isEven() && ac) || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(),
          v = this.clone();
      var a = nbv(1),
          b = nbv(0),
          c = nbv(0),
          d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i,
          x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i],
            j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i = 0; i < t; ++i) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {nextBytes: function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 0x0100);
          }
        }};
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    forge.jsbn = forge.jsbn || {};
    forge.jsbn.BigInteger = BigInteger;
  }
  var name = 'jsbn';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/jsbn", ["require", "module"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var pkcs1 = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === 'string') {
        label = options;
        seed = arguments[3] || undefined;
        md = arguments[4] || undefined;
      } else if (options) {
        label = options.label || undefined;
        seed = options.seed || undefined;
        md = options.md || undefined;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error('RSAES-OAEP input message length is too long.');
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = '';
      }
      md.update(label, 'raw');
      var lHash = md.digest();
      var PS = '';
      var PS_length = maxLength - message.length;
      for (var i = 0; i < PS_length; i++) {
        PS += '\x00';
      }
      var DB = lHash.getBytes() + PS + '\x01' + message;
      if (!seed) {
        seed = forge.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' + 'match the digest length.');
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return '\x00' + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === 'string') {
        label = options;
        md = arguments[3] || undefined;
      } else if (options) {
        label = options.label || undefined;
        md = options.md || undefined;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error('RSAES-OAEP encoded message length is invalid.');
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === undefined) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error('RSAES-OAEP key is too short for the hash function.');
      }
      if (!label) {
        label = '';
      }
      md.update(label, 'raw');
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = (y !== '\x00');
      for (var i = 0; i < md.digestLength; ++i) {
        error |= (lHash.charAt(i) !== lHashPrime.charAt(i));
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code = db.charCodeAt(j);
        var is_0 = (code & 0x1) ^ 0x1;
        var error_mask = in_ps ? 0xfffe : 0x0000;
        error |= (code & error_mask);
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 0x1) {
        throw new Error('Invalid RSAES-OAEP padding.');
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash) {
      if (!hash) {
        hash = forge.md.sha1.create();
      }
      var t = '';
      var count = Math.ceil(maskLength / hash.digestLength);
      for (var i = 0; i < count; ++i) {
        var c = String.fromCharCode((i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);
        hash.start();
        hash.update(seed + c);
        t += hash.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
  var name = 'pkcs1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pkcs1", ["require", "module", "npm:node-forge@0.6.35/js/util", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/sha1"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    if (forge.prime) {
      return;
    }
    var prime = forge.prime = forge.prime || {};
    var BigInteger = forge.jsbn.BigInteger;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    var op_or = function(x, y) {
      return x | y;
    };
    prime.generateProbablePrime = function(bits, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      var algorithm = options.algorithm || 'PRIMEINC';
      if (typeof algorithm === 'string') {
        algorithm = {name: algorithm};
      }
      algorithm.options = algorithm.options || {};
      var prng = options.prng || forge.random;
      var rng = {nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }};
      if (algorithm.name === 'PRIMEINC') {
        return primeincFindPrime(bits, rng, algorithm.options, callback);
      }
      throw new Error('Invalid prime generation algorithm: ' + algorithm.name);
    };
    function primeincFindPrime(bits, rng, options, callback) {
      if ('workers' in options) {
        return primeincFindPrimeWithWorkers(bits, rng, options, callback);
      }
      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    }
    function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
      var num = generateRandom(bits, rng);
      var deltaIdx = 0;
      var mrTests = getMillerRabinTests(num.bitLength());
      if ('millerRabinTests' in options) {
        mrTests = options.millerRabinTests;
      }
      var maxBlockTime = 10;
      if ('maxBlockTime' in options) {
        maxBlockTime = options.maxBlockTime;
      }
      var start = +new Date();
      do {
        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng);
        }
        if (num.isProbablePrime(mrTests)) {
          return callback(null, num);
        }
        num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
      } while (maxBlockTime < 0 || (+new Date() - start < maxBlockTime));
      forge.util.setImmediate(function() {
        primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      });
    }
    function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
      if (typeof Worker === 'undefined') {
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      var num = generateRandom(bits, rng);
      var numWorkers = options.workers;
      var workLoad = options.workLoad || 100;
      var range = workLoad * 30 / 8;
      var workerScript = options.workerScript || 'forge/prime.worker.js';
      if (numWorkers === -1) {
        return forge.util.estimateCores(function(err, cores) {
          if (err) {
            cores = 2;
          }
          numWorkers = cores - 1;
          generate();
        });
      }
      generate();
      function generate() {
        numWorkers = Math.max(1, numWorkers);
        var workers = [];
        for (var i = 0; i < numWorkers; ++i) {
          workers[i] = new Worker(workerScript);
        }
        var running = numWorkers;
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].addEventListener('message', workerMessage);
        }
        var found = false;
        function workerMessage(e) {
          if (found) {
            return;
          }
          --running;
          var data = e.data;
          if (data.found) {
            for (var i = 0; i < workers.length; ++i) {
              workers[i].terminate();
            }
            found = true;
            return callback(null, new BigInteger(data.prime, 16));
          }
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          var hex = num.toString(16);
          e.target.postMessage({
            hex: hex,
            workLoad: workLoad
          });
          num.dAddOffset(range, 0);
        }
      }
    }
    function generateRandom(bits, rng) {
      var num = new BigInteger(bits, rng);
      var bits1 = bits - 1;
      if (!num.testBit(bits1)) {
        num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
      }
      num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
      return num;
    }
    function getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
  }
  var name = 'prime';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/prime", ["require", "module", "npm:node-forge@0.6.35/js/util", "npm:node-forge@0.6.35/js/jsbn", "npm:node-forge@0.6.35/js/random"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    if (typeof BigInteger === 'undefined') {
      var BigInteger = forge.jsbn.BigInteger;
    }
    var asn1 = forge.asn1;
    forge.pki = forge.pki || {};
    forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      name: 'PrivateKeyInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PrivateKeyInfo.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyVersion'
      }, {
        name: 'PrivateKeyInfo.privateKeyAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'AlgorithmIdentifier.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'privateKeyOid'
        }]
      }, {
        name: 'PrivateKeyInfo',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'privateKey'
      }]
    };
    var rsaPrivateKeyValidator = {
      name: 'RSAPrivateKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'RSAPrivateKey.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyVersion'
      }, {
        name: 'RSAPrivateKey.modulus',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyModulus'
      }, {
        name: 'RSAPrivateKey.publicExponent',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyPublicExponent'
      }, {
        name: 'RSAPrivateKey.privateExponent',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyPrivateExponent'
      }, {
        name: 'RSAPrivateKey.prime1',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyPrime1'
      }, {
        name: 'RSAPrivateKey.prime2',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyPrime2'
      }, {
        name: 'RSAPrivateKey.exponent1',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyExponent1'
      }, {
        name: 'RSAPrivateKey.exponent2',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyExponent2'
      }, {
        name: 'RSAPrivateKey.coefficient',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'privateKeyCoefficient'
      }]
    };
    var rsaPublicKeyValidator = {
      name: 'RSAPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'RSAPublicKey.modulus',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'publicKeyModulus'
      }, {
        name: 'RSAPublicKey.exponent',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'publicKeyExponent'
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: 'SubjectPublicKeyInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'subjectPublicKeyInfo',
      value: [{
        name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'AlgorithmIdentifier.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'publicKeyOid'
        }]
      }, {
        name: 'SubjectPublicKeyInfo.subjectPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: 'rsaPublicKey'
        }]
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error('Unknown message digest algorithm.');
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));
      var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = (bt === 0x02);
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0x00);
        --zeros;
      }
      ed.putBytes(forge.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error('Encrypted message length is invalid.');
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error('Encrypted message is invalid.');
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0x00);
        --zeros;
      }
      eb.putBytes(forge.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof(bits) === 'string') {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }};
      var algorithm = options.algorithm || 'PRIMEINC';
      var rval;
      if (algorithm === 'PRIMEINC') {
        rval = {
          algorithm: algorithm,
          state: 0,
          bits: bits,
          rng: rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error('Invalid key generation algorithm: ' + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!('algorithm' in state)) {
        state.algorithm = 'PRIMEINC';
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = (state.p === null) ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = (state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0) ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === 'object') {
          options = bits;
          bits = undefined;
        } else if (typeof bits === 'function') {
          callback = bits;
          bits = undefined;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === 'number') {
          if (typeof e === 'function') {
            callback = e;
            e = undefined;
          } else if (typeof e !== 'number') {
            options = e;
            e = undefined;
          }
        } else {
          options = bits;
          callback = e;
          bits = undefined;
          e = undefined;
        }
      } else if (arguments.length === 3) {
        if (typeof e === 'number') {
          if (typeof options === 'function') {
            callback = options;
            options = undefined;
          }
        } else {
          callback = options;
          options = e;
          e = undefined;
        }
      }
      options = options || {};
      if (bits === undefined) {
        bits = options.bits || 2048;
      }
      if (e === undefined) {
        e = options.e || 0x10001;
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key = {
        n: n,
        e: e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === 'string') {
          scheme = scheme.toUpperCase();
        } else if (scheme === undefined) {
          scheme = 'RSAES-PKCS1-V1_5';
        }
        if (scheme === 'RSAES-PKCS1-V1_5') {
          scheme = {encode: function(m, key, pub) {
              return _encodePkcs1_v1_5(m, key, 0x02).getBytes();
            }};
        } else if (scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
          scheme = {encode: function(m, key) {
              return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
            }};
        } else if (['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
          scheme = {encode: function(e) {
              return e;
            }};
        } else if (typeof scheme === 'string') {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e, key, true);
      };
      key.verify = function(digest, signature, scheme) {
        if (typeof scheme === 'string') {
          scheme = scheme.toUpperCase();
        } else if (scheme === undefined) {
          scheme = 'RSASSA-PKCS1-V1_5';
        }
        if (scheme === 'RSASSA-PKCS1-V1_5') {
          scheme = {verify: function(digest, d) {
              d = _decodePkcs1_v1_5(d, key, true);
              var obj = asn1.fromDer(d);
              return digest === obj.value[1].value;
            }};
        } else if (scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
          scheme = {verify: function(digest, d) {
              d = _decodePkcs1_v1_5(d, key, true);
              return digest === d;
            }};
        }
        var d = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest, d, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n: n,
        e: e,
        d: d,
        p: p,
        q: q,
        dP: dP,
        dQ: dQ,
        qInv: qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === 'string') {
          scheme = scheme.toUpperCase();
        } else if (scheme === undefined) {
          scheme = 'RSAES-PKCS1-V1_5';
        }
        var d = pki.rsa.decrypt(data, key, false, false);
        if (scheme === 'RSAES-PKCS1-V1_5') {
          scheme = {decode: _decodePkcs1_v1_5};
        } else if (scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
          scheme = {decode: function(d, key) {
              return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
            }};
        } else if (['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
          scheme = {decode: function(d) {
              return d;
            }};
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === 'string') {
          scheme = scheme.toUpperCase();
        }
        if (scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {
          scheme = {encode: emsaPkcs1v15encode};
          bt = 0x01;
        } else if (scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
          scheme = {encode: function() {
              return md;
            }};
          bt = 0x01;
        }
        var d = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error('Cannot read private key. ' + 'ASN.1 object does not contain an RSAPrivateKey.');
        error.errors = errors;
        throw error;
      }
      var n,
          e,
          d,
          p,
          q,
          dP,
          dQ,
          qInv;
      n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error('Cannot read public key. Unknown OID.');
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error('Cannot read public key. ' + 'ASN.1 object does not contain an RSAPublicKey.');
        error.errors = errors;
        throw error;
      }
      var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [pki.publicKeyToRSAPublicKey(key)])]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > (k - 11)) {
        var error = new Error('Message is too long for PKCS#1 v1.5 padding.');
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0x00);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0x00 || bt === 0x01) {
        padByte = (bt === 0x00) ? 0x00 : 0xFF;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0x00);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0x00 || (pub && bt !== 0x00 && bt !== 0x01) || (!pub && bt != 0x02) || (pub && bt === 0x00 && typeof(ml) === 'undefined')) {
        throw new Error('Encryption block is invalid.');
      }
      var padNum = 0;
      if (bt === 0x00) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0x00) {
            throw new Error('Encryption block is invalid.');
          }
        }
      } else if (bt === 0x01) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 0xFF) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 0x02) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0x00) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0x00 || padNum !== (k - 3 - eb.length())) {
        throw new Error('Encryption block is invalid.');
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {algorithm: {
          name: options.algorithm || 'PRIMEINC',
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }};
      if ('prng' in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback) {
        forge.prime.generateProbablePrime(bits, opts, callback);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= '8') {
        hex = '00' + hex;
      }
      return forge.util.hexToBytes(hex);
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
  }
  var name = 'rsa';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/rsa", ["require", "module", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/jsbn", "npm:node-forge@0.6.35/js/oids", "npm:node-forge@0.6.35/js/pkcs1", "npm:node-forge@0.6.35/js/prime", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    if (typeof BigInteger === 'undefined') {
      var BigInteger = forge.jsbn.BigInteger;
    }
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    pki.pbe = forge.pbe = forge.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: 'EncryptedPrivateKeyInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'AlgorithmIdentifier.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'encryptionOid'
        }, {
          name: 'AlgorithmIdentifier.parameters',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'encryptionParams'
        }]
      }, {
        name: 'EncryptedPrivateKeyInfo.encryptedData',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'encryptedData'
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: 'PBES2Algorithms',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PBES2Algorithms.keyDerivationFunc',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'PBES2Algorithms.keyDerivationFunc.oid',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'kdfOid'
        }, {
          name: 'PBES2Algorithms.params',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'PBES2Algorithms.params.salt',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: 'kdfSalt'
          }, {
            name: 'PBES2Algorithms.params.iterationCount',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            onstructed: true,
            capture: 'kdfIterationCount'
          }]
        }]
      }, {
        name: 'PBES2Algorithms.encryptionScheme',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'PBES2Algorithms.encryptionScheme.oid',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'encOid'
        }, {
          name: 'PBES2Algorithms.encryptionScheme.iv',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: 'encIv'
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: 'pkcs-12PbeParams',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'pkcs-12PbeParams.salt',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'salt'
      }, {
        name: 'pkcs-12PbeParams.iterations',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'iterations'
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || 'aes128';
      var salt = forge.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {
        var ivLen,
            encOid,
            cipherFn;
        switch (options.algorithm) {
          case 'aes128':
            dkLen = 16;
            ivLen = 16;
            encOid = oids['aes128-CBC'];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case 'aes192':
            dkLen = 24;
            ivLen = 16;
            encOid = oids['aes192-CBC'];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case 'aes256':
            dkLen = 32;
            ivLen = 16;
            encOid = oids['aes256-CBC'];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case 'des':
            dkLen = 8;
            ivLen = 8;
            encOid = oids['desCBC'];
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
            error.algorithm = options.algorithm;
            throw error;
        }
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen);
        var iv = forge.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pkcs5PBES2']).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())])]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)])])]);
      } else if (options.algorithm === '3des') {
        dkLen = 24;
        var saltBytes = new forge.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())])]);
      } else {
        var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [encryptionAlgorithm, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error('Cannot read encrypted private key. ' + 'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: 'ENCRYPTED PRIVATE KEY',
        body: asn1.toDer(epki).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'ENCRYPTED PRIVATE KEY') {
        var error = new Error('Could not convert encrypted private key from PEM; ' + 'PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert encrypted private key from PEM; ' + 'PEM is encrypted.');
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case 'aes128':
          algorithm = 'AES-128-CBC';
          dkLen = 16;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case 'aes192':
          algorithm = 'AES-192-CBC';
          dkLen = 24;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case 'aes256':
          algorithm = 'AES-256-CBC';
          dkLen = 32;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case '3des':
          algorithm = 'DES-EDE3-CBC';
          dkLen = 24;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        case 'des':
          algorithm = 'DES-CBC';
          dkLen = 8;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported ' + 'encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: 'RSA PRIVATE KEY',
        procType: {
          version: '4',
          type: 'ENCRYPTED'
        },
        dekInfo: {
          algorithm: algorithm,
          parameters: forge.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'ENCRYPTED PRIVATE KEY' && msg.type !== 'PRIVATE KEY' && msg.type !== 'RSA PRIVATE KEY') {
        var error = new Error('Could not convert private key from PEM; PEM header type ' + 'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case 'DES-CBC':
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case 'DES-EDE3-CBC':
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case 'AES-128-CBC':
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case 'AES-192-CBC':
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case 'AES-256-CBC':
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case 'RC2-40-CBC':
            dkLen = 5;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case 'RC2-64-CBC':
            dkLen = 8;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case 'RC2-128-CBC':
            dkLen = 16;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported ' + 'encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === 'ENCRYPTED PRIVATE KEY') {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j,
          l;
      if (typeof md === 'undefined' || md === null) {
        md = forge.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge.util.ByteBuffer();
      var passBuf = new forge.util.ByteBuffer();
      if (password !== null && password !== undefined) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf = new forge.util.ByteBuffer();
        buf.putBytes(D.bytes());
        buf.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B = new forge.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge.util.ByteBuffer(I.getBytes(v));
          var x = 0x1ff;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 0xff);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids['pkcs5PBES2']:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
        case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');
          error.oid = oid;
          error.supportedOids = ['pkcs5PBES2', 'pbeWithSHAAnd3-KeyTripleDES-CBC', 'pbewithSHAAnd40BitRC2-CBC'];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error('Cannot read password-based-encryption algorithm ' + 'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids['pkcs5PBKDF2']) {
        var error = new Error('Cannot read encrypted private key. ' + 'Unsupported key derivation function OID.');
        error.oid = oid;
        error.supportedOids = ['pkcs5PBKDF2'];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids['aes128-CBC'] && oid !== pki.oids['aes192-CBC'] && oid !== pki.oids['aes256-CBC'] && oid !== pki.oids['des-EDE3-CBC'] && oid !== pki.oids['desCBC']) {
        var error = new Error('Cannot read encrypted private key. ' + 'Unsupported encryption scheme OID.');
        error.oid = oid;
        error.supportedOids = ['aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case 'aes128-CBC':
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case 'aes192-CBC':
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case 'aes256-CBC':
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case 'des-EDE3-CBC':
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case 'desCBC':
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
      }
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error('Cannot read password-based-encryption algorithm ' + 'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
        error.errors = errors;
        throw error;
      }
      var salt = forge.util.createBuffer(capture.salt);
      var count = forge.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen,
          dIvLen,
          cipherFn;
      switch (oid) {
        case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge.des.startDecrypting;
          break;
        case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key, iv) {
            var cipher = forge.rc2.createDecryptionCipher(key, 40);
            cipher.start(iv, null);
            return cipher;
          };
          break;
        default:
          var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');
          error.oid = oid;
          throw error;
      }
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen);
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === 'undefined' || md === null) {
        md = forge.md.md5.create();
      }
      if (salt === null) {
        salt = '';
      }
      var digests = [hash(md, password + salt)];
      for (var length = 16,
          i = 1; length < dkLen; ++i, length += 16) {
        digests.push(hash(md, digests[i - 1] + password + salt));
      }
      return digests.join('').substr(0, dkLen);
    };
    function hash(md, bytes) {
      return md.start().update(bytes).digest().getBytes();
    }
  }
  var name = 'pbe';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pbe", ["require", "module", "npm:node-forge@0.6.35/js/aes", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/des", "npm:node-forge@0.6.35/js/md", "npm:node-forge@0.6.35/js/oids", "npm:node-forge@0.6.35/js/pem", "npm:node-forge@0.6.35/js/pbkdf2", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/rc2", "npm:node-forge@0.6.35/js/rsa", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var p7v = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
    forge.pkcs7 = forge.pkcs7 || {};
    forge.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: 'ContentInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'ContentInfo.ContentType',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'contentType'
      }, {
        name: 'ContentInfo.content',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: 'content'
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: 'EncryptedContentInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'EncryptedContentInfo.contentType',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'contentType'
      }, {
        name: 'EncryptedContentInfo.contentEncryptionAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'encAlgorithm'
        }, {
          name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: 'encParameter'
        }]
      }, {
        name: 'EncryptedContentInfo.encryptedContent',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: 'encryptedContent',
        captureAsn1: 'encryptedContentAsn1'
      }]
    };
    p7v.envelopedDataValidator = {
      name: 'EnvelopedData',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'EnvelopedData.Version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }, {
        name: 'EnvelopedData.RecipientInfos',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: 'recipientInfos'
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: 'EncryptedData',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'EncryptedData.Version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: 'SignerInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'SignerInfo.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: 'SignerInfo.issuerAndSerialNumber',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'SignerInfo.issuerAndSerialNumber.issuer',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'issuer'
        }, {
          name: 'SignerInfo.issuerAndSerialNumber.serialNumber',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: 'serial'
        }]
      }, {
        name: 'SignerInfo.digestAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'SignerInfo.digestAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'digestAlgorithm'
        }, {
          name: 'SignerInfo.digestAlgorithm.parameter',
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: 'digestParameter',
          optional: true
        }]
      }, {
        name: 'SignerInfo.authenticatedAttributes',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: 'authenticatedAttributes'
      }, {
        name: 'SignerInfo.digestEncryptionAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: 'signatureAlgorithm'
      }, {
        name: 'SignerInfo.encryptedDigest',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'signature'
      }, {
        name: 'SignerInfo.unauthenticatedAttributes',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: 'unauthenticatedAttributes'
      }]
    };
    p7v.signedDataValidator = {
      name: 'SignedData',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'SignedData.Version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }, {
        name: 'SignedData.DigestAlgorithms',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: 'digestAlgorithms'
      }, contentInfoValidator, {
        name: 'SignedData.Certificates',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        optional: true,
        captureAsn1: 'certificates'
      }, {
        name: 'SignedData.CertificateRevocationLists',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        optional: true,
        captureAsn1: 'crls'
      }, {
        name: 'SignedData.SignerInfos',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        capture: 'signerInfos',
        optional: true,
        value: [signerValidator]
      }]
    };
    p7v.recipientInfoValidator = {
      name: 'RecipientInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'RecipientInfo.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }, {
        name: 'RecipientInfo.issuerAndSerial',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'RecipientInfo.issuerAndSerial.issuer',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'issuer'
        }, {
          name: 'RecipientInfo.issuerAndSerial.serialNumber',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: 'serial'
        }]
      }, {
        name: 'RecipientInfo.keyEncryptionAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'encAlgorithm'
        }, {
          name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: 'encParameter'
        }]
      }, {
        name: 'RecipientInfo.encryptedKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'encKey'
      }]
    };
  }
  var name = 'pkcs7asn1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pkcs7asn1", ["require", "module", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.mgf = forge.mgf || {};
    var mgf1 = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {generate: function(seed, maskLen) {
          var t = new forge.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }};
      return mgf;
    };
  }
  var name = 'mgf1';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/mgf1", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.mgf = forge.mgf || {};
    forge.mgf.mgf1 = forge.mgf1;
  }
  var name = 'mgf';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/mgf", ["require", "module", "npm:node-forge@0.6.35/js/mgf1"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var pss = forge.pss = forge.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash = options.md;
      var mgf = options.mgf;
      var hLen = hash.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === 'string') {
        salt_ = forge.util.createBuffer(salt_);
      }
      var sLen;
      if ('saltLength' in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error('Salt length not specified or specific salt not given.');
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error('Given salt length does not match length of given salt.');
      }
      var prng = options.prng || forge.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error('Message is too long to encrypt.');
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h = hash.digest().getBytes();
        var ps = new forge.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(0x01);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = '';
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(0xbc);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error('Inconsistent parameters to PSS signature verification.');
        }
        if (em.charCodeAt(emLen - 1) !== 0xbc) {
          throw new Error('Encoded message does not end in 0xBC.');
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error('Bits beyond keysize not zero as expected.');
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = '';
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen; i++) {
          if (db.charCodeAt(i) !== 0x00) {
            throw new Error('Leftmost octets not zero as expected');
          }
        }
        if (db.charCodeAt(checkLen) !== 0x01) {
          throw new Error('Inconsistent PSS signature, 0x01 marker not found');
        }
        var salt = db.substr(-sLen);
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h_ = hash.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
  var name = 'pss';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pss", ["require", "module", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames['CN'] = oids['commonName'];
    _shortNames['commonName'] = 'CN';
    _shortNames['C'] = oids['countryName'];
    _shortNames['countryName'] = 'C';
    _shortNames['L'] = oids['localityName'];
    _shortNames['localityName'] = 'L';
    _shortNames['ST'] = oids['stateOrProvinceName'];
    _shortNames['stateOrProvinceName'] = 'ST';
    _shortNames['O'] = oids['organizationName'];
    _shortNames['organizationName'] = 'O';
    _shortNames['OU'] = oids['organizationalUnitName'];
    _shortNames['organizationalUnitName'] = 'OU';
    _shortNames['E'] = oids['emailAddress'];
    _shortNames['emailAddress'] = 'E';
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: 'Certificate',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'Certificate.TBSCertificate',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: 'tbsCertificate',
        value: [{
          name: 'Certificate.TBSCertificate.version',
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          value: [{
            name: 'Certificate.TBSCertificate.version.integer',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: 'certVersion'
          }]
        }, {
          name: 'Certificate.TBSCertificate.serialNumber',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: 'certSerialNumber'
        }, {
          name: 'Certificate.TBSCertificate.signature',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'Certificate.TBSCertificate.signature.algorithm',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: 'certinfoSignatureOid'
          }, {
            name: 'Certificate.TBSCertificate.signature.parameters',
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: 'certinfoSignatureParams'
          }]
        }, {
          name: 'Certificate.TBSCertificate.issuer',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'certIssuer'
        }, {
          name: 'Certificate.TBSCertificate.validity',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'Certificate.TBSCertificate.validity.notBefore (utc)',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: false,
            optional: true,
            capture: 'certValidity1UTCTime'
          }, {
            name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: false,
            optional: true,
            capture: 'certValidity2GeneralizedTime'
          }, {
            name: 'Certificate.TBSCertificate.validity.notAfter (utc)',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: false,
            optional: true,
            capture: 'certValidity3UTCTime'
          }, {
            name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: false,
            optional: true,
            capture: 'certValidity4GeneralizedTime'
          }]
        }, {
          name: 'Certificate.TBSCertificate.subject',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: 'certSubject'
        }, publicKeyValidator, {
          name: 'Certificate.TBSCertificate.issuerUniqueID',
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          optional: true,
          value: [{
            name: 'Certificate.TBSCertificate.issuerUniqueID.id',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            capture: 'certIssuerUniqueId'
          }]
        }, {
          name: 'Certificate.TBSCertificate.subjectUniqueID',
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          constructed: true,
          optional: true,
          value: [{
            name: 'Certificate.TBSCertificate.subjectUniqueID.id',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            capture: 'certSubjectUniqueId'
          }]
        }, {
          name: 'Certificate.TBSCertificate.extensions',
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 3,
          constructed: true,
          captureAsn1: 'certExtensions',
          optional: true
        }]
      }, {
        name: 'Certificate.signatureAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'Certificate.signatureAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'certSignatureOid'
        }, {
          name: 'Certificate.TBSCertificate.signature.parameters',
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: 'certSignatureParams'
        }]
      }, {
        name: 'Certificate.signatureValue',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        capture: 'certSignature'
      }]
    };
    var rsassaPssParameterValidator = {
      name: 'rsapss',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'rsapss.hashAlgorithm',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: 'hashOid'
          }]
        }]
      }, {
        name: 'rsapss.maskGenAlgorithm',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: 'maskGenOid'
          }, {
            name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: 'maskGenHashOid'
            }]
          }]
        }]
      }, {
        name: 'rsapss.saltLength',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: 'rsapss.saltLength.saltLength',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: 'saltLength'
        }]
      }, {
        name: 'rsapss.trailerField',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: 'rsapss.trailer.trailer',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: 'trailer'
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: 'CertificationRequestInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certificationRequestInfo',
      value: [{
        name: 'CertificationRequestInfo.integer',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'certificationRequestInfoVersion'
      }, {
        name: 'CertificationRequestInfo.subject',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: 'certificationRequestInfoSubject'
      }, publicKeyValidator, {
        name: 'CertificationRequestInfo.attributes',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: 'certificationRequestInfoAttributes',
        value: [{
          name: 'CertificationRequestInfo.attributes',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'CertificationRequestInfo.attributes.type',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false
          }, {
            name: 'CertificationRequestInfo.attributes.value',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true
          }]
        }]
      }]
    };
    var certificationRequestValidator = {
      name: 'CertificationRequest',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'csr',
      value: [certificationRequestInfoValidator, {
        name: 'CertificationRequest.signatureAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'CertificationRequest.signatureAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'csrSignatureOid'
        }, {
          name: 'CertificationRequest.signatureAlgorithm.parameters',
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: 'csrSignatureParams'
        }]
      }, {
        name: 'CertificationRequest.signature',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        capture: 'csrSignature'
      }]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set,
          attr,
          obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i = 0; i < set.value.length; ++i) {
          obj = {};
          attr = set.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === 'string') {
        options = {shortName: options};
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids['RSASSA-PSS']) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {algorithmOid: oids['sha1']},
          mgf: {
            algorithmOid: oids['mgf1'],
            hash: {algorithmOid: oids['sha1']}
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error('Cannot read RSASSA-PSS parameter block.');
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== undefined) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== undefined) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== undefined) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'CERTIFICATE' && msg.type !== 'X509 CERTIFICATE' && msg.type !== 'TRUSTED CERTIFICATE') {
        var error = new Error('Could not convert certificate from PEM; PEM header type ' + 'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert certificate from PEM; PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert, maxline) {
      var msg = {
        type: 'CERTIFICATE',
        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {
        var error = new Error('Could not convert public key from PEM; PEM header ' + 'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert public key from PEM; PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: 'PUBLIC KEY',
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: 'RSA PUBLIC KEY',
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.sha1.create();
      var type = options.type || 'RSAPublicKey';
      var bytes;
      switch (type) {
        case 'RSAPublicKey':
          bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case 'SubjectPublicKeyInfo':
          bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes);
      var digest = md.digest();
      if (options.encoding === 'hex') {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === 'binary') {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'CERTIFICATE REQUEST') {
        var error = new Error('Could not convert certification request from PEM; ' + 'PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert certification request from PEM; ' + 'PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: 'CERTIFICATE REQUEST',
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.createCertificate = function() {
      var cert = {};
      cert.version = 0x02;
      cert.serialNumber = '00';
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], {cert: cert});
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === 'string') {
          options = {name: options};
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
          ext = cert.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];
        if (!algorithmOid) {
          var error = new Error('Could not compute certificate digest. ' + 'Unknown message digest algorithm OID.');
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki.getTBSCertificate(cert);
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error('The parent certificate did not issue the given child ' + 'certificate; the child certificate\'s issuer does not match the ' + 'parent\'s subject.');
          error.expectedIssuer = issuer.attributes;
          error.actualIssuer = subject.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          if (child.signatureOid in oids) {
            var oid = oids[child.signatureOid];
            switch (oid) {
              case 'sha1WithRSAEncryption':
                md = forge.md.sha1.create();
                break;
              case 'md5WithRSAEncryption':
                md = forge.md.md5.create();
                break;
              case 'sha256WithRSAEncryption':
                md = forge.md.sha256.create();
                break;
              case 'RSASSA-PSS':
                md = forge.md.sha256.create();
                break;
            }
          }
          if (md === null) {
            var error = new Error('Could not compute certificate digest. ' + 'Unknown signature OID.');
            error.signatureOid = child.signatureOid;
            throw error;
          }
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes = asn1.toDer(tbsCertificate);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          var scheme;
          switch (child.signatureOid) {
            case oids.sha1WithRSAEncryption:
              scheme = undefined;
              break;
            case oids['RSASSA-PSS']:
              var hash,
                  mgf;
              hash = oids[child.signatureParameters.mgf.hash.algorithmOid];
              if (hash === undefined || forge.md[hash] === undefined) {
                var error = new Error('Unsupported MGF hash function.');
                error.oid = child.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              mgf = oids[child.signatureParameters.mgf.algorithmOid];
              if (mgf === undefined || forge.mgf[mgf] === undefined) {
                var error = new Error('Unsupported MGF function.');
                error.oid = child.signatureParameters.mgf.algorithmOid;
                error.name = mgf;
                throw error;
              }
              mgf = forge.mgf[mgf].create(forge.md[hash].create());
              hash = oids[child.signatureParameters.hash.algorithmOid];
              if (hash === undefined || forge.md[hash] === undefined) {
                throw {
                  message: 'Unsupported RSASSA-PSS hash function.',
                  oid: child.signatureParameters.hash.algorithmOid,
                  name: hash
                };
              }
              scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength);
              break;
          }
          rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i = cert.issuer;
        var s = parent.subject;
        if (i.hash && s.hash) {
          rval = (i.hash === s.hash);
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr,
              sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert.publicKey, {type: 'RSAPublicKey'});
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids['subjectKeyIdentifier'];
        for (var i = 0; i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return (forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski);
          }
        }
        return false;
      };
      return cert;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error('Cannot read X.509 certificate. ' + 'ASN.1 object is not an X509v3 Certificate.');
        error.errors = errors;
        throw error;
      }
      if (typeof capture.certSignature !== 'string') {
        var certSignature = '\x00';
        for (var i = 0; i < capture.certSignature.length; ++i) {
          certSignature += asn1.toDer(capture.certSignature[i]).getBytes();
        }
        capture.certSignature = certSignature;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids['rsaEncryption']) {
        throw new Error('Cannot read public key. OID is not RSA.');
      }
      var cert = pki.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
      cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
      var signature = forge.util.createBuffer(capture.certSignature);
      ++signature.read;
      cert.signature = signature.getBytes();
      var validity = [];
      if (capture.certValidity1UTCTime !== undefined) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== undefined) {
        validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
      }
      if (capture.certValidity3UTCTime !== undefined) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== undefined) {
        validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
      }
      if (validity.length > 2) {
        throw new Error('Cannot read notBefore/notAfter validity times; more ' + 'than two times were provided in the certificate.');
      }
      if (validity.length < 2) {
        throw new Error('Cannot read notBefore/notAfter validity times; they ' + 'were not provided as either UTCTime or GeneralizedTime.');
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = null;
        if (cert.signatureOid in oids) {
          var oid = oids[cert.signatureOid];
          switch (oid) {
            case 'sha1WithRSAEncryption':
              cert.md = forge.md.sha1.create();
              break;
            case 'md5WithRSAEncryption':
              cert.md = forge.md.md5.create();
              break;
            case 'sha256WithRSAEncryption':
              cert.md = forge.md.sha256.create();
              break;
            case 'RSASSA-PSS':
              cert.md = forge.md.sha256.create();
              break;
          }
        }
        if (cert.md === null) {
          var error = new Error('Could not compute certificate digest. ' + 'Unknown signature OID.');
          error.signatureOid = cert.signatureOid;
          throw error;
        }
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
      }
      var imd = forge.md.sha1.create();
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge.md.sha1.create();
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === 'keyUsage') {
          var ev = asn1.fromDer(e.value);
          var b2 = 0x00;
          var b3 = 0x00;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 0x80) === 0x80;
          e.nonRepudiation = (b2 & 0x40) === 0x40;
          e.keyEncipherment = (b2 & 0x20) === 0x20;
          e.dataEncipherment = (b2 & 0x10) === 0x10;
          e.keyAgreement = (b2 & 0x08) === 0x08;
          e.keyCertSign = (b2 & 0x04) === 0x04;
          e.cRLSign = (b2 & 0x02) === 0x02;
          e.encipherOnly = (b2 & 0x01) === 0x01;
          e.decipherOnly = (b3 & 0x80) === 0x80;
        } else if (e.name === 'basicConstraints') {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === 'extKeyUsage') {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === 'nsCertType') {
          var ev = asn1.fromDer(e.value);
          var b2 = 0x00;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 0x80) === 0x80;
          e.server = (b2 & 0x40) === 0x40;
          e.email = (b2 & 0x20) === 0x20;
          e.objsign = (b2 & 0x10) === 0x10;
          e.reserved = (b2 & 0x08) === 0x08;
          e.sslCA = (b2 & 0x04) === 0x04;
          e.emailCA = (b2 & 0x02) === 0x02;
          e.objCA = (b2 & 0x01) === 0x01;
        } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === 'subjectKeyIdentifier') {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#10 certificate request. ' + 'ASN.1 object is not a PKCS#10 CertificationRequest.');
        error.errors = errors;
        throw error;
      }
      if (typeof capture.csrSignature !== 'string') {
        var csrSignature = '\x00';
        for (var i = 0; i < capture.csrSignature.length; ++i) {
          csrSignature += asn1.toDer(capture.csrSignature[i]).getBytes();
        }
        capture.csrSignature = csrSignature;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error('Cannot read public key. OID is not RSA.');
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
      csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
      var signature = forge.util.createBuffer(capture.csrSignature);
      ++signature.read;
      csr.signature = signature.getBytes();
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = null;
        if (csr.signatureOid in oids) {
          var oid = oids[csr.signatureOid];
          switch (oid) {
            case 'sha1WithRSAEncryption':
              csr.md = forge.md.sha1.create();
              break;
            case 'md5WithRSAEncryption':
              csr.md = forge.md.md5.create();
              break;
            case 'sha256WithRSAEncryption':
              csr.md = forge.md.sha256.create();
              break;
            case 'RSASSA-PSS':
              csr.md = forge.md.sha256.create();
              break;
          }
        }
        if (csr.md === null) {
          var error = new Error('Could not compute certification request digest. ' + 'Unknown signature OID.');
          error.signatureOid = csr.signatureOid;
          throw error;
        }
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0x00;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];
        if (!algorithmOid) {
          var error = new Error('Could not compute certification request digest. ' + 'Unknown message digest algorithm OID.');
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          if (csr.signatureOid in oids) {
            var oid = oids[csr.signatureOid];
            switch (oid) {
              case 'sha1WithRSAEncryption':
                md = forge.md.sha1.create();
                break;
              case 'md5WithRSAEncryption':
                md = forge.md.md5.create();
                break;
              case 'sha256WithRSAEncryption':
                md = forge.md.sha256.create();
                break;
              case 'RSASSA-PSS':
                md = forge.md.sha256.create();
                break;
            }
          }
          if (md === null) {
            var error = new Error('Could not compute certification request digest. ' + 'Unknown signature OID.');
            error.signatureOid = csr.signatureOid;
            throw error;
          }
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(cri);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          var scheme;
          switch (csr.signatureOid) {
            case oids.sha1WithRSAEncryption:
              break;
            case oids['RSASSA-PSS']:
              var hash,
                  mgf;
              hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];
              if (hash === undefined || forge.md[hash] === undefined) {
                var error = new Error('Unsupported MGF hash function.');
                error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              mgf = oids[csr.signatureParameters.mgf.algorithmOid];
              if (mgf === undefined || forge.mgf[mgf] === undefined) {
                var error = new Error('Unsupported MGF function.');
                error.oid = csr.signatureParameters.mgf.algorithmOid;
                error.name = mgf;
                throw error;
              }
              mgf = forge.mgf[mgf].create(forge.md[hash].create());
              hash = oids[csr.signatureParameters.hash.algorithmOid];
              if (hash === undefined || forge.md[hash] === undefined) {
                var error = new Error('Unsupported RSASSA-PSS hash function.');
                error.oid = csr.signatureParameters.hash.algorithmOid;
                error.name = hash;
                throw error;
              }
              scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength);
              break;
          }
          rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var attr,
          set;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ('valueTagClass' in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)])]);
        rval.value.push(set);
      }
      return rval;
    }
    function _getAttributesAsJson(attrs) {
      var rval = {};
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        if (attr.shortName && (attr.valueTagClass === asn1.Type.UTF8 || attr.valueTagClass === asn1.Type.PRINTABLESTRING || attr.valueTagClass === asn1.Type.IA5STRING)) {
          var value = attr.value;
          if (attr.valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(attr.value);
          }
          if (!(attr.shortName in rval)) {
            rval[attr.shortName] = value;
          } else if (forge.util.isArray(rval[attr.shortName])) {
            rval[attr.shortName].push(value);
          } else {
            rval[attr.shortName] = [rval[attr.shortName], value];
          }
        }
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === 'undefined') {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === 'undefined') {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error('Attribute type not specified.');
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === 'undefined') {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
            }
          }
        }
        if (typeof attr.value === 'undefined') {
          var error = new Error('Attribute value not specified.');
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === 'undefined') {
        if (e.id && e.id in pki.oids) {
          e.name = pki.oids[e.id];
        }
      }
      if (typeof e.id === 'undefined') {
        if (e.name && e.name in pki.oids) {
          e.id = pki.oids[e.name];
        } else {
          var error = new Error('Extension ID not specified.');
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== 'undefined') {
        return e;
      }
      if (e.name === 'keyUsage') {
        var unused = 0;
        var b2 = 0x00;
        var b3 = 0x00;
        if (e.digitalSignature) {
          b2 |= 0x80;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 0x40;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 0x20;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 0x10;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 0x08;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 0x04;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 0x02;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 0x01;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 0x80;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
      } else if (e.name === 'basicConstraints') {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        if (e.cA) {
          e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));
        }
        if ('pathLenConstraint' in e) {
          e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
        }
      } else if (e.name === 'extKeyUsage') {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
          } else if (key.indexOf('.') !== -1) {
            seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
          }
        }
      } else if (e.name === 'nsCertType') {
        var unused = 0;
        var b2 = 0x00;
        if (e.client) {
          b2 |= 0x80;
          unused = 7;
        }
        if (e.server) {
          b2 |= 0x40;
          unused = 6;
        }
        if (e.email) {
          b2 |= 0x20;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 0x10;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 0x08;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 0x04;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 0x02;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 0x01;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
      } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
      } else if (e.name === 'subjectKeyIdentifier' && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
      }
      if (typeof e.value === 'undefined') {
        var error = new Error('Extension value not specified.');
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids['RSASSA-PSS']:
          var parts = [];
          if (params.hash.algorithmOid !== undefined) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])]));
          }
          if (params.mgf.algorithmOid !== undefined) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])])]));
          }
          if (params.saltLength !== undefined) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ('valueTagClass' in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ('valueConstructed' in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]);
        rval.value.push(seq);
      }
      return rval;
    }
    pki.getTBSCertificate = function(cert) {
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]), _dnToAsn1(cert.issuer), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(cert.validity.notBefore)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(cert.validity.notAfter))]), _dnToAsn1(cert.subject), pki.publicKeyToAsn1(cert.publicKey)]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.issuer.uniqueId)]));
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.subject.uniqueId)]));
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()), _dnToAsn1(csr.subject), pki.publicKeyToAsn1(csr.publicKey), _CRIAttributesToAsn1(csr)]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [tbsCertificate, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()), _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.signature)]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
      if (ext.critical) {
        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));
      }
      var value = ext.value;
      if (typeof ext.value !== 'string') {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [cri, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()), _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + csr.signature)]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {certs: {}};
      caStore.getIssuer = function(cert) {
        var rval = getBySubject(cert.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert) {
        if (typeof cert === 'string') {
          cert = forge.pki.certificateFromPem(cert);
        }
        if (!cert.subject.hash) {
          var md = forge.md.sha1.create();
          cert.subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(cert.subject), md);
          cert.subject.hash = md.digest().toHex();
        }
        if (cert.subject.hash in caStore.certs) {
          var tmp = caStore.certs[cert.subject.hash];
          if (!forge.util.isArray(tmp)) {
            tmp = [tmp];
          }
          tmp.push(cert);
        } else {
          caStore.certs[cert.subject.hash] = cert;
        }
      };
      caStore.hasCertificate = function(cert) {
        var match = getBySubject(cert.subject);
        if (!match) {
          return false;
        }
        if (!forge.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
        for (var i = 0; i < match.length; ++i) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      function getBySubject(subject) {
        if (!subject.hash) {
          var md = forge.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
        return caStore.certs[subject.hash] || null;
      }
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert = certs[i];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: 'forge.pki.BadCertificate',
      unsupported_certificate: 'forge.pki.UnsupportedCertificate',
      certificate_revoked: 'forge.pki.CertificateRevoked',
      certificate_expired: 'forge.pki.CertificateExpired',
      certificate_unknown: 'forge.pki.CertificateUnknown',
      unknown_ca: 'forge.pki.UnknownCertificateAuthority'
    };
    pki.verifyCertificateChain = function(caStore, chain, verify) {
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var now = new Date();
      var first = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (now < cert.validity.notBefore || now > cert.validity.notAfter) {
          error = {
            message: 'Certificate is not valid yet or has expired.',
            error: pki.certificateError.certificate_expired,
            notBefore: cert.validity.notBefore,
            notAfter: cert.validity.notAfter,
            now: now
          };
        }
        if (error === null) {
          parent = chain[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {}
            }
            if (!verified) {
              error = {
                message: 'Certificate signature is invalid.',
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: 'Certificate is not trusted.',
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent && !cert.isIssuer(parent)) {
          error = {
            message: 'Certificate issuer is invalid.',
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error === null && i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: 'Certificate has an unsupported critical extension.',
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first || (chain.length === 0 && (!parent || selfSigned)))) {
          var bcExt = cert.getExtension('basicConstraints');
          var keyUsageExt = cert.getExtension('keyUsage');
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: 'Certificate keyUsage or basicConstraints conflict ' + 'or indicate that the certificate is not a CA. ' + 'If the certificate is the only one in the chain or ' + 'isn\'t the first then the certificate must be a ' + 'valid CA.',
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: 'Certificate basicConstraints indicates the certificate ' + 'is not a CA.',
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && 'pathLenConstraint' in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: 'Certificate basicConstraints pathLenConstraint violated.',
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = (error === null) ? true : error.error;
        var ret = verify ? verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: 'The application rejected the certificate.',
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === 'object' && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === 'string') {
              error.error = ret;
            }
          }
          throw error;
        }
        first = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
  var name = 'x509';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge.pki;
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/x509", ["require", "module", "npm:node-forge@0.6.35/js/aes", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/des", "npm:node-forge@0.6.35/js/md", "npm:node-forge@0.6.35/js/mgf", "npm:node-forge@0.6.35/js/oids", "npm:node-forge@0.6.35/js/pem", "npm:node-forge@0.6.35/js/pss", "npm:node-forge@0.6.35/js/rsa", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var pki = forge.pki;
    var p12 = forge.pkcs12 = forge.pkcs12 || {};
    var contentInfoValidator = {
      name: 'ContentInfo',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'ContentInfo.contentType',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'contentType'
      }, {
        name: 'ContentInfo.content',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: 'content'
      }]
    };
    var pfxValidator = {
      name: 'PFX',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PFX.version',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'version'
      }, contentInfoValidator, {
        name: 'PFX.macData',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: 'mac',
        value: [{
          name: 'PFX.macData.mac',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: 'PFX.macData.mac.digestAlgorithm',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: 'PFX.macData.mac.digestAlgorithm.algorithm',
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: 'macAlgorithm'
            }, {
              name: 'PFX.macData.mac.digestAlgorithm.parameters',
              tagClass: asn1.Class.UNIVERSAL,
              captureAsn1: 'macAlgorithmParameters'
            }]
          }, {
            name: 'PFX.macData.mac.digest',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: 'macDigest'
          }]
        }, {
          name: 'PFX.macData.macSalt',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: 'macSalt'
        }, {
          name: 'PFX.macData.iterations',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          optional: true,
          capture: 'macIterations'
        }]
      }]
    };
    var safeBagValidator = {
      name: 'SafeBag',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'SafeBag.bagId',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'bagId'
      }, {
        name: 'SafeBag.bagValue',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: 'bagValue'
      }, {
        name: 'SafeBag.bagAttributes',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: 'bagAttributes'
      }]
    };
    var attributeValidator = {
      name: 'Attribute',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'Attribute.attrId',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'oid'
      }, {
        name: 'Attribute.attrValues',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: 'values'
      }]
    };
    var certBagValidator = {
      name: 'CertBag',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'CertBag.certId',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'certId'
      }, {
        name: 'CertBag.certValue',
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        value: [{
          name: 'CertBag.certValue[0]',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: 'cert'
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result = [];
      for (var i = 0; i < safeContents.length; i++) {
        for (var j = 0; j < safeContents[i].safeBags.length; j++) {
          var bag = safeContents[i].safeBags[j];
          if (bagType !== undefined && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result.push(bag);
          }
        }
      }
      return result;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === 'string') {
        password = strict;
        strict = true;
      } else if (strict === undefined) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#12 PFX. ' + 'ASN.1 object is not an PKCS#12 PFX.');
        error.errors = error;
        throw error;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        getBags: function(filter) {
          var rval = {};
          var localKeyId;
          if ('localKeyId' in filter) {
            localKeyId = filter.localKeyId;
          } else if ('localKeyIdHex' in filter) {
            localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
          }
          if (localKeyId === undefined && !('friendlyName' in filter) && 'bagType' in filter) {
            rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);
          }
          if (localKeyId !== undefined) {
            rval.localKeyId = _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, filter.bagType);
          }
          if ('friendlyName' in filter) {
            rval.friendlyName = _getBagsByAttribute(pfx.safeContents, 'friendlyName', filter.friendlyName, filter.bagType);
          }
          return rval;
        },
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(pfx.safeContents, 'friendlyName', friendlyName, bagType);
        },
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, bagType);
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error = new Error('PKCS#12 PFX of version other than 3 not supported.');
        error.version = capture.version.charCodeAt(0);
        throw error;
      }
      if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
        var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');
        error.oid = asn1.derToOid(capture.contentType);
        throw error;
      }
      var data = capture.content.value[0];
      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
        throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');
      }
      data = _decodePkcs7Data(data);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki.oids.sha1:
            md = forge.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki.oids.sha256:
            md = forge.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki.oids.sha384:
            md = forge.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki.oids.sha512:
            md = forge.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki.oids.md5:
            md = forge.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);
        }
        var macSalt = new forge.util.ByteBuffer(capture.macSalt);
        var macIterations = (('macIterations' in capture) ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);
        var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);
        var mac = forge.hmac.create();
        mac.start(md, macKey);
        mac.update(data.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error('PKCS#12 MAC could not be verified. Invalid password?');
        }
      }
      _decodeAuthenticatedSafe(pfx, data.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data) {
      if (data.composed || data.constructed) {
        var value = forge.util.createBuffer();
        for (var i = 0; i < data.value.length; ++i) {
          value.putBytes(data.value[i].value);
        }
        data.composed = data.constructed = false;
        data.value = value.getBytes();
      }
      return data;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' + 'SEQUENCE OF ContentInfo');
      }
      for (var i = 0; i < authSafe.value.length; i++) {
        var contentInfo = authSafe.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error = new Error('Cannot read ContentInfo.');
          error.errors = errors;
          throw error;
        }
        var obj = {encrypted: false};
        var safeContents = null;
        var data = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki.oids.data:
            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
              throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');
            }
            safeContents = _decodePkcs7Data(data).value;
            break;
          case pki.oids.encryptedData:
            safeContents = _decryptSafeContents(data, password);
            obj.encrypted = true;
            break;
          default:
            var error = new Error('Unsupported PKCS#12 contentType.');
            error.contentType = asn1.derToOid(capture.contentType);
            throw error;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
        var error = new Error('Cannot read EncryptedContentInfo.');
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki.oids.data) {
        var error = new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');
        error.oid = oid;
        throw error;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error('Failed to decrypt PKCS#12 SafeContents.');
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');
      }
      var res = [];
      for (var i = 0; i < safeContents.value.length; i++) {
        var safeBag = safeContents.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error = new Error('Cannot read SafeBag.');
          error.errors = errors;
          throw error;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator,
            decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');
            }
          case pki.oids.keyBag:
            try {
              bag.key = pki.privateKeyFromAsn1(bagAsn1);
            } catch (e) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          case pki.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                var error = new Error('Unsupported certificate type, only X.509 supported.');
                error.oid = asn1.derToOid(capture.certId);
                throw error;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki.certificateFromAsn1(certAsn1, true);
              } catch (e) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error = new Error('Unsupported PKCS#12 SafeBag type.');
            error.oid = bag.type;
            throw error;
        }
        if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error = new Error('Cannot read PKCS#12 ' + validator.name);
          error.errors = errors;
          throw error;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== undefined) {
        for (var i = 0; i < attributes.length; ++i) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
            var error = new Error('Cannot read PKCS#12 BagAttribute.');
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki.oids[oid] === undefined) {
            continue;
          }
          decodedAttrs[pki.oids[oid]] = [];
          for (var j = 0; j < capture.values.length; ++j) {
            decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key, cert, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';
      if (!('useMac' in options)) {
        options.useMac = true;
      }
      if (!('localKeyId' in options)) {
        options.localKeyId = null;
      }
      if (!('generateLocalKeyId' in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === 'string') {
            pairedCert = pki.certificateFromPem(pairedCert);
          }
          var sha1 = forge.md.sha1.create();
          sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha1.digest().getBytes();
        } else {
          localKeyId = forge.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));
      }
      if ('friendlyName' in options) {
        attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert !== null) {
        if (forge.util.isArray(cert)) {
          chain = cert;
        } else {
          chain = [cert];
        }
      }
      var certSafeBags = [];
      for (var i = 0; i < chain.length; ++i) {
        cert = chain[i];
        if (typeof cert === 'string') {
          cert = pki.certificateFromPem(cert);
        }
        var certBagAttrs = (i === 0) ? bagAttrs : undefined;
        var certAsn1 = pki.certificateToAsn1(cert);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]), certBagAttrs]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);
        var certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);
        contents.push(certCI);
      }
      var keyBag = null;
      if (key !== null) {
        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pkAsn1]), bagAttrs]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pki.encryptPrivateKeyInfo(pkAsn1, password, options)]), bagAttrs]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);
        contents.push(keyCI);
      }
      var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);
      var macData;
      if (options.useMac) {
        var sha1 = forge.md.sha1.create();
        var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));
        var count = options.count;
        var key = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge.hmac.create();
        mac.start(sha1, key);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]), macData]);
    };
    p12.generateKey = forge.pbe.generatePkcs12Key;
  }
  var name = 'pkcs12';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pkcs12", ["require", "module", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/hmac", "npm:node-forge@0.6.35/js/oids", "npm:node-forge@0.6.35/js/pkcs7asn1", "npm:node-forge@0.6.35/js/pbe", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/rsa", "npm:node-forge@0.6.35/js/sha1", "npm:node-forge@0.6.35/js/util", "npm:node-forge@0.6.35/js/x509"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    pki.pemToDer = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert PEM to DER; PEM is encrypted.');
      }
      return forge.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'PRIVATE KEY' && msg.type !== 'RSA PRIVATE KEY') {
        var error = new Error('Could not convert private key from PEM; PEM ' + 'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert private key from PEM; PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key, maxline) {
      var msg = {
        type: 'RSA PRIVATE KEY',
        body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
    pki.privateKeyInfoToPem = function(pki, maxline) {
      var msg = {
        type: 'PRIVATE KEY',
        body: asn1.toDer(pki).getBytes()
      };
      return forge.pem.encode(msg, {maxline: maxline});
    };
  }
  var name = 'pki';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pki", ["require", "module", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/oids", "npm:node-forge@0.6.35/js/pbe", "npm:node-forge@0.6.35/js/pem", "npm:node-forge@0.6.35/js/pbkdf2", "npm:node-forge@0.6.35/js/pkcs12", "npm:node-forge@0.6.35/js/pss", "npm:node-forge@0.6.35/js/rsa", "npm:node-forge@0.6.35/js/util", "npm:node-forge@0.6.35/js/x509"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var prf_TLS1 = function(secret, label, seed, length) {
      var rval = forge.util.createBuffer();
      var idx = (secret.length >> 1);
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai = forge.util.createBuffer();
      var hmac = forge.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length / 16);
      var sha1itr = Math.ceil(length / 20);
      hmac.start('MD5', s1);
      var md5bytes = forge.util.createBuffer();
      ai.putBytes(seed);
      for (var i = 0; i < md5itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        md5bytes.putBuffer(hmac.digest());
      }
      hmac.start('SHA1', s2);
      var sha1bytes = forge.util.createBuffer();
      ai.clear();
      ai.putBytes(seed);
      for (var i = 0; i < sha1itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        sha1bytes.putBuffer(hmac.digest());
      }
      rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length));
      return rval;
    };
    var prf_sha256 = function(secret, label, seed, length) {};
    var hmac_sha1 = function(key, seqNum, record) {
      var hmac = forge.hmac.create();
      hmac.start('SHA1', key);
      var b = forge.util.createBuffer();
      b.putInt32(seqNum[0]);
      b.putInt32(seqNum[1]);
      b.putByte(record.type);
      b.putByte(record.version.major);
      b.putByte(record.version.minor);
      b.putInt16(record.length);
      b.putBytes(record.fragment.bytes());
      hmac.update(b.getBytes());
      return hmac.digest().getBytes();
    };
    var deflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.deflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {}
      return rval;
    };
    var inflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.inflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {}
      return rval;
    };
    var readVector = function(b, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b.getByte();
          break;
        case 2:
          len = b.getInt16();
          break;
        case 3:
          len = b.getInt24();
          break;
        case 4:
          len = b.getInt32();
          break;
      }
      return forge.util.createBuffer(b.getBytes(len));
    };
    var writeVector = function(b, lenBytes, v) {
      b.putInt(v.length(), lenBytes << 3);
      b.putBuffer(v);
    };
    var tls = {};
    tls.Versions = {
      TLS_1_0: {
        major: 3,
        minor: 1
      },
      TLS_1_1: {
        major: 3,
        minor: 2
      },
      TLS_1_2: {
        major: 3,
        minor: 3
      }
    };
    tls.SupportedVersions = [tls.Versions.TLS_1_1, tls.Versions.TLS_1_0];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {tls_prf_sha256: 0};
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key in tls.CipherSuites) {
        var cs = tls.CipherSuites[key];
        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c, record) {
      var ignore = (!c.open && c.entity === tls.ConnectionEnd.client);
      if (!ignore) {
        c.error(c, {
          message: 'Unexpected message. Received TLS record out of order.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c, record, length) {
      if (!c.handshaking && c.handshakes > 0) {
        tls.queue(c, tls.createAlert(c, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c);
      }
      c.process();
    };
    tls.parseHelloMessage = function(c, record, length) {
      var msg = null;
      var client = (c.entity === tls.ConnectionEnd.client);
      if (length < 38) {
        c.error(c, {
          message: client ? 'Invalid ServerHello message. Message too short.' : 'Invalid ClientHello message. Message too short.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b = record.fragment;
        var remaining = b.length();
        msg = {
          version: {
            major: b.getByte(),
            minor: b.getByte()
          },
          random: forge.util.createBuffer(b.getBytes(32)),
          session_id: readVector(b, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b.getBytes(2);
          msg.compression_method = b.getByte();
        } else {
          msg.cipher_suites = readVector(b, 2);
          msg.compression_methods = readVector(b, 1);
        }
        remaining = length - (remaining - b.length());
        if (remaining > 0) {
          var exts = readVector(b, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i = 0; i < msg.extensions.length; ++i) {
              var ext = msg.extensions[i];
              if (ext.type[0] === 0x00 && ext.type[1] === 0x00) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0x00) {
                    break;
                  }
                  c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());
                }
              }
            }
          }
        }
        if (c.session.version) {
          if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
            return c.error(c, {
              message: 'TLS version change is disallowed during renegotiation.',
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c.session.cipherSuite === null) {
          return c.error(c, {
            message: 'No cipher suites in common.',
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c.session.compressionMethod = msg.compression_method;
        } else {
          c.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c, msg) {
      var client = (c.entity === tls.ConnectionEnd.client);
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c.session.sp = {
        entity: c.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      if (msg.version.minor <= c.version.minor) {
        c.version.minor = msg.version.minor;
      } else {
        return c.error(c, {
          message: 'Incompatible TLS version.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c.session.version = c.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c.session.id) {
        c.expect = SCC;
        c.session.resuming = true;
        c.session.sp.server_random = msg.random.bytes();
      } else {
        c.expect = SCE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.session.id = sessionId;
      c.process();
    };
    tls.handleClientHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c.sessionCache) {
        session = c.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = '';
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = '';
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge.random.getBytes(32);
      }
      c.session.id = sessionId;
      c.session.clientHelloVersion = msg.version;
      c.session.sp = {};
      if (session) {
        c.version = c.session.version = session.version;
        c.session.sp = session.sp;
      } else {
        var version;
        for (var i = 1; i < tls.SupportedVersions.length; ++i) {
          version = tls.SupportedVersions[i];
          if (version.minor <= msg.version.minor) {
            break;
          }
        }
        c.version = {
          major: version.major,
          minor: version.minor
        };
        c.session.version = c.version;
      }
      if (session !== null) {
        c.expect = CCC;
        c.session.resuming = true;
        c.session.sp.client_random = msg.random.bytes();
      } else {
        c.expect = (c.verifyClient !== false) ? CCE : CKE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.open = true;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c)
      }));
      if (c.session.resuming) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      } else {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        }));
        if (!c.fail) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c)
          }));
          if (c.verifyClient !== false) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c)
            }));
          }
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c)
          }));
        }
      }
      tls.flush(c);
      c.process();
    };
    tls.handleCertificate = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: 'Invalid Certificate message. Message too short.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {certificate_list: readVector(b, 3)};
      var cert,
          asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert = readVector(msg.certificate_list, 3);
          asn1 = forge.asn1.fromDer(cert);
          cert = forge.pki.certificateFromAsn1(asn1, true);
          certs.push(cert);
        }
      } catch (ex) {
        return c.error(c, {
          message: 'Could not parse certificate list.',
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = (c.entity === tls.ConnectionEnd.client);
      if ((client || c.verifyClient === true) && certs.length === 0) {
        c.error(c, {
          message: client ? 'No server certificate provided.' : 'No client certificate provided.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c.session.serverCertificate = certs[0];
        } else {
          c.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c, certs)) {
          c.expect = client ? SKE : CKE;
        }
      }
      c.process();
    };
    tls.handleServerKeyExchange = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: 'Invalid key parameters. Only RSA is supported.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c.expect = SCR;
      c.process();
    };
    tls.handleClientKeyExchange = function(c, record, length) {
      if (length < 48) {
        return c.error(c, {
          message: 'Invalid key parameters. Only RSA is supported.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b = record.fragment;
      var msg = {enc_pre_master_secret: readVector(b, 2).getBytes()};
      var privateKey = null;
      if (c.getPrivateKey) {
        try {
          privateKey = c.getPrivateKey(c, c.session.serverCertificate);
          privateKey = forge.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c.error(c, {
            message: 'Could not get private key.',
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c.error(c, {
          message: 'No private key set.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version = c.session.clientHelloVersion;
        if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error('TLS version rollback attack detected.');
        }
      } catch (ex) {
        sp.pre_master_secret = forge.random.getBytes(48);
      }
      c.expect = CCC;
      if (c.session.clientCertificate !== null) {
        c.expect = CCV;
      }
      c.process();
    };
    tls.handleCertificateRequest = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: 'Invalid CertificateRequest. Message too short.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {
        certificate_types: readVector(b, 1),
        certificate_authorities: readVector(b, 2)
      };
      c.session.certificateRequest = msg;
      c.expect = SHD;
      c.process();
    };
    tls.handleCertificateVerify = function(c, record, length) {
      if (length < 2) {
        return c.error(c, {
          message: 'Invalid CertificateVerify. Message too short.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var msg = {signature: readVector(b, 2).getBytes()};
      var verify = forge.util.createBuffer();
      verify.putBuffer(c.session.md5.digest());
      verify.putBuffer(c.session.sha1.digest());
      verify = verify.getBytes();
      try {
        var cert = c.session.clientCertificate;
        if (!cert.publicKey.verify(verify, msg.signature, 'NONE')) {
          throw new Error('CertificateVerify signature does not match.');
        }
        c.session.md5.update(msgBytes);
        c.session.sha1.update(msgBytes);
      } catch (ex) {
        return c.error(c, {
          message: 'Bad signature in CertificateVerify.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c.expect = CCC;
      c.process();
    };
    tls.handleServerHelloDone = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: 'Invalid ServerHelloDone message. Invalid length.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c.serverCertificate === null) {
        var error = {
          message: 'No server certificate provided. Not enough security.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c.verify(c, error.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === 'object' && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
            } else if (typeof ret === 'number') {
              error.alert.description = ret;
            }
          }
          return c.error(c, error);
        }
      }
      if (c.session.certificateRequest !== null) {
        record = tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        });
        tls.queue(c, record);
      }
      record = tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c)
      });
      tls.queue(c, record);
      c.expect = SER;
      var callback = function(c, signature) {
        if (c.session.certificateRequest !== null && c.session.clientCertificate !== null) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c, signature)
          }));
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
        c.expect = SCC;
        tls.flush(c);
        c.process();
      };
      if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
        return callback(c, null);
      }
      tls.getClientSignature(c, callback);
    };
    tls.handleChangeCipherSpec = function(c, record) {
      if (record.fragment.getByte() !== 0x01) {
        return c.error(c, {
          message: 'Invalid ChangeCipherSpec message received.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = (c.entity === tls.ConnectionEnd.client);
      if ((c.session.resuming && client) || (!c.session.resuming && !client)) {
        c.state.pending = tls.createConnectionState(c);
      }
      c.state.current.read = c.state.pending.read;
      if ((!c.session.resuming && client) || (c.session.resuming && !client)) {
        c.state.pending = null;
      }
      c.expect = client ? SFI : CFI;
      c.process();
    };
    tls.handleFinished = function(c, record, length) {
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var vd = record.fragment.getBytes();
      b = forge.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = (c.entity === tls.ConnectionEnd.client);
      var label = client ? 'server finished' : 'client finished';
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      if (b.getBytes() !== vd) {
        return c.error(c, {
          message: 'Invalid verify_data in Finished message.',
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c.session.md5.update(msgBytes);
      c.session.sha1.update(msgBytes);
      if ((c.session.resuming && client) || (!c.session.resuming && !client)) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.current.write = c.state.pending.write;
        c.state.pending = null;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      }
      c.expect = client ? SAD : CAD;
      c.handshaking = false;
      ++c.handshakes;
      c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
      tls.flush(c);
      c.isConnected = true;
      c.connected(c);
      c.process();
    };
    tls.handleAlert = function(c, record) {
      var b = record.fragment;
      var alert = {
        level: b.getByte(),
        description: b.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = 'Connection closed.';
          break;
        case tls.Alert.Description.unexpected_message:
          msg = 'Unexpected message.';
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = 'Bad record MAC.';
          break;
        case tls.Alert.Description.decryption_failed:
          msg = 'Decryption failed.';
          break;
        case tls.Alert.Description.record_overflow:
          msg = 'Record overflow.';
          break;
        case tls.Alert.Description.decompression_failure:
          msg = 'Decompression failed.';
          break;
        case tls.Alert.Description.handshake_failure:
          msg = 'Handshake failure.';
          break;
        case tls.Alert.Description.bad_certificate:
          msg = 'Bad certificate.';
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = 'Unsupported certificate.';
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = 'Certificate revoked.';
          break;
        case tls.Alert.Description.certificate_expired:
          msg = 'Certificate expired.';
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = 'Certificate unknown.';
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = 'Illegal parameter.';
          break;
        case tls.Alert.Description.unknown_ca:
          msg = 'Unknown certificate authority.';
          break;
        case tls.Alert.Description.access_denied:
          msg = 'Access denied.';
          break;
        case tls.Alert.Description.decode_error:
          msg = 'Decode error.';
          break;
        case tls.Alert.Description.decrypt_error:
          msg = 'Decrypt error.';
          break;
        case tls.Alert.Description.export_restriction:
          msg = 'Export restriction.';
          break;
        case tls.Alert.Description.protocol_version:
          msg = 'Unsupported protocol version.';
          break;
        case tls.Alert.Description.insufficient_security:
          msg = 'Insufficient security.';
          break;
        case tls.Alert.Description.internal_error:
          msg = 'Internal error.';
          break;
        case tls.Alert.Description.user_canceled:
          msg = 'User canceled.';
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = 'Renegotiation not supported.';
          break;
        default:
          msg = 'Unknown error.';
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c.close();
      }
      c.error(c, {
        message: msg,
        send: false,
        origin: (c.entity === tls.ConnectionEnd.client) ? 'server' : 'client',
        alert: alert
      });
      c.process();
    };
    tls.handleHandshake = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length = b.getInt24();
      if (length > b.length()) {
        c.fragmented = record;
        record.fragment = forge.util.createBuffer();
        b.read -= 4;
        return c.process();
      }
      c.fragmented = null;
      b.read -= 4;
      var bytes = b.bytes(length + 4);
      b.read += 4;
      if (type in hsTable[c.entity][c.expect]) {
        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
          c.handshaking = true;
          c.session = {
            version: null,
            extensions: {server_name: {serverNameList: []}},
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
        }
        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
          c.session.md5.update(bytes);
          c.session.sha1.update(bytes);
        }
        hsTable[c.entity][c.expect][type](c, record, length);
      } else {
        tls.handleUnexpected(c, record);
      }
    };
    tls.handleApplicationData = function(c, record) {
      c.data.putBuffer(record.fragment);
      c.dataReady(c);
      c.process();
    };
    tls.handleHeartbeat = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length = b.getInt16();
      var payload = b.getBytes(length);
      if (type === tls.HeartbeatMessageType.heartbeat_request) {
        if (c.handshaking || length > payload.length) {
          return c.process();
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload)
        }));
        tls.flush(c);
      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c.expectedHeartbeatPayload) {
          return c.process();
        }
        if (c.heartbeatReceived) {
          c.heartbeatReceived(c, forge.util.createBuffer(payload));
        }
      }
      c.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var CER = 7;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R2 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [[__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [R0, R1, __, __, R4], [__, R1, R2, __, R4], [__, R1, R2, R3, R4], [__, R1, R2, __, R4]];
    ctTable[tls.ConnectionEnd.server] = [[__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [R0, R1, __, __, R4], [__, R1, R2, __, R4], [__, R1, R2, R3, R4], [__, R1, R2, __, R4]];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H2 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [[__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [[__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]];
    tls.generateKeys = function(c, sp) {
      var prf = prf_TLS1;
      var random = sp.client_random + sp.server_random;
      if (!c.session.resuming) {
        sp.master_secret = prf(sp.pre_master_secret, 'master secret', random, 48).bytes();
        sp.pre_master_secret = null;
      }
      random = sp.server_random + sp.client_random;
      var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = (c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor);
      if (tls10) {
        length += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, 'key expansion', random, length);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c) {
      var client = (c.entity === tls.ConnectionEnd.client);
      var createMode = function() {
        var mode = {
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode.sequenceNumber[1] === 0xFFFFFFFF) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }
        };
        return mode;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c.error(c, {
            message: 'Could not decrypt record or bad MAC.',
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c, record, state.read)) {
          c.error(c, {
            message: 'Could not decompress record.',
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c.fail;
      };
      state.write.update = function(c, record) {
        if (!state.write.compressFunction(c, record, state.write)) {
          c.error(c, {
            message: 'Could not compress record.',
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c.error(c, {
            message: 'Could not encrypt record.',
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c.fail;
      };
      if (c.session) {
        var sp = c.session.sp;
        c.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c.session.cipherSuite.initConnectionState(state, c, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error('Unsupported compression algorithm.');
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d = new Date();
      var utc = +d + d.getTimezoneOffset() * 60000;
      var rval = forge.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c.version.major,
          minor: c.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c, alert) {
      var b = forge.util.createBuffer();
      b.putByte(alert.level);
      b.putByte(alert.description);
      return tls.createRecord(c, {
        type: tls.ContentType.alert,
        data: b
      });
    };
    tls.createClientHello = function(c) {
      c.session.clientHelloVersion = {
        major: c.version.major,
        minor: c.version.minor
      };
      var cipherSuites = forge.util.createBuffer();
      for (var i = 0; i < c.cipherSuites.length; ++i) {
        var cs = c.cipherSuites[i];
        cipherSuites.putByte(cs.id[0]);
        cipherSuites.putByte(cs.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge.util.createBuffer();
      if (c.virtualHost) {
        var ext = forge.util.createBuffer();
        ext.putByte(0x00);
        ext.putByte(0x00);
        var serverName = forge.util.createBuffer();
        serverName.putByte(0x00);
        writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
        var snList = forge.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.client_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c) {
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.server_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      rval.putByte(c.session.cipherSuite.id[0]);
      rval.putByte(c.session.cipherSuite.id[1]);
      rval.putByte(c.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c) {
      var client = (c.entity === tls.ConnectionEnd.client);
      var cert = null;
      if (c.getCertificate) {
        var hint;
        if (client) {
          hint = c.session.certificateRequest;
        } else {
          hint = c.session.extensions.server_name.serverNameList;
        }
        cert = c.getCertificate(c, hint);
      }
      var certList = forge.util.createBuffer();
      if (cert !== null) {
        try {
          if (!forge.util.isArray(cert)) {
            cert = [cert];
          }
          var asn1 = null;
          for (var i = 0; i < cert.length; ++i) {
            var msg = forge.pem.decode(cert[i])[0];
            if (msg.type !== 'CERTIFICATE' && msg.type !== 'X509 CERTIFICATE' && msg.type !== 'TRUSTED CERTIFICATE') {
              var error = new Error('Could not convert certificate from PEM; PEM ' + 'header type is not "CERTIFICATE", "X509 CERTIFICATE", or ' + '"TRUSTED CERTIFICATE".');
              error.headerType = msg.type;
              throw error;
            }
            if (msg.procType && msg.procType.type === 'ENCRYPTED') {
              throw new Error('Could not convert certificate from PEM; PEM is encrypted.');
            }
            var der = forge.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert = forge.pki.certificateFromAsn1(asn1);
          if (client) {
            c.session.clientCertificate = cert;
          } else {
            c.session.serverCertificate = cert;
          }
        } catch (ex) {
          return c.error(c, {
            message: 'Could not send certificate list.',
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length = 3 + certList.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c) {
      var b = forge.util.createBuffer();
      b.putByte(c.session.clientHelloVersion.major);
      b.putByte(c.session.clientHelloVersion.minor);
      b.putBytes(forge.random.getBytes(46));
      var sp = c.session.sp;
      sp.pre_master_secret = b.getBytes();
      var key = c.session.serverCertificate.publicKey;
      b = key.encrypt(sp.pre_master_secret);
      var length = b.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length);
      rval.putInt16(b.length);
      rval.putBytes(b);
      return rval;
    };
    tls.createServerKeyExchange = function(c) {
      var length = 0;
      var rval = forge.util.createBuffer();
      if (length > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length);
      }
      return rval;
    };
    tls.getClientSignature = function(c, callback) {
      var b = forge.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      b = b.getBytes();
      c.getSignature = c.getSignature || function(c, b, callback) {
        var privateKey = null;
        if (c.getPrivateKey) {
          try {
            privateKey = c.getPrivateKey(c, c.session.clientCertificate);
            privateKey = forge.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c.error(c, {
              message: 'Could not get private key.',
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c.error(c, {
            message: 'No private key set.',
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b = privateKey.sign(b, null);
        }
        callback(c, b);
      };
      c.getSignature(c, b, callback);
    };
    tls.createCertificateVerify = function(c, signature) {
      var length = signature.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c) {
      var certTypes = forge.util.createBuffer();
      certTypes.putByte(0x01);
      var cAs = forge.util.createBuffer();
      for (var key in c.caStore.certs) {
        var cert = c.caStore.certs[key];
        var dn = forge.pki.distinguishedNameToAsn1(cert.subject);
        cAs.putBuffer(forge.asn1.toDer(dn));
      }
      var length = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c) {
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge.util.createBuffer();
      rval.putByte(0x01);
      return rval;
    };
    tls.createFinished = function(c) {
      var b = forge.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = (c.entity === tls.ConnectionEnd.client);
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? 'client finished' : 'server finished';
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b.length());
      rval.putBuffer(b);
      return rval;
    };
    tls.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === 'undefined') {
        payloadLength = payload.length;
      }
      var rval = forge.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c, record) {
      if (!record) {
        return;
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes = record.fragment.bytes();
        c.session.md5.update(bytes);
        c.session.sha1.update(bytes);
        bytes = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data = record.fragment.bytes();
        while (data.length > tls.MaxFragment) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
          }));
          data = data.slice(tls.MaxFragment);
        }
        if (data.length > 0) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge.util.createBuffer(data)
          }));
        }
      }
      for (var i = 0; i < records.length && !c.fail; ++i) {
        var rec = records[i];
        var s = c.state.current.write;
        if (s.update(c, rec)) {
          c.records.push(rec);
        }
      }
    };
    tls.flush = function(c) {
      for (var i = 0; i < c.records.length; ++i) {
        var record = c.records[i];
        c.tlsData.putByte(record.type);
        c.tlsData.putByte(record.version.major);
        c.tlsData.putByte(record.version.minor);
        c.tlsData.putInt16(record.fragment.length());
        c.tlsData.putBuffer(c.records[i].fragment);
      }
      c.records = [];
      return c.tlsDataReady(c);
    };
    var _certErrorToAlertDesc = function(error) {
      switch (error) {
        case true:
          return true;
        case forge.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge.pki.certificateError.unknown_ca;
        default:
          return forge.pki.certificateError.bad_certificate;
      }
    };
    tls.verifyCertificateChain = function(c, chain) {
      try {
        forge.pki.verifyCertificateChain(c.caStore, chain, function verify(vfd, depth, chain) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c.verify(c, vfd, depth, chain);
          if (ret !== true) {
            if (typeof ret === 'object' && !forge.util.isArray(ret)) {
              var error = new Error('The application rejected the certificate.');
              error.send = true;
              error.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
              throw error;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        });
      } catch (ex) {
        var err = ex;
        if (typeof err !== 'object' || forge.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!('send' in err)) {
          err.send = true;
        }
        if (!('alert' in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c.error(c, err);
      }
      return !c.fail;
    };
    tls.createSessionCache = function(cache, capacity) {
      var rval = null;
      if (cache && cache.getSession && cache.setSession && cache.order) {
        rval = cache;
      } else {
        rval = {};
        rval.cache = cache || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key in cache) {
          if (rval.order.length <= capacity) {
            rval.order.push(key);
          } else {
            delete cache[key];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key = null;
          if (sessionId) {
            key = forge.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key = rval.order[0];
          }
          if (key !== null && key in rval.cache) {
            session = rval.cache[key];
            delete rval.cache[key];
            for (var i in rval.order) {
              if (rval.order[i] === key) {
                rval.order.splice(i, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key = rval.order.shift();
            delete rval.cache[key];
          }
          var key = forge.util.bytesToHex(sessionId);
          rval.order.push(key);
          rval.cache[key] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge.util.isArray(options.caStore)) {
          caStore = forge.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key]);
        }
      }
      var entity = (options.server || false) ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c = {
        version: {
          major: tls.Version.major,
          minor: tls.Version.minor
        },
        entity: entity,
        sessionId: options.sessionId,
        caStore: caStore,
        sessionCache: sessionCache,
        cipherSuites: cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn, vfd, dpth, cts) {
          return vfd;
        },
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge.util.createBuffer(),
        tlsData: forge.util.createBuffer(),
        data: forge.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function(c, ex) {
          ex.origin = ex.origin || ((c.entity === tls.ConnectionEnd.client) ? 'client' : 'server');
          if (ex.send) {
            tls.queue(c, tls.createAlert(c, ex.alert));
            tls.flush(c);
          }
          var fatal = (ex.fatal !== false);
          if (fatal) {
            c.fail = true;
          }
          options.error(c, ex);
          if (fatal) {
            c.close(false);
          }
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c.reset = function(clearFail) {
        c.version = {
          major: tls.Version.major,
          minor: tls.Version.minor
        };
        c.record = null;
        c.session = null;
        c.peerCertificate = null;
        c.state = {
          pending: null,
          current: null
        };
        c.expect = (c.entity === tls.ConnectionEnd.client) ? SHE : CHE;
        c.fragmented = null;
        c.records = [];
        c.open = false;
        c.handshakes = 0;
        c.handshaking = false;
        c.isConnected = false;
        c.fail = !(clearFail || typeof(clearFail) === 'undefined');
        c.input.clear();
        c.tlsData.clear();
        c.data.clear();
        c.state.current = tls.createConnectionState(c);
      };
      c.reset();
      var _update = function(c, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers = ctTable[c.entity][c.expect];
        if (aligned in handlers) {
          handlers[aligned](c, record);
        } else {
          tls.handleUnexpected(c, record);
        }
      };
      var _readRecordHeader = function(c) {
        var rval = 0;
        var b = c.input;
        var len = b.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c.record = {
            type: b.getByte(),
            version: {
              major: b.getByte(),
              minor: b.getByte()
            },
            length: b.getInt16(),
            fragment: forge.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = (c.record.version.major === c.version.major);
          if (compatibleVersion && c.session && c.session.version) {
            compatibleVersion = (c.record.version.minor === c.version.minor);
          }
          if (!compatibleVersion) {
            c.error(c, {
              message: 'Incompatible TLS version.',
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c) {
        var rval = 0;
        var b = c.input;
        var len = b.length();
        if (len < c.record.length) {
          rval = c.record.length - len;
        } else {
          c.record.fragment.putBytes(b.getBytes(c.record.length));
          b.compact();
          var s = c.state.current.read;
          if (s.update(c, c.record)) {
            if (c.fragmented !== null) {
              if (c.fragmented.type === c.record.type) {
                c.fragmented.fragment.putBuffer(c.record.fragment);
                c.record = c.fragmented;
              } else {
                c.error(c, {
                  message: 'Invalid fragmented record.',
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c.record.ready = true;
          }
        }
        return rval;
      };
      c.handshake = function(sessionId) {
        if (c.entity !== tls.ConnectionEnd.client) {
          c.error(c, {
            message: 'Cannot initiate handshake as a server.',
            fatal: false
          });
        } else if (c.handshaking) {
          c.error(c, {
            message: 'Handshake already in progress.',
            fatal: false
          });
        } else {
          if (c.fail && !c.open && c.handshakes === 0) {
            c.fail = false;
          }
          c.handshaking = true;
          sessionId = sessionId || '';
          var session = null;
          if (sessionId.length > 0) {
            if (c.sessionCache) {
              session = c.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = '';
            }
          }
          if (sessionId.length === 0 && c.sessionCache) {
            session = c.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
          if (session) {
            c.version = session.version;
            c.session.sp = session.sp;
          }
          c.session.sp.client_random = tls.createRandom().getBytes();
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c)
          }));
          tls.flush(c);
        }
      };
      c.process = function(data) {
        var rval = 0;
        if (data) {
          c.input.putBytes(data);
        }
        if (!c.fail) {
          if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
            c.record = null;
          }
          if (c.record === null) {
            rval = _readRecordHeader(c);
          }
          if (!c.fail && c.record !== null && !c.record.ready) {
            rval = _readRecord(c);
          }
          if (!c.fail && c.record !== null && c.record.ready) {
            _update(c, c.record);
          }
        }
        return rval;
      };
      c.prepare = function(data) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.application_data,
          data: forge.util.createBuffer(data)
        }));
        return tls.flush(c);
      };
      c.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === 'undefined') {
          payloadLength = payload.length;
        }
        c.expectedHeartbeatPayload = payload;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)
        }));
        return tls.flush(c);
      };
      c.close = function(clearFail) {
        if (!c.fail && c.sessionCache && c.session) {
          var session = {
            id: c.session.id,
            version: c.session.version,
            sp: c.session.sp
          };
          session.sp.keys = null;
          c.sessionCache.setSession(session.id, session);
        }
        if (c.open) {
          c.open = false;
          c.input.clear();
          if (c.isConnected || c.handshaking) {
            c.isConnected = c.handshaking = false;
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c);
          }
          c.closed(c);
        }
        c.reset(clearFail);
      };
      return c;
    };
    forge.tls = forge.tls || {};
    for (var key in tls) {
      if (typeof tls[key] !== 'function') {
        forge.tls[key] = tls[key];
      }
    }
    forge.tls.prf_tls1 = prf_TLS1;
    forge.tls.hmac_sha1 = hmac_sha1;
    forge.tls.createSessionCache = tls.createSessionCache;
    forge.tls.createConnection = tls.createConnection;
  }
  var name = 'tls';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/tls", ["require", "module", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/hmac", "npm:node-forge@0.6.35/js/md", "npm:node-forge@0.6.35/js/pem", "npm:node-forge@0.6.35/js/pki", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var tls = forge.tls;
    tls.CipherSuites['TLS_RSA_WITH_AES_128_CBC_SHA'] = {
      id: [0x00, 0x2f],
      name: 'TLS_RSA_WITH_AES_128_CBC_SHA',
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState: initConnectionState
    };
    tls.CipherSuites['TLS_RSA_WITH_AES_256_CBC_SHA'] = {
      id: [0x00, 0x35],
      name: 'TLS_RSA_WITH_AES_256_CBC_SHA',
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState: initConnectionState
    };
    function initConnectionState(state, c, sp) {
      var client = (c.entity === forge.tls.ConnectionEnd.client);
      state.read.cipherState = {
        init: false,
        cipher: forge.cipher.createDecipher('AES-CBC', client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge.cipher.createCipher('AES-CBC', client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = forge.random.getBytesSync(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({iv: iv});
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
      if (!decrypt) {
        var padding = blockSize - (input.length() % blockSize);
        input.fillWithByte(padding - 1, padding);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
      var rval = true;
      if (decrypt) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
          rval = rval && (output.at(i) == paddingLength);
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    var count = 0;
    function decrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      ++count;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({iv: iv});
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s.macLength;
      var mac = forge.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
      s.updateSequenceNumber();
      rval = compareMacs(s.macKey, mac, mac2) && rval;
      return rval;
    }
    function compareMacs(key, mac1, mac2) {
      var hmac = forge.hmac.create();
      hmac.start('SHA1', key);
      hmac.update(mac1);
      mac1 = hmac.digest().getBytes();
      hmac.start(null, null);
      hmac.update(mac2);
      mac2 = hmac.digest().getBytes();
      return mac1 === mac2;
    }
  }
  var name = 'aesCipherSuites';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/aesCipherSuites", ["require", "module", "npm:node-forge@0.6.35/js/aes", "npm:node-forge@0.6.35/js/tls"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.debug = forge.debug || {};
    forge.debug.storage = {};
    forge.debug.get = function(cat, name) {
      var rval;
      if (typeof(cat) === 'undefined') {
        rval = forge.debug.storage;
      } else if (cat in forge.debug.storage) {
        if (typeof(name) === 'undefined') {
          rval = forge.debug.storage[cat];
        } else {
          rval = forge.debug.storage[cat][name];
        }
      }
      return rval;
    };
    forge.debug.set = function(cat, name, data) {
      if (!(cat in forge.debug.storage)) {
        forge.debug.storage[cat] = {};
      }
      forge.debug.storage[cat][name] = data;
    };
    forge.debug.clear = function(cat, name) {
      if (typeof(cat) === 'undefined') {
        forge.debug.storage = {};
      } else if (cat in forge.debug.storage) {
        if (typeof(name) === 'undefined') {
          delete forge.debug.storage[cat];
        } else {
          delete forge.debug.storage[cat][name];
        }
      }
    };
  }
  var name = 'debug';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/debug", ["require", "module"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.kem = forge.kem || {};
    var BigInteger = forge.jsbn.BigInteger;
    forge.kem.rsa = {};
    forge.kem.rsa.create = function(kdf, options) {
      options = options || {};
      var prng = options.prng || forge.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
        var r;
        do {
          r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);
        } while (r.equals(BigInteger.ZERO));
        r = forge.util.hexToBytes(r.toString(16));
        var zeros = byteLength - r.length;
        if (zeros > 0) {
          r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
        }
        var encapsulation = publicKey.encrypt(r, 'NONE');
        var key = kdf.generate(r, keyLength);
        return {
          encapsulation: encapsulation,
          key: key
        };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r = privateKey.decrypt(encapsulation, 'NONE');
        return kdf.generate(r, keyLength);
      };
      return kem;
    };
    forge.kem.kdf1 = function(md, digestLength) {
      _createKDF(this, md, 0, digestLength || md.digestLength);
    };
    forge.kem.kdf2 = function(md, digestLength) {
      _createKDF(this, md, 1, digestLength || md.digestLength);
    };
    function _createKDF(kdf, md, counterStart, digestLength) {
      kdf.generate = function(x, length) {
        var key = new forge.util.ByteBuffer();
        var k = Math.ceil(length / digestLength) + counterStart;
        var c = new forge.util.ByteBuffer();
        for (var i = counterStart; i < k; ++i) {
          c.putInt32(i);
          md.start();
          md.update(x + c.getBytes());
          var hash = md.digest();
          key.putBytes(hash.getBytes(digestLength));
        }
        key.truncate(key.length() - length);
        return key.getBytes();
      };
    }
  }
  var name = 'kem';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/kem", ["require", "module", "npm:node-forge@0.6.35/js/util", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/jsbn"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    forge.log = forge.log || {};
    forge.log.levels = ['none', 'error', 'warning', 'info', 'debug', 'verbose', 'max'];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge.log.LEVEL_LOCKED = (1 << 1);
    forge.log.NO_LEVEL_CHECK = (1 << 2);
    forge.log.INTERPOLATE = (1 << 3);
    for (var i = 0; i < forge.log.levels.length; ++i) {
      var level = forge.log.levels[i];
      sLevelInfo[level] = {
        index: i,
        name: level.toUpperCase()
      };
    }
    forge.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i = 0; i < sLoggers.length; ++i) {
        var logger = sLoggers[i];
        if (logger.flags & forge.log.NO_LEVEL_CHECK) {
          logger.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger.f(logger, message);
          }
        }
      }
    };
    forge.log.prepareStandard = function(message) {
      if (!('standard' in message)) {
        message.standard = sLevelInfo[message.level].name + ' [' + message.category + '] ' + message.message;
      }
    };
    forge.log.prepareFull = function(message) {
      if (!('full' in message)) {
        var args = [message.message];
        args = args.concat([] || message['arguments']);
        message.full = forge.util.format.apply(this, args);
      }
    };
    forge.log.prepareStandardFull = function(message) {
      if (!('standardFull' in message)) {
        forge.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    if (true) {
      var levels = ['error', 'warning', 'info', 'debug', 'verbose'];
      for (var i = 0; i < levels.length; ++i) {
        (function(level) {
          forge.log[level] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: new Date(),
              level: level,
              category: category,
              message: message,
              'arguments': args
            };
            forge.log.logMessage(msg);
          };
        })(levels[i]);
      }
    }
    forge.log.makeLogger = function(logFunction) {
      var logger = {
        flags: 0,
        f: logFunction
      };
      forge.log.setLevel(logger, 'none');
      return logger;
    };
    forge.log.setLevel = function(logger, level) {
      var rval = false;
      if (logger && !(logger.flags & forge.log.LEVEL_LOCKED)) {
        for (var i = 0; i < forge.log.levels.length; ++i) {
          var aValidLevel = forge.log.levels[i];
          if (level == aValidLevel) {
            logger.level = level;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge.log.lock = function(logger, lock) {
      if (typeof lock === 'undefined' || lock) {
        logger.flags |= forge.log.LEVEL_LOCKED;
      } else {
        logger.flags &= ~forge.log.LEVEL_LOCKED;
      }
    };
    forge.log.addLogger = function(logger) {
      sLoggers.push(logger);
    };
    if (typeof(console) !== 'undefined' && 'log' in console) {
      var logger;
      if (console.error && console.warn && console.info && console.debug) {
        var levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        var f = function(logger, message) {
          forge.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message['arguments'].slice());
          handler.apply(console, args);
        };
        logger = forge.log.makeLogger(f);
      } else {
        var f = function(logger, message) {
          forge.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger = forge.log.makeLogger(f);
      }
      forge.log.setLevel(logger, 'debug');
      forge.log.addLogger(logger);
      sConsoleLogger = logger;
    } else {
      console = {log: function() {}};
    }
    if (sConsoleLogger !== null) {
      var query = forge.util.getQueryVariables();
      if ('console.level' in query) {
        forge.log.setLevel(sConsoleLogger, query['console.level'].slice(-1)[0]);
      }
      if ('console.lock' in query) {
        var lock = query['console.lock'].slice(-1)[0];
        if (lock == 'true') {
          forge.log.lock(sConsoleLogger);
        }
      }
    }
    forge.log.consoleLogger = sConsoleLogger;
  }
  var name = 'log';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/log", ["require", "module", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var asn1 = forge.asn1;
    var p7 = forge.pkcs7 = forge.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== 'PKCS7') {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM ' + 'header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === 'ENCRYPTED') {
        throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: 'PKCS7',
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge.pem.encode(pemObj, {maxline: maxline});
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#7 message. ' + 'ASN.1 object is not an PKCS#7 ContentInfo.');
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error('Cannot read PKCS#7 message. ContentType with OID ' + contentType + ' is not (yet) supported.');
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          var certs = msg.rawCapture.certificates.value;
          for (var i = 0; i < certs.length; ++i) {
            msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers), msg.contentInfo])]);
          if (certs.length > 0) {
            signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
          }
          signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), signedData]);
        },
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === 'string') {
              cert = forge.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error('Could not add PKCS#7 signer; no private key specified.');
          }
          if (typeof key === 'string') {
            key = forge.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge.pki.oids.sha1:
            case forge.pki.oids.sha256:
            case forge.pki.oids.sha384:
            case forge.pki.oids.sha512:
            case forge.pki.oids.md5:
              break;
            default:
              throw new Error('Could not add PKCS#7 signer; unknown message digest algorithm: ' + digestAlgorithm);
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i = 0; i < authenticatedAttributes.length; ++i) {
              var attr = authenticatedAttributes[i];
              if (!contentType && attr.type === forge.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error('Invalid signer.authenticatedAttributes. If ' + 'signer.authenticatedAttributes is specified, then it must ' + 'contain at least two attributes, PKCS #9 content-type and ' + 'PKCS #9 message-digest.');
            }
          }
          msg.signers.push({
            key: key,
            version: 1,
            issuer: issuer,
            serialNumber: serialNumber,
            digestAlgorithm: digestAlgorithm,
            signatureAlgorithm: forge.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes: authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        sign: function() {
          if (typeof msg.content !== 'object' || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())]);
            if ('content' in msg) {
              var content;
              if (msg.content instanceof forge.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === 'string') {
                content = forge.util.encodeUtf8(msg.content);
              }
              msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)]));
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error('PKCS#7 signature verification not yet implemented.');
        },
        addCertificate: function(cert) {
          if (typeof cert === 'string') {
            cert = forge.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        addCertificateRevokationList: function(crl) {
          throw new Error('PKCS#7 CRL support not yet implemented.');
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge.md[forge.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge.md[forge.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]));
        }
        return mds;
      }
      function addSignerInfos(mds) {
        if (msg.contentInfo.value.length < 2) {
          throw new Error('Could not sign PKCS#7 message; there is no content to sign.');
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var content = msg.contentInfo.value[1];
        content = content.value[0];
        var bytes = asn1.toDer(content);
        bytes.getByte();
        asn1.getBerValueLength(bytes);
        bytes = bytes.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes);
        }
        var signingTime = new Date();
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge.pki.oids.data) {
              throw new Error('Invalid signer; authenticatedAttributes must be present ' + 'when the ContentInfo content type is not PKCS#7 Data.');
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
            var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes);
          }
          signer.signature = signer.key.sign(signer.md, 'RSASSA-PKCS1-V1_5');
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {algorithm: forge.pki.oids['aes256-CBC']},
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        decrypt: function(key) {
          if (key !== undefined) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {algorithm: forge.pki.oids['aes256-CBC']},
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))])])]);
        },
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r = msg.recipients[i];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === undefined && recipient !== undefined && privKey !== undefined) {
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
              case forge.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge.util.createBuffer(key);
                break;
              default:
                throw new Error('Unsupported asymmetric cipher, ' + 'OID ' + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              algorithm: forge.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === undefined) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen,
                ivLen,
                ciphFn;
            switch (cipher) {
              case forge.pki.oids['aes128-CBC']:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids['aes192-CBC']:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids['aes256-CBC']:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids['des-EDE3-CBC']:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge.des.createEncryptionCipher;
                break;
              default:
                throw new Error('Unsupported symmetric cipher, OID ' + cipher);
            }
            if (key === undefined) {
              key = forge.util.createBuffer(forge.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error('Symmetric key has wrong length; ' + 'got ' + key.length() + ' bytes, expected ' + keyLen + '.');
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error('Symmetric encryption failed.');
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; ++i) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== undefined) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
                break;
              default:
                throw new Error('Unsupported asymmetric cipher, OID ' + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#7 RecipientInfo. ' + 'ASN.1 object is not an PKCS#7 RecipientInfo.');
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter.value,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i = 0; i < infos.length; ++i) {
        ret.push(_recipientFromAsn1(infos[i]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i = 0; i < recipients.length; ++i) {
        ret.push(_recipientToAsn1(recipients[i]));
      }
      return ret;
    }
    function _signerFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.signerInfoValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#7 SignerInfo. ' + 'ASN.1 object is not an PKCS#7 SignerInfo.');
        error.errors = errors;
        throw error;
      }
      var rval = {
        version: capture.version.charCodeAt(0),
        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge.util.createBuffer(capture.serial).toHex(),
        digestAlgorithm: asn1.derToOid(capture.digestAlgorithm),
        signatureAlgorithm: asn1.derToOid(capture.signatureAlgorithm),
        signature: capture.signature,
        authenticatedAttributes: [],
        unauthenticatedAttributes: []
      };
      var authenticatedAttributes = capture.authenticatedAttributes || [];
      var unauthenticatedAttributes = capture.unauthenticatedAttributes || [];
      return rval;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]));
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
          var attr = obj.unauthenticatedAttributes[i];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersFromAsn1(signerInfoAsn1s) {
      var ret = [];
      for (var i = 0; i < signerInfoAsn1s.length; ++i) {
        ret.push(_signerFromAsn1(signerInfoAsn1s[i]));
      }
      return ret;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i = 0; i < signers.length; ++i) {
        ret.push(_signerToAsn1(signers[i]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge.pki.oids.contentType) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
      } else if (attr.type === forge.pki.oids.messageDigest) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
      } else if (attr.type === forge.pki.oids.signingTime) {
        var jan_1_1950 = new Date('Jan 1, 1950 00:00:00Z');
        var jan_1_2050 = new Date('Jan 1, 2050 00:00:00Z');
        var date = attr.value;
        if (typeof date === 'string') {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
        } else {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [value])]);
    }
    function _encryptedContentToAsn1(ec) {
      return [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())]), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())])];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error('Cannot read PKCS#7 message. ' + 'ASN.1 object is not a supported PKCS#7 message.');
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge.pki.oids.data) {
        throw new Error('Unsupported PKCS#7 message. ' + 'Only wrapped ContentType Data supported.');
      }
      if (capture.encryptedContent) {
        var content = '';
        if (forge.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error('Malformed PKCS#7 message, expecting encrypted ' + 'content constructed of only OCTET STRING objects.');
            }
            content += capture.encryptedContent[i].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge.util.createBuffer(capture.encParameter.value),
          content: forge.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = '';
        if (forge.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error('Malformed PKCS#7 message, expecting ' + 'content constructed of only OCTET STRING objects.');
            }
            content += capture.content[i].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === undefined) {
        throw new Error('Symmetric key not available.');
      }
      if (msg.content === undefined) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge.pki.oids['aes128-CBC']:
          case forge.pki.oids['aes192-CBC']:
          case forge.pki.oids['aes256-CBC']:
            ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge.pki.oids['desCBC']:
          case forge.pki.oids['des-EDE3-CBC']:
            ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error('Unsupported symmetric cipher, OID ' + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error('Symmetric decryption failed.');
        }
        msg.content = ciph.output;
      }
    }
  }
  var name = 'pkcs7';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/pkcs7", ["require", "module", "npm:node-forge@0.6.35/js/aes", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/des", "npm:node-forge@0.6.35/js/oids", "npm:node-forge@0.6.35/js/pem", "npm:node-forge@0.6.35/js/pkcs7asn1", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/util", "npm:node-forge@0.6.35/js/x509"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var ssh = forge.ssh = forge.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || '';
      passphrase = passphrase || '';
      var algorithm = 'ssh-rsa';
      var encryptionAlgorithm = (passphrase === '') ? 'none' : 'aes256-cbc';
      var ppk = 'PuTTY-User-Key-File-2: ' + algorithm + '\r\n';
      ppk += 'Encryption: ' + encryptionAlgorithm + '\r\n';
      ppk += 'Comment: ' + comment + '\r\n';
      var pubbuffer = forge.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge.util.encode64(pubbuffer.bytes(), 64);
      var length = Math.floor(pub.length / 66) + 1;
      ppk += 'Public-Lines: ' + length + '\r\n';
      ppk += pub;
      var privbuffer = forge.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding = _sha1(privbuffer.bytes());
        padding.truncate(padding.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding);
        var aeskey = forge.util.createBuffer();
        aeskey.putBuffer(_sha1('\x00\x00\x00\x00', passphrase));
        aeskey.putBuffer(_sha1('\x00\x00\x00\x01', passphrase));
        var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), 'CBC');
        cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge.util.encode64(encrypted.bytes(), 64);
      }
      length = Math.floor(priv.length / 66) + 1;
      ppk += '\r\nPrivate-Lines: ' + length + '\r\n';
      ppk += priv;
      var mackey = _sha1('putty-private-key-file-mac-key', passphrase);
      var macbuffer = forge.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac = forge.hmac.create();
      hmac.start('sha1', mackey);
      hmac.update(macbuffer.bytes());
      ppk += '\r\nPrivate-MAC: ' + hmac.digest().toHex() + '\r\n';
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key, comment) {
      var type = 'ssh-rsa';
      comment = comment || '';
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      return type + ' ' + forge.util.encode64(buffer.bytes()) + ' ' + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge.pki.privateKeyToPem(privateKey);
      }
      return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, {
        legacy: true,
        algorithm: 'aes128'
      });
    };
    ssh.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.md5.create();
      var type = 'ssh-rsa';
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      md.start();
      md.update(buffer.getBytes());
      var digest = md.digest();
      if (options.encoding === 'hex') {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === 'binary') {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    function _addBigIntegerToBuffer(buffer, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= '8') {
        hexVal = '00' + hexVal;
      }
      var bytes = forge.util.hexToBytes(hexVal);
      buffer.putInt32(bytes.length);
      buffer.putBytes(bytes);
    }
    function _addStringToBuffer(buffer, val) {
      buffer.putInt32(val.length);
      buffer.putString(val);
    }
    function _sha1() {
      var sha = forge.md.sha1.create();
      var num = arguments.length;
      for (var i = 0; i < num; ++i) {
        sha.update(arguments[i]);
      }
      return sha.digest();
    }
  }
  var name = 'ssh';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/ssh", ["require", "module", "npm:node-forge@0.6.35/js/aes", "npm:node-forge@0.6.35/js/hmac", "npm:node-forge@0.6.35/js/md5", "npm:node-forge@0.6.35/js/sha1", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  function initModule(forge) {
    var cat = 'forge.task';
    var sVL = 0;
    var sTasks = {};
    var sNextTaskId = 0;
    forge.debug.set(cat, 'tasks', sTasks);
    var sTaskQueues = {};
    forge.debug.set(cat, 'queues', sTaskQueues);
    var sNoTaskName = '?';
    var sMaxRecursions = 30;
    var sTimeSlice = 20;
    var READY = 'ready';
    var RUNNING = 'running';
    var BLOCKED = 'blocked';
    var SLEEPING = 'sleeping';
    var DONE = 'done';
    var ERROR = 'error';
    var STOP = 'stop';
    var START = 'start';
    var BLOCK = 'block';
    var UNBLOCK = 'unblock';
    var SLEEP = 'sleep';
    var WAKEUP = 'wakeup';
    var CANCEL = 'cancel';
    var FAIL = 'fail';
    var sStateTable = {};
    sStateTable[READY] = {};
    sStateTable[READY][STOP] = READY;
    sStateTable[READY][START] = RUNNING;
    sStateTable[READY][CANCEL] = DONE;
    sStateTable[READY][FAIL] = ERROR;
    sStateTable[RUNNING] = {};
    sStateTable[RUNNING][STOP] = READY;
    sStateTable[RUNNING][START] = RUNNING;
    sStateTable[RUNNING][BLOCK] = BLOCKED;
    sStateTable[RUNNING][UNBLOCK] = RUNNING;
    sStateTable[RUNNING][SLEEP] = SLEEPING;
    sStateTable[RUNNING][WAKEUP] = RUNNING;
    sStateTable[RUNNING][CANCEL] = DONE;
    sStateTable[RUNNING][FAIL] = ERROR;
    sStateTable[BLOCKED] = {};
    sStateTable[BLOCKED][STOP] = BLOCKED;
    sStateTable[BLOCKED][START] = BLOCKED;
    sStateTable[BLOCKED][BLOCK] = BLOCKED;
    sStateTable[BLOCKED][UNBLOCK] = BLOCKED;
    sStateTable[BLOCKED][SLEEP] = BLOCKED;
    sStateTable[BLOCKED][WAKEUP] = BLOCKED;
    sStateTable[BLOCKED][CANCEL] = DONE;
    sStateTable[BLOCKED][FAIL] = ERROR;
    sStateTable[SLEEPING] = {};
    sStateTable[SLEEPING][STOP] = SLEEPING;
    sStateTable[SLEEPING][START] = SLEEPING;
    sStateTable[SLEEPING][BLOCK] = SLEEPING;
    sStateTable[SLEEPING][UNBLOCK] = SLEEPING;
    sStateTable[SLEEPING][SLEEP] = SLEEPING;
    sStateTable[SLEEPING][WAKEUP] = SLEEPING;
    sStateTable[SLEEPING][CANCEL] = DONE;
    sStateTable[SLEEPING][FAIL] = ERROR;
    sStateTable[DONE] = {};
    sStateTable[DONE][STOP] = DONE;
    sStateTable[DONE][START] = DONE;
    sStateTable[DONE][BLOCK] = DONE;
    sStateTable[DONE][UNBLOCK] = DONE;
    sStateTable[DONE][SLEEP] = DONE;
    sStateTable[DONE][WAKEUP] = DONE;
    sStateTable[DONE][CANCEL] = DONE;
    sStateTable[DONE][FAIL] = ERROR;
    sStateTable[ERROR] = {};
    sStateTable[ERROR][STOP] = ERROR;
    sStateTable[ERROR][START] = ERROR;
    sStateTable[ERROR][BLOCK] = ERROR;
    sStateTable[ERROR][UNBLOCK] = ERROR;
    sStateTable[ERROR][SLEEP] = ERROR;
    sStateTable[ERROR][WAKEUP] = ERROR;
    sStateTable[ERROR][CANCEL] = ERROR;
    sStateTable[ERROR][FAIL] = ERROR;
    var Task = function(options) {
      this.id = -1;
      this.name = options.name || sNoTaskName;
      this.parent = options.parent || null;
      this.run = options.run;
      this.subtasks = [];
      this.error = false;
      this.state = READY;
      this.blocks = 0;
      this.timeoutId = null;
      this.swapTime = null;
      this.userData = null;
      this.id = sNextTaskId++;
      sTasks[this.id] = this;
      if (sVL >= 1) {
        forge.log.verbose(cat, '[%s][%s] init', this.id, this.name, this);
      }
    };
    Task.prototype.debug = function(msg) {
      msg = msg || '';
      forge.log.debug(cat, msg, '[%s][%s] task:', this.id, this.name, this, 'subtasks:', this.subtasks.length, 'queue:', sTaskQueues);
    };
    Task.prototype.next = function(name, subrun) {
      if (typeof(name) === 'function') {
        subrun = name;
        name = this.name;
      }
      var subtask = new Task({
        run: subrun,
        name: name,
        parent: this
      });
      subtask.state = RUNNING;
      subtask.type = this.type;
      subtask.successCallback = this.successCallback || null;
      subtask.failureCallback = this.failureCallback || null;
      this.subtasks.push(subtask);
      return this;
    };
    Task.prototype.parallel = function(name, subrun) {
      if (forge.util.isArray(name)) {
        subrun = name;
        name = this.name;
      }
      return this.next(name, function(task) {
        var ptask = task;
        ptask.block(subrun.length);
        var startParallelTask = function(pname, pi) {
          forge.task.start({
            type: pname,
            run: function(task) {
              subrun[pi](task);
            },
            success: function(task) {
              ptask.unblock();
            },
            failure: function(task) {
              ptask.unblock();
            }
          });
        };
        for (var i = 0; i < subrun.length; i++) {
          var pname = name + '__parallel-' + task.id + '-' + i;
          var pi = i;
          startParallelTask(pname, pi);
        }
      });
    };
    Task.prototype.stop = function() {
      this.state = sStateTable[this.state][STOP];
    };
    Task.prototype.start = function() {
      this.error = false;
      this.state = sStateTable[this.state][START];
      if (this.state === RUNNING) {
        this.start = new Date();
        this.run(this);
        runNext(this, 0);
      }
    };
    Task.prototype.block = function(n) {
      n = typeof(n) === 'undefined' ? 1 : n;
      this.blocks += n;
      if (this.blocks > 0) {
        this.state = sStateTable[this.state][BLOCK];
      }
    };
    Task.prototype.unblock = function(n) {
      n = typeof(n) === 'undefined' ? 1 : n;
      this.blocks -= n;
      if (this.blocks === 0 && this.state !== DONE) {
        this.state = RUNNING;
        runNext(this, 0);
      }
      return this.blocks;
    };
    Task.prototype.sleep = function(n) {
      n = typeof(n) === 'undefined' ? 0 : n;
      this.state = sStateTable[this.state][SLEEP];
      var self = this;
      this.timeoutId = setTimeout(function() {
        self.timeoutId = null;
        self.state = RUNNING;
        runNext(self, 0);
      }, n);
    };
    Task.prototype.wait = function(cond) {
      cond.wait(this);
    };
    Task.prototype.wakeup = function() {
      if (this.state === SLEEPING) {
        cancelTimeout(this.timeoutId);
        this.timeoutId = null;
        this.state = RUNNING;
        runNext(this, 0);
      }
    };
    Task.prototype.cancel = function() {
      this.state = sStateTable[this.state][CANCEL];
      this.permitsNeeded = 0;
      if (this.timeoutId !== null) {
        cancelTimeout(this.timeoutId);
        this.timeoutId = null;
      }
      this.subtasks = [];
    };
    Task.prototype.fail = function(next) {
      this.error = true;
      finish(this, true);
      if (next) {
        next.error = this.error;
        next.swapTime = this.swapTime;
        next.userData = this.userData;
        runNext(next, 0);
      } else {
        if (this.parent !== null) {
          var parent = this.parent;
          while (parent.parent !== null) {
            parent.error = this.error;
            parent.swapTime = this.swapTime;
            parent.userData = this.userData;
            parent = parent.parent;
          }
          finish(parent, true);
        }
        if (this.failureCallback) {
          this.failureCallback(this);
        }
      }
    };
    var start = function(task) {
      task.error = false;
      task.state = sStateTable[task.state][START];
      setTimeout(function() {
        if (task.state === RUNNING) {
          task.swapTime = +new Date();
          task.run(task);
          runNext(task, 0);
        }
      }, 0);
    };
    var runNext = function(task, recurse) {
      var swap = (recurse > sMaxRecursions) || (+new Date() - task.swapTime) > sTimeSlice;
      var doNext = function(recurse) {
        recurse++;
        if (task.state === RUNNING) {
          if (swap) {
            task.swapTime = +new Date();
          }
          if (task.subtasks.length > 0) {
            var subtask = task.subtasks.shift();
            subtask.error = task.error;
            subtask.swapTime = task.swapTime;
            subtask.userData = task.userData;
            subtask.run(subtask);
            if (!subtask.error) {
              runNext(subtask, recurse);
            }
          } else {
            finish(task);
            if (!task.error) {
              if (task.parent !== null) {
                task.parent.error = task.error;
                task.parent.swapTime = task.swapTime;
                task.parent.userData = task.userData;
                runNext(task.parent, recurse);
              }
            }
          }
        }
      };
      if (swap) {
        setTimeout(doNext, 0);
      } else {
        doNext(recurse);
      }
    };
    var finish = function(task, suppressCallbacks) {
      task.state = DONE;
      delete sTasks[task.id];
      if (sVL >= 1) {
        forge.log.verbose(cat, '[%s][%s] finish', task.id, task.name, task);
      }
      if (task.parent === null) {
        if (!(task.type in sTaskQueues)) {
          forge.log.error(cat, '[%s][%s] task queue missing [%s]', task.id, task.name, task.type);
        } else if (sTaskQueues[task.type].length === 0) {
          forge.log.error(cat, '[%s][%s] task queue empty [%s]', task.id, task.name, task.type);
        } else if (sTaskQueues[task.type][0] !== task) {
          forge.log.error(cat, '[%s][%s] task not first in queue [%s]', task.id, task.name, task.type);
        } else {
          sTaskQueues[task.type].shift();
          if (sTaskQueues[task.type].length === 0) {
            if (sVL >= 1) {
              forge.log.verbose(cat, '[%s][%s] delete queue [%s]', task.id, task.name, task.type);
            }
            delete sTaskQueues[task.type];
          } else {
            if (sVL >= 1) {
              forge.log.verbose(cat, '[%s][%s] queue start next [%s] remain:%s', task.id, task.name, task.type, sTaskQueues[task.type].length);
            }
            sTaskQueues[task.type][0].start();
          }
        }
        if (!suppressCallbacks) {
          if (task.error && task.failureCallback) {
            task.failureCallback(task);
          } else if (!task.error && task.successCallback) {
            task.successCallback(task);
          }
        }
      }
    };
    forge.task = forge.task || {};
    forge.task.start = function(options) {
      var task = new Task({
        run: options.run,
        name: options.name || sNoTaskName
      });
      task.type = options.type;
      task.successCallback = options.success || null;
      task.failureCallback = options.failure || null;
      if (!(task.type in sTaskQueues)) {
        if (sVL >= 1) {
          forge.log.verbose(cat, '[%s][%s] create queue [%s]', task.id, task.name, task.type);
        }
        sTaskQueues[task.type] = [task];
        start(task);
      } else {
        sTaskQueues[options.type].push(task);
      }
    };
    forge.task.cancel = function(type) {
      if (type in sTaskQueues) {
        sTaskQueues[type] = [sTaskQueues[type][0]];
      }
    };
    forge.task.createCondition = function() {
      var cond = {tasks: {}};
      cond.wait = function(task) {
        if (!(task.id in cond.tasks)) {
          task.block();
          cond.tasks[task.id] = task;
        }
      };
      cond.notify = function() {
        var tmp = cond.tasks;
        cond.tasks = {};
        for (var id in tmp) {
          tmp[id].unblock();
        }
      };
      return cond;
    };
  }
  var name = 'task';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {};
      }
      return initModule(forge);
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      }).concat(initModule);
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge[name];
    };
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/task", ["require", "module", "npm:node-forge@0.6.35/js/debug", "npm:node-forge@0.6.35/js/log", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function() {
  var name = 'forge';
  if (typeof define !== 'function') {
    if (typeof module === 'object' && module.exports) {
      var nodeJS = true;
      define = function(ids, factory) {
        factory(require, module);
      };
    } else {
      if (typeof forge === 'undefined') {
        forge = {disableNativeCode: false};
      }
      return;
    }
  }
  var deps;
  var defineFunc = function(require, module) {
    module.exports = function(forge) {
      var mods = deps.map(function(dep) {
        return require(dep);
      });
      forge = forge || {};
      forge.defined = forge.defined || {};
      if (forge.defined[name]) {
        return forge[name];
      }
      forge.defined[name] = true;
      for (var i = 0; i < mods.length; ++i) {
        mods[i](forge);
      }
      return forge;
    };
    module.exports.disableNativeCode = false;
    module.exports(module.exports);
  };
  var tmpDefine = define;
  define = function(ids, factory) {
    deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
    if (nodeJS) {
      delete define;
      return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
    }
    define = tmpDefine;
    return define.apply(null, Array.prototype.slice.call(arguments, 0));
  };
  define("npm:node-forge@0.6.35/js/forge", ["require", "module", "npm:node-forge@0.6.35/js/aes", "npm:node-forge@0.6.35/js/aesCipherSuites", "npm:node-forge@0.6.35/js/asn1", "npm:node-forge@0.6.35/js/cipher", "npm:node-forge@0.6.35/js/cipherModes", "npm:node-forge@0.6.35/js/debug", "npm:node-forge@0.6.35/js/des", "npm:node-forge@0.6.35/js/hmac", "npm:node-forge@0.6.35/js/kem", "npm:node-forge@0.6.35/js/log", "npm:node-forge@0.6.35/js/md", "npm:node-forge@0.6.35/js/mgf1", "npm:node-forge@0.6.35/js/pbkdf2", "npm:node-forge@0.6.35/js/pem", "npm:node-forge@0.6.35/js/pkcs7", "npm:node-forge@0.6.35/js/pkcs1", "npm:node-forge@0.6.35/js/pkcs12", "npm:node-forge@0.6.35/js/pki", "npm:node-forge@0.6.35/js/prime", "npm:node-forge@0.6.35/js/prng", "npm:node-forge@0.6.35/js/pss", "npm:node-forge@0.6.35/js/random", "npm:node-forge@0.6.35/js/rc2", "npm:node-forge@0.6.35/js/ssh", "npm:node-forge@0.6.35/js/task", "npm:node-forge@0.6.35/js/tls", "npm:node-forge@0.6.35/js/util"], function() {
    defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
  });
})();

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:node-forge@0.6.35", ["npm:node-forge@0.6.35/js/forge"], function(main) {
  return main;
});

_removeDefine();
})();
System.register('libraries/forge/forge.js', ['github:angular/bower-angular@1.4.7', 'npm:node-forge@0.6.35'], function (_export) {
  'use strict';

  var angular, forge;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_npmNodeForge0635) {
      forge = _npmNodeForge0635['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.forge', []).factory('forge', /*@ngInject*/function () {
        return forge;
      }));
    }
  };
});

System.registerDynamic("libraries/ionic/ionic-library.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    (function() {
      window.ionic = window.ionic || {};
      window.ionic.views = {};
      window.ionic.version = '1.1.0';
      (function(ionic) {
        ionic.DelegateService = function(methodNames) {
          if (methodNames.indexOf('$getByHandle') > -1) {
            throw new Error("Method '$getByHandle' is implicitly added to each delegate service. Do not list it as a method.");
          }
          function trueFn() {
            return true;
          }
          return ['$log', function($log) {
            function DelegateInstance(instances, handle) {
              this._instances = instances;
              this.handle = handle;
            }
            methodNames.forEach(function(methodName) {
              DelegateInstance.prototype[methodName] = instanceMethodCaller(methodName);
            });
            function DelegateService() {
              this._instances = [];
            }
            DelegateService.prototype = DelegateInstance.prototype;
            DelegateService.prototype._registerInstance = function(instance, handle, filterFn) {
              var instances = this._instances;
              instance.$$delegateHandle = handle;
              instance.$$filterFn = filterFn || trueFn;
              instances.push(instance);
              return function deregister() {
                var index = instances.indexOf(instance);
                if (index !== -1) {
                  instances.splice(index, 1);
                }
              };
            };
            DelegateService.prototype.$getByHandle = function(handle) {
              return new DelegateInstance(this._instances, handle);
            };
            return new DelegateService();
            function instanceMethodCaller(methodName) {
              return function caller() {
                var handle = this.handle;
                var args = arguments;
                var foundInstancesCount = 0;
                var returnValue;
                this._instances.forEach(function(instance) {
                  if ((!handle || handle == instance.$$delegateHandle) && instance.$$filterFn(instance)) {
                    foundInstancesCount++;
                    var ret = instance[methodName].apply(instance, args);
                    if (foundInstancesCount === 1) {
                      returnValue = ret;
                    }
                  }
                });
                if (!foundInstancesCount && handle) {
                  return $log.warn('Delegate for handle "' + handle + '" could not find a ' + 'corresponding element with delegate-handle="' + handle + '"! ' + methodName + '() was not called!\n' + 'Possible cause: If you are calling ' + methodName + '() immediately, and ' + 'your element with delegate-handle="' + handle + '" is a child of your ' + 'controller, then your element may not be compiled yet. Put a $timeout ' + 'around your call to ' + methodName + '() and try again.');
                }
                return returnValue;
              };
            }
          }];
        };
      })(window.ionic);
      (function(window, document, ionic) {
        var readyCallbacks = [];
        var isDomReady = document.readyState === 'complete' || document.readyState === 'interactive';
        function domReady() {
          isDomReady = true;
          for (var x = 0; x < readyCallbacks.length; x++) {
            ionic.requestAnimationFrame(readyCallbacks[x]);
          }
          readyCallbacks = [];
          document.removeEventListener('DOMContentLoaded', domReady);
        }
        if (!isDomReady) {
          document.addEventListener('DOMContentLoaded', domReady);
        }
        window._rAF = (function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
            window.setTimeout(callback, 16);
          };
        })();
        var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;
        ionic.DomUtil = {
          requestAnimationFrame: function(cb) {
            return window._rAF(cb);
          },
          cancelAnimationFrame: function(requestId) {
            cancelAnimationFrame(requestId);
          },
          animationFrameThrottle: function(cb) {
            var args,
                isQueued,
                context;
            return function() {
              args = arguments;
              context = this;
              if (!isQueued) {
                isQueued = true;
                ionic.requestAnimationFrame(function() {
                  cb.apply(context, args);
                  isQueued = false;
                });
              }
            };
          },
          contains: function(parentNode, otherNode) {
            var current = otherNode;
            while (current) {
              if (current === parentNode)
                return true;
              current = current.parentNode;
            }
          },
          getPositionInParent: function(el) {
            return {
              left: el.offsetLeft,
              top: el.offsetTop
            };
          },
          ready: function(cb) {
            if (isDomReady) {
              ionic.requestAnimationFrame(cb);
            } else {
              readyCallbacks.push(cb);
            }
          },
          getTextBounds: function(textNode) {
            if (document.createRange) {
              var range = document.createRange();
              range.selectNodeContents(textNode);
              if (range.getBoundingClientRect) {
                var rect = range.getBoundingClientRect();
                if (rect) {
                  var sx = window.scrollX;
                  var sy = window.scrollY;
                  return {
                    top: rect.top + sy,
                    left: rect.left + sx,
                    right: rect.left + sx + rect.width,
                    bottom: rect.top + sy + rect.height,
                    width: rect.width,
                    height: rect.height
                  };
                }
              }
            }
            return null;
          },
          getChildIndex: function(element, type) {
            if (type) {
              var ch = element.parentNode.children;
              var c;
              for (var i = 0,
                  k = 0,
                  j = ch.length; i < j; i++) {
                c = ch[i];
                if (c.nodeName && c.nodeName.toLowerCase() == type) {
                  if (c == element) {
                    return k;
                  }
                  k++;
                }
              }
            }
            return Array.prototype.slice.call(element.parentNode.children).indexOf(element);
          },
          swapNodes: function(src, dest) {
            dest.parentNode.insertBefore(src, dest);
          },
          elementIsDescendant: function(el, parent, stopAt) {
            var current = el;
            do {
              if (current === parent)
                return true;
              current = current.parentNode;
            } while (current && current !== stopAt);
            return false;
          },
          getParentWithClass: function(e, className, depth) {
            depth = depth || 10;
            while (e.parentNode && depth--) {
              if (e.parentNode.classList && e.parentNode.classList.contains(className)) {
                return e.parentNode;
              }
              e = e.parentNode;
            }
            return null;
          },
          getParentOrSelfWithClass: function(e, className, depth) {
            depth = depth || 10;
            while (e && depth--) {
              if (e.classList && e.classList.contains(className)) {
                return e;
              }
              e = e.parentNode;
            }
            return null;
          },
          rectContains: function(x, y, x1, y1, x2, y2) {
            if (x < x1 || x > x2)
              return false;
            if (y < y1 || y > y2)
              return false;
            return true;
          },
          blurAll: function() {
            if (document.activeElement && document.activeElement != document.body) {
              document.activeElement.blur();
              return document.activeElement;
            }
            return null;
          },
          cachedAttr: function(ele, key, value) {
            ele = ele && ele.length && ele[0] || ele;
            if (ele && ele.setAttribute) {
              var dataKey = '$attr-' + key;
              if (arguments.length > 2) {
                if (ele[dataKey] !== value) {
                  ele.setAttribute(key, value);
                  ele[dataKey] = value;
                }
              } else if (typeof ele[dataKey] == 'undefined') {
                ele[dataKey] = ele.getAttribute(key);
              }
              return ele[dataKey];
            }
          },
          cachedStyles: function(ele, styles) {
            ele = ele && ele.length && ele[0] || ele;
            if (ele && ele.style) {
              for (var prop in styles) {
                if (ele['$style-' + prop] !== styles[prop]) {
                  ele.style[prop] = ele['$style-' + prop] = styles[prop];
                }
              }
            }
          }
        };
        ionic.requestAnimationFrame = ionic.DomUtil.requestAnimationFrame;
        ionic.cancelAnimationFrame = ionic.DomUtil.cancelAnimationFrame;
        ionic.animationFrameThrottle = ionic.DomUtil.animationFrameThrottle;
      })(window, document, ionic);
      (function(ionic) {
        ionic.CustomEvent = (function() {
          if (typeof window.CustomEvent === 'function')
            return CustomEvent;
          var customEvent = function(event, params) {
            var evt;
            params = params || {
              bubbles: false,
              cancelable: false,
              detail: undefined
            };
            try {
              evt = document.createEvent("CustomEvent");
              evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            } catch (error) {
              evt = document.createEvent("Event");
              for (var param in params) {
                evt[param] = params[param];
              }
              evt.initEvent(event, params.bubbles, params.cancelable);
            }
            return evt;
          };
          customEvent.prototype = window.Event.prototype;
          return customEvent;
        })();
        ionic.EventController = {
          VIRTUALIZED_EVENTS: ['tap', 'swipe', 'swiperight', 'swipeleft', 'drag', 'hold', 'release'],
          trigger: function(eventType, data, bubbles, cancelable) {
            var event = new ionic.CustomEvent(eventType, {
              detail: data,
              bubbles: !!bubbles,
              cancelable: !!cancelable
            });
            data && data.target && data.target.dispatchEvent && data.target.dispatchEvent(event) || window.dispatchEvent(event);
          },
          on: function(type, callback, element) {
            var e = element || window;
            for (var i = 0,
                j = this.VIRTUALIZED_EVENTS.length; i < j; i++) {
              if (type == this.VIRTUALIZED_EVENTS[i]) {
                var gesture = new ionic.Gesture(element);
                gesture.on(type, callback);
                return gesture;
              }
            }
            e.addEventListener(type, callback);
          },
          off: function(type, callback, element) {
            element.removeEventListener(type, callback);
          },
          onGesture: function(type, callback, element, options) {
            var gesture = new ionic.Gesture(element, options);
            gesture.on(type, callback);
            return gesture;
          },
          offGesture: function(gesture, type, callback) {
            gesture && gesture.off(type, callback);
          },
          handlePopState: function() {}
        };
        ionic.on = function() {
          ionic.EventController.on.apply(ionic.EventController, arguments);
        };
        ionic.off = function() {
          ionic.EventController.off.apply(ionic.EventController, arguments);
        };
        ionic.trigger = ionic.EventController.trigger;
        ionic.onGesture = function() {
          return ionic.EventController.onGesture.apply(ionic.EventController.onGesture, arguments);
        };
        ionic.offGesture = function() {
          return ionic.EventController.offGesture.apply(ionic.EventController.offGesture, arguments);
        };
      })(window.ionic);
      (function(ionic) {
        ionic.Gesture = function(element, options) {
          return new ionic.Gestures.Instance(element, options || {});
        };
        ionic.Gestures = {};
        ionic.Gestures.defaults = {stop_browser_behavior: 'disable-user-behavior'};
        ionic.Gestures.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
        ionic.Gestures.HAS_TOUCHEVENTS = ('ontouchstart' in window);
        ionic.Gestures.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
        ionic.Gestures.NO_MOUSEEVENTS = ionic.Gestures.HAS_TOUCHEVENTS && window.navigator.userAgent.match(ionic.Gestures.MOBILE_REGEX);
        ionic.Gestures.EVENT_TYPES = {};
        ionic.Gestures.DIRECTION_DOWN = 'down';
        ionic.Gestures.DIRECTION_LEFT = 'left';
        ionic.Gestures.DIRECTION_UP = 'up';
        ionic.Gestures.DIRECTION_RIGHT = 'right';
        ionic.Gestures.POINTER_MOUSE = 'mouse';
        ionic.Gestures.POINTER_TOUCH = 'touch';
        ionic.Gestures.POINTER_PEN = 'pen';
        ionic.Gestures.EVENT_START = 'start';
        ionic.Gestures.EVENT_MOVE = 'move';
        ionic.Gestures.EVENT_END = 'end';
        ionic.Gestures.DOCUMENT = window.document;
        ionic.Gestures.plugins = {};
        ionic.Gestures.READY = false;
        function setup() {
          if (ionic.Gestures.READY) {
            return;
          }
          ionic.Gestures.event.determineEventTypes();
          for (var name in ionic.Gestures.gestures) {
            if (ionic.Gestures.gestures.hasOwnProperty(name)) {
              ionic.Gestures.detection.register(ionic.Gestures.gestures[name]);
            }
          }
          ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_MOVE, ionic.Gestures.detection.detect);
          ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_END, ionic.Gestures.detection.detect);
          ionic.Gestures.READY = true;
        }
        ionic.Gestures.Instance = function(element, options) {
          var self = this;
          if (element === null) {
            void 0;
            return this;
          }
          setup();
          this.element = element;
          this.enabled = true;
          this.options = ionic.Gestures.utils.extend(ionic.Gestures.utils.extend({}, ionic.Gestures.defaults), options || {});
          if (this.options.stop_browser_behavior) {
            ionic.Gestures.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
          }
          ionic.Gestures.event.onTouch(element, ionic.Gestures.EVENT_START, function(ev) {
            if (self.enabled) {
              ionic.Gestures.detection.startDetect(self, ev);
            }
          });
          return this;
        };
        ionic.Gestures.Instance.prototype = {
          on: function onEvent(gesture, handler) {
            var gestures = gesture.split(' ');
            for (var t = 0; t < gestures.length; t++) {
              this.element.addEventListener(gestures[t], handler, false);
            }
            return this;
          },
          off: function offEvent(gesture, handler) {
            var gestures = gesture.split(' ');
            for (var t = 0; t < gestures.length; t++) {
              this.element.removeEventListener(gestures[t], handler, false);
            }
            return this;
          },
          trigger: function triggerEvent(gesture, eventData) {
            var event = ionic.Gestures.DOCUMENT.createEvent('Event');
            event.initEvent(gesture, true, true);
            event.gesture = eventData;
            var element = this.element;
            if (ionic.Gestures.utils.hasParent(eventData.target, element)) {
              element = eventData.target;
            }
            element.dispatchEvent(event);
            return this;
          },
          enable: function enable(state) {
            this.enabled = state;
            return this;
          }
        };
        var last_move_event = null;
        var enable_detect = false;
        var touch_triggered = false;
        ionic.Gestures.event = {
          bindDom: function(element, type, handler) {
            var types = type.split(' ');
            for (var t = 0; t < types.length; t++) {
              element.addEventListener(types[t], handler, false);
            }
          },
          onTouch: function onTouch(element, eventType, handler) {
            var self = this;
            this.bindDom(element, ionic.Gestures.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
              var sourceEventType = ev.type.toLowerCase();
              if (sourceEventType.match(/mouse/) && touch_triggered) {
                return;
              } else if (sourceEventType.match(/touch/) || sourceEventType.match(/pointerdown/) || (sourceEventType.match(/mouse/) && ev.which === 1)) {
                enable_detect = true;
              } else if (sourceEventType.match(/mouse/) && ev.which !== 1) {
                enable_detect = false;
              }
              if (sourceEventType.match(/touch|pointer/)) {
                touch_triggered = true;
              }
              var count_touches = 0;
              if (enable_detect) {
                if (ionic.Gestures.HAS_POINTEREVENTS && eventType != ionic.Gestures.EVENT_END) {
                  count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
                } else if (sourceEventType.match(/touch/)) {
                  count_touches = ev.touches.length;
                } else if (!touch_triggered) {
                  count_touches = sourceEventType.match(/up/) ? 0 : 1;
                }
                if (count_touches > 0 && eventType == ionic.Gestures.EVENT_END) {
                  eventType = ionic.Gestures.EVENT_MOVE;
                } else if (!count_touches) {
                  eventType = ionic.Gestures.EVENT_END;
                }
                if (count_touches || last_move_event === null) {
                  last_move_event = ev;
                }
                handler.call(ionic.Gestures.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));
                if (ionic.Gestures.HAS_POINTEREVENTS && eventType == ionic.Gestures.EVENT_END) {
                  count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
                }
              }
              if (!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                ionic.Gestures.PointerEvent.reset();
              }
            });
          },
          determineEventTypes: function determineEventTypes() {
            var types;
            if (ionic.Gestures.HAS_POINTEREVENTS) {
              types = ionic.Gestures.PointerEvent.getEvents();
            } else if (ionic.Gestures.NO_MOUSEEVENTS) {
              types = ['touchstart', 'touchmove', 'touchend touchcancel'];
            } else {
              types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
            }
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_START] = types[0];
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_MOVE] = types[1];
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_END] = types[2];
          },
          getTouchList: function getTouchList(ev) {
            if (ionic.Gestures.HAS_POINTEREVENTS) {
              return ionic.Gestures.PointerEvent.getTouchList();
            } else if (ev.touches) {
              return ev.touches;
            } else {
              ev.identifier = 1;
              return [ev];
            }
          },
          collectEventData: function collectEventData(element, eventType, touches, ev) {
            var pointerType = ionic.Gestures.POINTER_TOUCH;
            if (ev.type.match(/mouse/) || ionic.Gestures.PointerEvent.matchType(ionic.Gestures.POINTER_MOUSE, ev)) {
              pointerType = ionic.Gestures.POINTER_MOUSE;
            }
            return {
              center: ionic.Gestures.utils.getCenter(touches),
              timeStamp: new Date().getTime(),
              target: ev.target,
              touches: touches,
              eventType: eventType,
              pointerType: pointerType,
              srcEvent: ev,
              preventDefault: function() {
                if (this.srcEvent.preventManipulation) {
                  this.srcEvent.preventManipulation();
                }
                if (this.srcEvent.preventDefault) {}
              },
              stopPropagation: function() {
                this.srcEvent.stopPropagation();
              },
              stopDetect: function() {
                return ionic.Gestures.detection.stopDetect();
              }
            };
          }
        };
        ionic.Gestures.PointerEvent = {
          pointers: {},
          getTouchList: function() {
            var self = this;
            var touchlist = [];
            Object.keys(self.pointers).sort().forEach(function(id) {
              touchlist.push(self.pointers[id]);
            });
            return touchlist;
          },
          updatePointer: function(type, pointerEvent) {
            if (type == ionic.Gestures.EVENT_END) {
              this.pointers = {};
            } else {
              pointerEvent.identifier = pointerEvent.pointerId;
              this.pointers[pointerEvent.pointerId] = pointerEvent;
            }
            return Object.keys(this.pointers).length;
          },
          matchType: function(pointerType, ev) {
            if (!ev.pointerType) {
              return false;
            }
            var types = {};
            types[ionic.Gestures.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == ionic.Gestures.POINTER_MOUSE);
            types[ionic.Gestures.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == ionic.Gestures.POINTER_TOUCH);
            types[ionic.Gestures.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == ionic.Gestures.POINTER_PEN);
            return types[pointerType];
          },
          getEvents: function() {
            return ['pointerdown MSPointerDown', 'pointermove MSPointerMove', 'pointerup pointercancel MSPointerUp MSPointerCancel'];
          },
          reset: function() {
            this.pointers = {};
          }
        };
        ionic.Gestures.utils = {
          extend: function extend(dest, src, merge) {
            for (var key in src) {
              if (dest[key] !== undefined && merge) {
                continue;
              }
              dest[key] = src[key];
            }
            return dest;
          },
          hasParent: function(node, parent) {
            while (node) {
              if (node == parent) {
                return true;
              }
              node = node.parentNode;
            }
            return false;
          },
          getCenter: function getCenter(touches) {
            var valuesX = [],
                valuesY = [];
            for (var t = 0,
                len = touches.length; t < len; t++) {
              valuesX.push(touches[t].pageX);
              valuesY.push(touches[t].pageY);
            }
            return {
              pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
              pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
            };
          },
          getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
            return {
              x: Math.abs(delta_x / delta_time) || 0,
              y: Math.abs(delta_y / delta_time) || 0
            };
          },
          getAngle: function getAngle(touch1, touch2) {
            var y = touch2.pageY - touch1.pageY,
                x = touch2.pageX - touch1.pageX;
            return Math.atan2(y, x) * 180 / Math.PI;
          },
          getDirection: function getDirection(touch1, touch2) {
            var x = Math.abs(touch1.pageX - touch2.pageX),
                y = Math.abs(touch1.pageY - touch2.pageY);
            if (x >= y) {
              return touch1.pageX - touch2.pageX > 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
            } else {
              return touch1.pageY - touch2.pageY > 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
            }
          },
          getDistance: function getDistance(touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
          },
          getScale: function getScale(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
            }
            return 1;
          },
          getRotation: function getRotation(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
            }
            return 0;
          },
          isVertical: function isVertical(direction) {
            return (direction == ionic.Gestures.DIRECTION_UP || direction == ionic.Gestures.DIRECTION_DOWN);
          },
          stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_class) {
            if (element && element.classList) {
              element.classList.add(css_class);
              element.onselectstart = function() {
                return false;
              };
            }
          }
        };
        ionic.Gestures.detection = {
          gestures: [],
          current: null,
          previous: null,
          stopped: false,
          startDetect: function startDetect(inst, eventData) {
            if (this.current) {
              return;
            }
            this.stopped = false;
            this.current = {
              inst: inst,
              startEvent: ionic.Gestures.utils.extend({}, eventData),
              lastEvent: false,
              name: ''
            };
            this.detect(eventData);
          },
          detect: function detect(eventData) {
            if (!this.current || this.stopped) {
              return null;
            }
            eventData = this.extendEventData(eventData);
            var inst_options = this.current.inst.options;
            for (var g = 0,
                len = this.gestures.length; g < len; g++) {
              var gesture = this.gestures[g];
              if (!this.stopped && inst_options[gesture.name] !== false) {
                if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                  this.stopDetect();
                  break;
                }
              }
            }
            if (this.current) {
              this.current.lastEvent = eventData;
            }
            if (eventData.eventType == ionic.Gestures.EVENT_END && !eventData.touches.length - 1) {
              this.stopDetect();
            }
            return eventData;
          },
          stopDetect: function stopDetect() {
            this.previous = ionic.Gestures.utils.extend({}, this.current);
            this.current = null;
            this.stopped = true;
          },
          extendEventData: function extendEventData(ev) {
            var startEv = this.current.startEvent;
            if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
              startEv.touches = [];
              for (var i = 0,
                  len = ev.touches.length; i < len; i++) {
                startEv.touches.push(ionic.Gestures.utils.extend({}, ev.touches[i]));
              }
            }
            var delta_time = ev.timeStamp - startEv.timeStamp,
                delta_x = ev.center.pageX - startEv.center.pageX,
                delta_y = ev.center.pageY - startEv.center.pageY,
                velocity = ionic.Gestures.utils.getVelocity(delta_time, delta_x, delta_y);
            ionic.Gestures.utils.extend(ev, {
              deltaTime: delta_time,
              deltaX: delta_x,
              deltaY: delta_y,
              velocityX: velocity.x,
              velocityY: velocity.y,
              distance: ionic.Gestures.utils.getDistance(startEv.center, ev.center),
              angle: ionic.Gestures.utils.getAngle(startEv.center, ev.center),
              direction: ionic.Gestures.utils.getDirection(startEv.center, ev.center),
              scale: ionic.Gestures.utils.getScale(startEv.touches, ev.touches),
              rotation: ionic.Gestures.utils.getRotation(startEv.touches, ev.touches),
              startEvent: startEv
            });
            return ev;
          },
          register: function register(gesture) {
            var options = gesture.defaults || {};
            if (options[gesture.name] === undefined) {
              options[gesture.name] = true;
            }
            ionic.Gestures.utils.extend(ionic.Gestures.defaults, options, true);
            gesture.index = gesture.index || 1000;
            this.gestures.push(gesture);
            this.gestures.sort(function(a, b) {
              if (a.index < b.index) {
                return -1;
              }
              if (a.index > b.index) {
                return 1;
              }
              return 0;
            });
            return this.gestures;
          }
        };
        ionic.Gestures.gestures = ionic.Gestures.gestures || {};
        ionic.Gestures.gestures.Hold = {
          name: 'hold',
          index: 10,
          defaults: {
            hold_timeout: 500,
            hold_threshold: 1
          },
          timer: null,
          handler: function holdGesture(ev, inst) {
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                clearTimeout(this.timer);
                ionic.Gestures.detection.current.name = this.name;
                this.timer = setTimeout(function() {
                  if (ionic.Gestures.detection.current.name == 'hold') {
                    ionic.tap.cancelClick();
                    inst.trigger('hold', ev);
                  }
                }, inst.options.hold_timeout);
                break;
              case ionic.Gestures.EVENT_MOVE:
                if (ev.distance > inst.options.hold_threshold) {
                  clearTimeout(this.timer);
                }
                break;
              case ionic.Gestures.EVENT_END:
                clearTimeout(this.timer);
                break;
            }
          }
        };
        ionic.Gestures.gestures.Tap = {
          name: 'tap',
          index: 100,
          defaults: {
            tap_max_touchtime: 250,
            tap_max_distance: 10,
            tap_always: true,
            doubletap_distance: 20,
            doubletap_interval: 300
          },
          handler: function tapGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END && ev.srcEvent.type != 'touchcancel') {
              var prev = ionic.Gestures.detection.previous,
                  did_doubletap = false;
              if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) {
                return;
              }
              if (prev && prev.name == 'tap' && (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance) {
                inst.trigger('doubletap', ev);
                did_doubletap = true;
              }
              if (!did_doubletap || inst.options.tap_always) {
                ionic.Gestures.detection.current.name = 'tap';
                inst.trigger('tap', ev);
              }
            }
          }
        };
        ionic.Gestures.gestures.Swipe = {
          name: 'swipe',
          index: 40,
          defaults: {
            swipe_max_touches: 1,
            swipe_velocity: 0.4
          },
          handler: function swipeGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END) {
              if (inst.options.swipe_max_touches > 0 && ev.touches.length > inst.options.swipe_max_touches) {
                return;
              }
              if (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) {
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
              }
            }
          }
        };
        ionic.Gestures.gestures.Drag = {
          name: 'drag',
          index: 50,
          defaults: {
            drag_min_distance: 10,
            correct_for_drag_min_distance: true,
            drag_max_touches: 1,
            drag_block_horizontal: true,
            drag_block_vertical: true,
            drag_lock_to_axis: false,
            drag_lock_min_distance: 25,
            prevent_default_directions: []
          },
          triggered: false,
          handler: function dragGesture(ev, inst) {
            if (ev.srcEvent.type == 'touchstart' || ev.srcEvent.type == 'touchend') {
              this.preventedFirstMove = false;
            } else if (!this.preventedFirstMove && ev.srcEvent.type == 'touchmove') {
              if (inst.options.prevent_default_directions.length > 0 && inst.options.prevent_default_directions.indexOf(ev.direction) != -1) {
                ev.srcEvent.preventDefault();
              }
              this.preventedFirstMove = true;
            }
            if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
              inst.trigger(this.name + 'end', ev);
              this.triggered = false;
              return;
            }
            if (inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches) {
              return;
            }
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                this.triggered = false;
                break;
              case ionic.Gestures.EVENT_MOVE:
                if (ev.distance < inst.options.drag_min_distance && ionic.Gestures.detection.current.name != this.name) {
                  return;
                }
                if (ionic.Gestures.detection.current.name != this.name) {
                  ionic.Gestures.detection.current.name = this.name;
                  if (inst.options.correct_for_drag_min_distance) {
                    var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
                    ionic.Gestures.detection.current.startEvent.center.pageX += ev.deltaX * factor;
                    ionic.Gestures.detection.current.startEvent.center.pageY += ev.deltaY * factor;
                    ev = ionic.Gestures.detection.extendEventData(ev);
                  }
                }
                if (ionic.Gestures.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance)) {
                  ev.drag_locked_to_axis = true;
                }
                var last_direction = ionic.Gestures.detection.current.lastEvent.direction;
                if (ev.drag_locked_to_axis && last_direction !== ev.direction) {
                  if (ionic.Gestures.utils.isVertical(last_direction)) {
                    ev.direction = (ev.deltaY < 0) ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
                  } else {
                    ev.direction = (ev.deltaX < 0) ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
                  }
                }
                if (!this.triggered) {
                  inst.trigger(this.name + 'start', ev);
                  this.triggered = true;
                }
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
                if ((inst.options.drag_block_vertical && ionic.Gestures.utils.isVertical(ev.direction)) || (inst.options.drag_block_horizontal && !ionic.Gestures.utils.isVertical(ev.direction))) {
                  ev.preventDefault();
                }
                break;
              case ionic.Gestures.EVENT_END:
                if (this.triggered) {
                  inst.trigger(this.name + 'end', ev);
                }
                this.triggered = false;
                break;
            }
          }
        };
        ionic.Gestures.gestures.Transform = {
          name: 'transform',
          index: 45,
          defaults: {
            transform_min_scale: 0.01,
            transform_min_rotation: 1,
            transform_always_block: false
          },
          triggered: false,
          handler: function transformGesture(ev, inst) {
            if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
              inst.trigger(this.name + 'end', ev);
              this.triggered = false;
              return;
            }
            if (ev.touches.length < 2) {
              return;
            }
            if (inst.options.transform_always_block) {
              ev.preventDefault();
            }
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                this.triggered = false;
                break;
              case ionic.Gestures.EVENT_MOVE:
                var scale_threshold = Math.abs(1 - ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);
                if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) {
                  return;
                }
                ionic.Gestures.detection.current.name = this.name;
                if (!this.triggered) {
                  inst.trigger(this.name + 'start', ev);
                  this.triggered = true;
                }
                inst.trigger(this.name, ev);
                if (rotation_threshold > inst.options.transform_min_rotation) {
                  inst.trigger('rotate', ev);
                }
                if (scale_threshold > inst.options.transform_min_scale) {
                  inst.trigger('pinch', ev);
                  inst.trigger('pinch' + ((ev.scale < 1) ? 'in' : 'out'), ev);
                }
                break;
              case ionic.Gestures.EVENT_END:
                if (this.triggered) {
                  inst.trigger(this.name + 'end', ev);
                }
                this.triggered = false;
                break;
            }
          }
        };
        ionic.Gestures.gestures.Touch = {
          name: 'touch',
          index: -Infinity,
          defaults: {
            prevent_default: false,
            prevent_mouseevents: false
          },
          handler: function touchGesture(ev, inst) {
            if (inst.options.prevent_mouseevents && ev.pointerType == ionic.Gestures.POINTER_MOUSE) {
              ev.stopDetect();
              return;
            }
            if (inst.options.prevent_default) {
              ev.preventDefault();
            }
            if (ev.eventType == ionic.Gestures.EVENT_START) {
              inst.trigger(this.name, ev);
            }
          }
        };
        ionic.Gestures.gestures.Release = {
          name: 'release',
          index: Infinity,
          handler: function releaseGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END) {
              inst.trigger(this.name, ev);
            }
          }
        };
      })(window.ionic);
      (function(window, document, ionic) {
        function getParameterByName(name) {
          name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
          var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
              results = regex.exec(location.search);
          return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        }
        var IOS = 'ios';
        var ANDROID = 'android';
        var WINDOWS_PHONE = 'windowsphone';
        var requestAnimationFrame = ionic.requestAnimationFrame;
        var self = ionic.Platform = {
          navigator: window.navigator,
          isReady: false,
          isFullScreen: false,
          platforms: null,
          grade: null,
          ua: navigator.userAgent,
          ready: function(cb) {
            if (self.isReady) {
              cb();
            } else {
              readyCallbacks.push(cb);
            }
          },
          detect: function() {
            self._checkPlatforms();
            requestAnimationFrame(function() {
              for (var i = 0; i < self.platforms.length; i++) {
                document.body.classList.add('platform-' + self.platforms[i]);
              }
            });
          },
          setGrade: function(grade) {
            var oldGrade = self.grade;
            self.grade = grade;
            requestAnimationFrame(function() {
              if (oldGrade) {
                document.body.classList.remove('grade-' + oldGrade);
              }
              document.body.classList.add('grade-' + grade);
            });
          },
          device: function() {
            return window.device || {};
          },
          _checkPlatforms: function() {
            self.platforms = [];
            var grade = 'a';
            if (self.isWebView()) {
              self.platforms.push('webview');
              if (!(!window.cordova && !window.PhoneGap && !window.phonegap)) {
                self.platforms.push('cordova');
              } else if (window.forge) {
                self.platforms.push('trigger');
              }
            } else {
              self.platforms.push('browser');
            }
            if (self.isIPad())
              self.platforms.push('ipad');
            var platform = self.platform();
            if (platform) {
              self.platforms.push(platform);
              var version = self.version();
              if (version) {
                var v = version.toString();
                if (v.indexOf('.') > 0) {
                  v = v.replace('.', '_');
                } else {
                  v += '_0';
                }
                self.platforms.push(platform + v.split('_')[0]);
                self.platforms.push(platform + v);
                if (self.isAndroid() && version < 4.4) {
                  grade = (version < 4 ? 'c' : 'b');
                } else if (self.isWindowsPhone()) {
                  grade = 'b';
                }
              }
            }
            self.setGrade(grade);
          },
          isWebView: function() {
            return !(!window.cordova && !window.PhoneGap && !window.phonegap && !window.forge);
          },
          isIPad: function() {
            if (/iPad/i.test(self.navigator.platform)) {
              return true;
            }
            return /iPad/i.test(self.ua);
          },
          isIOS: function() {
            return self.is(IOS);
          },
          isAndroid: function() {
            return self.is(ANDROID);
          },
          isWindowsPhone: function() {
            return self.is(WINDOWS_PHONE);
          },
          platform: function() {
            if (platformName === null)
              self.setPlatform(self.device().platform);
            return platformName;
          },
          setPlatform: function(n) {
            if (typeof n != 'undefined' && n !== null && n.length) {
              platformName = n.toLowerCase();
            } else if (getParameterByName('ionicplatform')) {
              platformName = getParameterByName('ionicplatform');
            } else if (self.ua.indexOf('Android') > 0) {
              platformName = ANDROID;
            } else if (/iPhone|iPad|iPod/.test(self.ua)) {
              platformName = IOS;
            } else if (self.ua.indexOf('Windows Phone') > -1) {
              platformName = WINDOWS_PHONE;
            } else {
              platformName = self.navigator.platform && navigator.platform.toLowerCase().split(' ')[0] || '';
            }
          },
          version: function() {
            if (platformVersion === null)
              self.setVersion(self.device().version);
            return platformVersion;
          },
          setVersion: function(v) {
            if (typeof v != 'undefined' && v !== null) {
              v = v.split('.');
              v = parseFloat(v[0] + '.' + (v.length > 1 ? v[1] : 0));
              if (!isNaN(v)) {
                platformVersion = v;
                return;
              }
            }
            platformVersion = 0;
            var pName = self.platform();
            var versionMatch = {
              'android': /Android (\d+).(\d+)?/,
              'ios': /OS (\d+)_(\d+)?/,
              'windowsphone': /Windows Phone (\d+).(\d+)?/
            };
            if (versionMatch[pName]) {
              v = self.ua.match(versionMatch[pName]);
              if (v && v.length > 2) {
                platformVersion = parseFloat(v[1] + '.' + v[2]);
              }
            }
          },
          is: function(type) {
            type = type.toLowerCase();
            if (self.platforms) {
              for (var x = 0; x < self.platforms.length; x++) {
                if (self.platforms[x] === type)
                  return true;
              }
            }
            var pName = self.platform();
            if (pName) {
              return pName === type.toLowerCase();
            }
            return self.ua.toLowerCase().indexOf(type) >= 0;
          },
          exitApp: function() {
            self.ready(function() {
              navigator.app && navigator.app.exitApp && navigator.app.exitApp();
            });
          },
          showStatusBar: function(val) {
            self._showStatusBar = val;
            self.ready(function() {
              requestAnimationFrame(function() {
                if (self._showStatusBar) {
                  window.StatusBar && window.StatusBar.show();
                  document.body.classList.remove('status-bar-hide');
                } else {
                  window.StatusBar && window.StatusBar.hide();
                  document.body.classList.add('status-bar-hide');
                }
              });
            });
          },
          fullScreen: function(showFullScreen, showStatusBar) {
            self.isFullScreen = (showFullScreen !== false);
            ionic.DomUtil.ready(function() {
              requestAnimationFrame(function() {
                if (self.isFullScreen) {
                  document.body.classList.add('fullscreen');
                } else {
                  document.body.classList.remove('fullscreen');
                }
              });
              self.showStatusBar((showStatusBar === true));
            });
          }
        };
        var platformName = null,
            platformVersion = null,
            readyCallbacks = [],
            windowLoadListenderAttached;
        function onWindowLoad() {
          if (self.isWebView()) {
            document.addEventListener("deviceready", onPlatformReady, false);
          } else {
            onPlatformReady();
          }
          if (windowLoadListenderAttached) {
            window.removeEventListener("load", onWindowLoad, false);
          }
        }
        if (document.readyState === 'complete') {
          onWindowLoad();
        } else {
          windowLoadListenderAttached = true;
          window.addEventListener("load", onWindowLoad, false);
        }
        function onPlatformReady() {
          self.isReady = true;
          self.detect();
          for (var x = 0; x < readyCallbacks.length; x++) {
            readyCallbacks[x]();
          }
          readyCallbacks = [];
          ionic.trigger('platformready', {target: document});
          requestAnimationFrame(function() {
            document.body.classList.add('platform-ready');
          });
        }
      })(this, document, ionic);
      (function(document, ionic) {
        'use strict';
        ionic.CSS = {};
        (function() {
          var i,
              keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
          for (i = 0; i < keys.length; i++) {
            if (document.documentElement.style[keys[i]] !== undefined) {
              ionic.CSS.TRANSFORM = keys[i];
              break;
            }
          }
          keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
          for (i = 0; i < keys.length; i++) {
            if (document.documentElement.style[keys[i]] !== undefined) {
              ionic.CSS.TRANSITION = keys[i];
              break;
            }
          }
          var isWebkit = ionic.CSS.TRANSITION.indexOf('webkit') > -1;
          ionic.CSS.TRANSITION_DURATION = (isWebkit ? '-webkit-' : '') + 'transition-duration';
          ionic.CSS.TRANSITIONEND = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
        })();
        if (!("classList" in document.documentElement) && Object.defineProperty && typeof HTMLElement !== 'undefined') {
          Object.defineProperty(HTMLElement.prototype, 'classList', {get: function() {
              var self = this;
              function update(fn) {
                return function() {
                  var x,
                      classes = self.className.split(/\s+/);
                  for (x = 0; x < arguments.length; x++) {
                    fn(classes, classes.indexOf(arguments[x]), arguments[x]);
                  }
                  self.className = classes.join(" ");
                };
              }
              return {
                add: update(function(classes, index, value) {
                  ~index || classes.push(value);
                }),
                remove: update(function(classes, index) {
                  ~index && classes.splice(index, 1);
                }),
                toggle: update(function(classes, index, value) {
                  ~index ? classes.splice(index, 1) : classes.push(value);
                }),
                contains: function(value) {
                  return !!~self.className.split(/\s+/).indexOf(value);
                },
                item: function(i) {
                  return self.className.split(/\s+/)[i] || null;
                }
              };
            }});
        }
      })(document, ionic);
      var tapDoc;
      var tapActiveEle;
      var tapEnabledTouchEvents;
      var tapMouseResetTimer;
      var tapPointerMoved;
      var tapPointerStart;
      var tapTouchFocusedInput;
      var tapLastTouchTarget;
      var tapTouchMoveListener = 'touchmove';
      var TAP_RELEASE_TOLERANCE = 12;
      var TAP_RELEASE_BUTTON_TOLERANCE = 50;
      var tapEventListeners = {
        'click': tapClickGateKeeper,
        'mousedown': tapMouseDown,
        'mouseup': tapMouseUp,
        'mousemove': tapMouseMove,
        'touchstart': tapTouchStart,
        'touchend': tapTouchEnd,
        'touchcancel': tapTouchCancel,
        'touchmove': tapTouchMove,
        'pointerdown': tapTouchStart,
        'pointerup': tapTouchEnd,
        'pointercancel': tapTouchCancel,
        'pointermove': tapTouchMove,
        'MSPointerDown': tapTouchStart,
        'MSPointerUp': tapTouchEnd,
        'MSPointerCancel': tapTouchCancel,
        'MSPointerMove': tapTouchMove,
        'focusin': tapFocusIn,
        'focusout': tapFocusOut
      };
      ionic.tap = {
        register: function(ele) {
          tapDoc = ele;
          tapEventListener('click', true, true);
          tapEventListener('mouseup');
          tapEventListener('mousedown');
          if (window.navigator.pointerEnabled) {
            tapEventListener('pointerdown');
            tapEventListener('pointerup');
            tapEventListener('pointcancel');
            tapTouchMoveListener = 'pointermove';
          } else if (window.navigator.msPointerEnabled) {
            tapEventListener('MSPointerDown');
            tapEventListener('MSPointerUp');
            tapEventListener('MSPointerCancel');
            tapTouchMoveListener = 'MSPointerMove';
          } else {
            tapEventListener('touchstart');
            tapEventListener('touchend');
            tapEventListener('touchcancel');
          }
          tapEventListener('focusin');
          tapEventListener('focusout');
          return function() {
            for (var type in tapEventListeners) {
              tapEventListener(type, false);
            }
            tapDoc = null;
            tapActiveEle = null;
            tapEnabledTouchEvents = false;
            tapPointerMoved = false;
            tapPointerStart = null;
          };
        },
        ignoreScrollStart: function(e) {
          return (e.defaultPrevented) || (/^(file|range)$/i).test(e.target.type) || (e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll')) == 'true' || (!!(/^(object|embed)$/i).test(e.target.tagName)) || ionic.tap.isElementTapDisabled(e.target);
        },
        isTextInput: function(ele) {
          return !!ele && (ele.tagName == 'TEXTAREA' || ele.contentEditable === 'true' || (ele.tagName == 'INPUT' && !(/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i).test(ele.type)));
        },
        isDateInput: function(ele) {
          return !!ele && (ele.tagName == 'INPUT' && (/^(date|time|datetime-local|month|week)$/i).test(ele.type));
        },
        isKeyboardElement: function(ele) {
          if (!ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
            return ionic.tap.isTextInput(ele) && !ionic.tap.isDateInput(ele);
          } else {
            return ionic.tap.isTextInput(ele) || (!!ele && ele.tagName == "SELECT");
          }
        },
        isLabelWithTextInput: function(ele) {
          var container = tapContainingElement(ele, false);
          return !!container && ionic.tap.isTextInput(tapTargetElement(container));
        },
        containsOrIsTextInput: function(ele) {
          return ionic.tap.isTextInput(ele) || ionic.tap.isLabelWithTextInput(ele);
        },
        cloneFocusedInput: function(container) {
          if (ionic.tap.hasCheckedClone)
            return;
          ionic.tap.hasCheckedClone = true;
          ionic.requestAnimationFrame(function() {
            var focusInput = container.querySelector(':focus');
            if (ionic.tap.isTextInput(focusInput) && !ionic.tap.isDateInput(focusInput)) {
              var clonedInput = focusInput.cloneNode(true);
              clonedInput.value = focusInput.value;
              clonedInput.classList.add('cloned-text-input');
              clonedInput.readOnly = true;
              if (focusInput.isContentEditable) {
                clonedInput.contentEditable = focusInput.contentEditable;
                clonedInput.innerHTML = focusInput.innerHTML;
              }
              focusInput.parentElement.insertBefore(clonedInput, focusInput);
              focusInput.classList.add('previous-input-focus');
              clonedInput.scrollTop = focusInput.scrollTop;
            }
          });
        },
        hasCheckedClone: false,
        removeClonedInputs: function(container) {
          ionic.tap.hasCheckedClone = false;
          ionic.requestAnimationFrame(function() {
            var clonedInputs = container.querySelectorAll('.cloned-text-input');
            var previousInputFocus = container.querySelectorAll('.previous-input-focus');
            var x;
            for (x = 0; x < clonedInputs.length; x++) {
              clonedInputs[x].parentElement.removeChild(clonedInputs[x]);
            }
            for (x = 0; x < previousInputFocus.length; x++) {
              previousInputFocus[x].classList.remove('previous-input-focus');
              previousInputFocus[x].style.top = '';
              if (ionic.keyboard.isOpen && !ionic.keyboard.isClosing)
                previousInputFocus[x].focus();
            }
          });
        },
        requiresNativeClick: function(ele) {
          if (!ele || ele.disabled || (/^(file|range)$/i).test(ele.type) || (/^(object|video)$/i).test(ele.tagName) || ionic.tap.isLabelContainingFileInput(ele)) {
            return true;
          }
          return ionic.tap.isElementTapDisabled(ele);
        },
        isLabelContainingFileInput: function(ele) {
          var lbl = tapContainingElement(ele);
          if (lbl.tagName !== 'LABEL')
            return false;
          var fileInput = lbl.querySelector('input[type=file]');
          if (fileInput && fileInput.disabled === false)
            return true;
          return false;
        },
        isElementTapDisabled: function(ele) {
          if (ele && ele.nodeType === 1) {
            var element = ele;
            while (element) {
              if ((element.dataset ? element.dataset.tapDisabled : element.getAttribute('data-tap-disabled')) == 'true') {
                return true;
              }
              element = element.parentElement;
            }
          }
          return false;
        },
        setTolerance: function(releaseTolerance, releaseButtonTolerance) {
          TAP_RELEASE_TOLERANCE = releaseTolerance;
          TAP_RELEASE_BUTTON_TOLERANCE = releaseButtonTolerance;
        },
        cancelClick: function() {
          tapPointerMoved = true;
        },
        pointerCoord: function(event) {
          var c = {
            x: 0,
            y: 0
          };
          if (event) {
            var touches = event.touches && event.touches.length ? event.touches : [event];
            var e = (event.changedTouches && event.changedTouches[0]) || touches[0];
            if (e) {
              c.x = e.clientX || e.pageX || 0;
              c.y = e.clientY || e.pageY || 0;
            }
          }
          return c;
        }
      };
      function tapEventListener(type, enable, useCapture) {
        if (enable !== false) {
          tapDoc.addEventListener(type, tapEventListeners[type], useCapture);
        } else {
          tapDoc.removeEventListener(type, tapEventListeners[type]);
        }
      }
      function tapClick(e) {
        var container = tapContainingElement(e.target);
        var ele = tapTargetElement(container);
        if (ionic.tap.requiresNativeClick(ele) || tapPointerMoved)
          return false;
        var c = ionic.tap.pointerCoord(e);
        triggerMouseEvent('click', ele, c.x, c.y);
        tapHandleFocus(ele);
      }
      function triggerMouseEvent(type, ele, x, y) {
        var clickEvent = document.createEvent("MouseEvents");
        clickEvent.initMouseEvent(type, true, true, window, 1, 0, 0, x, y, false, false, false, false, 0, null);
        clickEvent.isIonicTap = true;
        ele.dispatchEvent(clickEvent);
      }
      function tapClickGateKeeper(e) {
        if (e.target.type == 'submit' && e.detail === 0) {
          return null;
        }
        if ((ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) || (!e.isIonicTap && !ionic.tap.requiresNativeClick(e.target))) {
          e.stopPropagation();
          if (!ionic.tap.isLabelWithTextInput(e.target)) {
            e.preventDefault();
          }
          return false;
        }
      }
      function tapMouseDown(e) {
        if (e.isIonicTap || tapIgnoreEvent(e))
          return null;
        if (tapEnabledTouchEvents) {
          void 0;
          e.stopPropagation();
          if ((!ionic.tap.isTextInput(e.target) || tapLastTouchTarget !== e.target) && !(/^(select|option)$/i).test(e.target.tagName)) {
            e.preventDefault();
          }
          return false;
        }
        tapPointerMoved = false;
        tapPointerStart = ionic.tap.pointerCoord(e);
        tapEventListener('mousemove');
        ionic.activator.start(e);
      }
      function tapMouseUp(e) {
        if (tapEnabledTouchEvents) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        if (tapIgnoreEvent(e) || (/^(select|option)$/i).test(e.target.tagName))
          return false;
        if (!tapHasPointerMoved(e)) {
          tapClick(e);
        }
        tapEventListener('mousemove', false);
        ionic.activator.end();
        tapPointerMoved = false;
      }
      function tapMouseMove(e) {
        if (tapHasPointerMoved(e)) {
          tapEventListener('mousemove', false);
          ionic.activator.end();
          tapPointerMoved = true;
          return false;
        }
      }
      function tapTouchStart(e) {
        if (tapIgnoreEvent(e))
          return;
        tapPointerMoved = false;
        tapEnableTouchEvents();
        tapPointerStart = ionic.tap.pointerCoord(e);
        tapEventListener(tapTouchMoveListener);
        ionic.activator.start(e);
        if (ionic.Platform.isIOS() && ionic.tap.isLabelWithTextInput(e.target)) {
          var textInput = tapTargetElement(tapContainingElement(e.target));
          if (textInput !== tapActiveEle) {
            e.preventDefault();
          }
        }
      }
      function tapTouchEnd(e) {
        if (tapIgnoreEvent(e))
          return;
        tapEnableTouchEvents();
        if (!tapHasPointerMoved(e)) {
          tapClick(e);
          if ((/^(select|option)$/i).test(e.target.tagName)) {
            e.preventDefault();
          }
        }
        tapLastTouchTarget = e.target;
        tapTouchCancel();
      }
      function tapTouchMove(e) {
        if (tapHasPointerMoved(e)) {
          tapPointerMoved = true;
          tapEventListener(tapTouchMoveListener, false);
          ionic.activator.end();
          return false;
        }
      }
      function tapTouchCancel() {
        tapEventListener(tapTouchMoveListener, false);
        ionic.activator.end();
        tapPointerMoved = false;
      }
      function tapEnableTouchEvents() {
        tapEnabledTouchEvents = true;
        clearTimeout(tapMouseResetTimer);
        tapMouseResetTimer = setTimeout(function() {
          tapEnabledTouchEvents = false;
        }, 600);
      }
      function tapIgnoreEvent(e) {
        if (e.isTapHandled)
          return true;
        e.isTapHandled = true;
        if (ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) {
          e.preventDefault();
          return true;
        }
      }
      function tapHandleFocus(ele) {
        tapTouchFocusedInput = null;
        var triggerFocusIn = false;
        if (ele.tagName == 'SELECT') {
          triggerMouseEvent('mousedown', ele, 0, 0);
          ele.focus && ele.focus();
          triggerFocusIn = true;
        } else if (tapActiveElement() === ele) {
          triggerFocusIn = true;
        } else if ((/^(input|textarea)$/i).test(ele.tagName) || ele.isContentEditable) {
          triggerFocusIn = true;
          ele.focus && ele.focus();
          ele.value = ele.value;
          if (tapEnabledTouchEvents) {
            tapTouchFocusedInput = ele;
          }
        } else {
          tapFocusOutActive();
        }
        if (triggerFocusIn) {
          tapActiveElement(ele);
          ionic.trigger('ionic.focusin', {target: ele}, true);
        }
      }
      function tapFocusOutActive() {
        var ele = tapActiveElement();
        if (ele && ((/^(input|textarea|select)$/i).test(ele.tagName) || ele.isContentEditable)) {
          void 0;
          ele.blur();
        }
        tapActiveElement(null);
      }
      function tapFocusIn(e) {
        if (tapEnabledTouchEvents && ionic.tap.isTextInput(tapActiveElement()) && ionic.tap.isTextInput(tapTouchFocusedInput) && tapTouchFocusedInput !== e.target) {
          void 0;
          tapTouchFocusedInput.focus();
          tapTouchFocusedInput = null;
        }
        ionic.scroll.isScrolling = false;
      }
      function tapFocusOut() {
        tapActiveElement(null);
      }
      function tapActiveElement(ele) {
        if (arguments.length) {
          tapActiveEle = ele;
        }
        return tapActiveEle || document.activeElement;
      }
      function tapHasPointerMoved(endEvent) {
        if (!endEvent || endEvent.target.nodeType !== 1 || !tapPointerStart || (tapPointerStart.x === 0 && tapPointerStart.y === 0)) {
          return false;
        }
        var endCoordinates = ionic.tap.pointerCoord(endEvent);
        var hasClassList = !!(endEvent.target.classList && endEvent.target.classList.contains && typeof endEvent.target.classList.contains === 'function');
        var releaseTolerance = hasClassList && endEvent.target.classList.contains('button') ? TAP_RELEASE_BUTTON_TOLERANCE : TAP_RELEASE_TOLERANCE;
        return Math.abs(tapPointerStart.x - endCoordinates.x) > releaseTolerance || Math.abs(tapPointerStart.y - endCoordinates.y) > releaseTolerance;
      }
      function tapContainingElement(ele, allowSelf) {
        var climbEle = ele;
        for (var x = 0; x < 6; x++) {
          if (!climbEle)
            break;
          if (climbEle.tagName === 'LABEL')
            return climbEle;
          climbEle = climbEle.parentElement;
        }
        if (allowSelf !== false)
          return ele;
      }
      function tapTargetElement(ele) {
        if (ele && ele.tagName === 'LABEL') {
          if (ele.control)
            return ele.control;
          if (ele.querySelector) {
            var control = ele.querySelector('input,textarea,select');
            if (control)
              return control;
          }
        }
        return ele;
      }
      ionic.DomUtil.ready(function() {
        var ng = typeof angular !== 'undefined' ? angular : null;
        if (!ng || (ng && !ng.scenario)) {
          ionic.tap.register(document);
        }
      });
      (function(document, ionic) {
        'use strict';
        var queueElements = {};
        var activeElements = {};
        var keyId = 0;
        var ACTIVATED_CLASS = 'activated';
        ionic.activator = {
          start: function(e) {
            var hitX = ionic.tap.pointerCoord(e).x;
            if (hitX > 0 && hitX < 30) {
              return;
            }
            ionic.requestAnimationFrame(function() {
              if ((ionic.scroll && ionic.scroll.isScrolling) || ionic.tap.requiresNativeClick(e.target))
                return;
              var ele = e.target;
              var eleToActivate;
              for (var x = 0; x < 6; x++) {
                if (!ele || ele.nodeType !== 1)
                  break;
                if (eleToActivate && ele.classList && ele.classList.contains('item')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.tagName == 'A' || ele.tagName == 'BUTTON' || ele.hasAttribute('ng-click')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.classList.contains('button')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.tagName == 'ION-CONTENT' || (ele.classList && ele.classList.contains('pane')) || ele.tagName == 'BODY') {
                  break;
                }
                ele = ele.parentElement;
              }
              if (eleToActivate) {
                queueElements[keyId] = eleToActivate;
                ionic.requestAnimationFrame(activateElements);
                keyId = (keyId > 29 ? 0 : keyId + 1);
              }
            });
          },
          end: function() {
            setTimeout(clear, 200);
          }
        };
        function clear() {
          queueElements = {};
          ionic.requestAnimationFrame(deactivateElements);
        }
        function activateElements() {
          for (var key in queueElements) {
            if (queueElements[key]) {
              queueElements[key].classList.add(ACTIVATED_CLASS);
              activeElements[key] = queueElements[key];
            }
          }
          queueElements = {};
        }
        function deactivateElements() {
          if (ionic.transition && ionic.transition.isActive) {
            setTimeout(deactivateElements, 400);
            return;
          }
          for (var key in activeElements) {
            if (activeElements[key]) {
              activeElements[key].classList.remove(ACTIVATED_CLASS);
              delete activeElements[key];
            }
          }
        }
      })(document, ionic);
      (function(ionic) {
        var nextId = 0;
        ionic.Utils = {
          arrayMove: function(arr, oldIndex, newIndex) {
            if (newIndex >= arr.length) {
              var k = newIndex - arr.length;
              while ((k--) + 1) {
                arr.push(undefined);
              }
            }
            arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
            return arr;
          },
          proxy: function(func, context) {
            var args = Array.prototype.slice.call(arguments, 2);
            return function() {
              return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));
            };
          },
          debounce: function(func, wait, immediate) {
            var timeout,
                args,
                context,
                timestamp,
                result;
            return function() {
              context = this;
              args = arguments;
              timestamp = new Date();
              var later = function() {
                var last = (new Date()) - timestamp;
                if (last < wait) {
                  timeout = setTimeout(later, wait - last);
                } else {
                  timeout = null;
                  if (!immediate)
                    result = func.apply(context, args);
                }
              };
              var callNow = immediate && !timeout;
              if (!timeout) {
                timeout = setTimeout(later, wait);
              }
              if (callNow)
                result = func.apply(context, args);
              return result;
            };
          },
          throttle: function(func, wait, options) {
            var context,
                args,
                result;
            var timeout = null;
            var previous = 0;
            options || (options = {});
            var later = function() {
              previous = options.leading === false ? 0 : Date.now();
              timeout = null;
              result = func.apply(context, args);
            };
            return function() {
              var now = Date.now();
              if (!previous && options.leading === false)
                previous = now;
              var remaining = wait - (now - previous);
              context = this;
              args = arguments;
              if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
              } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
              }
              return result;
            };
          },
          inherit: function(protoProps, staticProps) {
            var parent = this;
            var child;
            if (protoProps && protoProps.hasOwnProperty('constructor')) {
              child = protoProps.constructor;
            } else {
              child = function() {
                return parent.apply(this, arguments);
              };
            }
            ionic.extend(child, parent, staticProps);
            var Surrogate = function() {
              this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            if (protoProps)
              ionic.extend(child.prototype, protoProps);
            child.__super__ = parent.prototype;
            return child;
          },
          extend: function(obj) {
            var args = Array.prototype.slice.call(arguments, 1);
            for (var i = 0; i < args.length; i++) {
              var source = args[i];
              if (source) {
                for (var prop in source) {
                  obj[prop] = source[prop];
                }
              }
            }
            return obj;
          },
          nextUid: function() {
            return 'ion' + (nextId++);
          },
          disconnectScope: function disconnectScope(scope) {
            if (!scope)
              return;
            if (scope.$root === scope) {
              return;
            }
            var parent = scope.$parent;
            scope.$$disconnected = true;
            scope.$broadcast('$ionic.disconnectScope', scope);
            if (parent.$$childHead === scope) {
              parent.$$childHead = scope.$$nextSibling;
            }
            if (parent.$$childTail === scope) {
              parent.$$childTail = scope.$$prevSibling;
            }
            if (scope.$$prevSibling) {
              scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
            }
            if (scope.$$nextSibling) {
              scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
            }
            scope.$$nextSibling = scope.$$prevSibling = null;
          },
          reconnectScope: function reconnectScope(scope) {
            if (!scope)
              return;
            if (scope.$root === scope) {
              return;
            }
            if (!scope.$$disconnected) {
              return;
            }
            var parent = scope.$parent;
            scope.$$disconnected = false;
            scope.$broadcast('$ionic.reconnectScope', scope);
            scope.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = scope;
              parent.$$childTail = scope;
            } else {
              parent.$$childHead = parent.$$childTail = scope;
            }
          },
          isScopeDisconnected: function(scope) {
            var climbScope = scope;
            while (climbScope) {
              if (climbScope.$$disconnected)
                return true;
              climbScope = climbScope.$parent;
            }
            return false;
          }
        };
        ionic.inherit = ionic.Utils.inherit;
        ionic.extend = ionic.Utils.extend;
        ionic.throttle = ionic.Utils.throttle;
        ionic.proxy = ionic.Utils.proxy;
        ionic.debounce = ionic.Utils.debounce;
      })(window.ionic);
      var keyboardCurrentViewportHeight = 0;
      var keyboardPortraitViewportHeight = 0;
      var keyboardLandscapeViewportHeight = 0;
      var keyboardActiveElement;
      var scrollView;
      var waitForResizeTimer;
      var keyboardFocusOutTimer;
      var wasOrientationChange = false;
      var KEYBOARD_OPEN_CSS = 'keyboard-open';
      var SCROLL_CONTAINER_CSS = 'scroll-content';
      var debouncedKeyboardFocusIn = ionic.debounce(keyboardFocusIn, 200, true);
      var debouncedKeyboardNativeShow = ionic.debounce(keyboardNativeShow, 100, true);
      ionic.keyboard = {
        isOpen: false,
        isClosing: false,
        isOpening: false,
        height: 0,
        isLandscape: false,
        isInitialized: false,
        hide: function() {
          if (keyboardHasPlugin()) {
            cordova.plugins.Keyboard.close();
          }
          keyboardActiveElement && keyboardActiveElement.blur();
        },
        show: function() {
          if (keyboardHasPlugin()) {
            cordova.plugins.Keyboard.show();
          }
        },
        disable: function() {
          if (keyboardHasPlugin()) {
            window.removeEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
            window.removeEventListener('native.keyboardhide', keyboardFocusOut);
          } else {
            document.body.removeEventListener('focusout', keyboardFocusOut);
          }
          document.body.removeEventListener('ionic.focusin', debouncedKeyboardFocusIn);
          document.body.removeEventListener('focusin', debouncedKeyboardFocusIn);
          window.removeEventListener('orientationchange', keyboardOrientationChange);
          if (window.navigator.msPointerEnabled) {
            document.removeEventListener("MSPointerDown", keyboardInit);
          } else {
            document.removeEventListener('touchstart', keyboardInit);
          }
          ionic.keyboard.isInitialized = false;
        },
        enable: function() {
          keyboardInit();
        }
      };
      keyboardCurrentViewportHeight = getViewportHeight();
      function keyboardInit() {
        if (ionic.keyboard.isInitialized)
          return;
        if (keyboardHasPlugin()) {
          window.addEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
          window.addEventListener('native.keyboardhide', keyboardFocusOut);
        } else {
          document.body.addEventListener('focusout', keyboardFocusOut);
        }
        document.body.addEventListener('ionic.focusin', debouncedKeyboardFocusIn);
        document.body.addEventListener('focusin', debouncedKeyboardFocusIn);
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerDown", keyboardInit);
        } else {
          document.removeEventListener('touchstart', keyboardInit);
        }
        ionic.keyboard.isInitialized = true;
      }
      function keyboardNativeShow(e) {
        clearTimeout(keyboardFocusOutTimer);
        if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
          ionic.keyboard.isOpening = true;
          ionic.keyboard.isClosing = false;
        }
        ionic.keyboard.height = e.keyboardHeight;
        if (wasOrientationChange) {
          keyboardWaitForResize(keyboardUpdateViewportHeight, true);
        } else {
          keyboardWaitForResize(keyboardShow, true);
        }
      }
      function keyboardFocusIn(e) {
        clearTimeout(keyboardFocusOutTimer);
        if (!e.target || e.target.readOnly || !ionic.tap.isKeyboardElement(e.target) || !(scrollView = ionic.DomUtil.getParentWithClass(e.target, SCROLL_CONTAINER_CSS))) {
          keyboardActiveElement = null;
          return;
        }
        keyboardActiveElement = e.target;
        if (!scrollView.classList.contains("overflow-scroll")) {
          document.body.scrollTop = 0;
          scrollView.scrollTop = 0;
          ionic.requestAnimationFrame(function() {
            document.body.scrollTop = 0;
            scrollView.scrollTop = 0;
          });
          if (window.navigator.msPointerEnabled) {
            document.addEventListener("MSPointerMove", keyboardPreventDefault, false);
          } else {
            document.addEventListener('touchmove', keyboardPreventDefault, false);
          }
        }
        if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
          ionic.keyboard.isOpening = true;
          ionic.keyboard.isClosing = false;
        }
        document.addEventListener('keydown', keyboardOnKeyDown, false);
        if (!ionic.keyboard.isOpen && !keyboardHasPlugin()) {
          keyboardWaitForResize(keyboardShow, true);
        } else if (ionic.keyboard.isOpen) {
          keyboardShow();
        }
      }
      function keyboardFocusOut() {
        clearTimeout(keyboardFocusOutTimer);
        if (ionic.keyboard.isOpen || ionic.keyboard.isOpening) {
          ionic.keyboard.isClosing = true;
          ionic.keyboard.isOpening = false;
        }
        keyboardFocusOutTimer = setTimeout(function() {
          ionic.requestAnimationFrame(function() {
            if (wasOrientationChange) {
              keyboardWaitForResize(function() {
                keyboardUpdateViewportHeight();
                keyboardHide();
              }, false);
            } else {
              keyboardWaitForResize(keyboardHide, false);
            }
          });
        }, 50);
      }
      function keyboardOrientationChange() {
        ionic.keyboard.isLandscape = !ionic.keyboard.isLandscape;
        if (ionic.Platform.isIOS()) {
          keyboardUpdateViewportHeight();
        }
        if (ionic.Platform.isAndroid()) {
          if (!ionic.keyboard.isOpen || !keyboardHasPlugin()) {
            keyboardWaitForResize(keyboardUpdateViewportHeight, false);
          } else {
            wasOrientationChange = true;
          }
        }
      }
      function keyboardOnKeyDown(e) {
        if (ionic.scroll.isScrolling) {
          keyboardPreventDefault(e);
        }
      }
      function keyboardPreventDefault(e) {
        if (e.target.tagName !== 'TEXTAREA') {
          e.preventDefault();
        }
      }
      function keyboardWaitForResize(callback, isOpening) {
        clearInterval(waitForResizeTimer);
        var count = 0;
        var maxCount;
        var initialHeight = getViewportHeight();
        var viewportHeight = initialHeight;
        if (ionic.Platform.isAndroid() && ionic.Platform.version() < 4.4) {
          maxCount = 30;
        } else if (ionic.Platform.isAndroid()) {
          maxCount = 10;
        } else {
          maxCount = 1;
        }
        waitForResizeTimer = setInterval(function() {
          viewportHeight = getViewportHeight();
          if (++count < maxCount && ((!isPortraitViewportHeight(viewportHeight) && !isLandscapeViewportHeight(viewportHeight)) || !ionic.keyboard.height)) {
            return;
          }
          if (!keyboardHasPlugin()) {
            ionic.keyboard.height = Math.abs(initialHeight - window.innerHeight);
          }
          ionic.keyboard.isOpen = isOpening;
          clearInterval(waitForResizeTimer);
          callback();
        }, 50);
        return maxCount;
      }
      function keyboardHide() {
        clearTimeout(keyboardFocusOutTimer);
        ionic.keyboard.isOpen = false;
        ionic.keyboard.isClosing = false;
        if (keyboardActiveElement) {
          ionic.trigger('resetScrollView', {target: keyboardActiveElement}, true);
        }
        ionic.requestAnimationFrame(function() {
          document.body.classList.remove(KEYBOARD_OPEN_CSS);
        });
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerMove", keyboardPreventDefault);
        } else {
          document.removeEventListener('touchmove', keyboardPreventDefault);
        }
        document.removeEventListener('keydown', keyboardOnKeyDown);
        if (ionic.Platform.isAndroid()) {
          if (keyboardHasPlugin())
            cordova.plugins.Keyboard.close();
          keyboardActiveElement && keyboardActiveElement.blur();
        }
        keyboardActiveElement = null;
      }
      function keyboardShow() {
        ionic.keyboard.isOpen = true;
        ionic.keyboard.isOpening = false;
        var details = {
          keyboardHeight: keyboardGetHeight(),
          viewportHeight: keyboardCurrentViewportHeight
        };
        if (keyboardActiveElement) {
          details.target = keyboardActiveElement;
          var elementBounds = keyboardActiveElement.getBoundingClientRect();
          details.elementTop = Math.round(elementBounds.top);
          details.elementBottom = Math.round(elementBounds.bottom);
          details.windowHeight = details.viewportHeight - details.keyboardHeight;
          details.isElementUnderKeyboard = (details.elementBottom > details.windowHeight);
          ionic.trigger('scrollChildIntoView', details, true);
        }
        setTimeout(function() {
          document.body.classList.add(KEYBOARD_OPEN_CSS);
        }, 400);
        return details;
      }
      function keyboardGetHeight() {
        if (ionic.keyboard.height) {
          return ionic.keyboard.height;
        }
        if (ionic.Platform.isAndroid()) {
          if (ionic.Platform.isFullScreen) {
            return 275;
          }
          var contentHeight = window.innerHeight;
          if (contentHeight < keyboardCurrentViewportHeight) {
            return keyboardCurrentViewportHeight - contentHeight;
          } else {
            return 0;
          }
        }
        if (ionic.Platform.isIOS()) {
          if (ionic.keyboard.isLandscape) {
            return 206;
          }
          if (!ionic.Platform.isWebView()) {
            return 216;
          }
          return 260;
        }
        return 275;
      }
      function isPortraitViewportHeight(viewportHeight) {
        return !!(!ionic.keyboard.isLandscape && keyboardPortraitViewportHeight && (Math.abs(keyboardPortraitViewportHeight - viewportHeight) < 2));
      }
      function isLandscapeViewportHeight(viewportHeight) {
        return !!(ionic.keyboard.isLandscape && keyboardLandscapeViewportHeight && (Math.abs(keyboardLandscapeViewportHeight - viewportHeight) < 2));
      }
      function keyboardUpdateViewportHeight() {
        wasOrientationChange = false;
        keyboardCurrentViewportHeight = getViewportHeight();
        if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
          keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
        } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
          keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
        }
        if (keyboardActiveElement) {
          ionic.trigger('resetScrollView', {target: keyboardActiveElement}, true);
        }
        if (ionic.keyboard.isOpen && ionic.tap.isTextInput(keyboardActiveElement)) {
          keyboardShow();
        }
      }
      function keyboardInitViewportHeight() {
        var viewportHeight = getViewportHeight();
        if ((viewportHeight / window.innerWidth) < 1) {
          ionic.keyboard.isLandscape = true;
        }
        keyboardCurrentViewportHeight = viewportHeight;
        if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
          keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
        } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
          keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
        }
      }
      function getViewportHeight() {
        var windowHeight = window.innerHeight;
        if (!(ionic.Platform.isAndroid() && ionic.Platform.isFullScreen) && (ionic.keyboard.isOpen || ionic.keyboard.isOpening) && !ionic.keyboard.isClosing) {
          return windowHeight + keyboardGetHeight();
        }
        return windowHeight;
      }
      function keyboardHasPlugin() {
        return !!(window.cordova && cordova.plugins && cordova.plugins.Keyboard);
      }
      ionic.Platform.ready(function() {
        keyboardInitViewportHeight();
        window.addEventListener('orientationchange', keyboardOrientationChange);
        setTimeout(keyboardInitViewportHeight, 999);
        if (window.navigator.msPointerEnabled) {
          document.addEventListener("MSPointerDown", keyboardInit, false);
        } else {
          document.addEventListener('touchstart', keyboardInit, false);
        }
      });
      var viewportTag;
      var viewportProperties = {};
      ionic.viewport = {orientation: function() {
          return (window.innerWidth > window.innerHeight ? 90 : 0);
        }};
      function viewportLoadTag() {
        var x;
        for (x = 0; x < document.head.children.length; x++) {
          if (document.head.children[x].name == 'viewport') {
            viewportTag = document.head.children[x];
            break;
          }
        }
        if (viewportTag) {
          var props = viewportTag.content.toLowerCase().replace(/\s+/g, '').split(',');
          var keyValue;
          for (x = 0; x < props.length; x++) {
            if (props[x]) {
              keyValue = props[x].split('=');
              viewportProperties[keyValue[0]] = (keyValue.length > 1 ? keyValue[1] : '_');
            }
          }
          viewportUpdate();
        }
      }
      function viewportUpdate() {
        var initWidth = viewportProperties.width;
        var initHeight = viewportProperties.height;
        var p = ionic.Platform;
        var version = p.version();
        var DEVICE_WIDTH = 'device-width';
        var DEVICE_HEIGHT = 'device-height';
        var orientation = ionic.viewport.orientation();
        delete viewportProperties.height;
        viewportProperties.width = DEVICE_WIDTH;
        if (p.isIPad()) {
          if (version > 7) {
            delete viewportProperties.width;
          } else {
            if (p.isWebView()) {
              if (orientation == 90) {
                viewportProperties.height = '0';
              } else if (version == 7) {
                viewportProperties.height = DEVICE_HEIGHT;
              }
            } else {
              if (version < 7) {
                viewportProperties.height = '0';
              }
            }
          }
        } else if (p.isIOS()) {
          if (p.isWebView()) {
            if (version > 7) {
              delete viewportProperties.width;
            } else if (version < 7) {
              if (initHeight)
                viewportProperties.height = '0';
            } else if (version == 7) {
              viewportProperties.height = DEVICE_HEIGHT;
            }
          } else {
            if (version < 7) {
              if (initHeight)
                viewportProperties.height = '0';
            }
          }
        }
        if (initWidth !== viewportProperties.width || initHeight !== viewportProperties.height) {
          viewportTagUpdate();
        }
      }
      function viewportTagUpdate() {
        var key,
            props = [];
        for (key in viewportProperties) {
          if (viewportProperties[key]) {
            props.push(key + (viewportProperties[key] == '_' ? '' : '=' + viewportProperties[key]));
          }
        }
        viewportTag.content = props.join(', ');
      }
      ionic.Platform.ready(function() {
        viewportLoadTag();
        window.addEventListener("orientationchange", function() {
          setTimeout(viewportUpdate, 1000);
        }, false);
      });
      (function(ionic) {
        'use strict';
        ionic.views.View = function() {
          this.initialize.apply(this, arguments);
        };
        ionic.views.View.inherit = ionic.inherit;
        ionic.extend(ionic.views.View.prototype, {initialize: function() {}});
      })(window.ionic);
      var zyngaCore = {effect: {}};
      (function(global) {
        var time = Date.now || function() {
          return +new Date();
        };
        var desiredFrames = 60;
        var millisecondsPerSecond = 1000;
        var running = {};
        var counter = 1;
        zyngaCore.effect.Animate = {
          requestAnimationFrame: (function() {
            var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
            var isNative = !!requestFrame;
            if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
              isNative = false;
            }
            if (isNative) {
              return function(callback, root) {
                requestFrame(callback, root);
              };
            }
            var TARGET_FPS = 60;
            var requests = {};
            var requestCount = 0;
            var rafHandle = 1;
            var intervalHandle = null;
            var lastActive = +new Date();
            return function(callback) {
              var callbackHandle = rafHandle++;
              requests[callbackHandle] = callback;
              requestCount++;
              if (intervalHandle === null) {
                intervalHandle = setInterval(function() {
                  var time = +new Date();
                  var currentRequests = requests;
                  requests = {};
                  requestCount = 0;
                  for (var key in currentRequests) {
                    if (currentRequests.hasOwnProperty(key)) {
                      currentRequests[key](time);
                      lastActive = time;
                    }
                  }
                  if (time - lastActive > 2500) {
                    clearInterval(intervalHandle);
                    intervalHandle = null;
                  }
                }, 1000 / TARGET_FPS);
              }
              return callbackHandle;
            };
          })(),
          stop: function(id) {
            var cleared = running[id] != null;
            if (cleared) {
              running[id] = null;
            }
            return cleared;
          },
          isRunning: function(id) {
            return running[id] != null;
          },
          start: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
            var start = time();
            var lastFrame = start;
            var percent = 0;
            var dropCounter = 0;
            var id = counter++;
            if (!root) {
              root = document.body;
            }
            if (id % 20 === 0) {
              var newRunning = {};
              for (var usedId in running) {
                newRunning[usedId] = true;
              }
              running = newRunning;
            }
            var step = function(virtual) {
              var render = virtual !== true;
              var now = time();
              if (!running[id] || (verifyCallback && !verifyCallback(id))) {
                running[id] = null;
                completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);
                return;
              }
              if (render) {
                var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
                for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
                  step(true);
                  dropCounter++;
                }
              }
              if (duration) {
                percent = (now - start) / duration;
                if (percent > 1) {
                  percent = 1;
                }
              }
              var value = easingMethod ? easingMethod(percent) : percent;
              if ((stepCallback(value, now, render) === false || percent === 1) && render) {
                running[id] = null;
                completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);
              } else if (render) {
                lastFrame = now;
                zyngaCore.effect.Animate.requestAnimationFrame(step, root);
              }
            };
            running[id] = true;
            zyngaCore.effect.Animate.requestAnimationFrame(step, root);
            return id;
          }
        };
      })(this);
      (function(ionic) {
        var NOOP = function() {};
        var easeOutCubic = function(pos) {
          return (Math.pow((pos - 1), 3) + 1);
        };
        var easeInOutCubic = function(pos) {
          if ((pos /= 0.5) < 1) {
            return 0.5 * Math.pow(pos, 3);
          }
          return 0.5 * (Math.pow((pos - 2), 3) + 2);
        };
        ionic.views.Scroll = ionic.views.View.inherit({
          initialize: function(options) {
            var self = this;
            self.__container = options.el;
            self.__content = options.el.firstElementChild;
            setTimeout(function() {
              if (self.__container && self.__content) {
                self.__container.scrollTop = 0;
                self.__content.scrollTop = 0;
              }
            });
            self.options = {
              scrollingX: false,
              scrollbarX: true,
              scrollingY: true,
              scrollbarY: true,
              startX: 0,
              startY: 0,
              wheelDampen: 6,
              minScrollbarSizeX: 5,
              minScrollbarSizeY: 5,
              scrollbarsFade: true,
              scrollbarFadeDelay: 300,
              scrollbarResizeFadeDelay: 1000,
              animating: true,
              animationDuration: 250,
              decelVelocityThreshold: 4,
              decelVelocityThresholdPaging: 4,
              bouncing: true,
              locking: true,
              paging: false,
              snapping: false,
              zooming: false,
              minZoom: 0.5,
              maxZoom: 3,
              speedMultiplier: 1,
              deceleration: 0.97,
              preventDefault: false,
              scrollingComplete: NOOP,
              penetrationDeceleration: 0.03,
              penetrationAcceleration: 0.08,
              scrollEventInterval: 10,
              freeze: false,
              getContentWidth: function() {
                return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
              },
              getContentHeight: function() {
                return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
              }
            };
            for (var key in options) {
              self.options[key] = options[key];
            }
            self.hintResize = ionic.debounce(function() {
              self.resize();
            }, 1000, true);
            self.onScroll = function() {
              if (!ionic.scroll.isScrolling) {
                setTimeout(self.setScrollStart, 50);
              } else {
                clearTimeout(self.scrollTimer);
                self.scrollTimer = setTimeout(self.setScrollStop, 80);
              }
            };
            self.freeze = function(shouldFreeze) {
              if (arguments.length) {
                self.options.freeze = shouldFreeze;
              }
              return self.options.freeze;
            };
            self.setScrollStart = function() {
              ionic.scroll.isScrolling = Math.abs(ionic.scroll.lastTop - self.__scrollTop) > 1;
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(self.setScrollStop, 80);
            };
            self.setScrollStop = function() {
              ionic.scroll.isScrolling = false;
              ionic.scroll.lastTop = self.__scrollTop;
            };
            self.triggerScrollEvent = ionic.throttle(function() {
              self.onScroll();
              ionic.trigger('scroll', {
                scrollTop: self.__scrollTop,
                scrollLeft: self.__scrollLeft,
                target: self.__container
              });
            }, self.options.scrollEventInterval);
            self.triggerScrollEndEvent = function() {
              ionic.trigger('scrollend', {
                scrollTop: self.__scrollTop,
                scrollLeft: self.__scrollLeft,
                target: self.__container
              });
            };
            self.__scrollLeft = self.options.startX;
            self.__scrollTop = self.options.startY;
            self.__callback = self.getRenderFn();
            self.__initEventHandlers();
            self.__createScrollbars();
          },
          run: function() {
            this.resize();
            this.__fadeScrollbars('out', this.options.scrollbarResizeFadeDelay);
          },
          __isSingleTouch: false,
          __isTracking: false,
          __didDecelerationComplete: false,
          __isGesturing: false,
          __isDragging: false,
          __isDecelerating: false,
          __isAnimating: false,
          __clientLeft: 0,
          __clientTop: 0,
          __clientWidth: 0,
          __clientHeight: 0,
          __contentWidth: 0,
          __contentHeight: 0,
          __snapWidth: 100,
          __snapHeight: 100,
          __refreshHeight: null,
          __refreshActive: false,
          __refreshActivate: null,
          __refreshDeactivate: null,
          __refreshStart: null,
          __zoomLevel: 1,
          __scrollLeft: 0,
          __scrollTop: 0,
          __maxScrollLeft: 0,
          __maxScrollTop: 0,
          __scheduledLeft: 0,
          __scheduledTop: 0,
          __scheduledZoom: 0,
          __lastTouchLeft: null,
          __lastTouchTop: null,
          __lastTouchMove: null,
          __positions: null,
          __minDecelerationScrollLeft: null,
          __minDecelerationScrollTop: null,
          __maxDecelerationScrollLeft: null,
          __maxDecelerationScrollTop: null,
          __decelerationVelocityX: null,
          __decelerationVelocityY: null,
          __transformProperty: null,
          __perspectiveProperty: null,
          __indicatorX: null,
          __indicatorY: null,
          __scrollbarFadeTimeout: null,
          __didWaitForSize: null,
          __sizerTimeout: null,
          __initEventHandlers: function() {
            var self = this;
            var container = self.__container;
            var scrollViewOffsetHeight;
            self.scrollChildIntoView = function(e) {
              var scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
              scrollViewOffsetHeight = container.offsetHeight;
              var alreadyShrunk = self.isShrunkForKeyboard;
              var isModal = container.parentNode.classList.contains('modal');
              var isInsetModal = isModal && window.innerWidth >= 680;
              if (!alreadyShrunk) {
                if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) {
                  var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop;
                  var keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
                  ionic.requestAnimationFrame(function() {
                    scrollViewOffsetHeight = scrollViewOffsetHeight - keyboardOffset;
                    container.style.height = scrollViewOffsetHeight + "px";
                    container.style.overflow = "visible";
                    self.resize();
                  });
                }
                self.isShrunkForKeyboard = true;
              }
              if (e.detail.isElementUnderKeyboard) {
                ionic.requestAnimationFrame(function() {
                  container.scrollTop = 0;
                  if (self.isShrunkForKeyboard && !alreadyShrunk) {
                    scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
                  }
                  var scrollMidpointOffset = scrollViewOffsetHeight * 0.5;
                  var inputMidpoint = ((e.detail.elementBottom + e.detail.elementTop) / 2);
                  var inputMidpointOffsetToScrollBottom = inputMidpoint - scrollBottomOffsetToTop;
                  var scrollTop = inputMidpointOffsetToScrollBottom + scrollMidpointOffset;
                  if (scrollTop > 0) {
                    if (ionic.Platform.isIOS())
                      ionic.tap.cloneFocusedInput(container, self);
                    self.scrollBy(0, scrollTop, true);
                    self.onScroll();
                  }
                });
              }
              e.stopPropagation();
            };
            self.resetScrollView = function() {
              if (self.isShrunkForKeyboard) {
                self.isShrunkForKeyboard = false;
                container.style.height = "";
                container.style.overflow = "";
              }
              self.resize();
            };
            container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.addEventListener('resetScrollView', self.resetScrollView);
            function getEventTouches(e) {
              return e.touches && e.touches.length ? e.touches : [{
                pageX: e.pageX,
                pageY: e.pageY
              }];
            }
            self.touchStart = function(e) {
              self.startCoordinates = ionic.tap.pointerCoord(e);
              if (ionic.tap.ignoreScrollStart(e)) {
                return;
              }
              self.__isDown = true;
              if (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT') {
                self.__hasStarted = false;
                return;
              }
              self.__isSelectable = true;
              self.__enableScrollY = true;
              self.__hasStarted = true;
              self.doTouchStart(getEventTouches(e), e.timeStamp);
              e.preventDefault();
            };
            self.touchMove = function(e) {
              if (self.options.freeze || !self.__isDown || (!self.__isDown && e.defaultPrevented) || (e.target.tagName === 'TEXTAREA' && e.target.parentElement.querySelector(':focus'))) {
                return;
              }
              if (!self.__hasStarted && (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT')) {
                self.__hasStarted = true;
                self.doTouchStart(getEventTouches(e), e.timeStamp);
                e.preventDefault();
                return;
              }
              if (self.startCoordinates) {
                var currentCoordinates = ionic.tap.pointerCoord(e);
                if (self.__isSelectable && ionic.tap.isTextInput(e.target) && Math.abs(self.startCoordinates.x - currentCoordinates.x) > 20) {
                  self.__enableScrollY = false;
                  self.__isSelectable = true;
                }
                if (self.__enableScrollY && Math.abs(self.startCoordinates.y - currentCoordinates.y) > 10) {
                  self.__isSelectable = false;
                  ionic.tap.cloneFocusedInput(container, self);
                }
              }
              self.doTouchMove(getEventTouches(e), e.timeStamp, e.scale);
              self.__isDown = true;
            };
            self.touchMoveBubble = function(e) {
              if (self.__isDown && self.options.preventDefault) {
                e.preventDefault();
              }
            };
            self.touchEnd = function(e) {
              if (!self.__isDown)
                return;
              self.doTouchEnd(e, e.timeStamp);
              self.__isDown = false;
              self.__hasStarted = false;
              self.__isSelectable = true;
              self.__enableScrollY = true;
              if (!self.__isDragging && !self.__isDecelerating && !self.__isAnimating) {
                ionic.tap.removeClonedInputs(container, self);
              }
            };
            self.mouseWheel = ionic.animationFrameThrottle(function(e) {
              var scrollParent = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'ionic-scroll');
              if (!self.options.freeze && scrollParent === self.__container) {
                self.hintResize();
                self.scrollBy((e.wheelDeltaX || e.deltaX || 0) / self.options.wheelDampen, (-e.wheelDeltaY || e.deltaY || 0) / self.options.wheelDampen);
                self.__fadeScrollbars('in');
                clearTimeout(self.__wheelHideBarTimeout);
                self.__wheelHideBarTimeout = setTimeout(function() {
                  self.__fadeScrollbars('out');
                }, 100);
              }
            });
            if ('ontouchstart' in window) {
              container.addEventListener("touchstart", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("touchmove", self.touchMoveBubble, false);
              document.addEventListener("touchmove", self.touchMove, false);
              document.addEventListener("touchend", self.touchEnd, false);
              document.addEventListener("touchcancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else if (window.navigator.pointerEnabled) {
              container.addEventListener("pointerdown", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("pointermove", self.touchMoveBubble, false);
              document.addEventListener("pointermove", self.touchMove, false);
              document.addEventListener("pointerup", self.touchEnd, false);
              document.addEventListener("pointercancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else if (window.navigator.msPointerEnabled) {
              container.addEventListener("MSPointerDown", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("MSPointerMove", self.touchMoveBubble, false);
              document.addEventListener("MSPointerMove", self.touchMove, false);
              document.addEventListener("MSPointerUp", self.touchEnd, false);
              document.addEventListener("MSPointerCancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else {
              var mousedown = false;
              self.mouseDown = function(e) {
                if (ionic.tap.ignoreScrollStart(e) || e.target.tagName === 'SELECT') {
                  return;
                }
                self.doTouchStart(getEventTouches(e), e.timeStamp);
                if (!ionic.tap.isTextInput(e.target)) {
                  e.preventDefault();
                }
                mousedown = true;
              };
              self.mouseMove = function(e) {
                if (self.options.freeze || !mousedown || (!mousedown && e.defaultPrevented)) {
                  return;
                }
                self.doTouchMove(getEventTouches(e), e.timeStamp);
                mousedown = true;
              };
              self.mouseMoveBubble = function(e) {
                if (mousedown && self.options.preventDefault) {
                  e.preventDefault();
                }
              };
              self.mouseUp = function(e) {
                if (!mousedown) {
                  return;
                }
                self.doTouchEnd(e, e.timeStamp);
                mousedown = false;
              };
              container.addEventListener("mousedown", self.mouseDown, false);
              if (self.options.preventDefault)
                container.addEventListener("mousemove", self.mouseMoveBubble, false);
              document.addEventListener("mousemove", self.mouseMove, false);
              document.addEventListener("mouseup", self.mouseUp, false);
              document.addEventListener('mousewheel', self.mouseWheel, false);
              document.addEventListener('wheel', self.mouseWheel, false);
            }
          },
          __cleanup: function() {
            var self = this;
            var container = self.__container;
            container.removeEventListener('touchstart', self.touchStart);
            container.removeEventListener('touchmove', self.touchMoveBubble);
            document.removeEventListener('touchmove', self.touchMove);
            document.removeEventListener('touchend', self.touchEnd);
            document.removeEventListener('touchcancel', self.touchEnd);
            container.removeEventListener("pointerdown", self.touchStart);
            container.removeEventListener("pointermove", self.touchMoveBubble);
            document.removeEventListener("pointermove", self.touchMove);
            document.removeEventListener("pointerup", self.touchEnd);
            document.removeEventListener("pointercancel", self.touchEnd);
            container.removeEventListener("MSPointerDown", self.touchStart);
            container.removeEventListener("MSPointerMove", self.touchMoveBubble);
            document.removeEventListener("MSPointerMove", self.touchMove);
            document.removeEventListener("MSPointerUp", self.touchEnd);
            document.removeEventListener("MSPointerCancel", self.touchEnd);
            container.removeEventListener("mousedown", self.mouseDown);
            container.removeEventListener("mousemove", self.mouseMoveBubble);
            document.removeEventListener("mousemove", self.mouseMove);
            document.removeEventListener("mouseup", self.mouseUp);
            document.removeEventListener('mousewheel', self.mouseWheel);
            document.removeEventListener('wheel', self.mouseWheel);
            container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.removeEventListener('resetScrollView', self.resetScrollView);
            ionic.tap.removeClonedInputs(container, self);
            delete self.__container;
            delete self.__content;
            delete self.__indicatorX;
            delete self.__indicatorY;
            delete self.options.el;
            self.__callback = self.scrollChildIntoView = self.resetScrollView = NOOP;
            self.mouseMove = self.mouseDown = self.mouseUp = self.mouseWheel = self.touchStart = self.touchMove = self.touchEnd = self.touchCancel = NOOP;
            self.resize = self.scrollTo = self.zoomTo = self.__scrollingComplete = NOOP;
            container = null;
          },
          __createScrollbar: function(direction) {
            var bar = document.createElement('div'),
                indicator = document.createElement('div');
            indicator.className = 'scroll-bar-indicator scroll-bar-fade-out';
            if (direction == 'h') {
              bar.className = 'scroll-bar scroll-bar-h';
            } else {
              bar.className = 'scroll-bar scroll-bar-v';
            }
            bar.appendChild(indicator);
            return bar;
          },
          __createScrollbars: function() {
            var self = this;
            var indicatorX,
                indicatorY;
            if (self.options.scrollingX) {
              indicatorX = {
                el: self.__createScrollbar('h'),
                sizeRatio: 1
              };
              indicatorX.indicator = indicatorX.el.children[0];
              if (self.options.scrollbarX) {
                self.__container.appendChild(indicatorX.el);
              }
              self.__indicatorX = indicatorX;
            }
            if (self.options.scrollingY) {
              indicatorY = {
                el: self.__createScrollbar('v'),
                sizeRatio: 1
              };
              indicatorY.indicator = indicatorY.el.children[0];
              if (self.options.scrollbarY) {
                self.__container.appendChild(indicatorY.el);
              }
              self.__indicatorY = indicatorY;
            }
          },
          __resizeScrollbars: function() {
            var self = this;
            if (self.__indicatorX) {
              var width = Math.max(Math.round(self.__clientWidth * self.__clientWidth / (self.__contentWidth)), 20);
              if (width > self.__contentWidth) {
                width = 0;
              }
              if (width !== self.__indicatorX.size) {
                ionic.requestAnimationFrame(function() {
                  self.__indicatorX.indicator.style.width = width + 'px';
                });
              }
              self.__indicatorX.size = width;
              self.__indicatorX.minScale = self.options.minScrollbarSizeX / width;
              self.__indicatorX.maxPos = self.__clientWidth - width;
              self.__indicatorX.sizeRatio = self.__maxScrollLeft ? self.__indicatorX.maxPos / self.__maxScrollLeft : 1;
            }
            if (self.__indicatorY) {
              var height = Math.max(Math.round(self.__clientHeight * self.__clientHeight / (self.__contentHeight)), 20);
              if (height > self.__contentHeight) {
                height = 0;
              }
              if (height !== self.__indicatorY.size) {
                ionic.requestAnimationFrame(function() {
                  self.__indicatorY && (self.__indicatorY.indicator.style.height = height + 'px');
                });
              }
              self.__indicatorY.size = height;
              self.__indicatorY.minScale = self.options.minScrollbarSizeY / height;
              self.__indicatorY.maxPos = self.__clientHeight - height;
              self.__indicatorY.sizeRatio = self.__maxScrollTop ? self.__indicatorY.maxPos / self.__maxScrollTop : 1;
            }
          },
          __repositionScrollbars: function() {
            var self = this,
                heightScale,
                widthScale,
                widthDiff,
                heightDiff,
                x,
                y,
                xstop = 0,
                ystop = 0;
            if (self.__indicatorX) {
              if (self.__indicatorY)
                xstop = 10;
              x = Math.round(self.__indicatorX.sizeRatio * self.__scrollLeft) || 0;
              widthDiff = self.__scrollLeft - (self.__maxScrollLeft - xstop);
              if (self.__scrollLeft < 0) {
                widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - Math.abs(self.__scrollLeft)) / self.__indicatorX.size);
                x = 0;
                self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'left center';
              } else if (widthDiff > 0) {
                widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - widthDiff) / self.__indicatorX.size);
                x = self.__indicatorX.maxPos - xstop;
                self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'right center';
              } else {
                x = Math.min(self.__maxScrollLeft, Math.max(0, x));
                widthScale = 1;
              }
              var translate3dX = 'translate3d(' + x + 'px, 0, 0) scaleX(' + widthScale + ')';
              if (self.__indicatorX.transformProp !== translate3dX) {
                self.__indicatorX.indicator.style[self.__transformProperty] = translate3dX;
                self.__indicatorX.transformProp = translate3dX;
              }
            }
            if (self.__indicatorY) {
              y = Math.round(self.__indicatorY.sizeRatio * self.__scrollTop) || 0;
              if (self.__indicatorX)
                ystop = 10;
              heightDiff = self.__scrollTop - (self.__maxScrollTop - ystop);
              if (self.__scrollTop < 0) {
                heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - Math.abs(self.__scrollTop)) / self.__indicatorY.size);
                y = 0;
                if (self.__indicatorY.originProp !== 'center top') {
                  self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center top';
                  self.__indicatorY.originProp = 'center top';
                }
              } else if (heightDiff > 0) {
                heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - heightDiff) / self.__indicatorY.size);
                y = self.__indicatorY.maxPos - ystop;
                if (self.__indicatorY.originProp !== 'center bottom') {
                  self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center bottom';
                  self.__indicatorY.originProp = 'center bottom';
                }
              } else {
                y = Math.min(self.__maxScrollTop, Math.max(0, y));
                heightScale = 1;
              }
              var translate3dY = 'translate3d(0,' + y + 'px, 0) scaleY(' + heightScale + ')';
              if (self.__indicatorY.transformProp !== translate3dY) {
                self.__indicatorY.indicator.style[self.__transformProperty] = translate3dY;
                self.__indicatorY.transformProp = translate3dY;
              }
            }
          },
          __fadeScrollbars: function(direction, delay) {
            var self = this;
            if (!self.options.scrollbarsFade) {
              return;
            }
            var className = 'scroll-bar-fade-out';
            if (self.options.scrollbarsFade === true) {
              clearTimeout(self.__scrollbarFadeTimeout);
              if (direction == 'in') {
                if (self.__indicatorX) {
                  self.__indicatorX.indicator.classList.remove(className);
                }
                if (self.__indicatorY) {
                  self.__indicatorY.indicator.classList.remove(className);
                }
              } else {
                self.__scrollbarFadeTimeout = setTimeout(function() {
                  if (self.__indicatorX) {
                    self.__indicatorX.indicator.classList.add(className);
                  }
                  if (self.__indicatorY) {
                    self.__indicatorY.indicator.classList.add(className);
                  }
                }, delay || self.options.scrollbarFadeDelay);
              }
            }
          },
          __scrollingComplete: function() {
            this.options.scrollingComplete();
            ionic.tap.removeClonedInputs(this.__container, this);
            this.__fadeScrollbars('out');
          },
          resize: function(continueScrolling) {
            var self = this;
            if (!self.__container || !self.options)
              return;
            self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
          },
          getRenderFn: function() {
            var self = this;
            var content = self.__content;
            var docStyle = document.documentElement.style;
            var engine;
            if ('MozAppearance' in docStyle) {
              engine = 'gecko';
            } else if ('WebkitAppearance' in docStyle) {
              engine = 'webkit';
            } else if (typeof navigator.cpuClass === 'string') {
              engine = 'trident';
            }
            var vendorPrefix = {
              trident: 'ms',
              gecko: 'Moz',
              webkit: 'Webkit',
              presto: 'O'
            }[engine];
            var helperElem = document.createElement("div");
            var undef;
            var perspectiveProperty = vendorPrefix + "Perspective";
            var transformProperty = vendorPrefix + "Transform";
            var transformOriginProperty = vendorPrefix + 'TransformOrigin';
            self.__perspectiveProperty = transformProperty;
            self.__transformProperty = transformProperty;
            self.__transformOriginProperty = transformOriginProperty;
            if (helperElem.style[perspectiveProperty] !== undef) {
              return function(left, top, zoom, wasResize) {
                var translate3d = 'translate3d(' + (-left) + 'px,' + (-top) + 'px,0) scale(' + zoom + ')';
                if (translate3d !== self.contentTransform) {
                  content.style[transformProperty] = translate3d;
                  self.contentTransform = translate3d;
                }
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            } else if (helperElem.style[transformProperty] !== undef) {
              return function(left, top, zoom, wasResize) {
                content.style[transformProperty] = 'translate(' + (-left) + 'px,' + (-top) + 'px) scale(' + zoom + ')';
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            } else {
              return function(left, top, zoom, wasResize) {
                content.style.marginLeft = left ? (-left / zoom) + 'px' : '';
                content.style.marginTop = top ? (-top / zoom) + 'px' : '';
                content.style.zoom = zoom || '';
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            }
          },
          setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight, continueScrolling) {
            var self = this;
            if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
              return;
            }
            if (clientWidth === +clientWidth) {
              self.__clientWidth = clientWidth;
            }
            if (clientHeight === +clientHeight) {
              self.__clientHeight = clientHeight;
            }
            if (contentWidth === +contentWidth) {
              self.__contentWidth = contentWidth;
            }
            if (contentHeight === +contentHeight) {
              self.__contentHeight = contentHeight;
            }
            self.__computeScrollMax();
            self.__resizeScrollbars();
            if (!continueScrolling) {
              self.scrollTo(self.__scrollLeft, self.__scrollTop, true, null, true);
            }
          },
          setPosition: function(left, top) {
            this.__clientLeft = left || 0;
            this.__clientTop = top || 0;
          },
          setSnapSize: function(width, height) {
            this.__snapWidth = width;
            this.__snapHeight = height;
          },
          activatePullToRefresh: function(height, refresherMethods) {
            var self = this;
            self.__refreshHeight = height;
            self.__refreshActivate = function() {
              ionic.requestAnimationFrame(refresherMethods.activate);
            };
            self.__refreshDeactivate = function() {
              ionic.requestAnimationFrame(refresherMethods.deactivate);
            };
            self.__refreshStart = function() {
              ionic.requestAnimationFrame(refresherMethods.start);
            };
            self.__refreshShow = function() {
              ionic.requestAnimationFrame(refresherMethods.show);
            };
            self.__refreshHide = function() {
              ionic.requestAnimationFrame(refresherMethods.hide);
            };
            self.__refreshTail = function() {
              ionic.requestAnimationFrame(refresherMethods.tail);
            };
            self.__refreshTailTime = 100;
            self.__minSpinTime = 600;
          },
          triggerPullToRefresh: function() {
            this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);
            var d = new Date();
            this.refreshStartTime = d.getTime();
            if (this.__refreshStart) {
              this.__refreshStart();
            }
          },
          finishPullToRefresh: function() {
            var self = this;
            var d = new Date();
            var delay = 0;
            if (self.refreshStartTime + self.__minSpinTime > d.getTime()) {
              delay = self.refreshStartTime + self.__minSpinTime - d.getTime();
            }
            setTimeout(function() {
              if (self.__refreshTail) {
                self.__refreshTail();
              }
              setTimeout(function() {
                self.__refreshActive = false;
                if (self.__refreshDeactivate) {
                  self.__refreshDeactivate();
                }
                if (self.__refreshHide) {
                  self.__refreshHide();
                }
                self.scrollTo(self.__scrollLeft, self.__scrollTop, true);
              }, self.__refreshTailTime);
            }, delay);
          },
          getValues: function() {
            return {
              left: this.__scrollLeft,
              top: this.__scrollTop,
              zoom: this.__zoomLevel
            };
          },
          getScrollMax: function() {
            return {
              left: this.__maxScrollLeft,
              top: this.__maxScrollTop
            };
          },
          zoomTo: function(level, animate, originLeft, originTop) {
            var self = this;
            if (!self.options.zooming) {
              throw new Error("Zooming is not enabled!");
            }
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
            }
            var oldLevel = self.__zoomLevel;
            if (originLeft == null) {
              originLeft = self.__clientWidth / 2;
            }
            if (originTop == null) {
              originTop = self.__clientHeight / 2;
            }
            level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
            self.__computeScrollMax(level);
            var left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;
            var top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;
            if (left > self.__maxScrollLeft) {
              left = self.__maxScrollLeft;
            } else if (left < 0) {
              left = 0;
            }
            if (top > self.__maxScrollTop) {
              top = self.__maxScrollTop;
            } else if (top < 0) {
              top = 0;
            }
            self.__publish(left, top, level, animate);
          },
          zoomBy: function(factor, animate, originLeft, originTop) {
            this.zoomTo(this.__zoomLevel * factor, animate, originLeft, originTop);
          },
          scrollTo: function(left, top, animate, zoom, wasResize) {
            var self = this;
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
            }
            if (zoom != null && zoom !== self.__zoomLevel) {
              if (!self.options.zooming) {
                throw new Error("Zooming is not enabled!");
              }
              left *= zoom;
              top *= zoom;
              self.__computeScrollMax(zoom);
            } else {
              zoom = self.__zoomLevel;
            }
            if (!self.options.scrollingX) {
              left = self.__scrollLeft;
            } else {
              if (self.options.paging) {
                left = Math.round(left / self.__clientWidth) * self.__clientWidth;
              } else if (self.options.snapping) {
                left = Math.round(left / self.__snapWidth) * self.__snapWidth;
              }
            }
            if (!self.options.scrollingY) {
              top = self.__scrollTop;
            } else {
              if (self.options.paging) {
                top = Math.round(top / self.__clientHeight) * self.__clientHeight;
              } else if (self.options.snapping) {
                top = Math.round(top / self.__snapHeight) * self.__snapHeight;
              }
            }
            left = Math.max(Math.min(self.__maxScrollLeft, left), 0);
            top = Math.max(Math.min(self.__maxScrollTop, top), 0);
            if (left === self.__scrollLeft && top === self.__scrollTop) {
              animate = false;
            }
            self.__publish(left, top, zoom, animate, wasResize);
          },
          scrollBy: function(left, top, animate) {
            var self = this;
            var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
            var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
            self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
          },
          doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {
            var change = wheelDelta > 0 ? 0.97 : 1.03;
            return this.zoomTo(this.__zoomLevel * change, false, pageX - this.__clientLeft, pageY - this.__clientTop);
          },
          doTouchStart: function(touches, timeStamp) {
            var self = this;
            self.__decStopped = !!(self.__isDecelerating || self.__isAnimating);
            self.hintResize();
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            self.__interruptedAnimation = true;
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
              self.__interruptedAnimation = true;
            }
            if (self.__isAnimating) {
              zyngaCore.effect.Animate.stop(self.__isAnimating);
              self.__isAnimating = false;
              self.__interruptedAnimation = true;
            }
            var currentTouchLeft,
                currentTouchTop;
            var isSingleTouch = touches.length === 1;
            if (isSingleTouch) {
              currentTouchLeft = touches[0].pageX;
              currentTouchTop = touches[0].pageY;
            } else {
              currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
              currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
            }
            self.__initialTouchLeft = currentTouchLeft;
            self.__initialTouchTop = currentTouchTop;
            self.__initialTouches = touches;
            self.__zoomLevelStart = self.__zoomLevel;
            self.__lastTouchLeft = currentTouchLeft;
            self.__lastTouchTop = currentTouchTop;
            self.__lastTouchMove = timeStamp;
            self.__lastScale = 1;
            self.__enableScrollX = !isSingleTouch && self.options.scrollingX;
            self.__enableScrollY = !isSingleTouch && self.options.scrollingY;
            self.__isTracking = true;
            self.__didDecelerationComplete = false;
            self.__isDragging = !isSingleTouch;
            self.__isSingleTouch = isSingleTouch;
            self.__positions = [];
          },
          doTouchMove: function(touches, timeStamp, scale) {
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            var self = this;
            if (!self.__isTracking) {
              return;
            }
            var currentTouchLeft,
                currentTouchTop;
            if (touches.length === 2) {
              currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
              currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
              if (!scale && self.options.zooming) {
                scale = self.__getScale(self.__initialTouches, touches);
              }
            } else {
              currentTouchLeft = touches[0].pageX;
              currentTouchTop = touches[0].pageY;
            }
            var positions = self.__positions;
            if (self.__isDragging) {
              self.__decStopped = false;
              var moveX = currentTouchLeft - self.__lastTouchLeft;
              var moveY = currentTouchTop - self.__lastTouchTop;
              var scrollLeft = self.__scrollLeft;
              var scrollTop = self.__scrollTop;
              var level = self.__zoomLevel;
              if (scale != null && self.options.zooming) {
                var oldLevel = level;
                level = level / self.__lastScale * scale;
                level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
                if (oldLevel !== level) {
                  var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;
                  var currentTouchTopRel = currentTouchTop - self.__clientTop;
                  scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;
                  scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;
                  self.__computeScrollMax(level);
                }
              }
              if (self.__enableScrollX) {
                scrollLeft -= moveX * self.options.speedMultiplier;
                var maxScrollLeft = self.__maxScrollLeft;
                if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
                  if (self.options.bouncing) {
                    scrollLeft += (moveX / 2 * self.options.speedMultiplier);
                  } else if (scrollLeft > maxScrollLeft) {
                    scrollLeft = maxScrollLeft;
                  } else {
                    scrollLeft = 0;
                  }
                }
              }
              if (self.__enableScrollY) {
                scrollTop -= moveY * self.options.speedMultiplier;
                var maxScrollTop = self.__maxScrollTop;
                if (scrollTop > maxScrollTop || scrollTop < 0) {
                  if (self.options.bouncing || (self.__refreshHeight && scrollTop < 0)) {
                    scrollTop += (moveY / 2 * self.options.speedMultiplier);
                    if (!self.__enableScrollX && self.__refreshHeight != null) {
                      if (scrollTop < 0) {
                        self.__refreshHidden = false;
                        self.__refreshShow();
                      } else {
                        self.__refreshHide();
                        self.__refreshHidden = true;
                      }
                      if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {
                        self.__refreshActive = true;
                        if (self.__refreshActivate) {
                          self.__refreshActivate();
                        }
                      } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {
                        self.__refreshActive = false;
                        if (self.__refreshDeactivate) {
                          self.__refreshDeactivate();
                        }
                      }
                    }
                  } else if (scrollTop > maxScrollTop) {
                    scrollTop = maxScrollTop;
                  } else {
                    scrollTop = 0;
                  }
                } else if (self.__refreshHeight && !self.__refreshHidden) {
                  self.__refreshHide();
                  self.__refreshHidden = true;
                }
              }
              if (positions.length > 60) {
                positions.splice(0, 30);
              }
              positions.push(scrollLeft, scrollTop, timeStamp);
              self.__publish(scrollLeft, scrollTop, level);
            } else {
              var minimumTrackingForScroll = self.options.locking ? 3 : 0;
              var minimumTrackingForDrag = 5;
              var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);
              var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);
              self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;
              self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;
              positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);
              self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
              if (self.__isDragging) {
                self.__interruptedAnimation = false;
                self.__fadeScrollbars('in');
              }
            }
            self.__lastTouchLeft = currentTouchLeft;
            self.__lastTouchTop = currentTouchTop;
            self.__lastTouchMove = timeStamp;
            self.__lastScale = scale;
          },
          doTouchEnd: function(e, timeStamp) {
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            var self = this;
            if (!self.__isTracking) {
              return;
            }
            self.__isTracking = false;
            if (self.__isDragging) {
              self.__isDragging = false;
              if (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {
                var positions = self.__positions;
                var endPos = positions.length - 1;
                var startPos = endPos;
                for (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {
                  startPos = i;
                }
                if (startPos !== endPos) {
                  var timeOffset = positions[endPos] - positions[startPos];
                  var movedLeft = self.__scrollLeft - positions[startPos - 2];
                  var movedTop = self.__scrollTop - positions[startPos - 1];
                  self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
                  self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);
                  var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? self.options.decelVelocityThresholdPaging : self.options.decelVelocityThreshold;
                  if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {
                    if (!self.__refreshActive) {
                      self.__startDeceleration(timeStamp);
                    }
                  }
                } else {
                  self.__scrollingComplete();
                }
              } else if ((timeStamp - self.__lastTouchMove) > 100) {
                self.__scrollingComplete();
              }
            } else if (self.__decStopped) {
              e.isTapHandled = true;
              self.__decStopped = false;
            }
            if (!self.__isDecelerating) {
              if (self.__refreshActive && self.__refreshStart) {
                self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);
                var d = new Date();
                self.refreshStartTime = d.getTime();
                if (self.__refreshStart) {
                  self.__refreshStart();
                }
                if (!ionic.Platform.isAndroid())
                  self.__startDeceleration();
              } else {
                if (self.__interruptedAnimation || self.__isDragging) {
                  self.__scrollingComplete();
                }
                self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);
                if (self.__refreshActive) {
                  self.__refreshActive = false;
                  if (self.__refreshDeactivate) {
                    self.__refreshDeactivate();
                  }
                }
              }
            }
            self.__positions.length = 0;
          },
          __publish: function(left, top, zoom, animate, wasResize) {
            var self = this;
            var wasAnimating = self.__isAnimating;
            if (wasAnimating) {
              zyngaCore.effect.Animate.stop(wasAnimating);
              self.__isAnimating = false;
            }
            if (animate && self.options.animating) {
              self.__scheduledLeft = left;
              self.__scheduledTop = top;
              self.__scheduledZoom = zoom;
              var oldLeft = self.__scrollLeft;
              var oldTop = self.__scrollTop;
              var oldZoom = self.__zoomLevel;
              var diffLeft = left - oldLeft;
              var diffTop = top - oldTop;
              var diffZoom = zoom - oldZoom;
              var step = function(percent, now, render) {
                if (render) {
                  self.__scrollLeft = oldLeft + (diffLeft * percent);
                  self.__scrollTop = oldTop + (diffTop * percent);
                  self.__zoomLevel = oldZoom + (diffZoom * percent);
                  if (self.__callback) {
                    self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel, wasResize);
                  }
                }
              };
              var verify = function(id) {
                return self.__isAnimating === id;
              };
              var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
                if (animationId === self.__isAnimating) {
                  self.__isAnimating = false;
                }
                if (self.__didDecelerationComplete || wasFinished) {
                  self.__scrollingComplete();
                }
                if (self.options.zooming) {
                  self.__computeScrollMax();
                }
              };
              self.__isAnimating = zyngaCore.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
            } else {
              self.__scheduledLeft = self.__scrollLeft = left;
              self.__scheduledTop = self.__scrollTop = top;
              self.__scheduledZoom = self.__zoomLevel = zoom;
              if (self.__callback) {
                self.__callback(left, top, zoom, wasResize);
              }
              if (self.options.zooming) {
                self.__computeScrollMax();
              }
            }
          },
          __computeScrollMax: function(zoomLevel) {
            var self = this;
            if (zoomLevel == null) {
              zoomLevel = self.__zoomLevel;
            }
            self.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);
            self.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);
            if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
              self.__didWaitForSize = true;
              self.__waitForSize();
            }
          },
          __waitForSize: function() {
            var self = this;
            clearTimeout(self.__sizerTimeout);
            var sizer = function() {
              self.resize(true);
            };
            sizer();
            self.__sizerTimeout = setTimeout(sizer, 500);
          },
          __startDeceleration: function() {
            var self = this;
            if (self.options.paging) {
              var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);
              var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);
              var clientWidth = self.__clientWidth;
              var clientHeight = self.__clientHeight;
              self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
              self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
              self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
              self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
            } else {
              self.__minDecelerationScrollLeft = 0;
              self.__minDecelerationScrollTop = 0;
              self.__maxDecelerationScrollLeft = self.__maxScrollLeft;
              self.__maxDecelerationScrollTop = self.__maxScrollTop;
              if (self.__refreshActive)
                self.__minDecelerationScrollTop = self.__refreshHeight * -1;
            }
            var step = function(percent, now, render) {
              self.__stepThroughDeceleration(render);
            };
            self.__minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1;
            var verify = function() {
              var shouldContinue = Math.abs(self.__decelerationVelocityX) >= self.__minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= self.__minVelocityToKeepDecelerating;
              if (!shouldContinue) {
                self.__didDecelerationComplete = true;
                if (self.options.bouncing && !self.__refreshActive) {
                  self.scrollTo(Math.min(Math.max(self.__scrollLeft, 0), self.__maxScrollLeft), Math.min(Math.max(self.__scrollTop, 0), self.__maxScrollTop), self.__refreshActive);
                }
              }
              return shouldContinue;
            };
            var completed = function() {
              self.__isDecelerating = false;
              if (self.__didDecelerationComplete) {
                self.__scrollingComplete();
              }
              if (self.options.paging) {
                self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);
              }
            };
            self.__isDecelerating = zyngaCore.effect.Animate.start(step, verify, completed);
          },
          __stepThroughDeceleration: function(render) {
            var self = this;
            var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;
            var scrollTop = self.__scrollTop + self.__decelerationVelocityY;
            if (!self.options.bouncing) {
              var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);
              if (scrollLeftFixed !== scrollLeft) {
                scrollLeft = scrollLeftFixed;
                self.__decelerationVelocityX = 0;
              }
              var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);
              if (scrollTopFixed !== scrollTop) {
                scrollTop = scrollTopFixed;
                self.__decelerationVelocityY = 0;
              }
            }
            if (render) {
              self.__publish(scrollLeft, scrollTop, self.__zoomLevel);
            } else {
              self.__scrollLeft = scrollLeft;
              self.__scrollTop = scrollTop;
            }
            if (!self.options.paging) {
              var frictionFactor = self.options.deceleration;
              self.__decelerationVelocityX *= frictionFactor;
              self.__decelerationVelocityY *= frictionFactor;
            }
            if (self.options.bouncing) {
              var scrollOutsideX = 0;
              var scrollOutsideY = 0;
              var penetrationDeceleration = self.options.penetrationDeceleration;
              var penetrationAcceleration = self.options.penetrationAcceleration;
              if (scrollLeft < self.__minDecelerationScrollLeft) {
                scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;
              } else if (scrollLeft > self.__maxDecelerationScrollLeft) {
                scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;
              }
              if (scrollTop < self.__minDecelerationScrollTop) {
                scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;
              } else if (scrollTop > self.__maxDecelerationScrollTop) {
                scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;
              }
              if (scrollOutsideX !== 0) {
                var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;
                if (isHeadingOutwardsX) {
                  self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
                }
                var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;
                if (!isHeadingOutwardsX || isStoppedX) {
                  self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
                }
              }
              if (scrollOutsideY !== 0) {
                var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;
                if (isHeadingOutwardsY) {
                  self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
                }
                var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;
                if (!isHeadingOutwardsY || isStoppedY) {
                  self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
                }
              }
            }
          },
          __getDistance: function getDistance(touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
          },
          __getScale: function getScale(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.__getDistance(end[0], end[1]) / this.__getDistance(start[0], start[1]);
            }
            return 1;
          }
        });
        ionic.scroll = {
          isScrolling: false,
          lastTop: 0
        };
      })(ionic);
      (function(ionic) {
        var NOOP = function() {};
        var depreciated = function(name) {
          void 0;
        };
        ionic.views.ScrollNative = ionic.views.View.inherit({
          initialize: function(options) {
            var self = this;
            self.__container = self.el = options.el;
            self.__content = options.el.firstElementChild;
            self.isNative = true;
            self.__scrollTop = self.el.scrollTop;
            self.__scrollLeft = self.el.scrollLeft;
            self.__clientHeight = self.__content.clientHeight;
            self.__clientWidth = self.__content.clientWidth;
            self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
            self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
            self.options = {
              freeze: false,
              getContentWidth: function() {
                return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
              },
              getContentHeight: function() {
                return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
              }
            };
            for (var key in options) {
              self.options[key] = options[key];
            }
            self.onScroll = function() {
              if (!ionic.scroll.isScrolling) {
                ionic.scroll.isScrolling = true;
              }
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(function() {
                ionic.scroll.isScrolling = false;
              }, 80);
            };
            self.freeze = NOOP;
            self.__initEventHandlers();
          },
          __callback: function() {
            depreciated('__callback');
          },
          zoomTo: function() {
            depreciated('zoomTo');
          },
          zoomBy: function() {
            depreciated('zoomBy');
          },
          activatePullToRefresh: function() {
            depreciated('activatePullToRefresh');
          },
          resize: function(continueScrolling) {
            var self = this;
            if (!self.__container || !self.options)
              return;
            self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
          },
          run: function() {
            this.resize();
          },
          getValues: function() {
            var self = this;
            self.update();
            return {
              left: self.__scrollLeft,
              top: self.__scrollTop,
              zoom: 1
            };
          },
          update: function() {
            var self = this;
            self.__scrollLeft = self.el.scrollLeft;
            self.__scrollTop = self.el.scrollTop;
          },
          setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {
            var self = this;
            if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
              return;
            }
            if (clientWidth === +clientWidth) {
              self.__clientWidth = clientWidth;
            }
            if (clientHeight === +clientHeight) {
              self.__clientHeight = clientHeight;
            }
            if (contentWidth === +contentWidth) {
              self.__contentWidth = contentWidth;
            }
            if (contentHeight === +contentHeight) {
              self.__contentHeight = contentHeight;
            }
            self.__computeScrollMax();
          },
          getScrollMax: function() {
            return {
              left: this.__maxScrollLeft,
              top: this.__maxScrollTop
            };
          },
          scrollBy: function(left, top, animate) {
            var self = this;
            self.update();
            var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
            var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
            self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
          },
          scrollTo: function(left, top, animate) {
            var self = this;
            if (!animate) {
              self.el.scrollTop = top;
              self.el.scrollLeft = left;
              self.resize();
              return;
            }
            animateScroll(top, left);
            function animateScroll(Y, X) {
              var start = Date.now(),
                  duration = 250,
                  fromY = self.el.scrollTop,
                  fromX = self.el.scrollLeft;
              if (fromY === Y && fromX === X) {
                self.resize();
                return;
              }
              function easeOutCubic(t) {
                return (--t) * t * t + 1;
              }
              function animateScrollStep() {
                var currentTime = Date.now(),
                    time = Math.min(1, ((currentTime - start) / duration)),
                    easedT = easeOutCubic(time);
                if (fromY != Y) {
                  self.el.scrollTop = parseInt((easedT * (Y - fromY)) + fromY, 10);
                }
                if (fromX != X) {
                  self.el.scrollLeft = parseInt((easedT * (X - fromX)) + fromX, 10);
                }
                if (time < 1) {
                  ionic.requestAnimationFrame(animateScrollStep);
                } else {
                  ionic.tap.removeClonedInputs(self.__container, self);
                  self.resize();
                }
              }
              ionic.requestAnimationFrame(animateScrollStep);
            }
          },
          __waitForSize: function() {
            var self = this;
            clearTimeout(self.__sizerTimeout);
            var sizer = function() {
              self.resize(true);
            };
            sizer();
            self.__sizerTimeout = setTimeout(sizer, 500);
          },
          __computeScrollMax: function() {
            var self = this;
            self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
            self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
            if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
              self.__didWaitForSize = true;
              self.__waitForSize();
            }
          },
          __initEventHandlers: function() {
            var self = this;
            var container = self.__container;
            var scrollViewOffsetHeight;
            self.scrollChildIntoView = function(e) {
              var scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
              scrollViewOffsetHeight = container.offsetHeight;
              var alreadyShrunk = self.isShrunkForKeyboard;
              var isModal = container.parentNode.classList.contains('modal');
              var isInsetModal = isModal && window.innerWidth >= 680;
              if (!alreadyShrunk) {
                if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) {
                  var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop;
                  var keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
                  ionic.requestAnimationFrame(function() {
                    scrollViewOffsetHeight = scrollViewOffsetHeight - keyboardOffset;
                    container.style.height = scrollViewOffsetHeight + "px";
                    self.resize();
                  });
                }
                self.isShrunkForKeyboard = true;
              }
              if (e.detail.isElementUnderKeyboard) {
                ionic.requestAnimationFrame(function() {
                  if (self.isShrunkForKeyboard && !alreadyShrunk) {
                    scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
                  }
                  var scrollMidpointOffset = scrollViewOffsetHeight * 0.5;
                  var inputMidpoint = ((e.detail.elementBottom + e.detail.elementTop) / 2);
                  var inputMidpointOffsetToScrollBottom = inputMidpoint - scrollBottomOffsetToTop;
                  var scrollTop = inputMidpointOffsetToScrollBottom + scrollMidpointOffset;
                  if (scrollTop > 0) {
                    if (ionic.Platform.isIOS()) {
                      setTimeout(function() {
                        ionic.tap.cloneFocusedInput(container, self);
                        self.scrollBy(0, scrollTop, true);
                        self.onScroll();
                      }, 32);
                    } else {
                      self.scrollBy(0, scrollTop, true);
                      self.onScroll();
                    }
                  }
                });
              }
              e.stopPropagation();
            };
            self.resetScrollView = function() {
              if (self.isShrunkForKeyboard) {
                self.isShrunkForKeyboard = false;
                container.style.height = "";
              }
              self.resize();
            };
            container.addEventListener('scroll', self.onScroll);
            container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.addEventListener('resetScrollView', self.resetScrollView);
          },
          __cleanup: function() {
            var self = this;
            var container = self.__container;
            container.removeEventListener('resetScrollView', self.resetScrollView);
            container.removeEventListener('scroll', self.onScroll);
            container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
            container.removeEventListener('resetScrollView', self.resetScrollView);
            ionic.tap.removeClonedInputs(container, self);
            delete self.__container;
            delete self.__content;
            delete self.__indicatorX;
            delete self.__indicatorY;
            delete self.options.el;
            self.resize = self.scrollTo = self.onScroll = self.resetScrollView = NOOP;
            self.scrollChildIntoView = NOOP;
            container = null;
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        var ITEM_CLASS = 'item';
        var ITEM_CONTENT_CLASS = 'item-content';
        var ITEM_SLIDING_CLASS = 'item-sliding';
        var ITEM_OPTIONS_CLASS = 'item-options';
        var ITEM_PLACEHOLDER_CLASS = 'item-placeholder';
        var ITEM_REORDERING_CLASS = 'item-reordering';
        var ITEM_REORDER_BTN_CLASS = 'item-reorder';
        var DragOp = function() {};
        DragOp.prototype = {
          start: function() {},
          drag: function() {},
          end: function() {},
          isSameItem: function() {
            return false;
          }
        };
        var SlideDrag = function(opts) {
          this.dragThresholdX = opts.dragThresholdX || 10;
          this.el = opts.el;
          this.item = opts.item;
          this.canSwipe = opts.canSwipe;
        };
        SlideDrag.prototype = new DragOp();
        SlideDrag.prototype.start = function(e) {
          var content,
              buttons,
              offsetX,
              buttonsWidth;
          if (!this.canSwipe()) {
            return;
          }
          if (e.target.classList.contains(ITEM_CONTENT_CLASS)) {
            content = e.target;
          } else if (e.target.classList.contains(ITEM_CLASS)) {
            content = e.target.querySelector('.' + ITEM_CONTENT_CLASS);
          } else {
            content = ionic.DomUtil.getParentWithClass(e.target, ITEM_CONTENT_CLASS);
          }
          if (!content) {
            return;
          }
          content.classList.remove(ITEM_SLIDING_CLASS);
          offsetX = parseFloat(content.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]) || 0;
          buttons = content.parentNode.querySelector('.' + ITEM_OPTIONS_CLASS);
          if (!buttons) {
            return;
          }
          buttons.classList.remove('invisible');
          buttonsWidth = buttons.offsetWidth;
          this._currentDrag = {
            buttons: buttons,
            buttonsWidth: buttonsWidth,
            content: content,
            startOffsetX: offsetX
          };
        };
        SlideDrag.prototype.isSameItem = function(op) {
          if (op._lastDrag && this._currentDrag) {
            return this._currentDrag.content == op._lastDrag.content;
          }
          return false;
        };
        SlideDrag.prototype.clean = function(isInstant) {
          var lastDrag = this._lastDrag;
          if (!lastDrag || !lastDrag.content)
            return;
          lastDrag.content.style[ionic.CSS.TRANSITION] = '';
          lastDrag.content.style[ionic.CSS.TRANSFORM] = '';
          if (isInstant) {
            lastDrag.content.style[ionic.CSS.TRANSITION] = 'none';
            makeInvisible();
            ionic.requestAnimationFrame(function() {
              lastDrag.content.style[ionic.CSS.TRANSITION] = '';
            });
          } else {
            ionic.requestAnimationFrame(function() {
              setTimeout(makeInvisible, 250);
            });
          }
          function makeInvisible() {
            lastDrag.buttons && lastDrag.buttons.classList.add('invisible');
          }
        };
        SlideDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
          var buttonsWidth;
          if (!this._currentDrag) {
            return;
          }
          if (!this._isDragging && ((Math.abs(e.gesture.deltaX) > this.dragThresholdX) || (Math.abs(this._currentDrag.startOffsetX) > 0))) {
            this._isDragging = true;
          }
          if (this._isDragging) {
            buttonsWidth = this._currentDrag.buttonsWidth;
            var newX = Math.min(0, this._currentDrag.startOffsetX + e.gesture.deltaX);
            if (newX < -buttonsWidth) {
              newX = Math.min(-buttonsWidth, -buttonsWidth + (((e.gesture.deltaX + buttonsWidth) * 0.4)));
            }
            this._currentDrag.content.$$ionicOptionsOpen = newX !== 0;
            this._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + newX + 'px, 0, 0)';
            this._currentDrag.content.style[ionic.CSS.TRANSITION] = 'none';
          }
        });
        SlideDrag.prototype.end = function(e, doneCallback) {
          var self = this;
          if (!self._currentDrag) {
            doneCallback && doneCallback();
            return;
          }
          var restingPoint = -self._currentDrag.buttonsWidth;
          if (e.gesture.deltaX > -(self._currentDrag.buttonsWidth / 2)) {
            if (e.gesture.direction == "left" && Math.abs(e.gesture.velocityX) < 0.3) {
              restingPoint = 0;
            } else if (e.gesture.direction == "right") {
              restingPoint = 0;
            }
          }
          ionic.requestAnimationFrame(function() {
            if (restingPoint === 0) {
              self._currentDrag.content.style[ionic.CSS.TRANSFORM] = '';
              var buttons = self._currentDrag.buttons;
              setTimeout(function() {
                buttons && buttons.classList.add('invisible');
              }, 250);
            } else {
              self._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + restingPoint + 'px,0,0)';
            }
            self._currentDrag.content.style[ionic.CSS.TRANSITION] = '';
            if (!self._lastDrag) {
              self._lastDrag = {};
            }
            ionic.extend(self._lastDrag, self._currentDrag);
            if (self._currentDrag) {
              self._currentDrag.buttons = null;
              self._currentDrag.content = null;
            }
            self._currentDrag = null;
            doneCallback && doneCallback();
          });
        };
        var ReorderDrag = function(opts) {
          var self = this;
          self.dragThresholdY = opts.dragThresholdY || 0;
          self.onReorder = opts.onReorder;
          self.listEl = opts.listEl;
          self.el = self.item = opts.el;
          self.scrollEl = opts.scrollEl;
          self.scrollView = opts.scrollView;
          self.listElTrueTop = 0;
          if (self.listEl.offsetParent) {
            var obj = self.listEl;
            do {
              self.listElTrueTop += obj.offsetTop;
              obj = obj.offsetParent;
            } while (obj);
          }
        };
        ReorderDrag.prototype = new DragOp();
        ReorderDrag.prototype._moveElement = function(e) {
          var y = e.gesture.center.pageY + this.scrollView.getValues().top - (this._currentDrag.elementHeight / 2) - this.listElTrueTop;
          this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(0, ' + y + 'px, 0)';
        };
        ReorderDrag.prototype.deregister = function() {
          this.listEl = this.el = this.scrollEl = this.scrollView = null;
        };
        ReorderDrag.prototype.start = function(e) {
          var startIndex = ionic.DomUtil.getChildIndex(this.el, this.el.nodeName.toLowerCase());
          var elementHeight = this.el.scrollHeight;
          var placeholder = this.el.cloneNode(true);
          placeholder.classList.add(ITEM_PLACEHOLDER_CLASS);
          this.el.parentNode.insertBefore(placeholder, this.el);
          this.el.classList.add(ITEM_REORDERING_CLASS);
          this._currentDrag = {
            elementHeight: elementHeight,
            startIndex: startIndex,
            placeholder: placeholder,
            scrollHeight: scroll,
            list: placeholder.parentNode
          };
          this._moveElement(e);
        };
        ReorderDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
          var self = this;
          if (!this._currentDrag) {
            return;
          }
          var scrollY = 0;
          var pageY = e.gesture.center.pageY;
          var offset = this.listElTrueTop;
          if (this.scrollView) {
            var container = this.scrollView.__container;
            scrollY = this.scrollView.getValues().top;
            var containerTop = container.offsetTop;
            var pixelsPastTop = containerTop - pageY + this._currentDrag.elementHeight / 2;
            var pixelsPastBottom = pageY + this._currentDrag.elementHeight / 2 - containerTop - container.offsetHeight;
            if (e.gesture.deltaY < 0 && pixelsPastTop > 0 && scrollY > 0) {
              this.scrollView.scrollBy(null, -pixelsPastTop);
              ionic.requestAnimationFrame(function() {
                self.drag(e);
              });
            }
            if (e.gesture.deltaY > 0 && pixelsPastBottom > 0) {
              if (scrollY < this.scrollView.getScrollMax().top) {
                this.scrollView.scrollBy(null, pixelsPastBottom);
                ionic.requestAnimationFrame(function() {
                  self.drag(e);
                });
              }
            }
          }
          if (!this._isDragging && Math.abs(e.gesture.deltaY) > this.dragThresholdY) {
            this._isDragging = true;
          }
          if (this._isDragging) {
            this._moveElement(e);
            this._currentDrag.currentY = scrollY + pageY - offset;
          }
        });
        ReorderDrag.prototype._getReorderIndex = function() {
          var self = this;
          var siblings = Array.prototype.slice.call(self._currentDrag.placeholder.parentNode.children).filter(function(el) {
            return el.nodeName === self.el.nodeName && el !== self.el;
          });
          var dragOffsetTop = self._currentDrag.currentY;
          var el;
          for (var i = 0,
              len = siblings.length; i < len; i++) {
            el = siblings[i];
            if (i === len - 1) {
              if (dragOffsetTop > el.offsetTop) {
                return i;
              }
            } else if (i === 0) {
              if (dragOffsetTop < el.offsetTop + el.offsetHeight) {
                return i;
              }
            } else if (dragOffsetTop > el.offsetTop - el.offsetHeight / 2 && dragOffsetTop < el.offsetTop + el.offsetHeight) {
              return i;
            }
          }
          return self._currentDrag.startIndex;
        };
        ReorderDrag.prototype.end = function(e, doneCallback) {
          if (!this._currentDrag) {
            doneCallback && doneCallback();
            return;
          }
          var placeholder = this._currentDrag.placeholder;
          var finalIndex = this._getReorderIndex();
          this.el.classList.remove(ITEM_REORDERING_CLASS);
          this.el.style[ionic.CSS.TRANSFORM] = '';
          placeholder.parentNode.insertBefore(this.el, placeholder);
          placeholder.parentNode.removeChild(placeholder);
          this.onReorder && this.onReorder(this.el, this._currentDrag.startIndex, finalIndex);
          this._currentDrag = {
            placeholder: null,
            content: null
          };
          this._currentDrag = null;
          doneCallback && doneCallback();
        };
        ionic.views.ListView = ionic.views.View.inherit({
          initialize: function(opts) {
            var self = this;
            opts = ionic.extend({
              onReorder: function() {},
              virtualRemoveThreshold: -200,
              virtualAddThreshold: 200,
              canSwipe: function() {
                return true;
              }
            }, opts);
            ionic.extend(self, opts);
            if (!self.itemHeight && self.listEl) {
              self.itemHeight = self.listEl.children[0] && parseInt(self.listEl.children[0].style.height, 10);
            }
            self.onRefresh = opts.onRefresh || function() {};
            self.onRefreshOpening = opts.onRefreshOpening || function() {};
            self.onRefreshHolding = opts.onRefreshHolding || function() {};
            var gestureOpts = {};
            if (ionic.DomUtil.getParentOrSelfWithClass(self.el, 'overflow-scroll')) {
              gestureOpts.prevent_default_directions = ['left', 'right'];
            }
            window.ionic.onGesture('release', function(e) {
              self._handleEndDrag(e);
            }, self.el, gestureOpts);
            window.ionic.onGesture('drag', function(e) {
              self._handleDrag(e);
            }, self.el, gestureOpts);
            self._initDrag();
          },
          deregister: function() {
            this.el = this.listEl = this.scrollEl = this.scrollView = null;
            if (this.isScrollFreeze) {
              self.scrollView.freeze(false);
            }
          },
          stopRefreshing: function() {
            var refresher = this.el.querySelector('.list-refresher');
            refresher.style.height = '0';
          },
          didScroll: function(e) {
            var self = this;
            if (self.isVirtual) {
              var itemHeight = self.itemHeight;
              var scrollHeight = e.target.scrollHeight;
              var viewportHeight = self.el.parentNode.offsetHeight;
              var highWater = Math.max(0, e.scrollTop + self.virtualRemoveThreshold);
              var lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + self.virtualAddThreshold);
              var first = parseInt(Math.abs(highWater / itemHeight), 10);
              var last = parseInt(Math.abs(lowWater / itemHeight), 10);
              self._virtualItemsToRemove = Array.prototype.slice.call(self.listEl.children, 0, first);
              self.renderViewport && self.renderViewport(highWater, lowWater, first, last);
            }
          },
          didStopScrolling: function() {
            if (this.isVirtual) {
              for (var i = 0; i < this._virtualItemsToRemove.length; i++) {
                this.didHideItem && this.didHideItem(i);
              }
            }
          },
          clearDragEffects: function(isInstant) {
            if (this._lastDragOp) {
              this._lastDragOp.clean && this._lastDragOp.clean(isInstant);
              this._lastDragOp.deregister && this._lastDragOp.deregister();
              this._lastDragOp = null;
            }
          },
          _initDrag: function() {
            if (this._lastDragOp) {
              this._lastDragOp.deregister && this._lastDragOp.deregister();
            }
            this._lastDragOp = this._dragOp;
            this._dragOp = null;
          },
          _getItem: function(target) {
            while (target) {
              if (target.classList && target.classList.contains(ITEM_CLASS)) {
                return target;
              }
              target = target.parentNode;
            }
            return null;
          },
          _startDrag: function(e) {
            var self = this;
            self._isDragging = false;
            var lastDragOp = self._lastDragOp;
            var item;
            if (self._didDragUpOrDown && lastDragOp instanceof SlideDrag) {
              lastDragOp.clean && lastDragOp.clean();
            }
            if (ionic.DomUtil.getParentOrSelfWithClass(e.target, ITEM_REORDER_BTN_CLASS) && (e.gesture.direction == 'up' || e.gesture.direction == 'down')) {
              item = self._getItem(e.target);
              if (item) {
                self._dragOp = new ReorderDrag({
                  listEl: self.el,
                  el: item,
                  scrollEl: self.scrollEl,
                  scrollView: self.scrollView,
                  onReorder: function(el, start, end) {
                    self.onReorder && self.onReorder(el, start, end);
                  }
                });
                self._dragOp.start(e);
                e.preventDefault();
              }
            } else if (!self._didDragUpOrDown && (e.gesture.direction == 'left' || e.gesture.direction == 'right') && Math.abs(e.gesture.deltaX) > 5) {
              item = self._getItem(e.target);
              if (item && item.querySelector('.item-options')) {
                self._dragOp = new SlideDrag({
                  el: self.el,
                  item: item,
                  canSwipe: self.canSwipe
                });
                self._dragOp.start(e);
                e.preventDefault();
                self.isScrollFreeze = self.scrollView.freeze(true);
              }
            }
            if (lastDragOp && self._dragOp && !self._dragOp.isSameItem(lastDragOp) && e.defaultPrevented) {
              lastDragOp.clean && lastDragOp.clean();
            }
          },
          _handleEndDrag: function(e) {
            var self = this;
            if (self.scrollView) {
              self.isScrollFreeze = self.scrollView.freeze(false);
            }
            self._didDragUpOrDown = false;
            if (!self._dragOp) {
              return;
            }
            self._dragOp.end(e, function() {
              self._initDrag();
            });
          },
          _handleDrag: function(e) {
            var self = this;
            if (Math.abs(e.gesture.deltaY) > 5) {
              self._didDragUpOrDown = true;
            }
            if (!self.isDragging && !self._dragOp) {
              self._startDrag(e);
            }
            if (!self._dragOp) {
              return;
            }
            e.gesture.srcEvent.preventDefault();
            self._dragOp.drag(e);
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Modal = ionic.views.View.inherit({
          initialize: function(opts) {
            opts = ionic.extend({
              focusFirstInput: false,
              unfocusOnHide: true,
              focusFirstDelay: 600,
              backdropClickToClose: true,
              hardwareBackButtonClose: true
            }, opts);
            ionic.extend(this, opts);
            this.el = opts.el;
          },
          show: function() {
            var self = this;
            if (self.focusFirstInput) {
              window.setTimeout(function() {
                var input = self.el.querySelector('input, textarea');
                input && input.focus && input.focus();
              }, self.focusFirstDelay);
            }
          },
          hide: function() {
            if (this.unfocusOnHide) {
              var inputs = this.el.querySelectorAll('input, textarea');
              window.setTimeout(function() {
                for (var i = 0; i < inputs.length; i++) {
                  inputs[i].blur && inputs[i].blur();
                }
              });
            }
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.SideMenu = ionic.views.View.inherit({
          initialize: function(opts) {
            this.el = opts.el;
            this.isEnabled = (typeof opts.isEnabled === 'undefined') ? true : opts.isEnabled;
            this.setWidth(opts.width);
          },
          getFullWidth: function() {
            return this.width;
          },
          setWidth: function(width) {
            this.width = width;
            this.el.style.width = width + 'px';
          },
          setIsEnabled: function(isEnabled) {
            this.isEnabled = isEnabled;
          },
          bringUp: function() {
            if (this.el.style.zIndex !== '0') {
              this.el.style.zIndex = '0';
            }
          },
          pushDown: function() {
            if (this.el.style.zIndex !== '-1') {
              this.el.style.zIndex = '-1';
            }
          }
        });
        ionic.views.SideMenuContent = ionic.views.View.inherit({
          initialize: function(opts) {
            ionic.extend(this, {
              animationClass: 'menu-animated',
              onDrag: function() {},
              onEndDrag: function() {}
            }, opts);
            ionic.onGesture('drag', ionic.proxy(this._onDrag, this), this.el);
            ionic.onGesture('release', ionic.proxy(this._onEndDrag, this), this.el);
          },
          _onDrag: function(e) {
            this.onDrag && this.onDrag(e);
          },
          _onEndDrag: function(e) {
            this.onEndDrag && this.onEndDrag(e);
          },
          disableAnimation: function() {
            this.el.classList.remove(this.animationClass);
          },
          enableAnimation: function() {
            this.el.classList.add(this.animationClass);
          },
          getTranslateX: function() {
            return parseFloat(this.el.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]);
          },
          setTranslateX: ionic.animationFrameThrottle(function(x) {
            this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(' + x + 'px, 0, 0)';
          })
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Slider = ionic.views.View.inherit({initialize: function(options) {
            var slider = this;
            var noop = function() {};
            var offloadFn = function(fn) {
              setTimeout(fn || noop, 0);
            };
            var browser = {
              addEventListener: !!window.addEventListener,
              touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,
              transitions: (function(temp) {
                var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
                for (var i in props)
                  if (temp.style[props[i]] !== undefined)
                    return true;
                return false;
              })(document.createElement('swipe'))
            };
            var container = options.el;
            if (!container)
              return;
            var element = container.children[0];
            var slides,
                slidePos,
                width,
                length;
            options = options || {};
            var index = parseInt(options.startSlide, 10) || 0;
            var speed = options.speed || 300;
            options.continuous = options.continuous !== undefined ? options.continuous : true;
            function setup() {
              if (!container.offsetWidth) {
                return;
              }
              slides = element.children;
              length = slides.length;
              if (slides.length < 2)
                options.continuous = false;
              if (browser.transitions && options.continuous && slides.length < 3) {
                element.appendChild(slides[0].cloneNode(true));
                element.appendChild(element.children[1].cloneNode(true));
                slides = element.children;
              }
              slidePos = new Array(slides.length);
              width = container.offsetWidth || container.getBoundingClientRect().width;
              element.style.width = (slides.length * width) + 'px';
              var pos = slides.length;
              while (pos--) {
                var slide = slides[pos];
                slide.style.width = width + 'px';
                slide.setAttribute('data-index', pos);
                if (browser.transitions) {
                  slide.style.left = (pos * -width) + 'px';
                  move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
                }
              }
              if (options.continuous && browser.transitions) {
                move(circle(index - 1), -width, 0);
                move(circle(index + 1), width, 0);
              }
              if (!browser.transitions)
                element.style.left = (index * -width) + 'px';
              container.style.visibility = 'visible';
              options.slidesChanged && options.slidesChanged();
            }
            function prev(slideSpeed) {
              if (options.continuous)
                slide(index - 1, slideSpeed);
              else if (index)
                slide(index - 1, slideSpeed);
            }
            function next(slideSpeed) {
              if (options.continuous)
                slide(index + 1, slideSpeed);
              else if (index < slides.length - 1)
                slide(index + 1, slideSpeed);
            }
            function circle(index) {
              return (slides.length + (index % slides.length)) % slides.length;
            }
            function slide(to, slideSpeed) {
              if (index == to)
                return;
              if (browser.transitions) {
                var direction = Math.abs(index - to) / (index - to);
                if (options.continuous) {
                  var naturalDirection = direction;
                  direction = -slidePos[circle(to)] / width;
                  if (direction !== naturalDirection)
                    to = -direction * slides.length + to;
                }
                var diff = Math.abs(index - to) - 1;
                while (diff--)
                  move(circle((to > index ? to : index) - diff - 1), width * direction, 0);
                to = circle(to);
                move(index, width * direction, slideSpeed || speed);
                move(to, 0, slideSpeed || speed);
                if (options.continuous)
                  move(circle(to - direction), -(width * direction), 0);
              } else {
                to = circle(to);
                animate(index * -width, to * -width, slideSpeed || speed);
              }
              index = to;
              offloadFn(options.callback && options.callback(index, slides[index]));
            }
            function move(index, dist, speed) {
              translate(index, dist, speed);
              slidePos[index] = dist;
            }
            function translate(index, dist, speed) {
              var slide = slides[index];
              var style = slide && slide.style;
              if (!style)
                return;
              style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + 'ms';
              style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
              style.msTransform = style.MozTransform = style.OTransform = 'translateX(' + dist + 'px)';
            }
            function animate(from, to, speed) {
              if (!speed) {
                element.style.left = to + 'px';
                return;
              }
              var start = +new Date();
              var timer = setInterval(function() {
                var timeElap = +new Date() - start;
                if (timeElap > speed) {
                  element.style.left = to + 'px';
                  if (delay)
                    begin();
                  options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                  clearInterval(timer);
                  return;
                }
                element.style.left = (((to - from) * (Math.floor((timeElap / speed) * 100) / 100)) + from) + 'px';
              }, 4);
            }
            var delay = options.auto || 0;
            var interval;
            function begin() {
              interval = setTimeout(next, delay);
            }
            function stop() {
              delay = options.auto || 0;
              clearTimeout(interval);
            }
            var start = {};
            var delta = {};
            var isScrolling;
            var events = {
              handleEvent: function(event) {
                if (event.type == 'mousedown' || event.type == 'mouseup' || event.type == 'mousemove') {
                  event.touches = [{
                    pageX: event.pageX,
                    pageY: event.pageY
                  }];
                }
                switch (event.type) {
                  case 'mousedown':
                    this.start(event);
                    break;
                  case 'touchstart':
                    this.start(event);
                    break;
                  case 'touchmove':
                    this.touchmove(event);
                    break;
                  case 'mousemove':
                    this.touchmove(event);
                    break;
                  case 'touchend':
                    offloadFn(this.end(event));
                    break;
                  case 'mouseup':
                    offloadFn(this.end(event));
                    break;
                  case 'webkitTransitionEnd':
                  case 'msTransitionEnd':
                  case 'oTransitionEnd':
                  case 'otransitionend':
                  case 'transitionend':
                    offloadFn(this.transitionEnd(event));
                    break;
                  case 'resize':
                    offloadFn(setup);
                    break;
                }
                if (options.stopPropagation)
                  event.stopPropagation();
              },
              start: function(event) {
                var touches = event.touches[0];
                start = {
                  x: touches.pageX,
                  y: touches.pageY,
                  time: +new Date()
                };
                isScrolling = undefined;
                delta = {};
                if (browser.touch) {
                  element.addEventListener('touchmove', this, false);
                  element.addEventListener('touchend', this, false);
                } else {
                  element.addEventListener('mousemove', this, false);
                  element.addEventListener('mouseup', this, false);
                  document.addEventListener('mouseup', this, false);
                }
              },
              touchmove: function(event) {
                if (event.touches.length > 1 || event.scale && event.scale !== 1 || slider.slideIsDisabled) {
                  return;
                }
                if (options.disableScroll)
                  event.preventDefault();
                var touches = event.touches[0];
                delta = {
                  x: touches.pageX - start.x,
                  y: touches.pageY - start.y
                };
                if (typeof isScrolling == 'undefined') {
                  isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
                }
                if (!isScrolling) {
                  event.preventDefault();
                  stop();
                  if (options.continuous) {
                    translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);
                  } else {
                    delta.x = delta.x / ((!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0) ? (Math.abs(delta.x) / width + 1) : 1);
                    translate(index - 1, delta.x + slidePos[index - 1], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(index + 1, delta.x + slidePos[index + 1], 0);
                  }
                  options.onDrag && options.onDrag();
                }
              },
              end: function() {
                var duration = +new Date() - start.time;
                var isValidSlide = Number(duration) < 250 && Math.abs(delta.x) > 20 || Math.abs(delta.x) > width / 2;
                var isPastBounds = (!index && delta.x > 0) || (index == slides.length - 1 && delta.x < 0);
                if (options.continuous)
                  isPastBounds = false;
                var direction = delta.x < 0;
                if (!isScrolling) {
                  if (isValidSlide && !isPastBounds) {
                    if (direction) {
                      if (options.continuous) {
                        move(circle(index - 1), -width, 0);
                        move(circle(index + 2), width, 0);
                      } else {
                        move(index - 1, -width, 0);
                      }
                      move(index, slidePos[index] - width, speed);
                      move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);
                      index = circle(index + 1);
                    } else {
                      if (options.continuous) {
                        move(circle(index + 1), width, 0);
                        move(circle(index - 2), -width, 0);
                      } else {
                        move(index + 1, width, 0);
                      }
                      move(index, slidePos[index] + width, speed);
                      move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);
                      index = circle(index - 1);
                    }
                    options.callback && options.callback(index, slides[index]);
                  } else {
                    if (options.continuous) {
                      move(circle(index - 1), -width, speed);
                      move(index, 0, speed);
                      move(circle(index + 1), width, speed);
                    } else {
                      move(index - 1, -width, speed);
                      move(index, 0, speed);
                      move(index + 1, width, speed);
                    }
                  }
                }
                if (browser.touch) {
                  element.removeEventListener('touchmove', events, false);
                  element.removeEventListener('touchend', events, false);
                } else {
                  element.removeEventListener('mousemove', events, false);
                  element.removeEventListener('mouseup', events, false);
                  document.removeEventListener('mouseup', events, false);
                }
                options.onDragEnd && options.onDragEnd();
              },
              transitionEnd: function(event) {
                if (parseInt(event.target.getAttribute('data-index'), 10) == index) {
                  if (delay)
                    begin();
                  options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                }
              }
            };
            this.update = function() {
              setTimeout(setup);
            };
            this.setup = function() {
              setup();
            };
            this.loop = function(value) {
              if (arguments.length)
                options.continuous = !!value;
              return options.continuous;
            };
            this.enableSlide = function(shouldEnable) {
              if (arguments.length) {
                this.slideIsDisabled = !shouldEnable;
              }
              return !this.slideIsDisabled;
            };
            this.slide = this.select = function(to, speed) {
              stop();
              slide(to, speed);
            };
            this.prev = this.previous = function() {
              stop();
              prev();
            };
            this.next = function() {
              stop();
              next();
            };
            this.stop = function() {
              stop();
            };
            this.start = function() {
              begin();
            };
            this.autoPlay = function(newDelay) {
              if (!delay || delay < 0) {
                stop();
              } else {
                delay = newDelay;
                begin();
              }
            };
            this.currentIndex = this.selected = function() {
              return index;
            };
            this.slidesCount = this.count = function() {
              return length;
            };
            this.kill = function() {
              stop();
              element.style.width = '';
              element.style.left = '';
              slides && (slides = []);
              if (browser.addEventListener) {
                element.removeEventListener('touchstart', events, false);
                element.removeEventListener('webkitTransitionEnd', events, false);
                element.removeEventListener('msTransitionEnd', events, false);
                element.removeEventListener('oTransitionEnd', events, false);
                element.removeEventListener('otransitionend', events, false);
                element.removeEventListener('transitionend', events, false);
                window.removeEventListener('resize', events, false);
              } else {
                window.onresize = null;
              }
            };
            this.load = function() {
              setup();
              if (delay)
                begin();
              if (browser.addEventListener) {
                if (browser.touch) {
                  element.addEventListener('touchstart', events, false);
                } else {
                  element.addEventListener('mousedown', events, false);
                }
                if (browser.transitions) {
                  element.addEventListener('webkitTransitionEnd', events, false);
                  element.addEventListener('msTransitionEnd', events, false);
                  element.addEventListener('oTransitionEnd', events, false);
                  element.addEventListener('otransitionend', events, false);
                  element.addEventListener('transitionend', events, false);
                }
                window.addEventListener('resize', events, false);
              } else {
                window.onresize = function() {
                  setup();
                };
              }
            };
          }});
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Toggle = ionic.views.View.inherit({
          initialize: function(opts) {
            var self = this;
            this.el = opts.el;
            this.checkbox = opts.checkbox;
            this.track = opts.track;
            this.handle = opts.handle;
            this.openPercent = -1;
            this.onChange = opts.onChange || function() {};
            this.triggerThreshold = opts.triggerThreshold || 20;
            this.dragStartHandler = function(e) {
              self.dragStart(e);
            };
            this.dragHandler = function(e) {
              self.drag(e);
            };
            this.holdHandler = function(e) {
              self.hold(e);
            };
            this.releaseHandler = function(e) {
              self.release(e);
            };
            this.dragStartGesture = ionic.onGesture('dragstart', this.dragStartHandler, this.el);
            this.dragGesture = ionic.onGesture('drag', this.dragHandler, this.el);
            this.dragHoldGesture = ionic.onGesture('hold', this.holdHandler, this.el);
            this.dragReleaseGesture = ionic.onGesture('release', this.releaseHandler, this.el);
          },
          destroy: function() {
            ionic.offGesture(this.dragStartGesture, 'dragstart', this.dragStartGesture);
            ionic.offGesture(this.dragGesture, 'drag', this.dragGesture);
            ionic.offGesture(this.dragHoldGesture, 'hold', this.holdHandler);
            ionic.offGesture(this.dragReleaseGesture, 'release', this.releaseHandler);
          },
          tap: function() {
            if (this.el.getAttribute('disabled') !== 'disabled') {
              this.val(!this.checkbox.checked);
            }
          },
          dragStart: function(e) {
            if (this.checkbox.disabled)
              return;
            this._dragInfo = {
              width: this.el.offsetWidth,
              left: this.el.offsetLeft,
              right: this.el.offsetLeft + this.el.offsetWidth,
              triggerX: this.el.offsetWidth / 2,
              initialState: this.checkbox.checked
            };
            e.gesture.srcEvent.preventDefault();
            this.hold(e);
          },
          drag: function(e) {
            var self = this;
            if (!this._dragInfo) {
              return;
            }
            e.gesture.srcEvent.preventDefault();
            ionic.requestAnimationFrame(function() {
              if (!self._dragInfo) {
                return;
              }
              var px = e.gesture.touches[0].pageX - self._dragInfo.left;
              var mx = self._dragInfo.width - self.triggerThreshold;
              if (self._dragInfo.initialState) {
                if (px < self.triggerThreshold) {
                  self.setOpenPercent(0);
                } else if (px > self._dragInfo.triggerX) {
                  self.setOpenPercent(100);
                }
              } else {
                if (px < self._dragInfo.triggerX) {
                  self.setOpenPercent(0);
                } else if (px > mx) {
                  self.setOpenPercent(100);
                }
              }
            });
          },
          endDrag: function() {
            this._dragInfo = null;
          },
          hold: function() {
            this.el.classList.add('dragging');
          },
          release: function(e) {
            this.el.classList.remove('dragging');
            this.endDrag(e);
          },
          setOpenPercent: function(openPercent) {
            if (this.openPercent < 0 || (openPercent < (this.openPercent - 3) || openPercent > (this.openPercent + 3))) {
              this.openPercent = openPercent;
              if (openPercent === 0) {
                this.val(false);
              } else if (openPercent === 100) {
                this.val(true);
              } else {
                var openPixel = Math.round((openPercent / 100) * this.track.offsetWidth - (this.handle.offsetWidth));
                openPixel = (openPixel < 1 ? 0 : openPixel);
                this.handle.style[ionic.CSS.TRANSFORM] = 'translate3d(' + openPixel + 'px,0,0)';
              }
            }
          },
          val: function(value) {
            if (value === true || value === false) {
              if (this.handle.style[ionic.CSS.TRANSFORM] !== "") {
                this.handle.style[ionic.CSS.TRANSFORM] = "";
              }
              this.checkbox.checked = value;
              this.openPercent = (value ? 100 : 0);
              this.onChange && this.onChange();
            }
            return this.checkbox.checked;
          }
        });
      })(ionic);
    })();
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-animate@1.4.7/angular-animate", ["github:angular/bower-angular@1.4.7"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var noop = angular.noop;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return [];
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationOptions(element, target, newOptions) {
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = [function() {
        return function(scope, element, attrs) {
          var val = attrs.ngAnimateChildren;
          if (angular.isString(val) && val.length === 0) {
            element.data(NG_ANIMATE_CHILDREN_DATA, true);
          } else {
            attrs.$observe('ngAnimateChildren', function(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            });
          }
        };
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $animate) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, options) {
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$animate.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            options = prepareAnimationOptions(options);
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle = parseFloat(options.delay);
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var startTime,
                  events = [];
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                element.on(events.join(' '), onAnimationProgress);
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
              function onAnimationProgress(event) {
                event.stopPropagation();
                var ev = event.originalEvent || event;
                var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
                var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                  animationCompleted = true;
                  close();
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            return {start: function() {
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                var animationClosed = false;
                var runner = new $$AnimateRunner({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  animationClosed = true;
                  applyOptions();
                  applyAnimationStyles(element, options);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }};
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(options, and) {
          options = options || {};
          var a = (options.addClass || '').length > 0;
          var b = (options.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation.options);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          var nO = newAnimation.options;
          var cO = currentAnimation.options;
          return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationOptions(element, options) {
            return mergeAnimationOptions(element, options, {});
          }
          function findCallbacks(element, event) {
            var targetNode = getDomNode(element);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (entry.node.contains(targetNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          return {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
            },
            off: function(event, container, callback) {
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
              function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                  var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                  return !isMatch;
                });
              }
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    bool = !!bool;
                    if (!bool) {
                      disabledElementsLookup.put(node, true);
                    } else if (recordExists) {
                      disabledElementsLookup.remove(node);
                    }
                  }
                }
              }
              return bool;
            }
          };
          function queueAnimation(element, event, options) {
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              close();
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationOptions(element, existingAnimation.options, options);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationOptions(element, options);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationOptions(element, options);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation.options);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails.options));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                  });
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              switch (state) {
                case RUNNING_STATE:
                  animationDetails.runner.end();
                case PRE_DIGEST_STATE:
                  if (animationDetails) {
                    activeAnimationsLookup.remove(child);
                  }
                  break;
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var parentHost = element.data(NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            while (parentElement && parentElement.length) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              var parentNode = parentElement[0];
              if (parentNode.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentNode) || {};
              if (!parentAnimationDetected) {
                parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
                if (!rootElementDetected) {
                  parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);
                  if (parentHost) {
                    parentElement = parentHost;
                  }
                }
              }
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              parentElement = parentElement.parent();
            }
            var allowAnimation = !parentAnimationDetected || animateChildren;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {
        var waitQueue = [];
        function waitForTick(fn) {
          waitQueue.push(fn);
          if (waitQueue.length > 1)
            return;
          $$rAF(function() {
            for (var i = 0; i < waitQueue.length; i++) {
              waitQueue[i]();
            }
            waitQueue = [];
          });
        }
        return function() {
          var passed = false;
          waitForTick(function() {
            passed = true;
          });
          return function(callback) {
            passed ? callback() : waitForTick(callback);
          };
        };
      }];
      var $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun', function($q, $sniffer, $$animateAsyncRun) {
        var INITIAL_STATE = 0;
        var DONE_PENDING_STATE = 1;
        var DONE_COMPLETE_STATE = 2;
        AnimateRunner.chain = function(chain, callback) {
          var index = 0;
          next();
          function next() {
            if (index === chain.length) {
              callback(true);
              return;
            }
            chain[index](function(response) {
              if (response === false) {
                callback(false);
                return;
              }
              index++;
              next();
            });
          }
        };
        AnimateRunner.all = function(runners, callback) {
          var count = 0;
          var status = true;
          forEach(runners, function(runner) {
            runner.done(onProgress);
          });
          function onProgress(response) {
            status = status && response;
            if (++count === runners.length) {
              callback(status);
            }
          }
        };
        function AnimateRunner(host) {
          this.setHost(host);
          this._doneCallbacks = [];
          this._runInAnimationFrame = $$animateAsyncRun();
          this._state = 0;
        }
        AnimateRunner.prototype = {
          setHost: function(host) {
            this.host = host || {};
          },
          done: function(fn) {
            if (this._state === DONE_COMPLETE_STATE) {
              fn();
            } else {
              this._doneCallbacks.push(fn);
            }
          },
          progress: noop,
          getPromise: function() {
            if (!this.promise) {
              var self = this;
              this.promise = $q(function(resolve, reject) {
                self.done(function(status) {
                  status === false ? reject() : resolve();
                });
              });
            }
            return this.promise;
          },
          then: function(resolveHandler, rejectHandler) {
            return this.getPromise().then(resolveHandler, rejectHandler);
          },
          'catch': function(handler) {
            return this.getPromise()['catch'](handler);
          },
          'finally': function(handler) {
            return this.getPromise()['finally'](handler);
          },
          pause: function() {
            if (this.host.pause) {
              this.host.pause();
            }
          },
          resume: function() {
            if (this.host.resume) {
              this.host.resume();
            }
          },
          end: function() {
            if (this.host.end) {
              this.host.end();
            }
            this._resolve(true);
          },
          cancel: function() {
            if (this.host.cancel) {
              this.host.cancel();
            }
            this._resolve(false);
          },
          complete: function(response) {
            var self = this;
            if (self._state === INITIAL_STATE) {
              self._state = DONE_PENDING_STATE;
              self._runInAnimationFrame(function() {
                self._resolve(response);
              });
            }
          },
          _resolve: function(response) {
            if (this._state !== DONE_COMPLETE_STATE) {
              forEach(this._doneCallbacks, function(fn) {
                fn(response);
              });
              this._doneCallbacks.length = 0;
              this._state = DONE_COMPLETE_STATE;
            }
          }
        };
        return AnimateRunner;
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                if (!$injector.has(driverName))
                  continue;
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                getRunner(element).setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      angular.module('ngAnimate', []).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).factory('$$AnimateRunner', $$AnimateRunnerFactory).factory('$$animateAsyncRun', $$AnimateAsyncRunFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-animate@1.4.7", ["github:angular/bower-angular-animate@1.4.7/angular-animate"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:angular/bower-angular-animate@1.4.7/angular-animate');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-sanitize@1.4.7/angular-sanitize", ["github:angular/bower-angular@1.4.7"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      function $SanitizeProvider() {
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
      }
      var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
          END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
          ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
          BEGIN_TAG_REGEXP = /^</,
          BEGING_END_TAGE_REGEXP = /^<\//,
          COMMENT_REGEXP = /<!--(.*?)-->/g,
          DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
          CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
          SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
          NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
      var voidElements = makeMap("area,br,col,hr,img,wbr");
      var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
          optionalEndTagInlineElements = makeMap("rp,rt"),
          optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
      var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
      var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
      var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
      var specialElements = makeMap("script,style");
      var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
      var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
      var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
      var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
      var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
      function makeMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
      }
      function htmlParser(html, handler) {
        if (typeof html !== 'string') {
          if (html === null || typeof html === 'undefined') {
            html = '';
          } else {
            html = '' + html;
          }
        }
        var index,
            chars,
            match,
            stack = [],
            last = html,
            text;
        stack.last = function() {
          return stack[stack.length - 1];
        };
        while (html) {
          text = '';
          chars = true;
          if (!stack.last() || !specialElements[stack.last()]) {
            if (html.indexOf("<!--") === 0) {
              index = html.indexOf("--", 4);
              if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                if (handler.comment)
                  handler.comment(html.substring(4, index));
                html = html.substring(index + 3);
                chars = false;
              }
            } else if (DOCTYPE_REGEXP.test(html)) {
              match = html.match(DOCTYPE_REGEXP);
              if (match) {
                html = html.replace(match[0], '');
                chars = false;
              }
            } else if (BEGING_END_TAGE_REGEXP.test(html)) {
              match = html.match(END_TAG_REGEXP);
              if (match) {
                html = html.substring(match[0].length);
                match[0].replace(END_TAG_REGEXP, parseEndTag);
                chars = false;
              }
            } else if (BEGIN_TAG_REGEXP.test(html)) {
              match = html.match(START_TAG_REGEXP);
              if (match) {
                if (match[4]) {
                  html = html.substring(match[0].length);
                  match[0].replace(START_TAG_REGEXP, parseStartTag);
                }
                chars = false;
              } else {
                text += '<';
                html = html.substring(1);
              }
            }
            if (chars) {
              index = html.indexOf("<");
              text += index < 0 ? html : html.substring(0, index);
              html = index < 0 ? "" : html.substring(index);
              if (handler.chars)
                handler.chars(decodeEntities(text));
            }
          } else {
            html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'), function(all, text) {
              text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
              if (handler.chars)
                handler.chars(decodeEntities(text));
              return "";
            });
            parseEndTag("", stack.last());
          }
          if (html == last) {
            throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " + "of html: {0}", html);
          }
          last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
          tagName = angular.lowercase(tagName);
          if (blockElements[tagName]) {
            while (stack.last() && inlineElements[stack.last()]) {
              parseEndTag("", stack.last());
            }
          }
          if (optionalEndTagElements[tagName] && stack.last() == tagName) {
            parseEndTag("", tagName);
          }
          unary = voidElements[tagName] || !!unary;
          if (!unary) {
            stack.push(tagName);
          }
          var attrs = {};
          rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
            var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';
            attrs[name] = decodeEntities(value);
          });
          if (handler.start)
            handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
          var pos = 0,
              i;
          tagName = angular.lowercase(tagName);
          if (tagName) {
            for (pos = stack.length - 1; pos >= 0; pos--) {
              if (stack[pos] == tagName)
                break;
            }
          }
          if (pos >= 0) {
            for (i = stack.length - 1; i >= pos; i--)
              if (handler.end)
                handler.end(stack[i]);
            stack.length = pos;
          }
        }
      }
      var hiddenPre = document.createElement("pre");
      function decodeEntities(value) {
        if (!value) {
          return '';
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
      }
      function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
          return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
          start: function(tag, attrs, unary) {
            tag = angular.lowercase(tag);
            if (!ignore && specialElements[tag]) {
              ignore = tag;
            }
            if (!ignore && validElements[tag] === true) {
              out('<');
              out(tag);
              angular.forEach(attrs, function(value, key) {
                var lkey = angular.lowercase(key);
                var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                  out(' ');
                  out(key);
                  out('="');
                  out(encodeEntities(value));
                  out('"');
                }
              });
              out(unary ? '/>' : '>');
            }
          },
          end: function(tag) {
            tag = angular.lowercase(tag);
            if (!ignore && validElements[tag] === true) {
              out('</');
              out(tag);
              out('>');
            }
            if (tag == ignore) {
              ignore = false;
            }
          },
          chars: function(chars) {
            if (!ignore) {
              out(encodeEntities(chars));
            }
          }
        };
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;
        return function(text, target) {
          if (!text)
            return text;
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            html.push('<a ');
            if (angular.isDefined(target)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-sanitize@1.4.7", ["github:angular/bower-angular-sanitize@1.4.7/angular-sanitize"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:angular/bower-angular-sanitize@1.4.7/angular-sanitize');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/ui-router@0.2.15/angular-ui-router", ["github:angular/bower-angular@1.4.7"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')' + (optional ? "?" : "")];
              break;
            case true:
              surroundPattern = ['?(', ')?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/g, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          var param = this.params[paramName];
          var paramVal = m[i + 1];
          for (j = 0; j < param.replace; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$normalize = arrayHandler(bindTo(type, '$normalize'));
          this.name = type.name;
          this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                  return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
              },
              int: {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              bool: {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              date: {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            return config.type instanceof Type ? config.type : new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = injector.invoke(config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
              throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
            return defaultValue;
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var keys = this.$$keys(),
                i,
                param,
                rawVal,
                normalized,
                encoded;
            for (i = 0; i < keys.length; i++) {
              param = this[keys[i]];
              rawVal = paramValues[keys[i]];
              if ((rawVal === undefined || rawVal === null) && param.isOptional)
                break;
              normalized = param.type.$normalize(rawVal);
              if (!param.type.is(normalized))
                return false;
              encoded = param.type.encode(normalized);
              if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                return false;
            }
            return true;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
        function $get($location, $rootScope, $injector, $browser) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return;
              }
              if ($location.url() === location)
                return;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              var url = urlMatcher.format(params || {});
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              $location.url(url);
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = extend({}, state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "'' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload(state) {
            return $state.transitionTo($state.current, $stateParams, {
              reload: state || true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            var hash = toParams['#'];
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            } else if (isString(options.reload) || isObject(options.reload)) {
              if (isObject(options.reload) && !options.reload.name) {
                throw new Error('Invalid reload state object');
              }
              var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
              if (options.reload && !reloadState) {
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
              }
              while (state && state === fromPath[keep] && state !== reloadState) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
              if (hash)
                toParams['#'] = hash;
              $state.params = toParams;
              copy($state.params, $stateParams);
              if (options.location && to.navigable && to.navigable.url) {
                $urlRouter.push(to.navigable.url, toParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
                $urlRouter.update(true);
              }
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if (hash)
                toParams['#'] = hash;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            function resolveViews() {
              var viewsPromises = [];
              forEach(state.views, function(view, name) {
                var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                injectables.$template = [function() {
                  return $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify
                  }) || '';
                }];
                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                  if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                    var injectLocals = angular.extend({}, injectables, dst.globals);
                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  dst[name] = result;
                }));
              });
              return $q.all(viewsPromises).then(function() {
                return dst.globals;
              });
            }
            return $q.all(promises).then(resolveViews).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
          function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
            function notSearchParam(key) {
              return fromAndToState.params[key].location != "search";
            }
            var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
            var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
            var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
            return nonQueryParamSet.$$equals(fromParams, toParams);
          }
          if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              if (result && options.notify) {
                $rootScope.$broadcast('$viewContentLoading', options);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            return $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = function() {
            return {
              enter: function(element, target, cb) {
                target.after(element);
                cb();
              },
              leave: function(element, cb) {
                element.remove();
                cb();
              }
            };
          };
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                var promise = $animate.enter(element, null, target, cb);
                if (promise && promise.then)
                  promise.then(cb);
              },
              leave: function(element, cb) {
                var promise = $animate.leave(element, cb);
                if (promise && promise.then)
                  promise.then(cb);
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics();
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                if (previousEl) {
                  previousEl.remove();
                  previousEl = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    previousEl = null;
                  });
                  previousEl = currentEl;
                  currentEl = null;
                }
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals)
                  return;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded');
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                locals.$element = $element;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var params = null,
                url = null,
                base = stateContext(element) || $state.$current;
            var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
            var newHref = null,
                isAnchor = element.prop("tagName").toUpperCase() === "A";
            var isForm = element[0].nodeName === "FORM";
            var attr = isForm ? "action" : hrefKind,
                nav = true;
            var options = {
              relative: base,
              inherit: true
            };
            var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
            angular.forEach(allowedOptions, function(option) {
              if (option in optionsOverride) {
                options[option] = optionsOverride[option];
              }
            });
            var update = function(newVal) {
              if (newVal)
                params = angular.copy(newVal);
              if (!nav)
                return;
              newHref = $state.href(ref.state, params, options);
              var activeDirective = uiSrefActive[1] || uiSrefActive[0];
              if (activeDirective) {
                activeDirective.$$addStateInfo(ref.state, params);
              }
              if (newHref === null) {
                nav = false;
                return false;
              }
              attrs.$set(attr, newHref);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                if (newVal !== params)
                  update(newVal);
              }, true);
              params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (isForm)
              return;
            element.bind("click", function(e) {
              var button = e.which || e.button;
              if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                var transition = $timeout(function() {
                  $state.go(ref.state, params, options);
                });
                e.preventDefault();
                var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                e.preventDefault = function() {
                  if (ignorePreventDefaultCount-- <= 0)
                    $timeout.cancel(transition);
                };
              }
            });
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var states = [],
                activeClass;
            activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
            this.$$addStateInfo = function(newState, newParams) {
              var state = $state.get(newState, stateContext($element));
              states.push({
                state: state || {name: newState},
                params: newParams
              });
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function update() {
              if (anyMatch()) {
                $element.addClass(activeClass);
              } else {
                $element.removeClass(activeClass);
              }
            }
            function anyMatch() {
              for (var i = 0; i < states.length; i++) {
                if (isMatch(states[i].state, states[i].params)) {
                  return true;
                }
              }
              return false;
            }
            function isMatch(state, params) {
              if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
                return $state.is(state.name, params);
              } else {
                return $state.includes(state.name, params);
              }
            }
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state) {
          return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
          return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular-ui/ui-router@0.2.15", ["github:angular-ui/ui-router@0.2.15/angular-ui-router"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:angular-ui/ui-router@0.2.15/angular-ui-router');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("libraries/ionic/ionic-angular-library.js", ["libraries/ionic/ionic-library.js", "github:angular/bower-angular@1.4.7", "github:angular/bower-angular-animate@1.4.7", "github:angular/bower-angular-sanitize@1.4.7", "github:angular-ui/ui-router@0.2.15"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps ./ionic-library";
    "deps angular";
    "deps angular-animate";
    "deps angular-sanitize";
    "deps angular-ui-router";
    (function() {
      var IonicModule = angular.module('ionic', ['ngAnimate', 'ngSanitize', 'ui.router']),
          extend = angular.extend,
          forEach = angular.forEach,
          isDefined = angular.isDefined,
          isNumber = angular.isNumber,
          isString = angular.isString,
          jqLite = angular.element,
          noop = angular.noop;
      IonicModule.factory('$ionicActionSheet', ['$rootScope', '$compile', '$animate', '$timeout', '$ionicTemplateLoader', '$ionicPlatform', '$ionicBody', 'IONIC_BACK_PRIORITY', function($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody, IONIC_BACK_PRIORITY) {
        return {show: actionSheet};
        function actionSheet(opts) {
          var scope = $rootScope.$new(true);
          extend(scope, {
            cancel: noop,
            destructiveButtonClicked: noop,
            buttonClicked: noop,
            $deregisterBackButton: noop,
            buttons: [],
            cancelOnStateChange: true
          }, opts || {});
          function textForIcon(text) {
            if (text && /icon/.test(text)) {
              scope.$actionSheetHasIcon = true;
            }
          }
          for (var x = 0; x < scope.buttons.length; x++) {
            textForIcon(scope.buttons[x].text);
          }
          textForIcon(scope.cancelText);
          textForIcon(scope.destructiveText);
          var element = scope.element = $compile('<ion-action-sheet ng-class="cssClass" buttons="buttons"></ion-action-sheet>')(scope);
          var sheetEl = jqLite(element[0].querySelector('.action-sheet-wrapper'));
          var stateChangeListenDone = scope.cancelOnStateChange ? $rootScope.$on('$stateChangeSuccess', function() {
            scope.cancel();
          }) : noop;
          scope.removeSheet = function(done) {
            if (scope.removed)
              return;
            scope.removed = true;
            sheetEl.removeClass('action-sheet-up');
            $timeout(function() {
              $ionicBody.removeClass('action-sheet-open');
            }, 400);
            scope.$deregisterBackButton();
            stateChangeListenDone();
            $animate.removeClass(element, 'active').then(function() {
              scope.$destroy();
              element.remove();
              scope.cancel.$scope = sheetEl = null;
              (done || noop)();
            });
          };
          scope.showSheet = function(done) {
            if (scope.removed)
              return;
            $ionicBody.append(element).addClass('action-sheet-open');
            $animate.addClass(element, 'active').then(function() {
              if (scope.removed)
                return;
              (done || noop)();
            });
            $timeout(function() {
              if (scope.removed)
                return;
              sheetEl.addClass('action-sheet-up');
            }, 20, false);
          };
          scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(function() {
            $timeout(scope.cancel);
          }, IONIC_BACK_PRIORITY.actionSheet);
          scope.cancel = function() {
            scope.removeSheet(opts.cancel);
          };
          scope.buttonClicked = function(index) {
            if (opts.buttonClicked(index, opts.buttons[index]) === true) {
              scope.removeSheet();
            }
          };
          scope.destructiveButtonClicked = function() {
            if (opts.destructiveButtonClicked() === true) {
              scope.removeSheet();
            }
          };
          scope.showSheet();
          scope.cancel.$scope = scope;
          return scope.cancel;
        }
      }]);
      jqLite.prototype.addClass = function(cssClasses) {
        var x,
            y,
            cssClass,
            el,
            splitClasses,
            existingClasses;
        if (cssClasses && cssClasses != 'ng-scope' && cssClasses != 'ng-isolate-scope') {
          for (x = 0; x < this.length; x++) {
            el = this[x];
            if (el.setAttribute) {
              if (cssClasses.indexOf(' ') < 0 && el.classList.add) {
                el.classList.add(cssClasses);
              } else {
                existingClasses = (' ' + (el.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
                splitClasses = cssClasses.split(' ');
                for (y = 0; y < splitClasses.length; y++) {
                  cssClass = splitClasses[y].trim();
                  if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                    existingClasses += cssClass + ' ';
                  }
                }
                el.setAttribute('class', existingClasses.trim());
              }
            }
          }
        }
        return this;
      };
      jqLite.prototype.removeClass = function(cssClasses) {
        var x,
            y,
            splitClasses,
            cssClass,
            el;
        if (cssClasses) {
          for (x = 0; x < this.length; x++) {
            el = this[x];
            if (el.getAttribute) {
              if (cssClasses.indexOf(' ') < 0 && el.classList.remove) {
                el.classList.remove(cssClasses);
              } else {
                splitClasses = cssClasses.split(' ');
                for (y = 0; y < splitClasses.length; y++) {
                  cssClass = splitClasses[y];
                  el.setAttribute('class', ((" " + (el.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + cssClass.trim() + " ", " ")).trim());
                }
              }
            }
          }
        }
        return this;
      };
      IonicModule.factory('$ionicBackdrop', ['$document', '$timeout', '$$rAF', function($document, $timeout, $$rAF) {
        var el = jqLite('<div class="backdrop">');
        var backdropHolds = 0;
        $document[0].body.appendChild(el[0]);
        return {
          retain: retain,
          release: release,
          getElement: getElement,
          _element: el
        };
        function retain() {
          backdropHolds++;
          if (backdropHolds === 1) {
            el.addClass('visible');
            $$rAF(function() {
              if (backdropHolds >= 1)
                el.addClass('active');
            });
          }
        }
        function release() {
          if (backdropHolds === 1) {
            el.removeClass('active');
            $timeout(function() {
              if (backdropHolds === 0)
                el.removeClass('visible');
            }, 400, false);
          }
          backdropHolds = Math.max(0, backdropHolds - 1);
        }
        function getElement() {
          return el;
        }
      }]);
      IonicModule.factory('$ionicBind', ['$parse', '$interpolate', function($parse, $interpolate) {
        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
        return function(scope, attrs, bindDefinition) {
          forEach(bindDefinition || {}, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                mode = match[1],
                parentGet,
                unwatch;
            switch (mode) {
              case '@':
                if (!attrs[attrName]) {
                  return;
                }
                attrs.$observe(attrName, function(value) {
                  scope[scopeName] = value;
                });
                if (attrs[attrName]) {
                  scope[scopeName] = $interpolate(attrs[attrName])(scope);
                }
                break;
              case '=':
                if (!attrs[attrName]) {
                  return;
                }
                unwatch = scope.$watch(attrs[attrName], function(value) {
                  scope[scopeName] = value;
                });
                scope.$on('$destroy', unwatch);
                break;
              case '&':
                if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + '\(.*?\)'))) {
                  throw new Error('& expression binding "' + scopeName + '" looks like it will recursively call "' + attrs[attrName] + '" and cause a stack overflow! Please choose a different scopeName.');
                }
                parentGet = $parse(attrs[attrName]);
                scope[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });
        };
      }]);
      IonicModule.factory('$ionicBody', ['$document', function($document) {
        return {
          addClass: function() {
            for (var x = 0; x < arguments.length; x++) {
              $document[0].body.classList.add(arguments[x]);
            }
            return this;
          },
          removeClass: function() {
            for (var x = 0; x < arguments.length; x++) {
              $document[0].body.classList.remove(arguments[x]);
            }
            return this;
          },
          enableClass: function(shouldEnableClass) {
            var args = Array.prototype.slice.call(arguments).slice(1);
            if (shouldEnableClass) {
              this.addClass.apply(this, args);
            } else {
              this.removeClass.apply(this, args);
            }
            return this;
          },
          append: function(ele) {
            $document[0].body.appendChild(ele.length ? ele[0] : ele);
            return this;
          },
          get: function() {
            return $document[0].body;
          }
        };
      }]);
      IonicModule.factory('$ionicClickBlock', ['$document', '$ionicBody', '$timeout', function($document, $ionicBody, $timeout) {
        var CSS_HIDE = 'click-block-hide';
        var cbEle,
            fallbackTimer,
            pendingShow;
        function preventClick(ev) {
          ev.preventDefault();
          ev.stopPropagation();
        }
        function addClickBlock() {
          if (pendingShow) {
            if (cbEle) {
              cbEle.classList.remove(CSS_HIDE);
            } else {
              cbEle = $document[0].createElement('div');
              cbEle.className = 'click-block';
              $ionicBody.append(cbEle);
              cbEle.addEventListener('touchstart', preventClick);
              cbEle.addEventListener('mousedown', preventClick);
            }
            pendingShow = false;
          }
        }
        function removeClickBlock() {
          cbEle && cbEle.classList.add(CSS_HIDE);
        }
        return {
          show: function(autoExpire) {
            pendingShow = true;
            $timeout.cancel(fallbackTimer);
            fallbackTimer = $timeout(this.hide, autoExpire || 310, false);
            addClickBlock();
          },
          hide: function() {
            pendingShow = false;
            $timeout.cancel(fallbackTimer);
            removeClickBlock();
          }
        };
      }]);
      IonicModule.factory('$ionicGesture', [function() {
        return {
          on: function(eventType, cb, $element, options) {
            return window.ionic.onGesture(eventType, cb, $element[0], options);
          },
          off: function(gesture, eventType, cb) {
            return window.ionic.offGesture(gesture, eventType, cb);
          }
        };
      }]);
      IonicModule.factory('$ionicHistory', ['$rootScope', '$state', '$location', '$window', '$timeout', '$ionicViewSwitcher', '$ionicNavViewDelegate', function($rootScope, $state, $location, $window, $timeout, $ionicViewSwitcher, $ionicNavViewDelegate) {
        var ACTION_INITIAL_VIEW = 'initialView';
        var ACTION_NEW_VIEW = 'newView';
        var ACTION_MOVE_BACK = 'moveBack';
        var ACTION_MOVE_FORWARD = 'moveForward';
        var DIRECTION_BACK = 'back';
        var DIRECTION_FORWARD = 'forward';
        var DIRECTION_ENTER = 'enter';
        var DIRECTION_EXIT = 'exit';
        var DIRECTION_SWAP = 'swap';
        var DIRECTION_NONE = 'none';
        var stateChangeCounter = 0;
        var lastStateId,
            nextViewOptions,
            deregisterStateChangeListener,
            nextViewExpireTimer,
            forcedNav;
        var viewHistory = {
          histories: {root: {
              historyId: 'root',
              parentHistoryId: null,
              stack: [],
              cursor: -1
            }},
          views: {},
          backView: null,
          forwardView: null,
          currentView: null
        };
        var View = function() {};
        View.prototype.initialize = function(data) {
          if (data) {
            for (var name in data)
              this[name] = data[name];
            return this;
          }
          return null;
        };
        View.prototype.go = function() {
          if (this.stateName) {
            return $state.go(this.stateName, this.stateParams);
          }
          if (this.url && this.url !== $location.url()) {
            if (viewHistory.backView === this) {
              return $window.history.go(-1);
            } else if (viewHistory.forwardView === this) {
              return $window.history.go(1);
            }
            $location.url(this.url);
          }
          return null;
        };
        View.prototype.destroy = function() {
          if (this.scope) {
            this.scope.$destroy && this.scope.$destroy();
            this.scope = null;
          }
        };
        function getViewById(viewId) {
          return (viewId ? viewHistory.views[viewId] : null);
        }
        function getBackView(view) {
          return (view ? getViewById(view.backViewId) : null);
        }
        function getForwardView(view) {
          return (view ? getViewById(view.forwardViewId) : null);
        }
        function getHistoryById(historyId) {
          return (historyId ? viewHistory.histories[historyId] : null);
        }
        function getHistory(scope) {
          var histObj = getParentHistoryObj(scope);
          if (!viewHistory.histories[histObj.historyId]) {
            viewHistory.histories[histObj.historyId] = {
              historyId: histObj.historyId,
              parentHistoryId: getParentHistoryObj(histObj.scope.$parent).historyId,
              stack: [],
              cursor: -1
            };
          }
          return getHistoryById(histObj.historyId);
        }
        function getParentHistoryObj(scope) {
          var parentScope = scope;
          while (parentScope) {
            if (parentScope.hasOwnProperty('$historyId')) {
              return {
                historyId: parentScope.$historyId,
                scope: parentScope
              };
            }
            parentScope = parentScope.$parent;
          }
          return {
            historyId: 'root',
            scope: $rootScope
          };
        }
        function setNavViews(viewId) {
          viewHistory.currentView = getViewById(viewId);
          viewHistory.backView = getBackView(viewHistory.currentView);
          viewHistory.forwardView = getForwardView(viewHistory.currentView);
        }
        function getCurrentStateId() {
          var id;
          if ($state && $state.current && $state.current.name) {
            id = $state.current.name;
            if ($state.params) {
              for (var key in $state.params) {
                if ($state.params.hasOwnProperty(key) && $state.params[key]) {
                  id += "_" + key + "=" + $state.params[key];
                }
              }
            }
            return id;
          }
          return ionic.Utils.nextUid();
        }
        function getCurrentStateParams() {
          var rtn;
          if ($state && $state.params) {
            for (var key in $state.params) {
              if ($state.params.hasOwnProperty(key)) {
                rtn = rtn || {};
                rtn[key] = $state.params[key];
              }
            }
          }
          return rtn;
        }
        return {
          register: function(parentScope, viewLocals) {
            var currentStateId = getCurrentStateId(),
                hist = getHistory(parentScope),
                currentView = viewHistory.currentView,
                backView = viewHistory.backView,
                forwardView = viewHistory.forwardView,
                viewId = null,
                action = null,
                direction = DIRECTION_NONE,
                historyId = hist.historyId,
                url = $location.url(),
                tmp,
                x,
                ele;
            if (lastStateId !== currentStateId) {
              lastStateId = currentStateId;
              stateChangeCounter++;
            }
            if (forcedNav) {
              viewId = forcedNav.viewId;
              action = forcedNav.action;
              direction = forcedNav.direction;
              forcedNav = null;
            } else if (backView && backView.stateId === currentStateId) {
              viewId = backView.viewId;
              historyId = backView.historyId;
              action = ACTION_MOVE_BACK;
              if (backView.historyId === currentView.historyId) {
                direction = DIRECTION_BACK;
              } else if (currentView) {
                direction = DIRECTION_EXIT;
                tmp = getHistoryById(backView.historyId);
                if (tmp && tmp.parentHistoryId === currentView.historyId) {
                  direction = DIRECTION_ENTER;
                } else {
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  }
                }
              }
            } else if (forwardView && forwardView.stateId === currentStateId) {
              viewId = forwardView.viewId;
              historyId = forwardView.historyId;
              action = ACTION_MOVE_FORWARD;
              if (forwardView.historyId === currentView.historyId) {
                direction = DIRECTION_FORWARD;
              } else if (currentView) {
                direction = DIRECTION_EXIT;
                if (currentView.historyId === hist.parentHistoryId) {
                  direction = DIRECTION_ENTER;
                } else {
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  }
                }
              }
              tmp = getParentHistoryObj(parentScope);
              if (forwardView.historyId && tmp.scope) {
                tmp.scope.$historyId = forwardView.historyId;
                historyId = forwardView.historyId;
              }
            } else if (currentView && currentView.historyId !== historyId && hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length && hist.stack[hist.cursor].stateId === currentStateId) {
              var switchToView = hist.stack[hist.cursor];
              viewId = switchToView.viewId;
              historyId = switchToView.historyId;
              action = ACTION_MOVE_BACK;
              direction = DIRECTION_SWAP;
              tmp = getHistoryById(currentView.historyId);
              if (tmp && tmp.parentHistoryId === historyId) {
                direction = DIRECTION_EXIT;
              } else {
                tmp = getHistoryById(historyId);
                if (tmp && tmp.parentHistoryId === currentView.historyId) {
                  direction = DIRECTION_ENTER;
                }
              }
              tmp = getViewById(switchToView.backViewId);
              if (tmp && switchToView.historyId !== tmp.historyId) {
                hist.stack[hist.cursor].backViewId = currentView.viewId;
              }
            } else {
              ele = $ionicViewSwitcher.createViewEle(viewLocals);
              if (this.isAbstractEle(ele, viewLocals)) {
                void 0;
                return {
                  action: 'abstractView',
                  direction: DIRECTION_NONE,
                  ele: ele
                };
              }
              viewId = ionic.Utils.nextUid();
              if (currentView) {
                currentView.forwardViewId = viewId;
                action = ACTION_NEW_VIEW;
                if (forwardView && currentView.stateId !== forwardView.stateId && currentView.historyId === forwardView.historyId) {
                  tmp = getHistoryById(forwardView.historyId);
                  if (tmp) {
                    for (x = tmp.stack.length - 1; x >= forwardView.index; x--) {
                      var stackItem = tmp.stack[x];
                      stackItem && stackItem.destroy && stackItem.destroy();
                      tmp.stack.splice(x);
                    }
                    historyId = forwardView.historyId;
                  }
                }
                if (hist.historyId === currentView.historyId) {
                  direction = DIRECTION_FORWARD;
                } else if (currentView.historyId !== hist.historyId) {
                  direction = DIRECTION_ENTER;
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  } else {
                    tmp = getHistoryById(tmp.parentHistoryId);
                    if (tmp && tmp.historyId === hist.historyId) {
                      direction = DIRECTION_EXIT;
                    }
                  }
                }
              } else {
                action = ACTION_INITIAL_VIEW;
              }
              if (stateChangeCounter < 2) {
                direction = DIRECTION_NONE;
              }
              viewHistory.views[viewId] = this.createView({
                viewId: viewId,
                index: hist.stack.length,
                historyId: hist.historyId,
                backViewId: (currentView && currentView.viewId ? currentView.viewId : null),
                forwardViewId: null,
                stateId: currentStateId,
                stateName: this.currentStateName(),
                stateParams: getCurrentStateParams(),
                url: url,
                canSwipeBack: canSwipeBack(ele, viewLocals)
              });
              hist.stack.push(viewHistory.views[viewId]);
            }
            deregisterStateChangeListener && deregisterStateChangeListener();
            $timeout.cancel(nextViewExpireTimer);
            if (nextViewOptions) {
              if (nextViewOptions.disableAnimate)
                direction = DIRECTION_NONE;
              if (nextViewOptions.disableBack)
                viewHistory.views[viewId].backViewId = null;
              if (nextViewOptions.historyRoot) {
                for (x = 0; x < hist.stack.length; x++) {
                  if (hist.stack[x].viewId === viewId) {
                    hist.stack[x].index = 0;
                    hist.stack[x].backViewId = hist.stack[x].forwardViewId = null;
                  } else {
                    delete viewHistory.views[hist.stack[x].viewId];
                  }
                }
                hist.stack = [viewHistory.views[viewId]];
              }
              nextViewOptions = null;
            }
            setNavViews(viewId);
            if (viewHistory.backView && historyId == viewHistory.backView.historyId && currentStateId == viewHistory.backView.stateId && url == viewHistory.backView.url) {
              for (x = 0; x < hist.stack.length; x++) {
                if (hist.stack[x].viewId == viewId) {
                  action = 'dupNav';
                  direction = DIRECTION_NONE;
                  if (x > 0) {
                    hist.stack[x - 1].forwardViewId = null;
                  }
                  viewHistory.forwardView = null;
                  viewHistory.currentView.index = viewHistory.backView.index;
                  viewHistory.currentView.backViewId = viewHistory.backView.backViewId;
                  viewHistory.backView = getBackView(viewHistory.backView);
                  hist.stack.splice(x, 1);
                  break;
                }
              }
            }
            void 0;
            hist.cursor = viewHistory.currentView.index;
            return {
              viewId: viewId,
              action: action,
              direction: direction,
              historyId: historyId,
              enableBack: this.enabledBack(viewHistory.currentView),
              isHistoryRoot: (viewHistory.currentView.index === 0),
              ele: ele
            };
          },
          registerHistory: function(scope) {
            scope.$historyId = ionic.Utils.nextUid();
          },
          createView: function(data) {
            var newView = new View();
            return newView.initialize(data);
          },
          getViewById: getViewById,
          viewHistory: function() {
            return viewHistory;
          },
          currentView: function(view) {
            if (arguments.length) {
              viewHistory.currentView = view;
            }
            return viewHistory.currentView;
          },
          currentHistoryId: function() {
            return viewHistory.currentView ? viewHistory.currentView.historyId : null;
          },
          currentTitle: function(val) {
            if (viewHistory.currentView) {
              if (arguments.length) {
                viewHistory.currentView.title = val;
              }
              return viewHistory.currentView.title;
            }
          },
          backView: function(view) {
            if (arguments.length) {
              viewHistory.backView = view;
            }
            return viewHistory.backView;
          },
          backTitle: function(view) {
            var backView = (view && getViewById(view.backViewId)) || viewHistory.backView;
            return backView && backView.title;
          },
          forwardView: function(view) {
            if (arguments.length) {
              viewHistory.forwardView = view;
            }
            return viewHistory.forwardView;
          },
          currentStateName: function() {
            return ($state && $state.current ? $state.current.name : null);
          },
          isCurrentStateNavView: function(navView) {
            return !!($state && $state.current && $state.current.views && $state.current.views[navView]);
          },
          goToHistoryRoot: function(historyId) {
            if (historyId) {
              var hist = getHistoryById(historyId);
              if (hist && hist.stack.length) {
                if (viewHistory.currentView && viewHistory.currentView.viewId === hist.stack[0].viewId) {
                  return;
                }
                forcedNav = {
                  viewId: hist.stack[0].viewId,
                  action: ACTION_MOVE_BACK,
                  direction: DIRECTION_BACK
                };
                hist.stack[0].go();
              }
            }
          },
          goBack: function(backCount) {
            if (isDefined(backCount) && backCount !== -1) {
              if (backCount > -1)
                return;
              var currentHistory = viewHistory.histories[this.currentHistoryId()];
              var newCursor = currentHistory.cursor + backCount + 1;
              if (newCursor < 1) {
                newCursor = 1;
              }
              currentHistory.cursor = newCursor;
              setNavViews(currentHistory.stack[newCursor].viewId);
              var cursor = newCursor - 1;
              var clearStateIds = [];
              var fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
              while (fwdView) {
                clearStateIds.push(fwdView.stateId || fwdView.viewId);
                cursor++;
                if (cursor >= currentHistory.stack.length)
                  break;
                fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
              }
              var self = this;
              if (clearStateIds.length) {
                $timeout(function() {
                  self.clearCache(clearStateIds);
                }, 600);
              }
            }
            viewHistory.backView && viewHistory.backView.go();
          },
          enabledBack: function(view) {
            var backView = getBackView(view);
            return !!(backView && backView.historyId === view.historyId);
          },
          clearHistory: function() {
            var histories = viewHistory.histories,
                currentView = viewHistory.currentView;
            if (histories) {
              for (var historyId in histories) {
                if (histories[historyId].stack) {
                  histories[historyId].stack = [];
                  histories[historyId].cursor = -1;
                }
                if (currentView && currentView.historyId === historyId) {
                  currentView.backViewId = currentView.forwardViewId = null;
                  histories[historyId].stack.push(currentView);
                } else if (histories[historyId].destroy) {
                  histories[historyId].destroy();
                }
              }
            }
            for (var viewId in viewHistory.views) {
              if (viewId !== currentView.viewId) {
                delete viewHistory.views[viewId];
              }
            }
            if (currentView) {
              setNavViews(currentView.viewId);
            }
          },
          clearCache: function(stateIds) {
            return $timeout(function() {
              $ionicNavViewDelegate._instances.forEach(function(instance) {
                instance.clearCache(stateIds);
              });
            });
          },
          nextViewOptions: function(opts) {
            deregisterStateChangeListener && deregisterStateChangeListener();
            if (arguments.length) {
              $timeout.cancel(nextViewExpireTimer);
              if (opts === null) {
                nextViewOptions = opts;
              } else {
                nextViewOptions = nextViewOptions || {};
                extend(nextViewOptions, opts);
                if (nextViewOptions.expire) {
                  deregisterStateChangeListener = $rootScope.$on('$stateChangeSuccess', function() {
                    nextViewExpireTimer = $timeout(function() {
                      nextViewOptions = null;
                    }, nextViewOptions.expire);
                  });
                }
              }
            }
            return nextViewOptions;
          },
          isAbstractEle: function(ele, viewLocals) {
            if (viewLocals && viewLocals.$$state && viewLocals.$$state.self['abstract']) {
              return true;
            }
            return !!(ele && (isAbstractTag(ele) || isAbstractTag(ele.children())));
          },
          isActiveScope: function(scope) {
            if (!scope)
              return false;
            var climbScope = scope;
            var currentHistoryId = this.currentHistoryId();
            var foundHistoryId;
            while (climbScope) {
              if (climbScope.$$disconnected) {
                return false;
              }
              if (!foundHistoryId && climbScope.hasOwnProperty('$historyId')) {
                foundHistoryId = true;
              }
              if (currentHistoryId) {
                if (climbScope.hasOwnProperty('$historyId') && currentHistoryId == climbScope.$historyId) {
                  return true;
                }
                if (climbScope.hasOwnProperty('$activeHistoryId')) {
                  if (currentHistoryId == climbScope.$activeHistoryId) {
                    if (climbScope.hasOwnProperty('$historyId')) {
                      return true;
                    }
                    if (!foundHistoryId) {
                      return true;
                    }
                  }
                }
              }
              if (foundHistoryId && climbScope.hasOwnProperty('$activeHistoryId')) {
                foundHistoryId = false;
              }
              climbScope = climbScope.$parent;
            }
            return currentHistoryId ? currentHistoryId == 'root' : true;
          }
        };
        function isAbstractTag(ele) {
          return ele && ele.length && /ion-side-menus|ion-tabs/i.test(ele[0].tagName);
        }
        function canSwipeBack(ele, viewLocals) {
          if (viewLocals && viewLocals.$$state && viewLocals.$$state.self.canSwipeBack === false) {
            return false;
          }
          if (ele && ele.attr('can-swipe-back') === 'false') {
            return false;
          }
          return true;
        }
      }]).run(['$rootScope', '$state', '$location', '$document', '$ionicPlatform', '$ionicHistory', 'IONIC_BACK_PRIORITY', function($rootScope, $state, $location, $document, $ionicPlatform, $ionicHistory, IONIC_BACK_PRIORITY) {
        $rootScope.$on('$ionicView.beforeEnter', function() {
          ionic.keyboard && ionic.keyboard.hide && ionic.keyboard.hide();
        });
        $rootScope.$on('$ionicHistory.change', function(e, data) {
          if (!data)
            return null;
          var viewHistory = $ionicHistory.viewHistory();
          var hist = (data.historyId ? viewHistory.histories[data.historyId] : null);
          if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {
            var view = hist.stack[hist.cursor];
            return view.go(data);
          }
          if (!data.url && data.uiSref) {
            data.url = $state.href(data.uiSref);
          }
          if (data.url) {
            if (data.url.indexOf('#') === 0) {
              data.url = data.url.replace('#', '');
            }
            if (data.url !== $location.url()) {
              $location.url(data.url);
            }
          }
        });
        $rootScope.$ionicGoBack = function(backCount) {
          $ionicHistory.goBack(backCount);
        };
        $rootScope.$on('$ionicView.afterEnter', function(ev, data) {
          if (data && data.title) {
            $document[0].title = data.title;
          }
        });
        function onHardwareBackButton(e) {
          var backView = $ionicHistory.backView();
          if (backView) {
            backView.go();
          } else {
            ionic.Platform.exitApp();
          }
          e.preventDefault();
          return false;
        }
        $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.view);
      }]);
      IonicModule.provider('$ionicConfig', function() {
        var provider = this;
        provider.platform = {};
        var PLATFORM = 'platform';
        var configProperties = {
          views: {
            maxCache: PLATFORM,
            forwardCache: PLATFORM,
            transition: PLATFORM,
            swipeBackEnabled: PLATFORM,
            swipeBackHitWidth: PLATFORM
          },
          navBar: {
            alignTitle: PLATFORM,
            positionPrimaryButtons: PLATFORM,
            positionSecondaryButtons: PLATFORM,
            transition: PLATFORM
          },
          backButton: {
            icon: PLATFORM,
            text: PLATFORM,
            previousTitleText: PLATFORM
          },
          form: {
            checkbox: PLATFORM,
            toggle: PLATFORM
          },
          scrolling: {jsScrolling: PLATFORM},
          spinner: {icon: PLATFORM},
          tabs: {
            style: PLATFORM,
            position: PLATFORM
          },
          templates: {maxPrefetch: PLATFORM},
          platform: {}
        };
        createConfig(configProperties, provider, '');
        setPlatformConfig('default', {
          views: {
            maxCache: 10,
            forwardCache: false,
            transition: 'ios',
            swipeBackEnabled: true,
            swipeBackHitWidth: 45
          },
          navBar: {
            alignTitle: 'center',
            positionPrimaryButtons: 'left',
            positionSecondaryButtons: 'right',
            transition: 'view'
          },
          backButton: {
            icon: 'ion-ios-arrow-back',
            text: 'Back',
            previousTitleText: true
          },
          form: {
            checkbox: 'circle',
            toggle: 'large'
          },
          scrolling: {jsScrolling: true},
          spinner: {icon: 'ios'},
          tabs: {
            style: 'standard',
            position: 'bottom'
          },
          templates: {maxPrefetch: 30}
        });
        setPlatformConfig('ios', {});
        setPlatformConfig('android', {
          views: {
            transition: 'android',
            swipeBackEnabled: false
          },
          navBar: {
            alignTitle: 'left',
            positionPrimaryButtons: 'right',
            positionSecondaryButtons: 'right'
          },
          backButton: {
            icon: 'ion-android-arrow-back',
            text: false,
            previousTitleText: false
          },
          form: {
            checkbox: 'square',
            toggle: 'small'
          },
          spinner: {icon: 'android'},
          tabs: {
            style: 'striped',
            position: 'top'
          }
        });
        setPlatformConfig('windowsphone', {spinner: {icon: 'android'}});
        provider.transitions = {
          views: {},
          navBar: {}
        };
        provider.transitions.views.ios = function(enteringEle, leavingEle, direction, shouldAnimate) {
          function setStyles(ele, opacity, x, boxShadowOpacity) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
            css.opacity = opacity;
            if (boxShadowOpacity > -1) {
              css.boxShadow = '0 0 10px rgba(0,0,0,' + (d.shouldAnimate ? boxShadowOpacity * 0.45 : 0.3) + ')';
            }
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
            ionic.DomUtil.cachedStyles(ele, css);
          }
          var d = {
            run: function(step) {
              if (direction == 'forward') {
                setStyles(enteringEle, 1, (1 - step) * 99, 1 - step);
                setStyles(leavingEle, (1 - 0.1 * step), step * -33, -1);
              } else if (direction == 'back') {
                setStyles(enteringEle, (1 - 0.1 * (1 - step)), (1 - step) * -33, -1);
                setStyles(leavingEle, 1, step * 100, 1 - step);
              } else {
                setStyles(enteringEle, 1, 0, -1);
                setStyles(leavingEle, 0, 0, -1);
              }
            },
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
          return d;
        };
        provider.transitions.navBar.ios = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
          function setStyles(ctrl, opacity, titleX, backTextX) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : '0ms';
            css.opacity = opacity === 1 ? '' : opacity;
            ctrl.setCss('buttons-left', css);
            ctrl.setCss('buttons-right', css);
            ctrl.setCss('back-button', css);
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + backTextX + 'px,0,0)';
            ctrl.setCss('back-text', css);
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + titleX + 'px,0,0)';
            ctrl.setCss('title', css);
          }
          function enter(ctrlA, ctrlB, step) {
            if (!ctrlA || !ctrlB)
              return;
            var titleX = (ctrlA.titleTextX() + ctrlA.titleWidth()) * (1 - step);
            var backTextX = (ctrlB && (ctrlB.titleTextX() - ctrlA.backButtonTextLeft()) * (1 - step)) || 0;
            setStyles(ctrlA, step, titleX, backTextX);
          }
          function leave(ctrlA, ctrlB, step) {
            if (!ctrlA || !ctrlB)
              return;
            var titleX = (-(ctrlA.titleTextX() - ctrlB.backButtonTextLeft()) - (ctrlA.titleLeftRight())) * step;
            setStyles(ctrlA, 1 - step, titleX, 0);
          }
          var d = {
            run: function(step) {
              var enteringHeaderCtrl = enteringHeaderBar.controller();
              var leavingHeaderCtrl = leavingHeaderBar && leavingHeaderBar.controller();
              if (d.direction == 'back') {
                leave(enteringHeaderCtrl, leavingHeaderCtrl, 1 - step);
                enter(leavingHeaderCtrl, enteringHeaderCtrl, 1 - step);
              } else {
                enter(enteringHeaderCtrl, leavingHeaderCtrl, step);
                leave(leavingHeaderCtrl, enteringHeaderCtrl, step);
              }
            },
            direction: direction,
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
          return d;
        };
        provider.transitions.views.android = function(enteringEle, leavingEle, direction, shouldAnimate) {
          shouldAnimate = shouldAnimate && (direction == 'forward' || direction == 'back');
          function setStyles(ele, x) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
            ionic.DomUtil.cachedStyles(ele, css);
          }
          var d = {
            run: function(step) {
              if (direction == 'forward') {
                setStyles(enteringEle, (1 - step) * 99);
                setStyles(leavingEle, step * -100);
              } else if (direction == 'back') {
                setStyles(enteringEle, (1 - step) * -100);
                setStyles(leavingEle, step * 100);
              } else {
                setStyles(enteringEle, 0);
                setStyles(leavingEle, 0);
              }
            },
            shouldAnimate: shouldAnimate
          };
          return d;
        };
        provider.transitions.navBar.android = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
          function setStyles(ctrl, opacity) {
            if (!ctrl)
              return;
            var css = {};
            css.opacity = opacity === 1 ? '' : opacity;
            ctrl.setCss('buttons-left', css);
            ctrl.setCss('buttons-right', css);
            ctrl.setCss('back-button', css);
            ctrl.setCss('back-text', css);
            ctrl.setCss('title', css);
          }
          return {
            run: function(step) {
              setStyles(enteringHeaderBar.controller(), step);
              setStyles(leavingHeaderBar && leavingHeaderBar.controller(), 1 - step);
            },
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
        };
        provider.transitions.views.none = function(enteringEle, leavingEle) {
          return {
            run: function(step) {
              provider.transitions.views.android(enteringEle, leavingEle, false, false).run(step);
            },
            shouldAnimate: false
          };
        };
        provider.transitions.navBar.none = function(enteringHeaderBar, leavingHeaderBar) {
          return {
            run: function(step) {
              provider.transitions.navBar.ios(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
              provider.transitions.navBar.android(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
            },
            shouldAnimate: false
          };
        };
        function setPlatformConfig(platformName, platformConfigs) {
          configProperties.platform[platformName] = platformConfigs;
          provider.platform[platformName] = {};
          addConfig(configProperties, configProperties.platform[platformName]);
          createConfig(configProperties.platform[platformName], provider.platform[platformName], '');
        }
        function addConfig(configObj, platformObj) {
          for (var n in configObj) {
            if (n != PLATFORM && configObj.hasOwnProperty(n)) {
              if (angular.isObject(configObj[n])) {
                if (!isDefined(platformObj[n])) {
                  platformObj[n] = {};
                }
                addConfig(configObj[n], platformObj[n]);
              } else if (!isDefined(platformObj[n])) {
                platformObj[n] = null;
              }
            }
          }
        }
        function createConfig(configObj, providerObj, platformPath) {
          forEach(configObj, function(value, namespace) {
            if (angular.isObject(configObj[namespace])) {
              providerObj[namespace] = {};
              createConfig(configObj[namespace], providerObj[namespace], platformPath + '.' + namespace);
            } else {
              providerObj[namespace] = function(newValue) {
                if (arguments.length) {
                  configObj[namespace] = newValue;
                  return providerObj;
                }
                if (configObj[namespace] == PLATFORM) {
                  var platformConfig = stringObj(configProperties.platform, ionic.Platform.platform() + platformPath + '.' + namespace);
                  if (platformConfig || platformConfig === false) {
                    return platformConfig;
                  }
                  return stringObj(configProperties.platform, 'default' + platformPath + '.' + namespace);
                }
                return configObj[namespace];
              };
            }
          });
        }
        function stringObj(obj, str) {
          str = str.split(".");
          for (var i = 0; i < str.length; i++) {
            if (obj && isDefined(obj[str[i]])) {
              obj = obj[str[i]];
            } else {
              return null;
            }
          }
          return obj;
        }
        provider.setPlatformConfig = setPlatformConfig;
        provider.$get = function() {
          return provider;
        };
      }).config(['$compileProvider', function($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|tel|ftp|mailto|file|ghttps?|ms-appx|x-wmapp0):/);
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|content|blob|ms-appx|x-wmapp0):|data:image\//);
      }]);
      var LOADING_TPL = '<div class="loading-container">' + '<div class="loading">' + '</div>' + '</div>';
      var LOADING_HIDE_DEPRECATED = '$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().';
      var LOADING_SHOW_DEPRECATED = '$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().';
      var LOADING_SET_DEPRECATED = '$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: \'my content\' }).';
      IonicModule.constant('$ionicLoadingConfig', {template: '<ion-spinner></ion-spinner>'}).factory('$ionicLoading', ['$ionicLoadingConfig', '$ionicBody', '$ionicTemplateLoader', '$ionicBackdrop', '$timeout', '$q', '$log', '$compile', '$ionicPlatform', '$rootScope', 'IONIC_BACK_PRIORITY', function($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform, $rootScope, IONIC_BACK_PRIORITY) {
        var loaderInstance;
        var deregisterBackAction = noop;
        var deregisterStateListener1 = noop;
        var deregisterStateListener2 = noop;
        var loadingShowDelay = $q.when();
        return {
          show: showLoader,
          hide: hideLoader,
          _getLoader: getLoader
        };
        function getLoader() {
          if (!loaderInstance) {
            loaderInstance = $ionicTemplateLoader.compile({
              template: LOADING_TPL,
              appendTo: $ionicBody.get()
            }).then(function(self) {
              self.show = function(options) {
                var templatePromise = options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : $q.when(options.template || options.content || '');
                self.scope = options.scope || self.scope;
                if (!self.isShown) {
                  self.hasBackdrop = !options.noBackdrop && options.showBackdrop !== false;
                  if (self.hasBackdrop) {
                    $ionicBackdrop.retain();
                    $ionicBackdrop.getElement().addClass('backdrop-loading');
                  }
                }
                if (options.duration) {
                  $timeout.cancel(self.durationTimeout);
                  self.durationTimeout = $timeout(angular.bind(self, self.hide), +options.duration);
                }
                deregisterBackAction();
                deregisterBackAction = $ionicPlatform.registerBackButtonAction(noop, IONIC_BACK_PRIORITY.loading);
                templatePromise.then(function(html) {
                  if (html) {
                    var loading = self.element.children();
                    loading.html(html);
                    $compile(loading.contents())(self.scope);
                  }
                  if (self.isShown) {
                    self.element.addClass('visible');
                    ionic.requestAnimationFrame(function() {
                      if (self.isShown) {
                        self.element.addClass('active');
                        $ionicBody.addClass('loading-active');
                      }
                    });
                  }
                });
                self.isShown = true;
              };
              self.hide = function() {
                deregisterBackAction();
                if (self.isShown) {
                  if (self.hasBackdrop) {
                    $ionicBackdrop.release();
                    $ionicBackdrop.getElement().removeClass('backdrop-loading');
                  }
                  self.element.removeClass('active');
                  $ionicBody.removeClass('loading-active');
                  setTimeout(function() {
                    !self.isShown && self.element.removeClass('visible');
                  }, 200);
                }
                $timeout.cancel(self.durationTimeout);
                self.isShown = false;
              };
              return self;
            });
          }
          return loaderInstance;
        }
        function showLoader(options) {
          options = extend({}, $ionicLoadingConfig || {}, options || {});
          var delay = options.delay || options.showDelay || 0;
          deregisterStateListener1();
          deregisterStateListener2();
          if (options.hideOnStateChange) {
            deregisterStateListener1 = $rootScope.$on('$stateChangeSuccess', hideLoader);
            deregisterStateListener2 = $rootScope.$on('$stateChangeError', hideLoader);
          }
          $timeout.cancel(loadingShowDelay);
          loadingShowDelay = $timeout(noop, delay);
          loadingShowDelay.then(getLoader).then(function(loader) {
            return loader.show(options);
          });
          return {
            hide: function deprecatedHide() {
              $log.error(LOADING_HIDE_DEPRECATED);
              return hideLoader.apply(this, arguments);
            },
            show: function deprecatedShow() {
              $log.error(LOADING_SHOW_DEPRECATED);
              return showLoader.apply(this, arguments);
            },
            setContent: function deprecatedSetContent(content) {
              $log.error(LOADING_SET_DEPRECATED);
              return getLoader().then(function(loader) {
                loader.show({template: content});
              });
            }
          };
        }
        function hideLoader() {
          deregisterStateListener1();
          deregisterStateListener2();
          $timeout.cancel(loadingShowDelay);
          getLoader().then(function(loader) {
            loader.hide();
          });
        }
      }]);
      IonicModule.factory('$ionicModal', ['$rootScope', '$ionicBody', '$compile', '$timeout', '$ionicPlatform', '$ionicTemplateLoader', '$$q', '$log', '$ionicClickBlock', '$window', 'IONIC_BACK_PRIORITY', function($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $$q, $log, $ionicClickBlock, $window, IONIC_BACK_PRIORITY) {
        var ModalView = ionic.views.Modal.inherit({
          initialize: function(opts) {
            ionic.views.Modal.prototype.initialize.call(this, opts);
            this.animation = opts.animation || 'slide-in-up';
          },
          show: function(target) {
            var self = this;
            if (self.scope.$$destroyed) {
              $log.error('Cannot call ' + self.viewType + '.show() after remove(). Please create a new ' + self.viewType + ' instance.');
              return $$q.when();
            }
            $ionicClickBlock.show(600);
            stack.add(self);
            var modalEl = jqLite(self.modalEl);
            self.el.classList.remove('hide');
            $timeout(function() {
              if (!self._isShown)
                return;
              $ionicBody.addClass(self.viewType + '-open');
            }, 400, false);
            if (!self.el.parentElement) {
              modalEl.addClass(self.animation);
              $ionicBody.append(self.el);
            }
            var scrollCtrl = modalEl.data('$$ionicScrollController');
            scrollCtrl && scrollCtrl.resize();
            if (target && self.positionView) {
              self.positionView(target, modalEl);
              self._onWindowResize = function() {
                if (self._isShown)
                  self.positionView(target, modalEl);
              };
              ionic.on('resize', self._onWindowResize, window);
            }
            modalEl.addClass('ng-enter active').removeClass('ng-leave ng-leave-active');
            self._isShown = true;
            self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(self.hardwareBackButtonClose ? angular.bind(self, self.hide) : noop, IONIC_BACK_PRIORITY.modal);
            ionic.views.Modal.prototype.show.call(self);
            $timeout(function() {
              if (!self._isShown)
                return;
              modalEl.addClass('ng-enter-active');
              self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.shown', self);
              self.el.classList.add('active');
              self.scope.$broadcast('$ionicHeader.align');
            }, 20);
            return $timeout(function() {
              if (!self._isShown)
                return;
              self.$el.on('click', function(e) {
                if (self.backdropClickToClose && e.target === self.el && stack.isHighest(self)) {
                  self.hide();
                }
              });
            }, 400);
          },
          hide: function() {
            var self = this;
            var modalEl = jqLite(self.modalEl);
            $ionicClickBlock.show(600);
            stack.remove(self);
            self.el.classList.remove('active');
            modalEl.addClass('ng-leave');
            $timeout(function() {
              if (self._isShown)
                return;
              modalEl.addClass('ng-leave-active').removeClass('ng-enter ng-enter-active active');
            }, 20, false);
            self.$el.off('click');
            self._isShown = false;
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.hidden', self);
            self._deregisterBackButton && self._deregisterBackButton();
            ionic.views.Modal.prototype.hide.call(self);
            if (self.positionView) {
              ionic.off('resize', self._onWindowResize, window);
            }
            return $timeout(function() {
              $ionicBody.removeClass(self.viewType + '-open');
              self.el.classList.add('hide');
            }, self.hideDelay || 320);
          },
          remove: function() {
            var self = this;
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.removed', self);
            return self.hide().then(function() {
              self.scope.$destroy();
              self.$el.remove();
            });
          },
          isShown: function() {
            return !!this._isShown;
          }
        });
        var createModal = function(templateString, options) {
          var scope = options.scope && options.scope.$new() || $rootScope.$new(true);
          options.viewType = options.viewType || 'modal';
          extend(scope, {
            $hasHeader: false,
            $hasSubheader: false,
            $hasFooter: false,
            $hasSubfooter: false,
            $hasTabs: false,
            $hasTabsTop: false
          });
          var element = $compile('<ion-' + options.viewType + '>' + templateString + '</ion-' + options.viewType + '>')(scope);
          options.$el = element;
          options.el = element[0];
          options.modalEl = options.el.querySelector('.' + options.viewType);
          var modal = new ModalView(options);
          modal.scope = scope;
          if (!options.scope) {
            scope[options.viewType] = modal;
          }
          return modal;
        };
        var modalStack = [];
        var stack = {
          add: function(modal) {
            modalStack.push(modal);
          },
          remove: function(modal) {
            var index = modalStack.indexOf(modal);
            if (index > -1 && index < modalStack.length) {
              modalStack.splice(index, 1);
            }
          },
          isHighest: function(modal) {
            var index = modalStack.indexOf(modal);
            return (index > -1 && index === modalStack.length - 1);
          }
        };
        return {
          fromTemplate: function(templateString, options) {
            var modal = createModal(templateString, options || {});
            return modal;
          },
          fromTemplateUrl: function(url, options, _) {
            var cb;
            if (angular.isFunction(options)) {
              cb = options;
              options = _;
            }
            return $ionicTemplateLoader.load(url).then(function(templateString) {
              var modal = createModal(templateString, options || {});
              cb && cb(modal);
              return modal;
            });
          },
          stack: stack
        };
      }]);
      IonicModule.service('$ionicNavBarDelegate', ionic.DelegateService(['align', 'showBackButton', 'showBar', 'title', 'changeTitle', 'setTitle', 'getTitle', 'back', 'getPreviousTitle']));
      IonicModule.service('$ionicNavViewDelegate', ionic.DelegateService(['clearCache']));
      IonicModule.constant('IONIC_BACK_PRIORITY', {
        view: 100,
        sideMenu: 150,
        modal: 200,
        actionSheet: 300,
        popup: 400,
        loading: 500
      }).provider('$ionicPlatform', function() {
        return {$get: ['$q', function($q) {
            var self = {
              onHardwareBackButton: function(cb) {
                ionic.Platform.ready(function() {
                  document.addEventListener('backbutton', cb, false);
                });
              },
              offHardwareBackButton: function(fn) {
                ionic.Platform.ready(function() {
                  document.removeEventListener('backbutton', fn);
                });
              },
              $backButtonActions: {},
              registerBackButtonAction: function(fn, priority, actionId) {
                if (!self._hasBackButtonHandler) {
                  self.$backButtonActions = {};
                  self.onHardwareBackButton(self.hardwareBackButtonClick);
                  self._hasBackButtonHandler = true;
                }
                var action = {
                  id: (actionId ? actionId : ionic.Utils.nextUid()),
                  priority: (priority ? priority : 0),
                  fn: fn
                };
                self.$backButtonActions[action.id] = action;
                return function() {
                  delete self.$backButtonActions[action.id];
                };
              },
              hardwareBackButtonClick: function(e) {
                var priorityAction,
                    actionId;
                for (actionId in self.$backButtonActions) {
                  if (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) {
                    priorityAction = self.$backButtonActions[actionId];
                  }
                }
                if (priorityAction) {
                  priorityAction.fn(e);
                  return priorityAction;
                }
              },
              is: function(type) {
                return ionic.Platform.is(type);
              },
              on: function(type, cb) {
                ionic.Platform.ready(function() {
                  document.addEventListener(type, cb, false);
                });
                return function() {
                  ionic.Platform.ready(function() {
                    document.removeEventListener(type, cb);
                  });
                };
              },
              ready: function(cb) {
                var q = $q.defer();
                ionic.Platform.ready(function() {
                  q.resolve();
                  cb && cb();
                });
                return q.promise;
              }
            };
            return self;
          }]};
      });
      IonicModule.factory('$ionicPopover', ['$ionicModal', '$ionicPosition', '$document', '$window', function($ionicModal, $ionicPosition, $document, $window) {
        var POPOVER_BODY_PADDING = 6;
        var POPOVER_OPTIONS = {
          viewType: 'popover',
          hideDelay: 1,
          animation: 'none',
          positionView: positionView
        };
        function positionView(target, popoverEle) {
          var targetEle = jqLite(target.target || target);
          var buttonOffset = $ionicPosition.offset(targetEle);
          var popoverWidth = popoverEle.prop('offsetWidth');
          var popoverHeight = popoverEle.prop('offsetHeight');
          var bodyWidth = $window.innerWidth;
          var bodyHeight = $window.innerHeight;
          var popoverCSS = {left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2};
          var arrowEle = jqLite(popoverEle[0].querySelector('.popover-arrow'));
          if (popoverCSS.left < POPOVER_BODY_PADDING) {
            popoverCSS.left = POPOVER_BODY_PADDING;
          } else if (popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth) {
            popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING;
          }
          if (buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight && buttonOffset.top - popoverHeight > 0) {
            popoverCSS.top = buttonOffset.top - popoverHeight;
            popoverEle.addClass('popover-bottom');
          } else {
            popoverCSS.top = buttonOffset.top + buttonOffset.height;
            popoverEle.removeClass('popover-bottom');
          }
          arrowEle.css({left: buttonOffset.left + buttonOffset.width / 2 - arrowEle.prop('offsetWidth') / 2 - popoverCSS.left + 'px'});
          popoverEle.css({
            top: popoverCSS.top + 'px',
            left: popoverCSS.left + 'px',
            marginLeft: '0',
            opacity: '1'
          });
        }
        return {
          fromTemplate: function(templateString, options) {
            return $ionicModal.fromTemplate(templateString, ionic.Utils.extend(POPOVER_OPTIONS, options || {}));
          },
          fromTemplateUrl: function(url, options) {
            return $ionicModal.fromTemplateUrl(url, ionic.Utils.extend(POPOVER_OPTIONS, options || {}));
          }
        };
      }]);
      var POPUP_TPL = '<div class="popup-container" ng-class="cssClass">' + '<div class="popup">' + '<div class="popup-head">' + '<h3 class="popup-title" ng-bind-html="title"></h3>' + '<h5 class="popup-sub-title" ng-bind-html="subTitle" ng-if="subTitle"></h5>' + '</div>' + '<div class="popup-body">' + '</div>' + '<div class="popup-buttons" ng-show="buttons.length">' + '<button ng-repeat="button in buttons" ng-click="$buttonTapped(button, $event)" class="button" ng-class="button.type || \'button-default\'" ng-bind-html="button.text"></button>' + '</div>' + '</div>' + '</div>';
      IonicModule.factory('$ionicPopup', ['$ionicTemplateLoader', '$ionicBackdrop', '$q', '$timeout', '$rootScope', '$ionicBody', '$compile', '$ionicPlatform', '$ionicModal', 'IONIC_BACK_PRIORITY', function($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform, $ionicModal, IONIC_BACK_PRIORITY) {
        var config = {stackPushDelay: 75};
        var popupStack = [];
        var $ionicPopup = {
          show: showPopup,
          alert: showAlert,
          confirm: showConfirm,
          prompt: showPrompt,
          _createPopup: createPopup,
          _popupStack: popupStack
        };
        return $ionicPopup;
        function createPopup(options) {
          options = extend({
            scope: null,
            title: '',
            buttons: []
          }, options || {});
          var self = {};
          self.scope = (options.scope || $rootScope).$new();
          self.element = jqLite(POPUP_TPL);
          self.responseDeferred = $q.defer();
          $ionicBody.get().appendChild(self.element[0]);
          $compile(self.element)(self.scope);
          extend(self.scope, {
            title: options.title,
            buttons: options.buttons,
            subTitle: options.subTitle,
            cssClass: options.cssClass,
            $buttonTapped: function(button, event) {
              var result = (button.onTap || noop)(event);
              event = event.originalEvent || event;
              if (!event.defaultPrevented) {
                self.responseDeferred.resolve(result);
              }
            }
          });
          $q.when(options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : (options.template || options.content || '')).then(function(template) {
            var popupBody = jqLite(self.element[0].querySelector('.popup-body'));
            if (template) {
              popupBody.html(template);
              $compile(popupBody.contents())(self.scope);
            } else {
              popupBody.remove();
            }
          });
          self.show = function() {
            if (self.isShown || self.removed)
              return;
            $ionicModal.stack.add(self);
            self.isShown = true;
            ionic.requestAnimationFrame(function() {
              if (!self.isShown)
                return;
              self.element.removeClass('popup-hidden');
              self.element.addClass('popup-showing active');
              focusInput(self.element);
            });
          };
          self.hide = function(callback) {
            callback = callback || noop;
            if (!self.isShown)
              return callback();
            $ionicModal.stack.remove(self);
            self.isShown = false;
            self.element.removeClass('active');
            self.element.addClass('popup-hidden');
            $timeout(callback, 250, false);
          };
          self.remove = function() {
            if (self.removed || !$ionicModal.stack.isHighest(self))
              return;
            self.hide(function() {
              self.element.remove();
              self.scope.$destroy();
            });
            self.removed = true;
          };
          return self;
        }
        function onHardwareBackButton() {
          var last = popupStack[popupStack.length - 1];
          last && last.responseDeferred.resolve();
        }
        function showPopup(options) {
          var popup = $ionicPopup._createPopup(options);
          var showDelay = 0;
          if (popupStack.length > 0) {
            popupStack[popupStack.length - 1].hide();
            showDelay = config.stackPushDelay;
          } else {
            $ionicBody.addClass('popup-open');
            $ionicBackdrop.retain();
            $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.popup);
          }
          popup.responseDeferred.promise.close = function popupClose(result) {
            if (!popup.removed)
              popup.responseDeferred.resolve(result);
          };
          popup.responseDeferred.notify({close: popup.responseDeferred.close});
          doShow();
          return popup.responseDeferred.promise;
          function doShow() {
            popupStack.push(popup);
            $timeout(popup.show, showDelay, false);
            popup.responseDeferred.promise.then(function(result) {
              var index = popupStack.indexOf(popup);
              if (index !== -1) {
                popupStack.splice(index, 1);
              }
              if (popupStack.length > 0) {
                popupStack[popupStack.length - 1].show();
              } else {
                $ionicBackdrop.release();
                $timeout(function() {
                  if (!popupStack.length) {
                    $ionicBody.removeClass('popup-open');
                  }
                }, 400, false);
                ($ionicPopup._backButtonActionDone || noop)();
              }
              popup.remove();
              return result;
            });
          }
        }
        function focusInput(element) {
          var focusOn = element[0].querySelector('[autofocus]');
          if (focusOn) {
            focusOn.focus();
          }
        }
        function showAlert(opts) {
          return showPopup(extend({buttons: [{
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return true;
              }
            }]}, opts || {}));
        }
        function showConfirm(opts) {
          return showPopup(extend({buttons: [{
              text: opts.cancelText || 'Cancel',
              type: opts.cancelType || 'button-default',
              onTap: function() {
                return false;
              }
            }, {
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return true;
              }
            }]}, opts || {}));
        }
        function showPrompt(opts) {
          var scope = $rootScope.$new(true);
          scope.data = {};
          var text = '';
          if (opts.template && /<[a-z][\s\S]*>/i.test(opts.template) === false) {
            text = '<span>' + opts.template + '</span>';
            delete opts.template;
          }
          return showPopup(extend({
            template: text + '<input ng-model="data.response" type="' + (opts.inputType || 'text') + '" placeholder="' + (opts.inputPlaceholder || '') + '">',
            scope: scope,
            buttons: [{
              text: opts.cancelText || 'Cancel',
              type: opts.cancelType || 'button-default',
              onTap: function() {}
            }, {
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return scope.data.response || '';
              }
            }]
          }, opts || {}));
        }
      }]);
      IonicModule.factory('$ionicPosition', ['$document', '$window', function($document, $window) {
        function getStyle(el, cssprop) {
          if (el.currentStyle) {
            return el.currentStyle[cssprop];
          } else if ($window.getComputedStyle) {
            return $window.getComputedStyle(el)[cssprop];
          }
          return el.style[cssprop];
        }
        function isStaticPositioned(element) {
          return (getStyle(element, 'position') || 'static') === 'static';
        }
        var parentOffsetEl = function(element) {
          var docDomEl = $document[0];
          var offsetParent = element.offsetParent || docDomEl;
          while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || docDomEl;
        };
        return {
          position: function(element) {
            var elBCR = this.offset(element);
            var offsetParentBCR = {
              top: 0,
              left: 0
            };
            var offsetParentEl = parentOffsetEl(element[0]);
            if (offsetParentEl != $document[0]) {
              offsetParentBCR = this.offset(jqLite(offsetParentEl));
              offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
              offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
            }
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
              width: boundingClientRect.width || element.prop('offsetWidth'),
              height: boundingClientRect.height || element.prop('offsetHeight'),
              top: elBCR.top - offsetParentBCR.top,
              left: elBCR.left - offsetParentBCR.left
            };
          },
          offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
              width: boundingClientRect.width || element.prop('offsetWidth'),
              height: boundingClientRect.height || element.prop('offsetHeight'),
              top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
              left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
          }
        };
      }]);
      IonicModule.service('$ionicScrollDelegate', ionic.DelegateService(['resize', 'scrollTop', 'scrollBottom', 'scrollTo', 'scrollBy', 'zoomTo', 'zoomBy', 'getScrollPosition', 'anchorScroll', 'freezeScroll', 'freezeAllScrolls', 'getScrollView']));
      IonicModule.service('$ionicSideMenuDelegate', ionic.DelegateService(['toggleLeft', 'toggleRight', 'getOpenRatio', 'isOpen', 'isOpenLeft', 'isOpenRight', 'canDragContent', 'edgeDragThreshold']));
      IonicModule.service('$ionicSlideBoxDelegate', ionic.DelegateService(['update', 'slide', 'select', 'enableSlide', 'previous', 'next', 'stop', 'autoPlay', 'start', 'currentIndex', 'selected', 'slidesCount', 'count', 'loop']));
      IonicModule.service('$ionicTabsDelegate', ionic.DelegateService(['select', 'selectedIndex']));
      (function() {
        var templatesToCache = [];
        IonicModule.factory('$ionicTemplateCache', ['$http', '$templateCache', '$timeout', function($http, $templateCache, $timeout) {
          var toCache = templatesToCache,
              hasRun;
          function $ionicTemplateCache(templates) {
            if (typeof templates === 'undefined') {
              return run();
            }
            if (isString(templates)) {
              templates = [templates];
            }
            forEach(templates, function(template) {
              toCache.push(template);
            });
            if (hasRun) {
              run();
            }
          }
          function run() {
            var template;
            $ionicTemplateCache._runCount++;
            hasRun = true;
            if (toCache.length === 0)
              return;
            var i = 0;
            while (i < 4 && (template = toCache.pop())) {
              if (isString(template))
                $http.get(template, {cache: $templateCache});
              i++;
            }
            if (toCache.length) {
              $timeout(run, 1000);
            }
          }
          $ionicTemplateCache._runCount = 0;
          return $ionicTemplateCache;
        }]).config(['$stateProvider', '$ionicConfigProvider', function($stateProvider, $ionicConfigProvider) {
          var stateProviderState = $stateProvider.state;
          $stateProvider.state = function(stateName, definition) {
            if (typeof definition === 'object') {
              var enabled = definition.prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
              if (enabled && isString(definition.templateUrl))
                templatesToCache.push(definition.templateUrl);
              if (angular.isObject(definition.views)) {
                for (var key in definition.views) {
                  enabled = definition.views[key].prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
                  if (enabled && isString(definition.views[key].templateUrl))
                    templatesToCache.push(definition.views[key].templateUrl);
                }
              }
            }
            return stateProviderState.call($stateProvider, stateName, definition);
          };
        }]).run(['$ionicTemplateCache', function($ionicTemplateCache) {
          $ionicTemplateCache();
        }]);
      })();
      IonicModule.factory('$ionicTemplateLoader', ['$compile', '$controller', '$http', '$q', '$rootScope', '$templateCache', function($compile, $controller, $http, $q, $rootScope, $templateCache) {
        return {
          load: fetchTemplate,
          compile: loadAndCompile
        };
        function fetchTemplate(url) {
          return $http.get(url, {cache: $templateCache}).then(function(response) {
            return response.data && response.data.trim();
          });
        }
        function loadAndCompile(options) {
          options = extend({
            template: '',
            templateUrl: '',
            scope: null,
            controller: null,
            locals: {},
            appendTo: null
          }, options || {});
          var templatePromise = options.templateUrl ? this.load(options.templateUrl) : $q.when(options.template);
          return templatePromise.then(function(template) {
            var controller;
            var scope = options.scope || $rootScope.$new();
            var element = jqLite('<div>').html(template).contents();
            if (options.controller) {
              controller = $controller(options.controller, extend(options.locals, {$scope: scope}));
              element.children().data('$ngControllerController', controller);
            }
            if (options.appendTo) {
              jqLite(options.appendTo).append(element);
            }
            $compile(element)(scope);
            return {
              element: element,
              scope: scope
            };
          });
        }
      }]);
      IonicModule.factory('$ionicViewService', ['$ionicHistory', '$log', function($ionicHistory, $log) {
        function warn(oldMethod, newMethod) {
          $log.warn('$ionicViewService' + oldMethod + ' is deprecated, please use $ionicHistory' + newMethod + ' instead: http://ionicframework.com/docs/nightly/api/service/$ionicHistory/');
        }
        warn('', '');
        var methodsMap = {
          getCurrentView: 'currentView',
          getBackView: 'backView',
          getForwardView: 'forwardView',
          getCurrentStateName: 'currentStateName',
          nextViewOptions: 'nextViewOptions',
          clearHistory: 'clearHistory'
        };
        forEach(methodsMap, function(newMethod, oldMethod) {
          methodsMap[oldMethod] = function() {
            warn('.' + oldMethod, '.' + newMethod);
            return $ionicHistory[newMethod].apply(this, arguments);
          };
        });
        return methodsMap;
      }]);
      IonicModule.factory('$ionicViewSwitcher', ['$timeout', '$document', '$q', '$ionicClickBlock', '$ionicConfig', '$ionicNavBarDelegate', function($timeout, $document, $q, $ionicClickBlock, $ionicConfig, $ionicNavBarDelegate) {
        var TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
        var DATA_NO_CACHE = '$noCache';
        var DATA_DESTROY_ELE = '$destroyEle';
        var DATA_ELE_IDENTIFIER = '$eleId';
        var DATA_VIEW_ACCESSED = '$accessed';
        var DATA_FALLBACK_TIMER = '$fallbackTimer';
        var DATA_VIEW = '$viewData';
        var NAV_VIEW_ATTR = 'nav-view';
        var VIEW_STATUS_ACTIVE = 'active';
        var VIEW_STATUS_CACHED = 'cached';
        var VIEW_STATUS_STAGED = 'stage';
        var transitionCounter = 0;
        var nextTransition,
            nextDirection;
        ionic.transition = ionic.transition || {};
        ionic.transition.isActive = false;
        var isActiveTimer;
        var cachedAttr = ionic.DomUtil.cachedAttr;
        var transitionPromises = [];
        var defaultTimeout = 1100;
        var ionicViewSwitcher = {
          create: function(navViewCtrl, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
            var enteringEle,
                leavingEle;
            var transitionId = ++transitionCounter;
            var alreadyInDom;
            var switcher = {
              init: function(registerData, callback) {
                ionicViewSwitcher.isTransitioning(true);
                switcher.loadViewElements(registerData);
                switcher.render(registerData, function() {
                  callback && callback();
                });
              },
              loadViewElements: function(registerData) {
                var x,
                    l,
                    viewEle;
                var viewElements = navViewCtrl.getViewElements();
                var enteringEleIdentifier = getViewElementIdentifier(viewLocals, enteringView);
                var navViewActiveEleId = navViewCtrl.activeEleId();
                for (x = 0, l = viewElements.length; x < l; x++) {
                  viewEle = viewElements.eq(x);
                  if (viewEle.data(DATA_ELE_IDENTIFIER) === enteringEleIdentifier) {
                    if (viewEle.data(DATA_NO_CACHE)) {
                      viewEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier + ionic.Utils.nextUid());
                      viewEle.data(DATA_DESTROY_ELE, true);
                    } else {
                      enteringEle = viewEle;
                    }
                  } else if (isDefined(navViewActiveEleId) && viewEle.data(DATA_ELE_IDENTIFIER) === navViewActiveEleId) {
                    leavingEle = viewEle;
                  }
                  if (enteringEle && leavingEle)
                    break;
                }
                alreadyInDom = !!enteringEle;
                if (!alreadyInDom) {
                  enteringEle = registerData.ele || ionicViewSwitcher.createViewEle(viewLocals);
                  enteringEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier);
                }
                if (renderEnd) {
                  navViewCtrl.activeEleId(enteringEleIdentifier);
                }
                registerData.ele = null;
              },
              render: function(registerData, callback) {
                if (alreadyInDom) {
                  ionic.Utils.reconnectScope(enteringEle.scope());
                } else {
                  navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                  var enteringData = getTransitionData(viewLocals, enteringEle, registerData.direction, enteringView);
                  var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                  transitionFn(enteringEle, null, enteringData.direction, true).run(0);
                  enteringEle.data(DATA_VIEW, {
                    viewId: enteringData.viewId,
                    historyId: enteringData.historyId,
                    stateName: enteringData.stateName,
                    stateParams: enteringData.stateParams
                  });
                  if (viewState(viewLocals).cache === false || viewState(viewLocals).cache === 'false' || enteringEle.attr('cache-view') == 'false' || $ionicConfig.views.maxCache() === 0) {
                    enteringEle.data(DATA_NO_CACHE, true);
                  }
                  var viewScope = navViewCtrl.appendViewElement(enteringEle, viewLocals);
                  delete enteringData.direction;
                  delete enteringData.transition;
                  viewScope.$emit('$ionicView.loaded', enteringData);
                }
                enteringEle.data(DATA_VIEW_ACCESSED, Date.now());
                callback && callback();
              },
              transition: function(direction, enableBack, allowAnimate) {
                var deferred;
                var enteringData = getTransitionData(viewLocals, enteringEle, direction, enteringView);
                var leavingData = extend(extend({}, enteringData), getViewData(leavingView));
                enteringData.transitionId = leavingData.transitionId = transitionId;
                enteringData.fromCache = !!alreadyInDom;
                enteringData.enableBack = !!enableBack;
                enteringData.renderStart = renderStart;
                enteringData.renderEnd = renderEnd;
                cachedAttr(enteringEle.parent(), 'nav-view-transition', enteringData.transition);
                cachedAttr(enteringEle.parent(), 'nav-view-direction', enteringData.direction);
                $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                var viewTransition = transitionFn(enteringEle, leavingEle, enteringData.direction, enteringData.shouldAnimate && allowAnimate && renderEnd);
                if (viewTransition.shouldAnimate) {
                  enteringEle.on(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                  enteringEle.data(DATA_FALLBACK_TIMER, $timeout(transitionComplete, defaultTimeout));
                  $ionicClickBlock.show(defaultTimeout);
                }
                if (renderStart) {
                  switcher.emit('before', enteringData, leavingData);
                  navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                  viewTransition.run(0);
                }
                if (renderEnd) {
                  deferred = $q.defer();
                  transitionPromises.push(deferred.promise);
                }
                if (renderStart && renderEnd) {
                  $timeout(onReflow, 16);
                } else if (!renderEnd) {
                  navViewAttr(enteringEle, 'entering');
                  navViewAttr(leavingEle, 'leaving');
                  return {
                    run: viewTransition.run,
                    cancel: function(shouldAnimate) {
                      if (shouldAnimate) {
                        enteringEle.on(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                        enteringEle.data(DATA_FALLBACK_TIMER, $timeout(cancelTransition, defaultTimeout));
                        $ionicClickBlock.show(defaultTimeout);
                      } else {
                        cancelTransition();
                      }
                      viewTransition.shouldAnimate = shouldAnimate;
                      viewTransition.run(0);
                      viewTransition = null;
                    }
                  };
                } else if (renderEnd) {
                  onReflow();
                }
                function onReflow() {
                  navViewAttr(enteringEle, viewTransition.shouldAnimate ? 'entering' : VIEW_STATUS_ACTIVE);
                  navViewAttr(leavingEle, viewTransition.shouldAnimate ? 'leaving' : VIEW_STATUS_CACHED);
                  viewTransition.run(1);
                  $ionicNavBarDelegate._instances.forEach(function(instance) {
                    instance.triggerTransitionStart(transitionId);
                  });
                  if (!viewTransition.shouldAnimate) {
                    transitionComplete();
                  }
                }
                function completeOnTransitionEnd(ev) {
                  if (ev.target !== this)
                    return;
                  transitionComplete();
                }
                function transitionComplete() {
                  if (transitionComplete.x)
                    return;
                  transitionComplete.x = true;
                  enteringEle.off(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                  $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                  leavingEle && $timeout.cancel(leavingEle.data(DATA_FALLBACK_TIMER));
                  switcher.emit('after', enteringData, leavingData);
                  deferred && deferred.resolve(navViewCtrl);
                  if (transitionId === transitionCounter) {
                    $q.all(transitionPromises).then(ionicViewSwitcher.transitionEnd);
                    switcher.cleanup(enteringData);
                  }
                  $ionicNavBarDelegate._instances.forEach(function(instance) {
                    instance.triggerTransitionEnd();
                  });
                  nextTransition = nextDirection = enteringView = leavingView = enteringEle = leavingEle = null;
                }
                function cancelOnTransitionEnd(ev) {
                  if (ev.target !== this)
                    return;
                  cancelTransition();
                }
                function cancelTransition() {
                  navViewAttr(enteringEle, VIEW_STATUS_CACHED);
                  navViewAttr(leavingEle, VIEW_STATUS_ACTIVE);
                  enteringEle.off(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                  $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                  ionicViewSwitcher.transitionEnd([navViewCtrl]);
                }
              },
              emit: function(step, enteringData, leavingData) {
                var enteringScope = enteringEle.scope(),
                    leavingScope = leavingEle && leavingEle.scope();
                if (step == 'after') {
                  if (enteringScope) {
                    enteringScope.$emit('$ionicView.enter', enteringData);
                  }
                  if (leavingScope) {
                    leavingScope.$emit('$ionicView.leave', leavingData);
                  } else if (enteringScope && leavingData && leavingData.viewId) {
                    enteringScope.$emit('$ionicNavView.leave', leavingData);
                  }
                }
                if (enteringScope) {
                  enteringScope.$emit('$ionicView.' + step + 'Enter', enteringData);
                }
                if (leavingScope) {
                  leavingScope.$emit('$ionicView.' + step + 'Leave', leavingData);
                } else if (enteringScope && leavingData && leavingData.viewId) {
                  enteringScope.$emit('$ionicNavView.' + step + 'Leave', leavingData);
                }
              },
              cleanup: function(transData) {
                if (leavingEle && transData.direction == 'back' && !$ionicConfig.views.forwardCache()) {
                  destroyViewEle(leavingEle);
                }
                var viewElements = navViewCtrl.getViewElements();
                var viewElementsLength = viewElements.length;
                var x,
                    viewElement;
                var removeOldestAccess = (viewElementsLength - 1) > $ionicConfig.views.maxCache();
                var removableEle;
                var oldestAccess = Date.now();
                for (x = 0; x < viewElementsLength; x++) {
                  viewElement = viewElements.eq(x);
                  if (removeOldestAccess && viewElement.data(DATA_VIEW_ACCESSED) < oldestAccess) {
                    oldestAccess = viewElement.data(DATA_VIEW_ACCESSED);
                    removableEle = viewElements.eq(x);
                  } else if (viewElement.data(DATA_DESTROY_ELE) && navViewAttr(viewElement) != VIEW_STATUS_ACTIVE) {
                    destroyViewEle(viewElement);
                  }
                }
                destroyViewEle(removableEle);
                if (enteringEle.data(DATA_NO_CACHE)) {
                  enteringEle.data(DATA_DESTROY_ELE, true);
                }
              },
              enteringEle: function() {
                return enteringEle;
              },
              leavingEle: function() {
                return leavingEle;
              }
            };
            return switcher;
          },
          transitionEnd: function(navViewCtrls) {
            forEach(navViewCtrls, function(navViewCtrl) {
              navViewCtrl.transitionEnd();
            });
            ionicViewSwitcher.isTransitioning(false);
            $ionicClickBlock.hide();
            transitionPromises = [];
          },
          nextTransition: function(val) {
            nextTransition = val;
          },
          nextDirection: function(val) {
            nextDirection = val;
          },
          isTransitioning: function(val) {
            if (arguments.length) {
              ionic.transition.isActive = !!val;
              $timeout.cancel(isActiveTimer);
              if (val) {
                isActiveTimer = $timeout(function() {
                  ionicViewSwitcher.isTransitioning(false);
                }, 999);
              }
            }
            return ionic.transition.isActive;
          },
          createViewEle: function(viewLocals) {
            var containerEle = $document[0].createElement('div');
            if (viewLocals && viewLocals.$template) {
              containerEle.innerHTML = viewLocals.$template;
              if (containerEle.children.length === 1) {
                containerEle.children[0].classList.add('pane');
                return jqLite(containerEle.children[0]);
              }
            }
            containerEle.className = "pane";
            return jqLite(containerEle);
          },
          viewEleIsActive: function(viewEle, isActiveAttr) {
            navViewAttr(viewEle, isActiveAttr ? VIEW_STATUS_ACTIVE : VIEW_STATUS_CACHED);
          },
          getTransitionData: getTransitionData,
          navViewAttr: navViewAttr,
          destroyViewEle: destroyViewEle
        };
        return ionicViewSwitcher;
        function getViewElementIdentifier(locals, view) {
          if (viewState(locals)['abstract'])
            return viewState(locals).name;
          if (view)
            return view.stateId || view.viewId;
          return ionic.Utils.nextUid();
        }
        function viewState(locals) {
          return locals && locals.$$state && locals.$$state.self || {};
        }
        function getTransitionData(viewLocals, enteringEle, direction, view) {
          var state = viewState(viewLocals);
          var viewTransition = nextTransition || cachedAttr(enteringEle, 'view-transition') || state.viewTransition || $ionicConfig.views.transition() || 'ios';
          var navBarTransition = $ionicConfig.navBar.transition();
          direction = nextDirection || cachedAttr(enteringEle, 'view-direction') || state.viewDirection || direction || 'none';
          return extend(getViewData(view), {
            transition: viewTransition,
            navBarTransition: navBarTransition === 'view' ? viewTransition : navBarTransition,
            direction: direction,
            shouldAnimate: (viewTransition !== 'none' && direction !== 'none')
          });
        }
        function getViewData(view) {
          view = view || {};
          return {
            viewId: view.viewId,
            historyId: view.historyId,
            stateId: view.stateId,
            stateName: view.stateName,
            stateParams: view.stateParams
          };
        }
        function navViewAttr(ele, value) {
          if (arguments.length > 1) {
            cachedAttr(ele, NAV_VIEW_ATTR, value);
          } else {
            return cachedAttr(ele, NAV_VIEW_ATTR);
          }
        }
        function destroyViewEle(ele) {
          if (ele && ele.length) {
            var viewScope = ele.scope();
            if (viewScope) {
              viewScope.$emit('$ionicView.unloaded', ele.data(DATA_VIEW));
              viewScope.$destroy();
            }
            ele.remove();
          }
        }
      }]);
      IonicModule.config(['$provide', function($provide) {
        $provide.decorator('$compile', ['$delegate', function($compile) {
          $compile.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          };
          return $compile;
        }]);
      }]);
      IonicModule.config(['$provide', function($provide) {
        function $LocationDecorator($location, $timeout) {
          $location.__hash = $location.hash;
          $location.hash = function(value) {
            if (isDefined(value) && value.length > 0) {
              $timeout(function() {
                var scroll = document.querySelector('.scroll-content');
                if (scroll) {
                  scroll.scrollTop = 0;
                }
              }, 0, false);
            }
            return $location.__hash(value);
          };
          return $location;
        }
        $provide.decorator('$location', ['$delegate', '$timeout', $LocationDecorator]);
      }]);
      IonicModule.controller('$ionicHeaderBar', ['$scope', '$element', '$attrs', '$q', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $q, $ionicConfig, $ionicHistory) {
        var TITLE = 'title';
        var BACK_TEXT = 'back-text';
        var BACK_BUTTON = 'back-button';
        var DEFAULT_TITLE = 'default-title';
        var PREVIOUS_TITLE = 'previous-title';
        var HIDE = 'hide';
        var self = this;
        var titleText = '';
        var previousTitleText = '';
        var titleLeft = 0;
        var titleRight = 0;
        var titleCss = '';
        var isBackEnabled = false;
        var isBackShown = true;
        var isNavBackShown = true;
        var isBackElementShown = false;
        var titleTextWidth = 0;
        self.beforeEnter = function(viewData) {
          $scope.$broadcast('$ionicView.beforeEnter', viewData);
        };
        self.title = function(newTitleText) {
          if (arguments.length && newTitleText !== titleText) {
            getEle(TITLE).innerHTML = newTitleText;
            titleText = newTitleText;
            titleTextWidth = 0;
          }
          return titleText;
        };
        self.enableBack = function(shouldEnable, disableReset) {
          if (arguments.length) {
            isBackEnabled = shouldEnable;
            if (!disableReset)
              self.updateBackButton();
          }
          return isBackEnabled;
        };
        self.showBack = function(shouldShow, disableReset) {
          if (arguments.length) {
            isBackShown = shouldShow;
            if (!disableReset)
              self.updateBackButton();
          }
          return isBackShown;
        };
        self.showNavBack = function(shouldShow) {
          isNavBackShown = shouldShow;
          self.updateBackButton();
        };
        self.updateBackButton = function() {
          var ele;
          if ((isBackShown && isNavBackShown && isBackEnabled) !== isBackElementShown) {
            isBackElementShown = isBackShown && isNavBackShown && isBackEnabled;
            ele = getEle(BACK_BUTTON);
            ele && ele.classList[isBackElementShown ? 'remove' : 'add'](HIDE);
          }
          if (isBackEnabled) {
            ele = ele || getEle(BACK_BUTTON);
            if (ele) {
              if (self.backButtonIcon !== $ionicConfig.backButton.icon()) {
                ele = getEle(BACK_BUTTON + ' .icon');
                if (ele) {
                  self.backButtonIcon = $ionicConfig.backButton.icon();
                  ele.className = 'icon ' + self.backButtonIcon;
                }
              }
              if (self.backButtonText !== $ionicConfig.backButton.text()) {
                ele = getEle(BACK_BUTTON + ' .back-text');
                if (ele) {
                  ele.textContent = self.backButtonText = $ionicConfig.backButton.text();
                }
              }
            }
          }
        };
        self.titleTextWidth = function() {
          if (!titleTextWidth) {
            var bounds = ionic.DomUtil.getTextBounds(getEle(TITLE));
            titleTextWidth = Math.min(bounds && bounds.width || 30);
          }
          return titleTextWidth;
        };
        self.titleWidth = function() {
          var titleWidth = self.titleTextWidth();
          var offsetWidth = getEle(TITLE).offsetWidth;
          if (offsetWidth < titleWidth) {
            titleWidth = offsetWidth + (titleLeft - titleRight - 5);
          }
          return titleWidth;
        };
        self.titleTextX = function() {
          return ($element[0].offsetWidth / 2) - (self.titleWidth() / 2);
        };
        self.titleLeftRight = function() {
          return titleLeft - titleRight;
        };
        self.backButtonTextLeft = function() {
          var offsetLeft = 0;
          var ele = getEle(BACK_TEXT);
          while (ele) {
            offsetLeft += ele.offsetLeft;
            ele = ele.parentElement;
          }
          return offsetLeft;
        };
        self.resetBackButton = function(viewData) {
          if ($ionicConfig.backButton.previousTitleText()) {
            var previousTitleEle = getEle(PREVIOUS_TITLE);
            if (previousTitleEle) {
              previousTitleEle.classList.remove(HIDE);
              var view = (viewData && $ionicHistory.getViewById(viewData.viewId));
              var newPreviousTitleText = $ionicHistory.backTitle(view);
              if (newPreviousTitleText !== previousTitleText) {
                previousTitleText = previousTitleEle.innerHTML = newPreviousTitleText;
              }
            }
            var defaultTitleEle = getEle(DEFAULT_TITLE);
            if (defaultTitleEle) {
              defaultTitleEle.classList.remove(HIDE);
            }
          }
        };
        self.align = function(textAlign) {
          var titleEle = getEle(TITLE);
          textAlign = textAlign || $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
          var widths = self.calcWidths(textAlign, false);
          if (isBackShown && previousTitleText && $ionicConfig.backButton.previousTitleText()) {
            var previousTitleWidths = self.calcWidths(textAlign, true);
            var availableTitleWidth = $element[0].offsetWidth - previousTitleWidths.titleLeft - previousTitleWidths.titleRight;
            if (self.titleTextWidth() <= availableTitleWidth) {
              widths = previousTitleWidths;
            }
          }
          return self.updatePositions(titleEle, widths.titleLeft, widths.titleRight, widths.buttonsLeft, widths.buttonsRight, widths.css, widths.showPrevTitle);
        };
        self.calcWidths = function(textAlign, isPreviousTitle) {
          var titleEle = getEle(TITLE);
          var backBtnEle = getEle(BACK_BUTTON);
          var x,
              y,
              z,
              b,
              c,
              d,
              childSize,
              bounds;
          var childNodes = $element[0].childNodes;
          var buttonsLeft = 0;
          var buttonsRight = 0;
          var isCountRightOfTitle;
          var updateTitleLeft = 0;
          var updateTitleRight = 0;
          var updateCss = '';
          var backButtonWidth = 0;
          for (x = 0; x < childNodes.length; x++) {
            c = childNodes[x];
            childSize = 0;
            if (c.nodeType == 1) {
              if (c === titleEle) {
                isCountRightOfTitle = true;
                continue;
              }
              if (c.classList.contains(HIDE)) {
                continue;
              }
              if (isBackShown && c === backBtnEle) {
                for (y = 0; y < c.childNodes.length; y++) {
                  b = c.childNodes[y];
                  if (b.nodeType == 1) {
                    if (b.classList.contains(BACK_TEXT)) {
                      for (z = 0; z < b.children.length; z++) {
                        d = b.children[z];
                        if (isPreviousTitle) {
                          if (d.classList.contains(DEFAULT_TITLE))
                            continue;
                          backButtonWidth += d.offsetWidth;
                        } else {
                          if (d.classList.contains(PREVIOUS_TITLE))
                            continue;
                          backButtonWidth += d.offsetWidth;
                        }
                      }
                    } else {
                      backButtonWidth += b.offsetWidth;
                    }
                  } else if (b.nodeType == 3 && b.nodeValue.trim()) {
                    bounds = ionic.DomUtil.getTextBounds(b);
                    backButtonWidth += bounds && bounds.width || 0;
                  }
                }
                childSize = backButtonWidth || c.offsetWidth;
              } else {
                childSize = c.offsetWidth;
              }
            } else if (c.nodeType == 3 && c.nodeValue.trim()) {
              bounds = ionic.DomUtil.getTextBounds(c);
              childSize = bounds && bounds.width || 0;
            }
            if (isCountRightOfTitle) {
              buttonsRight += childSize;
            } else {
              buttonsLeft += childSize;
            }
          }
          if (textAlign == 'left') {
            updateCss = 'title-left';
            if (buttonsLeft) {
              updateTitleLeft = buttonsLeft + 15;
            }
            if (buttonsRight) {
              updateTitleRight = buttonsRight + 15;
            }
          } else if (textAlign == 'right') {
            updateCss = 'title-right';
            if (buttonsLeft) {
              updateTitleLeft = buttonsLeft + 15;
            }
            if (buttonsRight) {
              updateTitleRight = buttonsRight + 15;
            }
          } else {
            var margin = Math.max(buttonsLeft, buttonsRight) + 10;
            if (margin > 10) {
              updateTitleLeft = updateTitleRight = margin;
            }
          }
          return {
            backButtonWidth: backButtonWidth,
            buttonsLeft: buttonsLeft,
            buttonsRight: buttonsRight,
            titleLeft: updateTitleLeft,
            titleRight: updateTitleRight,
            showPrevTitle: isPreviousTitle,
            css: updateCss
          };
        };
        self.updatePositions = function(titleEle, updateTitleLeft, updateTitleRight, buttonsLeft, buttonsRight, updateCss, showPreviousTitle) {
          var deferred = $q.defer();
          if (titleEle) {
            if (updateTitleLeft !== titleLeft) {
              titleEle.style.left = updateTitleLeft ? updateTitleLeft + 'px' : '';
              titleLeft = updateTitleLeft;
            }
            if (updateTitleRight !== titleRight) {
              titleEle.style.right = updateTitleRight ? updateTitleRight + 'px' : '';
              titleRight = updateTitleRight;
            }
            if (updateCss !== titleCss) {
              updateCss && titleEle.classList.add(updateCss);
              titleCss && titleEle.classList.remove(titleCss);
              titleCss = updateCss;
            }
          }
          if ($ionicConfig.backButton.previousTitleText()) {
            var prevTitle = getEle(PREVIOUS_TITLE);
            var defaultTitle = getEle(DEFAULT_TITLE);
            prevTitle && prevTitle.classList[showPreviousTitle ? 'remove' : 'add'](HIDE);
            defaultTitle && defaultTitle.classList[showPreviousTitle ? 'add' : 'remove'](HIDE);
          }
          ionic.requestAnimationFrame(function() {
            if (titleEle && titleEle.offsetWidth + 10 < titleEle.scrollWidth) {
              var minRight = buttonsRight + 5;
              var testRight = $element[0].offsetWidth - titleLeft - self.titleTextWidth() - 20;
              updateTitleRight = testRight < minRight ? minRight : testRight;
              if (updateTitleRight !== titleRight) {
                titleEle.style.right = updateTitleRight + 'px';
                titleRight = updateTitleRight;
              }
            }
            deferred.resolve();
          });
          return deferred.promise;
        };
        self.setCss = function(elementClassname, css) {
          ionic.DomUtil.cachedStyles(getEle(elementClassname), css);
        };
        var eleCache = {};
        function getEle(className) {
          if (!eleCache[className]) {
            eleCache[className] = $element[0].querySelector('.' + className);
          }
          return eleCache[className];
        }
        $scope.$on('$destroy', function() {
          for (var n in eleCache)
            eleCache[n] = null;
        });
      }]);
      IonicModule.controller('$ionInfiniteScroll', ['$scope', '$attrs', '$element', '$timeout', function($scope, $attrs, $element, $timeout) {
        var self = this;
        self.isLoading = false;
        $scope.icon = function() {
          return isDefined($attrs.icon) ? $attrs.icon : 'ion-load-d';
        };
        $scope.spinner = function() {
          return isDefined($attrs.spinner) ? $attrs.spinner : '';
        };
        $scope.$on('scroll.infiniteScrollComplete', function() {
          finishInfiniteScroll();
        });
        $scope.$on('$destroy', function() {
          if (self.scrollCtrl && self.scrollCtrl.$element)
            self.scrollCtrl.$element.off('scroll', self.checkBounds);
          if (self.scrollEl && self.scrollEl.removeEventListener) {
            self.scrollEl.removeEventListener('scroll', self.checkBounds);
          }
        });
        self.checkBounds = ionic.Utils.throttle(checkInfiniteBounds, 300);
        function onInfinite() {
          ionic.requestAnimationFrame(function() {
            $element[0].classList.add('active');
          });
          self.isLoading = true;
          $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || '');
        }
        function finishInfiniteScroll() {
          ionic.requestAnimationFrame(function() {
            $element[0].classList.remove('active');
          });
          $timeout(function() {
            if (self.jsScrolling)
              self.scrollView.resize();
            if ((self.jsScrolling && self.scrollView.__container && self.scrollView.__container.offsetHeight > 0) || !self.jsScrolling) {
              self.checkBounds();
            }
          }, 30, false);
          self.isLoading = false;
        }
        function checkInfiniteBounds() {
          if (self.isLoading)
            return;
          var maxScroll = {};
          if (self.jsScrolling) {
            maxScroll = self.getJSMaxScroll();
            var scrollValues = self.scrollView.getValues();
            if ((maxScroll.left !== -1 && scrollValues.left >= maxScroll.left) || (maxScroll.top !== -1 && scrollValues.top >= maxScroll.top)) {
              onInfinite();
            }
          } else {
            maxScroll = self.getNativeMaxScroll();
            if ((maxScroll.left !== -1 && self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth) || (maxScroll.top !== -1 && self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight)) {
              onInfinite();
            }
          }
        }
        self.getJSMaxScroll = function() {
          var maxValues = self.scrollView.getScrollMax();
          return {
            left: self.scrollView.options.scrollingX ? calculateMaxValue(maxValues.left) : -1,
            top: self.scrollView.options.scrollingY ? calculateMaxValue(maxValues.top) : -1
          };
        };
        self.getNativeMaxScroll = function() {
          var maxValues = {
            left: self.scrollEl.scrollWidth,
            top: self.scrollEl.scrollHeight
          };
          var computedStyle = window.getComputedStyle(self.scrollEl) || {};
          return {
            left: computedStyle.overflowX === 'scroll' || computedStyle.overflowX === 'auto' || self.scrollEl.style['overflow-x'] === 'scroll' ? calculateMaxValue(maxValues.left) : -1,
            top: computedStyle.overflowY === 'scroll' || computedStyle.overflowY === 'auto' || self.scrollEl.style['overflow-y'] === 'scroll' ? calculateMaxValue(maxValues.top) : -1
          };
        };
        function calculateMaxValue(maximum) {
          var distance = ($attrs.distance || '2.5%').trim();
          var isPercent = distance.indexOf('%') !== -1;
          return isPercent ? maximum * (1 - parseFloat(distance) / 100) : maximum - parseFloat(distance);
        }
        self.__finishInfiniteScroll = finishInfiniteScroll;
      }]);
      IonicModule.service('$ionicListDelegate', ionic.DelegateService(['showReorder', 'showDelete', 'canSwipeItems', 'closeOptionButtons'])).controller('$ionicList', ['$scope', '$attrs', '$ionicListDelegate', '$ionicHistory', function($scope, $attrs, $ionicListDelegate, $ionicHistory) {
        var self = this;
        var isSwipeable = true;
        var isReorderShown = false;
        var isDeleteShown = false;
        var deregisterInstance = $ionicListDelegate._registerInstance(self, $attrs.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on('$destroy', deregisterInstance);
        self.showReorder = function(show) {
          if (arguments.length) {
            isReorderShown = !!show;
          }
          return isReorderShown;
        };
        self.showDelete = function(show) {
          if (arguments.length) {
            isDeleteShown = !!show;
          }
          return isDeleteShown;
        };
        self.canSwipeItems = function(can) {
          if (arguments.length) {
            isSwipeable = !!can;
          }
          return isSwipeable;
        };
        self.closeOptionButtons = function() {
          self.listView && self.listView.clearDragEffects();
        };
      }]);
      IonicModule.controller('$ionicNavBar', ['$scope', '$element', '$attrs', '$compile', '$timeout', '$ionicNavBarDelegate', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $compile, $timeout, $ionicNavBarDelegate, $ionicConfig, $ionicHistory) {
        var CSS_HIDE = 'hide';
        var DATA_NAV_BAR_CTRL = '$ionNavBarController';
        var PRIMARY_BUTTONS = 'primaryButtons';
        var SECONDARY_BUTTONS = 'secondaryButtons';
        var BACK_BUTTON = 'backButton';
        var ITEM_TYPES = 'primaryButtons secondaryButtons leftButtons rightButtons title'.split(' ');
        var self = this;
        var headerBars = [];
        var navElementHtml = {};
        var isVisible = true;
        var queuedTransitionStart,
            queuedTransitionEnd,
            latestTransitionId;
        $element.parent().data(DATA_NAV_BAR_CTRL, self);
        var delegateHandle = $attrs.delegateHandle || 'navBar' + ionic.Utils.nextUid();
        var deregisterInstance = $ionicNavBarDelegate._registerInstance(self, delegateHandle);
        self.init = function() {
          $element.addClass('nav-bar-container');
          ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', $ionicConfig.views.transition());
          self.createHeaderBar(false);
          self.createHeaderBar(true);
          $scope.$emit('ionNavBar.init', delegateHandle);
        };
        self.createHeaderBar = function(isActive) {
          var containerEle = jqLite('<div class="nav-bar-block">');
          ionic.DomUtil.cachedAttr(containerEle, 'nav-bar', isActive ? 'active' : 'cached');
          var alignTitle = $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
          var headerBarEle = jqLite('<ion-header-bar>').addClass($attrs['class']).attr('align-title', alignTitle);
          if (isDefined($attrs.noTapScroll))
            headerBarEle.attr('no-tap-scroll', $attrs.noTapScroll);
          var titleEle = jqLite('<div class="title title-' + alignTitle + '">');
          var navEle = {};
          var lastViewItemEle = {};
          var leftButtonsEle,
              rightButtonsEle;
          navEle[BACK_BUTTON] = createNavElement(BACK_BUTTON);
          navEle[BACK_BUTTON] && headerBarEle.append(navEle[BACK_BUTTON]);
          headerBarEle.append(titleEle);
          forEach(ITEM_TYPES, function(itemType) {
            navEle[itemType] = createNavElement(itemType);
            positionItem(navEle[itemType], itemType);
          });
          for (var x = 0; x < headerBarEle[0].children.length; x++) {
            headerBarEle[0].children[x].classList.add('header-item');
          }
          containerEle.append(headerBarEle);
          $element.append($compile(containerEle)($scope.$new()));
          var headerBarCtrl = headerBarEle.data('$ionHeaderBarController');
          headerBarCtrl.backButtonIcon = $ionicConfig.backButton.icon();
          headerBarCtrl.backButtonText = $ionicConfig.backButton.text();
          var headerBarInstance = {
            isActive: isActive,
            title: function(newTitleText) {
              headerBarCtrl.title(newTitleText);
            },
            setItem: function(navBarItemEle, itemType) {
              headerBarInstance.removeItem(itemType);
              if (navBarItemEle) {
                if (itemType === 'title') {
                  headerBarInstance.title("");
                }
                positionItem(navBarItemEle, itemType);
                if (navEle[itemType]) {
                  navEle[itemType].addClass(CSS_HIDE);
                }
                lastViewItemEle[itemType] = navBarItemEle;
              } else if (navEle[itemType]) {
                navEle[itemType].removeClass(CSS_HIDE);
              }
            },
            removeItem: function(itemType) {
              if (lastViewItemEle[itemType]) {
                lastViewItemEle[itemType].scope().$destroy();
                lastViewItemEle[itemType].remove();
                lastViewItemEle[itemType] = null;
              }
            },
            containerEle: function() {
              return containerEle;
            },
            headerBarEle: function() {
              return headerBarEle;
            },
            afterLeave: function() {
              forEach(ITEM_TYPES, function(itemType) {
                headerBarInstance.removeItem(itemType);
              });
              headerBarCtrl.resetBackButton();
            },
            controller: function() {
              return headerBarCtrl;
            },
            destroy: function() {
              forEach(ITEM_TYPES, function(itemType) {
                headerBarInstance.removeItem(itemType);
              });
              containerEle.scope().$destroy();
              for (var n in navEle) {
                if (navEle[n]) {
                  navEle[n].removeData();
                  navEle[n] = null;
                }
              }
              leftButtonsEle && leftButtonsEle.removeData();
              rightButtonsEle && rightButtonsEle.removeData();
              titleEle.removeData();
              headerBarEle.removeData();
              containerEle.remove();
              containerEle = headerBarEle = titleEle = leftButtonsEle = rightButtonsEle = null;
            }
          };
          function positionItem(ele, itemType) {
            if (!ele)
              return;
            if (itemType === 'title') {
              titleEle.append(ele);
            } else if (itemType == 'rightButtons' || (itemType == SECONDARY_BUTTONS && $ionicConfig.navBar.positionSecondaryButtons() != 'left') || (itemType == PRIMARY_BUTTONS && $ionicConfig.navBar.positionPrimaryButtons() == 'right')) {
              if (!rightButtonsEle) {
                rightButtonsEle = jqLite('<div class="buttons buttons-right">');
                headerBarEle.append(rightButtonsEle);
              }
              if (itemType == SECONDARY_BUTTONS) {
                rightButtonsEle.append(ele);
              } else {
                rightButtonsEle.prepend(ele);
              }
            } else {
              if (!leftButtonsEle) {
                leftButtonsEle = jqLite('<div class="buttons buttons-left">');
                if (navEle[BACK_BUTTON]) {
                  navEle[BACK_BUTTON].after(leftButtonsEle);
                } else {
                  headerBarEle.prepend(leftButtonsEle);
                }
              }
              if (itemType == SECONDARY_BUTTONS) {
                leftButtonsEle.append(ele);
              } else {
                leftButtonsEle.prepend(ele);
              }
            }
          }
          headerBars.push(headerBarInstance);
          return headerBarInstance;
        };
        self.navElement = function(type, html) {
          if (isDefined(html)) {
            navElementHtml[type] = html;
          }
          return navElementHtml[type];
        };
        self.update = function(viewData) {
          var showNavBar = !viewData.hasHeaderBar && viewData.showNavBar;
          viewData.transition = $ionicConfig.views.transition();
          if (!showNavBar) {
            viewData.direction = 'none';
          }
          self.enable(showNavBar);
          var enteringHeaderBar = self.isInitialized ? getOffScreenHeaderBar() : getOnScreenHeaderBar();
          var leavingHeaderBar = self.isInitialized ? getOnScreenHeaderBar() : null;
          var enteringHeaderCtrl = enteringHeaderBar.controller();
          enteringHeaderCtrl.enableBack(viewData.enableBack, true);
          enteringHeaderCtrl.showBack(viewData.showBack, true);
          enteringHeaderCtrl.updateBackButton();
          self.title(viewData.title, enteringHeaderBar);
          self.showBar(showNavBar);
          if (viewData.navBarItems) {
            forEach(ITEM_TYPES, function(itemType) {
              enteringHeaderBar.setItem(viewData.navBarItems[itemType], itemType);
            });
          }
          self.transition(enteringHeaderBar, leavingHeaderBar, viewData);
          self.isInitialized = true;
          navSwipeAttr('');
        };
        self.transition = function(enteringHeaderBar, leavingHeaderBar, viewData) {
          var enteringHeaderBarCtrl = enteringHeaderBar.controller();
          var transitionFn = $ionicConfig.transitions.navBar[viewData.navBarTransition] || $ionicConfig.transitions.navBar.none;
          var transitionId = viewData.transitionId;
          enteringHeaderBarCtrl.beforeEnter(viewData);
          var navBarTransition = transitionFn(enteringHeaderBar, leavingHeaderBar, viewData.direction, viewData.shouldAnimate && self.isInitialized);
          ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', viewData.navBarTransition);
          ionic.DomUtil.cachedAttr($element, 'nav-bar-direction', viewData.direction);
          if (navBarTransition.shouldAnimate && viewData.renderEnd) {
            navBarAttr(enteringHeaderBar, 'stage');
          } else {
            navBarAttr(enteringHeaderBar, 'entering');
            navBarAttr(leavingHeaderBar, 'leaving');
          }
          enteringHeaderBarCtrl.resetBackButton(viewData);
          navBarTransition.run(0);
          self.activeTransition = {
            run: function(step) {
              navBarTransition.shouldAnimate = false;
              navBarTransition.direction = 'back';
              navBarTransition.run(step);
            },
            cancel: function(shouldAnimate, speed, cancelData) {
              navSwipeAttr(speed);
              navBarAttr(leavingHeaderBar, 'active');
              navBarAttr(enteringHeaderBar, 'cached');
              navBarTransition.shouldAnimate = shouldAnimate;
              navBarTransition.run(0);
              self.activeTransition = navBarTransition = null;
              var runApply;
              if (cancelData.showBar !== self.showBar()) {
                self.showBar(cancelData.showBar);
              }
              if (cancelData.showBackButton !== self.showBackButton()) {
                self.showBackButton(cancelData.showBackButton);
              }
              if (runApply) {
                $scope.$apply();
              }
            },
            complete: function(shouldAnimate, speed) {
              navSwipeAttr(speed);
              navBarTransition.shouldAnimate = shouldAnimate;
              navBarTransition.run(1);
              queuedTransitionEnd = transitionEnd;
            }
          };
          $timeout(enteringHeaderBarCtrl.align, 16);
          queuedTransitionStart = function() {
            if (latestTransitionId !== transitionId)
              return;
            navBarAttr(enteringHeaderBar, 'entering');
            navBarAttr(leavingHeaderBar, 'leaving');
            navBarTransition.run(1);
            queuedTransitionEnd = function() {
              if (latestTransitionId == transitionId || !navBarTransition.shouldAnimate) {
                transitionEnd();
              }
            };
            queuedTransitionStart = null;
          };
          function transitionEnd() {
            for (var x = 0; x < headerBars.length; x++) {
              headerBars[x].isActive = false;
            }
            enteringHeaderBar.isActive = true;
            navBarAttr(enteringHeaderBar, 'active');
            navBarAttr(leavingHeaderBar, 'cached');
            self.activeTransition = navBarTransition = queuedTransitionEnd = null;
          }
          queuedTransitionStart();
        };
        self.triggerTransitionStart = function(triggerTransitionId) {
          latestTransitionId = triggerTransitionId;
          queuedTransitionStart && queuedTransitionStart();
        };
        self.triggerTransitionEnd = function() {
          queuedTransitionEnd && queuedTransitionEnd();
        };
        self.showBar = function(shouldShow) {
          if (arguments.length) {
            self.visibleBar(shouldShow);
            $scope.$parent.$hasHeader = !!shouldShow;
          }
          return !!$scope.$parent.$hasHeader;
        };
        self.visibleBar = function(shouldShow) {
          if (shouldShow && !isVisible) {
            $element.removeClass(CSS_HIDE);
            self.align();
          } else if (!shouldShow && isVisible) {
            $element.addClass(CSS_HIDE);
          }
          isVisible = shouldShow;
        };
        self.enable = function(val) {
          self.visibleBar(val);
          for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
            if ($ionicNavBarDelegate._instances[x] !== self)
              $ionicNavBarDelegate._instances[x].visibleBar(false);
          }
        };
        self.showBackButton = function(shouldShow) {
          if (arguments.length) {
            for (var x = 0; x < headerBars.length; x++) {
              headerBars[x].controller().showNavBack(!!shouldShow);
            }
            $scope.$isBackButtonShown = !!shouldShow;
          }
          return $scope.$isBackButtonShown;
        };
        self.showActiveBackButton = function(shouldShow) {
          var headerBar = getOnScreenHeaderBar();
          if (headerBar) {
            if (arguments.length) {
              return headerBar.controller().showBack(shouldShow);
            }
            return headerBar.controller().showBack();
          }
        };
        self.title = function(newTitleText, headerBar) {
          if (isDefined(newTitleText)) {
            newTitleText = newTitleText || '';
            headerBar = headerBar || getOnScreenHeaderBar();
            headerBar && headerBar.title(newTitleText);
            $scope.$title = newTitleText;
            $ionicHistory.currentTitle(newTitleText);
          }
          return $scope.$title;
        };
        self.align = function(val, headerBar) {
          headerBar = headerBar || getOnScreenHeaderBar();
          headerBar && headerBar.controller().align(val);
        };
        self.hasTabsTop = function(isTabsTop) {
          $element[isTabsTop ? 'addClass' : 'removeClass']('nav-bar-tabs-top');
        };
        self.hasBarSubheader = function(isBarSubheader) {
          $element[isBarSubheader ? 'addClass' : 'removeClass']('nav-bar-has-subheader');
        };
        self.changeTitle = function(val) {
          deprecatedWarning('changeTitle(val)', 'title(val)');
          self.title(val);
        };
        self.setTitle = function(val) {
          deprecatedWarning('setTitle(val)', 'title(val)');
          self.title(val);
        };
        self.getTitle = function() {
          deprecatedWarning('getTitle()', 'title()');
          return self.title();
        };
        self.back = function() {
          deprecatedWarning('back()', '$ionicHistory.goBack()');
          $ionicHistory.goBack();
        };
        self.getPreviousTitle = function() {
          deprecatedWarning('getPreviousTitle()', '$ionicHistory.backTitle()');
          $ionicHistory.goBack();
        };
        function deprecatedWarning(oldMethod, newMethod) {
          var warn = console.warn || console.log;
          warn && warn.call(console, 'navBarController.' + oldMethod + ' is deprecated, please use ' + newMethod + ' instead');
        }
        function createNavElement(type) {
          if (navElementHtml[type]) {
            return jqLite(navElementHtml[type]);
          }
        }
        function getOnScreenHeaderBar() {
          for (var x = 0; x < headerBars.length; x++) {
            if (headerBars[x].isActive)
              return headerBars[x];
          }
        }
        function getOffScreenHeaderBar() {
          for (var x = 0; x < headerBars.length; x++) {
            if (!headerBars[x].isActive)
              return headerBars[x];
          }
        }
        function navBarAttr(ctrl, val) {
          ctrl && ionic.DomUtil.cachedAttr(ctrl.containerEle(), 'nav-bar', val);
        }
        function navSwipeAttr(val) {
          ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
        }
        $scope.$on('$destroy', function() {
          $scope.$parent.$hasHeader = false;
          $element.parent().removeData(DATA_NAV_BAR_CTRL);
          for (var x = 0; x < headerBars.length; x++) {
            headerBars[x].destroy();
          }
          $element.remove();
          $element = headerBars = null;
          deregisterInstance();
        });
      }]);
      IonicModule.controller('$ionicNavView', ['$scope', '$element', '$attrs', '$compile', '$controller', '$ionicNavBarDelegate', '$ionicNavViewDelegate', '$ionicHistory', '$ionicViewSwitcher', '$ionicConfig', '$ionicScrollDelegate', function($scope, $element, $attrs, $compile, $controller, $ionicNavBarDelegate, $ionicNavViewDelegate, $ionicHistory, $ionicViewSwitcher, $ionicConfig, $ionicScrollDelegate) {
        var DATA_ELE_IDENTIFIER = '$eleId';
        var DATA_DESTROY_ELE = '$destroyEle';
        var DATA_NO_CACHE = '$noCache';
        var VIEW_STATUS_ACTIVE = 'active';
        var VIEW_STATUS_CACHED = 'cached';
        var self = this;
        var direction;
        var isPrimary = false;
        var navBarDelegate;
        var activeEleId;
        var navViewAttr = $ionicViewSwitcher.navViewAttr;
        var disableRenderStartViewId,
            disableAnimation;
        self.scope = $scope;
        self.element = $element;
        self.init = function() {
          var navViewName = $attrs.name || '';
          var parent = $element.parent().inheritedData('$uiView');
          var parentViewName = ((parent && parent.state) ? parent.state.name : '');
          if (navViewName.indexOf('@') < 0)
            navViewName = navViewName + '@' + parentViewName;
          var viewData = {
            name: navViewName,
            state: null
          };
          $element.data('$uiView', viewData);
          var deregisterInstance = $ionicNavViewDelegate._registerInstance(self, $attrs.delegateHandle);
          $scope.$on('$destroy', function() {
            deregisterInstance();
            if (self.isSwipeFreeze) {
              $ionicScrollDelegate.freezeAllScrolls(false);
            }
          });
          $scope.$on('$ionicHistory.deselect', self.cacheCleanup);
          $scope.$on('$ionicTabs.top', onTabsTop);
          $scope.$on('$ionicSubheader', onBarSubheader);
          $scope.$on('$ionicTabs.beforeLeave', onTabsLeave);
          $scope.$on('$ionicTabs.afterLeave', onTabsLeave);
          $scope.$on('$ionicTabs.leave', onTabsLeave);
          ionic.Platform.ready(function() {
            if (ionic.Platform.isWebView() && $ionicConfig.views.swipeBackEnabled()) {
              self.initSwipeBack();
            }
          });
          return viewData;
        };
        self.register = function(viewLocals) {
          var leavingView = extend({}, $ionicHistory.currentView());
          var registerData = $ionicHistory.register($scope, viewLocals);
          self.update(registerData);
          var enteringView = $ionicHistory.getViewById(registerData.viewId) || {};
          var renderStart = (disableRenderStartViewId !== registerData.viewId);
          self.render(registerData, viewLocals, enteringView, leavingView, renderStart, true);
        };
        self.update = function(registerData) {
          isPrimary = true;
          direction = registerData.direction;
          var parentNavViewCtrl = $element.parent().inheritedData('$ionNavViewController');
          if (parentNavViewCtrl) {
            parentNavViewCtrl.isPrimary(false);
            if (direction === 'enter' || direction === 'exit') {
              parentNavViewCtrl.direction(direction);
              if (direction === 'enter') {
                direction = 'none';
              }
            }
          }
        };
        self.render = function(registerData, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
          var switcher = $ionicViewSwitcher.create(self, viewLocals, enteringView, leavingView, renderStart, renderEnd);
          switcher.init(registerData, function() {
            switcher.transition(self.direction(), registerData.enableBack, !disableAnimation);
            disableRenderStartViewId = disableAnimation = null;
          });
        };
        self.beforeEnter = function(transitionData) {
          if (isPrimary) {
            navBarDelegate = transitionData.navBarDelegate;
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            associatedNavBarCtrl && associatedNavBarCtrl.update(transitionData);
            navSwipeAttr('');
          }
        };
        self.activeEleId = function(eleId) {
          if (arguments.length) {
            activeEleId = eleId;
          }
          return activeEleId;
        };
        self.transitionEnd = function() {
          var viewElements = $element.children();
          var x,
              l,
              viewElement;
          for (x = 0, l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (viewElement.data(DATA_ELE_IDENTIFIER) === activeEleId) {
              navViewAttr(viewElement, VIEW_STATUS_ACTIVE);
            } else if (navViewAttr(viewElement) === 'leaving' || navViewAttr(viewElement) === VIEW_STATUS_ACTIVE || navViewAttr(viewElement) === VIEW_STATUS_CACHED) {
              if (viewElement.data(DATA_DESTROY_ELE) || viewElement.data(DATA_NO_CACHE)) {
                $ionicViewSwitcher.destroyViewEle(viewElement);
              } else {
                navViewAttr(viewElement, VIEW_STATUS_CACHED);
                ionic.Utils.disconnectScope(viewElement.scope());
              }
            }
          }
          navSwipeAttr('');
          if (self.isSwipeFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(false);
          }
        };
        function onTabsLeave(ev, data) {
          var viewElements = $element.children();
          var viewElement,
              viewScope;
          for (var x = 0,
              l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
              viewScope = viewElement.scope();
              viewScope && viewScope.$emit(ev.name.replace('Tabs', 'View'), data);
              break;
            }
          }
        }
        self.cacheCleanup = function() {
          var viewElements = $element.children();
          for (var x = 0,
              l = viewElements.length; x < l; x++) {
            if (viewElements.eq(x).data(DATA_DESTROY_ELE)) {
              $ionicViewSwitcher.destroyViewEle(viewElements.eq(x));
            }
          }
        };
        self.clearCache = function(stateIds) {
          var viewElements = $element.children();
          var viewElement,
              viewScope,
              x,
              l,
              y,
              eleIdentifier;
          for (x = 0, l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (stateIds) {
              eleIdentifier = viewElement.data(DATA_ELE_IDENTIFIER);
              for (y = 0; y < stateIds.length; y++) {
                if (eleIdentifier === stateIds[y]) {
                  $ionicViewSwitcher.destroyViewEle(viewElement);
                }
              }
              continue;
            }
            if (navViewAttr(viewElement) == VIEW_STATUS_CACHED) {
              $ionicViewSwitcher.destroyViewEle(viewElement);
            } else if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
              viewScope = viewElement.scope();
              viewScope && viewScope.$broadcast('$ionicView.clearCache');
            }
          }
        };
        self.getViewElements = function() {
          return $element.children();
        };
        self.appendViewElement = function(viewEle, viewLocals) {
          var linkFn = $compile(viewEle);
          $element.append(viewEle);
          var viewScope = $scope.$new();
          if (viewLocals && viewLocals.$$controller) {
            viewLocals.$scope = viewScope;
            var controller = $controller(viewLocals.$$controller, viewLocals);
            $element.children().data('$ngControllerController', controller);
          }
          linkFn(viewScope);
          return viewScope;
        };
        self.title = function(val) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.title(val);
        };
        self.enableBackButton = function(shouldEnable) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.enableBackButton(shouldEnable);
        };
        self.showBackButton = function(shouldShow) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          if (associatedNavBarCtrl) {
            if (arguments.length) {
              return associatedNavBarCtrl.showActiveBackButton(shouldShow);
            }
            return associatedNavBarCtrl.showActiveBackButton();
          }
          return true;
        };
        self.showBar = function(val) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          if (associatedNavBarCtrl) {
            if (arguments.length) {
              return associatedNavBarCtrl.showBar(val);
            }
            return associatedNavBarCtrl.showBar();
          }
          return true;
        };
        self.isPrimary = function(val) {
          if (arguments.length) {
            isPrimary = val;
          }
          return isPrimary;
        };
        self.direction = function(val) {
          if (arguments.length) {
            direction = val;
          }
          return direction;
        };
        self.initSwipeBack = function() {
          var swipeBackHitWidth = $ionicConfig.views.swipeBackHitWidth();
          var viewTransition,
              associatedNavBarCtrl,
              backView;
          var deregDragStart,
              deregDrag,
              deregRelease;
          var windowWidth,
              startDragX,
              dragPoints;
          var cancelData = {};
          function onDragStart(ev) {
            if (!isPrimary)
              return;
            startDragX = getDragX(ev);
            if (startDragX > swipeBackHitWidth)
              return;
            backView = $ionicHistory.backView();
            var currentView = $ionicHistory.currentView();
            if (!backView || backView.historyId !== currentView.historyId || currentView.canSwipeBack === false)
              return;
            if (!windowWidth)
              windowWidth = window.innerWidth;
            self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(true);
            var registerData = {direction: 'back'};
            dragPoints = [];
            cancelData = {
              showBar: self.showBar(),
              showBackButton: self.showBackButton()
            };
            var switcher = $ionicViewSwitcher.create(self, registerData, backView, currentView, true, false);
            switcher.loadViewElements(registerData);
            switcher.render(registerData);
            viewTransition = switcher.transition('back', $ionicHistory.enabledBack(backView), true);
            associatedNavBarCtrl = getAssociatedNavBarCtrl();
            deregDrag = ionic.onGesture('drag', onDrag, $element[0]);
            deregRelease = ionic.onGesture('release', onRelease, $element[0]);
          }
          function onDrag(ev) {
            if (isPrimary && viewTransition) {
              var dragX = getDragX(ev);
              dragPoints.push({
                t: Date.now(),
                x: dragX
              });
              if (dragX >= windowWidth - 15) {
                onRelease(ev);
              } else {
                var step = Math.min(Math.max(getSwipeCompletion(dragX), 0), 1);
                viewTransition.run(step);
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.run(step);
              }
            }
          }
          function onRelease(ev) {
            if (isPrimary && viewTransition && dragPoints && dragPoints.length > 1) {
              var now = Date.now();
              var releaseX = getDragX(ev);
              var startDrag = dragPoints[dragPoints.length - 1];
              for (var x = dragPoints.length - 2; x >= 0; x--) {
                if (now - startDrag.t > 200) {
                  break;
                }
                startDrag = dragPoints[x];
              }
              var isSwipingRight = (releaseX >= dragPoints[dragPoints.length - 2].x);
              var releaseSwipeCompletion = getSwipeCompletion(releaseX);
              var velocity = Math.abs(startDrag.x - releaseX) / (now - startDrag.t);
              disableRenderStartViewId = backView.viewId;
              disableAnimation = (releaseSwipeCompletion < 0.03 || releaseSwipeCompletion > 0.97);
              if (isSwipingRight && (releaseSwipeCompletion > 0.5 || velocity > 0.1)) {
                var speed = (velocity > 0.5 || velocity < 0.05 || releaseX > windowWidth - 45) ? 'fast' : 'slow';
                navSwipeAttr(disableAnimation ? '' : speed);
                backView.go();
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.complete(!disableAnimation, speed);
              } else {
                navSwipeAttr(disableAnimation ? '' : 'fast');
                disableRenderStartViewId = null;
                viewTransition.cancel(!disableAnimation);
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.cancel(!disableAnimation, 'fast', cancelData);
                disableAnimation = null;
              }
            }
            ionic.offGesture(deregDrag, 'drag', onDrag);
            ionic.offGesture(deregRelease, 'release', onRelease);
            windowWidth = viewTransition = dragPoints = null;
            self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(false);
          }
          function getDragX(ev) {
            return ionic.tap.pointerCoord(ev.gesture.srcEvent).x;
          }
          function getSwipeCompletion(dragX) {
            return (dragX - startDragX) / windowWidth;
          }
          deregDragStart = ionic.onGesture('dragstart', onDragStart, $element[0]);
          $scope.$on('$destroy', function() {
            ionic.offGesture(deregDragStart, 'dragstart', onDragStart);
            ionic.offGesture(deregDrag, 'drag', onDrag);
            ionic.offGesture(deregRelease, 'release', onRelease);
            self.element = viewTransition = associatedNavBarCtrl = null;
          });
        };
        function navSwipeAttr(val) {
          ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
        }
        function onTabsTop(ev, isTabsTop) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.hasTabsTop(isTabsTop);
        }
        function onBarSubheader(ev, isBarSubheader) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.hasBarSubheader(isBarSubheader);
        }
        function getAssociatedNavBarCtrl() {
          if (navBarDelegate) {
            for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
              if ($ionicNavBarDelegate._instances[x].$$delegateHandle == navBarDelegate) {
                return $ionicNavBarDelegate._instances[x];
              }
            }
          }
          return $element.inheritedData('$ionNavBarController');
        }
      }]);
      IonicModule.controller('$ionicRefresher', ['$scope', '$attrs', '$element', '$ionicBind', '$timeout', function($scope, $attrs, $element, $ionicBind, $timeout) {
        var self = this,
            isDragging = false,
            isOverscrolling = false,
            dragOffset = 0,
            lastOverscroll = 0,
            ptrThreshold = 60,
            activated = false,
            scrollTime = 500,
            startY = null,
            deltaY = null,
            canOverscroll = true,
            scrollParent,
            scrollChild;
        if (!isDefined($attrs.pullingIcon)) {
          $attrs.$set('pullingIcon', 'ion-android-arrow-down');
        }
        $scope.showSpinner = !isDefined($attrs.refreshingIcon) && $attrs.spinner != 'none';
        $scope.showIcon = isDefined($attrs.refreshingIcon);
        $ionicBind($scope, $attrs, {
          pullingIcon: '@',
          pullingText: '@',
          refreshingIcon: '@',
          refreshingText: '@',
          spinner: '@',
          disablePullingRotation: '@',
          $onRefresh: '&onRefresh',
          $onPulling: '&onPulling'
        });
        function handleTouchend() {
          if (!canOverscroll && !isDragging) {
            return;
          }
          startY = null;
          if (!isDragging) {
            dragOffset = 0;
            isOverscrolling = false;
            setScrollLock(false);
          } else {
            isDragging = false;
            dragOffset = 0;
            if (lastOverscroll > ptrThreshold) {
              start();
              scrollTo(ptrThreshold, scrollTime);
            } else {
              scrollTo(0, scrollTime, deactivate);
              isOverscrolling = false;
            }
          }
        }
        function handleTouchmove(e) {
          if (!canOverscroll || e.touches.length > 1) {
            return;
          }
          if (startY === null) {
            startY = parseInt(e.touches[0].screenY, 10);
          }
          if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && scrollParent.scrollTop === 0) {
            isDragging = true;
            e.preventDefault();
          }
          deltaY = parseInt(e.touches[0].screenY, 10) - startY;
          if (deltaY - dragOffset <= 0 || scrollParent.scrollTop !== 0) {
            if (isOverscrolling) {
              isOverscrolling = false;
              setScrollLock(false);
            }
            if (isDragging) {
              nativescroll(scrollParent, parseInt(deltaY - dragOffset, 10) * -1);
            }
            if (lastOverscroll !== 0) {
              overscroll(0);
            }
            return;
          } else if (deltaY > 0 && scrollParent.scrollTop === 0 && !isOverscrolling) {
            dragOffset = deltaY;
          }
          e.preventDefault();
          if (!isOverscrolling) {
            isOverscrolling = true;
            setScrollLock(true);
          }
          isDragging = true;
          overscroll(parseInt((deltaY - dragOffset) / 3, 10));
          if (!activated && lastOverscroll > ptrThreshold) {
            activated = true;
            ionic.requestAnimationFrame(activate);
          } else if (activated && lastOverscroll < ptrThreshold) {
            activated = false;
            ionic.requestAnimationFrame(deactivate);
          }
        }
        function handleScroll(e) {
          canOverscroll = (e.target.scrollTop === 0) || isDragging;
        }
        function overscroll(val) {
          scrollChild.style[ionic.CSS.TRANSFORM] = 'translateY(' + val + 'px)';
          lastOverscroll = val;
        }
        function nativescroll(target, newScrollTop) {
          target.scrollTop = newScrollTop;
          var e = document.createEvent("UIEvents");
          e.initUIEvent("scroll", true, true, window, 1);
          target.dispatchEvent(e);
        }
        function setScrollLock(enabled) {
          if (enabled) {
            ionic.requestAnimationFrame(function() {
              scrollChild.classList.add('overscroll');
              show();
            });
          } else {
            ionic.requestAnimationFrame(function() {
              scrollChild.classList.remove('overscroll');
              hide();
              deactivate();
            });
          }
        }
        $scope.$on('scroll.refreshComplete', function() {
          $timeout(function() {
            ionic.requestAnimationFrame(tail);
            scrollTo(0, scrollTime, deactivate);
            $timeout(function() {
              if (isOverscrolling) {
                isOverscrolling = false;
                setScrollLock(false);
              }
            }, scrollTime);
          }, scrollTime);
        });
        function scrollTo(Y, duration, callback) {
          var start = Date.now(),
              from = lastOverscroll;
          if (from === Y) {
            callback();
            return;
          }
          function easeOutCubic(t) {
            return (--t) * t * t + 1;
          }
          function scroll() {
            var currentTime = Date.now(),
                time = Math.min(1, ((currentTime - start) / duration)),
                easedT = easeOutCubic(time);
            overscroll(parseInt((easedT * (Y - from)) + from, 10));
            if (time < 1) {
              ionic.requestAnimationFrame(scroll);
            } else {
              if (Y < 5 && Y > -5) {
                isOverscrolling = false;
                setScrollLock(false);
              }
              callback && callback();
            }
          }
          ionic.requestAnimationFrame(scroll);
        }
        self.init = function() {
          scrollParent = $element.parent().parent()[0];
          scrollChild = $element.parent()[0];
          if (!scrollParent || !scrollParent.classList.contains('ionic-scroll') || !scrollChild || !scrollChild.classList.contains('scroll')) {
            throw new Error('Refresher must be immediate child of ion-content or ion-scroll');
          }
          ionic.on('touchmove', handleTouchmove, scrollChild);
          ionic.on('touchend', handleTouchend, scrollChild);
          ionic.on('scroll', handleScroll, scrollParent);
          $scope.$on('$destroy', destroy);
        };
        function destroy() {
          ionic.off('touchmove', handleTouchmove, scrollChild);
          ionic.off('touchend', handleTouchend, scrollChild);
          ionic.off('scroll', handleScroll, scrollParent);
          scrollParent = null;
          scrollChild = null;
        }
        self.getRefresherDomMethods = function() {
          return {
            activate: activate,
            deactivate: deactivate,
            start: start,
            show: show,
            hide: hide,
            tail: tail
          };
        };
        function activate() {
          $element[0].classList.add('active');
          $scope.$onPulling();
        }
        function deactivate() {
          $timeout(function() {
            $element.removeClass('active refreshing refreshing-tail');
            if (activated)
              activated = false;
          }, 150);
        }
        function start() {
          $element[0].classList.add('refreshing');
          $scope.$onRefresh();
        }
        function show() {
          $element[0].classList.remove('invisible');
        }
        function hide() {
          $element[0].classList.add('invisible');
        }
        function tail() {
          $element[0].classList.add('refreshing-tail');
        }
        self.__handleTouchmove = handleTouchmove;
        self.__getScrollChild = function() {
          return scrollChild;
        };
        self.__getScrollParent = function() {
          return scrollParent;
        };
      }]);
      IonicModule.controller('$ionicScroll', ['$scope', 'scrollViewOptions', '$timeout', '$window', '$location', '$document', '$ionicScrollDelegate', '$ionicHistory', function($scope, scrollViewOptions, $timeout, $window, $location, $document, $ionicScrollDelegate, $ionicHistory) {
        var self = this;
        self.__timeout = $timeout;
        self._scrollViewOptions = scrollViewOptions;
        self.isNative = function() {
          return !!scrollViewOptions.nativeScrolling;
        };
        var element = self.element = scrollViewOptions.el;
        var $element = self.$element = jqLite(element);
        var scrollView;
        if (self.isNative()) {
          scrollView = self.scrollView = new ionic.views.ScrollNative(scrollViewOptions);
        } else {
          scrollView = self.scrollView = new ionic.views.Scroll(scrollViewOptions);
        }
        ($element.parent().length ? $element.parent() : $element).data('$$ionicScrollController', self);
        var deregisterInstance = $ionicScrollDelegate._registerInstance(self, scrollViewOptions.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        if (!isDefined(scrollViewOptions.bouncing)) {
          ionic.Platform.ready(function() {
            if (scrollView.options) {
              scrollView.options.bouncing = true;
              if (ionic.Platform.isAndroid()) {
                scrollView.options.bouncing = false;
                scrollView.options.deceleration = 0.95;
              }
            }
          });
        }
        var resize = angular.bind(scrollView, scrollView.resize);
        angular.element($window).on('resize', resize);
        var scrollFunc = function(e) {
          var detail = (e.originalEvent || e).detail || {};
          $scope.$onScroll && $scope.$onScroll({
            event: e,
            scrollTop: detail.scrollTop || 0,
            scrollLeft: detail.scrollLeft || 0
          });
        };
        $element.on('scroll', scrollFunc);
        $scope.$on('$destroy', function() {
          deregisterInstance();
          scrollView && scrollView.__cleanup && scrollView.__cleanup();
          angular.element($window).off('resize', resize);
          $element.off('scroll', scrollFunc);
          scrollView = self.scrollView = scrollViewOptions = self._scrollViewOptions = scrollViewOptions.el = self._scrollViewOptions.el = $element = self.$element = element = null;
        });
        $timeout(function() {
          scrollView && scrollView.run && scrollView.run();
        });
        self.getScrollView = function() {
          return scrollView;
        };
        self.getScrollPosition = function() {
          return scrollView.getValues();
        };
        self.resize = function() {
          return $timeout(resize, 0, false).then(function() {
            $element && $element.triggerHandler('scroll-resize');
          });
        };
        self.scrollTop = function(shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollTo(0, 0, !!shouldAnimate);
          });
        };
        self.scrollBottom = function(shouldAnimate) {
          self.resize().then(function() {
            var max = scrollView.getScrollMax();
            scrollView.scrollTo(max.left, max.top, !!shouldAnimate);
          });
        };
        self.scrollTo = function(left, top, shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollTo(left, top, !!shouldAnimate);
          });
        };
        self.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {
          self.resize().then(function() {
            scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);
          });
        };
        self.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {
          self.resize().then(function() {
            scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);
          });
        };
        self.scrollBy = function(left, top, shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollBy(left, top, !!shouldAnimate);
          });
        };
        self.anchorScroll = function(shouldAnimate) {
          self.resize().then(function() {
            var hash = $location.hash();
            var elm = hash && $document[0].getElementById(hash);
            if (!(hash && elm)) {
              scrollView.scrollTo(0, 0, !!shouldAnimate);
              return;
            }
            var curElm = elm;
            var scrollLeft = 0,
                scrollTop = 0;
            do {
              if (curElm !== null)
                scrollLeft += curElm.offsetLeft;
              if (curElm !== null)
                scrollTop += curElm.offsetTop;
              curElm = curElm.offsetParent;
            } while (curElm.attributes != self.element.attributes && curElm.offsetParent);
            scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);
          });
        };
        self.freezeScroll = scrollView.freeze;
        self.freezeAllScrolls = function(shouldFreeze) {
          for (var i = 0; i < $ionicScrollDelegate._instances.length; i++) {
            $ionicScrollDelegate._instances[i].freezeScroll(shouldFreeze);
          }
        };
        self._setRefresher = function(refresherScope, refresherElement, refresherMethods) {
          self.refresher = refresherElement;
          var refresherHeight = self.refresher.clientHeight || 60;
          scrollView.activatePullToRefresh(refresherHeight, refresherMethods);
        };
      }]);
      IonicModule.controller('$ionicSideMenus', ['$scope', '$attrs', '$ionicSideMenuDelegate', '$ionicPlatform', '$ionicBody', '$ionicHistory', '$ionicScrollDelegate', 'IONIC_BACK_PRIORITY', '$rootScope', function($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody, $ionicHistory, $ionicScrollDelegate, IONIC_BACK_PRIORITY, $rootScope) {
        var self = this;
        var rightShowing,
            leftShowing,
            isDragging;
        var startX,
            lastX,
            offsetX,
            isAsideExposed;
        var enableMenuWithBackViews = true;
        self.$scope = $scope;
        self.initialize = function(options) {
          self.left = options.left;
          self.right = options.right;
          self.setContent(options.content);
          self.dragThresholdX = options.dragThresholdX || 10;
          $ionicHistory.registerHistory(self.$scope);
        };
        self.setContent = function(content) {
          if (content) {
            self.content = content;
            self.content.onDrag = function(e) {
              self._handleDrag(e);
            };
            self.content.endDrag = function(e) {
              self._endDrag(e);
            };
          }
        };
        self.isOpenLeft = function() {
          return self.getOpenAmount() > 0;
        };
        self.isOpenRight = function() {
          return self.getOpenAmount() < 0;
        };
        self.toggleLeft = function(shouldOpen) {
          if (isAsideExposed || !self.left.isEnabled)
            return;
          var openAmount = self.getOpenAmount();
          if (arguments.length === 0) {
            shouldOpen = openAmount <= 0;
          }
          self.content.enableAnimation();
          if (!shouldOpen) {
            self.openPercentage(0);
            $rootScope.$emit('$ionicSideMenuClose', 'left');
          } else {
            self.openPercentage(100);
            $rootScope.$emit('$ionicSideMenuOpen', 'left');
          }
        };
        self.toggleRight = function(shouldOpen) {
          if (!self.right.isEnabled)
            return;
          var openAmount = self.getOpenAmount();
          if (arguments.length === 0) {
            shouldOpen = openAmount >= 0;
          }
          self.content.enableAnimation();
          if (!shouldOpen) {
            self.openPercentage(0);
            $rootScope.$emit('$ionicSideMenuClose', 'right');
          } else {
            self.openPercentage(-100);
            $rootScope.$emit('$ionicSideMenuOpen', 'right');
          }
        };
        self.toggle = function(side) {
          if (side == 'right') {
            self.toggleRight();
          } else {
            self.toggleLeft();
          }
        };
        self.close = function() {
          self.openPercentage(0);
          $rootScope.$emit('$ionicSideMenuClose', 'left');
          $rootScope.$emit('$ionicSideMenuClose', 'right');
        };
        self.getOpenAmount = function() {
          return self.content && self.content.getTranslateX() || 0;
        };
        self.getOpenRatio = function() {
          var amount = self.getOpenAmount();
          if (amount >= 0) {
            return amount / self.left.width;
          }
          return amount / self.right.width;
        };
        self.isOpen = function() {
          return self.getOpenAmount() !== 0;
        };
        self.getOpenPercentage = function() {
          return self.getOpenRatio() * 100;
        };
        self.openPercentage = function(percentage) {
          var p = percentage / 100;
          if (self.left && percentage >= 0) {
            self.openAmount(self.left.width * p);
          } else if (self.right && percentage < 0) {
            self.openAmount(self.right.width * p);
          }
          $ionicBody.enableClass((percentage !== 0), 'menu-open');
          freezeAllScrolls(false);
        };
        function freezeAllScrolls(shouldFreeze) {
          if (shouldFreeze && !self.isScrollFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);
          } else if (!shouldFreeze && self.isScrollFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(false);
          }
          self.isScrollFreeze = shouldFreeze;
        }
        self.openAmount = function(amount) {
          var maxLeft = self.left && self.left.width || 0;
          var maxRight = self.right && self.right.width || 0;
          if (!(self.left && self.left.isEnabled) && amount > 0) {
            self.content.setTranslateX(0);
            return;
          }
          if (!(self.right && self.right.isEnabled) && amount < 0) {
            self.content.setTranslateX(0);
            return;
          }
          if (leftShowing && amount > maxLeft) {
            self.content.setTranslateX(maxLeft);
            return;
          }
          if (rightShowing && amount < -maxRight) {
            self.content.setTranslateX(-maxRight);
            return;
          }
          self.content.setTranslateX(amount);
          if (amount >= 0) {
            leftShowing = true;
            rightShowing = false;
            if (amount > 0) {
              self.right && self.right.pushDown && self.right.pushDown();
              self.left && self.left.bringUp && self.left.bringUp();
            }
          } else {
            rightShowing = true;
            leftShowing = false;
            self.right && self.right.bringUp && self.right.bringUp();
            self.left && self.left.pushDown && self.left.pushDown();
          }
        };
        self.snapToRest = function(e) {
          self.content.enableAnimation();
          isDragging = false;
          var ratio = self.getOpenRatio();
          if (ratio === 0) {
            self.openPercentage(0);
            return;
          }
          var velocityThreshold = 0.3;
          var velocityX = e.gesture.velocityX;
          var direction = e.gesture.direction;
          if (ratio > 0 && ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
            self.openPercentage(0);
          } else if (ratio > 0.5 && direction == 'left' && velocityX < velocityThreshold) {
            self.openPercentage(100);
          } else if (ratio < 0 && ratio > -0.5 && direction == 'left' && velocityX < velocityThreshold) {
            self.openPercentage(0);
          } else if (ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
            self.openPercentage(-100);
          } else if (direction == 'right' && ratio >= 0 && (ratio >= 0.5 || velocityX > velocityThreshold)) {
            self.openPercentage(100);
          } else if (direction == 'left' && ratio <= 0 && (ratio <= -0.5 || velocityX > velocityThreshold)) {
            self.openPercentage(-100);
          } else {
            self.openPercentage(0);
          }
        };
        self.enableMenuWithBackViews = function(val) {
          if (arguments.length) {
            enableMenuWithBackViews = !!val;
          }
          return enableMenuWithBackViews;
        };
        self.isAsideExposed = function() {
          return !!isAsideExposed;
        };
        self.exposeAside = function(shouldExposeAside) {
          if (!(self.left && self.left.isEnabled) && !(self.right && self.right.isEnabled))
            return;
          self.close();
          isAsideExposed = shouldExposeAside;
          if (self.left && self.left.isEnabled) {
            self.content.setMarginLeft(isAsideExposed ? self.left.width : 0);
          } else if (self.right && self.right.isEnabled) {
            self.content.setMarginRight(isAsideExposed ? self.right.width : 0);
          }
          self.$scope.$emit('$ionicExposeAside', isAsideExposed);
        };
        self.activeAsideResizing = function(isResizing) {
          $ionicBody.enableClass(isResizing, 'aside-resizing');
        };
        self._endDrag = function(e) {
          freezeAllScrolls(false);
          if (isAsideExposed)
            return;
          if (isDragging) {
            self.snapToRest(e);
          }
          startX = null;
          lastX = null;
          offsetX = null;
        };
        self._handleDrag = function(e) {
          if (isAsideExposed || !$scope.dragContent)
            return;
          if (!startX) {
            startX = e.gesture.touches[0].pageX;
            lastX = startX;
          } else {
            lastX = e.gesture.touches[0].pageX;
          }
          if (!isDragging && Math.abs(lastX - startX) > self.dragThresholdX) {
            startX = lastX;
            isDragging = true;
            self.content.disableAnimation();
            offsetX = self.getOpenAmount();
          }
          if (isDragging) {
            self.openAmount(offsetX + (lastX - startX));
            freezeAllScrolls(true);
          }
        };
        self.canDragContent = function(canDrag) {
          if (arguments.length) {
            $scope.dragContent = !!canDrag;
          }
          return $scope.dragContent;
        };
        self.edgeThreshold = 25;
        self.edgeThresholdEnabled = false;
        self.edgeDragThreshold = function(value) {
          if (arguments.length) {
            if (isNumber(value) && value > 0) {
              self.edgeThreshold = value;
              self.edgeThresholdEnabled = true;
            } else {
              self.edgeThresholdEnabled = !!value;
            }
          }
          return self.edgeThresholdEnabled;
        };
        self.isDraggableTarget = function(e) {
          var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen();
          var startX = e.gesture.startEvent && e.gesture.startEvent.center && e.gesture.startEvent.center.pageX;
          var dragIsWithinBounds = !shouldOnlyAllowEdgeDrag || startX <= self.edgeThreshold || startX >= self.content.element.offsetWidth - self.edgeThreshold;
          var backView = $ionicHistory.backView();
          var menuEnabled = enableMenuWithBackViews ? true : !backView;
          if (!menuEnabled) {
            var currentView = $ionicHistory.currentView() || {};
            return backView.historyId !== currentView.historyId;
          }
          return ($scope.dragContent || self.isOpen()) && dragIsWithinBounds && !e.gesture.srcEvent.defaultPrevented && menuEnabled && !e.target.tagName.match(/input|textarea|select|object|embed/i) && !e.target.isContentEditable && !(e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll') == 'true');
        };
        $scope.sideMenuContentTranslateX = 0;
        var deregisterBackButtonAction = noop;
        var closeSideMenu = angular.bind(self, self.close);
        $scope.$watch(function() {
          return self.getOpenAmount() !== 0;
        }, function(isOpen) {
          deregisterBackButtonAction();
          if (isOpen) {
            deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(closeSideMenu, IONIC_BACK_PRIORITY.sideMenu);
          }
        });
        var deregisterInstance = $ionicSideMenuDelegate._registerInstance(self, $attrs.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on('$destroy', function() {
          deregisterInstance();
          deregisterBackButtonAction();
          self.$scope = null;
          if (self.content) {
            self.content.element = null;
            self.content = null;
          }
          freezeAllScrolls(false);
        });
        self.initialize({
          left: {width: 275},
          right: {width: 275}
        });
      }]);
      (function(ionic) {
        var TRANSLATE32 = 'translate(32,32)';
        var STROKE_OPACITY = 'stroke-opacity';
        var ROUND = 'round';
        var INDEFINITE = 'indefinite';
        var DURATION = '750ms';
        var NONE = 'none';
        var SHORTCUTS = {
          a: 'animate',
          an: 'attributeName',
          at: 'animateTransform',
          c: 'circle',
          da: 'stroke-dasharray',
          os: 'stroke-dashoffset',
          f: 'fill',
          lc: 'stroke-linecap',
          rc: 'repeatCount',
          sw: 'stroke-width',
          t: 'transform',
          v: 'values'
        };
        var SPIN_ANIMATION = {
          v: '0,32,32;360,32,32',
          an: 'transform',
          type: 'rotate',
          rc: INDEFINITE,
          dur: DURATION
        };
        function createSvgElement(tagName, data, parent, spinnerName) {
          var ele = document.createElement(SHORTCUTS[tagName] || tagName);
          var k,
              x,
              y;
          for (k in data) {
            if (angular.isArray(data[k])) {
              for (x = 0; x < data[k].length; x++) {
                if (data[k][x].fn) {
                  for (y = 0; y < data[k][x].t; y++) {
                    createSvgElement(k, data[k][x].fn(y, spinnerName), ele, spinnerName);
                  }
                } else {
                  createSvgElement(k, data[k][x], ele, spinnerName);
                }
              }
            } else {
              setSvgAttribute(ele, k, data[k]);
            }
          }
          parent.appendChild(ele);
        }
        function setSvgAttribute(ele, k, v) {
          ele.setAttribute(SHORTCUTS[k] || k, v);
        }
        function animationValues(strValues, i) {
          var values = strValues.split(';');
          var back = values.slice(i);
          var front = values.slice(0, values.length - back.length);
          values = back.concat(front).reverse();
          return values.join(';') + ';' + values[0];
        }
        var IOS_SPINNER = {
          sw: 4,
          lc: ROUND,
          line: [{
            fn: function(i, spinnerName) {
              return {
                y1: spinnerName == 'ios' ? 17 : 12,
                y2: spinnerName == 'ios' ? 29 : 20,
                t: TRANSLATE32 + ' rotate(' + (30 * i + (i < 6 ? 180 : -180)) + ')',
                a: [{
                  fn: function() {
                    return {
                      an: STROKE_OPACITY,
                      dur: DURATION,
                      v: animationValues('0;.1;.15;.25;.35;.45;.55;.65;.7;.85;1', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 12
          }]
        };
        var spinners = {
          android: {c: [{
              sw: 6,
              da: 128,
              os: 82,
              r: 26,
              cx: 32,
              cy: 32,
              f: NONE
            }]},
          ios: IOS_SPINNER,
          'ios-small': IOS_SPINNER,
          bubbles: {
            sw: 0,
            c: [{
              fn: function(i) {
                return {
                  cx: 24 * Math.cos(2 * Math.PI * i / 8),
                  cy: 24 * Math.sin(2 * Math.PI * i / 8),
                  t: TRANSLATE32,
                  a: [{
                    fn: function() {
                      return {
                        an: 'r',
                        dur: DURATION,
                        v: animationValues('1;2;3;4;5;6;7;8', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 8
            }]
          },
          circles: {c: [{
              fn: function(i) {
                return {
                  r: 5,
                  cx: 24 * Math.cos(2 * Math.PI * i / 8),
                  cy: 24 * Math.sin(2 * Math.PI * i / 8),
                  t: TRANSLATE32,
                  sw: 0,
                  a: [{
                    fn: function() {
                      return {
                        an: 'fill-opacity',
                        dur: DURATION,
                        v: animationValues('.3;.3;.3;.4;.7;.85;.9;1', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 8
            }]},
          crescent: {c: [{
              sw: 4,
              da: 128,
              os: 82,
              r: 26,
              cx: 32,
              cy: 32,
              f: NONE,
              at: [SPIN_ANIMATION]
            }]},
          dots: {c: [{
              fn: function(i) {
                return {
                  cx: 16 + (16 * i),
                  cy: 32,
                  sw: 0,
                  a: [{
                    fn: function() {
                      return {
                        an: 'fill-opacity',
                        dur: DURATION,
                        v: animationValues('.5;.6;.8;1;.8;.6;.5', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: 'r',
                        dur: DURATION,
                        v: animationValues('4;5;6;5;4;3;3', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 3
            }]},
          lines: {
            sw: 7,
            lc: ROUND,
            line: [{
              fn: function(i) {
                return {
                  x1: 10 + (i * 14),
                  x2: 10 + (i * 14),
                  a: [{
                    fn: function() {
                      return {
                        an: 'y1',
                        dur: DURATION,
                        v: animationValues('16;18;28;18;16', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: 'y2',
                        dur: DURATION,
                        v: animationValues('48;44;36;46;48', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: STROKE_OPACITY,
                        dur: DURATION,
                        v: animationValues('1;.8;.5;.4;1', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 4
            }]
          },
          ripple: {
            f: NONE,
            'fill-rule': 'evenodd',
            sw: 3,
            circle: [{
              fn: function(i) {
                return {
                  cx: 32,
                  cy: 32,
                  a: [{
                    fn: function() {
                      return {
                        an: 'r',
                        begin: (i * -1) + 's',
                        dur: '2s',
                        v: '0;24',
                        keyTimes: '0;1',
                        keySplines: '0.1,0.2,0.3,1',
                        calcMode: 'spline',
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: STROKE_OPACITY,
                        begin: (i * -1) + 's',
                        dur: '2s',
                        v: '.2;1;.2;0',
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 2
            }]
          },
          spiral: {
            defs: [{linearGradient: [{
                id: 'sGD',
                gradientUnits: 'userSpaceOnUse',
                x1: 55,
                y1: 46,
                x2: 2,
                y2: 46,
                stop: [{
                  offset: 0.1,
                  class: 'stop1'
                }, {
                  offset: 1,
                  class: 'stop2'
                }]
              }]}],
            g: [{
              sw: 4,
              lc: ROUND,
              f: NONE,
              path: [{
                stroke: 'url(#sGD)',
                d: 'M4,32 c0,15,12,28,28,28c8,0,16-4,21-9'
              }, {d: 'M60,32 C60,16,47.464,4,32,4S4,16,4,32'}],
              at: [SPIN_ANIMATION]
            }]
          }
        };
        var animations = {android: function(ele) {
            var rIndex = 0;
            var rotateCircle = 0;
            var startTime;
            var svgEle = ele.querySelector('g');
            var circleEle = ele.querySelector('circle');
            function run() {
              var v = easeInOutCubic(Date.now() - startTime, 650);
              var scaleX = 1;
              var translateX = 0;
              var dasharray = (188 - (58 * v));
              var dashoffset = (182 - (182 * v));
              if (rIndex % 2) {
                scaleX = -1;
                translateX = -64;
                dasharray = (128 - (-58 * v));
                dashoffset = (182 * v);
              }
              var rotateLine = [0, -101, -90, -11, -180, 79, -270, -191][rIndex];
              setSvgAttribute(circleEle, 'da', Math.max(Math.min(dasharray, 188), 128));
              setSvgAttribute(circleEle, 'os', Math.max(Math.min(dashoffset, 182), 0));
              setSvgAttribute(circleEle, 't', 'scale(' + scaleX + ',1) translate(' + translateX + ',0) rotate(' + rotateLine + ',32,32)');
              rotateCircle += 4.1;
              if (rotateCircle > 359)
                rotateCircle = 0;
              setSvgAttribute(svgEle, 't', 'rotate(' + rotateCircle + ',32,32)');
              if (v >= 1) {
                rIndex++;
                if (rIndex > 7)
                  rIndex = 0;
                startTime = Date.now();
              }
              ionic.requestAnimationFrame(run);
            }
            return function() {
              startTime = Date.now();
              run();
            };
          }};
        function easeInOutCubic(t, c) {
          t /= c / 2;
          if (t < 1)
            return 1 / 2 * t * t * t;
          t -= 2;
          return 1 / 2 * (t * t * t + 2);
        }
        IonicModule.controller('$ionicSpinner', ['$element', '$attrs', '$ionicConfig', function($element, $attrs, $ionicConfig) {
          var spinnerName;
          this.init = function() {
            spinnerName = $attrs.icon || $ionicConfig.spinner.icon();
            var container = document.createElement('div');
            createSvgElement('svg', {
              viewBox: '0 0 64 64',
              g: [spinners[spinnerName]]
            }, container, spinnerName);
            $element.html(container.innerHTML);
            this.start();
            return spinnerName;
          };
          this.start = function() {
            animations[spinnerName] && animations[spinnerName]($element[0])();
          };
        }]);
      })(ionic);
      IonicModule.controller('$ionicTab', ['$scope', '$ionicHistory', '$attrs', '$location', '$state', function($scope, $ionicHistory, $attrs, $location, $state) {
        this.$scope = $scope;
        this.hrefMatchesState = function() {
          return $attrs.href && $location.path().indexOf($attrs.href.replace(/^#/, '').replace(/\/$/, '')) === 0;
        };
        this.srefMatchesState = function() {
          return $attrs.uiSref && $state.includes($attrs.uiSref.split('(')[0]);
        };
        this.navNameMatchesState = function() {
          return this.navViewName && $ionicHistory.isCurrentStateNavView(this.navViewName);
        };
        this.tabMatchesState = function() {
          return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();
        };
      }]);
      IonicModule.controller('$ionicTabs', ['$scope', '$element', '$ionicHistory', function($scope, $element, $ionicHistory) {
        var self = this;
        var selectedTab = null;
        var previousSelectedTab = null;
        var selectedTabIndex;
        self.tabs = [];
        self.selectedIndex = function() {
          return self.tabs.indexOf(selectedTab);
        };
        self.selectedTab = function() {
          return selectedTab;
        };
        self.previousSelectedTab = function() {
          return previousSelectedTab;
        };
        self.add = function(tab) {
          $ionicHistory.registerHistory(tab);
          self.tabs.push(tab);
        };
        self.remove = function(tab) {
          var tabIndex = self.tabs.indexOf(tab);
          if (tabIndex === -1) {
            return;
          }
          if (tab.$tabSelected) {
            self.deselect(tab);
            if (self.tabs.length === 1) {} else {
              var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;
              self.select(self.tabs[newTabIndex]);
            }
          }
          self.tabs.splice(tabIndex, 1);
        };
        self.deselect = function(tab) {
          if (tab.$tabSelected) {
            previousSelectedTab = selectedTab;
            selectedTab = selectedTabIndex = null;
            tab.$tabSelected = false;
            (tab.onDeselect || noop)();
            tab.$broadcast && tab.$broadcast('$ionicHistory.deselect');
          }
        };
        self.select = function(tab, shouldEmitEvent) {
          var tabIndex;
          if (isNumber(tab)) {
            tabIndex = tab;
            if (tabIndex >= self.tabs.length)
              return;
            tab = self.tabs[tabIndex];
          } else {
            tabIndex = self.tabs.indexOf(tab);
          }
          if (arguments.length === 1) {
            shouldEmitEvent = !!(tab.navViewName || tab.uiSref);
          }
          if (selectedTab && selectedTab.$historyId == tab.$historyId) {
            if (shouldEmitEvent) {
              $ionicHistory.goToHistoryRoot(tab.$historyId);
            }
          } else if (selectedTabIndex !== tabIndex) {
            forEach(self.tabs, function(tab) {
              self.deselect(tab);
            });
            selectedTab = tab;
            selectedTabIndex = tabIndex;
            if (self.$scope && self.$scope.$parent) {
              self.$scope.$parent.$activeHistoryId = tab.$historyId;
            }
            tab.$tabSelected = true;
            (tab.onSelect || noop)();
            if (shouldEmitEvent) {
              $scope.$emit('$ionicHistory.change', {
                type: 'tab',
                tabIndex: tabIndex,
                historyId: tab.$historyId,
                navViewName: tab.navViewName,
                hasNavView: !!tab.navViewName,
                title: tab.title,
                url: tab.href,
                uiSref: tab.uiSref
              });
            }
          }
        };
        self.hasActiveScope = function() {
          for (var x = 0; x < self.tabs.length; x++) {
            if ($ionicHistory.isActiveScope(self.tabs[x])) {
              return true;
            }
          }
          return false;
        };
      }]);
      IonicModule.controller('$ionicView', ['$scope', '$element', '$attrs', '$compile', '$rootScope', function($scope, $element, $attrs, $compile, $rootScope) {
        var self = this;
        var navElementHtml = {};
        var navViewCtrl;
        var navBarDelegateHandle;
        var hasViewHeaderBar;
        var deregisters = [];
        var viewTitle;
        var deregIonNavBarInit = $scope.$on('ionNavBar.init', function(ev, delegateHandle) {
          ev.stopPropagation();
          navBarDelegateHandle = delegateHandle;
        });
        self.init = function() {
          deregIonNavBarInit();
          var modalCtrl = $element.inheritedData('$ionModalController');
          navViewCtrl = $element.inheritedData('$ionNavViewController');
          if (!navViewCtrl || modalCtrl)
            return;
          $scope.$on('$ionicView.beforeEnter', self.beforeEnter);
          $scope.$on('$ionicView.afterEnter', afterEnter);
          $scope.$on('$ionicView.beforeLeave', deregisterFns);
        };
        self.beforeEnter = function(ev, transData) {
          if (transData && !transData.viewNotified) {
            transData.viewNotified = true;
            if (!$rootScope.$$phase)
              $scope.$digest();
            viewTitle = isDefined($attrs.viewTitle) ? $attrs.viewTitle : $attrs.title;
            var navBarItems = {};
            for (var n in navElementHtml) {
              navBarItems[n] = generateNavBarItem(navElementHtml[n]);
            }
            navViewCtrl.beforeEnter(extend(transData, {
              title: viewTitle,
              showBack: !attrTrue('hideBackButton'),
              navBarItems: navBarItems,
              navBarDelegate: navBarDelegateHandle || null,
              showNavBar: !attrTrue('hideNavBar'),
              hasHeaderBar: !!hasViewHeaderBar
            }));
            deregisterFns();
          }
        };
        function afterEnter() {
          var viewTitleAttr = isDefined($attrs.viewTitle) && 'viewTitle' || isDefined($attrs.title) && 'title';
          if (viewTitleAttr) {
            titleUpdate($attrs[viewTitleAttr]);
            deregisters.push($attrs.$observe(viewTitleAttr, titleUpdate));
          }
          if (isDefined($attrs.hideBackButton)) {
            deregisters.push($scope.$watch($attrs.hideBackButton, function(val) {
              navViewCtrl.showBackButton(!val);
            }));
          }
          if (isDefined($attrs.hideNavBar)) {
            deregisters.push($scope.$watch($attrs.hideNavBar, function(val) {
              navViewCtrl.showBar(!val);
            }));
          }
        }
        function titleUpdate(newTitle) {
          if (isDefined(newTitle) && newTitle !== viewTitle) {
            viewTitle = newTitle;
            navViewCtrl.title(viewTitle);
          }
        }
        function deregisterFns() {
          for (var x = 0; x < deregisters.length; x++) {
            deregisters[x]();
          }
          deregisters = [];
        }
        function generateNavBarItem(html) {
          if (html) {
            return $compile(html)($scope.$new());
          }
        }
        function attrTrue(key) {
          return !!$scope.$eval($attrs[key]);
        }
        self.navElement = function(type, html) {
          navElementHtml[type] = html;
        };
      }]);
      IonicModule.directive('ionActionSheet', ['$document', function($document) {
        return {
          restrict: 'E',
          scope: true,
          replace: true,
          link: function($scope, $element) {
            var keyUp = function(e) {
              if (e.which == 27) {
                $scope.cancel();
                $scope.$apply();
              }
            };
            var backdropClick = function(e) {
              if (e.target == $element[0]) {
                $scope.cancel();
                $scope.$apply();
              }
            };
            $scope.$on('$destroy', function() {
              $element.remove();
              $document.unbind('keyup', keyUp);
            });
            $document.bind('keyup', keyUp);
            $element.bind('click', backdropClick);
          },
          template: '<div class="action-sheet-backdrop">' + '<div class="action-sheet-wrapper">' + '<div class="action-sheet" ng-class="{\'action-sheet-has-icons\': $actionSheetHasIcon}">' + '<div class="action-sheet-group action-sheet-options">' + '<div class="action-sheet-title" ng-if="titleText" ng-bind-html="titleText"></div>' + '<button class="button action-sheet-option" ng-click="buttonClicked($index)" ng-repeat="b in buttons" ng-bind-html="b.text"></button>' + '<button class="button destructive action-sheet-destructive" ng-if="destructiveText" ng-click="destructiveButtonClicked()" ng-bind-html="destructiveText"></button>' + '</div>' + '<div class="action-sheet-group action-sheet-cancel" ng-if="cancelText">' + '<button class="button" ng-click="cancel()" ng-bind-html="cancelText"></button>' + '</div>' + '</div>' + '</div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionCheckbox', ['$ionicConfig', function($ionicConfig) {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<label class="item item-checkbox">' + '<div class="checkbox checkbox-input-hidden disable-pointer-events">' + '<input type="checkbox">' + '<i class="checkbox-icon"></i>' + '</div>' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '</label>',
          compile: function(element, attr) {
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-checked': attr.ngChecked,
              'ng-disabled': attr.ngDisabled,
              'ng-true-value': attr.ngTrueValue,
              'ng-false-value': attr.ngFalseValue,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            var checkboxWrapper = element[0].querySelector('.checkbox');
            checkboxWrapper.classList.add('checkbox-' + $ionicConfig.form.checkbox());
          }
        };
      }]);
      IonicModule.directive('collectionRepeat', CollectionRepeatDirective).factory('$ionicCollectionManager', RepeatManagerFactory);
      var ONE_PX_TRANSPARENT_IMG_SRC = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
      var WIDTH_HEIGHT_REGEX = /height:.*?px;\s*width:.*?px/;
      var DEFAULT_RENDER_BUFFER = 3;
      CollectionRepeatDirective.$inject = ['$ionicCollectionManager', '$parse', '$window', '$$rAF', '$rootScope', '$timeout'];
      function CollectionRepeatDirective($ionicCollectionManager, $parse, $window, $$rAF, $rootScope, $timeout) {
        return {
          restrict: 'A',
          priority: 1000,
          transclude: 'element',
          $$tlb: true,
          require: '^^$ionicScroll',
          link: postLink
        };
        function postLink(scope, element, attr, scrollCtrl, transclude) {
          var scrollView = scrollCtrl.scrollView;
          var node = element[0];
          var containerNode = angular.element('<div class="collection-repeat-container">')[0];
          node.parentNode.replaceChild(containerNode, node);
          if (scrollView.options.scrollingX && scrollView.options.scrollingY) {
            throw new Error("collection-repeat expected a parent x or y scrollView, not " + "an xy scrollView.");
          }
          var repeatExpr = attr.collectionRepeat;
          var match = repeatExpr.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
          if (!match) {
            throw new Error("collection-repeat expected expression in form of '_item_ in " + "_collection_[ track by _id_]' but got '" + attr.collectionRepeat + "'.");
          }
          var keyExpr = match[1];
          var listExpr = match[2];
          var listGetter = $parse(listExpr);
          var heightData = {};
          var widthData = {};
          var computedStyleDimensions = {};
          var data = [];
          var repeatManager;
          var renderBufferExpr = attr.itemRenderBuffer || attr.collectionBufferSize;
          var renderBuffer = angular.isDefined(renderBufferExpr) ? parseInt(renderBufferExpr) : DEFAULT_RENDER_BUFFER;
          var heightExpr = attr.itemHeight || attr.collectionItemHeight;
          var widthExpr = attr.itemWidth || attr.collectionItemWidth;
          var afterItemsContainer = initAfterItemsContainer();
          var changeValidator = makeChangeValidator();
          initDimensions();
          scrollCtrl.$element.on('scroll-resize', refreshDimensions);
          angular.element($window).on('resize', onResize);
          var unlistenToExposeAside = $rootScope.$on('$ionicExposeAside', ionic.animationFrameThrottle(function() {
            scrollCtrl.scrollView.resize();
            onResize();
          }));
          $timeout(refreshDimensions, 0, false);
          function onResize() {
            if (changeValidator.resizeRequiresRefresh(scrollView.__clientWidth, scrollView.__clientHeight)) {
              refreshDimensions();
            }
          }
          scope.$watchCollection(listGetter, function(newValue) {
            data = newValue || (newValue = []);
            if (!angular.isArray(newValue)) {
              throw new Error("collection-repeat expected an array for '" + listExpr + "', " + "but got a " + typeof value);
            }
            scope.$$postDigest(function() {
              getRepeatManager().setData(data);
              if (changeValidator.dataChangeRequiresRefresh(data))
                refreshDimensions();
            });
          });
          scope.$on('$destroy', function() {
            angular.element($window).off('resize', onResize);
            unlistenToExposeAside();
            scrollCtrl.$element && scrollCtrl.$element.off('scroll-resize', refreshDimensions);
            computedStyleNode && computedStyleNode.parentNode && computedStyleNode.parentNode.removeChild(computedStyleNode);
            computedStyleScope && computedStyleScope.$destroy();
            computedStyleScope = computedStyleNode = null;
            repeatManager && repeatManager.destroy();
            repeatManager = null;
          });
          function makeChangeValidator() {
            var self;
            return (self = {
              dataLength: 0,
              width: 0,
              height: 0,
              resizeRequiresRefresh: function(newWidth, newHeight) {
                var requiresRefresh = self.dataLength && newWidth && newHeight && (newWidth !== self.width || newHeight !== self.height);
                self.width = newWidth;
                self.height = newHeight;
                return !!requiresRefresh;
              },
              dataChangeRequiresRefresh: function(newData) {
                var requiresRefresh = newData.length > 0 || newData.length < self.dataLength;
                self.dataLength = newData.length;
                return !!requiresRefresh;
              }
            });
          }
          function getRepeatManager() {
            return repeatManager || (repeatManager = new $ionicCollectionManager({
              afterItemsNode: afterItemsContainer[0],
              containerNode: containerNode,
              heightData: heightData,
              widthData: widthData,
              forceRefreshImages: !!(isDefined(attr.forceRefreshImages) && attr.forceRefreshImages !== 'false'),
              keyExpression: keyExpr,
              renderBuffer: renderBuffer,
              scope: scope,
              scrollView: scrollCtrl.scrollView,
              transclude: transclude
            }));
          }
          function initAfterItemsContainer() {
            var container = angular.element(scrollView.__content.querySelector('.collection-repeat-after-container'));
            if (!container.length) {
              var elementIsAfterRepeater = false;
              var afterNodes = [].filter.call(scrollView.__content.childNodes, function(node) {
                if (ionic.DomUtil.contains(node, containerNode)) {
                  elementIsAfterRepeater = true;
                  return false;
                }
                return elementIsAfterRepeater;
              });
              container = angular.element('<span class="collection-repeat-after-container">');
              if (scrollView.options.scrollingX) {
                container.addClass('horizontal');
              }
              container.append(afterNodes);
              scrollView.__content.appendChild(container[0]);
            }
            return container;
          }
          function initDimensions() {
            if (heightExpr) {
              parseDimensionAttr(heightExpr, heightData);
            } else {
              heightData.computed = true;
            }
            if (widthExpr) {
              parseDimensionAttr(widthExpr, widthData);
            } else {
              widthData.computed = true;
            }
          }
          function refreshDimensions() {
            var hasData = data.length > 0;
            if (hasData && (heightData.computed || widthData.computed)) {
              computeStyleDimensions();
            }
            if (hasData && heightData.computed) {
              heightData.value = computedStyleDimensions.height;
              if (!heightData.value) {
                throw new Error('collection-repeat tried to compute the height of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-height" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
              }
            } else if (!heightData.dynamic && heightData.getValue) {
              heightData.value = heightData.getValue();
            }
            if (hasData && widthData.computed) {
              widthData.value = computedStyleDimensions.width;
              if (!widthData.value) {
                throw new Error('collection-repeat tried to compute the width of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-width" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
              }
            } else if (!widthData.dynamic && widthData.getValue) {
              widthData.value = widthData.getValue();
            }
            getRepeatManager().refreshLayout();
          }
          function parseDimensionAttr(attrValue, dimensionData) {
            if (!attrValue)
              return;
            var parsedValue;
            try {
              parsedValue = $parse(attrValue);
            } catch (e) {
              if (attrValue.trim().match(/\d+(px|%)$/)) {
                attrValue = '"' + attrValue + '"';
              }
              parsedValue = $parse(attrValue);
            }
            var constantAttrValue = attrValue.replace(/(\'|\"|px|%)/g, '').trim();
            var isConstant = constantAttrValue.length && !/([a-zA-Z]|\$|:|\?)/.test(constantAttrValue);
            dimensionData.attrValue = attrValue;
            if (isConstant) {
              var intValue = parseInt(parsedValue());
              if (attrValue.indexOf('%') > -1) {
                var decimalValue = intValue / 100;
                dimensionData.getValue = dimensionData === heightData ? function() {
                  return Math.floor(decimalValue * scrollView.__clientHeight);
                } : function() {
                  return Math.floor(decimalValue * scrollView.__clientWidth);
                };
              } else {
                dimensionData.value = intValue;
              }
            } else {
              dimensionData.dynamic = true;
              dimensionData.getValue = dimensionData === heightData ? function heightGetter(scope, locals) {
                var result = parsedValue(scope, locals);
                if (result.charAt && result.charAt(result.length - 1) === '%') {
                  return Math.floor(parseInt(result) / 100 * scrollView.__clientHeight);
                }
                return parseInt(result);
              } : function widthGetter(scope, locals) {
                var result = parsedValue(scope, locals);
                if (result.charAt && result.charAt(result.length - 1) === '%') {
                  return Math.floor(parseInt(result) / 100 * scrollView.__clientWidth);
                }
                return parseInt(result);
              };
            }
          }
          var computedStyleNode;
          var computedStyleScope;
          function computeStyleDimensions() {
            if (!computedStyleNode) {
              transclude(computedStyleScope = scope.$new(), function(clone) {
                clone[0].removeAttribute('collection-repeat');
                computedStyleNode = clone[0];
              });
            }
            computedStyleScope[keyExpr] = (listGetter(scope) || [])[0];
            if (!$rootScope.$$phase)
              computedStyleScope.$digest();
            containerNode.appendChild(computedStyleNode);
            var style = $window.getComputedStyle(computedStyleNode);
            computedStyleDimensions.width = parseInt(style.width);
            computedStyleDimensions.height = parseInt(style.height);
            containerNode.removeChild(computedStyleNode);
          }
        }
      }
      RepeatManagerFactory.$inject = ['$rootScope', '$window', '$$rAF'];
      function RepeatManagerFactory($rootScope, $window, $$rAF) {
        var EMPTY_DIMENSION = {
          primaryPos: 0,
          secondaryPos: 0,
          primarySize: 0,
          secondarySize: 0,
          rowPrimarySize: 0
        };
        return function RepeatController(options) {
          var afterItemsNode = options.afterItemsNode;
          var containerNode = options.containerNode;
          var forceRefreshImages = options.forceRefreshImages;
          var heightData = options.heightData;
          var widthData = options.widthData;
          var keyExpression = options.keyExpression;
          var renderBuffer = options.renderBuffer;
          var scope = options.scope;
          var scrollView = options.scrollView;
          var transclude = options.transclude;
          var data = [];
          var getterLocals = {};
          var heightFn = heightData.getValue || function() {
            return heightData.value;
          };
          var heightGetter = function(index, value) {
            getterLocals[keyExpression] = value;
            getterLocals.$index = index;
            return heightFn(scope, getterLocals);
          };
          var widthFn = widthData.getValue || function() {
            return widthData.value;
          };
          var widthGetter = function(index, value) {
            getterLocals[keyExpression] = value;
            getterLocals.$index = index;
            return widthFn(scope, getterLocals);
          };
          var isVertical = !!scrollView.options.scrollingY;
          var isGridView = isVertical ? (widthData.dynamic || widthData.value !== scrollView.__clientWidth) : (heightData.dynamic || heightData.value !== scrollView.__clientHeight);
          var isStaticView = !heightData.dynamic && !widthData.dynamic;
          var PRIMARY = 'PRIMARY';
          var SECONDARY = 'SECONDARY';
          var TRANSLATE_TEMPLATE_STR = isVertical ? 'translate3d(SECONDARYpx,PRIMARYpx,0)' : 'translate3d(PRIMARYpx,SECONDARYpx,0)';
          var WIDTH_HEIGHT_TEMPLATE_STR = isVertical ? 'height: PRIMARYpx; width: SECONDARYpx;' : 'height: SECONDARYpx; width: PRIMARYpx;';
          var estimatedHeight;
          var estimatedWidth;
          var repeaterBeforeSize = 0;
          var repeaterAfterSize = 0;
          var renderStartIndex = -1;
          var renderEndIndex = -1;
          var renderAfterBoundary = -1;
          var renderBeforeBoundary = -1;
          var itemsPool = [];
          var itemsLeaving = [];
          var itemsEntering = [];
          var itemsShownMap = {};
          var nextItemId = 0;
          var scrollViewSetDimensions = isVertical ? function() {
            scrollView.setDimensions(null, null, null, view.getContentSize(), true);
          } : function() {
            scrollView.setDimensions(null, null, view.getContentSize(), null, true);
          };
          var view = isVertical ? new VerticalViewType() : new HorizontalViewType();
          (isGridView ? GridViewType : ListViewType).call(view);
          (isStaticView ? StaticViewType : DynamicViewType).call(view);
          var contentSizeStr = isVertical ? 'getContentHeight' : 'getContentWidth';
          var originalGetContentSize = scrollView.options[contentSizeStr];
          scrollView.options[contentSizeStr] = angular.bind(view, view.getContentSize);
          scrollView.__$callback = scrollView.__callback;
          scrollView.__callback = function(transformLeft, transformTop, zoom, wasResize) {
            var scrollValue = view.getScrollValue();
            if (renderStartIndex === -1 || scrollValue + view.scrollPrimarySize > renderAfterBoundary || scrollValue < renderBeforeBoundary) {
              render();
            }
            scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);
          };
          var isLayoutReady = false;
          var isDataReady = false;
          this.refreshLayout = function() {
            if (data.length) {
              estimatedHeight = heightGetter(0, data[0]);
              estimatedWidth = widthGetter(0, data[0]);
            } else {
              estimatedHeight = 100;
              estimatedWidth = 100;
            }
            var style = getComputedStyle(afterItemsNode) || {};
            var firstStyle = afterItemsNode.firstElementChild && getComputedStyle(afterItemsNode.firstElementChild) || {};
            var lastStyle = afterItemsNode.lastElementChild && getComputedStyle(afterItemsNode.lastElementChild) || {};
            repeaterAfterSize = (parseInt(style[isVertical ? 'height' : 'width']) || 0) + (firstStyle && parseInt(firstStyle[isVertical ? 'marginTop' : 'marginLeft']) || 0) + (lastStyle && parseInt(lastStyle[isVertical ? 'marginBottom' : 'marginRight']) || 0);
            repeaterBeforeSize = 0;
            var current = containerNode;
            do {
              repeaterBeforeSize += current[isVertical ? 'offsetTop' : 'offsetLeft'];
            } while (ionic.DomUtil.contains(scrollView.__content, current = current.offsetParent));
            var containerPrevNode = containerNode.previousElementSibling;
            var beforeStyle = containerPrevNode ? $window.getComputedStyle(containerPrevNode) : {};
            var beforeMargin = parseInt(beforeStyle[isVertical ? 'marginBottom' : 'marginRight'] || 0);
            containerNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, -beforeMargin).replace(SECONDARY, 0);
            repeaterBeforeSize -= beforeMargin;
            if (!scrollView.__clientHeight || !scrollView.__clientWidth) {
              scrollView.__clientWidth = scrollView.__container.clientWidth;
              scrollView.__clientHeight = scrollView.__container.clientHeight;
            }
            (view.onRefreshLayout || angular.noop)();
            view.refreshDirection();
            scrollViewSetDimensions();
            if (!isLayoutReady) {
              var poolSize = Math.max(20, renderBuffer * 3);
              for (var i = 0; i < poolSize; i++) {
                itemsPool.push(new RepeatItem());
              }
            }
            isLayoutReady = true;
            if (isLayoutReady && isDataReady) {
              if (scrollView.__scrollLeft > scrollView.__maxScrollLeft || scrollView.__scrollTop > scrollView.__maxScrollTop) {
                scrollView.resize();
              }
              forceRerender(true);
            }
          };
          this.setData = function(newData) {
            data = newData;
            (view.onRefreshData || angular.noop)();
            isDataReady = true;
          };
          this.destroy = function() {
            render.destroyed = true;
            itemsPool.forEach(function(item) {
              item.scope.$destroy();
              item.scope = item.element = item.node = item.images = null;
            });
            itemsPool.length = itemsEntering.length = itemsLeaving.length = 0;
            itemsShownMap = {};
            scrollView.options[contentSizeStr] = originalGetContentSize;
            scrollView.__callback = scrollView.__$callback;
            scrollView.resize();
            (view.onDestroy || angular.noop)();
          };
          function forceRerender() {
            return render(true);
          }
          function render(forceRerender) {
            if (render.destroyed)
              return;
            var i;
            var ii;
            var item;
            var dim;
            var scope;
            var scrollValue = view.getScrollValue();
            var scrollValueEnd = scrollValue + view.scrollPrimarySize;
            view.updateRenderRange(scrollValue, scrollValueEnd);
            renderStartIndex = Math.max(0, renderStartIndex - renderBuffer);
            renderEndIndex = Math.min(data.length - 1, renderEndIndex + renderBuffer);
            for (i in itemsShownMap) {
              if (i < renderStartIndex || i > renderEndIndex) {
                item = itemsShownMap[i];
                delete itemsShownMap[i];
                itemsLeaving.push(item);
                item.isShown = false;
              }
            }
            for (i = renderStartIndex; i <= renderEndIndex; i++) {
              if (i >= data.length || (itemsShownMap[i] && !forceRerender))
                continue;
              item = itemsShownMap[i] || (itemsShownMap[i] = itemsLeaving.length ? itemsLeaving.pop() : itemsPool.length ? itemsPool.shift() : new RepeatItem());
              itemsEntering.push(item);
              item.isShown = true;
              scope = item.scope;
              scope.$index = i;
              scope[keyExpression] = data[i];
              scope.$first = (i === 0);
              scope.$last = (i === (data.length - 1));
              scope.$middle = !(scope.$first || scope.$last);
              scope.$odd = !(scope.$even = (i & 1) === 0);
              if (scope.$$disconnected)
                ionic.Utils.reconnectScope(item.scope);
              dim = view.getDimensions(i);
              if (item.secondaryPos !== dim.secondaryPos || item.primaryPos !== dim.primaryPos) {
                item.node.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, (item.primaryPos = dim.primaryPos)).replace(SECONDARY, (item.secondaryPos = dim.secondaryPos));
              }
              if (item.secondarySize !== dim.secondarySize || item.primarySize !== dim.primarySize) {
                item.node.style.cssText = item.node.style.cssText.replace(WIDTH_HEIGHT_REGEX, WIDTH_HEIGHT_TEMPLATE_STR.replace(PRIMARY, (item.primarySize = dim.primarySize) + 1).replace(SECONDARY, (item.secondarySize = dim.secondarySize)));
              }
            }
            if (renderEndIndex === data.length - 1) {
              dim = view.getDimensions(data.length - 1) || EMPTY_DIMENSION;
              afterItemsNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, dim.primaryPos + dim.primarySize).replace(SECONDARY, 0);
            }
            while (itemsLeaving.length) {
              item = itemsLeaving.pop();
              item.scope.$broadcast('$collectionRepeatLeave');
              ionic.Utils.disconnectScope(item.scope);
              itemsPool.push(item);
              item.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
              item.primaryPos = item.secondaryPos = null;
            }
            if (forceRefreshImages) {
              for (i = 0, ii = itemsEntering.length; i < ii && (item = itemsEntering[i]); i++) {
                if (!item.images)
                  continue;
                for (var j = 0,
                    jj = item.images.length,
                    img; j < jj && (img = item.images[j]); j++) {
                  var src = img.src;
                  img.src = ONE_PX_TRANSPARENT_IMG_SRC;
                  img.src = src;
                }
              }
            }
            if (forceRerender) {
              var rootScopePhase = $rootScope.$$phase;
              while (itemsEntering.length) {
                item = itemsEntering.pop();
                if (!rootScopePhase)
                  item.scope.$digest();
              }
            } else {
              digestEnteringItems();
            }
          }
          function digestEnteringItems() {
            var item;
            if (digestEnteringItems.running)
              return;
            digestEnteringItems.running = true;
            $$rAF(function process() {
              var rootScopePhase = $rootScope.$$phase;
              while (itemsEntering.length) {
                item = itemsEntering.pop();
                if (item.isShown) {
                  if (!rootScopePhase)
                    item.scope.$digest();
                }
              }
              digestEnteringItems.running = false;
            });
          }
          function RepeatItem() {
            var self = this;
            this.scope = scope.$new();
            this.id = 'item' + (nextItemId++);
            transclude(this.scope, function(clone) {
              self.element = clone;
              self.element.data('$$collectionRepeatItem', self);
              self.node = clone[0];
              self.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
              self.node.style.cssText += ' height: 0px; width: 0px;';
              ionic.Utils.disconnectScope(self.scope);
              containerNode.appendChild(self.node);
              self.images = clone[0].getElementsByTagName('img');
            });
          }
          function VerticalViewType() {
            this.getItemPrimarySize = heightGetter;
            this.getItemSecondarySize = widthGetter;
            this.getScrollValue = function() {
              return Math.max(0, Math.min(scrollView.__scrollTop - repeaterBeforeSize, scrollView.__maxScrollTop - repeaterBeforeSize - repeaterAfterSize));
            };
            this.refreshDirection = function() {
              this.scrollPrimarySize = scrollView.__clientHeight;
              this.scrollSecondarySize = scrollView.__clientWidth;
              this.estimatedPrimarySize = estimatedHeight;
              this.estimatedSecondarySize = estimatedWidth;
              this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientWidth / estimatedWidth) || 1;
            };
          }
          function HorizontalViewType() {
            this.getItemPrimarySize = widthGetter;
            this.getItemSecondarySize = heightGetter;
            this.getScrollValue = function() {
              return Math.max(0, Math.min(scrollView.__scrollLeft - repeaterBeforeSize, scrollView.__maxScrollLeft - repeaterBeforeSize - repeaterAfterSize));
            };
            this.refreshDirection = function() {
              this.scrollPrimarySize = scrollView.__clientWidth;
              this.scrollSecondarySize = scrollView.__clientHeight;
              this.estimatedPrimarySize = estimatedWidth;
              this.estimatedSecondarySize = estimatedHeight;
              this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientHeight / estimatedHeight) || 1;
            };
          }
          function GridViewType() {
            this.getEstimatedSecondaryPos = function(index) {
              return (index % this.estimatedItemsAcross) * this.estimatedSecondarySize;
            };
            this.getEstimatedPrimaryPos = function(index) {
              return Math.floor(index / this.estimatedItemsAcross) * this.estimatedPrimarySize;
            };
            this.getEstimatedIndex = function(scrollValue) {
              return Math.floor(scrollValue / this.estimatedPrimarySize) * this.estimatedItemsAcross;
            };
          }
          function ListViewType() {
            this.getEstimatedSecondaryPos = function() {
              return 0;
            };
            this.getEstimatedPrimaryPos = function(index) {
              return index * this.estimatedPrimarySize;
            };
            this.getEstimatedIndex = function(scrollValue) {
              return Math.floor((scrollValue) / this.estimatedPrimarySize);
            };
          }
          function StaticViewType() {
            this.getContentSize = function() {
              return this.getEstimatedPrimaryPos(data.length - 1) + this.estimatedPrimarySize + repeaterBeforeSize + repeaterAfterSize;
            };
            var dim = {};
            this.getDimensions = function(index) {
              dim.primaryPos = this.getEstimatedPrimaryPos(index);
              dim.secondaryPos = this.getEstimatedSecondaryPos(index);
              dim.primarySize = this.estimatedPrimarySize;
              dim.secondarySize = this.estimatedSecondarySize;
              return dim;
            };
            this.updateRenderRange = function(scrollValue, scrollValueEnd) {
              renderStartIndex = Math.max(0, this.getEstimatedIndex(scrollValue));
              renderEndIndex = Math.min(data.length - 1, this.getEstimatedIndex(scrollValueEnd) + this.estimatedItemsAcross - 1);
              renderBeforeBoundary = Math.max(0, this.getEstimatedPrimaryPos(renderStartIndex));
              renderAfterBoundary = this.getEstimatedPrimaryPos(renderEndIndex) + this.estimatedPrimarySize;
            };
          }
          function DynamicViewType() {
            var self = this;
            var debouncedScrollViewSetDimensions = ionic.debounce(scrollViewSetDimensions, 25, true);
            var calculateDimensions = isGridView ? calculateDimensionsGrid : calculateDimensionsList;
            var dimensionsIndex;
            var dimensions = [];
            function calculateDimensionsList(toIndex) {
              var i,
                  prevDimension,
                  dim;
              for (i = Math.max(0, dimensionsIndex); i <= toIndex && (dim = dimensions[i]); i++) {
                prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
                dim.primarySize = self.getItemPrimarySize(i, data[i]);
                dim.secondarySize = self.scrollSecondarySize;
                dim.primaryPos = prevDimension.primaryPos + prevDimension.primarySize;
                dim.secondaryPos = 0;
              }
            }
            function calculateDimensionsGrid(toIndex) {
              var i,
                  prevDimension,
                  dim;
              for (i = Math.max(dimensionsIndex, 0); i <= toIndex && (dim = dimensions[i]); i++) {
                prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
                dim.secondarySize = Math.min(self.getItemSecondarySize(i, data[i]), self.scrollSecondarySize);
                dim.secondaryPos = prevDimension.secondaryPos + prevDimension.secondarySize;
                if (i === 0 || dim.secondaryPos + dim.secondarySize > self.scrollSecondarySize) {
                  dim.secondaryPos = 0;
                  dim.primarySize = self.getItemPrimarySize(i, data[i]);
                  dim.primaryPos = prevDimension.primaryPos + prevDimension.rowPrimarySize;
                  dim.rowStartIndex = i;
                  dim.rowPrimarySize = dim.primarySize;
                } else {
                  dim.primarySize = self.getItemPrimarySize(i, data[i]);
                  dim.primaryPos = prevDimension.primaryPos;
                  dim.rowStartIndex = prevDimension.rowStartIndex;
                  dimensions[dim.rowStartIndex].rowPrimarySize = dim.rowPrimarySize = Math.max(dimensions[dim.rowStartIndex].rowPrimarySize, dim.primarySize);
                  dim.rowPrimarySize = Math.max(dim.primarySize, dim.rowPrimarySize);
                }
              }
            }
            this.getContentSize = function() {
              var dim = dimensions[dimensionsIndex] || EMPTY_DIMENSION;
              return ((dim.primaryPos + dim.primarySize) || 0) + this.getEstimatedPrimaryPos(data.length - dimensionsIndex - 1) + repeaterBeforeSize + repeaterAfterSize;
            };
            this.onDestroy = function() {
              dimensions.length = 0;
            };
            this.onRefreshData = function() {
              var i;
              var ii;
              for (i = dimensions.length, ii = data.length; i < ii; i++) {
                dimensions.push({});
              }
              dimensionsIndex = -1;
            };
            this.onRefreshLayout = function() {
              dimensionsIndex = -1;
            };
            this.getDimensions = function(index) {
              index = Math.min(index, data.length - 1);
              if (dimensionsIndex < index) {
                if (index > data.length * 0.9) {
                  calculateDimensions(data.length - 1);
                  dimensionsIndex = data.length - 1;
                  scrollViewSetDimensions();
                } else {
                  calculateDimensions(index);
                  dimensionsIndex = index;
                  debouncedScrollViewSetDimensions();
                }
              }
              return dimensions[index];
            };
            var oldRenderStartIndex = -1;
            var oldScrollValue = -1;
            this.updateRenderRange = function(scrollValue, scrollValueEnd) {
              var i;
              var len;
              var dim;
              this.getDimensions(this.getEstimatedIndex(scrollValueEnd) * 2);
              if (oldRenderStartIndex === -1 || scrollValue === 0) {
                i = 0;
              } else if (scrollValue >= oldScrollValue) {
                for (i = oldRenderStartIndex, len = data.length; i < len; i++) {
                  if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize >= scrollValue) {
                    break;
                  }
                }
              } else {
                for (i = oldRenderStartIndex; i >= 0; i--) {
                  if ((dim = this.getDimensions(i)) && dim.primaryPos <= scrollValue) {
                    i = isGridView ? dim.rowStartIndex : i;
                    break;
                  }
                }
              }
              renderStartIndex = Math.min(Math.max(0, i), data.length - 1);
              renderBeforeBoundary = renderStartIndex !== -1 ? this.getDimensions(renderStartIndex).primaryPos : -1;
              var lastRowDim;
              for (i = renderStartIndex + 1, len = data.length; i < len; i++) {
                if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize > scrollValueEnd) {
                  if (isGridView) {
                    lastRowDim = dim;
                    while (i < len - 1 && (dim = this.getDimensions(i + 1)).primaryPos === lastRowDim.primaryPos) {
                      i++;
                    }
                  }
                  break;
                }
              }
              renderEndIndex = Math.min(i, data.length - 1);
              renderAfterBoundary = renderEndIndex !== -1 ? ((dim = this.getDimensions(renderEndIndex)).primaryPos + (dim.rowPrimarySize || dim.primarySize)) : -1;
              oldScrollValue = scrollValue;
              oldRenderStartIndex = renderStartIndex;
            };
          }
        };
      }
      IonicModule.directive('ionContent', ['$timeout', '$controller', '$ionicBind', '$ionicConfig', function($timeout, $controller, $ionicBind, $ionicConfig) {
        return {
          restrict: 'E',
          require: '^?ionNavView',
          scope: true,
          priority: 800,
          compile: function(element, attr) {
            var innerElement;
            var scrollCtrl;
            element.addClass('scroll-content ionic-scroll');
            if (attr.scroll != 'false') {
              innerElement = jqLite('<div class="scroll"></div>');
              innerElement.append(element.contents());
              element.append(innerElement);
            } else {
              element.addClass('scroll-content-false');
            }
            var nativeScrolling = attr.overflowScroll === "true" || !$ionicConfig.scrolling.jsScrolling();
            if (nativeScrolling) {
              nativeScrolling = !element[0].querySelector('[collection-repeat]');
            }
            return {pre: prelink};
            function prelink($scope, $element, $attr) {
              var parentScope = $scope.$parent;
              $scope.$watch(function() {
                return (parentScope.$hasHeader ? ' has-header' : '') + (parentScope.$hasSubheader ? ' has-subheader' : '') + (parentScope.$hasFooter ? ' has-footer' : '') + (parentScope.$hasSubfooter ? ' has-subfooter' : '') + (parentScope.$hasTabs ? ' has-tabs' : '') + (parentScope.$hasTabsTop ? ' has-tabs-top' : '');
              }, function(className, oldClassName) {
                $element.removeClass(oldClassName);
                $element.addClass(className);
              });
              $scope.$hasHeader = $scope.$hasSubheader = $scope.$hasFooter = $scope.$hasSubfooter = $scope.$hasTabs = $scope.$hasTabsTop = false;
              $ionicBind($scope, $attr, {
                $onScroll: '&onScroll',
                $onScrollComplete: '&onScrollComplete',
                hasBouncing: '@',
                padding: '@',
                direction: '@',
                scrollbarX: '@',
                scrollbarY: '@',
                startX: '@',
                startY: '@',
                scrollEventInterval: '@'
              });
              $scope.direction = $scope.direction || 'y';
              if (isDefined($attr.padding)) {
                $scope.$watch($attr.padding, function(newVal) {
                  (innerElement || $element).toggleClass('padding', !!newVal);
                });
              }
              if ($attr.scroll === "false") {} else {
                var scrollViewOptions = {};
                if (nativeScrolling) {
                  $element.addClass('overflow-scroll');
                  scrollViewOptions = {
                    el: $element[0],
                    delegateHandle: attr.delegateHandle,
                    startX: $scope.$eval($scope.startX) || 0,
                    startY: $scope.$eval($scope.startY) || 0,
                    nativeScrolling: true
                  };
                } else {
                  scrollViewOptions = {
                    el: $element[0],
                    delegateHandle: attr.delegateHandle,
                    locking: (attr.locking || 'true') === 'true',
                    bouncing: $scope.$eval($scope.hasBouncing),
                    startX: $scope.$eval($scope.startX) || 0,
                    startY: $scope.$eval($scope.startY) || 0,
                    scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                    scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                    scrollingX: $scope.direction.indexOf('x') >= 0,
                    scrollingY: $scope.direction.indexOf('y') >= 0,
                    scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,
                    scrollingComplete: onScrollComplete
                  };
                }
                scrollCtrl = $controller('$ionicScroll', {
                  $scope: $scope,
                  scrollViewOptions: scrollViewOptions
                });
                $scope.$on('$destroy', function() {
                  if (scrollViewOptions) {
                    scrollViewOptions.scrollingComplete = noop;
                    delete scrollViewOptions.el;
                  }
                  innerElement = null;
                  $element = null;
                  attr.$$element = null;
                });
              }
              function onScrollComplete() {
                $scope.$onScrollComplete({
                  scrollTop: scrollCtrl.scrollView.__scrollTop,
                  scrollLeft: scrollCtrl.scrollView.__scrollLeft
                });
              }
            }
          }
        };
      }]);
      IonicModule.directive('exposeAsideWhen', ['$window', function($window) {
        return {
          restrict: 'A',
          require: '^ionSideMenus',
          link: function($scope, $element, $attr, sideMenuCtrl) {
            function checkAsideExpose() {
              var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;
              sideMenuCtrl.exposeAside($window.matchMedia(mq).matches);
              sideMenuCtrl.activeAsideResizing(false);
            }
            function onResize() {
              sideMenuCtrl.activeAsideResizing(true);
              debouncedCheck();
            }
            var debouncedCheck = ionic.debounce(function() {
              $scope.$apply(checkAsideExpose);
            }, 300, false);
            $scope.$evalAsync(checkAsideExpose);
            ionic.on('resize', onResize, $window);
            $scope.$on('$destroy', function() {
              ionic.off('resize', onResize, $window);
            });
          }
        };
      }]);
      var GESTURE_DIRECTIVES = 'onHold onTap onDoubleTap onTouch onRelease onDragStart onDrag onDragEnd onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft'.split(' ');
      GESTURE_DIRECTIVES.forEach(function(name) {
        IonicModule.directive(name, gestureDirective(name));
      });
      function gestureDirective(directiveName) {
        return ['$ionicGesture', '$parse', function($ionicGesture, $parse) {
          var eventType = directiveName.substr(2).toLowerCase();
          return function(scope, element, attr) {
            var fn = $parse(attr[directiveName]);
            var listener = function(ev) {
              scope.$apply(function() {
                fn(scope, {$event: ev});
              });
            };
            var gesture = $ionicGesture.on(eventType, listener, element);
            scope.$on('$destroy', function() {
              $ionicGesture.off(gesture, eventType, listener);
            });
          };
        }];
      }
      IonicModule.directive('ionHeaderBar', tapScrollToTopDirective()).directive('ionHeaderBar', headerFooterBarDirective(true)).directive('ionFooterBar', headerFooterBarDirective(false));
      function tapScrollToTopDirective() {
        return ['$ionicScrollDelegate', function($ionicScrollDelegate) {
          return {
            restrict: 'E',
            link: function($scope, $element, $attr) {
              if ($attr.noTapScroll == 'true') {
                return;
              }
              ionic.on('tap', onTap, $element[0]);
              $scope.$on('$destroy', function() {
                ionic.off('tap', onTap, $element[0]);
              });
              function onTap(e) {
                var depth = 3;
                var current = e.target;
                while (depth-- && current) {
                  if (current.classList.contains('button') || current.tagName.match(/input|textarea|select/i) || current.isContentEditable) {
                    return;
                  }
                  current = current.parentNode;
                }
                var touch = e.gesture && e.gesture.touches[0] || e.detail.touches[0];
                var bounds = $element[0].getBoundingClientRect();
                if (ionic.DomUtil.rectContains(touch.pageX, touch.pageY, bounds.left, bounds.top - 20, bounds.left + bounds.width, bounds.top + bounds.height)) {
                  $ionicScrollDelegate.scrollTop(true);
                }
              }
            }
          };
        }];
      }
      function headerFooterBarDirective(isHeader) {
        return ['$document', '$timeout', function($document, $timeout) {
          return {
            restrict: 'E',
            controller: '$ionicHeaderBar',
            compile: function(tElement) {
              tElement.addClass(isHeader ? 'bar bar-header' : 'bar bar-footer');
              $timeout(function() {
                if (isHeader && $document[0].getElementsByClassName('tabs-top').length)
                  tElement.addClass('has-tabs-top');
              });
              return {pre: prelink};
              function prelink($scope, $element, $attr, ctrl) {
                if (isHeader) {
                  $scope.$watch(function() {
                    return $element[0].className;
                  }, function(value) {
                    var isShown = value.indexOf('ng-hide') === -1;
                    var isSubheader = value.indexOf('bar-subheader') !== -1;
                    $scope.$hasHeader = isShown && !isSubheader;
                    $scope.$hasSubheader = isShown && isSubheader;
                    $scope.$emit('$ionicSubheader', $scope.$hasSubheader);
                  });
                  $scope.$on('$destroy', function() {
                    delete $scope.$hasHeader;
                    delete $scope.$hasSubheader;
                  });
                  ctrl.align();
                  $scope.$on('$ionicHeader.align', function() {
                    ionic.requestAnimationFrame(function() {
                      ctrl.align();
                    });
                  });
                } else {
                  $scope.$watch(function() {
                    return $element[0].className;
                  }, function(value) {
                    var isShown = value.indexOf('ng-hide') === -1;
                    var isSubfooter = value.indexOf('bar-subfooter') !== -1;
                    $scope.$hasFooter = isShown && !isSubfooter;
                    $scope.$hasSubfooter = isShown && isSubfooter;
                  });
                  $scope.$on('$destroy', function() {
                    delete $scope.$hasFooter;
                    delete $scope.$hasSubfooter;
                  });
                  $scope.$watch('$hasTabs', function(val) {
                    $element.toggleClass('has-tabs', !!val);
                  });
                }
              }
            }
          };
        }];
      }
      IonicModule.directive('ionInfiniteScroll', ['$timeout', function($timeout) {
        return {
          restrict: 'E',
          require: ['?^$ionicScroll', 'ionInfiniteScroll'],
          template: function($element, $attrs) {
            if ($attrs.icon)
              return '<i class="icon {{icon()}} icon-refreshing {{scrollingType}}"></i>';
            return '<ion-spinner icon="{{spinner()}}"></ion-spinner>';
          },
          scope: true,
          controller: '$ionInfiniteScroll',
          link: function($scope, $element, $attrs, ctrls) {
            var infiniteScrollCtrl = ctrls[1];
            var scrollCtrl = infiniteScrollCtrl.scrollCtrl = ctrls[0];
            var jsScrolling = infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative();
            if (jsScrolling) {
              infiniteScrollCtrl.scrollView = scrollCtrl.scrollView;
              $scope.scrollingType = 'js-scrolling';
              scrollCtrl.$element.on('scroll', infiniteScrollCtrl.checkBounds);
            } else {
              var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, 'overflow-scroll');
              infiniteScrollCtrl.scrollEl = scrollEl;
              if (!scrollEl) {
                throw 'Infinite scroll must be used inside a scrollable div';
              }
              infiniteScrollCtrl.scrollEl.addEventListener('scroll', infiniteScrollCtrl.checkBounds);
            }
            var doImmediateCheck = isDefined($attrs.immediateCheck) ? $scope.$eval($attrs.immediateCheck) : true;
            if (doImmediateCheck) {
              $timeout(function() {
                infiniteScrollCtrl.checkBounds();
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionItem', ['$$rAF', function($$rAF) {
        return {
          restrict: 'E',
          controller: ['$scope', '$element', function($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
          }],
          scope: true,
          compile: function($element, $attrs) {
            var isAnchor = isDefined($attrs.href) || isDefined($attrs.ngHref) || isDefined($attrs.uiSref);
            var isComplexItem = isAnchor || /ion-(delete|option|reorder)-button/i.test($element.html());
            if (isComplexItem) {
              var innerElement = jqLite(isAnchor ? '<a></a>' : '<div></div>');
              innerElement.addClass('item-content');
              if (isDefined($attrs.href) || isDefined($attrs.ngHref)) {
                innerElement.attr('ng-href', '{{$href()}}');
                if (isDefined($attrs.target)) {
                  innerElement.attr('target', '{{$target()}}');
                }
              }
              innerElement.append($element.contents());
              $element.addClass('item item-complex').append(innerElement);
            } else {
              $element.addClass('item');
            }
            return function link($scope, $element, $attrs) {
              $scope.$href = function() {
                return $attrs.href || $attrs.ngHref;
              };
              $scope.$target = function() {
                return $attrs.target;
              };
              var content = $element[0].querySelector('.item-content');
              if (content) {
                $scope.$on('$collectionRepeatLeave', function() {
                  if (content && content.$$ionicOptionsOpen) {
                    content.style[ionic.CSS.TRANSFORM] = '';
                    content.style[ionic.CSS.TRANSITION] = 'none';
                    $$rAF(function() {
                      content.style[ionic.CSS.TRANSITION] = '';
                    });
                    content.$$ionicOptionsOpen = false;
                  }
                });
              }
            };
          }
        };
      }]);
      var ITEM_TPL_DELETE_BUTTON = '<div class="item-left-edit item-delete enable-pointer-events">' + '</div>';
      IonicModule.directive('ionDeleteButton', function() {
        function stopPropagation(ev) {
          ev.stopPropagation();
        }
        return {
          restrict: 'E',
          require: ['^^ionItem', '^?ionList'],
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
            return function($scope, $element, $attr, ctrls) {
              var itemCtrl = ctrls[0];
              var listCtrl = ctrls[1];
              var container = jqLite(ITEM_TPL_DELETE_BUTTON);
              container.append($element);
              itemCtrl.$element.append(container).addClass('item-left-editable');
              $element.on('click', stopPropagation);
              init();
              $scope.$on('$ionic.reconnectScope', init);
              function init() {
                listCtrl = listCtrl || $element.controller('ionList');
                if (listCtrl && listCtrl.showDelete()) {
                  container.addClass('visible active');
                }
              }
            };
          }
        };
      });
      IonicModule.directive('itemFloatingLabel', function() {
        return {
          restrict: 'C',
          link: function(scope, element) {
            var el = element[0];
            var input = el.querySelector('input, textarea');
            var inputLabel = el.querySelector('.input-label');
            if (!input || !inputLabel)
              return;
            var onInput = function() {
              if (input.value) {
                inputLabel.classList.add('has-input');
              } else {
                inputLabel.classList.remove('has-input');
              }
            };
            input.addEventListener('input', onInput);
            var ngModelCtrl = jqLite(input).controller('ngModel');
            if (ngModelCtrl) {
              ngModelCtrl.$render = function() {
                input.value = ngModelCtrl.$viewValue || '';
                onInput();
              };
            }
            scope.$on('$destroy', function() {
              input.removeEventListener('input', onInput);
            });
          }
        };
      });
      var ITEM_TPL_OPTION_BUTTONS = '<div class="item-options invisible">' + '</div>';
      IonicModule.directive('ionOptionButton', [function() {
        function stopPropagation(e) {
          e.stopPropagation();
        }
        return {
          restrict: 'E',
          require: '^ionItem',
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button', true);
            return function($scope, $element, $attr, itemCtrl) {
              if (!itemCtrl.optionsContainer) {
                itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS);
                itemCtrl.$element.append(itemCtrl.optionsContainer);
              }
              itemCtrl.optionsContainer.append($element);
              itemCtrl.$element.addClass('item-right-editable');
              $element.on('click', stopPropagation);
            };
          }
        };
      }]);
      var ITEM_TPL_REORDER_BUTTON = '<div data-prevent-scroll="true" class="item-right-edit item-reorder enable-pointer-events">' + '</div>';
      IonicModule.directive('ionReorderButton', ['$parse', function($parse) {
        return {
          restrict: 'E',
          require: ['^ionItem', '^?ionList'],
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
            $element[0].setAttribute('data-prevent-scroll', true);
            return function($scope, $element, $attr, ctrls) {
              var itemCtrl = ctrls[0];
              var listCtrl = ctrls[1];
              var onReorderFn = $parse($attr.onReorder);
              $scope.$onReorder = function(oldIndex, newIndex) {
                onReorderFn($scope, {
                  $fromIndex: oldIndex,
                  $toIndex: newIndex
                });
              };
              if (!$attr.ngClick && !$attr.onClick && !$attr.onclick) {
                $element[0].onclick = function(e) {
                  e.stopPropagation();
                  return false;
                };
              }
              var container = jqLite(ITEM_TPL_REORDER_BUTTON);
              container.append($element);
              itemCtrl.$element.append(container).addClass('item-right-editable');
              if (listCtrl && listCtrl.showReorder()) {
                container.addClass('visible active');
              }
            };
          }
        };
      }]);
      IonicModule.directive('keyboardAttach', function() {
        return function(scope, element) {
          ionic.on('native.keyboardshow', onShow, window);
          ionic.on('native.keyboardhide', onHide, window);
          ionic.on('native.showkeyboard', onShow, window);
          ionic.on('native.hidekeyboard', onHide, window);
          var scrollCtrl;
          function onShow(e) {
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              return;
            }
            var keyboardHeight = e.keyboardHeight || e.detail.keyboardHeight;
            element.css('bottom', keyboardHeight + "px");
            scrollCtrl = element.controller('$ionicScroll');
            if (scrollCtrl) {
              scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + "px";
            }
          }
          function onHide() {
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              return;
            }
            element.css('bottom', '');
            if (scrollCtrl) {
              scrollCtrl.scrollView.__container.style.bottom = '';
            }
          }
          scope.$on('$destroy', function() {
            ionic.off('native.keyboardshow', onShow, window);
            ionic.off('native.keyboardhide', onHide, window);
            ionic.off('native.showkeyboard', onShow, window);
            ionic.off('native.hidekeyboard', onHide, window);
          });
        };
      });
      function keyboardAttachGetClientHeight(element) {
        return element.clientHeight;
      }
      IonicModule.directive('ionList', ['$timeout', function($timeout) {
        return {
          restrict: 'E',
          require: ['ionList', '^?$ionicScroll'],
          controller: '$ionicList',
          compile: function($element, $attr) {
            var listEl = jqLite('<div class="list">').append($element.contents()).addClass($attr.type);
            $element.append(listEl);
            return function($scope, $element, $attrs, ctrls) {
              var listCtrl = ctrls[0];
              var scrollCtrl = ctrls[1];
              $timeout(init);
              function init() {
                var listView = listCtrl.listView = new ionic.views.ListView({
                  el: $element[0],
                  listEl: $element.children()[0],
                  scrollEl: scrollCtrl && scrollCtrl.element,
                  scrollView: scrollCtrl && scrollCtrl.scrollView,
                  onReorder: function(el, oldIndex, newIndex) {
                    var itemScope = jqLite(el).scope();
                    if (itemScope && itemScope.$onReorder) {
                      $timeout(function() {
                        itemScope.$onReorder(oldIndex, newIndex);
                      });
                    }
                  },
                  canSwipe: function() {
                    return listCtrl.canSwipeItems();
                  }
                });
                $scope.$on('$destroy', function() {
                  if (listView) {
                    listView.deregister && listView.deregister();
                    listView = null;
                  }
                });
                if (isDefined($attr.canSwipe)) {
                  $scope.$watch('!!(' + $attr.canSwipe + ')', function(value) {
                    listCtrl.canSwipeItems(value);
                  });
                }
                if (isDefined($attr.showDelete)) {
                  $scope.$watch('!!(' + $attr.showDelete + ')', function(value) {
                    listCtrl.showDelete(value);
                  });
                }
                if (isDefined($attr.showReorder)) {
                  $scope.$watch('!!(' + $attr.showReorder + ')', function(value) {
                    listCtrl.showReorder(value);
                  });
                }
                $scope.$watch(function() {
                  return listCtrl.showDelete();
                }, function(isShown, wasShown) {
                  if (!isShown && !wasShown) {
                    return;
                  }
                  if (isShown)
                    listCtrl.closeOptionButtons();
                  listCtrl.canSwipeItems(!isShown);
                  $element.children().toggleClass('list-left-editing', isShown);
                  $element.toggleClass('disable-pointer-events', isShown);
                  var deleteButton = jqLite($element[0].getElementsByClassName('item-delete'));
                  setButtonShown(deleteButton, listCtrl.showDelete);
                });
                $scope.$watch(function() {
                  return listCtrl.showReorder();
                }, function(isShown, wasShown) {
                  if (!isShown && !wasShown) {
                    return;
                  }
                  if (isShown)
                    listCtrl.closeOptionButtons();
                  listCtrl.canSwipeItems(!isShown);
                  $element.children().toggleClass('list-right-editing', isShown);
                  $element.toggleClass('disable-pointer-events', isShown);
                  var reorderButton = jqLite($element[0].getElementsByClassName('item-reorder'));
                  setButtonShown(reorderButton, listCtrl.showReorder);
                });
                function setButtonShown(el, shown) {
                  shown() && el.addClass('visible') || el.removeClass('active');
                  ionic.requestAnimationFrame(function() {
                    shown() && el.addClass('active') || el.removeClass('visible');
                  });
                }
              }
            };
          }
        };
      }]);
      IonicModule.directive('menuClose', ['$ionicHistory', '$timeout', function($ionicHistory, $timeout) {
        return {
          restrict: 'AC',
          link: function($scope, $element) {
            $element.bind('click', function() {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              if (sideMenuCtrl) {
                $ionicHistory.nextViewOptions({
                  historyRoot: true,
                  disableAnimate: true,
                  expire: 300
                });
                $timeout(function() {
                  $ionicHistory.nextViewOptions({
                    historyRoot: false,
                    disableAnimate: false
                  });
                }, 300);
                sideMenuCtrl.close();
              }
            });
          }
        };
      }]);
      IonicModule.directive('menuToggle', function() {
        return {
          restrict: 'AC',
          link: function($scope, $element, $attr) {
            $scope.$on('$ionicView.beforeEnter', function(ev, viewData) {
              if (viewData.enableBack) {
                var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
                if (!sideMenuCtrl.enableMenuWithBackViews()) {
                  $element.addClass('hide');
                }
              } else {
                $element.removeClass('hide');
              }
            });
            $element.bind('click', function() {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              sideMenuCtrl && sideMenuCtrl.toggle($attr.menuToggle);
            });
          }
        };
      });
      IonicModule.directive('ionModal', [function() {
        return {
          restrict: 'E',
          transclude: true,
          replace: true,
          controller: [function() {}],
          template: '<div class="modal-backdrop">' + '<div class="modal-backdrop-bg"></div>' + '<div class="modal-wrapper" ng-transclude></div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionModalView', function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.addClass('modal');
          }
        };
      });
      IonicModule.directive('ionNavBackButton', ['$ionicConfig', '$document', function($ionicConfig, $document) {
        return {
          restrict: 'E',
          require: '^ionNavBar',
          compile: function(tElement, tAttrs) {
            var buttonEle = $document[0].createElement('button');
            for (var n in tAttrs.$attr) {
              buttonEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
            }
            if (!tAttrs.ngClick) {
              buttonEle.setAttribute('ng-click', '$ionicGoBack()');
            }
            buttonEle.className = 'button back-button hide buttons ' + (tElement.attr('class') || '');
            buttonEle.innerHTML = tElement.html() || '';
            var childNode;
            var hasIcon = hasIconClass(tElement[0]);
            var hasInnerText;
            var hasButtonText;
            var hasPreviousTitle;
            for (var x = 0; x < tElement[0].childNodes.length; x++) {
              childNode = tElement[0].childNodes[x];
              if (childNode.nodeType === 1) {
                if (hasIconClass(childNode)) {
                  hasIcon = true;
                } else if (childNode.classList.contains('default-title')) {
                  hasButtonText = true;
                } else if (childNode.classList.contains('previous-title')) {
                  hasPreviousTitle = true;
                }
              } else if (!hasInnerText && childNode.nodeType === 3) {
                hasInnerText = !!childNode.nodeValue.trim();
              }
            }
            function hasIconClass(ele) {
              return /ion-|icon/.test(ele.className);
            }
            var defaultIcon = $ionicConfig.backButton.icon();
            if (!hasIcon && defaultIcon && defaultIcon !== 'none') {
              buttonEle.innerHTML = '<i class="icon ' + defaultIcon + '"></i> ' + buttonEle.innerHTML;
              buttonEle.className += ' button-clear';
            }
            if (!hasInnerText) {
              var buttonTextEle = $document[0].createElement('span');
              buttonTextEle.className = 'back-text';
              if (!hasButtonText && $ionicConfig.backButton.text()) {
                buttonTextEle.innerHTML += '<span class="default-title">' + $ionicConfig.backButton.text() + '</span>';
              }
              if (!hasPreviousTitle && $ionicConfig.backButton.previousTitleText()) {
                buttonTextEle.innerHTML += '<span class="previous-title"></span>';
              }
              buttonEle.appendChild(buttonTextEle);
            }
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attr, navBarCtrl) {
                navBarCtrl.navElement('backButton', buttonEle.outerHTML);
                buttonEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('ionNavBar', function() {
        return {
          restrict: 'E',
          controller: '$ionicNavBar',
          scope: true,
          link: function($scope, $element, $attr, ctrl) {
            ctrl.init();
          }
        };
      });
      IonicModule.directive('ionNavButtons', ['$document', function($document) {
        return {
          require: '^ionNavBar',
          restrict: 'E',
          compile: function(tElement, tAttrs) {
            var side = 'left';
            if (/^primary|secondary|right$/i.test(tAttrs.side || '')) {
              side = tAttrs.side.toLowerCase();
            }
            var spanEle = $document[0].createElement('span');
            spanEle.className = side + '-buttons';
            spanEle.innerHTML = tElement.html();
            var navElementType = side + 'Buttons';
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attrs, navBarCtrl) {
                var parentViewCtrl = $element.parent().data('$ionViewController');
                if (parentViewCtrl) {
                  parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                } else {
                  navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                }
                spanEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('navDirection', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
        return {
          restrict: 'A',
          priority: 1000,
          link: function($scope, $element, $attr) {
            $element.bind('click', function() {
              $ionicViewSwitcher.nextDirection($attr.navDirection);
            });
          }
        };
      }]);
      IonicModule.directive('ionNavTitle', ['$document', function($document) {
        return {
          require: '^ionNavBar',
          restrict: 'E',
          compile: function(tElement, tAttrs) {
            var navElementType = 'title';
            var spanEle = $document[0].createElement('span');
            for (var n in tAttrs.$attr) {
              spanEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
            }
            spanEle.classList.add('nav-bar-title');
            spanEle.innerHTML = tElement.html();
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attrs, navBarCtrl) {
                var parentViewCtrl = $element.parent().data('$ionViewController');
                if (parentViewCtrl) {
                  parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                } else {
                  navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                }
                spanEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('navTransition', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
        return {
          restrict: 'A',
          priority: 1000,
          link: function($scope, $element, $attr) {
            $element.bind('click', function() {
              $ionicViewSwitcher.nextTransition($attr.navTransition);
            });
          }
        };
      }]);
      IonicModule.directive('ionNavView', ['$state', '$ionicConfig', function($state, $ionicConfig) {
        return {
          restrict: 'E',
          terminal: true,
          priority: 2000,
          transclude: true,
          controller: '$ionicNavView',
          compile: function(tElement, tAttrs, transclude) {
            tElement.addClass('view-container');
            ionic.DomUtil.cachedAttr(tElement, 'nav-view-transition', $ionicConfig.views.transition());
            return function($scope, $element, $attr, navViewCtrl) {
              var latestLocals;
              transclude($scope, function(clone) {
                $element.append(clone);
              });
              var viewData = navViewCtrl.init();
              $scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              $scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function updateView(firstTime) {
                var viewLocals = $state.$current && $state.$current.locals[viewData.name];
                if (!viewLocals || (!firstTime && viewLocals === latestLocals))
                  return;
                latestLocals = viewLocals;
                viewData.state = viewLocals.$$state;
                navViewCtrl.register(viewLocals);
              }
            };
          }
        };
      }]);
      IonicModule.config(['$provide', function($provide) {
        $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
          $delegate.shift();
          return $delegate;
        }]);
      }]).factory('$ionicNgClick', ['$parse', function($parse) {
        return function(scope, element, clickExpr) {
          var clickHandler = angular.isFunction(clickExpr) ? clickExpr : $parse(clickExpr);
          element.on('click', function(event) {
            scope.$apply(function() {
              clickHandler(scope, {$event: (event)});
            });
          });
          element.onclick = noop;
        };
      }]).directive('ngClick', ['$ionicNgClick', function($ionicNgClick) {
        return function(scope, element, attr) {
          $ionicNgClick(scope, element, attr.ngClick);
        };
      }]).directive('ionStopEvent', function() {
        return {
          restrict: 'A',
          link: function(scope, element, attr) {
            element.bind(attr.ionStopEvent, eventStopPropagation);
          }
        };
      });
      function eventStopPropagation(e) {
        e.stopPropagation();
      }
      IonicModule.directive('ionPane', function() {
        return {
          restrict: 'E',
          link: function(scope, element) {
            element.addClass('pane');
          }
        };
      });
      IonicModule.directive('ionPopover', [function() {
        return {
          restrict: 'E',
          transclude: true,
          replace: true,
          controller: [function() {}],
          template: '<div class="popover-backdrop">' + '<div class="popover-wrapper" ng-transclude></div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionPopoverView', function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.append(jqLite('<div class="popover-arrow">'));
            element.addClass('popover');
          }
        };
      });
      IonicModule.directive('ionRadio', function() {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<label class="item item-radio">' + '<input type="radio" name="radio-group">' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' + '</label>',
          compile: function(element, attr) {
            if (attr.icon) {
              element.children().eq(2).removeClass('ion-checkmark').addClass(attr.icon);
            }
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'value': attr.value,
              'disabled': attr.disabled,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-disabled': attr.ngDisabled,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            return function(scope, element, attr) {
              scope.getValue = function() {
                return scope.ngValue || attr.value;
              };
            };
          }
        };
      });
      IonicModule.directive('ionRefresher', [function() {
        return {
          restrict: 'E',
          replace: true,
          require: ['?^$ionicScroll', 'ionRefresher'],
          controller: '$ionicRefresher',
          template: '<div class="scroll-refresher invisible" collection-repeat-ignore>' + '<div class="ionic-refresher-content" ' + 'ng-class="{\'ionic-refresher-with-text\': pullingText || refreshingText}">' + '<div class="icon-pulling" ng-class="{\'pulling-rotation-disabled\':disablePullingRotation}">' + '<i class="icon {{pullingIcon}}"></i>' + '</div>' + '<div class="text-pulling" ng-bind-html="pullingText"></div>' + '<div class="icon-refreshing">' + '<ion-spinner ng-if="showSpinner" icon="{{spinner}}"></ion-spinner>' + '<i ng-if="showIcon" class="icon {{refreshingIcon}}"></i>' + '</div>' + '<div class="text-refreshing" ng-bind-html="refreshingText"></div>' + '</div>' + '</div>',
          link: function($scope, $element, $attrs, ctrls) {
            var scrollCtrl = ctrls[0],
                refresherCtrl = ctrls[1];
            if (!scrollCtrl || scrollCtrl.isNative()) {
              refresherCtrl.init();
            } else {
              $element[0].classList.add('js-scrolling');
              scrollCtrl._setRefresher($scope, $element[0], refresherCtrl.getRefresherDomMethods());
              $scope.$on('scroll.refreshComplete', function() {
                $scope.$evalAsync(function() {
                  scrollCtrl.scrollView.finishPullToRefresh();
                });
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionScroll', ['$timeout', '$controller', '$ionicBind', function($timeout, $controller, $ionicBind) {
        return {
          restrict: 'E',
          scope: true,
          controller: function() {},
          compile: function(element) {
            element.addClass('scroll-view ionic-scroll');
            var innerElement = jqLite('<div class="scroll"></div>');
            innerElement.append(element.contents());
            element.append(innerElement);
            return {pre: prelink};
            function prelink($scope, $element, $attr) {
              $ionicBind($scope, $attr, {
                direction: '@',
                paging: '@',
                $onScroll: '&onScroll',
                scroll: '@',
                scrollbarX: '@',
                scrollbarY: '@',
                zooming: '@',
                minZoom: '@',
                maxZoom: '@'
              });
              $scope.direction = $scope.direction || 'y';
              if (isDefined($attr.padding)) {
                $scope.$watch($attr.padding, function(newVal) {
                  innerElement.toggleClass('padding', !!newVal);
                });
              }
              if ($scope.$eval($scope.paging) === true) {
                innerElement.addClass('scroll-paging');
              }
              if (!$scope.direction) {
                $scope.direction = 'y';
              }
              var isPaging = $scope.$eval($scope.paging) === true;
              var scrollViewOptions = {
                el: $element[0],
                delegateHandle: $attr.delegateHandle,
                locking: ($attr.locking || 'true') === 'true',
                bouncing: $scope.$eval($attr.hasBouncing),
                paging: isPaging,
                scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                scrollingX: $scope.direction.indexOf('x') >= 0,
                scrollingY: $scope.direction.indexOf('y') >= 0,
                zooming: $scope.$eval($scope.zooming) === true,
                maxZoom: $scope.$eval($scope.maxZoom) || 3,
                minZoom: $scope.$eval($scope.minZoom) || 0.5,
                preventDefault: true
              };
              if (isPaging) {
                scrollViewOptions.speedMultiplier = 0.8;
                scrollViewOptions.bouncing = false;
              }
              $controller('$ionicScroll', {
                $scope: $scope,
                scrollViewOptions: scrollViewOptions
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSideMenu', function() {
        return {
          restrict: 'E',
          require: '^ionSideMenus',
          scope: true,
          compile: function(element, attr) {
            angular.isUndefined(attr.isEnabled) && attr.$set('isEnabled', 'true');
            angular.isUndefined(attr.width) && attr.$set('width', '275');
            element.addClass('menu menu-' + attr.side);
            return function($scope, $element, $attr, sideMenuCtrl) {
              $scope.side = $attr.side || 'left';
              var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({
                width: attr.width,
                el: $element[0],
                isEnabled: true
              });
              $scope.$watch($attr.width, function(val) {
                var numberVal = +val;
                if (numberVal && numberVal == val) {
                  sideMenu.setWidth(+val);
                }
              });
              $scope.$watch($attr.isEnabled, function(val) {
                sideMenu.setIsEnabled(!!val);
              });
            };
          }
        };
      });
      IonicModule.directive('ionSideMenuContent', ['$timeout', '$ionicGesture', '$window', function($timeout, $ionicGesture, $window) {
        return {
          restrict: 'EA',
          require: '^ionSideMenus',
          scope: true,
          compile: function(element, attr) {
            element.addClass('menu-content pane');
            return {pre: prelink};
            function prelink($scope, $element, $attr, sideMenuCtrl) {
              var startCoord = null;
              var primaryScrollAxis = null;
              if (isDefined(attr.dragContent)) {
                $scope.$watch(attr.dragContent, function(value) {
                  sideMenuCtrl.canDragContent(value);
                });
              } else {
                sideMenuCtrl.canDragContent(true);
              }
              if (isDefined(attr.edgeDragThreshold)) {
                $scope.$watch(attr.edgeDragThreshold, function(value) {
                  sideMenuCtrl.edgeDragThreshold(value);
                });
              }
              function onContentTap(gestureEvt) {
                if (sideMenuCtrl.getOpenAmount() !== 0) {
                  sideMenuCtrl.close();
                  gestureEvt.gesture.srcEvent.preventDefault();
                  startCoord = null;
                  primaryScrollAxis = null;
                } else if (!startCoord) {
                  startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                }
              }
              function onDragX(e) {
                if (!sideMenuCtrl.isDraggableTarget(e))
                  return;
                if (getPrimaryScrollAxis(e) == 'x') {
                  sideMenuCtrl._handleDrag(e);
                  e.gesture.srcEvent.preventDefault();
                }
              }
              function onDragY(e) {
                if (getPrimaryScrollAxis(e) == 'x') {
                  e.gesture.srcEvent.preventDefault();
                }
              }
              function onDragRelease(e) {
                sideMenuCtrl._endDrag(e);
                startCoord = null;
                primaryScrollAxis = null;
              }
              function getPrimaryScrollAxis(gestureEvt) {
                if (primaryScrollAxis) {
                  return primaryScrollAxis;
                }
                if (gestureEvt && gestureEvt.gesture) {
                  if (!startCoord) {
                    startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                  } else {
                    var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                    var xDistance = Math.abs(endCoord.x - startCoord.x);
                    var yDistance = Math.abs(endCoord.y - startCoord.y);
                    var scrollAxis = (xDistance < yDistance ? 'y' : 'x');
                    if (Math.max(xDistance, yDistance) > 30) {
                      primaryScrollAxis = scrollAxis;
                    }
                    return scrollAxis;
                  }
                }
                return 'y';
              }
              var content = {
                element: element[0],
                onDrag: function() {},
                endDrag: function() {},
                getTranslateX: function() {
                  return $scope.sideMenuContentTranslateX || 0;
                },
                setTranslateX: ionic.animationFrameThrottle(function(amount) {
                  var xTransform = content.offsetX + amount;
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + xTransform + 'px,0,0)';
                  $timeout(function() {
                    $scope.sideMenuContentTranslateX = amount;
                  });
                }),
                setMarginLeft: ionic.animationFrameThrottle(function(amount) {
                  if (amount) {
                    amount = parseInt(amount, 10);
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amount + 'px,0,0)';
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amount;
                  } else {
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                }),
                setMarginRight: ionic.animationFrameThrottle(function(amount) {
                  if (amount) {
                    amount = parseInt(amount, 10);
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amount;
                  } else {
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                }),
                enableAnimation: function() {
                  $scope.animationEnabled = true;
                  $element[0].classList.add('menu-animated');
                },
                disableAnimation: function() {
                  $scope.animationEnabled = false;
                  $element[0].classList.remove('menu-animated');
                },
                offsetX: 0
              };
              sideMenuCtrl.setContent(content);
              var gestureOpts = {stop_browser_behavior: false};
              if (ionic.DomUtil.getParentOrSelfWithClass($element[0], 'overflow-scroll')) {
                gestureOpts.prevent_default_directions = ['left', 'right'];
              }
              var contentTapGesture = $ionicGesture.on('tap', onContentTap, $element, gestureOpts);
              var dragRightGesture = $ionicGesture.on('dragright', onDragX, $element, gestureOpts);
              var dragLeftGesture = $ionicGesture.on('dragleft', onDragX, $element, gestureOpts);
              var dragUpGesture = $ionicGesture.on('dragup', onDragY, $element, gestureOpts);
              var dragDownGesture = $ionicGesture.on('dragdown', onDragY, $element, gestureOpts);
              var releaseGesture = $ionicGesture.on('release', onDragRelease, $element, gestureOpts);
              $scope.$on('$destroy', function() {
                if (content) {
                  content.element = null;
                  content = null;
                }
                $ionicGesture.off(dragLeftGesture, 'dragleft', onDragX);
                $ionicGesture.off(dragRightGesture, 'dragright', onDragX);
                $ionicGesture.off(dragUpGesture, 'dragup', onDragY);
                $ionicGesture.off(dragDownGesture, 'dragdown', onDragY);
                $ionicGesture.off(releaseGesture, 'release', onDragRelease);
                $ionicGesture.off(contentTapGesture, 'tap', onContentTap);
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSideMenus', ['$ionicBody', function($ionicBody) {
        return {
          restrict: 'ECA',
          controller: '$ionicSideMenus',
          compile: function(element, attr) {
            attr.$set('class', (attr['class'] || '') + ' view');
            return {pre: prelink};
            function prelink($scope, $element, $attrs, ctrl) {
              ctrl.enableMenuWithBackViews($scope.$eval($attrs.enableMenuWithBackViews));
              $scope.$on('$ionicExposeAside', function(evt, isAsideExposed) {
                if (!$scope.$exposeAside)
                  $scope.$exposeAside = {};
                $scope.$exposeAside.active = isAsideExposed;
                $ionicBody.enableClass(isAsideExposed, 'aside-open');
              });
              $scope.$on('$ionicView.beforeEnter', function(ev, d) {
                if (d.historyId) {
                  $scope.$activeHistoryId = d.historyId;
                }
              });
              $scope.$on('$destroy', function() {
                $ionicBody.removeClass('menu-open', 'aside-open');
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSlideBox', ['$timeout', '$compile', '$ionicSlideBoxDelegate', '$ionicHistory', '$ionicScrollDelegate', function($timeout, $compile, $ionicSlideBoxDelegate, $ionicHistory, $ionicScrollDelegate) {
        return {
          restrict: 'E',
          replace: true,
          transclude: true,
          scope: {
            autoPlay: '=',
            doesContinue: '@',
            slideInterval: '@',
            showPager: '@',
            pagerClick: '&',
            disableScroll: '@',
            onSlideChanged: '&',
            delegateHandle: '@',
            activeSlide: '=?'
          },
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var _this = this;
            var continuous = $scope.$eval($scope.doesContinue) === true;
            var shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : false;
            var slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4000 : 0;
            var slider = new ionic.views.Slider({
              el: $element[0],
              auto: slideInterval,
              continuous: continuous,
              startSlide: $scope.activeSlide,
              slidesChanged: function() {
                $scope.currentSlide = slider.currentIndex();
                $timeout(function() {});
              },
              callback: function(slideIndex) {
                $scope.currentSlide = slideIndex;
                $scope.onSlideChanged({
                  index: $scope.currentSlide,
                  $index: $scope.currentSlide
                });
                $scope.$parent.$broadcast('slideBox.slideChanged', slideIndex);
                $scope.activeSlide = slideIndex;
                $timeout(function() {});
              },
              onDrag: function() {
                freezeAllScrolls(true);
              },
              onDragEnd: function() {
                freezeAllScrolls(false);
              }
            });
            function freezeAllScrolls(shouldFreeze) {
              if (shouldFreeze && !_this.isScrollFreeze) {
                $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);
              } else if (!shouldFreeze && _this.isScrollFreeze) {
                $ionicScrollDelegate.freezeAllScrolls(false);
              }
              _this.isScrollFreeze = shouldFreeze;
            }
            slider.enableSlide($scope.$eval($attrs.disableScroll) !== true);
            $scope.$watch('activeSlide', function(nv) {
              if (isDefined(nv)) {
                slider.slide(nv);
              }
            });
            $scope.$on('slideBox.nextSlide', function() {
              slider.next();
            });
            $scope.$on('slideBox.prevSlide', function() {
              slider.prev();
            });
            $scope.$on('slideBox.setSlide', function(e, index) {
              slider.slide(index);
            });
            this.__slider = slider;
            var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(slider, $scope.delegateHandle, function() {
              return $ionicHistory.isActiveScope($scope);
            });
            $scope.$on('$destroy', function() {
              deregisterInstance();
              slider.kill();
            });
            this.slidesCount = function() {
              return slider.slidesCount();
            };
            this.onPagerClick = function(index) {
              void 0;
              $scope.pagerClick({index: index});
            };
            $timeout(function() {
              slider.load();
            });
          }],
          template: '<div class="slider">' + '<div class="slider-slides" ng-transclude>' + '</div>' + '</div>',
          link: function($scope, $element, $attr) {
            if (!isDefined($attr.showPager)) {
              $scope.showPager = true;
              getPager().toggleClass('hide', !true);
            }
            $attr.$observe('showPager', function(show) {
              if (show === undefined)
                return;
              show = $scope.$eval(show);
              getPager().toggleClass('hide', !show);
            });
            var pager;
            function getPager() {
              if (!pager) {
                var childScope = $scope.$new();
                pager = jqLite('<ion-pager></ion-pager>');
                $element.append(pager);
                pager = $compile(pager)(childScope);
              }
              return pager;
            }
          }
        };
      }]).directive('ionSlide', function() {
        return {
          restrict: 'E',
          require: '^ionSlideBox',
          compile: function(element) {
            element.addClass('slider-slide');
          }
        };
      }).directive('ionPager', function() {
        return {
          restrict: 'E',
          replace: true,
          require: '^ionSlideBox',
          template: '<div class="slider-pager"><span class="slider-pager-page" ng-repeat="slide in numSlides() track by $index" ng-class="{active: $index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
          link: function($scope, $element, $attr, slideBox) {
            var selectPage = function(index) {
              var children = $element[0].children;
              var length = children.length;
              for (var i = 0; i < length; i++) {
                if (i == index) {
                  children[i].classList.add('active');
                } else {
                  children[i].classList.remove('active');
                }
              }
            };
            $scope.pagerClick = function(index) {
              slideBox.onPagerClick(index);
            };
            $scope.numSlides = function() {
              return new Array(slideBox.slidesCount());
            };
            $scope.$watch('currentSlide', function(v) {
              selectPage(v);
            });
          }
        };
      });
      IonicModule.directive('ionSpinner', function() {
        return {
          restrict: 'E',
          controller: '$ionicSpinner',
          link: function($scope, $element, $attrs, ctrl) {
            var spinnerName = ctrl.init();
            $element.addClass('spinner spinner-' + spinnerName);
          }
        };
      });
      IonicModule.directive('ionTab', ['$compile', '$ionicConfig', '$ionicBind', '$ionicViewSwitcher', function($compile, $ionicConfig, $ionicBind, $ionicViewSwitcher) {
        function attrStr(k, v) {
          return isDefined(v) ? ' ' + k + '="' + v + '"' : '';
        }
        return {
          restrict: 'E',
          require: ['^ionTabs', 'ionTab'],
          controller: '$ionicTab',
          scope: true,
          compile: function(element, attr) {
            var tabNavTemplate = '<ion-tab-nav' + attrStr('ng-click', attr.ngClick) + attrStr('title', attr.title) + attrStr('icon', attr.icon) + attrStr('icon-on', attr.iconOn) + attrStr('icon-off', attr.iconOff) + attrStr('badge', attr.badge) + attrStr('badge-style', attr.badgeStyle) + attrStr('hidden', attr.hidden) + attrStr('disabled', attr.disabled) + attrStr('class', attr['class']) + '></ion-tab-nav>';
            var tabContentEle = document.createElement('div');
            for (var x = 0; x < element[0].children.length; x++) {
              tabContentEle.appendChild(element[0].children[x].cloneNode(true));
            }
            var childElementCount = tabContentEle.childElementCount;
            element.empty();
            var navViewName,
                isNavView;
            if (childElementCount) {
              if (tabContentEle.children[0].tagName === 'ION-NAV-VIEW') {
                navViewName = tabContentEle.children[0].getAttribute('name');
                tabContentEle.children[0].classList.add('view-container');
                isNavView = true;
              }
              if (childElementCount === 1) {
                tabContentEle = tabContentEle.children[0];
              }
              if (!isNavView)
                tabContentEle.classList.add('pane');
              tabContentEle.classList.add('tab-content');
            }
            return function link($scope, $element, $attr, ctrls) {
              var childScope;
              var childElement;
              var tabsCtrl = ctrls[0];
              var tabCtrl = ctrls[1];
              var isTabContentAttached = false;
              $scope.$tabSelected = false;
              $ionicBind($scope, $attr, {
                onSelect: '&',
                onDeselect: '&',
                title: '@',
                uiSref: '@',
                href: '@'
              });
              tabsCtrl.add($scope);
              $scope.$on('$destroy', function() {
                if (!$scope.$tabsDestroy) {
                  tabsCtrl.remove($scope);
                }
                tabNavElement.isolateScope().$destroy();
                tabNavElement.remove();
                tabNavElement = tabContentEle = childElement = null;
              });
              $element[0].removeAttribute('title');
              if (navViewName) {
                tabCtrl.navViewName = $scope.navViewName = navViewName;
              }
              $scope.$on('$stateChangeSuccess', selectIfMatchesState);
              selectIfMatchesState();
              function selectIfMatchesState() {
                if (tabCtrl.tabMatchesState()) {
                  tabsCtrl.select($scope, false);
                }
              }
              var tabNavElement = jqLite(tabNavTemplate);
              tabNavElement.data('$ionTabsController', tabsCtrl);
              tabNavElement.data('$ionTabController', tabCtrl);
              tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope));
              function tabSelected(isSelected) {
                if (isSelected && childElementCount) {
                  if (!isTabContentAttached) {
                    childScope = $scope.$new();
                    childElement = jqLite(tabContentEle);
                    $ionicViewSwitcher.viewEleIsActive(childElement, true);
                    tabsCtrl.$element.append(childElement);
                    $compile(childElement)(childScope);
                    isTabContentAttached = true;
                  }
                  $ionicViewSwitcher.viewEleIsActive(childElement, true);
                } else if (isTabContentAttached && childElement) {
                  if ($ionicConfig.views.maxCache() > 0) {
                    $ionicViewSwitcher.viewEleIsActive(childElement, false);
                  } else {
                    destroyTab();
                  }
                }
              }
              function destroyTab() {
                childScope && childScope.$destroy();
                isTabContentAttached && childElement && childElement.remove();
                tabContentEle.innerHTML = '';
                isTabContentAttached = childScope = childElement = null;
              }
              $scope.$watch('$tabSelected', tabSelected);
              $scope.$on('$ionicView.afterEnter', function() {
                $ionicViewSwitcher.viewEleIsActive(childElement, $scope.$tabSelected);
              });
              $scope.$on('$ionicView.clearCache', function() {
                if (!$scope.$tabSelected) {
                  destroyTab();
                }
              });
            };
          }
        };
      }]);
      IonicModule.directive('ionTabNav', [function() {
        return {
          restrict: 'E',
          replace: true,
          require: ['^ionTabs', '^ionTab'],
          template: '<a ng-class="{\'tab-item-active\': isTabActive(), \'has-badge\':badge, \'tab-hidden\':isHidden()}" ' + ' ng-disabled="disabled()" class="tab-item">' + '<span class="badge {{badgeStyle}}" ng-if="badge">{{badge}}</span>' + '<i class="icon {{getIconOn()}}" ng-if="getIconOn() && isTabActive()"></i>' + '<i class="icon {{getIconOff()}}" ng-if="getIconOff() && !isTabActive()"></i>' + '<span class="tab-title" ng-bind-html="title"></span>' + '</a>',
          scope: {
            title: '@',
            icon: '@',
            iconOn: '@',
            iconOff: '@',
            badge: '=',
            hidden: '@',
            disabled: '&',
            badgeStyle: '@',
            'class': '@'
          },
          link: function($scope, $element, $attrs, ctrls) {
            var tabsCtrl = ctrls[0],
                tabCtrl = ctrls[1];
            $element[0].removeAttribute('title');
            $scope.selectTab = function(e) {
              e.preventDefault();
              tabsCtrl.select(tabCtrl.$scope, true);
            };
            if (!$attrs.ngClick) {
              $element.on('click', function(event) {
                $scope.$apply(function() {
                  $scope.selectTab(event);
                });
              });
            }
            $scope.isHidden = function() {
              if ($attrs.hidden === 'true' || $attrs.hidden === true)
                return true;
              return false;
            };
            $scope.getIconOn = function() {
              return $scope.iconOn || $scope.icon;
            };
            $scope.getIconOff = function() {
              return $scope.iconOff || $scope.icon;
            };
            $scope.isTabActive = function() {
              return tabsCtrl.selectedTab() === tabCtrl.$scope;
            };
          }
        };
      }]);
      IonicModule.directive('ionTabs', ['$ionicTabsDelegate', '$ionicConfig', function($ionicTabsDelegate, $ionicConfig) {
        return {
          restrict: 'E',
          scope: true,
          controller: '$ionicTabs',
          compile: function(tElement) {
            var innerElement = jqLite('<div class="tab-nav tabs">');
            innerElement.append(tElement.contents());
            tElement.append(innerElement).addClass('tabs-' + $ionicConfig.tabs.position() + ' tabs-' + $ionicConfig.tabs.style());
            return {
              pre: prelink,
              post: postLink
            };
            function prelink($scope, $element, $attr, tabsCtrl) {
              var deregisterInstance = $ionicTabsDelegate._registerInstance(tabsCtrl, $attr.delegateHandle, tabsCtrl.hasActiveScope);
              tabsCtrl.$scope = $scope;
              tabsCtrl.$element = $element;
              tabsCtrl.$tabsElement = jqLite($element[0].querySelector('.tabs'));
              $scope.$watch(function() {
                return $element[0].className;
              }, function(value) {
                var isTabsTop = value.indexOf('tabs-top') !== -1;
                var isHidden = value.indexOf('tabs-item-hide') !== -1;
                $scope.$hasTabs = !isTabsTop && !isHidden;
                $scope.$hasTabsTop = isTabsTop && !isHidden;
                $scope.$emit('$ionicTabs.top', $scope.$hasTabsTop);
              });
              function emitLifecycleEvent(ev, data) {
                ev.stopPropagation();
                var previousSelectedTab = tabsCtrl.previousSelectedTab();
                if (previousSelectedTab) {
                  previousSelectedTab.$broadcast(ev.name.replace('NavView', 'Tabs'), data);
                }
              }
              $scope.$on('$ionicNavView.beforeLeave', emitLifecycleEvent);
              $scope.$on('$ionicNavView.afterLeave', emitLifecycleEvent);
              $scope.$on('$ionicNavView.leave', emitLifecycleEvent);
              $scope.$on('$destroy', function() {
                $scope.$tabsDestroy = true;
                deregisterInstance();
                tabsCtrl.$tabsElement = tabsCtrl.$element = tabsCtrl.$scope = innerElement = null;
                delete $scope.$hasTabs;
                delete $scope.$hasTabsTop;
              });
            }
            function postLink($scope, $element, $attr, tabsCtrl) {
              if (!tabsCtrl.selectedTab()) {
                tabsCtrl.select(0);
              }
            }
          }
        };
      }]);
      IonicModule.directive('ionToggle', ['$timeout', '$ionicConfig', function($timeout, $ionicConfig) {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<div class="item item-toggle">' + '<div ng-transclude></div>' + '<label class="toggle">' + '<input type="checkbox">' + '<div class="track">' + '<div class="handle"></div>' + '</div>' + '</label>' + '</div>',
          compile: function(element, attr) {
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-checked': attr.ngChecked,
              'ng-disabled': attr.ngDisabled,
              'ng-true-value': attr.ngTrueValue,
              'ng-false-value': attr.ngFalseValue,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            if (attr.toggleClass) {
              element[0].getElementsByTagName('label')[0].classList.add(attr.toggleClass);
            }
            element.addClass('toggle-' + $ionicConfig.form.toggle());
            return function($scope, $element) {
              var el = $element[0].getElementsByTagName('label')[0];
              var checkbox = el.children[0];
              var track = el.children[1];
              var handle = track.children[0];
              var ngModelController = jqLite(checkbox).controller('ngModel');
              $scope.toggle = new ionic.views.Toggle({
                el: el,
                track: track,
                checkbox: checkbox,
                handle: handle,
                onChange: function() {
                  if (ngModelController) {
                    ngModelController.$setViewValue(checkbox.checked);
                    $scope.$apply();
                  }
                }
              });
              $scope.$on('$destroy', function() {
                $scope.toggle.destroy();
              });
            };
          }
        };
      }]);
      IonicModule.directive('ionView', function() {
        return {
          restrict: 'EA',
          priority: 1000,
          controller: '$ionicView',
          compile: function(tElement) {
            tElement.addClass('pane');
            tElement[0].removeAttribute('title');
            return function link($scope, $element, $attrs, viewCtrl) {
              viewCtrl.init();
            };
          }
        };
      });
    })();
  })();
  return _retrieveGlobal();
});

System.register('libraries/ionic/ionic.js', ['github:angular/bower-angular@1.4.7', 'libraries/ionic/ionic-angular-library.js'], function (_export) {

  // custom fork of ionic v1.1.0 with workaround for right side menu toggle
  // when exposeAsideWhen is enabled
  // TODO: ionic v1.2.x should hava a better fix, migrate when available
  'use strict';

  var angular;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_librariesIonicIonicAngularLibraryJs) {}],
    execute: function () {
      _export('default', angular.module('toc.libraries.ionic', ['ionic']));
    }
  };
});

System.registerDynamic("npm:moment@2.10.6/moment", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
  }(this, function() {
    'use strict';
    var hookCallback;
    function utils_hooks__hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return Object.prototype.toString.call(input) === '[object Array]';
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }
    function map(arr, fn) {
      var res = [],
          i;
      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function create_utc__createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    function valid__isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
        if (m._strict) {
          m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }
      }
      return m._isValid;
    }
    function valid__createInvalid(flags) {
      var m = create_utc__createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = utils_hooks__hooks.momentProperties = [];
    function copyConfig(to, from) {
      var i,
          prop,
          val;
      if (typeof from._isAMomentObject !== 'undefined') {
        to._isAMomentObject = from._isAMomentObject;
      }
      if (typeof from._i !== 'undefined') {
        to._i = from._i;
      }
      if (typeof from._f !== 'undefined') {
        to._f = from._f;
      }
      if (typeof from._l !== 'undefined') {
        to._l = from._l;
      }
      if (typeof from._strict !== 'undefined') {
        to._strict = from._strict;
      }
      if (typeof from._tzm !== 'undefined') {
        to._tzm = from._tzm;
      }
      if (typeof from._isUTC !== 'undefined') {
        to._isUTC = from._isUTC;
      }
      if (typeof from._offset !== 'undefined') {
        to._offset = from._offset;
      }
      if (typeof from._pf !== 'undefined') {
        to._pf = getParsingFlags(from);
      }
      if (typeof from._locale !== 'undefined') {
        to._locale = from._locale;
      }
      if (momentProperties.length > 0) {
        for (i in momentProperties) {
          prop = momentProperties[i];
          val = from[prop];
          if (typeof val !== 'undefined') {
            to[prop] = val;
          }
        }
      }
      return to;
    }
    var updateInProgress = false;
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (updateInProgress === false) {
        updateInProgress = true;
        utils_hooks__hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number);
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;
      for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function Locale() {}
    var locales = {};
    var globalLocale;
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    }
    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));
          if (locale) {
            return locale;
          }
          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return null;
    }
    function loadLocale(name) {
      var oldLocale = null;
      if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          req('./locale/' + name);
          locale_locales__getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }
      return locales[name];
    }
    function locale_locales__getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (typeof values === 'undefined') {
          data = locale_locales__getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, values) {
      if (values !== null) {
        values.abbr = name;
        locales[name] = locales[name] || new Locale();
        locales[name].set(values);
        locale_locales__getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function locale_locales__getLocale(key) {
      var locale;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale = loadLocale(key);
        if (locale) {
          return locale;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          get_set__set(this, unit, value);
          utils_hooks__hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get_set__get(this, unit);
        }
      };
    }
    function get_set__get(mom, unit) {
      return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }
    function get_set__set(mom, unit, value) {
      return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
    function getSet(units, value) {
      var unit;
      if (typeof units === 'object') {
        for (unit in units) {
          this.set(unit, units[unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (typeof this[units] === 'function') {
          return this[units](value);
        }
      }
      return this;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;
      if (typeof callback === 'string') {
        func = function() {
          return this[callback]();
        };
      }
      if (token) {
        formatTokenFunctions[token] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal) {
        formatTokenFunctions[ordinal] = function() {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }
      return input.replace(/\\/g, '');
    }
    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;
      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = '';
        for (i = 0; i < length; i++) {
          output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
        }
        return output;
      };
    }
    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format;
    }
    var match1 = /\d/;
    var match2 = /\d\d/;
    var match3 = /\d{3}/;
    var match4 = /\d{4}/;
    var match6 = /[+-]?\d{6}/;
    var match1to2 = /\d\d?/;
    var match1to3 = /\d{1,3}/;
    var match1to4 = /\d{1,4}/;
    var match1to6 = /[+-]?\d{1,6}/;
    var matchUnsigned = /\d+/;
    var matchSigned = /[+-]?\d+/;
    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    var regexes = {};
    function isFunction(sth) {
      return typeof sth === 'function' && Object.prototype.toString.call(sth) === '[object Function]';
    }
    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function(isStrict) {
        return (isStrict && strictRegex) ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }
      return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    var tokens = {};
    function addParseToken(token, callback) {
      var i,
          func = callback;
      if (typeof token === 'string') {
        token = [token];
      }
      if (typeof callback === 'number') {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }
    function addWeekParseToken(token, callback) {
      addParseToken(token, function(input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }
    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    function daysInMonth(year, month) {
      return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    addFormatToken('M', ['MM', 2], 'Mo', function() {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function(format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function(format) {
      return this.localeData().months(this, format);
    });
    addUnitAlias('month', 'M');
    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', matchWord);
    addRegexToken('MMMM', matchWord);
    addParseToken(['M', 'MM'], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths(m) {
      return this._months[m.month()];
    }
    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort(m) {
      return this._monthsShort[m.month()];
    }
    function localeMonthsParse(monthName, format, strict) {
      var i,
          mom,
          regex;
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = create_utc__createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      var dayOfMonth;
      if (typeof value === 'string') {
        value = mom.localeData().monthsParse(value);
        if (typeof value !== 'number') {
          return mom;
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        utils_hooks__hooks.updateOffset(this, true);
        return this;
      } else {
        return get_set__get(this, 'Month');
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function checkOverflow(m) {
      var overflow;
      var a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    function warn(msg) {
      if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (firstTime) {
          warn(msg + '\n' + (new Error()).stack);
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    utils_hooks__hooks.suppressDeprecationWarnings = false;
    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/], ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/], ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/], ['GGGG-[W]WW', /\d{4}-W\d{2}/], ['YYYY-DDD', /\d{4}-\d{3}/]];
    var isoTimes = [['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/], ['HH:mm', /(T| )\d\d:\d\d/], ['HH', /(T| )\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = from_string__isoRegex.exec(string);
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(string)) {
            config._f = isoDates[i][0];
            break;
          }
        }
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(string)) {
            config._f += (match[6] || ' ') + isoTimes[i][0];
            break;
          }
        }
        if (string.match(matchOffset)) {
          config._f += 'Z';
        }
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
        utils_hooks__hooks.createFromInputFallback(config);
      }
    }
    utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'https://github.com/moment/moment/issues/1407 for more info.', function(config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    });
    function createDate(y, m, d, h, M, s, ms) {
      var date = new Date(y, m, d, h, M, s, ms);
      if (y < 1970) {
        date.setFullYear(y);
      }
      return date;
    }
    function createUTCDate(y) {
      var date = new Date(Date.UTC.apply(null, arguments));
      if (y < 1970) {
        date.setUTCFullYear(y);
      }
      return date;
    }
    addFormatToken(0, ['YY', 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
    addUnitAlias('year', 'y');
    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function(input, array) {
      array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function(input, array) {
      array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
      return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }
    utils_hooks__hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };
    var getSetYear = makeGetSet('FullYear', false);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');
    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    });
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
      var end = firstDayOfWeekOfYear - firstDayOfWeek,
          daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
          adjustedMoment;
      if (daysToDayOfWeek > end) {
        daysToDayOfWeek -= 7;
      }
      if (daysToDayOfWeek < end - 7) {
        daysToDayOfWeek += 7;
      }
      adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
      return {
        week: Math.ceil(adjustedMoment.dayOfYear() / 7),
        year: adjustedMoment.year()
      };
    }
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    }
    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
    addUnitAlias('dayOfYear', 'DDD');
    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
      var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear,
          janX = createUTCDate(year, 0, 1 + week1Jan),
          d = janX.getUTCDay(),
          dayOfYear;
      if (d < firstDayOfWeek) {
        d += 7;
      }
      weekday = weekday != null ? 1 * weekday : firstDayOfWeek;
      dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;
      return {
        year: dayOfYear > 0 ? year : year - 1,
        dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
      };
    }
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var now = new Date();
      if (config._useUTC) {
        return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
      }
      return [now.getFullYear(), now.getMonth(), now.getDate()];
    }
    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse)) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w,
          weekYear,
          week,
          weekday,
          dow,
          doy,
          temp;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
        week = defaults(w.w, 1);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < dow) {
            ++week;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
        } else {
          weekday = dow;
        }
      }
      temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
    utils_hooks__hooks.ISO_8601 = function() {};
    function configFromStringAndFormat(config) {
      if (config._f === utils_hooks__hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }
          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }
      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;
      if (meridiem == null) {
        return hour;
      }
      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig,
          bestMoment,
          scoreToBeat,
          i,
          currentScore;
      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }
      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (!valid__isValid(tempConfig)) {
          continue;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i);
      config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, 'd');
        res._nextDay = undefined;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || locale_locales__getLocale(config._l);
      if (input === null || (format === undefined && input === '')) {
        return valid__createInvalid({nullInput: true});
      }
      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else if (isDate(input)) {
        config._d = input;
      } else {
        configFromInput(config);
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (input === undefined) {
        config._d = new Date();
      } else if (isDate(input)) {
        config._d = new Date(+input);
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (typeof(input) === 'object') {
        configFromObject(config);
      } else if (typeof(input) === 'number') {
        config._d = new Date(input);
      } else {
        utils_hooks__hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};
      if (typeof(locale) === 'boolean') {
        strict = locale;
        locale = undefined;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }
    function local__createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate('moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548', function() {
      var other = local__createLocal.apply(null, arguments);
      return other < this ? this : other;
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548', function() {
      var other = local__createLocal.apply(null, arguments);
      return other > this ? this : other;
    });
    function pickBy(fn, moments) {
      var res,
          i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return local__createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
      this._days = +days + weeks * 7;
      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = locale_locales__getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function offset(token, separator) {
      addFormatToken(token, 0, 0, function() {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
      });
    }
    offset('Z', ':');
    offset('ZZ', '');
    addRegexToken('Z', matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(string) {
      var matches = ((string || '').match(matchOffset) || []);
      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return parts[0] === '+' ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
      var res,
          diff;
      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
        res._d.setTime(+res._d + diff);
        utils_hooks__hooks.updateOffset(res, false);
        return res;
      } else {
        return local__createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    utils_hooks__hooks.updateOffset = function() {};
    function getSetOffset(input, keepLocalTime) {
      var offset = this._offset || 0,
          localAdjust;
      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(input);
        }
        if (Math.abs(input) < 16) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }
        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            utils_hooks__hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm) {
        this.utcOffset(this._tzm);
      } else if (typeof this._i === 'string') {
        this.utcOffset(offsetFromString(this._i));
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      input = input ? local__createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
    }
    function isDaylightSavingTimeShifted() {
      if (typeof this._isDSTShifted !== 'undefined') {
        return this._isDSTShifted;
      }
      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return !this._isUTC;
    }
    function isUtcOffset() {
      return this._isUTC;
    }
    function isUtc() {
      return this._isUTC && this._offset === 0;
    }
    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
    function create__createDuration(input, key) {
      var duration = input,
          match = null,
          sign,
          ret,
          diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (typeof input === 'number') {
        duration = {};
        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(match[MILLISECOND]) * sign
        };
      } else if (!!(match = create__isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          d: parseIso(match[4], sign),
          h: parseIso(match[5], sign),
          m: parseIso(match[6], sign),
          s: parseIso(match[7], sign),
          w: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }
      return ret;
    }
    create__createDuration.fn = Duration.prototype;
    function parseIso(inp, sign) {
      var res = inp && parseFloat(inp.replace(',', '.'));
      return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
      var res = {
        milliseconds: 0,
        months: 0
      };
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur,
            tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
          tmp = val;
          val = period;
          period = tmp;
        }
        val = typeof val === 'string' ? +val : val;
        dur = create__createDuration(val, period);
        add_subtract__addSubtract(this, dur, direction);
        return this;
      };
    }
    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = duration._days,
          months = duration._months;
      updateOffset = updateOffset == null ? true : updateOffset;
      if (milliseconds) {
        mom._d.setTime(+mom._d + milliseconds * isAdding);
      }
      if (days) {
        get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
      }
      if (months) {
        setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
      }
      if (updateOffset) {
        utils_hooks__hooks.updateOffset(mom, days || months);
      }
    }
    var add_subtract__add = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');
    function moment_calendar__calendar(time, formats) {
      var now = time || local__createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          diff = this.diff(sod, 'days', true),
          format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
      return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var inputMs;
      units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
      if (units === 'millisecond') {
        input = isMoment(input) ? input : local__createLocal(input);
        return +this > +input;
      } else {
        inputMs = isMoment(input) ? +input : +local__createLocal(input);
        return inputMs < +this.clone().startOf(units);
      }
    }
    function isBefore(input, units) {
      var inputMs;
      units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
      if (units === 'millisecond') {
        input = isMoment(input) ? input : local__createLocal(input);
        return +this < +input;
      } else {
        inputMs = isMoment(input) ? +input : +local__createLocal(input);
        return +this.clone().endOf(units) < inputMs;
      }
    }
    function isBetween(from, to, units) {
      return this.isAfter(from, units) && this.isBefore(to, units);
    }
    function isSame(input, units) {
      var inputMs;
      units = normalizeUnits(units || 'millisecond');
      if (units === 'millisecond') {
        input = isMoment(input) ? input : local__createLocal(input);
        return +this === +input;
      } else {
        inputMs = +local__createLocal(input);
        return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
      }
    }
    function diff(input, units, asFloat) {
      var that = cloneWithOffset(input, this),
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
          delta,
          output;
      units = normalizeUnits(units);
      if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
          output = output / 3;
        } else if (units === 'year') {
          output = output / 12;
        }
      } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : units === 'minute' ? delta / 6e4 : units === 'hour' ? delta / 36e5 : units === 'day' ? (delta - zoneDelta) / 864e5 : units === 'week' ? (delta - zoneDelta) / 6048e5 : delta;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
          anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust);
    }
    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }
    function moment_format__toISOString() {
      var m = this.clone().utc();
      if (0 < m.year() && m.year() <= 9999) {
        if ('function' === typeof Date.prototype.toISOString) {
          return this.toDate().toISOString();
        } else {
          return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
      } else {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      }
    }
    function format(inputString) {
      var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      return create__createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function fromNow(withoutSuffix) {
      return this.from(local__createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      return create__createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function toNow(withoutSuffix) {
      return this.to(local__createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = locale_locales__getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });
    function localeData() {
      return this._locale;
    }
    function startOf(units) {
      units = normalizeUnits(units);
      switch (units) {
        case 'year':
          this.month(0);
        case 'quarter':
        case 'month':
          this.date(1);
        case 'week':
        case 'isoWeek':
        case 'day':
          this.hours(0);
        case 'hour':
          this.minutes(0);
        case 'minute':
          this.seconds(0);
        case 'second':
          this.milliseconds(0);
      }
      if (units === 'week') {
        this.weekday(0);
      }
      if (units === 'isoWeek') {
        this.isoWeekday(1);
      }
      if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
      }
      return this;
    }
    function endOf(units) {
      units = normalizeUnits(units);
      if (units === undefined || units === 'millisecond') {
        return this;
      }
      return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }
    function to_type__valueOf() {
      return +this._d - ((this._offset || 0) * 60000);
    }
    function unix() {
      return Math.floor(+this / 1000);
    }
    function toDate() {
      return this._offset ? new Date(+this) : this._d;
    }
    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function moment_valid__isValid() {
      return valid__isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    addFormatToken(0, ['gg', 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }
    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');
    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
      week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function weeksInYear(year, dow, doy) {
      return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }
    function getSetWeekYear(input) {
      var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
      return input == null ? year : this.add((input - year), 'y');
    }
    function getSetISOWeekYear(input) {
      var year = weekOfYear(this, 1, 4).year;
      return input == null ? year : this.add((input - year), 'y');
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    addFormatToken('Q', 0, 0, 'quarter');
    addUnitAlias('quarter', 'Q');
    addRegexToken('Q', match1);
    addParseToken('Q', function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken('D', ['DD', 2], 'Do', 'date');
    addUnitAlias('date', 'D');
    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function(isStrict, locale) {
      return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet('Date', true);
    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function(format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function(format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function(format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');
    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');
    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', matchWord);
    addRegexToken('ddd', matchWord);
    addRegexToken('dddd', matchWord);
    addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config) {
      var weekday = config._locale.weekdaysParse(input);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
      week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale.weekdaysParse(input);
      if (typeof input === 'number') {
        return input;
      }
      return null;
    }
    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays(m) {
      return this._weekdays[m.day()];
    }
    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort(m) {
      return this._weekdaysShort[m.day()];
    }
    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin(m) {
      return this._weekdaysMin[m.day()];
    }
    function localeWeekdaysParse(weekdayName) {
      var i,
          mom,
          regex;
      this._weekdaysParse = this._weekdaysParse || [];
      for (i = 0; i < 7; i++) {
        if (!this._weekdaysParse[i]) {
          mom = local__createLocal([2000, 1]).day(i);
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        if (this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }
    function getSetISODayOfWeek(input) {
      return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }
    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function() {
      return this.hours() % 12 || 12;
    });
    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }
    meridiem('a', true);
    meridiem('A', false);
    addUnitAlias('hour', 'h');
    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }
    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    function localeIsPM(input) {
      return ((input + '').toLowerCase().charAt(0) === 'p');
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    }
    var getSetHour = makeGetSet('Hours', true);
    addFormatToken('m', ['mm', 2], 0, 'minute');
    addUnitAlias('minute', 'm');
    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);
    var getSetMinute = makeGetSet('Minutes', false);
    addFormatToken('s', ['ss', 2], 0, 'second');
    addUnitAlias('second', 's');
    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);
    var getSetSecond = makeGetSet('Seconds', false);
    addFormatToken('S', 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function() {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function() {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
      return this.millisecond() * 1000000;
    });
    addUnitAlias('millisecond', 'ms');
    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }
    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    }
    var getSetMillisecond = makeGetSet('Milliseconds', false);
    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');
    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }
    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }
    var momentPrototype__proto = Moment.prototype;
    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = getSet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = getSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toObject = toObject;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = moment_format__toISOString;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;
    momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
    var momentPrototype = momentPrototype__proto;
    function moment__createUnix(input) {
      return local__createLocal(input * 1000);
    }
    function moment__createInZone() {
      return local__createLocal.apply(null, arguments).parseZone();
    }
    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };
    function locale_calendar__calendar(key, mom, now) {
      var output = this._calendar[key];
      return typeof output === 'function' ? output.call(mom, now) : output;
    }
    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };
    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format || !formatUpper) {
        return format;
      }
      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = 'Invalid date';
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }
    function preParsePostFormat(string) {
      return string;
    }
    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };
    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return (typeof output === 'function') ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }
    function locale_set__set(config) {
      var prop,
          i;
      for (i in config) {
        prop = config[i];
        if (typeof prop === 'function') {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }
      this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }
    var prototype__proto = Locale.prototype;
    prototype__proto._calendar = defaultCalendar;
    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto._invalidDate = defaultInvalidDate;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto._ordinal = defaultOrdinal;
    prototype__proto.ordinal = ordinal;
    prototype__proto._ordinalParse = defaultOrdinalParse;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto._relativeTime = defaultRelativeTime;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;
    prototype__proto.months = localeMonths;
    prototype__proto._months = defaultLocaleMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto._weekdays = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;
    function lists__get(format, index, field, setter) {
      var locale = locale_locales__getLocale();
      var utc = create_utc__createUTC().set(setter, index);
      return locale[field](utc, format);
    }
    function list(format, index, field, count, setter) {
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
      if (index != null) {
        return lists__get(format, index, field, setter);
      }
      var i;
      var out = [];
      for (i = 0; i < count; i++) {
        out[i] = lists__get(format, i, field, setter);
      }
      return out;
    }
    function lists__listMonths(format, index) {
      return list(format, index, 'months', 12, 'month');
    }
    function lists__listMonthsShort(format, index) {
      return list(format, index, 'monthsShort', 12, 'month');
    }
    function lists__listWeekdays(format, index) {
      return list(format, index, 'weekdays', 7, 'day');
    }
    function lists__listWeekdaysShort(format, index) {
      return list(format, index, 'weekdaysShort', 7, 'day');
    }
    function lists__listWeekdaysMin(format, index) {
      return list(format, index, 'weekdaysMin', 7, 'day');
    }
    locale_locales__getSetGlobalLocale('en', {
      ordinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
        return number + output;
      }
    });
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
    var mathAbs = Math.abs;
    function duration_abs__abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function duration_add_subtract__addSubtract(duration, input, value, direction) {
      var other = create__createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function duration_add_subtract__add(input, value) {
      return duration_add_subtract__addSubtract(this, input, value, 1);
    }
    function duration_add_subtract__subtract(input, value) {
      return duration_add_subtract__addSubtract(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds,
          minutes,
          hours,
          years,
          monthsFromDays;
      if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      }
      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24);
      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays));
      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }
    function daysToMonths(days) {
      return days * 4800 / 146097;
    }
    function monthsToDays(months) {
      return months * 146097 / 4800;
    }
    function as(units) {
      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);
      if (units === 'month' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
      } else {
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;
          case 'day':
            return days + milliseconds / 864e5;
          case 'hour':
            return days * 24 + milliseconds / 36e5;
          case 'minute':
            return days * 1440 + milliseconds / 6e4;
          case 'second':
            return days * 86400 + milliseconds / 1000;
          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;
          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    }
    function duration_as__valueOf() {
      return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asYears = makeAs('y');
    function duration_get__get(units) {
      units = normalizeUnits(units);
      return this[units + 's']();
    }
    function makeGetter(name) {
      return function() {
        return this._data[name];
      };
    }
    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round;
    var thresholds = {
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
      var duration = create__createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds < thresholds.s && ['s', seconds] || minutes === 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours === 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days === 1 && ['d'] || days < thresholds.d && ['dd', days] || months === 1 && ['M'] || months < thresholds.M && ['MM', months] || years === 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    }
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }
      if (limit === undefined) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      return true;
    }
    function humanize(withSuffix) {
      var locale = this.localeData();
      var output = duration_humanize__relativeTime(this, !withSuffix, locale);
      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }
      return locale.postformat(output);
    }
    var iso_string__abs = Math.abs;
    function iso_string__toISOString() {
      var seconds = iso_string__abs(this._milliseconds) / 1000;
      var days = iso_string__abs(this._days);
      var months = iso_string__abs(this._months);
      var minutes,
          hours,
          years;
      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60;
      years = absFloor(months / 12);
      months %= 12;
      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds;
      var total = this.asSeconds();
      if (!total) {
        return 'P0D';
      }
      return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
    }
    var duration_prototype__proto = Duration.prototype;
    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;
    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');
    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function(input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    utils_hooks__hooks.version = '2.10.6';
    setHookCallback(local__createLocal);
    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    var _moment = utils_hooks__hooks;
    return _moment;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:moment@2.10.6", ["npm:moment@2.10.6/moment"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:moment@2.10.6/moment');
  global.define = __define;
  return module.exports;
});

System.register('libraries/moment/moment.js', ['github:angular/bower-angular@1.4.7', 'npm:moment@2.10.6'], function (_export) {
  'use strict';

  var angular, moment;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_npmMoment2106) {
      moment = _npmMoment2106['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.moment', []).factory('moment', /*@ngInject*/function () {
        return moment;
      }));
    }
  };
});

System.registerDynamic("npm:events@1.0.2/events", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;
  EventEmitter.defaultMaxListeners = 10;
  EventEmitter.prototype.setMaxListeners = function(n) {
    if (!isNumber(n) || n < 0 || isNaN(n))
      throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };
  EventEmitter.prototype.emit = function(type) {
    var er,
        handler,
        len,
        args,
        i,
        listeners;
    if (!this._events)
      this._events = {};
    if (type === 'error') {
      if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er;
        }
        throw TypeError('Uncaught, unspecified "error" event.');
      }
    }
    handler = this._events[type];
    if (isUndefined(handler))
      return false;
    if (isFunction(handler)) {
      switch (arguments.length) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++)
        listeners[i].apply(this, args);
    }
    return true;
  };
  EventEmitter.prototype.addListener = function(type, listener) {
    var m;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events)
      this._events = {};
    if (this._events.newListener)
      this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
    if (!this._events[type])
      this._events[type] = listener;
    else if (isObject(this._events[type]))
      this._events[type].push(listener);
    else
      this._events[type] = [this._events[type], listener];
    if (isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }
      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
        if (typeof console.trace === 'function') {
          console.trace();
        }
      }
    }
    return this;
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.once = function(type, listener) {
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    var fired = false;
    function g() {
      this.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }
    g.listener = listener;
    this.on(type, g);
    return this;
  };
  EventEmitter.prototype.removeListener = function(type, listener) {
    var list,
        position,
        length,
        i;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events || !this._events[type])
      return this;
    list = this._events[type];
    length = list.length;
    position = -1;
    if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type];
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    } else if (isObject(list)) {
      for (i = length; i-- > 0; ) {
        if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function(type) {
    var key,
        listeners;
    if (!this._events)
      return this;
    if (!this._events.removeListener) {
      if (arguments.length === 0)
        this._events = {};
      else if (this._events[type])
        delete this._events[type];
      return this;
    }
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener')
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }
    listeners = this._events[type];
    if (isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else {
      while (listeners.length)
        this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];
    return this;
  };
  EventEmitter.prototype.listeners = function(type) {
    var ret;
    if (!this._events || !this._events[type])
      ret = [];
    else if (isFunction(this._events[type]))
      ret = [this._events[type]];
    else
      ret = this._events[type].slice();
    return ret;
  };
  EventEmitter.listenerCount = function(emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type])
      ret = 0;
    else if (isFunction(emitter._events[type]))
      ret = 1;
    else
      ret = emitter._events[type].length;
    return ret;
  };
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:events@1.0.2", ["npm:events@1.0.2/events"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:events@1.0.2/events');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-events@0.1.1/index", ["npm:events@1.0.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('events') : req('npm:events@1.0.2');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-events@0.1.1", ["github:jspm/nodelibs-events@0.1.1/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:jspm/nodelibs-events@0.1.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:inherits@2.0.1/inherits_browser", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if (typeof Object.create === 'function') {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:inherits@2.0.1", ["npm:inherits@2.0.1/inherits_browser"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:inherits@2.0.1/inherits_browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:isarray@0.0.1/index", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Array.isArray || function(arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:isarray@0.0.1", ["npm:isarray@0.0.1/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:isarray@0.0.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:base64-js@0.0.8/lib/b64", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:base64-js@0.0.8", ["npm:base64-js@0.0.8/lib/b64"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:base64-js@0.0.8/lib/b64');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ieee754@1.1.6/index", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ieee754@1.1.6", ["npm:ieee754@1.1.6/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:ieee754@1.1.6/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-array@1.0.1/index", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var str = Object.prototype.toString;
  module.exports = isArray || function(val) {
    return !!val && '[object Array]' == str.call(val);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-array@1.0.1", ["npm:is-array@1.0.1/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:is-array@1.0.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:buffer@3.5.1/index", ["npm:base64-js@0.0.8", "npm:ieee754@1.1.6", "npm:is-array@1.0.1"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var base64 = req('npm:base64-js@0.0.8');
  var ieee754 = req('npm:ieee754@1.1.6');
  var isArray = req('npm:is-array@1.0.1');
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function() {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  }
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    this.length = 0;
    this.parent = undefined;
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = '' + string;
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  Buffer.prototype.length = undefined;
  Buffer.prototype.parent = undefined;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte,
            thirdByte,
            fourthByte,
            tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 0x1000;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return;
    if (this.length === 0)
      return;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1)
            bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:buffer@3.5.1", ["npm:buffer@3.5.1/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:buffer@3.5.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0/index", ["npm:buffer@3.5.1"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : req('npm:buffer@3.5.1');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0", ["github:jspm/nodelibs-buffer@0.1.0/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:jspm/nodelibs-buffer@0.1.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-util-is@1.0.1/lib/util", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    function isBuffer(arg) {
      return Buffer.isBuffer(arg);
    }
    exports.isBuffer = isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-util-is@1.0.1", ["npm:core-util-is@1.0.1/lib/util"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:core-util-is@1.0.1/lib/util');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2", ["npm:process@0.11.2/browser"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:process@0.11.2/browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index", ["npm:process@0.11.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : req('npm:process@0.11.2');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2", ["github:jspm/nodelibs-process@0.1.2/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:jspm/nodelibs-process@0.1.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_writable", ["github:jspm/nodelibs-buffer@0.1.0", "npm:core-util-is@1.0.1", "npm:inherits@2.0.1", "npm:stream-browserify@1.0.0/index", "npm:readable-stream@1.1.13/lib/_stream_duplex", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Writable;
    var Buffer = req('github:jspm/nodelibs-buffer@0.1.0').Buffer;
    Writable.WritableState = WritableState;
    var util = req('npm:core-util-is@1.0.1');
    util.inherits = req('npm:inherits@2.0.1');
    var Stream = req('npm:stream-browserify@1.0.0/index');
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = req('npm:readable-stream@1.1.13/lib/_stream_duplex');
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = req('npm:readable-stream@1.1.13/lib/_stream_duplex');
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (!util.isFunction(cb))
        cb = function() {};
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          state.pendingcb--;
          cb(er);
        });
      else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++)
          cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length)
          state.buffer = state.buffer.slice(c);
        else
          state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (util.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util.isNullOrUndefined(chunk))
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return (state.ending && state.length === 0 && !state.finished && !state.writing);
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else
          prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer, req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_duplex", ["npm:core-util-is@1.0.1", "npm:inherits@2.0.1", "npm:readable-stream@1.1.13/lib/_stream_readable", "npm:readable-stream@1.1.13/lib/_stream_writable", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = req('npm:core-util-is@1.0.1');
    util.inherits = req('npm:inherits@2.0.1');
    var Readable = req('npm:readable-stream@1.1.13/lib/_stream_readable');
    var Writable = req('npm:readable-stream@1.1.13/lib/_stream_writable');
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:string_decoder@0.10.31/index", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var Buffer = req('github:jspm/nodelibs-buffer@0.1.0').Buffer;
    var isBufferEncoding = Buffer.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      while (this.charLength) {
        var available = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return '';
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = (buffer.length >= 3) ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:string_decoder@0.10.31", ["npm:string_decoder@0.10.31/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:string_decoder@0.10.31/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_readable", ["npm:isarray@0.0.1", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-events@0.1.1", "npm:stream-browserify@1.0.0/index", "npm:core-util-is@1.0.1", "npm:inherits@2.0.1", "@empty", "npm:readable-stream@1.1.13/lib/_stream_duplex", "npm:string_decoder@0.10.31", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Readable;
    var isArray = req('npm:isarray@0.0.1');
    var Buffer = req('github:jspm/nodelibs-buffer@0.1.0').Buffer;
    Readable.ReadableState = ReadableState;
    var EE = req('github:jspm/nodelibs-events@0.1.1').EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = req('npm:stream-browserify@1.0.0/index');
    var util = req('npm:core-util-is@1.0.1');
    util.inherits = req('npm:inherits@2.0.1');
    var StringDecoder;
    var debug = req('@empty');
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function() {};
    }
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      var Duplex = req('npm:readable-stream@1.1.13/lib/_stream_duplex');
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = req('npm:string_decoder@0.10.31').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      var Duplex = req('npm:readable-stream@1.1.13/lib/_stream_duplex');
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (util.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (util.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          if (!addToFront)
            state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = req('npm:string_decoder@0.10.31').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (isNaN(n) || util.isNull(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
      if (!util.isNumber(n) || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (util.isNull(ret)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
      if (!util.isNull(ret))
        this.emit('data', ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          process.nextTick(function() {
            emitReadable_(stream);
          });
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self = this;
            process.nextTick(function() {
              debug('readable nexttick read 0');
              self.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        if (!state.reading) {
          debug('resume read 0');
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function() {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length)
          return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
          var c = 0;
          for (var i = 0,
              l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer, req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_transform", ["npm:readable-stream@1.1.13/lib/_stream_duplex", "npm:core-util-is@1.0.1", "npm:inherits@2.0.1", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Transform;
    var Duplex = req('npm:readable-stream@1.1.13/lib/_stream_duplex');
    var util = req('npm:core-util-is@1.0.1');
    util.inherits = req('npm:inherits@2.0.1');
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util.isNullOrUndefined(data))
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once('prefinish', function() {
        if (util.isFunction(this._flush))
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_passthrough", ["npm:readable-stream@1.1.13/lib/_stream_transform", "npm:core-util-is@1.0.1", "npm:inherits@2.0.1"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = PassThrough;
  var Transform = req('npm:readable-stream@1.1.13/lib/_stream_transform');
  var util = req('npm:core-util-is@1.0.1');
  util.inherits = req('npm:inherits@2.0.1');
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/readable", ["npm:readable-stream@1.1.13/lib/_stream_readable", "npm:stream-browserify@1.0.0/index", "npm:readable-stream@1.1.13/lib/_stream_writable", "npm:readable-stream@1.1.13/lib/_stream_duplex", "npm:readable-stream@1.1.13/lib/_stream_transform", "npm:readable-stream@1.1.13/lib/_stream_passthrough"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = req('npm:readable-stream@1.1.13/lib/_stream_readable');
  exports.Stream = req('npm:stream-browserify@1.0.0/index');
  exports.Readable = exports;
  exports.Writable = req('npm:readable-stream@1.1.13/lib/_stream_writable');
  exports.Duplex = req('npm:readable-stream@1.1.13/lib/_stream_duplex');
  exports.Transform = req('npm:readable-stream@1.1.13/lib/_stream_transform');
  exports.PassThrough = req('npm:readable-stream@1.1.13/lib/_stream_passthrough');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/writable", ["npm:readable-stream@1.1.13/lib/_stream_writable"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:readable-stream@1.1.13/lib/_stream_writable');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/duplex", ["npm:readable-stream@1.1.13/lib/_stream_duplex"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:readable-stream@1.1.13/lib/_stream_duplex');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/transform", ["npm:readable-stream@1.1.13/lib/_stream_transform"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:readable-stream@1.1.13/lib/_stream_transform');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/passthrough", ["npm:readable-stream@1.1.13/lib/_stream_passthrough"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:readable-stream@1.1.13/lib/_stream_passthrough');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:stream-browserify@1.0.0/index", ["github:jspm/nodelibs-events@0.1.1", "npm:inherits@2.0.1", "npm:readable-stream@1.1.13/readable", "npm:readable-stream@1.1.13/writable", "npm:readable-stream@1.1.13/duplex", "npm:readable-stream@1.1.13/transform", "npm:readable-stream@1.1.13/passthrough"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Stream;
  var EE = req('github:jspm/nodelibs-events@0.1.1').EventEmitter;
  var inherits = req('npm:inherits@2.0.1');
  inherits(Stream, EE);
  Stream.Readable = req('npm:readable-stream@1.1.13/readable');
  Stream.Writable = req('npm:readable-stream@1.1.13/writable');
  Stream.Duplex = req('npm:readable-stream@1.1.13/duplex');
  Stream.Transform = req('npm:readable-stream@1.1.13/transform');
  Stream.PassThrough = req('npm:readable-stream@1.1.13/passthrough');
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on('data', ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on('drain', ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === 'function')
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, 'error') === 0) {
        throw er;
      }
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);
      source.removeListener('end', onend);
      source.removeListener('close', onclose);
      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);
      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);
      dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    return dest;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:stream-browserify@1.0.0", ["npm:stream-browserify@1.0.0/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:stream-browserify@1.0.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-stream@0.1.0/index", ["npm:stream-browserify@1.0.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('stream') : req('npm:stream-browserify@1.0.0');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-stream@0.1.0", ["github:jspm/nodelibs-stream@0.1.0/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:jspm/nodelibs-stream@0.1.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/encode", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    "use strict";
    function pushBits(arr, n, value) {
      for (var bit = 1 << (n - 1); bit; bit = bit >>> 1) {
        arr.push(bit & value ? 1 : 0);
      }
    }
    function encode_8bit(data) {
      var len = data.length;
      var bits = [];
      for (var i = 0; i < len; i++) {
        pushBits(bits, 8, data[i]);
      }
      var res = {};
      var d = [0, 1, 0, 0];
      pushBits(d, 16, len);
      res.data10 = res.data27 = d.concat(bits);
      if (len < 256) {
        var d = [0, 1, 0, 0];
        pushBits(d, 8, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    var ALPHANUM = (function(s) {
      var res = {};
      for (var i = 0; i < s.length; i++) {
        res[s[i]] = i;
      }
      return res;
    })('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:');
    function encode_alphanum(str) {
      var len = str.length;
      var bits = [];
      for (var i = 0; i < len; i += 2) {
        var b = 6;
        var n = ALPHANUM[str[i]];
        if (str[i + 1]) {
          b = 11;
          n = n * 45 + ALPHANUM[str[i + 1]];
        }
        pushBits(bits, b, n);
      }
      var res = {};
      var d = [0, 0, 1, 0];
      pushBits(d, 13, len);
      res.data27 = d.concat(bits);
      if (len < 2048) {
        var d = [0, 0, 1, 0];
        pushBits(d, 11, len);
        res.data10 = d.concat(bits);
      }
      if (len < 512) {
        var d = [0, 0, 1, 0];
        pushBits(d, 9, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    function encode_numeric(str) {
      var len = str.length;
      var bits = [];
      for (var i = 0; i < len; i += 3) {
        var s = str.substr(i, 3);
        var b = Math.ceil(s.length * 10 / 3);
        pushBits(bits, b, parseInt(s, 10));
      }
      var res = {};
      var d = [0, 0, 0, 1];
      pushBits(d, 14, len);
      res.data27 = d.concat(bits);
      if (len < 4096) {
        var d = [0, 0, 0, 1];
        pushBits(d, 12, len);
        res.data10 = d.concat(bits);
      }
      if (len < 1024) {
        var d = [0, 0, 0, 1];
        pushBits(d, 10, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    function encode_url(str) {
      var slash = str.indexOf('/', 8) + 1 || str.length;
      var res = encode(str.slice(0, slash).toUpperCase(), false);
      if (slash >= str.length) {
        return res;
      }
      var path_res = encode(str.slice(slash), false);
      res.data27 = res.data27.concat(path_res.data27);
      if (res.data10 && path_res.data10) {
        res.data10 = res.data10.concat(path_res.data10);
      }
      if (res.data1 && path_res.data1) {
        res.data1 = res.data1.concat(path_res.data1);
      }
      return res;
    }
    function encode(data, parse_url) {
      var str;
      var t = typeof data;
      if (t == 'string' || t == 'number') {
        str = '' + data;
        data = Buffer(str);
      } else if (Buffer.isBuffer(data)) {
        str = data.toString();
      } else if (Array.isArray(data)) {
        data = Buffer(data);
        str = data.toString();
      } else {
        throw new Error("Bad data");
      }
      if (/^[0-9]+$/.test(str)) {
        if (data.length > 7089) {
          throw new Error("Too much data");
        }
        return encode_numeric(str);
      }
      if (/^[0-9A-Z \$%\*\+\.\/\:\-]+$/.test(str)) {
        if (data.length > 4296) {
          throw new Error("Too much data");
        }
        return encode_alphanum(str);
      }
      if (parse_url && /^https?:/i.test(str)) {
        return encode_url(str);
      }
      if (data.length > 2953) {
        throw new Error("Too much data");
      }
      return encode_8bit(data);
    }
    module.exports = encode;
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/errorcode", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    "use strict";
    var GF256_BASE = 285;
    var EXP_TABLE = [1];
    var LOG_TABLE = [];
    for (var i = 1; i < 256; i++) {
      var n = EXP_TABLE[i - 1] << 1;
      if (n > 255)
        n = n ^ GF256_BASE;
      EXP_TABLE[i] = n;
    }
    for (var i = 0; i < 255; i++) {
      LOG_TABLE[EXP_TABLE[i]] = i;
    }
    function exp(k) {
      while (k < 0)
        k += 255;
      while (k > 255)
        k -= 255;
      return EXP_TABLE[k];
    }
    function log(k) {
      if (k < 1 || k > 255) {
        throw Error('Bad log(' + k + ')');
      }
      return LOG_TABLE[k];
    }
    var POLYNOMIALS = [[0], [0, 0], [0, 25, 1]];
    function generatorPolynomial(num) {
      if (POLYNOMIALS[num]) {
        return POLYNOMIALS[num];
      }
      var prev = generatorPolynomial(num - 1);
      var res = [];
      res[0] = prev[0];
      for (var i = 1; i <= num; i++) {
        res[i] = log(exp(prev[i]) ^ exp(prev[i - 1] + num - 1));
      }
      POLYNOMIALS[num] = res;
      return res;
    }
    module.exports = function calculate_ec(msg, ec_len) {
      msg = [].slice.call(msg);
      var poly = generatorPolynomial(ec_len);
      for (var i = 0; i < ec_len; i++)
        msg.push(0);
      while (msg.length > ec_len) {
        if (!msg[0]) {
          msg.shift();
          continue;
        }
        var log_k = log(msg[0]);
        for (var i = 0; i <= ec_len; i++) {
          msg[i] = msg[i] ^ exp(poly[i] + log_k);
        }
        msg.shift();
      }
      return Buffer(msg);
    };
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/matrix", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    "use strict";
    function init(version) {
      var N = version * 4 + 17;
      var matrix = [];
      var zeros = Buffer(N);
      zeros.fill(0);
      zeros = [].slice.call(zeros);
      for (var i = 0; i < N; i++) {
        matrix[i] = zeros.slice();
      }
      return matrix;
    }
    function fillFinders(matrix) {
      var N = matrix.length;
      for (var i = -3; i <= 3; i++) {
        for (var j = -3; j <= 3; j++) {
          var max = Math.max(i, j);
          var min = Math.min(i, j);
          var pixel = (max == 2 && min >= -2) || (min == -2 && max <= 2) ? 0x80 : 0x81;
          matrix[3 + i][3 + j] = pixel;
          matrix[3 + i][N - 4 + j] = pixel;
          matrix[N - 4 + i][3 + j] = pixel;
        }
      }
      for (var i = 0; i < 8; i++) {
        matrix[7][i] = matrix[i][7] = matrix[7][N - i - 1] = matrix[i][N - 8] = matrix[N - 8][i] = matrix[N - 1 - i][7] = 0x80;
      }
    }
    function fillAlignAndTiming(matrix) {
      var N = matrix.length;
      if (N > 21) {
        var len = N - 13;
        var delta = Math.round(len / Math.ceil(len / 28));
        if (delta % 2)
          delta++;
        var res = [];
        for (var p = len + 6; p > 10; p -= delta) {
          res.unshift(p);
        }
        res.unshift(6);
        for (var i = 0; i < res.length; i++) {
          for (var j = 0; j < res.length; j++) {
            var x = res[i],
                y = res[j];
            if (matrix[x][y])
              continue;
            for (var r = -2; r <= 2; r++) {
              for (var c = -2; c <= 2; c++) {
                var max = Math.max(r, c);
                var min = Math.min(r, c);
                var pixel = (max == 1 && min >= -1) || (min == -1 && max <= 1) ? 0x80 : 0x81;
                matrix[x + r][y + c] = pixel;
              }
            }
          }
        }
      }
      for (var i = 8; i < N - 8; i++) {
        matrix[6][i] = matrix[i][6] = i % 2 ? 0x80 : 0x81;
      }
    }
    function fillStub(matrix) {
      var N = matrix.length;
      for (var i = 0; i < 8; i++) {
        if (i != 6) {
          matrix[8][i] = matrix[i][8] = 0x80;
        }
        matrix[8][N - 1 - i] = 0x80;
        matrix[N - 1 - i][8] = 0x80;
      }
      matrix[8][8] = 0x80;
      matrix[N - 8][8] = 0x81;
      if (N < 45)
        return;
      for (var i = N - 11; i < N - 8; i++) {
        for (var j = 0; j < 6; j++) {
          matrix[i][j] = matrix[j][i] = 0x80;
        }
      }
    }
    var fillReserved = (function() {
      var FORMATS = Array(32);
      var VERSIONS = Array(40);
      var gf15 = 0x0537;
      var gf18 = 0x1f25;
      var formats_mask = 0x5412;
      for (var format = 0; format < 32; format++) {
        var res = format << 10;
        for (var i = 5; i > 0; i--) {
          if (res >>> (9 + i)) {
            res = res ^ (gf15 << (i - 1));
          }
        }
        FORMATS[format] = (res | (format << 10)) ^ formats_mask;
      }
      for (var version = 7; version <= 40; version++) {
        var res = version << 12;
        for (var i = 6; i > 0; i--) {
          if (res >>> (11 + i)) {
            res = res ^ (gf18 << (i - 1));
          }
        }
        VERSIONS[version] = (res | (version << 12));
      }
      var EC_LEVELS = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
      };
      return function fillReserved(matrix, ec_level, mask) {
        var N = matrix.length;
        var format = FORMATS[EC_LEVELS[ec_level] << 3 | mask];
        function F(k) {
          return format >> k & 1 ? 0x81 : 0x80;
        }
        ;
        for (var i = 0; i < 8; i++) {
          matrix[8][N - 1 - i] = F(i);
          if (i < 6)
            matrix[i][8] = F(i);
        }
        for (var i = 8; i < 15; i++) {
          matrix[N - 15 + i][8] = F(i);
          if (i > 8)
            matrix[8][14 - i] = F(i);
        }
        matrix[7][8] = F(6);
        matrix[8][8] = F(7);
        matrix[8][7] = F(8);
        var version = VERSIONS[(N - 17) / 4];
        if (!version)
          return;
        function V(k) {
          return version >> k & 1 ? 0x81 : 0x80;
        }
        ;
        for (var i = 0; i < 6; i++) {
          for (var j = 0; j < 3; j++) {
            matrix[N - 11 + j][i] = matrix[i][N - 11 + j] = V(i * 3 + j);
          }
        }
      };
    })();
    var fillData = (function() {
      var MASK_FUNCTIONS = [function(i, j) {
        return (i + j) % 2 == 0;
      }, function(i, j) {
        return i % 2 == 0;
      }, function(i, j) {
        return j % 3 == 0;
      }, function(i, j) {
        return (i + j) % 3 == 0;
      }, function(i, j) {
        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
      }, function(i, j) {
        return (i * j) % 2 + (i * j) % 3 == 0;
      }, function(i, j) {
        return ((i * j) % 2 + (i * j) % 3) % 2 == 0;
      }, function(i, j) {
        return ((i * j) % 3 + (i + j) % 2) % 2 == 0;
      }];
      return function fillData(matrix, data, mask) {
        var N = matrix.length;
        var row,
            col,
            dir = -1;
        row = col = N - 1;
        var mask_fn = MASK_FUNCTIONS[mask];
        var len = data.blocks[data.blocks.length - 1].length;
        for (var i = 0; i < len; i++) {
          for (var b = 0; b < data.blocks.length; b++) {
            if (data.blocks[b].length <= i)
              continue;
            put(data.blocks[b][i]);
          }
        }
        len = data.ec_len;
        for (var i = 0; i < len; i++) {
          for (var b = 0; b < data.ec.length; b++) {
            put(data.ec[b][i]);
          }
        }
        if (col > -1) {
          do {
            matrix[row][col] = mask_fn(row, col) ? 1 : 0;
          } while (next());
        }
        function put(byte) {
          for (var mask = 0x80; mask; mask = mask >> 1) {
            var pixel = !!(mask & byte);
            if (mask_fn(row, col))
              pixel = !pixel;
            matrix[row][col] = pixel ? 1 : 0;
            next();
          }
        }
        function next() {
          do {
            if ((col % 2) ^ (col < 6)) {
              if (dir < 0 && row == 0 || dir > 0 && row == N - 1) {
                col--;
                dir = -dir;
              } else {
                col++;
                row += dir;
              }
            } else {
              col--;
            }
            if (col == 6) {
              col--;
            }
            if (col < 0) {
              return false;
            }
          } while (matrix[row][col] & 0xf0);
          return true;
        }
      };
    })();
    function calculatePenalty(matrix) {
      var N = matrix.length;
      var penalty = 0;
      for (var i = 0; i < N; i++) {
        var pixel = matrix[i][0] & 1;
        var len = 1;
        for (var j = 1; j < N; j++) {
          var p = matrix[i][j] & 1;
          if (p == pixel) {
            len++;
            continue;
          }
          if (len >= 5) {
            penalty += len - 2;
          }
          pixel = p;
          len = 1;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
      }
      for (var j = 0; j < N; j++) {
        var pixel = matrix[0][j] & 1;
        var len = 1;
        for (var i = 1; i < N; i++) {
          var p = matrix[i][j] & 1;
          if (p == pixel) {
            len++;
            continue;
          }
          if (len >= 5) {
            penalty += len - 2;
          }
          pixel = p;
          len = 1;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
      }
      for (var i = 0; i < N - 1; i++) {
        for (var j = 0; j < N - 1; j++) {
          var s = matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1] & 7;
          if (s == 0 || s == 4) {
            penalty += 3;
          }
        }
      }
      function I(k) {
        return matrix[i][j + k] & 1;
      }
      ;
      function J(k) {
        return matrix[i + k][j] & 1;
      }
      ;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (j < N - 6 && I(0) && !I(1) && I(2) && I(3) && I(4) && !I(5) && I(6)) {
            if (j >= 4 && !(I(-4) || I(-3) || I(-2) || I(-1))) {
              penalty += 40;
            }
            if (j < N - 10 && !(I(7) || I(8) || I(9) || I(10))) {
              penalty += 40;
            }
          }
          if (i < N - 6 && J(0) && !J(1) && J(2) && J(3) && J(4) && !J(5) && J(6)) {
            if (i >= 4 && !(J(-4) || J(-3) || J(-2) || J(-1))) {
              penalty += 40;
            }
            if (i < N - 10 && !(J(7) || J(8) || J(9) || J(10))) {
              penalty += 40;
            }
          }
        }
      }
      var numDark = 0;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (matrix[i][j] & 1)
            numDark++;
        }
      }
      penalty += 10 * Math.floor(Math.abs(10 - 20 * numDark / (N * N)));
      return penalty;
    }
    function getMatrix(data) {
      var matrix = init(data.version);
      fillFinders(matrix);
      fillAlignAndTiming(matrix);
      fillStub(matrix);
      var penalty = Infinity;
      var bestMask = 0;
      for (var mask = 0; mask < 8; mask++) {
        fillData(matrix, data, mask);
        fillReserved(matrix, data.ec_level, mask);
        var p = calculatePenalty(matrix);
        if (p < penalty) {
          penalty = p;
          bestMask = mask;
        }
      }
      fillData(matrix, data, bestMask);
      fillReserved(matrix, data.ec_level, bestMask);
      return matrix.map(function(row) {
        return row.map(function(cell) {
          return cell & 1;
        });
      });
    }
    module.exports = {
      getMatrix: getMatrix,
      init: init,
      fillFinders: fillFinders,
      fillAlignAndTiming: fillAlignAndTiming,
      fillStub: fillStub,
      fillReserved: fillReserved,
      fillData: fillData,
      calculatePenalty: calculatePenalty
    };
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/qr-base", ["npm:qr-image@3.1.0/lib/encode", "npm:qr-image@3.1.0/lib/errorcode", "npm:qr-image@3.1.0/lib/matrix", "github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    "use strict";
    var encode = req('npm:qr-image@3.1.0/lib/encode');
    var calculateEC = req('npm:qr-image@3.1.0/lib/errorcode');
    var matrix = req('npm:qr-image@3.1.0/lib/matrix');
    function _deepCopy(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    var EC_LEVELS = ['L', 'M', 'Q', 'H'];
    var versions = [[], [26, 7, 1, 10, 1, 13, 1, 17, 1], [44, 10, 1, 16, 1, 22, 1, 28, 1], [70, 15, 1, 26, 1, 36, 2, 44, 2], [100, 20, 1, 36, 2, 52, 2, 64, 4], [134, 26, 1, 48, 2, 72, 4, 88, 4], [172, 36, 2, 64, 4, 96, 4, 112, 4], [196, 40, 2, 72, 4, 108, 6, 130, 5], [242, 48, 2, 88, 4, 132, 6, 156, 6], [292, 60, 2, 110, 5, 160, 8, 192, 8], [346, 72, 4, 130, 5, 192, 8, 224, 8], [404, 80, 4, 150, 5, 224, 8, 264, 11], [466, 96, 4, 176, 8, 260, 10, 308, 11], [532, 104, 4, 198, 9, 288, 12, 352, 16], [581, 120, 4, 216, 9, 320, 16, 384, 16], [655, 132, 6, 240, 10, 360, 12, 432, 18], [733, 144, 6, 280, 10, 408, 17, 480, 16], [815, 168, 6, 308, 11, 448, 16, 532, 19], [901, 180, 6, 338, 13, 504, 18, 588, 21], [991, 196, 7, 364, 14, 546, 21, 650, 25], [1085, 224, 8, 416, 16, 600, 20, 700, 25], [1156, 224, 8, 442, 17, 644, 23, 750, 25], [1258, 252, 9, 476, 17, 690, 23, 816, 34], [1364, 270, 9, 504, 18, 750, 25, 900, 30], [1474, 300, 10, 560, 20, 810, 27, 960, 32], [1588, 312, 12, 588, 21, 870, 29, 1050, 35], [1706, 336, 12, 644, 23, 952, 34, 1110, 37], [1828, 360, 12, 700, 25, 1020, 34, 1200, 40], [1921, 390, 13, 728, 26, 1050, 35, 1260, 42], [2051, 420, 14, 784, 28, 1140, 38, 1350, 45], [2185, 450, 15, 812, 29, 1200, 40, 1440, 48], [2323, 480, 16, 868, 31, 1290, 43, 1530, 51], [2465, 510, 17, 924, 33, 1350, 45, 1620, 54], [2611, 540, 18, 980, 35, 1440, 48, 1710, 57], [2761, 570, 19, 1036, 37, 1530, 51, 1800, 60], [2876, 570, 19, 1064, 38, 1590, 53, 1890, 63], [3034, 600, 20, 1120, 40, 1680, 56, 1980, 66], [3196, 630, 21, 1204, 43, 1770, 59, 2100, 70], [3362, 660, 22, 1260, 45, 1860, 62, 2220, 74], [3532, 720, 24, 1316, 47, 1950, 65, 2310, 77], [3706, 750, 25, 1372, 49, 2040, 68, 2430, 81]];
    versions = versions.map(function(v, index) {
      if (!index)
        return {};
      var res = {};
      for (var i = 1; i < 8; i += 2) {
        var length = v[0] - v[i];
        var num_template = v[i + 1];
        var ec_level = EC_LEVELS[(i / 2) | 0];
        var level = {
          version: index,
          ec_level: ec_level,
          data_len: length,
          ec_len: v[i] / num_template,
          blocks: [],
          ec: []
        };
        for (var k = num_template,
            n = length; k > 0; k--) {
          var block = (n / k) | 0;
          level.blocks.push(block);
          n -= block;
        }
        res[ec_level] = level;
      }
      return res;
    });
    function getTemplate(message, ec_level) {
      var i = 1;
      var len;
      if (message.data1) {
        len = Math.ceil(message.data1.length / 8);
      } else {
        i = 10;
      }
      for (; i < 10; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      if (message.data10) {
        len = Math.ceil(message.data10.length / 8);
      } else {
        i = 27;
      }
      for (; i < 27; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      len = Math.ceil(message.data27.length / 8);
      for (; i < 41; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      throw new Error("Too much data");
    }
    function fillTemplate(message, template) {
      var blocks = Buffer(template.data_len);
      blocks.fill(0);
      if (template.version < 10) {
        message = message.data1;
      } else if (template.version < 27) {
        message = message.data10;
      } else {
        message = message.data27;
      }
      var len = message.length;
      for (var i = 0; i < len; i += 8) {
        var b = 0;
        for (var j = 0; j < 8; j++) {
          b = (b << 1) | (message[i + j] ? 1 : 0);
        }
        blocks[i / 8] = b;
      }
      var pad = 236;
      for (var i = Math.ceil((len + 4) / 8); i < blocks.length; i++) {
        blocks[i] = pad;
        pad = (pad == 236) ? 17 : 236;
      }
      var offset = 0;
      template.blocks = template.blocks.map(function(n) {
        var b = blocks.slice(offset, offset + n);
        offset += n;
        template.ec.push(calculateEC(b, template.ec_len));
        return b;
      });
      return template;
    }
    function QR(text, ec_level, parse_url) {
      ec_level = EC_LEVELS.indexOf(ec_level) > -1 ? ec_level : 'M';
      var message = encode(text, parse_url);
      var data = fillTemplate(message, getTemplate(message, ec_level));
      return matrix.getMatrix(data);
    }
    module.exports = {
      QR: QR,
      getTemplate: getTemplate,
      fillTemplate: fillTemplate
    };
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/crc32buffer", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var crc_table = [];
    for (var n = 0; n < 256; n++) {
      var c = crc_table[n] = Buffer(4);
      c.writeUInt32BE(n, 0);
      for (var k = 0; k < 8; k++) {
        var b0 = c[0] & 1;
        var b1 = c[1] & 1;
        var b2 = c[2] & 1;
        var b3 = c[3] & 1;
        c[0] = (c[0] >> 1) ^ (b3 ? 0xed : 0);
        c[1] = (c[1] >> 1) ^ (b3 ? 0xb8 : 0) ^ (b0 ? 0x80 : 0);
        c[2] = (c[2] >> 1) ^ (b3 ? 0x83 : 0) ^ (b1 ? 0x80 : 0);
        c[3] = (c[3] >> 1) ^ (b3 ? 0x20 : 0) ^ (b2 ? 0x80 : 0);
      }
    }
    function update(c, buf) {
      var l = buf.length;
      for (var n = 0; n < l; n++) {
        var e = crc_table[c[3] ^ buf[n]];
        c[3] = e[3] ^ c[2];
        c[2] = e[2] ^ c[1];
        c[1] = e[1] ^ c[0];
        c[0] = e[0];
      }
    }
    function crc32() {
      var l = arguments.length;
      var c = Buffer(4);
      c.fill(0xff);
      for (var i = 0; i < l; i++) {
        update(c, Buffer(arguments[i]));
      }
      c[0] = c[0] ^ 0xff;
      c[1] = c[1] ^ 0xff;
      c[2] = c[2] ^ 0xff;
      c[3] = c[3] ^ 0xff;
      return c.readUInt32BE(0);
    }
    module.exports = crc32;
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/crc32", ["npm:qr-image@3.1.0/lib/crc32buffer", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    "use strict";
    (function() {
      if (process.arch === 'arm') {
        module.exports = req('npm:qr-image@3.1.0/lib/crc32buffer');
        return;
      }
      var crc_table = [];
      (function() {
        for (var n = 0; n < 256; n++) {
          var c = n;
          for (var k = 0; k < 8; k++) {
            if (c & 1) {
              c = 0xedb88320 ^ (c >>> 1);
            } else {
              c = c >>> 1;
            }
          }
          crc_table[n] = c >>> 0;
        }
      })();
      function update(c, buf) {
        var l = buf.length;
        for (var n = 0; n < l; n++) {
          c = crc_table[(c ^ buf[n]) & 0xff] ^ (c >>> 8);
        }
        return c;
      }
      function crc32() {
        var l = arguments.length;
        var c = -1;
        for (var i = 0; i < l; i++) {
          c = update(c, Buffer(arguments[i]));
        }
        c = (c ^ -1) >>> 0;
        return c;
      }
      module.exports = crc32;
    })();
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer, req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/messages", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = {
    '2': 'need dictionary',
    '1': 'stream end',
    '0': '',
    '-1': 'file error',
    '-2': 'stream error',
    '-3': 'data error',
    '-4': 'insufficient memory',
    '-5': 'buffer error',
    '-6': 'incompatible version'
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/zstream", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = '';
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module.exports = ZStream;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/utils/common", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var TYPED_OK = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Int32Array !== 'undefined');
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }
      for (var p in source) {
        if (source.hasOwnProperty(p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      var i,
          l,
          len,
          pos,
          chunk,
          result;
      len = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/trees", ["npm:pako@0.2.8/lib/utils/common", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var utils = req('npm:pako@0.2.8/lib/utils/common');
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    };
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    var TreeDesc = function(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    };
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = (w) & 0xff;
      s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > (Buf_size - length)) {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> (Buf_size - s.bi_valid);
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n,
          m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1 << extra_lbits[code]); n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1 << extra_dbits[code]); n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return (tree[_n2] < tree[_m2] || (tree[_n2] === tree[_m2] && depth[n] <= depth[m]));
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n,
          m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = (s.heap_len >> 1); n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 0xffff;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 0xf3ffc07f;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if ((black_mask & 1) && (s.dyn_ltree[n * 2] !== 0)) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb,
          static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = (s.opt_len + 3 + 7) >>> 3;
        static_lenb = (s.static_len + 3 + 7) >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return (s.last_lit === s.lit_bufsize - 1);
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/adler32", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function adler32(adler, buf, len, pos) {
    var s1 = (adler & 0xffff) | 0,
        s2 = ((adler >>> 16) & 0xffff) | 0,
        n = 0;
    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;
      do {
        s1 = (s1 + buf[pos++]) | 0;
        s2 = (s2 + s1) | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return (s1 | (s2 << 16)) | 0;
  }
  module.exports = adler32;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/crc32", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function makeTable() {
    var c,
        table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;
    crc = crc ^ (-1);
    for (var i = pos; i < end; i++) {
      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }
    return (crc ^ (-1));
  }
  module.exports = crc32;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/deflate", ["npm:pako@0.2.8/lib/utils/common", "npm:pako@0.2.8/lib/zlib/trees", "npm:pako@0.2.8/lib/zlib/adler32", "npm:pako@0.2.8/lib/zlib/crc32", "npm:pako@0.2.8/lib/zlib/messages", "github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var utils = req('npm:pako@0.2.8/lib/utils/common');
    var trees = req('npm:pako@0.2.8/lib/zlib/trees');
    var adler32 = req('npm:pako@0.2.8/lib/zlib/adler32');
    var crc32 = req('npm:pako@0.2.8/lib/zlib/crc32');
    var msg = req('npm:pako@0.2.8/lib/zlib/messages');
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
    var PRESET_DICT = 0x20;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 0x03;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return ((f) << 1) - ((f) > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p,
          n,
          m,
          more,
          str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 0xffff;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan,
          strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    var Config = function(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    };
    var configuration_table;
    configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
      strm.adler = (s.wrap === 2) ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << (memLevel + 6);
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = s.lit_bufsize >> 1;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush,
          s;
      var beg,
          val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {
        return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0));
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, (s.gzhead.time >> 8) & 0xff);
            put_byte(s, (s.gzhead.time >> 16) & 0xff);
            put_byte(s, (s.gzhead.time >> 24) & 0xff);
            put_byte(s, s.level === 9 ? 2 : (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0));
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= (level_flags << 6);
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - (header % 31);
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
        var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) : (s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush));
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        put_byte(s, (strm.adler >> 16) & 0xff);
        put_byte(s, (strm.adler >> 24) & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, (strm.total_in >> 8) & 0xff);
        put_byte(s, (strm.total_in >> 16) & 0xff);
        put_byte(s, (strm.total_in >> 24) & 0xff);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/inffast", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input,
        output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen: for (; ; ) {
        op = here >>> 24;
        hold >>>= op;
        bits -= op;
        op = (here >>> 16) & 0xff;
        if (op === 0) {
          output[_out++] = here & 0xffff;
        } else if (op & 16) {
          len = here & 0xffff;
          op &= 15;
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & ((1 << op) - 1);
            hold >>>= op;
            bits -= op;
          }
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];
          dodist: for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = (here >>> 16) & 0xff;
            if (op & 16) {
              dist = here & 0xffff;
              op &= 15;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & ((1 << op) - 1);
              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break top;
              }
              hold >>>= op;
              bits -= op;
              op = _out - beg;
              if (dist > op) {
                op = dist - op;
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break top;
                  }
                }
                from = 0;
                from_source = s_window;
                if (wnext === 0) {
                  from += wsize - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                } else if (wnext < op) {
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  }
                } else {
                  from += wnext - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist;
                do {
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              here = dcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
              continue dodist;
            } else {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break top;
            }
            break;
          }
        } else if ((op & 64) === 0) {
          here = lcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
          continue dolen;
        } else if (op & 32) {
          state.mode = TYPE;
          break top;
        } else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break top;
        }
        break;
      }
    } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
    strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
    state.hold = hold;
    state.bits = bits;
    return;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/inftrees", ["npm:pako@0.2.8/lib/utils/common", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var utils = req('npm:pako@0.2.8/lib/utils/common');
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
    var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
    var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
    var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0,
          max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits,
          here_op,
          here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }
      var i = 0;
      for (; ; ) {
        i++;
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << (len - drop);
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
        } while (fill !== 0);
        incr = 1 << (len - 1);
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {
            return 1;
          }
          low = huff & mask;
          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
      }
      opts.bits = root;
      return 0;
    };
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/inflate", ["npm:pako@0.2.8/lib/utils/common", "npm:pako@0.2.8/lib/zlib/adler32", "npm:pako@0.2.8/lib/zlib/crc32", "npm:pako@0.2.8/lib/zlib/inffast", "npm:pako@0.2.8/lib/zlib/inftrees", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var utils = req('npm:pako@0.2.8/lib/utils/common');
    var adler32 = req('npm:pako@0.2.8/lib/zlib/adler32');
    var crc32 = req('npm:pako@0.2.8/lib/zlib/crc32');
    var inflate_fast = req('npm:pako@0.2.8/lib/zlib/inffast');
    var inflate_table = req('npm:pako@0.2.8/lib/zlib/inftrees');
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function ZSWAP32(q) {
      return (((q >>> 24) & 0xff) + ((q >>> 8) & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24));
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = '';
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix,
        distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {bits: 9});
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {bits: 5});
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input,
          output;
      var next;
      var put;
      var have,
          left;
      var hold;
      var bits;
      var _in,
          _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits,
          here_op,
          here_val;
      var last_bits,
          last_op,
          last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || (!strm.input && strm.avail_in !== 0)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave: for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((state.wrap & 2) && hold === 0x8b1f) {
              state.check = 0;
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
              strm.msg = 'incorrect header check';
              state.mode = BAD;
              break;
            }
            if ((hold & 0x0f) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 0x0f) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = 'invalid window size';
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 0x200 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 0xff) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            if (state.flags & 0xe000) {
              strm.msg = 'unknown header flags set';
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = ((hold >> 8) & 1);
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              hbuf[2] = (hold >>> 16) & 0xff;
              hbuf[3] = (hold >>> 24) & 0xff;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = (hold & 0xff);
              state.head.os = (hold >> 8);
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 0x0400) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 0x0200) {
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 0x0400) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 0x0800) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && (state.length < 65536)) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 0x1000) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && (state.length < 65536)) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 0x0200) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 0xffff)) {
                strm.msg = 'header crc mismatch';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = ((state.flags >> 9) & 1);
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = ZSWAP32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = (hold & 0x01);
            hold >>>= 1;
            bits -= 1;
            switch ((hold & 0x03)) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = 'invalid block type';
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
              strm.msg = 'invalid stored block lengths';
              state.mode = BAD;
              break;
            }
            state.length = hold & 0xffff;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 0x1f) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 0x1f) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 0x0f) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = 'too many length or distance symbols';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = (hold & 0x07);
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid code lengths set';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 0x03);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 0x07);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 0x7f);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = 'invalid code -- missing end-of-block';
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid literal/lengths set';
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid distances set';
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((last_bits + here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & ((1 << state.extra) - 1);
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & ((1 << state.distbits) - 1)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;
              if ((here_bits) <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((last_bits + here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = (here_op) & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & ((1 << state.extra) - 1);
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
              }
              _out = left;
              if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
                strm.msg = 'incorrect data check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 0xffffffff)) {
                strm.msg = 'incorrect length check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/constants", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:browserify-zlib@0.1.4/src/binding", ["npm:pako@0.2.8/lib/zlib/messages", "npm:pako@0.2.8/lib/zlib/zstream", "npm:pako@0.2.8/lib/zlib/deflate", "npm:pako@0.2.8/lib/zlib/inflate", "npm:pako@0.2.8/lib/zlib/constants", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var msg = req('npm:pako@0.2.8/lib/zlib/messages');
    var zstream = req('npm:pako@0.2.8/lib/zlib/zstream');
    var zlib_deflate = req('npm:pako@0.2.8/lib/zlib/deflate');
    var zlib_inflate = req('npm:pako@0.2.8/lib/zlib/inflate');
    var constants = req('npm:pako@0.2.8/lib/zlib/constants');
    for (var key in constants) {
      exports[key] = constants[key];
    }
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    function Zlib(mode) {
      if (mode < exports.DEFLATE || mode > exports.UNZIP)
        throw new TypeError("Bad argument");
      this.mode = mode;
      this.init_done = false;
      this.write_in_progress = false;
      this.pending_close = false;
      this.windowBits = 0;
      this.level = 0;
      this.memLevel = 0;
      this.strategy = 0;
      this.dictionary = null;
    }
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      this.windowBits = windowBits;
      this.level = level;
      this.memLevel = memLevel;
      this.strategy = strategy;
      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
        this.windowBits += 16;
      if (this.mode === exports.UNZIP)
        this.windowBits += 32;
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
        this.windowBits = -this.windowBits;
      this.strm = new zstream();
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          var status = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (status !== exports.Z_OK) {
        this._error(status);
        return;
      }
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype._writeCheck = function() {
      if (!this.init_done)
        throw new Error("write before init");
      if (this.mode === exports.NONE)
        throw new Error("already finalized");
      if (this.write_in_progress)
        throw new Error("write already in progress");
      if (this.pending_close)
        throw new Error("close is pending");
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck();
      this.write_in_progress = true;
      var self = this;
      process.nextTick(function() {
        self.write_in_progress = false;
        var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
        self.callback(res[0], res[1]);
        if (self.pending_close)
          self.close();
      });
      return this;
    };
    function bufferSet(data, offset) {
      for (var i = 0; i < data.length; i++) {
        this[offset + i] = data[i];
      }
    }
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck();
      return this._write(flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this.write_in_progress = true;
      if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = new Buffer(0);
        in_len = 0;
        in_off = 0;
      }
      if (out._set)
        out.set = out._set;
      else
        out.set = bufferSet;
      var strm = this.strm;
      strm.avail_in = in_len;
      strm.input = input;
      strm.next_in = in_off;
      strm.avail_out = out_len;
      strm.output = out;
      strm.next_out = out_off;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflate(strm, flush);
          break;
        case exports.UNZIP:
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          var status = zlib_inflate.inflate(strm, flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
        this._error(status);
      }
      this.write_in_progress = false;
      return [strm.avail_in, strm.avail_out];
    };
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports.NONE;
    };
    Zlib.prototype.reset = function() {
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
          var status = zlib_inflate.inflateReset(this.strm);
          break;
      }
      if (status !== exports.Z_OK) {
        this._error(status);
      }
    };
    Zlib.prototype._error = function(status) {
      this.onerror(msg[status] + ': ' + this.strm.msg, status);
      this.write_in_progress = false;
      if (this.pending_close)
        this.close();
    };
    exports.Zlib = Zlib;
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer, req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3/support/isBufferBrowser", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3/util", ["npm:util@0.10.3/support/isBufferBrowser", "npm:inherits@2.0.1", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%')
          return '%';
        if (i >= len)
          return x;
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (isUndefined(global.process)) {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
          array = false,
          braces = ['{', '}'];
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0,
          l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name,
          str,
          desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = req('npm:util@0.10.3/support/isBufferBrowser');
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = req('npm:inherits@2.0.1');
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3", ["npm:util@0.10.3/util"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:util@0.10.3/util');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-util@0.1.0/index", ["npm:util@0.10.3"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('util') : req('npm:util@0.10.3');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-util@0.1.0", ["github:jspm/nodelibs-util@0.1.0/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:jspm/nodelibs-util@0.1.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:assert@1.3.0/assert", ["npm:util@0.10.3"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var util = req('npm:util@0.10.3');
  var pSlice = Array.prototype.slice;
  var hasOwn = Object.prototype.hasOwnProperty;
  var assert = module.exports = ok;
  assert.AssertionError = function AssertionError(options) {
    this.name = 'AssertionError';
    this.actual = options.actual;
    this.expected = options.expected;
    this.operator = options.operator;
    if (options.message) {
      this.message = options.message;
      this.generatedMessage = false;
    } else {
      this.message = getMessage(this);
      this.generatedMessage = true;
    }
    var stackStartFunction = options.stackStartFunction || fail;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, stackStartFunction);
    } else {
      var err = new Error();
      if (err.stack) {
        var out = err.stack;
        var fn_name = stackStartFunction.name;
        var idx = out.indexOf('\n' + fn_name);
        if (idx >= 0) {
          var next_line = out.indexOf('\n', idx + 1);
          out = out.substring(next_line + 1);
        }
        this.stack = out;
      }
    }
  };
  util.inherits(assert.AssertionError, Error);
  function replacer(key, value) {
    if (util.isUndefined(value)) {
      return '' + value;
    }
    if (util.isNumber(value) && !isFinite(value)) {
      return value.toString();
    }
    if (util.isFunction(value) || util.isRegExp(value)) {
      return value.toString();
    }
    return value;
  }
  function truncate(s, n) {
    if (util.isString(s)) {
      return s.length < n ? s : s.slice(0, n);
    } else {
      return s;
    }
  }
  function getMessage(self) {
    return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' + self.operator + ' ' + truncate(JSON.stringify(self.expected, replacer), 128);
  }
  function fail(actual, expected, message, operator, stackStartFunction) {
    throw new assert.AssertionError({
      message: message,
      actual: actual,
      expected: expected,
      operator: operator,
      stackStartFunction: stackStartFunction
    });
  }
  assert.fail = fail;
  function ok(value, message) {
    if (!value)
      fail(value, true, message, '==', assert.ok);
  }
  assert.ok = ok;
  assert.equal = function equal(actual, expected, message) {
    if (actual != expected)
      fail(actual, expected, message, '==', assert.equal);
  };
  assert.notEqual = function notEqual(actual, expected, message) {
    if (actual == expected) {
      fail(actual, expected, message, '!=', assert.notEqual);
    }
  };
  assert.deepEqual = function deepEqual(actual, expected, message) {
    if (!_deepEqual(actual, expected)) {
      fail(actual, expected, message, 'deepEqual', assert.deepEqual);
    }
  };
  function _deepEqual(actual, expected) {
    if (actual === expected) {
      return true;
    } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
      if (actual.length != expected.length)
        return false;
      for (var i = 0; i < actual.length; i++) {
        if (actual[i] !== expected[i])
          return false;
      }
      return true;
    } else if (util.isDate(actual) && util.isDate(expected)) {
      return actual.getTime() === expected.getTime();
    } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
      return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
    } else if (!util.isObject(actual) && !util.isObject(expected)) {
      return actual == expected;
    } else {
      return objEquiv(actual, expected);
    }
  }
  function isArguments(object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }
  function objEquiv(a, b) {
    if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
      return false;
    if (a.prototype !== b.prototype)
      return false;
    if (util.isPrimitive(a) || util.isPrimitive(b)) {
      return a === b;
    }
    var aIsArgs = isArguments(a),
        bIsArgs = isArguments(b);
    if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
      return false;
    if (aIsArgs) {
      a = pSlice.call(a);
      b = pSlice.call(b);
      return _deepEqual(a, b);
    }
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key,
        i;
    if (ka.length != kb.length)
      return false;
    ka.sort();
    kb.sort();
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i])
        return false;
    }
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!_deepEqual(a[key], b[key]))
        return false;
    }
    return true;
  }
  assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (_deepEqual(actual, expected)) {
      fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
    }
  };
  assert.strictEqual = function strictEqual(actual, expected, message) {
    if (actual !== expected) {
      fail(actual, expected, message, '===', assert.strictEqual);
    }
  };
  assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (actual === expected) {
      fail(actual, expected, message, '!==', assert.notStrictEqual);
    }
  };
  function expectedException(actual, expected) {
    if (!actual || !expected) {
      return false;
    }
    if (Object.prototype.toString.call(expected) == '[object RegExp]') {
      return expected.test(actual);
    } else if (actual instanceof expected) {
      return true;
    } else if (expected.call({}, actual) === true) {
      return true;
    }
    return false;
  }
  function _throws(shouldThrow, block, expected, message) {
    var actual;
    if (util.isString(expected)) {
      message = expected;
      expected = null;
    }
    try {
      block();
    } catch (e) {
      actual = e;
    }
    message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
    if (shouldThrow && !actual) {
      fail(actual, expected, 'Missing expected exception' + message);
    }
    if (!shouldThrow && expectedException(actual, expected)) {
      fail(actual, expected, 'Got unwanted exception' + message);
    }
    if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {
      throw actual;
    }
  }
  assert.throws = function(block, error, message) {
    _throws.apply(this, [true].concat(pSlice.call(arguments)));
  };
  assert.doesNotThrow = function(block, message) {
    _throws.apply(this, [false].concat(pSlice.call(arguments)));
  };
  assert.ifError = function(err) {
    if (err) {
      throw err;
    }
  };
  var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for (var key in obj) {
      if (hasOwn.call(obj, key))
        keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:assert@1.3.0", ["npm:assert@1.3.0/assert"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:assert@1.3.0/assert');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-assert@0.1.0/index", ["npm:assert@1.3.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('assert') : req('npm:assert@1.3.0');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-assert@0.1.0", ["github:jspm/nodelibs-assert@0.1.0/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:jspm/nodelibs-assert@0.1.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:browserify-zlib@0.1.4/src/index", ["npm:readable-stream@1.1.13/transform", "npm:browserify-zlib@0.1.4/src/binding", "github:jspm/nodelibs-util@0.1.0", "github:jspm/nodelibs-assert@0.1.0", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var Transform = req('npm:readable-stream@1.1.13/transform');
    var binding = req('npm:browserify-zlib@0.1.4/src/binding');
    var util = req('github:jspm/nodelibs-util@0.1.0');
    var assert = req('github:jspm/nodelibs-assert@0.1.0').ok;
    binding.Z_MIN_WINDOWBITS = 8;
    binding.Z_MAX_WINDOWBITS = 15;
    binding.Z_DEFAULT_WINDOWBITS = 15;
    binding.Z_MIN_CHUNK = 64;
    binding.Z_MAX_CHUNK = Infinity;
    binding.Z_DEFAULT_CHUNK = (16 * 1024);
    binding.Z_MIN_MEMLEVEL = 1;
    binding.Z_MAX_MEMLEVEL = 9;
    binding.Z_DEFAULT_MEMLEVEL = 8;
    binding.Z_MIN_LEVEL = -1;
    binding.Z_MAX_LEVEL = 9;
    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
    Object.keys(binding).forEach(function(k) {
      if (k.match(/^Z/))
        exports[k] = binding[k];
    });
    exports.codes = {
      Z_OK: binding.Z_OK,
      Z_STREAM_END: binding.Z_STREAM_END,
      Z_NEED_DICT: binding.Z_NEED_DICT,
      Z_ERRNO: binding.Z_ERRNO,
      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding.Z_DATA_ERROR,
      Z_MEM_ERROR: binding.Z_MEM_ERROR,
      Z_BUF_ERROR: binding.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding.Z_VERSION_ERROR
    };
    Object.keys(exports.codes).forEach(function(k) {
      exports.codes[exports.codes[k]] = k;
    });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function(o) {
      return new Deflate(o);
    };
    exports.createInflate = function(o) {
      return new Inflate(o);
    };
    exports.createDeflateRaw = function(o) {
      return new DeflateRaw(o);
    };
    exports.createInflateRaw = function(o) {
      return new InflateRaw(o);
    };
    exports.createGzip = function(o) {
      return new Gzip(o);
    };
    exports.createGunzip = function(o) {
      return new Gunzip(o);
    };
    exports.createUnzip = function(o) {
      return new Unzip(o);
    };
    exports.deflate = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports.deflateSync = function(buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports.gzip = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports.gzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports.deflateRaw = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports.deflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports.unzip = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports.unzipSync = function(buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports.inflate = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports.inflateSync = function(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports.gunzip = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports.gunzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports.inflateRaw = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports.inflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [];
      var nread = 0;
      engine.on('error', onError);
      engine.on('end', onEnd);
      engine.end(buffer);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once('readable', flow);
      }
      function onError(err) {
        engine.removeListener('end', onEnd);
        engine.removeListener('readable', flow);
        callback(err);
      }
      function onEnd() {
        var buf = Buffer.concat(buffers, nread);
        buffers = [];
        callback(null, buf);
        engine.close();
      }
    }
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === 'string')
        buffer = new Buffer(buffer);
      if (!Buffer.isBuffer(buffer))
        throw new TypeError('Not a string or buffer');
      var flushFlag = binding.Z_FINISH;
      return engine._processChunk(buffer, flushFlag);
    }
    function Deflate(opts) {
      if (!(this instanceof Deflate))
        return new Deflate(opts);
      Zlib.call(this, opts, binding.DEFLATE);
    }
    function Inflate(opts) {
      if (!(this instanceof Inflate))
        return new Inflate(opts);
      Zlib.call(this, opts, binding.INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip))
        return new Gzip(opts);
      Zlib.call(this, opts, binding.GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip))
        return new Gunzip(opts);
      Zlib.call(this, opts, binding.GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw))
        return new DeflateRaw(opts);
      Zlib.call(this, opts, binding.DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw))
        return new InflateRaw(opts);
      Zlib.call(this, opts, binding.INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip))
        return new Unzip(opts);
      Zlib.call(this, opts, binding.UNZIP);
    }
    function Zlib(opts, mode) {
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
      Transform.call(this, opts);
      if (opts.flush) {
        if (opts.flush !== binding.Z_NO_FLUSH && opts.flush !== binding.Z_PARTIAL_FLUSH && opts.flush !== binding.Z_SYNC_FLUSH && opts.flush !== binding.Z_FULL_FLUSH && opts.flush !== binding.Z_FINISH && opts.flush !== binding.Z_BLOCK) {
          throw new Error('Invalid flush flag: ' + opts.flush);
        }
      }
      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
          throw new Error('Invalid chunk size: ' + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
          throw new Error('Invalid windowBits: ' + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
          throw new Error('Invalid compression level: ' + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
          throw new Error('Invalid memLevel: ' + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
          throw new Error('Invalid strategy: ' + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer.isBuffer(opts.dictionary)) {
          throw new Error('Invalid dictionary: it should be a Buffer instance');
        }
      }
      this._binding = new binding.Zlib(mode);
      var self = this;
      this._hadError = false;
      this._binding.onerror = function(message, errno) {
        self._binding = null;
        self._hadError = true;
        var error = new Error(message);
        error.errno = errno;
        error.code = exports.codes[errno];
        self.emit('error', error);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === 'number')
        level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === 'number')
        strategy = opts.strategy;
      this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = new Buffer(this._chunkSize);
      this._offset = 0;
      this._closed = false;
      this._level = level;
      this._strategy = strategy;
      this.once('end', this.close);
    }
    util.inherits(Zlib, Transform);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
        throw new RangeError('Invalid compression level: ' + level);
      }
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new TypeError('Invalid strategy: ' + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self = this;
        this.flush(binding.Z_SYNC_FLUSH, function() {
          self._binding.params(level, strategy);
          if (!self._hadError) {
            self._level = level;
            self._strategy = strategy;
            if (callback)
              callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function() {
      return this._binding.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(new Buffer(0), '', callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var ws = this._writableState;
      if (typeof kind === 'function' || (kind === void 0 && !callback)) {
        callback = kind;
        kind = binding.Z_FULL_FLUSH;
      }
      if (ws.ended) {
        if (callback)
          process.nextTick(callback);
      } else if (ws.ending) {
        if (callback)
          this.once('end', callback);
      } else if (ws.needDrain) {
        var self = this;
        this.once('drain', function() {
          self.flush(callback);
        });
      } else {
        this._flushFlag = kind;
        this.write(new Buffer(0), '', callback);
      }
    };
    Zlib.prototype.close = function(callback) {
      if (callback)
        process.nextTick(callback);
      if (this._closed)
        return;
      this._closed = true;
      this._binding.close();
      var self = this;
      process.nextTick(function() {
        self.emit('close');
      });
    };
    Zlib.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag;
      var ws = this._writableState;
      var ending = ws.ending || ws.ended;
      var last = ending && (!chunk || ws.length === chunk.length);
      if (!chunk === null && !Buffer.isBuffer(chunk))
        return cb(new Error('invalid input'));
      if (last)
        flushFlag = binding.Z_FINISH;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
        }
      }
      var self = this;
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self = this;
      var async = typeof cb === 'function';
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error;
        this.on('error', function(er) {
          error = er;
        });
        do {
          var res = this._binding.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error;
        }
        var buf = Buffer.concat(buffers, nread);
        this.close();
        return buf;
      }
      var req = this._binding.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (self._hadError)
          return;
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, 'have should not go down');
        if (have > 0) {
          var out = self._buffer.slice(self._offset, self._offset + have);
          self._offset += have;
          if (async) {
            self.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self._offset >= self._chunkSize) {
          availOutBefore = self._chunkSize;
          self._offset = 0;
          self._buffer = new Buffer(self._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += (availInBefore - availInAfter);
          availInBefore = availInAfter;
          if (!async)
            return true;
          var newReq = self._binding.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async)
          return false;
        cb();
      }
    };
    util.inherits(Deflate, Zlib);
    util.inherits(Inflate, Zlib);
    util.inherits(Gzip, Zlib);
    util.inherits(Gunzip, Zlib);
    util.inherits(DeflateRaw, Zlib);
    util.inherits(InflateRaw, Zlib);
    util.inherits(Unzip, Zlib);
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer, req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:browserify-zlib@0.1.4", ["npm:browserify-zlib@0.1.4/src/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:browserify-zlib@0.1.4/src/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-zlib@0.1.0/index", ["npm:browserify-zlib@0.1.4"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('zlib') : req('npm:browserify-zlib@0.1.4');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-zlib@0.1.0", ["github:jspm/nodelibs-zlib@0.1.0/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('github:jspm/nodelibs-zlib@0.1.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/utils/strings", ["npm:pako@0.2.8/lib/utils/common", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var utils = req('npm:pako@0.2.8/lib/utils/common');
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (var q = 0; q < 256; q++) {
      _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
    }
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf,
          c,
          c2,
          m_pos,
          i,
          str_len = str.length,
          buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        if (c < 0x80) {
          buf[i++] = c;
        } else if (c < 0x800) {
          buf[i++] = 0xC0 | (c >>> 6);
          buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
          buf[i++] = 0xE0 | (c >>> 12);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        } else {
          buf[i++] = 0xf0 | (c >>> 18);
          buf[i++] = 0x80 | (c >>> 12 & 0x3f);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65537) {
        if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = '';
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0,
          len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i,
          out,
          c,
          c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 0x80) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 0xfffd;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        while (c_len > 1 && i < len) {
          c = (c << 6) | (buf[i++] & 0x3f);
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 0xfffd;
          continue;
        }
        if (c < 0x10000) {
          utf16buf[out++] = c;
        } else {
          c -= 0x10000;
          utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
          utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return (pos + _utf8len[buf[pos]] > max) ? pos : max;
    };
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/deflate", ["npm:pako@0.2.8/lib/zlib/deflate", "npm:pako@0.2.8/lib/utils/common", "npm:pako@0.2.8/lib/utils/strings", "npm:pako@0.2.8/lib/zlib/messages", "npm:pako@0.2.8/lib/zlib/zstream"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var zlib_deflate = req('npm:pako@0.2.8/lib/zlib/deflate');
  var utils = req('npm:pako@0.2.8/lib/utils/common');
  var strings = req('npm:pako@0.2.8/lib/utils/strings');
  var msg = req('npm:pako@0.2.8/lib/zlib/messages');
  var zstream = req('npm:pako@0.2.8/lib/zlib/zstream');
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  var Deflate = function(options) {
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ''
    }, options || {});
    var opt = this.options;
    if (opt.raw && (opt.windowBits > 0)) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = '';
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
  };
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status,
        _mode;
    if (this.ended) {
      return false;
    }
    _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);
    if (typeof data === 'string') {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
        if (this.options.to === 'string') {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg;
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/zlib/gzheader", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = '';
    this.comment = '';
    this.hcrc = 0;
    this.done = false;
  }
  module.exports = GZheader;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/lib/inflate", ["npm:pako@0.2.8/lib/zlib/inflate", "npm:pako@0.2.8/lib/utils/common", "npm:pako@0.2.8/lib/utils/strings", "npm:pako@0.2.8/lib/zlib/constants", "npm:pako@0.2.8/lib/zlib/messages", "npm:pako@0.2.8/lib/zlib/zstream", "npm:pako@0.2.8/lib/zlib/gzheader", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var zlib_inflate = req('npm:pako@0.2.8/lib/zlib/inflate');
    var utils = req('npm:pako@0.2.8/lib/utils/common');
    var strings = req('npm:pako@0.2.8/lib/utils/strings');
    var c = req('npm:pako@0.2.8/lib/zlib/constants');
    var msg = req('npm:pako@0.2.8/lib/zlib/messages');
    var zstream = req('npm:pako@0.2.8/lib/zlib/zstream');
    var gzheader = req('npm:pako@0.2.8/lib/zlib/gzheader');
    var toString = Object.prototype.toString;
    var Inflate = function(options) {
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ''
      }, options || {});
      var opt = this.options;
      if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if ((opt.windowBits >= 0) && (opt.windowBits < 16) && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = '';
      this.ended = false;
      this.chunks = [];
      this.strm = new zstream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new gzheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
    };
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status,
          _mode;
      var next_out_utf8,
          tail,
          utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);
      if (typeof data === 'string') {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {
            if (this.options.to === 'string') {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === 'string') {
          this.result = this.chunks.join('');
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg;
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8/index", ["npm:pako@0.2.8/lib/utils/common", "npm:pako@0.2.8/lib/deflate", "npm:pako@0.2.8/lib/inflate", "npm:pako@0.2.8/lib/zlib/constants"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var assign = req('npm:pako@0.2.8/lib/utils/common').assign;
  var deflate = req('npm:pako@0.2.8/lib/deflate');
  var inflate = req('npm:pako@0.2.8/lib/inflate');
  var constants = req('npm:pako@0.2.8/lib/zlib/constants');
  var pako = {};
  assign(pako, deflate, inflate, constants);
  module.exports = pako;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pako@0.2.8", ["npm:pako@0.2.8/index"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:pako@0.2.8/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/png", ["npm:qr-image@3.1.0/lib/crc32", "github:jspm/nodelibs-zlib@0.1.0", "npm:pako@0.2.8", "github:jspm/nodelibs-buffer@0.1.0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    "use strict";
    var crc32 = req('npm:qr-image@3.1.0/lib/crc32');
    var PNG_HEAD = Buffer([137, 80, 78, 71, 13, 10, 26, 10]);
    var PNG_IHDR = Buffer([0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0]);
    var PNG_IEND = Buffer([0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]);
    function png(bitmap, stream) {
      var zlib = req('github:jspm/nodelibs-zlib@0.1.0');
      var IHDR = Buffer(25);
      PNG_IHDR.copy(IHDR);
      IHDR.writeUInt32BE(bitmap.size, 8);
      IHDR.writeUInt32BE(bitmap.size, 12);
      IHDR.writeUInt32BE(crc32(IHDR.slice(4, -4)), 21);
      stream.push(PNG_HEAD);
      stream.push(IHDR);
      var IDAT = [Buffer([0, 0, 0, 0, 73, 68, 65, 84])];
      zlib.createDeflate({level: 9}).on('data', function(chunk) {
        IDAT.push(chunk);
      }).on('end', function() {
        IDAT.push(Buffer(4));
        IDAT = Buffer.concat(IDAT);
        IDAT.writeUInt32BE(IDAT.length - 12, 0);
        IDAT.writeUInt32BE(crc32(IDAT.slice(4, -4)), IDAT.length - 4);
        stream.push(IDAT);
        stream.push(PNG_IEND);
        stream.push(null);
      }).end(bitmap.data);
    }
    function png_sync(bitmap) {
      var pako = req('npm:pako@0.2.8');
      var stream = [];
      var IHDR = Buffer(25);
      PNG_IHDR.copy(IHDR);
      IHDR.writeUInt32BE(bitmap.size, 8);
      IHDR.writeUInt32BE(bitmap.size, 12);
      IHDR.writeUInt32BE(crc32(IHDR.slice(4, -4)), 21);
      stream.push(PNG_HEAD);
      stream.push(IHDR);
      var IDAT = Buffer.concat([Buffer([0, 0, 0, 0, 73, 68, 65, 84]), Buffer(pako.deflate(bitmap.data, {level: 9})), Buffer(4)]);
      IDAT.writeUInt32BE(IDAT.length - 12, 0);
      IDAT.writeUInt32BE(crc32(IDAT.slice(4, -4)), IDAT.length - 4);
      stream.push(IDAT);
      stream.push(PNG_IEND);
      return Buffer.concat(stream);
    }
    function bitmap(matrix, size, margin) {
      var N = matrix.length;
      var X = (N + 2 * margin) * size;
      var data = Buffer((X + 1) * X);
      data.fill(255);
      for (var i = 0; i < X; i++) {
        data[i * (X + 1)] = 0;
      }
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (matrix[i][j]) {
            var offset = ((margin + i) * (X + 1) + (margin + j)) * size + 1;
            data.fill(0, offset, offset + size);
            for (var c = 1; c < size; c++) {
              data.copy(data, offset + c * (X + 1), offset, offset + size);
            }
          }
        }
      }
      return {
        data: data,
        size: X
      };
    }
    module.exports = {
      bitmap: bitmap,
      png: png,
      png_sync: png_sync
    };
  })(req('github:jspm/nodelibs-buffer@0.1.0').Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/vector", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function matrix2path(matrix) {
    var N = matrix.length;
    var filled = [];
    for (var row = -1; row <= N; row++) {
      filled[row] = [];
    }
    var path = [];
    for (var row = 0; row < N; row++) {
      for (var col = 0; col < N; col++) {
        if (filled[row][col])
          continue;
        filled[row][col] = 1;
        if (isDark(row, col)) {
          if (!isDark(row - 1, col)) {
            path.push(plot(row, col, 'right'));
          }
        } else {
          if (isDark(row, col - 1)) {
            path.push(plot(row, col, 'down'));
          }
        }
      }
    }
    return path;
    function isDark(row, col) {
      if (row < 0 || col < 0 || row >= N || col >= N)
        return false;
      return !!matrix[row][col];
    }
    function plot(row0, col0, dir) {
      filled[row0][col0] = 1;
      var res = [];
      res.push(['M', col0, row0]);
      var row = row0;
      var col = col0;
      var len = 0;
      do {
        switch (dir) {
          case 'right':
            filled[row][col] = 1;
            if (isDark(row, col)) {
              filled[row - 1][col] = 1;
              if (isDark(row - 1, col)) {
                res.push(['h', len]);
                len = 0;
                dir = 'up';
              } else {
                len++;
                col++;
              }
            } else {
              res.push(['h', len]);
              len = 0;
              dir = 'down';
            }
            break;
          case 'left':
            filled[row - 1][col - 1] = 1;
            if (isDark(row - 1, col - 1)) {
              filled[row][col - 1] = 1;
              if (isDark(row, col - 1)) {
                res.push(['h', -len]);
                len = 0;
                dir = 'down';
              } else {
                len++;
                col--;
              }
            } else {
              res.push(['h', -len]);
              len = 0;
              dir = 'up';
            }
            break;
          case 'down':
            filled[row][col - 1] = 1;
            if (isDark(row, col - 1)) {
              filled[row][col] = 1;
              if (isDark(row, col)) {
                res.push(['v', len]);
                len = 0;
                dir = 'right';
              } else {
                len++;
                row++;
              }
            } else {
              res.push(['v', len]);
              len = 0;
              dir = 'left';
            }
            break;
          case 'up':
            filled[row - 1][col] = 1;
            if (isDark(row - 1, col)) {
              filled[row - 1][col - 1] = 1;
              if (isDark(row - 1, col - 1)) {
                res.push(['v', -len]);
                len = 0;
                dir = 'left';
              } else {
                len++;
                row--;
              }
            } else {
              res.push(['v', -len]);
              len = 0;
              dir = 'right';
            }
            break;
        }
      } while (row != row0 || col != col0);
      return res;
    }
  }
  function pushSVGPath(matrix, stream, margin) {
    matrix2path(matrix).forEach(function(subpath) {
      var res = '';
      for (var k = 0; k < subpath.length; k++) {
        var item = subpath[k];
        switch (item[0]) {
          case 'M':
            res += 'M' + (item[1] + margin) + ' ' + (item[2] + margin);
            break;
          default:
            res += item.join('');
        }
      }
      res += 'z';
      stream.push(res);
    });
  }
  function SVG_object(matrix, margin) {
    var stream = [];
    pushSVGPath(matrix, stream, margin);
    var result = {
      size: matrix.length + 2 * margin,
      path: stream.filter(Boolean).join('')
    };
    return result;
  }
  function SVG(matrix, stream, margin, size) {
    var X = matrix.length + 2 * margin;
    stream.push('<svg xmlns="http://www.w3.org/2000/svg" ');
    if (size > 0) {
      var XY = X * size;
      stream.push('width="' + XY + '" height="' + XY + '" ');
    }
    stream.push('viewBox="0 0 ' + X + ' ' + X + '">');
    stream.push('<path d="');
    pushSVGPath(matrix, stream, margin);
    stream.push('"/></svg>');
    stream.push(null);
  }
  function EPS(matrix, stream, margin) {
    var N = matrix.length;
    var scale = 9;
    var X = (N + 2 * margin) * scale;
    stream.push(['%!PS-Adobe-3.0 EPSF-3.0', '%%BoundingBox: 0 0 ' + X + ' ' + X, '/h { 0 rlineto } bind def', '/v { 0 exch neg rlineto } bind def', '/M { neg ' + (N + margin) + ' add moveto } bind def', '/z { closepath } bind def', scale + ' ' + scale + ' scale', ''].join('\n'));
    matrix2path(matrix).forEach(function(subpath) {
      var res = '';
      for (var k = 0; k < subpath.length; k++) {
        var item = subpath[k];
        switch (item[0]) {
          case 'M':
            res += (item[1] + margin) + ' ' + item[2] + ' M ';
            break;
          default:
            res += item[1] + ' ' + item[0] + ' ';
        }
      }
      res += 'z\n';
      stream.push(res);
    });
    stream.push('fill\n%%EOF\n');
    stream.push(null);
  }
  function PDF(matrix, stream, margin) {
    var N = matrix.length;
    var scale = 9;
    var X = (N + 2 * margin) * scale;
    var data = ['%PDF-1.0\n\n', '1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj\n', '2 0 obj << /Type /Pages /Count 1 /Kids [ 3 0 R ] >> endobj\n'];
    data.push('3 0 obj << /Type /Page /Parent 2 0 R /Resources <<>> ' + '/Contents 4 0 R /MediaBox [ 0 0 ' + X + ' ' + X + ' ] >> endobj\n');
    var path = scale + ' 0 0 ' + scale + ' 0 0 cm\n';
    path += matrix2path(matrix).map(function(subpath) {
      var res = '';
      var x,
          y;
      for (var k = 0; k < subpath.length; k++) {
        var item = subpath[k];
        switch (item[0]) {
          case 'M':
            x = item[1] + margin;
            y = N - item[2] + margin;
            res += x + ' ' + y + ' m ';
            break;
          case 'h':
            x += item[1];
            res += x + ' ' + y + ' l ';
            break;
          case 'v':
            y -= item[1];
            res += x + ' ' + y + ' l ';
            break;
        }
      }
      res += 'h';
      return res;
    }).join('\n');
    path += '\nf\n';
    data.push('4 0 obj << /Length ' + path.length + ' >> stream\n' + path + 'endstream\nendobj\n');
    var xref = 'xref\n0 5\n0000000000 65535 f \n';
    for (var i = 1,
        l = data[0].length; i < 5; i++) {
      xref += ('0000000000' + l).substr(-10) + ' 00000 n \n';
      l += data[i].length;
    }
    data.push(xref, 'trailer << /Root 1 0 R /Size 5 >>\n', 'startxref\n' + l + '\n%%EOF\n');
    stream.push(data.join(''));
    stream.push(null);
  }
  module.exports = {
    svg: SVG,
    eps: EPS,
    pdf: PDF,
    svg_object: SVG_object
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0/lib/qr", ["github:jspm/nodelibs-stream@0.1.0", "npm:qr-image@3.1.0/lib/qr-base", "npm:qr-image@3.1.0/lib/png", "npm:qr-image@3.1.0/lib/vector", "github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var Readable = req('github:jspm/nodelibs-stream@0.1.0').Readable;
    var QR = req('npm:qr-image@3.1.0/lib/qr-base').QR;
    var png = req('npm:qr-image@3.1.0/lib/png');
    var vector = req('npm:qr-image@3.1.0/lib/vector');
    var fn_noop = function() {};
    var BITMAP_OPTIONS = {
      parse_url: false,
      ec_level: 'M',
      size: 5,
      margin: 4,
      customize: null
    };
    var VECTOR_OPTIONS = {
      parse_url: false,
      ec_level: 'M',
      margin: 1,
      size: 0
    };
    function get_options(options, force_type) {
      if (typeof options === 'string') {
        options = {'ec_level': options};
      } else {
        options = options || {};
      }
      var _options = {type: String(force_type || options.type || 'png').toLowerCase()};
      var defaults = _options.type == 'png' ? BITMAP_OPTIONS : VECTOR_OPTIONS;
      for (var k in defaults) {
        _options[k] = k in options ? options[k] : defaults[k];
      }
      return _options;
    }
    function qr_image(text, options) {
      options = get_options(options);
      var matrix = QR(text, options.ec_level, options.parse_url);
      var stream = new Readable();
      stream._read = fn_noop;
      switch (options.type) {
        case 'svg':
        case 'pdf':
        case 'eps':
          process.nextTick(function() {
            vector[options.type](matrix, stream, options.margin, options.size);
          });
          break;
        case 'svgpath':
          process.nextTick(function() {
            var obj = vector.svg_object(matrix, options.margin, options.size);
            stream.push(obj.path);
            stream.push(null);
          });
          break;
        case 'png':
        default:
          process.nextTick(function() {
            var bitmap = png.bitmap(matrix, options.size, options.margin);
            if (options.customize) {
              options.customize(bitmap);
            }
            png.png(bitmap, stream);
          });
      }
      return stream;
    }
    function qr_image_sync(text, options) {
      options = get_options(options);
      var matrix = QR(text, options.ec_level, options.parse_url);
      var result;
      switch (options.type) {
        case 'svg':
        case 'pdf':
        case 'eps':
          var stream = [];
          vector[options.type](matrix, stream, options.margin, options.size);
          result = stream.filter(Boolean).join('');
          break;
        case 'png':
        default:
          var bitmap = png.bitmap(matrix, options.size, options.margin);
          if (options.customize) {
            options.customize(bitmap);
          }
          result = png.png_sync(bitmap);
      }
      return result;
    }
    function svg_object(text, options) {
      options = get_options(options, 'svg');
      var matrix = QR(text, options.ec_level);
      return vector.svg_object(matrix, options.margin);
    }
    module.exports = {
      matrix: QR,
      image: qr_image,
      imageSync: qr_image_sync,
      svgObject: svg_object
    };
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:qr-image@3.1.0", ["npm:qr-image@3.1.0/lib/qr"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:qr-image@3.1.0/lib/qr');
  global.define = __define;
  return module.exports;
});

System.register('libraries/qr-image/qr-image.js', ['github:angular/bower-angular@1.4.7', 'npm:qr-image@3.1.0'], function (_export) {
  'use strict';

  var angular, qrImage;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_npmQrImage310) {
      qrImage = _npmQrImage310['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.qr-image', []).factory('qrImage', /*@ngInject*/function () {
        return qrImage;
      }));
    }
  };
});

System.registerDynamic("npm:ramda@0.17.1/dist/ramda", ["github:jspm/nodelibs-process@0.1.2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      'use strict';
      var __ = {'@@functional/placeholder': true};
      var _arity = function _arity(n, fn) {
        switch (n) {
          case 0:
            return function() {
              return fn.apply(this, arguments);
            };
          case 1:
            return function(a0) {
              return fn.apply(this, arguments);
            };
          case 2:
            return function(a0, a1) {
              return fn.apply(this, arguments);
            };
          case 3:
            return function(a0, a1, a2) {
              return fn.apply(this, arguments);
            };
          case 4:
            return function(a0, a1, a2, a3) {
              return fn.apply(this, arguments);
            };
          case 5:
            return function(a0, a1, a2, a3, a4) {
              return fn.apply(this, arguments);
            };
          case 6:
            return function(a0, a1, a2, a3, a4, a5) {
              return fn.apply(this, arguments);
            };
          case 7:
            return function(a0, a1, a2, a3, a4, a5, a6) {
              return fn.apply(this, arguments);
            };
          case 8:
            return function(a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.apply(this, arguments);
            };
          case 9:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.apply(this, arguments);
            };
          case 10:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.apply(this, arguments);
            };
          default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
      };
      var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
      };
      var _complement = function _complement(f) {
        return function() {
          return !f.apply(this, arguments);
        };
      };
      var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
          result[result.length] = set1[idx];
          idx += 1;
        }
        idx = 0;
        while (idx < len2) {
          result[result.length] = set2[idx];
          idx += 1;
        }
        return result;
      };
      var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0,
            len = list.length;
        while (idx < len) {
          if (pred(x, list[idx])) {
            return true;
          }
          idx += 1;
        }
        return false;
      };
      var _curry1 = function _curry1(fn) {
        return function f1(a) {
          if (arguments.length === 0) {
            return f1;
          } else if (a != null && a['@@functional/placeholder'] === true) {
            return f1;
          } else {
            return fn.apply(this, arguments);
          }
        };
      };
      var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
          var n = arguments.length;
          if (n === 0) {
            return f2;
          } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
            return f2;
          } else if (n === 1) {
            return _curry1(function(b) {
              return fn(a, b);
            });
          } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
            return f2;
          } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
            return _curry1(function(a) {
              return fn(a, b);
            });
          } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
            return _curry1(function(b) {
              return fn(a, b);
            });
          } else {
            return fn(a, b);
          }
        };
      };
      var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
          var n = arguments.length;
          if (n === 0) {
            return f3;
          } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
            return f3;
          } else if (n === 1) {
            return _curry2(function(b, c) {
              return fn(a, b, c);
            });
          } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
            return f3;
          } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
            return _curry2(function(a, c) {
              return fn(a, b, c);
            });
          } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
            return _curry2(function(b, c) {
              return fn(a, b, c);
            });
          } else if (n === 2) {
            return _curry1(function(c) {
              return fn(a, b, c);
            });
          } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
            return f3;
          } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
            return _curry2(function(a, b) {
              return fn(a, b, c);
            });
          } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
            return _curry2(function(a, c) {
              return fn(a, b, c);
            });
          } else if (n === 3 && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
            return _curry2(function(b, c) {
              return fn(a, b, c);
            });
          } else if (n === 3 && a != null && a['@@functional/placeholder'] === true) {
            return _curry1(function(a) {
              return fn(a, b, c);
            });
          } else if (n === 3 && b != null && b['@@functional/placeholder'] === true) {
            return _curry1(function(b) {
              return fn(a, b, c);
            });
          } else if (n === 3 && c != null && c['@@functional/placeholder'] === true) {
            return _curry1(function(c) {
              return fn(a, b, c);
            });
          } else {
            return fn(a, b, c);
          }
        };
      };
      var _curryN = function _curryN(length, received, fn) {
        return function() {
          var combined = [];
          var argsIdx = 0;
          var left = length;
          var combinedIdx = 0;
          while (combinedIdx < received.length || argsIdx < arguments.length) {
            var result;
            if (combinedIdx < received.length && (received[combinedIdx] == null || received[combinedIdx]['@@functional/placeholder'] !== true || argsIdx >= arguments.length)) {
              result = received[combinedIdx];
            } else {
              result = arguments[argsIdx];
              argsIdx += 1;
            }
            combined[combinedIdx] = result;
            if (result == null || result['@@functional/placeholder'] !== true) {
              left -= 1;
            }
            combinedIdx += 1;
          }
          return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
      };
      var _filter = function _filter(fn, list) {
        var idx = 0,
            len = list.length,
            result = [];
        while (idx < len) {
          if (fn(list[idx])) {
            result[result.length] = list[idx];
          }
          idx += 1;
        }
        return result;
      };
      var _forceReduced = function _forceReduced(x) {
        return {
          '@@transducer/value': x,
          '@@transducer/reduced': true
        };
      };
      var _functionsWith = function _functionsWith(fn) {
        return function(obj) {
          return _filter(function(key) {
            return typeof obj[key] === 'function';
          }, fn(obj));
        };
      };
      var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      };
      var _identity = function _identity(x) {
        return x;
      };
      var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
      };
      var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
      };
      var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
      };
      var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
      };
      var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
      };
      var _map = function _map(fn, list) {
        var idx = 0,
            len = list.length,
            result = Array(len);
        while (idx < len) {
          result[idx] = fn(list[idx]);
          idx += 1;
        }
        return result;
      };
      var _pipe = function _pipe(f, g) {
        return function() {
          return g.call(this, f.apply(this, arguments));
        };
      };
      var _pipeP = function _pipeP(f, g) {
        return function() {
          var ctx = this;
          return f.apply(ctx, arguments).then(function(x) {
            return g.call(ctx, x);
          });
        };
      };
      var _quote = function _quote(s) {
        return '"' + s.replace(/"/g, '\\"') + '"';
      };
      var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
          '@@transducer/value': x,
          '@@transducer/reduced': true
        };
      };
      var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
          case 1:
            return _slice(args, 0, args.length);
          case 2:
            return _slice(args, from, args.length);
          default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
              list[idx] = args[from + idx];
              idx += 1;
            }
            return list;
        }
      };
      var _toISOString = function() {
        var pad = function pad(n) {
          return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
          return d.toISOString();
        } : function _toISOString(d) {
          return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
      }();
      var _xdropRepeatsWith = function() {
        function XDropRepeatsWith(pred, xf) {
          this.xf = xf;
          this.pred = pred;
          this.lastValue = undefined;
          this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function() {
          return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function(result) {
          return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function(result, input) {
          var sameAsLast = false;
          if (!this.seenFirstValue) {
            this.seenFirstValue = true;
          } else if (this.pred(this.lastValue, input)) {
            sameAsLast = true;
          }
          this.lastValue = input;
          return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
          return new XDropRepeatsWith(pred, xf);
        });
      }();
      var _xfBase = {
        init: function() {
          return this.xf['@@transducer/init']();
        },
        result: function(result) {
          return this.xf['@@transducer/result'](result);
        }
      };
      var _xfilter = function() {
        function XFilter(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function(result, input) {
          return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
          return new XFilter(f, xf);
        });
      }();
      var _xfind = function() {
        function XFind(f, xf) {
          this.xf = xf;
          this.f = f;
          this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function(result) {
          if (!this.found) {
            result = this.xf['@@transducer/step'](result, void 0);
          }
          return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function(result, input) {
          if (this.f(input)) {
            this.found = true;
            result = _reduced(this.xf['@@transducer/step'](result, input));
          }
          return result;
        };
        return _curry2(function _xfind(f, xf) {
          return new XFind(f, xf);
        });
      }();
      var _xfindIndex = function() {
        function XFindIndex(f, xf) {
          this.xf = xf;
          this.f = f;
          this.idx = -1;
          this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function(result) {
          if (!this.found) {
            result = this.xf['@@transducer/step'](result, -1);
          }
          return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function(result, input) {
          this.idx += 1;
          if (this.f(input)) {
            this.found = true;
            result = _reduced(this.xf['@@transducer/step'](result, this.idx));
          }
          return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
          return new XFindIndex(f, xf);
        });
      }();
      var _xfindLast = function() {
        function XFindLast(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function(result) {
          return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function(result, input) {
          if (this.f(input)) {
            this.last = input;
          }
          return result;
        };
        return _curry2(function _xfindLast(f, xf) {
          return new XFindLast(f, xf);
        });
      }();
      var _xfindLastIndex = function() {
        function XFindLastIndex(f, xf) {
          this.xf = xf;
          this.f = f;
          this.idx = -1;
          this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function(result) {
          return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function(result, input) {
          this.idx += 1;
          if (this.f(input)) {
            this.lastIdx = this.idx;
          }
          return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
          return new XFindLastIndex(f, xf);
        });
      }();
      var _xmap = function() {
        function XMap(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function(result, input) {
          return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
          return new XMap(f, xf);
        });
      }();
      var _xtake = function() {
        function XTake(n, xf) {
          this.xf = xf;
          this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function(result, input) {
          if (this.n === 0) {
            return _reduced(result);
          } else {
            this.n -= 1;
            return this.xf['@@transducer/step'](result, input);
          }
        };
        return _curry2(function _xtake(n, xf) {
          return new XTake(n, xf);
        });
      }();
      var _xtakeWhile = function() {
        function XTakeWhile(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function(result, input) {
          return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
          return new XTakeWhile(f, xf);
        });
      }();
      var _xwrap = function() {
        function XWrap(fn) {
          this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function() {
          throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function(acc) {
          return acc;
        };
        XWrap.prototype['@@transducer/step'] = function(acc, x) {
          return this.f(acc, x);
        };
        return function _xwrap(fn) {
          return new XWrap(fn);
        };
      }();
      var add = _curry2(function add(a, b) {
        return a + b;
      });
      var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
          return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
      });
      var always = _curry1(function always(val) {
        return function() {
          return val;
        };
      });
      var aperture = _curry2(function aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
          acc[idx] = _slice(list, idx, idx + n);
          idx += 1;
        }
        return acc;
      });
      var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
      });
      var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
      });
      var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
          result[p] = obj[p];
        }
        result[prop] = val;
        return result;
      });
      var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
          case 0:
            return obj;
          case 1:
            return assoc(path[0], val, obj);
          default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
      });
      var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function() {
          return fn.apply(thisObj, arguments);
        });
      });
      var both = _curry2(function both(f, g) {
        return function _both() {
          return f.apply(this, arguments) && g.apply(this, arguments);
        };
      });
      var comparator = _curry1(function comparator(pred) {
        return function(a, b) {
          return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
      });
      var complement = _curry1(_complement);
      var cond = _curry1(function cond(pairs) {
        return function() {
          var idx = 0;
          while (idx < pairs.length) {
            if (pairs[idx][0].apply(this, arguments)) {
              return pairs[idx][1].apply(this, arguments);
            }
            idx += 1;
          }
        };
      });
      var containsWith = _curry3(_containsWith);
      var countBy = _curry2(function countBy(fn, list) {
        var counts = {};
        var len = list.length;
        var idx = 0;
        while (idx < len) {
          var key = fn(list[idx]);
          counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
          idx += 1;
        }
        return counts;
      });
      var createMapEntry = _curry2(function createMapEntry(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
      });
      var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
          return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
      });
      var dec = add(-1);
      var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null ? d : v;
      });
      var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        var containsPred = containsWith(pred);
        while (idx < firstLen) {
          if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {
            out[out.length] = first[idx];
          }
          idx += 1;
        }
        return out;
      });
      var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
          if (p !== prop) {
            result[p] = obj[p];
          }
        }
        return result;
      });
      var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
          case 0:
            return obj;
          case 1:
            return dissoc(path[0], obj);
          default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
      });
      var divide = _curry2(function divide(a, b) {
        return a / b;
      });
      var dropLastWhile = _curry2(function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
          idx -= 1;
        }
        return _slice(list, 0, idx + 1);
      });
      var either = _curry2(function either(f, g) {
        return function _either() {
          return f.apply(this, arguments) || g.apply(this, arguments);
        };
      });
      var empty = _curry1(function empty(x) {
        if (x != null && typeof x.empty === 'function') {
          return x.empty();
        } else if (x != null && typeof x.constructor != null && typeof x.constructor.empty === 'function') {
          return x.constructor.empty();
        } else {
          switch (Object.prototype.toString.call(x)) {
            case '[object Array]':
              return [];
            case '[object Object]':
              return {};
            case '[object String]':
              return '';
          }
        }
      });
      var evolve = _curry2(function evolve(transformations, object) {
        var transformation,
            key,
            type,
            result = {};
        for (key in object) {
          transformation = transformations[key];
          type = typeof transformation;
          result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
      });
      var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0,
            len = pairs.length,
            out = {};
        while (idx < len) {
          if (_isArray(pairs[idx]) && pairs[idx].length) {
            out[pairs[idx][0]] = pairs[idx][1];
          }
          idx += 1;
        }
        return out;
      });
      var gt = _curry2(function gt(a, b) {
        return a > b;
      });
      var gte = _curry2(function gte(a, b) {
        return a >= b;
      });
      var has = _curry2(_has);
      var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
      });
      var identical = _curry2(function identical(a, b) {
        if (a === b) {
          return a !== 0 || 1 / a === 1 / b;
        } else {
          return a !== a && b !== b;
        }
      });
      var identity = _curry1(_identity);
      var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
          return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
      });
      var inc = add(1);
      var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
      });
      var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
      });
      var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
      });
      var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
          return true;
        }
        if (!x) {
          return false;
        }
        if (typeof x !== 'object') {
          return false;
        }
        if (x instanceof String) {
          return false;
        }
        if (x.nodeType === 1) {
          return !!x.length;
        }
        if (x.length === 0) {
          return true;
        }
        if (x.length > 0) {
          return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
      });
      var isEmpty = _curry1(function isEmpty(list) {
        return Object(list).length === 0;
      });
      var isNil = _curry1(function isNil(x) {
        return x == null;
      });
      var keys = function() {
        var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
        var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
        var contains = function contains(list, item) {
          var idx = 0;
          while (idx < list.length) {
            if (list[idx] === item) {
              return true;
            }
            idx += 1;
          }
          return false;
        };
        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
          return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
          if (Object(obj) !== obj) {
            return [];
          }
          var prop,
              ks = [],
              nIdx;
          for (prop in obj) {
            if (_has(prop, obj)) {
              ks[ks.length] = prop;
            }
          }
          if (hasEnumBug) {
            nIdx = nonEnumerableProps.length - 1;
            while (nIdx >= 0) {
              prop = nonEnumerableProps[nIdx];
              if (_has(prop, obj) && !contains(ks, prop)) {
                ks[ks.length] = prop;
              }
              nIdx -= 1;
            }
          }
          return ks;
        });
      }();
      var keysIn = _curry1(function keysIn(obj) {
        var prop,
            ks = [];
        for (prop in obj) {
          ks[ks.length] = prop;
        }
        return ks;
      });
      var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
      });
      var lt = _curry2(function lt(a, b) {
        return a < b;
      });
      var lte = _curry2(function lte(a, b) {
        return a <= b;
      });
      var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0,
            len = list.length,
            result = [],
            tuple = [acc];
        while (idx < len) {
          tuple = fn(tuple[0], list[idx]);
          result[idx] = tuple[1];
          idx += 1;
        }
        return [tuple[0], result];
      });
      var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1,
            result = [],
            tuple = [acc];
        while (idx >= 0) {
          tuple = fn(tuple[0], list[idx]);
          result[idx] = tuple[1];
          idx -= 1;
        }
        return [tuple[0], result];
      });
      var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
      });
      var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
          return NaN;
        }
        if (!_isInteger(p) || p < 1) {
          return NaN;
        }
        return (m % p + p) % p;
      });
      var max = _curry2(function max(a, b) {
        return b > a ? b : a;
      });
      var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
      });
      var merge = _curry2(function merge(a, b) {
        var result = {};
        var ks = keys(a);
        var idx = 0;
        while (idx < ks.length) {
          result[ks[idx]] = a[ks[idx]];
          idx += 1;
        }
        ks = keys(b);
        idx = 0;
        while (idx < ks.length) {
          result[ks[idx]] = b[ks[idx]];
          idx += 1;
        }
        return result;
      });
      var min = _curry2(function min(a, b) {
        return b < a ? b : a;
      });
      var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
      });
      var modulo = _curry2(function modulo(a, b) {
        return a % b;
      });
      var multiply = _curry2(function multiply(a, b) {
        return a * b;
      });
      var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
          case 0:
            return function() {
              return fn.call(this);
            };
          case 1:
            return function(a0) {
              return fn.call(this, a0);
            };
          case 2:
            return function(a0, a1) {
              return fn.call(this, a0, a1);
            };
          case 3:
            return function(a0, a1, a2) {
              return fn.call(this, a0, a1, a2);
            };
          case 4:
            return function(a0, a1, a2, a3) {
              return fn.call(this, a0, a1, a2, a3);
            };
          case 5:
            return function(a0, a1, a2, a3, a4) {
              return fn.call(this, a0, a1, a2, a3, a4);
            };
          case 6:
            return function(a0, a1, a2, a3, a4, a5) {
              return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
          case 7:
            return function(a0, a1, a2, a3, a4, a5, a6) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
          case 8:
            return function(a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
          case 9:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
          case 10:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
          default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
      });
      var negate = _curry1(function negate(n) {
        return -n;
      });
      var not = _curry1(function not(a) {
        return !a;
      });
      var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
      });
      var nthArg = _curry1(function nthArg(n) {
        return function() {
          return nth(n, arguments);
        };
      });
      var nthChar = _curry2(function nthChar(n, str) {
        return str.charAt(n < 0 ? str.length + n : n);
      });
      var nthCharCode = _curry2(function nthCharCode(n, str) {
        return str.charCodeAt(n < 0 ? str.length + n : n);
      });
      var of = _curry1(function of(x) {
        return [x];
      });
      var once = _curry1(function once(fn) {
        var called = false,
            result;
        return function() {
          if (called) {
            return result;
          }
          called = true;
          result = fn.apply(this, arguments);
          return result;
        };
      });
      var over = function() {
        var Identity = function(x) {
          return {
            value: x,
            map: function(f) {
              return Identity(f(x));
            }
          };
        };
        return _curry3(function over(lens, f, x) {
          return lens(function(y) {
            return Identity(f(y));
          })(x).value;
        });
      }();
      var path = _curry2(function path(paths, obj) {
        if (obj == null) {
          return;
        } else {
          var val = obj;
          for (var idx = 0,
              len = paths.length; idx < len && val != null; idx += 1) {
            val = val[paths[idx]];
          }
          return val;
        }
      });
      var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
          if (names[idx] in obj) {
            result[names[idx]] = obj[names[idx]];
          }
          idx += 1;
        }
        return result;
      });
      var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
          var name = names[idx];
          result[name] = obj[name];
          idx += 1;
        }
        return result;
      });
      var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
          if (test(obj[prop], prop, obj)) {
            result[prop] = obj[prop];
          }
        }
        return result;
      });
      var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
      });
      var prop = _curry2(function prop(p, obj) {
        return obj[p];
      });
      var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
      });
      var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
      });
      var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
          out[idx] = obj[ps[idx]];
          idx += 1;
        }
        return out;
      });
      var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
          throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
          result.push(n);
          n += 1;
        }
        return result;
      });
      var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
          acc = fn(acc, list[idx]);
          idx -= 1;
        }
        return acc;
      });
      var reduced = _curry1(_reduced);
      var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
      });
      var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
      });
      var reverse = _curry1(function reverse(list) {
        return _slice(list).reverse();
      });
      var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0,
            len = list.length,
            result = [acc];
        while (idx < len) {
          acc = fn(acc, list[idx]);
          result[idx + 1] = acc;
          idx += 1;
        }
        return result;
      });
      var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
      });
      var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
      });
      var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function(a, b) {
          var aa = fn(a);
          var bb = fn(b);
          return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
      });
      var subtract = _curry2(function subtract(a, b) {
        return a - b;
      });
      var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
          idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
      });
      var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
      });
      var test = _curry2(function test(pattern, str) {
        return _cloneRegExp(pattern).test(str);
      });
      var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var list = new Array(len);
        var idx = 0;
        while (idx < len) {
          list[idx] = fn(idx);
          idx += 1;
        }
        return list;
      });
      var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
          if (_has(prop, obj)) {
            pairs[pairs.length] = [prop, obj[prop]];
          }
        }
        return pairs;
      });
      var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
          pairs[pairs.length] = [prop, obj[prop]];
        }
        return pairs;
      });
      var trim = function() {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
          return _curry1(function trim(str) {
            var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
            var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
            return str.replace(beginRx, '').replace(endRx, '');
          });
        } else {
          return _curry1(function trim(str) {
            return str.trim();
          });
        }
      }();
      var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
      });
      var unapply = _curry1(function unapply(fn) {
        return function() {
          return fn(_slice(arguments));
        };
      });
      var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
      });
      var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function() {
          var currentDepth = 1;
          var value = fn;
          var idx = 0;
          var endIdx;
          while (currentDepth <= depth && typeof value === 'function') {
            endIdx = currentDepth === depth ? arguments.length : idx + value.length;
            value = value.apply(this, _slice(arguments, idx, endIdx));
            currentDepth += 1;
            idx = endIdx;
          }
          return value;
        });
      });
      var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
          result[result.length] = pair[0];
          pair = fn(pair[1]);
        }
        return result;
      });
      var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0,
            len = list.length;
        var result = [],
            item;
        while (idx < len) {
          item = list[idx];
          if (!_containsWith(pred, item, result)) {
            result[result.length] = item;
          }
          idx += 1;
        }
        return result;
      });
      var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
      });
      var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
          vals[idx] = obj[props[idx]];
          idx += 1;
        }
        return vals;
      });
      var valuesIn = _curry1(function valuesIn(obj) {
        var prop,
            vs = [];
        for (prop in obj) {
          vs[vs.length] = obj[prop];
        }
        return vs;
      });
      var view = function() {
        var Const = function(x) {
          return {
            value: x,
            map: function() {
              return this;
            }
          };
        };
        return _curry2(function view(lens, x) {
          return lens(Const)(x).value;
        });
      }();
      var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
          if (_has(prop, spec) && !spec[prop](testObj[prop])) {
            return false;
          }
        }
        return true;
      });
      var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function() {
          return wrapper.apply(this, _concat([fn], arguments));
        });
      });
      var xprod = _curry2(function xprod(a, b) {
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
          j = 0;
          while (j < jlen) {
            result[result.length] = [a[idx], b[j]];
            j += 1;
          }
          idx += 1;
        }
        return result;
      });
      var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
          rv[idx] = [a[idx], b[idx]];
          idx += 1;
        }
        return rv;
      });
      var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0,
            len = keys.length,
            out = {};
        while (idx < len) {
          out[keys[idx]] = values[idx];
          idx += 1;
        }
        return out;
      });
      var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [],
            idx = 0,
            len = Math.min(a.length, b.length);
        while (idx < len) {
          rv[idx] = fn(a[idx], b[idx]);
          idx += 1;
        }
        return rv;
      });
      var F = always(false);
      var T = always(true);
      var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function() {
          var length = arguments.length;
          if (length === 0) {
            return fn();
          }
          var obj = arguments[length - 1];
          return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
      };
      var _clone = function _clone(value, refFrom, refTo) {
        var copy = function copy(copiedValue) {
          var len = refFrom.length;
          var idx = 0;
          while (idx < len) {
            if (value === refFrom[idx]) {
              return refTo[idx];
            }
            idx += 1;
          }
          refFrom[idx + 1] = value;
          refTo[idx + 1] = copiedValue;
          for (var key in value) {
            copiedValue[key] = _clone(value[key], refFrom, refTo);
          }
          return copiedValue;
        };
        switch (type(value)) {
          case 'Object':
            return copy({});
          case 'Array':
            return copy([]);
          case 'Date':
            return new Date(value);
          case 'RegExp':
            return _cloneRegExp(value);
          default:
            return value;
        }
      };
      var _createPartialApplicator = function _createPartialApplicator(concat) {
        return function(fn) {
          var args = _slice(arguments, 1);
          return _arity(Math.max(0, fn.length - args.length), function() {
            return fn.apply(this, concat(args, arguments));
          });
        };
      };
      var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function() {
          var length = arguments.length;
          if (length === 0) {
            return fn();
          }
          var obj = arguments[length - 1];
          if (!_isArray(obj)) {
            var args = _slice(arguments, 0, length - 1);
            if (typeof obj[methodname] === 'function') {
              return obj[methodname].apply(obj, args);
            }
            if (_isTransformer(obj)) {
              var transducer = xf.apply(null, args);
              return transducer(obj);
            }
          }
          return fn.apply(this, arguments);
        };
      };
      var _equals = function _equals(a, b, stackA, stackB) {
        var typeA = type(a);
        if (typeA !== type(b)) {
          return false;
        }
        if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
          return typeof a === 'object' ? typeof b === 'object' && identical(a.valueOf(), b.valueOf()) : identical(a, b);
        }
        if (identical(a, b)) {
          return true;
        }
        if (typeA === 'RegExp') {
          return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;
        }
        if (Object(a) === a) {
          if (typeA === 'Date' && a.getTime() !== b.getTime()) {
            return false;
          }
          var keysA = keys(a);
          if (keysA.length !== keys(b).length) {
            return false;
          }
          var idx = stackA.length - 1;
          while (idx >= 0) {
            if (stackA[idx] === a) {
              return stackB[idx] === b;
            }
            idx -= 1;
          }
          stackA[stackA.length] = a;
          stackB[stackB.length] = b;
          idx = keysA.length - 1;
          while (idx >= 0) {
            var key = keysA[idx];
            if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
              return false;
            }
            idx -= 1;
          }
          stackA.pop();
          stackB.pop();
          return true;
        }
        return false;
      };
      var _hasMethod = function _hasMethod(methodName, obj) {
        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
      };
      var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
          var value,
              result = [],
              idx = 0,
              j,
              ilen = list.length,
              jlen;
          while (idx < ilen) {
            if (isArrayLike(list[idx])) {
              value = recursive ? flatt(list[idx]) : list[idx];
              j = 0;
              jlen = value.length;
              while (j < jlen) {
                result[result.length] = value[j];
                j += 1;
              }
            } else {
              result[result.length] = list[idx];
            }
            idx += 1;
          }
          return result;
        };
      };
      var _reduce = function() {
        function _arrayReduce(xf, acc, list) {
          var idx = 0,
              len = list.length;
          while (idx < len) {
            acc = xf['@@transducer/step'](acc, list[idx]);
            if (acc && acc['@@transducer/reduced']) {
              acc = acc['@@transducer/value'];
              break;
            }
            idx += 1;
          }
          return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
          var step = iter.next();
          while (!step.done) {
            acc = xf['@@transducer/step'](acc, step.value);
            if (acc && acc['@@transducer/reduced']) {
              acc = acc['@@transducer/value'];
              break;
            }
            step = iter.next();
          }
          return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
          return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
          if (typeof fn === 'function') {
            fn = _xwrap(fn);
          }
          if (isArrayLike(list)) {
            return _arrayReduce(fn, acc, list);
          }
          if (typeof list.reduce === 'function') {
            return _methodReduce(fn, acc, list);
          }
          if (list[symIterator] != null) {
            return _iterableReduce(fn, acc, list[symIterator]());
          }
          if (typeof list.next === 'function') {
            return _iterableReduce(fn, acc, list);
          }
          throw new TypeError('reduce: list must be array or iterable');
        };
      }();
      var _stepCat = function() {
        var _stepCatArray = {
          '@@transducer/init': Array,
          '@@transducer/step': function(xs, x) {
            return _concat(xs, [x]);
          },
          '@@transducer/result': _identity
        };
        var _stepCatString = {
          '@@transducer/init': String,
          '@@transducer/step': function(a, b) {
            return a + b;
          },
          '@@transducer/result': _identity
        };
        var _stepCatObject = {
          '@@transducer/init': Object,
          '@@transducer/step': function(result, input) {
            return merge(result, isArrayLike(input) ? createMapEntry(input[0], input[1]) : input);
          },
          '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
          if (_isTransformer(obj)) {
            return obj;
          }
          if (isArrayLike(obj)) {
            return _stepCatArray;
          }
          if (typeof obj === 'string') {
            return _stepCatString;
          }
          if (typeof obj === 'object') {
            return _stepCatObject;
          }
          throw new Error('Cannot create transformer for ' + obj);
        };
      }();
      var _xall = function() {
        function XAll(f, xf) {
          this.xf = xf;
          this.f = f;
          this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function(result) {
          if (this.all) {
            result = this.xf['@@transducer/step'](result, true);
          }
          return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function(result, input) {
          if (!this.f(input)) {
            this.all = false;
            result = _reduced(this.xf['@@transducer/step'](result, false));
          }
          return result;
        };
        return _curry2(function _xall(f, xf) {
          return new XAll(f, xf);
        });
      }();
      var _xany = function() {
        function XAny(f, xf) {
          this.xf = xf;
          this.f = f;
          this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function(result) {
          if (!this.any) {
            result = this.xf['@@transducer/step'](result, false);
          }
          return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function(result, input) {
          if (this.f(input)) {
            this.any = true;
            result = _reduced(this.xf['@@transducer/step'](result, true));
          }
          return result;
        };
        return _curry2(function _xany(f, xf) {
          return new XAny(f, xf);
        });
      }();
      var _xdrop = function() {
        function XDrop(n, xf) {
          this.xf = xf;
          this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function(result, input) {
          if (this.n > 0) {
            this.n -= 1;
            return result;
          }
          return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
          return new XDrop(n, xf);
        });
      }();
      var _xdropWhile = function() {
        function XDropWhile(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function(result, input) {
          if (this.f) {
            if (this.f(input)) {
              return result;
            }
            this.f = null;
          }
          return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
          return new XDropWhile(f, xf);
        });
      }();
      var _xgroupBy = function() {
        function XGroupBy(f, xf) {
          this.xf = xf;
          this.f = f;
          this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function(result) {
          var key;
          for (key in this.inputs) {
            if (_has(key, this.inputs)) {
              result = this.xf['@@transducer/step'](result, this.inputs[key]);
              if (result['@@transducer/reduced']) {
                result = result['@@transducer/value'];
                break;
              }
            }
          }
          return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function(result, input) {
          var key = this.f(input);
          this.inputs[key] = this.inputs[key] || [key, []];
          this.inputs[key][1] = append(input, this.inputs[key][1]);
          return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
          return new XGroupBy(f, xf);
        });
      }();
      var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function() {
          var idx = 0;
          var origFn = arguments[0];
          var list = arguments[arguments.length - 1];
          var args = _slice(arguments);
          args[0] = function() {
            var result = origFn.apply(this, _concat(arguments, [idx, list]));
            idx += 1;
            return result;
          };
          return fn.apply(this, args);
        });
      });
      var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
          if (!fn(list[idx])) {
            return false;
          }
          idx += 1;
        }
        return true;
      }));
      var and = _curry2(function and(a, b) {
        return _hasMethod('and', a) ? a.and(b) : a && b;
      });
      var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
          if (fn(list[idx])) {
            return true;
          }
          idx += 1;
        }
        return false;
      }));
      var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
      });
      var clone = _curry1(function clone(value) {
        return _clone(value, [], []);
      });
      var concat = _curry2(function concat(set1, set2) {
        if (_isArray(set2)) {
          return _concat(set1, set2);
        } else if (_hasMethod('concat', set1)) {
          return set1.concat(set2);
        } else {
          throw new TypeError('can\'t concat ' + typeof set1);
        }
      });
      var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
      });
      var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0,
            len = list.length;
        while (idx < len && pred(list[idx])) {
          idx += 1;
        }
        return _slice(list, idx);
      }));
      var equals = _curry2(function equals(a, b) {
        return _hasMethod('equals', a) ? a.equals(b) : _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
      });
      var filter = _curry2(_dispatchable('filter', _xfilter, _filter));
      var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
          if (fn(list[idx])) {
            return list[idx];
          }
          idx += 1;
        }
      }));
      var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
          if (fn(list[idx])) {
            return idx;
          }
          idx += 1;
        }
        return -1;
      }));
      var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
          if (fn(list[idx])) {
            return list[idx];
          }
          idx -= 1;
        }
      }));
      var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
          if (fn(list[idx])) {
            return idx;
          }
          idx -= 1;
        }
        return -1;
      }));
      var flatten = _curry1(_makeFlat(true));
      var flip = _curry1(function flip(fn) {
        return curry(function(a, b) {
          var args = _slice(arguments);
          args[0] = b;
          args[1] = a;
          return fn.apply(this, args);
        });
      });
      var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
          fn(list[idx]);
          idx += 1;
        }
        return list;
      }));
      var functions = _curry1(_functionsWith(keys));
      var functionsIn = _curry1(_functionsWith(keysIn));
      var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
        return _reduce(function(acc, elt) {
          var key = fn(elt);
          acc[key] = append(elt, acc[key] || (acc[key] = []));
          return acc;
        }, {}, list);
      }));
      var head = nth(0);
      var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var results = [],
            idx = 0;
        while (idx < list1.length) {
          if (_containsWith(pred, list1[idx], list2)) {
            results[results.length] = list1[idx];
          }
          idx += 1;
        }
        return uniqWith(pred, results);
      });
      var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
          if (idx === length - 1) {
            out.push(list[idx]);
          } else {
            out.push(list[idx], separator);
          }
          idx += 1;
        }
        return out;
      }));
      var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
      });
      var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
          var key = props[idx];
          var val = obj[key];
          var list = _has(val, out) ? out[val] : out[val] = [];
          list[list.length] = key;
          idx += 1;
        }
        return out;
      });
      var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
          var key = props[idx];
          out[obj[key]] = key;
          idx += 1;
        }
        return out;
      });
      var last = nth(-1);
      var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (_hasMethod('lastIndexOf', xs)) {
          return xs.lastIndexOf(target);
        } else {
          var idx = xs.length - 1;
          while (idx >= 0) {
            if (equals(xs[idx], target)) {
              return idx;
            }
            idx -= 1;
          }
          return -1;
        }
      });
      var map = _curry2(_dispatchable('map', _xmap, _map));
      var mapObj = _curry2(function mapObj(fn, obj) {
        return _reduce(function(acc, key) {
          acc[key] = fn(obj[key]);
          return acc;
        }, {}, keys(obj));
      });
      var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function(acc, key) {
          acc[key] = fn(obj[key], key, obj);
          return acc;
        }, {}, keys(obj));
      });
      var none = _curry2(_complement(_dispatchable('any', _xany, any)));
      var or = _curry2(function or(a, b) {
        return _hasMethod('or', a) ? a.or(b) : a || b;
      });
      var partial = curry(_createPartialApplicator(_concat));
      var partialRight = curry(_createPartialApplicator(flip(_concat)));
      var partition = _curry2(function partition(pred, list) {
        return _reduce(function(acc, elt) {
          var xs = acc[pred(elt) ? 0 : 1];
          xs[xs.length] = elt;
          return acc;
        }, [[], []], list);
      });
      var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
      });
      var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
      });
      var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
      });
      var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
      });
      var reduce = _curry3(_reduce);
      var reject = _curry2(function reject(fn, list) {
        return filter(_complement(fn), list);
      });
      var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
      });
      var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
      }));
      var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
          throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
          result.push(slice(idx, idx += n, list));
        }
        return result;
      });
      var sum = reduce(add, 0);
      var tail = _checkForMethod('tail', slice(1, Infinity));
      var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
      }));
      var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0,
            len = list.length;
        while (idx < len && fn(list[idx])) {
          idx += 1;
        }
        return _slice(list, 0, idx);
      }));
      var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
      });
      var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
      });
      var uniq = uniqWith(equals);
      var unnest = _curry1(_makeFlat(false));
      var useWith = curry(function useWith(fn) {
        var transformers = _slice(arguments, 1);
        var tlen = transformers.length;
        return curry(_arity(tlen, function() {
          var args = [],
              idx = 0;
          while (idx < tlen) {
            args[idx] = transformers[idx](arguments[idx]);
            idx += 1;
          }
          return fn.apply(this, args.concat(_slice(arguments, tlen)));
        }));
      });
      var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(mapObj(equals, spec), testObj);
      });
      var _flatCat = function() {
        var preservingReduced = function(xf) {
          return {
            '@@transducer/init': _xfBase.init,
            '@@transducer/result': function(result) {
              return xf['@@transducer/result'](result);
            },
            '@@transducer/step': function(result, input) {
              var ret = xf['@@transducer/step'](result, input);
              return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
            }
          };
        };
        return function _xcat(xf) {
          var rxf = preservingReduced(xf);
          return {
            '@@transducer/init': _xfBase.init,
            '@@transducer/result': function(result) {
              return rxf['@@transducer/result'](result);
            },
            '@@transducer/step': function(result, input) {
              return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
            }
          };
        };
      }();
      var _indexOf = function _indexOf(list, item, from) {
        var idx = from;
        while (idx < list.length) {
          if (equals(list[idx], item)) {
            return idx;
          }
          idx += 1;
        }
        return -1;
      };
      var _predicateWrap = function _predicateWrap(predPicker) {
        return function(preds) {
          var predIterator = function() {
            var args = arguments;
            return predPicker(function(predicate) {
              return predicate.apply(null, args);
            }, preds);
          };
          return arguments.length > 1 ? predIterator.apply(null, _slice(arguments, 1)) : _arity(Math.max.apply(Math, pluck('length', preds)), predIterator);
        };
      };
      var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
      });
      var allPass = _curry1(_predicateWrap(all));
      var anyPass = _curry1(_predicateWrap(any));
      var ap = _curry2(function ap(fns, vs) {
        return _hasMethod('ap', fns) ? fns.ap(vs) : _reduce(function(acc, fn) {
          return _concat(acc, map(fn, vs));
        }, [], fns);
      });
      var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
      });
      var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, list) {
        return unnest(map(fn, list));
      }));
      var commuteMap = _curry3(function commuteMap(fn, of, list) {
        function consF(acc, ftor) {
          return ap(map(append, fn(ftor)), acc);
        }
        return _reduce(consF, of([]), list);
      });
      var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
          throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
          return function() {
            return new Fn();
          };
        }
        return curry(nAry(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
          switch (arguments.length) {
            case 1:
              return new Fn($0);
            case 2:
              return new Fn($0, $1);
            case 3:
              return new Fn($0, $1, $2);
            case 4:
              return new Fn($0, $1, $2, $3);
            case 5:
              return new Fn($0, $1, $2, $3, $4);
            case 6:
              return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
              return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
          }
        }));
      });
      var converge = curryN(3, function converge(after) {
        var fns = _slice(arguments, 1);
        return curryN(Math.max.apply(Math, pluck('length', fns)), function() {
          var args = arguments;
          var context = this;
          return after.apply(context, _map(function(fn) {
            return fn.apply(context, args);
          }, fns));
        });
      });
      var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
      }));
      var dropLast = _curry2(function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
      });
      var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
          result[0] = list[0];
          while (idx < len) {
            if (!pred(last(result), list[idx])) {
              result[result.length] = list[idx];
            }
            idx += 1;
          }
        }
        return result;
      }));
      var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
      });
      var indexOf = _curry2(function indexOf(target, xs) {
        return _hasMethod('indexOf', xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
      });
      var init = slice(0, -1);
      var isSet = _curry1(function isSet(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
          if (_indexOf(list, list[idx], idx + 1) >= 0) {
            return false;
          }
          idx += 1;
        }
        return true;
      });
      var lens = _curry2(function lens(getter, setter) {
        return function(f) {
          return function(s) {
            return map(function(v) {
              return setter(v, s);
            }, f(getter(s)));
          };
        };
      });
      var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
      });
      var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
      });
      var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function() {
          return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
      });
      var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
      });
      var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
          return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
      });
      var mergeAll = _curry1(function mergeAll(list) {
        return reduce(merge, {}, list);
      });
      var pipe = function pipe() {
        if (arguments.length === 0) {
          throw new Error('pipe requires at least one argument');
        }
        return curryN(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
      };
      var pipeP = function pipeP() {
        if (arguments.length === 0) {
          throw new Error('pipeP requires at least one argument');
        }
        return curryN(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
      };
      var product = reduce(multiply, 1);
      var project = useWith(_map, pickAll, identity);
      var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
      });
      var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
      };
      var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
          var xs = seen.concat([x]);
          return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        var mapPairs = function(obj, keys) {
          return _map(function(k) {
            return _quote(k) + ': ' + recur(obj[k]);
          }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
          case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
          case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(test(/^\d+$/), keys(x)))).join(', ') + ']';
          case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
          case '[object Date]':
            return 'new Date(' + _quote(_toISOString(x)) + ')';
          case '[object Null]':
            return 'null';
          case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
          case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
          case '[object Undefined]':
            return 'undefined';
          default:
            return typeof x.constructor === 'function' && x.constructor.name !== 'Object' && typeof x.toString === 'function' && x.toString() !== '[object Object]' ? x.toString() : '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
      };
      var commute = commuteMap(identity);
      var compose = function compose() {
        if (arguments.length === 0) {
          throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
      };
      var composeK = function composeK() {
        return arguments.length === 0 ? identity : compose.apply(this, map(chain, arguments));
      };
      var composeP = function composeP() {
        if (arguments.length === 0) {
          throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
      };
      var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
      });
      var contains = _curry2(_contains);
      var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
          if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
            out[out.length] = first[idx];
          }
          idx += 1;
        }
        return out;
      });
      var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));
      var intersection = _curry2(function intersection(list1, list2) {
        return uniq(_filter(flip(_contains)(list1), list2));
      });
      var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
      });
      var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
          if (!_contains(prop, names)) {
            result[prop] = obj[prop];
          }
        }
        return result;
      });
      var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
      };
      var toString = _curry1(function toString(val) {
        return _toString(val, []);
      });
      var union = _curry2(compose(uniq, _concat));
      var uniqBy = _curry2(function uniqBy(fn, list) {
        var idx = 0,
            applied = [],
            result = [],
            appliedItem,
            item;
        while (idx < list.length) {
          item = list[idx];
          appliedItem = fn(item);
          if (!_contains(appliedItem, applied)) {
            result.push(item);
            applied.push(appliedItem);
          }
          idx += 1;
        }
        return result;
      });
      var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function() {
          var target = arguments[arity];
          if (target != null && is(Function, target[method])) {
            return target[method].apply(target, _slice(arguments, 0, arity));
          }
          throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
      });
      var join = invoker(1, 'join');
      var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return function() {
          var key = toString(arguments);
          if (!_has(key, cache)) {
            cache[key] = fn.apply(this, arguments);
          }
          return cache[key];
        };
      });
      var split = invoker(1, 'split');
      var toLower = invoker(0, 'toLowerCase');
      var toUpper = invoker(0, 'toUpperCase');
      var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clone: clone,
        commute: commute,
        commuteMap: commuteMap,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        containsWith: containsWith,
        converge: converge,
        countBy: countBy,
        createMapEntry: createMapEntry,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        functions: functions,
        functionsIn: functionsIn,
        groupBy: groupBy,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        isSet: isSet,
        join: join,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObj: mapObj,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        nthChar: nthChar,
        nthCharCode: nthCharCode,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitEvery: splitEvery,
        subtract: subtract,
        sum: sum,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        trim: trim,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unnest: unnest,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        where: where,
        whereEq: whereEq,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
      };
      if (typeof exports === 'object') {
        module.exports = R;
      } else if (typeof define === 'function' && define.amd) {
        define(function() {
          return R;
        });
      } else {
        this.R = R;
      }
    }.call(this));
  })(req('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ramda@0.17.1", ["npm:ramda@0.17.1/dist/ramda"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:ramda@0.17.1/dist/ramda');
  global.define = __define;
  return module.exports;
});

System.register('libraries/ramda/ramda.js', ['github:angular/bower-angular@1.4.7', 'npm:ramda@0.17.1'], function (_export) {
  'use strict';

  var angular, R;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_npmRamda0171) {
      R = _npmRamda0171['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.ramda', []).factory('R', /*@ngInject*/function () {
        return R;
      }));
    }
  };
});

System.registerDynamic("npm:remotestoragejs@0.12.1/release/stable/remotestorage", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    var CHARS = this["CHARS"];
    "format global";
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Promise = e();
      }
    }(function() {
      var define,
          module,
          exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof require == "function" && require;
              if (!u && a)
                return a(o, !0);
              if (i)
                return i(o, !0);
              throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {exports: {}};
            t[o][0].call(f.exports, function(e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      })({
        1: [function(_dereq_, module, exports) {
          "use strict";
          var schedule = _dereq_("./schedule.js");
          var Queue = _dereq_("./queue.js");
          var errorObj = _dereq_("./util.js").errorObj;
          var tryCatch1 = _dereq_("./util.js").tryCatch1;
          var _process = typeof process !== "undefined" ? process : void 0;
          function Async() {
            this._isTickUsed = false;
            this._schedule = schedule;
            this._length = 0;
            this._lateBuffer = new Queue(16);
            this._functionBuffer = new Queue(65536);
            var self = this;
            this.consumeFunctionBuffer = function Async$consumeFunctionBuffer() {
              self._consumeFunctionBuffer();
            };
          }
          Async.prototype.haveItemsQueued = function Async$haveItemsQueued() {
            return this._length > 0;
          };
          Async.prototype.invokeLater = function Async$invokeLater(fn, receiver, arg) {
            if (_process !== void 0 && _process.domain != null && !fn.domain) {
              fn = _process.domain.bind(fn);
            }
            this._lateBuffer.push(fn, receiver, arg);
            this._queueTick();
          };
          Async.prototype.invoke = function Async$invoke(fn, receiver, arg) {
            if (_process !== void 0 && _process.domain != null && !fn.domain) {
              fn = _process.domain.bind(fn);
            }
            var functionBuffer = this._functionBuffer;
            functionBuffer.push(fn, receiver, arg);
            this._length = functionBuffer.length();
            this._queueTick();
          };
          Async.prototype._consumeFunctionBuffer = function Async$_consumeFunctionBuffer() {
            var functionBuffer = this._functionBuffer;
            while (functionBuffer.length() > 0) {
              var fn = functionBuffer.shift();
              var receiver = functionBuffer.shift();
              var arg = functionBuffer.shift();
              fn.call(receiver, arg);
            }
            this._reset();
            this._consumeLateBuffer();
          };
          Async.prototype._consumeLateBuffer = function Async$_consumeLateBuffer() {
            var buffer = this._lateBuffer;
            while (buffer.length() > 0) {
              var fn = buffer.shift();
              var receiver = buffer.shift();
              var arg = buffer.shift();
              var res = tryCatch1(fn, receiver, arg);
              if (res === errorObj) {
                this._queueTick();
                if (fn.domain != null) {
                  fn.domain.emit("error", res.e);
                } else {
                  throw res.e;
                }
              }
            }
          };
          Async.prototype._queueTick = function Async$_queue() {
            if (!this._isTickUsed) {
              this._schedule(this.consumeFunctionBuffer);
              this._isTickUsed = true;
            }
          };
          Async.prototype._reset = function Async$_reset() {
            this._isTickUsed = false;
            this._length = 0;
          };
          module.exports = new Async();
        }, {
          "./queue.js": 15,
          "./schedule.js": 16,
          "./util.js": 19
        }],
        2: [function(_dereq_, module, exports) {
          "use strict";
          var Promise = _dereq_("./promise.js")();
          module.exports = Promise;
        }, {"./promise.js": 12}],
        3: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function() {
            var inherits = _dereq_("./util.js").inherits;
            var defineProperty = _dereq_("./es5.js").defineProperty;
            var rignore = new RegExp("\\b(?:[a-zA-Z0-9.]+\\$_\\w+|" + "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|" + "\\w*PromiseArray\\.\\w*PromiseArray|" + "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|" + "process._tickCallback|nextTick|Async\\$\\w+)\\b");
            var rtraceline = null;
            var formatStack = null;
            function formatNonError(obj) {
              var str;
              if (typeof obj === "function") {
                str = "[function " + (obj.name || "anonymous") + "]";
              } else {
                str = obj.toString();
                var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
                if (ruselessToString.test(str)) {
                  try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                  } catch (e) {}
                }
                if (str.length === 0) {
                  str = "(empty array)";
                }
              }
              return ("(<" + snip(str) + ">, no stack trace)");
            }
            function snip(str) {
              var maxChars = 41;
              if (str.length < maxChars) {
                return str;
              }
              return str.substr(0, maxChars - 3) + "...";
            }
            function CapturedTrace(ignoreUntil, isTopLevel) {
              this.captureStackTrace(CapturedTrace, isTopLevel);
            }
            inherits(CapturedTrace, Error);
            CapturedTrace.prototype.captureStackTrace = function CapturedTrace$captureStackTrace(ignoreUntil, isTopLevel) {
              captureStackTrace(this, ignoreUntil, isTopLevel);
            };
            CapturedTrace.possiblyUnhandledRejection = function CapturedTrace$PossiblyUnhandledRejection(reason) {
              if (typeof console === "object") {
                var message;
                if (typeof reason === "object" || typeof reason === "function") {
                  var stack = reason.stack;
                  message = "Possibly unhandled " + formatStack(stack, reason);
                } else {
                  message = "Possibly unhandled " + String(reason);
                }
                if (typeof console.error === "function" || typeof console.error === "object") {
                  console.error(message);
                } else if (typeof console.log === "function" || typeof console.log === "object") {
                  console.log(message);
                }
              }
            };
            CapturedTrace.combine = function CapturedTrace$Combine(current, prev) {
              var curLast = current.length - 1;
              for (var i = prev.length - 1; i >= 0; --i) {
                var line = prev[i];
                if (current[curLast] === line) {
                  current.pop();
                  curLast--;
                } else {
                  break;
                }
              }
              current.push("From previous event:");
              var lines = current.concat(prev);
              var ret = [];
              for (var i = 0,
                  len = lines.length; i < len; ++i) {
                if (((rignore.test(lines[i]) && rtraceline.test(lines[i])) || (i > 0 && !rtraceline.test(lines[i])) && lines[i] !== "From previous event:")) {
                  continue;
                }
                ret.push(lines[i]);
              }
              return ret;
            };
            CapturedTrace.protectErrorMessageNewlines = function(stack) {
              for (var i = 0; i < stack.length; ++i) {
                if (rtraceline.test(stack[i])) {
                  break;
                }
              }
              if (i <= 1)
                return;
              var errorMessageLines = [];
              for (var j = 0; j < i; ++j) {
                errorMessageLines.push(stack.shift());
              }
              stack.unshift(errorMessageLines.join("\u0002\u0000\u0001"));
            };
            CapturedTrace.isSupported = function CapturedTrace$IsSupported() {
              return typeof captureStackTrace === "function";
            };
            var captureStackTrace = (function stackDetection() {
              if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
                rtraceline = /^\s*at\s*/;
                formatStack = function(stack, error) {
                  if (typeof stack === "string")
                    return stack;
                  if (error.name !== void 0 && error.message !== void 0) {
                    return error.name + ". " + error.message;
                  }
                  return formatNonError(error);
                };
                var captureStackTrace = Error.captureStackTrace;
                return function CapturedTrace$_captureStackTrace(receiver, ignoreUntil) {
                  captureStackTrace(receiver, ignoreUntil);
                };
              }
              var err = new Error();
              if (typeof err.stack === "string" && typeof"".startsWith === "function" && (err.stack.startsWith("stackDetection@")) && stackDetection.name === "stackDetection") {
                defineProperty(Error, "stackTraceLimit", {
                  writable: true,
                  enumerable: false,
                  configurable: false,
                  value: 25
                });
                rtraceline = /@/;
                var rline = /[@\n]/;
                formatStack = function(stack, error) {
                  if (typeof stack === "string") {
                    return (error.name + ". " + error.message + "\n" + stack);
                  }
                  if (error.name !== void 0 && error.message !== void 0) {
                    return error.name + ". " + error.message;
                  }
                  return formatNonError(error);
                };
                return function captureStackTrace(o) {
                  var stack = new Error().stack;
                  var split = stack.split(rline);
                  var len = split.length;
                  var ret = "";
                  for (var i = 0; i < len; i += 2) {
                    ret += split[i];
                    ret += "@";
                    ret += split[i + 1];
                    ret += "\n";
                  }
                  o.stack = ret;
                };
              } else {
                formatStack = function(stack, error) {
                  if (typeof stack === "string")
                    return stack;
                  if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                    return error.name + ". " + error.message;
                  }
                  return formatNonError(error);
                };
                return null;
              }
            })();
            return CapturedTrace;
          };
        }, {
          "./es5.js": 8,
          "./util.js": 19
        }],
        4: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(NEXT_FILTER) {
            var util = _dereq_("./util.js");
            var errors = _dereq_("./errors.js");
            var tryCatch1 = util.tryCatch1;
            var errorObj = util.errorObj;
            var keys = _dereq_("./es5.js").keys;
            var TypeError = errors.TypeError;
            function CatchFilter(instances, callback, promise) {
              this._instances = instances;
              this._callback = callback;
              this._promise = promise;
            }
            function CatchFilter$_safePredicate(predicate, e) {
              var safeObject = {};
              var retfilter = tryCatch1(predicate, safeObject, e);
              if (retfilter === errorObj)
                return retfilter;
              var safeKeys = keys(safeObject);
              if (safeKeys.length) {
                errorObj.e = new TypeError("Catch filter must inherit from Error " + "or be a simple predicate function");
                return errorObj;
              }
              return retfilter;
            }
            CatchFilter.prototype.doFilter = function CatchFilter$_doFilter(e) {
              var cb = this._callback;
              var promise = this._promise;
              var boundTo = promise._boundTo;
              for (var i = 0,
                  len = this._instances.length; i < len; ++i) {
                var item = this._instances[i];
                var itemIsErrorType = item === Error || (item != null && item.prototype instanceof Error);
                if (itemIsErrorType && e instanceof item) {
                  var ret = tryCatch1(cb, boundTo, e);
                  if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                  }
                  return ret;
                } else if (typeof item === "function" && !itemIsErrorType) {
                  var shouldHandle = CatchFilter$_safePredicate(item, e);
                  if (shouldHandle === errorObj) {
                    var trace = errors.canAttach(errorObj.e) ? errorObj.e : new Error(errorObj.e + "");
                    this._promise._attachExtraTrace(trace);
                    e = errorObj.e;
                    break;
                  } else if (shouldHandle) {
                    var ret = tryCatch1(cb, boundTo, e);
                    if (ret === errorObj) {
                      NEXT_FILTER.e = ret.e;
                      return NEXT_FILTER;
                    }
                    return ret;
                  }
                }
              }
              NEXT_FILTER.e = e;
              return NEXT_FILTER;
            };
            return CatchFilter;
          };
        }, {
          "./errors.js": 6,
          "./es5.js": 8,
          "./util.js": 19
        }],
        5: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util.js");
          var isPrimitive = util.isPrimitive;
          var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
          module.exports = function(Promise) {
            var returner = function Promise$_returner() {
              return this;
            };
            var thrower = function Promise$_thrower() {
              throw this;
            };
            var wrapper = function Promise$_wrapper(value, action) {
              if (action === 1) {
                return function Promise$_thrower() {
                  throw value;
                };
              } else if (action === 2) {
                return function Promise$_returner() {
                  return value;
                };
              }
            };
            Promise.prototype["return"] = Promise.prototype.thenReturn = function Promise$thenReturn(value) {
              if (wrapsPrimitiveReceiver && isPrimitive(value)) {
                return this._then(wrapper(value, 2), void 0, void 0, void 0, void 0);
              }
              return this._then(returner, void 0, void 0, value, void 0);
            };
            Promise.prototype["throw"] = Promise.prototype.thenThrow = function Promise$thenThrow(reason) {
              if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
                return this._then(wrapper(reason, 1), void 0, void 0, void 0, void 0);
              }
              return this._then(thrower, void 0, void 0, reason, void 0);
            };
          };
        }, {"./util.js": 19}],
        6: [function(_dereq_, module, exports) {
          "use strict";
          var Objectfreeze = _dereq_("./es5.js").freeze;
          var util = _dereq_("./util.js");
          var inherits = util.inherits;
          var notEnumerableProp = util.notEnumerableProp;
          function markAsOriginatingFromRejection(e) {
            try {
              notEnumerableProp(e, "isOperational", true);
            } catch (ignore) {}
          }
          function originatesFromRejection(e) {
            if (e == null)
              return false;
            return ((e instanceof OperationalError) || e["isOperational"] === true);
          }
          function isError(obj) {
            return obj instanceof Error;
          }
          function canAttach(obj) {
            return isError(obj);
          }
          function subError(nameProperty, defaultMessage) {
            function SubError(message) {
              if (!(this instanceof SubError))
                return new SubError(message);
              this.message = typeof message === "string" ? message : defaultMessage;
              this.name = nameProperty;
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              }
            }
            inherits(SubError, Error);
            return SubError;
          }
          var _TypeError,
              _RangeError;
          var CancellationError = subError("CancellationError", "cancellation error");
          var TimeoutError = subError("TimeoutError", "timeout error");
          var AggregateError = subError("AggregateError", "aggregate error");
          try {
            _TypeError = TypeError;
            _RangeError = RangeError;
          } catch (e) {
            _TypeError = subError("TypeError", "type error");
            _RangeError = subError("RangeError", "range error");
          }
          var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
          for (var i = 0; i < methods.length; ++i) {
            if (typeof Array.prototype[methods[i]] === "function") {
              AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
            }
          }
          AggregateError.prototype.length = 0;
          AggregateError.prototype["isOperational"] = true;
          var level = 0;
          AggregateError.prototype.toString = function() {
            var indent = Array(level * 4 + 1).join(" ");
            var ret = "\n" + indent + "AggregateError of:" + "\n";
            level++;
            indent = Array(level * 4 + 1).join(" ");
            for (var i = 0; i < this.length; ++i) {
              var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
              var lines = str.split("\n");
              for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
              }
              str = lines.join("\n");
              ret += str + "\n";
            }
            level--;
            return ret;
          };
          function OperationalError(message) {
            this.name = "OperationalError";
            this.message = message;
            this.cause = message;
            this["isOperational"] = true;
            if (message instanceof Error) {
              this.message = message.message;
              this.stack = message.stack;
            } else if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          }
          inherits(OperationalError, Error);
          var key = "__BluebirdErrorTypes__";
          var errorTypes = Error[key];
          if (!errorTypes) {
            errorTypes = Objectfreeze({
              CancellationError: CancellationError,
              TimeoutError: TimeoutError,
              OperationalError: OperationalError,
              RejectionError: OperationalError,
              AggregateError: AggregateError
            });
            notEnumerableProp(Error, key, errorTypes);
          }
          module.exports = {
            Error: Error,
            TypeError: _TypeError,
            RangeError: _RangeError,
            CancellationError: errorTypes.CancellationError,
            OperationalError: errorTypes.OperationalError,
            TimeoutError: errorTypes.TimeoutError,
            AggregateError: errorTypes.AggregateError,
            originatesFromRejection: originatesFromRejection,
            markAsOriginatingFromRejection: markAsOriginatingFromRejection,
            canAttach: canAttach
          };
        }, {
          "./es5.js": 8,
          "./util.js": 19
        }],
        7: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var TypeError = _dereq_('./errors.js').TypeError;
            function apiRejection(msg) {
              var error = new TypeError(msg);
              var ret = Promise.rejected(error);
              var parent = ret._peekContext();
              if (parent != null) {
                parent._attachExtraTrace(error);
              }
              return ret;
            }
            return apiRejection;
          };
        }, {"./errors.js": 6}],
        8: [function(_dereq_, module, exports) {
          var isES5 = (function() {
            "use strict";
            return this === void 0;
          })();
          if (isES5) {
            module.exports = {
              freeze: Object.freeze,
              defineProperty: Object.defineProperty,
              keys: Object.keys,
              getPrototypeOf: Object.getPrototypeOf,
              isArray: Array.isArray,
              isES5: isES5
            };
          } else {
            var has = {}.hasOwnProperty;
            var str = {}.toString;
            var proto = {}.constructor.prototype;
            var ObjectKeys = function ObjectKeys(o) {
              var ret = [];
              for (var key in o) {
                if (has.call(o, key)) {
                  ret.push(key);
                }
              }
              return ret;
            };
            var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {
              o[key] = desc.value;
              return o;
            };
            var ObjectFreeze = function ObjectFreeze(obj) {
              return obj;
            };
            var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {
              try {
                return Object(obj).constructor.prototype;
              } catch (e) {
                return proto;
              }
            };
            var ArrayIsArray = function ArrayIsArray(obj) {
              try {
                return str.call(obj) === "[object Array]";
              } catch (e) {
                return false;
              }
            };
            module.exports = {
              isArray: ArrayIsArray,
              keys: ObjectKeys,
              defineProperty: ObjectDefineProperty,
              freeze: ObjectFreeze,
              getPrototypeOf: ObjectGetPrototypeOf,
              isES5: isES5
            };
          }
        }, {}],
        9: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, NEXT_FILTER, cast) {
            var util = _dereq_("./util.js");
            var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
            var isPrimitive = util.isPrimitive;
            var thrower = util.thrower;
            function returnThis() {
              return this;
            }
            function throwThis() {
              throw this;
            }
            function return$(r) {
              return function Promise$_returner() {
                return r;
              };
            }
            function throw$(r) {
              return function Promise$_thrower() {
                throw r;
              };
            }
            function promisedFinally(ret, reasonOrValue, isFulfilled) {
              var then;
              if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
                then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
              } else {
                then = isFulfilled ? returnThis : throwThis;
              }
              return ret._then(then, thrower, void 0, reasonOrValue, void 0);
            }
            function finallyHandler(reasonOrValue) {
              var promise = this.promise;
              var handler = this.handler;
              var ret = promise._isBound() ? handler.call(promise._boundTo) : handler();
              if (ret !== void 0) {
                var maybePromise = cast(ret, void 0);
                if (maybePromise instanceof Promise) {
                  return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled());
                }
              }
              if (promise.isRejected()) {
                NEXT_FILTER.e = reasonOrValue;
                return NEXT_FILTER;
              } else {
                return reasonOrValue;
              }
            }
            function tapHandler(value) {
              var promise = this.promise;
              var handler = this.handler;
              var ret = promise._isBound() ? handler.call(promise._boundTo, value) : handler(value);
              if (ret !== void 0) {
                var maybePromise = cast(ret, void 0);
                if (maybePromise instanceof Promise) {
                  return promisedFinally(maybePromise, value, true);
                }
              }
              return value;
            }
            Promise.prototype._passThroughHandler = function Promise$_passThroughHandler(handler, isFinally) {
              if (typeof handler !== "function")
                return this.then();
              var promiseAndHandler = {
                promise: this,
                handler: handler
              };
              return this._then(isFinally ? finallyHandler : tapHandler, isFinally ? finallyHandler : void 0, void 0, promiseAndHandler, void 0);
            };
            Promise.prototype.lastly = Promise.prototype["finally"] = function Promise$finally(handler) {
              return this._passThroughHandler(handler, true);
            };
            Promise.prototype.tap = function Promise$tap(handler) {
              return this._passThroughHandler(handler, false);
            };
          };
        }, {"./util.js": 19}],
        10: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, cast, INTERNAL) {
            var util = _dereq_("./util.js");
            var canEvaluate = util.canEvaluate;
            var tryCatch1 = util.tryCatch1;
            var errorObj = util.errorObj;
            if (canEvaluate) {
              var thenCallback = function(i) {
                return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
              };
              var caller = function(count) {
                var values = [];
                for (var i = 1; i <= count; ++i)
                  values.push("holder.p" + i);
                return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
              };
              var thenCallbacks = [];
              var callers = [void 0];
              for (var i = 1; i <= 5; ++i) {
                thenCallbacks.push(thenCallback(i));
                callers.push(caller(i));
              }
              var Holder = function(total, fn) {
                this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                this.fn = fn;
                this.total = total;
                this.now = 0;
              };
              Holder.prototype.callers = callers;
              Holder.prototype.checkFulfillment = function(promise) {
                var now = this.now;
                now++;
                var total = this.total;
                if (now >= total) {
                  var handler = this.callers[total];
                  var ret = tryCatch1(handler, void 0, this);
                  if (ret === errorObj) {
                    promise._rejectUnchecked(ret.e);
                  } else if (!promise._tryFollow(ret)) {
                    promise._fulfillUnchecked(ret);
                  }
                } else {
                  this.now = now;
                }
              };
            }
            Promise.join = function Promise$Join() {
              var last = arguments.length - 1;
              var fn;
              if (last > 0 && typeof arguments[last] === "function") {
                fn = arguments[last];
                if (last < 6 && canEvaluate) {
                  var ret = new Promise(INTERNAL);
                  ret._setTrace(void 0);
                  var holder = new Holder(last, fn);
                  var reject = ret._reject;
                  var callbacks = thenCallbacks;
                  for (var i = 0; i < last; ++i) {
                    var maybePromise = cast(arguments[i], void 0);
                    if (maybePromise instanceof Promise) {
                      if (maybePromise.isPending()) {
                        maybePromise._then(callbacks[i], reject, void 0, ret, holder);
                      } else if (maybePromise.isFulfilled()) {
                        callbacks[i].call(ret, maybePromise._settledValue, holder);
                      } else {
                        ret._reject(maybePromise._settledValue);
                        maybePromise._unsetRejectionIsUnhandled();
                      }
                    } else {
                      callbacks[i].call(ret, maybePromise, holder);
                    }
                  }
                  return ret;
                }
              }
              var $_len = arguments.length;
              var args = new Array($_len);
              for (var $_i = 0; $_i < $_len; ++$_i) {
                args[$_i] = arguments[$_i];
              }
              var ret = new PromiseArray(args).promise();
              return fn !== void 0 ? ret.spread(fn) : ret;
            };
          };
        }, {"./util.js": 19}],
        11: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var util = _dereq_("./util.js");
            var async = _dereq_("./async.js");
            var tryCatch2 = util.tryCatch2;
            var tryCatch1 = util.tryCatch1;
            var errorObj = util.errorObj;
            function thrower(r) {
              throw r;
            }
            function Promise$_spreadAdapter(val, receiver) {
              if (!util.isArray(val))
                return Promise$_successAdapter(val, receiver);
              var ret = util.tryCatchApply(this, [null].concat(val), receiver);
              if (ret === errorObj) {
                async.invokeLater(thrower, void 0, ret.e);
              }
            }
            function Promise$_successAdapter(val, receiver) {
              var nodeback = this;
              var ret = val === void 0 ? tryCatch1(nodeback, receiver, null) : tryCatch2(nodeback, receiver, null, val);
              if (ret === errorObj) {
                async.invokeLater(thrower, void 0, ret.e);
              }
            }
            function Promise$_errorAdapter(reason, receiver) {
              var nodeback = this;
              var ret = tryCatch1(nodeback, receiver, reason);
              if (ret === errorObj) {
                async.invokeLater(thrower, void 0, ret.e);
              }
            }
            Promise.prototype.nodeify = function Promise$nodeify(nodeback, options) {
              if (typeof nodeback == "function") {
                var adapter = Promise$_successAdapter;
                if (options !== void 0 && Object(options).spread) {
                  adapter = Promise$_spreadAdapter;
                }
                this._then(adapter, Promise$_errorAdapter, void 0, nodeback, this._boundTo);
              }
              return this;
            };
          };
        }, {
          "./async.js": 1,
          "./util.js": 19
        }],
        12: [function(_dereq_, module, exports) {
          "use strict";
          var old;
          if (typeof Promise !== "undefined")
            old = Promise;
          function noConflict(bluebird) {
            try {
              if (Promise === bluebird)
                Promise = old;
            } catch (e) {}
            return bluebird;
          }
          module.exports = function() {
            var util = _dereq_("./util.js");
            var async = _dereq_("./async.js");
            var errors = _dereq_("./errors.js");
            var INTERNAL = function() {};
            var APPLY = {};
            var NEXT_FILTER = {e: null};
            var cast = _dereq_("./thenables.js")(Promise, INTERNAL);
            var PromiseArray = _dereq_("./promise_array.js")(Promise, INTERNAL, cast);
            var CapturedTrace = _dereq_("./captured_trace.js")();
            var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
            var PromiseResolver = _dereq_("./promise_resolver.js");
            var isArray = util.isArray;
            var errorObj = util.errorObj;
            var tryCatch1 = util.tryCatch1;
            var tryCatch2 = util.tryCatch2;
            var tryCatchApply = util.tryCatchApply;
            var RangeError = errors.RangeError;
            var TypeError = errors.TypeError;
            var CancellationError = errors.CancellationError;
            var TimeoutError = errors.TimeoutError;
            var OperationalError = errors.OperationalError;
            var originatesFromRejection = errors.originatesFromRejection;
            var markAsOriginatingFromRejection = errors.markAsOriginatingFromRejection;
            var canAttach = errors.canAttach;
            var thrower = util.thrower;
            var apiRejection = _dereq_("./errors_api_rejection")(Promise);
            var makeSelfResolutionError = function Promise$_makeSelfResolutionError() {
              return new TypeError("circular promise resolution chain");
            };
            function Promise(resolver) {
              if (typeof resolver !== "function") {
                throw new TypeError("the promise constructor requires a resolver function");
              }
              if (this.constructor !== Promise) {
                throw new TypeError("the promise constructor cannot be invoked directly");
              }
              this._bitField = 0;
              this._fulfillmentHandler0 = void 0;
              this._rejectionHandler0 = void 0;
              this._promise0 = void 0;
              this._receiver0 = void 0;
              this._settledValue = void 0;
              this._boundTo = void 0;
              if (resolver !== INTERNAL)
                this._resolveFromResolver(resolver);
            }
            function returnFirstElement(elements) {
              return elements[0];
            }
            Promise.prototype.bind = function Promise$bind(thisArg) {
              var maybePromise = cast(thisArg, void 0);
              var ret = new Promise(INTERNAL);
              if (maybePromise instanceof Promise) {
                var binder = maybePromise.then(function(thisArg) {
                  ret._setBoundTo(thisArg);
                });
                var p = Promise.all([this, binder]).then(returnFirstElement);
                ret._follow(p);
              } else {
                ret._follow(this);
                ret._setBoundTo(thisArg);
              }
              ret._propagateFrom(this, 2 | 1);
              return ret;
            };
            Promise.prototype.toString = function Promise$toString() {
              return "[object Promise]";
            };
            Promise.prototype.caught = Promise.prototype["catch"] = function Promise$catch(fn) {
              var len = arguments.length;
              if (len > 1) {
                var catchInstances = new Array(len - 1),
                    j = 0,
                    i;
                for (i = 0; i < len - 1; ++i) {
                  var item = arguments[i];
                  if (typeof item === "function") {
                    catchInstances[j++] = item;
                  } else {
                    var catchFilterTypeError = new TypeError("A catch filter must be an error constructor " + "or a filter function");
                    this._attachExtraTrace(catchFilterTypeError);
                    return Promise.reject(catchFilterTypeError);
                  }
                }
                catchInstances.length = j;
                fn = arguments[i];
                this._resetTrace();
                var catchFilter = new CatchFilter(catchInstances, fn, this);
                return this._then(void 0, catchFilter.doFilter, void 0, catchFilter, void 0);
              }
              return this._then(void 0, fn, void 0, void 0, void 0);
            };
            Promise.prototype.then = function Promise$then(didFulfill, didReject, didProgress) {
              return this._then(didFulfill, didReject, didProgress, void 0, void 0);
            };
            Promise.prototype.done = function Promise$done(didFulfill, didReject, didProgress) {
              var promise = this._then(didFulfill, didReject, didProgress, void 0, void 0);
              promise._setIsFinal();
            };
            Promise.prototype.spread = function Promise$spread(didFulfill, didReject) {
              return this._then(didFulfill, didReject, void 0, APPLY, void 0);
            };
            Promise.prototype.isCancellable = function Promise$isCancellable() {
              return !this.isResolved() && this._cancellable();
            };
            Promise.prototype.toJSON = function Promise$toJSON() {
              var ret = {
                isFulfilled: false,
                isRejected: false,
                fulfillmentValue: void 0,
                rejectionReason: void 0
              };
              if (this.isFulfilled()) {
                ret.fulfillmentValue = this._settledValue;
                ret.isFulfilled = true;
              } else if (this.isRejected()) {
                ret.rejectionReason = this._settledValue;
                ret.isRejected = true;
              }
              return ret;
            };
            Promise.prototype.all = function Promise$all() {
              return new PromiseArray(this).promise();
            };
            Promise.is = function Promise$Is(val) {
              return val instanceof Promise;
            };
            Promise.all = function Promise$All(promises) {
              return new PromiseArray(promises).promise();
            };
            Promise.prototype.error = function Promise$_error(fn) {
              return this.caught(originatesFromRejection, fn);
            };
            Promise.prototype._resolveFromSyncValue = function Promise$_resolveFromSyncValue(value) {
              if (value === errorObj) {
                this._cleanValues();
                this._setRejected();
                this._settledValue = value.e;
                this._ensurePossibleRejectionHandled();
              } else {
                var maybePromise = cast(value, void 0);
                if (maybePromise instanceof Promise) {
                  this._follow(maybePromise);
                } else {
                  this._cleanValues();
                  this._setFulfilled();
                  this._settledValue = value;
                }
              }
            };
            Promise.method = function Promise$_Method(fn) {
              if (typeof fn !== "function") {
                throw new TypeError("fn must be a function");
              }
              return function Promise$_method() {
                var value;
                switch (arguments.length) {
                  case 0:
                    value = tryCatch1(fn, this, void 0);
                    break;
                  case 1:
                    value = tryCatch1(fn, this, arguments[0]);
                    break;
                  case 2:
                    value = tryCatch2(fn, this, arguments[0], arguments[1]);
                    break;
                  default:
                    var $_len = arguments.length;
                    var args = new Array($_len);
                    for (var $_i = 0; $_i < $_len; ++$_i) {
                      args[$_i] = arguments[$_i];
                    }
                    value = tryCatchApply(fn, args, this);
                    break;
                }
                var ret = new Promise(INTERNAL);
                ret._setTrace(void 0);
                ret._resolveFromSyncValue(value);
                return ret;
              };
            };
            Promise.attempt = Promise["try"] = function Promise$_Try(fn, args, ctx) {
              if (typeof fn !== "function") {
                return apiRejection("fn must be a function");
              }
              var value = isArray(args) ? tryCatchApply(fn, args, ctx) : tryCatch1(fn, ctx, args);
              var ret = new Promise(INTERNAL);
              ret._setTrace(void 0);
              ret._resolveFromSyncValue(value);
              return ret;
            };
            Promise.defer = Promise.pending = function Promise$Defer() {
              var promise = new Promise(INTERNAL);
              promise._setTrace(void 0);
              return new PromiseResolver(promise);
            };
            Promise.bind = function Promise$Bind(thisArg) {
              var maybePromise = cast(thisArg, void 0);
              var ret = new Promise(INTERNAL);
              ret._setTrace(void 0);
              if (maybePromise instanceof Promise) {
                var p = maybePromise.then(function(thisArg) {
                  ret._setBoundTo(thisArg);
                });
                ret._follow(p);
              } else {
                ret._setBoundTo(thisArg);
                ret._setFulfilled();
              }
              return ret;
            };
            Promise.cast = function Promise$_Cast(obj) {
              var ret = cast(obj, void 0);
              if (!(ret instanceof Promise)) {
                var val = ret;
                ret = new Promise(INTERNAL);
                ret._setTrace(void 0);
                ret._setFulfilled();
                ret._cleanValues();
                ret._settledValue = val;
              }
              return ret;
            };
            Promise.resolve = Promise.fulfilled = Promise.cast;
            Promise.reject = Promise.rejected = function Promise$Reject(reason) {
              var ret = new Promise(INTERNAL);
              ret._setTrace(void 0);
              markAsOriginatingFromRejection(reason);
              ret._cleanValues();
              ret._setRejected();
              ret._settledValue = reason;
              if (!canAttach(reason)) {
                var trace = new Error(reason + "");
                ret._setCarriedStackTrace(trace);
              }
              ret._ensurePossibleRejectionHandled();
              return ret;
            };
            Promise.onPossiblyUnhandledRejection = function Promise$OnPossiblyUnhandledRejection(fn) {
              CapturedTrace.possiblyUnhandledRejection = typeof fn === "function" ? fn : void 0;
            };
            var unhandledRejectionHandled;
            Promise.onUnhandledRejectionHandled = function Promise$onUnhandledRejectionHandled(fn) {
              unhandledRejectionHandled = typeof fn === "function" ? fn : void 0;
            };
            var debugging = false || !!(typeof process !== "undefined" && typeof process.execPath === "string" && typeof process.env === "object" && (process.env["BLUEBIRD_DEBUG"] || process.env["NODE_ENV"] === "development"));
            Promise.longStackTraces = function Promise$LongStackTraces() {
              if (async.haveItemsQueued() && debugging === false) {
                throw new Error("cannot enable long stack traces after promises have been created");
              }
              debugging = CapturedTrace.isSupported();
            };
            Promise.hasLongStackTraces = function Promise$HasLongStackTraces() {
              return debugging && CapturedTrace.isSupported();
            };
            Promise.prototype._then = function Promise$_then(didFulfill, didReject, didProgress, receiver, internalData) {
              var haveInternalData = internalData !== void 0;
              var ret = haveInternalData ? internalData : new Promise(INTERNAL);
              if (!haveInternalData) {
                if (debugging) {
                  var haveSameContext = this._peekContext() === this._traceParent;
                  ret._traceParent = haveSameContext ? this._traceParent : this;
                }
                ret._propagateFrom(this, 7);
              }
              var callbackIndex = this._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);
              if (this.isResolved()) {
                async.invoke(this._queueSettleAt, this, callbackIndex);
              }
              return ret;
            };
            Promise.prototype._length = function Promise$_length() {
              return this._bitField & 262143;
            };
            Promise.prototype._isFollowingOrFulfilledOrRejected = function Promise$_isFollowingOrFulfilledOrRejected() {
              return (this._bitField & 939524096) > 0;
            };
            Promise.prototype._isFollowing = function Promise$_isFollowing() {
              return (this._bitField & 536870912) === 536870912;
            };
            Promise.prototype._setLength = function Promise$_setLength(len) {
              this._bitField = (this._bitField & -262144) | (len & 262143);
            };
            Promise.prototype._setFulfilled = function Promise$_setFulfilled() {
              this._bitField = this._bitField | 268435456;
            };
            Promise.prototype._setRejected = function Promise$_setRejected() {
              this._bitField = this._bitField | 134217728;
            };
            Promise.prototype._setFollowing = function Promise$_setFollowing() {
              this._bitField = this._bitField | 536870912;
            };
            Promise.prototype._setIsFinal = function Promise$_setIsFinal() {
              this._bitField = this._bitField | 33554432;
            };
            Promise.prototype._isFinal = function Promise$_isFinal() {
              return (this._bitField & 33554432) > 0;
            };
            Promise.prototype._cancellable = function Promise$_cancellable() {
              return (this._bitField & 67108864) > 0;
            };
            Promise.prototype._setCancellable = function Promise$_setCancellable() {
              this._bitField = this._bitField | 67108864;
            };
            Promise.prototype._unsetCancellable = function Promise$_unsetCancellable() {
              this._bitField = this._bitField & (~67108864);
            };
            Promise.prototype._setRejectionIsUnhandled = function Promise$_setRejectionIsUnhandled() {
              this._bitField = this._bitField | 2097152;
            };
            Promise.prototype._unsetRejectionIsUnhandled = function Promise$_unsetRejectionIsUnhandled() {
              this._bitField = this._bitField & (~2097152);
              if (this._isUnhandledRejectionNotified()) {
                this._unsetUnhandledRejectionIsNotified();
                this._notifyUnhandledRejectionIsHandled();
              }
            };
            Promise.prototype._isRejectionUnhandled = function Promise$_isRejectionUnhandled() {
              return (this._bitField & 2097152) > 0;
            };
            Promise.prototype._setUnhandledRejectionIsNotified = function Promise$_setUnhandledRejectionIsNotified() {
              this._bitField = this._bitField | 524288;
            };
            Promise.prototype._unsetUnhandledRejectionIsNotified = function Promise$_unsetUnhandledRejectionIsNotified() {
              this._bitField = this._bitField & (~524288);
            };
            Promise.prototype._isUnhandledRejectionNotified = function Promise$_isUnhandledRejectionNotified() {
              return (this._bitField & 524288) > 0;
            };
            Promise.prototype._setCarriedStackTrace = function Promise$_setCarriedStackTrace(capturedTrace) {
              this._bitField = this._bitField | 1048576;
              this._fulfillmentHandler0 = capturedTrace;
            };
            Promise.prototype._unsetCarriedStackTrace = function Promise$_unsetCarriedStackTrace() {
              this._bitField = this._bitField & (~1048576);
              this._fulfillmentHandler0 = void 0;
            };
            Promise.prototype._isCarryingStackTrace = function Promise$_isCarryingStackTrace() {
              return (this._bitField & 1048576) > 0;
            };
            Promise.prototype._getCarriedStackTrace = function Promise$_getCarriedStackTrace() {
              return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : void 0;
            };
            Promise.prototype._receiverAt = function Promise$_receiverAt(index) {
              var ret = index === 0 ? this._receiver0 : this[(index << 2) + index - 5 + 4];
              if (this._isBound() && ret === void 0) {
                return this._boundTo;
              }
              return ret;
            };
            Promise.prototype._promiseAt = function Promise$_promiseAt(index) {
              return index === 0 ? this._promise0 : this[(index << 2) + index - 5 + 3];
            };
            Promise.prototype._fulfillmentHandlerAt = function Promise$_fulfillmentHandlerAt(index) {
              return index === 0 ? this._fulfillmentHandler0 : this[(index << 2) + index - 5 + 0];
            };
            Promise.prototype._rejectionHandlerAt = function Promise$_rejectionHandlerAt(index) {
              return index === 0 ? this._rejectionHandler0 : this[(index << 2) + index - 5 + 1];
            };
            Promise.prototype._addCallbacks = function Promise$_addCallbacks(fulfill, reject, progress, promise, receiver) {
              var index = this._length();
              if (index >= 262143 - 5) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promise;
                if (receiver !== void 0)
                  this._receiver0 = receiver;
                if (typeof fulfill === "function" && !this._isCarryingStackTrace())
                  this._fulfillmentHandler0 = fulfill;
                if (typeof reject === "function")
                  this._rejectionHandler0 = reject;
                if (typeof progress === "function")
                  this._progressHandler0 = progress;
              } else {
                var base = (index << 2) + index - 5;
                this[base + 3] = promise;
                this[base + 4] = receiver;
                this[base + 0] = typeof fulfill === "function" ? fulfill : void 0;
                this[base + 1] = typeof reject === "function" ? reject : void 0;
                this[base + 2] = typeof progress === "function" ? progress : void 0;
              }
              this._setLength(index + 1);
              return index;
            };
            Promise.prototype._setProxyHandlers = function Promise$_setProxyHandlers(receiver, promiseSlotValue) {
              var index = this._length();
              if (index >= 262143 - 5) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promiseSlotValue;
                this._receiver0 = receiver;
              } else {
                var base = (index << 2) + index - 5;
                this[base + 3] = promiseSlotValue;
                this[base + 4] = receiver;
                this[base + 0] = this[base + 1] = this[base + 2] = void 0;
              }
              this._setLength(index + 1);
            };
            Promise.prototype._proxyPromiseArray = function Promise$_proxyPromiseArray(promiseArray, index) {
              this._setProxyHandlers(promiseArray, index);
            };
            Promise.prototype._proxyPromise = function Promise$_proxyPromise(promise) {
              promise._setProxied();
              this._setProxyHandlers(promise, -15);
            };
            Promise.prototype._setBoundTo = function Promise$_setBoundTo(obj) {
              if (obj !== void 0) {
                this._bitField = this._bitField | 8388608;
                this._boundTo = obj;
              } else {
                this._bitField = this._bitField & (~8388608);
              }
            };
            Promise.prototype._isBound = function Promise$_isBound() {
              return (this._bitField & 8388608) === 8388608;
            };
            Promise.prototype._resolveFromResolver = function Promise$_resolveFromResolver(resolver) {
              var promise = this;
              this._setTrace(void 0);
              this._pushContext();
              function Promise$_resolver(val) {
                if (promise._tryFollow(val)) {
                  return;
                }
                promise._fulfill(val);
              }
              function Promise$_rejecter(val) {
                var trace = canAttach(val) ? val : new Error(val + "");
                promise._attachExtraTrace(trace);
                markAsOriginatingFromRejection(val);
                promise._reject(val, trace === val ? void 0 : trace);
              }
              var r = tryCatch2(resolver, void 0, Promise$_resolver, Promise$_rejecter);
              this._popContext();
              if (r !== void 0 && r === errorObj) {
                var e = r.e;
                var trace = canAttach(e) ? e : new Error(e + "");
                promise._reject(e, trace);
              }
            };
            Promise.prototype._spreadSlowCase = function Promise$_spreadSlowCase(targetFn, promise, values, boundTo) {
              var promiseForAll = new PromiseArray(values).promise();
              var promise2 = promiseForAll._then(function() {
                return targetFn.apply(boundTo, arguments);
              }, void 0, void 0, APPLY, void 0);
              promise._follow(promise2);
            };
            Promise.prototype._callSpread = function Promise$_callSpread(handler, promise, value) {
              var boundTo = this._boundTo;
              if (isArray(value)) {
                for (var i = 0,
                    len = value.length; i < len; ++i) {
                  if (cast(value[i], void 0) instanceof Promise) {
                    this._spreadSlowCase(handler, promise, value, boundTo);
                    return;
                  }
                }
              }
              promise._pushContext();
              return tryCatchApply(handler, value, boundTo);
            };
            Promise.prototype._callHandler = function Promise$_callHandler(handler, receiver, promise, value) {
              var x;
              if (receiver === APPLY && !this.isRejected()) {
                x = this._callSpread(handler, promise, value);
              } else {
                promise._pushContext();
                x = tryCatch1(handler, receiver, value);
              }
              promise._popContext();
              return x;
            };
            Promise.prototype._settlePromiseFromHandler = function Promise$_settlePromiseFromHandler(handler, receiver, value, promise) {
              if (!(promise instanceof Promise)) {
                handler.call(receiver, value, promise);
                return;
              }
              var x = this._callHandler(handler, receiver, promise, value);
              if (promise._isFollowing())
                return;
              if (x === errorObj || x === promise || x === NEXT_FILTER) {
                var err = x === promise ? makeSelfResolutionError() : x.e;
                var trace = canAttach(err) ? err : new Error(err + "");
                if (x !== NEXT_FILTER)
                  promise._attachExtraTrace(trace);
                promise._rejectUnchecked(err, trace);
              } else {
                var castValue = cast(x, promise);
                if (castValue instanceof Promise) {
                  if (castValue.isRejected() && !castValue._isCarryingStackTrace() && !canAttach(castValue._settledValue)) {
                    var trace = new Error(castValue._settledValue + "");
                    promise._attachExtraTrace(trace);
                    castValue._setCarriedStackTrace(trace);
                  }
                  promise._follow(castValue);
                  promise._propagateFrom(castValue, 1);
                } else {
                  promise._fulfillUnchecked(x);
                }
              }
            };
            Promise.prototype._follow = function Promise$_follow(promise) {
              this._setFollowing();
              if (promise.isPending()) {
                this._propagateFrom(promise, 1);
                promise._proxyPromise(this);
              } else if (promise.isFulfilled()) {
                this._fulfillUnchecked(promise._settledValue);
              } else {
                this._rejectUnchecked(promise._settledValue, promise._getCarriedStackTrace());
              }
              if (promise._isRejectionUnhandled())
                promise._unsetRejectionIsUnhandled();
              if (debugging && promise._traceParent == null) {
                promise._traceParent = this;
              }
            };
            Promise.prototype._tryFollow = function Promise$_tryFollow(value) {
              if (this._isFollowingOrFulfilledOrRejected() || value === this) {
                return false;
              }
              var maybePromise = cast(value, void 0);
              if (!(maybePromise instanceof Promise)) {
                return false;
              }
              this._follow(maybePromise);
              return true;
            };
            Promise.prototype._resetTrace = function Promise$_resetTrace() {
              if (debugging) {
                this._trace = new CapturedTrace(this._peekContext() === void 0);
              }
            };
            Promise.prototype._setTrace = function Promise$_setTrace(parent) {
              if (debugging) {
                var context = this._peekContext();
                this._traceParent = context;
                var isTopLevel = context === void 0;
                if (parent !== void 0 && parent._traceParent === context) {
                  this._trace = parent._trace;
                } else {
                  this._trace = new CapturedTrace(isTopLevel);
                }
              }
              return this;
            };
            Promise.prototype._attachExtraTrace = function Promise$_attachExtraTrace(error) {
              if (debugging) {
                var promise = this;
                var stack = error.stack;
                stack = typeof stack === "string" ? stack.split("\n") : [];
                CapturedTrace.protectErrorMessageNewlines(stack);
                var headerLineCount = 1;
                var combinedTraces = 1;
                while (promise != null && promise._trace != null) {
                  stack = CapturedTrace.combine(stack, promise._trace.stack.split("\n"));
                  promise = promise._traceParent;
                  combinedTraces++;
                }
                var stackTraceLimit = Error.stackTraceLimit || 10;
                var max = (stackTraceLimit + headerLineCount) * combinedTraces;
                var len = stack.length;
                if (len > max) {
                  stack.length = max;
                }
                if (len > 0)
                  stack[0] = stack[0].split("\u0002\u0000\u0001").join("\n");
                if (stack.length <= headerLineCount) {
                  error.stack = "(No stack trace)";
                } else {
                  error.stack = stack.join("\n");
                }
              }
            };
            Promise.prototype._cleanValues = function Promise$_cleanValues() {
              if (this._cancellable()) {
                this._cancellationParent = void 0;
              }
            };
            Promise.prototype._propagateFrom = function Promise$_propagateFrom(parent, flags) {
              if ((flags & 1) > 0 && parent._cancellable()) {
                this._setCancellable();
                this._cancellationParent = parent;
              }
              if ((flags & 4) > 0) {
                this._setBoundTo(parent._boundTo);
              }
              if ((flags & 2) > 0) {
                this._setTrace(parent);
              }
            };
            Promise.prototype._fulfill = function Promise$_fulfill(value) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._fulfillUnchecked(value);
            };
            Promise.prototype._reject = function Promise$_reject(reason, carriedStackTrace) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._rejectUnchecked(reason, carriedStackTrace);
            };
            Promise.prototype._settlePromiseAt = function Promise$_settlePromiseAt(index) {
              var handler = this.isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
              var value = this._settledValue;
              var receiver = this._receiverAt(index);
              var promise = this._promiseAt(index);
              if (typeof handler === "function") {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
              } else {
                var done = false;
                var isFulfilled = this.isFulfilled();
                if (receiver !== void 0) {
                  if (receiver instanceof Promise && receiver._isProxied()) {
                    receiver._unsetProxied();
                    if (isFulfilled)
                      receiver._fulfillUnchecked(value);
                    else
                      receiver._rejectUnchecked(value, this._getCarriedStackTrace());
                    done = true;
                  } else if (receiver instanceof PromiseArray) {
                    if (isFulfilled)
                      receiver._promiseFulfilled(value, promise);
                    else
                      receiver._promiseRejected(value, promise);
                    done = true;
                  }
                }
                if (!done) {
                  if (isFulfilled)
                    promise._fulfill(value);
                  else
                    promise._reject(value, this._getCarriedStackTrace());
                }
              }
              if (index >= 4) {
                this._queueGC();
              }
            };
            Promise.prototype._isProxied = function Promise$_isProxied() {
              return (this._bitField & 4194304) === 4194304;
            };
            Promise.prototype._setProxied = function Promise$_setProxied() {
              this._bitField = this._bitField | 4194304;
            };
            Promise.prototype._unsetProxied = function Promise$_unsetProxied() {
              this._bitField = this._bitField & (~4194304);
            };
            Promise.prototype._isGcQueued = function Promise$_isGcQueued() {
              return (this._bitField & -1073741824) === -1073741824;
            };
            Promise.prototype._setGcQueued = function Promise$_setGcQueued() {
              this._bitField = this._bitField | -1073741824;
            };
            Promise.prototype._unsetGcQueued = function Promise$_unsetGcQueued() {
              this._bitField = this._bitField & (~-1073741824);
            };
            Promise.prototype._queueGC = function Promise$_queueGC() {
              if (this._isGcQueued())
                return;
              this._setGcQueued();
              async.invokeLater(this._gc, this, void 0);
            };
            Promise.prototype._gc = function Promise$gc() {
              var len = this._length() * 5 - 5;
              for (var i = 0; i < len; i++) {
                delete this[i];
              }
              this._clearFirstHandlerData();
              this._setLength(0);
              this._unsetGcQueued();
            };
            Promise.prototype._clearFirstHandlerData = function Promise$_clearFirstHandlerData() {
              this._fulfillmentHandler0 = void 0;
              this._rejectionHandler0 = void 0;
              this._promise0 = void 0;
              this._receiver0 = void 0;
            };
            Promise.prototype._queueSettleAt = function Promise$_queueSettleAt(index) {
              if (this._isRejectionUnhandled())
                this._unsetRejectionIsUnhandled();
              async.invoke(this._settlePromiseAt, this, index);
            };
            Promise.prototype._fulfillUnchecked = function Promise$_fulfillUnchecked(value) {
              if (!this.isPending())
                return;
              if (value === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._rejectUnchecked(err, void 0);
              }
              this._cleanValues();
              this._setFulfilled();
              this._settledValue = value;
              var len = this._length();
              if (len > 0) {
                async.invoke(this._settlePromises, this, len);
              }
            };
            Promise.prototype._rejectUncheckedCheckError = function Promise$_rejectUncheckedCheckError(reason) {
              var trace = canAttach(reason) ? reason : new Error(reason + "");
              this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
            };
            Promise.prototype._rejectUnchecked = function Promise$_rejectUnchecked(reason, trace) {
              if (!this.isPending())
                return;
              if (reason === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._rejectUnchecked(err);
              }
              this._cleanValues();
              this._setRejected();
              this._settledValue = reason;
              if (this._isFinal()) {
                async.invokeLater(thrower, void 0, trace === void 0 ? reason : trace);
                return;
              }
              var len = this._length();
              if (trace !== void 0)
                this._setCarriedStackTrace(trace);
              if (len > 0) {
                async.invoke(this._rejectPromises, this, null);
              } else {
                this._ensurePossibleRejectionHandled();
              }
            };
            Promise.prototype._rejectPromises = function Promise$_rejectPromises() {
              this._settlePromises();
              this._unsetCarriedStackTrace();
            };
            Promise.prototype._settlePromises = function Promise$_settlePromises() {
              var len = this._length();
              for (var i = 0; i < len; i++) {
                this._settlePromiseAt(i);
              }
            };
            Promise.prototype._ensurePossibleRejectionHandled = function Promise$_ensurePossibleRejectionHandled() {
              this._setRejectionIsUnhandled();
              if (CapturedTrace.possiblyUnhandledRejection !== void 0) {
                async.invokeLater(this._notifyUnhandledRejection, this, void 0);
              }
            };
            Promise.prototype._notifyUnhandledRejectionIsHandled = function Promise$_notifyUnhandledRejectionIsHandled() {
              if (typeof unhandledRejectionHandled === "function") {
                async.invokeLater(unhandledRejectionHandled, void 0, this);
              }
            };
            Promise.prototype._notifyUnhandledRejection = function Promise$_notifyUnhandledRejection() {
              if (this._isRejectionUnhandled()) {
                var reason = this._settledValue;
                var trace = this._getCarriedStackTrace();
                this._setUnhandledRejectionIsNotified();
                if (trace !== void 0) {
                  this._unsetCarriedStackTrace();
                  reason = trace;
                }
                if (typeof CapturedTrace.possiblyUnhandledRejection === "function") {
                  CapturedTrace.possiblyUnhandledRejection(reason, this);
                }
              }
            };
            var contextStack = [];
            Promise.prototype._peekContext = function Promise$_peekContext() {
              var lastIndex = contextStack.length - 1;
              if (lastIndex >= 0) {
                return contextStack[lastIndex];
              }
              return void 0;
            };
            Promise.prototype._pushContext = function Promise$_pushContext() {
              if (!debugging)
                return;
              contextStack.push(this);
            };
            Promise.prototype._popContext = function Promise$_popContext() {
              if (!debugging)
                return;
              contextStack.pop();
            };
            Promise.noConflict = function Promise$NoConflict() {
              return noConflict(Promise);
            };
            Promise.setScheduler = function(fn) {
              if (typeof fn !== "function")
                throw new TypeError("fn must be a function");
              async._schedule = fn;
            };
            if (!CapturedTrace.isSupported()) {
              Promise.longStackTraces = function() {};
              debugging = false;
            }
            Promise._makeSelfResolutionError = makeSelfResolutionError;
            _dereq_("./finally.js")(Promise, NEXT_FILTER, cast);
            _dereq_("./direct_resolve.js")(Promise);
            _dereq_("./synchronous_inspection.js")(Promise);
            _dereq_("./join.js")(Promise, PromiseArray, cast, INTERNAL);
            Promise.RangeError = RangeError;
            Promise.CancellationError = CancellationError;
            Promise.TimeoutError = TimeoutError;
            Promise.TypeError = TypeError;
            Promise.OperationalError = OperationalError;
            Promise.RejectionError = OperationalError;
            Promise.AggregateError = errors.AggregateError;
            util.toFastProperties(Promise);
            util.toFastProperties(Promise.prototype);
            Promise.Promise = Promise;
            _dereq_('./nodeify.js')(Promise);
            Promise.prototype = Promise.prototype;
            return Promise;
          };
        }, {
          "./async.js": 1,
          "./captured_trace.js": 3,
          "./catch_filter.js": 4,
          "./direct_resolve.js": 5,
          "./errors.js": 6,
          "./errors_api_rejection": 7,
          "./finally.js": 9,
          "./join.js": 10,
          "./nodeify.js": 11,
          "./promise_array.js": 13,
          "./promise_resolver.js": 14,
          "./synchronous_inspection.js": 17,
          "./thenables.js": 18,
          "./util.js": 19
        }],
        13: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, cast) {
            var canAttach = _dereq_("./errors.js").canAttach;
            var util = _dereq_("./util.js");
            var isArray = util.isArray;
            function toResolutionValue(val) {
              switch (val) {
                case -1:
                  return void 0;
                case -2:
                  return [];
                case -3:
                  return {};
              }
            }
            function PromiseArray(values) {
              var promise = this._promise = new Promise(INTERNAL);
              var parent = void 0;
              if (values instanceof Promise) {
                parent = values;
                promise._propagateFrom(parent, 1 | 4);
              }
              promise._setTrace(parent);
              this._values = values;
              this._length = 0;
              this._totalResolved = 0;
              this._init(void 0, -2);
            }
            PromiseArray.prototype.length = function PromiseArray$length() {
              return this._length;
            };
            PromiseArray.prototype.promise = function PromiseArray$promise() {
              return this._promise;
            };
            PromiseArray.prototype._init = function PromiseArray$_init(_, resolveValueIfEmpty) {
              var values = cast(this._values, void 0);
              if (values instanceof Promise) {
                this._values = values;
                values._setBoundTo(this._promise._boundTo);
                if (values.isFulfilled()) {
                  values = values._settledValue;
                  if (!isArray(values)) {
                    var err = new Promise.TypeError("expecting an array, a promise or a thenable");
                    this.__hardReject__(err);
                    return;
                  }
                } else if (values.isPending()) {
                  values._then(PromiseArray$_init, this._reject, void 0, this, resolveValueIfEmpty);
                  return;
                } else {
                  values._unsetRejectionIsUnhandled();
                  this._reject(values._settledValue);
                  return;
                }
              } else if (!isArray(values)) {
                var err = new Promise.TypeError("expecting an array, a promise or a thenable");
                this.__hardReject__(err);
                return;
              }
              if (values.length === 0) {
                if (resolveValueIfEmpty === -5) {
                  this._resolveEmptyArray();
                } else {
                  this._resolve(toResolutionValue(resolveValueIfEmpty));
                }
                return;
              }
              var len = this.getActualLength(values.length);
              var newLen = len;
              var newValues = this.shouldCopyValues() ? new Array(len) : this._values;
              var isDirectScanNeeded = false;
              for (var i = 0; i < len; ++i) {
                var maybePromise = cast(values[i], void 0);
                if (maybePromise instanceof Promise) {
                  if (maybePromise.isPending()) {
                    maybePromise._proxyPromiseArray(this, i);
                  } else {
                    maybePromise._unsetRejectionIsUnhandled();
                    isDirectScanNeeded = true;
                  }
                } else {
                  isDirectScanNeeded = true;
                }
                newValues[i] = maybePromise;
              }
              this._values = newValues;
              this._length = newLen;
              if (isDirectScanNeeded) {
                this._scanDirectValues(len);
              }
            };
            PromiseArray.prototype._settlePromiseAt = function PromiseArray$_settlePromiseAt(index) {
              var value = this._values[index];
              if (!(value instanceof Promise)) {
                this._promiseFulfilled(value, index);
              } else if (value.isFulfilled()) {
                this._promiseFulfilled(value._settledValue, index);
              } else if (value.isRejected()) {
                this._promiseRejected(value._settledValue, index);
              }
            };
            PromiseArray.prototype._scanDirectValues = function PromiseArray$_scanDirectValues(len) {
              for (var i = 0; i < len; ++i) {
                if (this._isResolved()) {
                  break;
                }
                this._settlePromiseAt(i);
              }
            };
            PromiseArray.prototype._isResolved = function PromiseArray$_isResolved() {
              return this._values === null;
            };
            PromiseArray.prototype._resolve = function PromiseArray$_resolve(value) {
              this._values = null;
              this._promise._fulfill(value);
            };
            PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function PromiseArray$_reject(reason) {
              this._values = null;
              var trace = canAttach(reason) ? reason : new Error(reason + "");
              this._promise._attachExtraTrace(trace);
              this._promise._reject(reason, trace);
            };
            PromiseArray.prototype._promiseProgressed = function PromiseArray$_promiseProgressed(progressValue, index) {
              if (this._isResolved())
                return;
              this._promise._progress({
                index: index,
                value: progressValue
              });
            };
            PromiseArray.prototype._promiseFulfilled = function PromiseArray$_promiseFulfilled(value, index) {
              if (this._isResolved())
                return;
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                this._resolve(this._values);
              }
            };
            PromiseArray.prototype._promiseRejected = function PromiseArray$_promiseRejected(reason, index) {
              if (this._isResolved())
                return;
              this._totalResolved++;
              this._reject(reason);
            };
            PromiseArray.prototype.shouldCopyValues = function PromiseArray$_shouldCopyValues() {
              return true;
            };
            PromiseArray.prototype.getActualLength = function PromiseArray$getActualLength(len) {
              return len;
            };
            return PromiseArray;
          };
        }, {
          "./errors.js": 6,
          "./util.js": 19
        }],
        14: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util.js");
          var maybeWrapAsError = util.maybeWrapAsError;
          var errors = _dereq_("./errors.js");
          var TimeoutError = errors.TimeoutError;
          var OperationalError = errors.OperationalError;
          var async = _dereq_("./async.js");
          var haveGetters = util.haveGetters;
          var es5 = _dereq_("./es5.js");
          function isUntypedError(obj) {
            return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
          }
          function wrapAsOperationalError(obj) {
            var ret;
            if (isUntypedError(obj)) {
              ret = new OperationalError(obj);
            } else {
              ret = obj;
            }
            errors.markAsOriginatingFromRejection(ret);
            return ret;
          }
          function nodebackForPromise(promise) {
            function PromiseResolver$_callback(err, value) {
              if (promise === null)
                return;
              if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
              } else if (arguments.length > 2) {
                var $_len = arguments.length;
                var args = new Array($_len - 1);
                for (var $_i = 1; $_i < $_len; ++$_i) {
                  args[$_i - 1] = arguments[$_i];
                }
                promise._fulfill(args);
              } else {
                promise._fulfill(value);
              }
              promise = null;
            }
            return PromiseResolver$_callback;
          }
          var PromiseResolver;
          if (!haveGetters) {
            PromiseResolver = function PromiseResolver(promise) {
              this.promise = promise;
              this.asCallback = nodebackForPromise(promise);
              this.callback = this.asCallback;
            };
          } else {
            PromiseResolver = function PromiseResolver(promise) {
              this.promise = promise;
            };
          }
          if (haveGetters) {
            var prop = {get: function() {
                return nodebackForPromise(this.promise);
              }};
            es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
            es5.defineProperty(PromiseResolver.prototype, "callback", prop);
          }
          PromiseResolver._nodebackForPromise = nodebackForPromise;
          PromiseResolver.prototype.toString = function PromiseResolver$toString() {
            return "[object PromiseResolver]";
          };
          PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function PromiseResolver$resolve(value) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
            }
            var promise = this.promise;
            if (promise._tryFollow(value)) {
              return;
            }
            async.invoke(promise._fulfill, promise, value);
          };
          PromiseResolver.prototype.reject = function PromiseResolver$reject(reason) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
            }
            var promise = this.promise;
            errors.markAsOriginatingFromRejection(reason);
            var trace = errors.canAttach(reason) ? reason : new Error(reason + "");
            promise._attachExtraTrace(trace);
            async.invoke(promise._reject, promise, reason);
            if (trace !== reason) {
              async.invoke(this._setCarriedStackTrace, this, trace);
            }
          };
          PromiseResolver.prototype.progress = function PromiseResolver$progress(value) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
            }
            async.invoke(this.promise._progress, this.promise, value);
          };
          PromiseResolver.prototype.cancel = function PromiseResolver$cancel() {
            async.invoke(this.promise.cancel, this.promise, void 0);
          };
          PromiseResolver.prototype.timeout = function PromiseResolver$timeout() {
            this.reject(new TimeoutError("timeout"));
          };
          PromiseResolver.prototype.isResolved = function PromiseResolver$isResolved() {
            return this.promise.isResolved();
          };
          PromiseResolver.prototype.toJSON = function PromiseResolver$toJSON() {
            return this.promise.toJSON();
          };
          PromiseResolver.prototype._setCarriedStackTrace = function PromiseResolver$_setCarriedStackTrace(trace) {
            if (this.promise.isRejected()) {
              this.promise._setCarriedStackTrace(trace);
            }
          };
          module.exports = PromiseResolver;
        }, {
          "./async.js": 1,
          "./errors.js": 6,
          "./es5.js": 8,
          "./util.js": 19
        }],
        15: [function(_dereq_, module, exports) {
          "use strict";
          function arrayCopy(src, srcIndex, dst, dstIndex, len) {
            for (var j = 0; j < len; ++j) {
              dst[j + dstIndex] = src[j + srcIndex];
            }
          }
          function Queue(capacity) {
            this._capacity = capacity;
            this._length = 0;
            this._front = 0;
            this._makeCapacity();
          }
          Queue.prototype._willBeOverCapacity = function Queue$_willBeOverCapacity(size) {
            return this._capacity < size;
          };
          Queue.prototype._pushOne = function Queue$_pushOne(arg) {
            var length = this.length();
            this._checkCapacity(length + 1);
            var i = (this._front + length) & (this._capacity - 1);
            this[i] = arg;
            this._length = length + 1;
          };
          Queue.prototype.push = function Queue$push(fn, receiver, arg) {
            var length = this.length() + 3;
            if (this._willBeOverCapacity(length)) {
              this._pushOne(fn);
              this._pushOne(receiver);
              this._pushOne(arg);
              return;
            }
            var j = this._front + length - 3;
            this._checkCapacity(length);
            var wrapMask = this._capacity - 1;
            this[(j + 0) & wrapMask] = fn;
            this[(j + 1) & wrapMask] = receiver;
            this[(j + 2) & wrapMask] = arg;
            this._length = length;
          };
          Queue.prototype.shift = function Queue$shift() {
            var front = this._front,
                ret = this[front];
            this[front] = void 0;
            this._front = (front + 1) & (this._capacity - 1);
            this._length--;
            return ret;
          };
          Queue.prototype.length = function Queue$length() {
            return this._length;
          };
          Queue.prototype._makeCapacity = function Queue$_makeCapacity() {
            var len = this._capacity;
            for (var i = 0; i < len; ++i) {
              this[i] = void 0;
            }
          };
          Queue.prototype._checkCapacity = function Queue$_checkCapacity(size) {
            if (this._capacity < size) {
              this._resizeTo(this._capacity << 3);
            }
          };
          Queue.prototype._resizeTo = function Queue$_resizeTo(capacity) {
            var oldFront = this._front;
            var oldCapacity = this._capacity;
            var oldQueue = new Array(oldCapacity);
            var length = this.length();
            arrayCopy(this, 0, oldQueue, 0, oldCapacity);
            this._capacity = capacity;
            this._makeCapacity();
            this._front = 0;
            if (oldFront + length <= oldCapacity) {
              arrayCopy(oldQueue, oldFront, this, 0, length);
            } else {
              var lengthBeforeWrapping = length - ((oldFront + length) & (oldCapacity - 1));
              arrayCopy(oldQueue, oldFront, this, 0, lengthBeforeWrapping);
              arrayCopy(oldQueue, 0, this, lengthBeforeWrapping, length - lengthBeforeWrapping);
            }
          };
          module.exports = Queue;
        }, {}],
        16: [function(_dereq_, module, exports) {
          "use strict";
          var schedule;
          var _MutationObserver;
          if (typeof process === "object" && typeof process.version === "string") {
            schedule = function Promise$_Scheduler(fn) {
              process.nextTick(fn);
            };
          } else if ((typeof MutationObserver !== "undefined" && (_MutationObserver = MutationObserver)) || (typeof WebKitMutationObserver !== "undefined" && (_MutationObserver = WebKitMutationObserver))) {
            schedule = (function() {
              var div = document.createElement("div");
              var queuedFn = void 0;
              var observer = new _MutationObserver(function Promise$_Scheduler() {
                var fn = queuedFn;
                queuedFn = void 0;
                fn();
              });
              observer.observe(div, {attributes: true});
              return function Promise$_Scheduler(fn) {
                queuedFn = fn;
                div.classList.toggle("foo");
              };
            })();
          } else if (typeof setTimeout !== "undefined") {
            schedule = function Promise$_Scheduler(fn) {
              setTimeout(fn, 0);
            };
          } else
            throw new Error("no async scheduler available");
          module.exports = schedule;
        }, {}],
        17: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            function PromiseInspection(promise) {
              if (promise !== void 0) {
                this._bitField = promise._bitField;
                this._settledValue = promise.isResolved() ? promise._settledValue : void 0;
              } else {
                this._bitField = 0;
                this._settledValue = void 0;
              }
            }
            PromiseInspection.prototype.isFulfilled = Promise.prototype.isFulfilled = function Promise$isFulfilled() {
              return (this._bitField & 268435456) > 0;
            };
            PromiseInspection.prototype.isRejected = Promise.prototype.isRejected = function Promise$isRejected() {
              return (this._bitField & 134217728) > 0;
            };
            PromiseInspection.prototype.isPending = Promise.prototype.isPending = function Promise$isPending() {
              return (this._bitField & 402653184) === 0;
            };
            PromiseInspection.prototype.value = Promise.prototype.value = function Promise$value() {
              if (!this.isFulfilled()) {
                throw new TypeError("cannot get fulfillment value of a non-fulfilled promise");
              }
              return this._settledValue;
            };
            PromiseInspection.prototype.error = PromiseInspection.prototype.reason = Promise.prototype.reason = function Promise$reason() {
              if (!this.isRejected()) {
                throw new TypeError("cannot get rejection reason of a non-rejected promise");
              }
              return this._settledValue;
            };
            PromiseInspection.prototype.isResolved = Promise.prototype.isResolved = function Promise$isResolved() {
              return (this._bitField & 402653184) > 0;
            };
            Promise.PromiseInspection = PromiseInspection;
          };
        }, {}],
        18: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var util = _dereq_("./util.js");
            var canAttach = _dereq_("./errors.js").canAttach;
            var errorObj = util.errorObj;
            var isObject = util.isObject;
            function getThen(obj) {
              try {
                return obj.then;
              } catch (e) {
                errorObj.e = e;
                return errorObj;
              }
            }
            function Promise$_Cast(obj, originalPromise) {
              if (isObject(obj)) {
                if (obj instanceof Promise) {
                  return obj;
                } else if (isAnyBluebirdPromise(obj)) {
                  var ret = new Promise(INTERNAL);
                  ret._setTrace(void 0);
                  obj._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null);
                  ret._setFollowing();
                  return ret;
                }
                var then = getThen(obj);
                if (then === errorObj) {
                  if (originalPromise !== void 0 && canAttach(then.e)) {
                    originalPromise._attachExtraTrace(then.e);
                  }
                  return Promise.reject(then.e);
                } else if (typeof then === "function") {
                  return Promise$_doThenable(obj, then, originalPromise);
                }
              }
              return obj;
            }
            var hasProp = {}.hasOwnProperty;
            function isAnyBluebirdPromise(obj) {
              return hasProp.call(obj, "_promise0");
            }
            function Promise$_doThenable(x, then, originalPromise) {
              var resolver = Promise.defer();
              var called = false;
              try {
                then.call(x, Promise$_resolveFromThenable, Promise$_rejectFromThenable, Promise$_progressFromThenable);
              } catch (e) {
                if (!called) {
                  called = true;
                  var trace = canAttach(e) ? e : new Error(e + "");
                  if (originalPromise !== void 0) {
                    originalPromise._attachExtraTrace(trace);
                  }
                  resolver.promise._reject(e, trace);
                }
              }
              return resolver.promise;
              function Promise$_resolveFromThenable(y) {
                if (called)
                  return;
                called = true;
                if (x === y) {
                  var e = Promise._makeSelfResolutionError();
                  if (originalPromise !== void 0) {
                    originalPromise._attachExtraTrace(e);
                  }
                  resolver.promise._reject(e, void 0);
                  return;
                }
                resolver.resolve(y);
              }
              function Promise$_rejectFromThenable(r) {
                if (called)
                  return;
                called = true;
                var trace = canAttach(r) ? r : new Error(r + "");
                if (originalPromise !== void 0) {
                  originalPromise._attachExtraTrace(trace);
                }
                resolver.promise._reject(r, trace);
              }
              function Promise$_progressFromThenable(v) {
                if (called)
                  return;
                var promise = resolver.promise;
                if (typeof promise._progress === "function") {
                  promise._progress(v);
                }
              }
            }
            return Promise$_Cast;
          };
        }, {
          "./errors.js": 6,
          "./util.js": 19
        }],
        19: [function(_dereq_, module, exports) {
          "use strict";
          var es5 = _dereq_("./es5.js");
          var haveGetters = (function() {
            try {
              var o = {};
              es5.defineProperty(o, "f", {get: function() {
                  return 3;
                }});
              return o.f === 3;
            } catch (e) {
              return false;
            }
          })();
          var canEvaluate = typeof navigator == "undefined";
          var errorObj = {e: {}};
          function tryCatch1(fn, receiver, arg) {
            try {
              return fn.call(receiver, arg);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch2(fn, receiver, arg, arg2) {
            try {
              return fn.call(receiver, arg, arg2);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch3(fn, receiver, arg, arg2, arg3) {
            try {
              return fn.call(receiver, arg, arg2, arg3);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch4(fn, receiver, arg, arg2, arg3, arg4) {
            try {
              return fn.call(receiver, arg, arg2, arg3, arg4);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatchApply(fn, args, receiver) {
            try {
              return fn.apply(receiver, args);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          var inherits = function(Child, Parent) {
            var hasProp = {}.hasOwnProperty;
            function T() {
              this.constructor = Child;
              this.constructor$ = Parent;
              for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                  this[propertyName + "$"] = Parent.prototype[propertyName];
                }
              }
            }
            T.prototype = Parent.prototype;
            Child.prototype = new T();
            return Child.prototype;
          };
          function asString(val) {
            return typeof val === "string" ? val : ("" + val);
          }
          function isPrimitive(val) {
            return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
          }
          function isObject(value) {
            return !isPrimitive(value);
          }
          function maybeWrapAsError(maybeError) {
            if (!isPrimitive(maybeError))
              return maybeError;
            return new Error(asString(maybeError));
          }
          function withAppended(target, appendee) {
            var len = target.length;
            var ret = new Array(len + 1);
            var i;
            for (i = 0; i < len; ++i) {
              ret[i] = target[i];
            }
            ret[i] = appendee;
            return ret;
          }
          function getDataPropertyOrDefault(obj, key, defaultValue) {
            if (es5.isES5) {
              var desc = Object.getOwnPropertyDescriptor(obj, key);
              if (desc != null) {
                return desc.get == null && desc.set == null ? desc.value : defaultValue;
              }
            } else {
              return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
            }
          }
          function notEnumerableProp(obj, name, value) {
            if (isPrimitive(obj))
              return obj;
            var descriptor = {
              value: value,
              configurable: true,
              enumerable: false,
              writable: true
            };
            es5.defineProperty(obj, name, descriptor);
            return obj;
          }
          var wrapsPrimitiveReceiver = (function() {
            return this !== "string";
          }).call("string");
          function thrower(r) {
            throw r;
          }
          var inheritedDataKeys = (function() {
            if (es5.isES5) {
              return function(obj, opts) {
                var ret = [];
                var visitedKeys = Object.create(null);
                var getKeys = Object(opts).includeHidden ? Object.getOwnPropertyNames : Object.keys;
                while (obj != null) {
                  var keys;
                  try {
                    keys = getKeys(obj);
                  } catch (e) {
                    return ret;
                  }
                  for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key])
                      continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                      ret.push(key);
                    }
                  }
                  obj = es5.getPrototypeOf(obj);
                }
                return ret;
              };
            } else {
              return function(obj) {
                var ret = [];
                for (var key in obj) {
                  ret.push(key);
                }
                return ret;
              };
            }
          })();
          function isClass(fn) {
            try {
              if (typeof fn === "function") {
                var keys = es5.keys(fn.prototype);
                return keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
              }
              return false;
            } catch (e) {
              return false;
            }
          }
          function toFastProperties(obj) {
            function f() {}
            f.prototype = obj;
            return f;
            eval(obj);
          }
          var rident = /^[a-z$_][a-z$_0-9]*$/i;
          function isIdentifier(str) {
            return rident.test(str);
          }
          function filledRange(count, prefix, suffix) {
            var ret = new Array(count);
            for (var i = 0; i < count; ++i) {
              ret[i] = prefix + i + suffix;
            }
            return ret;
          }
          var ret = {
            isClass: isClass,
            isIdentifier: isIdentifier,
            inheritedDataKeys: inheritedDataKeys,
            getDataPropertyOrDefault: getDataPropertyOrDefault,
            thrower: thrower,
            isArray: es5.isArray,
            haveGetters: haveGetters,
            notEnumerableProp: notEnumerableProp,
            isPrimitive: isPrimitive,
            isObject: isObject,
            canEvaluate: canEvaluate,
            errorObj: errorObj,
            tryCatch1: tryCatch1,
            tryCatch2: tryCatch2,
            tryCatch3: tryCatch3,
            tryCatch4: tryCatch4,
            tryCatchApply: tryCatchApply,
            inherits: inherits,
            withAppended: withAppended,
            asString: asString,
            maybeWrapAsError: maybeWrapAsError,
            wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
            toFastProperties: toFastProperties,
            filledRange: filledRange
          };
          module.exports = ret;
        }, {"./es5.js": 8}]
      }, {}, [2])(2);
    });
    ;
    if (typeof window !== 'undefined' && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== 'undefined' && self !== null) {
      self.P = self.Promise;
    }
    (function(global) {
      Promise.defer = function() {
        var resolve,
            reject;
        var promise = new Promise(function() {
          resolve = arguments[0];
          reject = arguments[1];
        });
        return {
          resolve: resolve,
          reject: reject,
          promise: promise
        };
      };
      function logError(error) {
        if (typeof(error) === 'string') {
          console.error(error);
        } else {
          console.error(error.message, error.stack);
        }
      }
      function emitUnauthorized(r) {
        if (r.statusCode === 403 || r.statusCode === 401) {
          this._emit('error', new RemoteStorage.Unauthorized());
        }
        return Promise.resolve(r);
      }
      function shareFirst(path) {
        return (this.backend === 'dropbox' && path.match(/^\/public\/.*[^\/]$/));
      }
      var SyncedGetPutDelete = {
        get: function(path, maxAge) {
          var self = this;
          if (this.local) {
            if (maxAge === undefined) {
              if ((typeof this.remote === 'object') && this.remote.connected && this.remote.online) {
                maxAge = 2 * this.getSyncInterval();
              } else {
                RemoteStorage.log('Not setting default maxAge, because remote is offline or not connected');
                maxAge = false;
              }
            }
            var maxAgeInvalid = function(maxAge) {
              return maxAge !== false && typeof(maxAge) !== 'number';
            };
            if (maxAgeInvalid(maxAge)) {
              return Promise.reject('Argument \'maxAge\' must be false or a number');
            }
            return this.local.get(path, maxAge, this.sync.queueGetRequest.bind(this.sync));
          } else {
            return this.remote.get(path);
          }
        },
        put: function(path, body, contentType) {
          if (shareFirst.bind(this)(path)) {
            return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.put(path, body, contentType));
          } else if (this.local) {
            return this.local.put(path, body, contentType);
          } else {
            return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.put(path, body, contentType));
          }
        },
        'delete': function(path) {
          if (this.local) {
            return this.local.delete(path);
          } else {
            return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.delete(path));
          }
        },
        _wrapBusyDone: function(result) {
          var self = this;
          this._emit('wire-busy');
          return result.then(function(r) {
            self._emit('wire-done', {success: true});
            return Promise.resolve(r);
          }, function(err) {
            self._emit('wire-done', {success: false});
            return Promise.reject(err);
          });
        }
      };
      var RemoteStorage = function(cfg) {
        if (typeof cfg === 'object') {
          RemoteStorage.config.logging = !!cfg.logging;
          RemoteStorage.config.cordovaRedirectUri = cfg.cordovaRedirectUri;
        }
        RemoteStorage.eventHandling(this, 'ready', 'connected', 'disconnected', 'not-connected', 'conflict', 'error', 'features-loaded', 'connecting', 'authing', 'wire-busy', 'wire-done', 'sync-interval-change');
        this._pending = [];
        this._setGPD({
          get: this._pendingGPD('get'),
          put: this._pendingGPD('put'),
          delete: this._pendingGPD('delete')
        });
        this._cleanups = [];
        this._pathHandlers = {change: {}};
        this.apiKeys = {};
        if (this.localStorageAvailable()) {
          try {
            this.apiKeys = JSON.parse(localStorage['remotestorage:api-keys']);
          } catch (exc) {}
          this.setBackend(localStorage['remotestorage:backend'] || 'remotestorage');
        }
        var origOn = this.on;
        this.on = function(eventName, handler) {
          if (eventName === 'ready' && this.remote.connected && this._allLoaded) {
            setTimeout(handler, 0);
          } else if (eventName === 'features-loaded' && this._allLoaded) {
            setTimeout(handler, 0);
          }
          return origOn.call(this, eventName, handler);
        };
        this._init();
        this.fireInitial = function() {
          if (this.local) {
            setTimeout(this.local.fireInitial.bind(this.local), 0);
          }
        }.bind(this);
        this.on('ready', this.fireInitial.bind(this));
      };
      RemoteStorage.SyncedGetPutDelete = SyncedGetPutDelete;
      RemoteStorage.DiscoveryError = function(message) {
        Error.apply(this, arguments);
        this.message = message;
      };
      RemoteStorage.DiscoveryError.prototype = Object.create(Error.prototype);
      RemoteStorage.Unauthorized = function() {
        Error.apply(this, arguments);
      };
      RemoteStorage.Unauthorized.prototype = Object.create(Error.prototype);
      RemoteStorage.log = function() {
        if (RemoteStorage.config.logging) {
          console.log.apply(console, arguments);
        }
      };
      RemoteStorage.config = {
        logging: false,
        changeEvents: {
          local: true,
          window: false,
          remote: true,
          conflict: true
        },
        discoveryTimeout: 10000,
        cordovaRedirectUri: undefined
      };
      RemoteStorage.prototype = {
        connect: function(userAddress, token) {
          this.setBackend('remotestorage');
          if (userAddress.indexOf('@') < 0) {
            this._emit('error', new RemoteStorage.DiscoveryError("User address doesn't contain an @."));
            return;
          }
          if (global.cordova) {
            if (typeof RemoteStorage.config.cordovaRedirectUri !== 'string') {
              this._emit('error', new RemoteStorage.DiscoveryError("Please supply a custom HTTPS redirect URI for your Cordova app"));
              return;
            }
            if (!global.cordova.InAppBrowser) {
              this._emit('error', new RemoteStorage.DiscoveryError("Please include the InAppBrowser Cordova plugin to enable OAuth"));
              return;
            }
          }
          this.remote.configure({userAddress: userAddress});
          this._emit('connecting');
          var discoveryTimeout = setTimeout(function() {
            this._emit('error', new RemoteStorage.DiscoveryError("No storage information found at that user address."));
          }.bind(this), RemoteStorage.config.discoveryTimeout);
          RemoteStorage.Discover(userAddress).then(function(info) {
            clearTimeout(discoveryTimeout);
            this._emit('authing');
            info.userAddress = userAddress;
            this.remote.configure(info);
            if (!this.remote.connected) {
              if (info.authURL) {
                if (typeof token === 'undefined') {
                  this.authorize(info.authURL, RemoteStorage.config.cordovaRedirectUri);
                } else if (typeof token === 'string') {
                  RemoteStorage.log('Skipping authorization sequence and connecting with known token');
                  this.remote.configure({token: token});
                } else {
                  throw new Error("Supplied bearer token must be a string");
                }
              } else {
                this.impliedauth();
              }
            }
          }.bind(this), function(err) {
            this._emit('error', new RemoteStorage.DiscoveryError("Failed to contact storage server."));
          }.bind(this));
        },
        disconnect: function() {
          if (this.remote) {
            this.remote.configure({
              userAddress: null,
              href: null,
              storageApi: null,
              token: null,
              properties: null
            });
          }
          this._setGPD({
            get: this._pendingGPD('get'),
            put: this._pendingGPD('put'),
            delete: this._pendingGPD('delete')
          });
          var n = this._cleanups.length,
              i = 0;
          var oneDone = function() {
            i++;
            if (i >= n) {
              this._init();
              RemoteStorage.log('Done cleaning up, emitting disconnected and disconnect events');
              this._emit('disconnected');
            }
          }.bind(this);
          if (n > 0) {
            this._cleanups.forEach(function(cleanup) {
              var cleanupResult = cleanup(this);
              if (typeof(cleanup) === 'object' && typeof(cleanup.then) === 'function') {
                cleanupResult.then(oneDone);
              } else {
                oneDone();
              }
            }.bind(this));
          } else {
            oneDone();
          }
        },
        setBackend: function(what) {
          this.backend = what;
          if (this.localStorageAvailable()) {
            if (what) {
              localStorage['remotestorage:backend'] = what;
            } else {
              delete localStorage['remotestorage:backend'];
            }
          }
        },
        onChange: function(path, handler) {
          if (!this._pathHandlers.change[path]) {
            this._pathHandlers.change[path] = [];
          }
          this._pathHandlers.change[path].push(handler);
        },
        enableLog: function() {
          RemoteStorage.config.logging = true;
        },
        disableLog: function() {
          RemoteStorage.config.logging = false;
        },
        log: function() {
          RemoteStorage.log.apply(RemoteStorage, arguments);
        },
        setApiKeys: function(type, keys) {
          if (keys) {
            this.apiKeys[type] = keys;
          } else {
            delete this.apiKeys[type];
          }
          if (this.localStorageAvailable()) {
            localStorage['remotestorage:api-keys'] = JSON.stringify(this.apiKeys);
          }
        },
        setCordovaRedirectUri: function(uri) {
          if (typeof uri !== 'string' || !uri.match(/http(s)?\:\/\//)) {
            throw new Error("Cordova redirect URI must be a URI string");
          }
          RemoteStorage.config.cordovaRedirectUri = uri;
        },
        _init: function() {
          var self = this,
              readyFired = false;
          function fireReady() {
            try {
              if (!readyFired) {
                self._emit('ready');
                readyFired = true;
              }
            } catch (e) {
              console.error("'ready' failed: ", e, e.stack);
              self._emit('error', e);
            }
          }
          this._loadFeatures(function(features) {
            this.log('[RemoteStorage] All features loaded');
            this.local = features.local && new features.local();
            if (this.local && this.remote) {
              this._setGPD(SyncedGetPutDelete, this);
              this._bindChange(this.local);
            } else if (this.remote) {
              this._setGPD(this.remote, this.remote);
            }
            if (this.remote) {
              this.remote.on('connected', function() {
                fireReady();
                self._emit('connected');
              });
              this.remote.on('not-connected', function() {
                fireReady();
                self._emit('not-connected');
              });
              if (this.remote.connected) {
                fireReady();
                self._emit('connected');
              }
              if (!this.hasFeature('Authorize')) {
                this.remote.stopWaitingForToken();
              }
            }
            this._collectCleanupFunctions();
            try {
              this._allLoaded = true;
              this._emit('features-loaded');
            } catch (exc) {
              logError(exc);
              this._emit('error', exc);
            }
            this._processPending();
          }.bind(this));
        },
        _collectCleanupFunctions: function() {
          for (var i = 0; i < this.features.length; i++) {
            var cleanup = this.features[i].cleanup;
            if (typeof(cleanup) === 'function') {
              this._cleanups.push(cleanup);
            }
          }
        },
        _loadFeatures: function(callback) {
          var featureList = ['WireClient', 'I18n', 'Dropbox', 'GoogleDrive', 'Access', 'Caching', 'Discover', 'Authorize', 'Widget', 'IndexedDB', 'LocalStorage', 'InMemoryStorage', 'Sync', 'BaseClient', 'Env'];
          var features = [];
          var featuresDone = 0;
          var self = this;
          function featureDone() {
            featuresDone++;
            if (featuresDone === featureList.length) {
              setTimeout(function() {
                features.caching = !!RemoteStorage.Caching;
                features.sync = !!RemoteStorage.Sync;
                ['IndexedDB', 'LocalStorage', 'InMemoryStorage'].some(function(cachingLayer) {
                  if (features.some(function(feature) {
                    return feature.name === cachingLayer;
                  })) {
                    features.local = RemoteStorage[cachingLayer];
                    return true;
                  }
                });
                self.features = features;
                callback(features);
              }, 0);
            }
          }
          function featureInitialized(name) {
            self.log("[RemoteStorage] [FEATURE " + name + "] initialized.");
            features.push({
              name: name,
              init: RemoteStorage[name]._rs_init,
              supported: true,
              cleanup: RemoteStorage[name]._rs_cleanup
            });
            featureDone();
          }
          function featureFailed(name, err) {
            self.log("[RemoteStorage] [FEATURE " + name + "] initialization failed ( " + err + ")");
            featureDone();
          }
          function featureSupported(name, success) {
            self.log("[RemoteStorage] [FEATURE " + name + "]" + success ? "" : " not" + " supported");
            if (!success) {
              featureDone();
            }
          }
          function initFeature(name) {
            var initResult;
            try {
              initResult = RemoteStorage[name]._rs_init(self);
            } catch (e) {
              featureFailed(name, e);
              return;
            }
            if (typeof(initResult) === 'object' && typeof(initResult.then) === 'function') {
              initResult.then(function() {
                featureInitialized(name);
              }, function(err) {
                featureFailed(name, err);
              });
            } else {
              featureInitialized(name);
            }
          }
          featureList.forEach(function(featureName) {
            self.log("[RemoteStorage] [FEATURE " + featureName + "] initializing...");
            var impl = RemoteStorage[featureName];
            var supported;
            if (impl) {
              supported = !impl._rs_supported || impl._rs_supported();
              if (typeof supported === 'object') {
                supported.then(function() {
                  featureSupported(featureName, true);
                  initFeature(featureName);
                }, function() {
                  featureSupported(featureName, false);
                });
              } else if (typeof supported === 'boolean') {
                featureSupported(featureName, supported);
                if (supported) {
                  initFeature(featureName);
                }
              }
            } else {
              featureSupported(featureName, false);
            }
          });
        },
        hasFeature: function(feature) {
          for (var i = this.features.length - 1; i >= 0; i--) {
            if (this.features[i].name === feature) {
              return this.features[i].supported;
            }
          }
          return false;
        },
        localStorageAvailable: function() {
          try {
            return !!global.localStorage;
          } catch (error) {
            return false;
          }
        },
        _setGPD: function(impl, context) {
          function wrap(func) {
            return function() {
              return func.apply(context, arguments).then(emitUnauthorized.bind(this));
            };
          }
          this.get = wrap(impl.get);
          this.put = wrap(impl.put);
          this.delete = wrap(impl.delete);
        },
        _pendingGPD: function(methodName) {
          return function() {
            var pending = Promise.defer();
            this._pending.push({
              method: methodName,
              args: Array.prototype.slice.call(arguments),
              promise: pending
            });
            return pending.promise;
          }.bind(this);
        },
        _processPending: function() {
          this._pending.forEach(function(pending) {
            try {
              this[pending.method].apply(this, pending.args).then(pending.promise.resolve, pending.promise.reject);
            } catch (e) {
              pending.promise.reject(e);
            }
          }.bind(this));
          this._pending = [];
        },
        _bindChange: function(object) {
          object.on('change', this._dispatchEvent.bind(this, 'change'));
        },
        _dispatchEvent: function(eventName, event) {
          var self = this;
          Object.keys(this._pathHandlers[eventName]).forEach(function(path) {
            var pl = path.length;
            if (event.path.substr(0, pl) === path) {
              self._pathHandlers[eventName][path].forEach(function(handler) {
                var ev = {};
                for (var key in event) {
                  ev[key] = event[key];
                }
                ev.relativePath = event.path.replace(new RegExp('^' + path), '');
                try {
                  handler(ev);
                } catch (e) {
                  console.error("'change' handler failed: ", e, e.stack);
                  self._emit('error', e);
                }
              });
            }
          });
        }
      };
      Object.defineProperty(RemoteStorage.prototype, 'connected', {get: function() {
          return this.remote.connected;
        }});
      if ((typeof module === 'object') && (typeof module.exports !== undefined)) {
        module.exports = RemoteStorage;
      } else {
        global.RemoteStorage = RemoteStorage;
      }
    })(typeof(window) !== 'undefined' ? window : global);
    (function() {
      function fixArrayBuffers(srcObj, dstObj) {
        var field,
            srcArr,
            dstArr;
        if (typeof(srcObj) !== 'object' || Array.isArray(srcObj) || srcObj === null) {
          return;
        }
        for (field in srcObj) {
          if (typeof(srcObj[field]) === 'object' && srcObj[field] !== null) {
            if (srcObj[field].toString() === '[object ArrayBuffer]') {
              dstObj[field] = new ArrayBuffer(srcObj[field].byteLength);
              srcArr = new Int8Array(srcObj[field]);
              dstArr = new Int8Array(dstObj[field]);
              dstArr.set(srcArr);
            } else {
              fixArrayBuffers(srcObj[field], dstObj[field]);
            }
          }
        }
      }
      RemoteStorage.util = {
        getEventEmitter: function() {
          var object = {};
          var args = Array.prototype.slice.call(arguments);
          args.unshift(object);
          RemoteStorage.eventHandling.apply(RemoteStorage, args);
          object.emit = object._emit;
          return object;
        },
        extend: function(target) {
          var sources = Array.prototype.slice.call(arguments, 1);
          sources.forEach(function(source) {
            for (var key in source) {
              target[key] = source[key];
            }
          });
          return target;
        },
        asyncEach: function(array, callback) {
          return this.asyncMap(array, callback).then(function() {
            return array;
          });
        },
        asyncMap: function(array, callback) {
          var pending = Promise.defer();
          var n = array.length,
              i = 0;
          var results = [],
              errors = [];
          function oneDone() {
            i++;
            if (i === n) {
              pending.resolve(results, errors);
            }
          }
          array.forEach(function(item, index) {
            var result;
            try {
              result = callback(item);
            } catch (exc) {
              oneDone();
              errors[index] = exc;
            }
            if (typeof(result) === 'object' && typeof(result.then) === 'function') {
              result.then(function(res) {
                results[index] = res;
                oneDone();
              }, function(error) {
                errors[index] = error;
                oneDone();
              });
            } else {
              oneDone();
              results[index] = result;
            }
          });
          return pending.promise;
        },
        containingFolder: function(path) {
          if (path === '') {
            return '/';
          }
          if (!path) {
            throw "Path not given!";
          }
          return path.replace(/\/+/g, '/').replace(/[^\/]+\/?$/, '');
        },
        isFolder: function(path) {
          return path.substr(-1) === '/';
        },
        isDocument: function(path) {
          return path.substr(-1) !== '/';
        },
        baseName: function(path) {
          var parts = path.split('/');
          if (this.isFolder(path)) {
            return parts[parts.length - 2] + '/';
          } else {
            return parts[parts.length - 1];
          }
        },
        cleanPath: function(path) {
          return path.replace(/\/+/g, '/').split('/').map(encodeURIComponent).join('/').replace(/'/g, '%27');
        },
        bindAll: function(object) {
          for (var key in this) {
            if (typeof(object[key]) === 'function') {
              object[key] = object[key].bind(object);
            }
          }
        },
        equal: function(a, b, seen) {
          var key;
          seen = seen || [];
          if (typeof(a) !== typeof(b)) {
            return false;
          }
          if (typeof(a) === 'number' || typeof(a) === 'boolean' || typeof(a) === 'string') {
            return a === b;
          }
          if (typeof(a) === 'function') {
            return a.toString() === b.toString();
          }
          if (a instanceof ArrayBuffer && b instanceof ArrayBuffer) {
            a = new Uint8Array(a);
            b = new Uint8Array(b);
          }
          if (a instanceof Array) {
            if (a.length !== b.length) {
              return false;
            }
            for (var i = 0,
                c = a.length; i < c; i++) {
              if (!RemoteStorage.util.equal(a[i], b[i], seen)) {
                return false;
              }
            }
          } else {
            for (key in a) {
              if (a.hasOwnProperty(key) && !(key in b)) {
                return false;
              }
            }
            for (key in b) {
              if (!b.hasOwnProperty(key)) {
                continue;
              }
              if (!(key in a)) {
                return false;
              }
              var seenArg;
              if (typeof(b[key]) === 'object') {
                if (seen.indexOf(b[key]) >= 0) {
                  continue;
                }
                seenArg = seen.slice();
                seenArg.push(b[key]);
              }
              if (!RemoteStorage.util.equal(a[key], b[key], seenArg)) {
                return false;
              }
            }
          }
          return true;
        },
        equalObj: function(obj1, obj2) {
          console.warn('DEPRECATION WARNING: RemoteStorage.util.equalObj has been replaced by RemoteStorage.util.equal.');
          return RemoteStorage.util.equal(obj1, obj2);
        },
        deepClone: function(obj) {
          var clone;
          if (obj === undefined) {
            return undefined;
          } else {
            clone = JSON.parse(JSON.stringify(obj));
            fixArrayBuffers(obj, clone);
            return clone;
          }
        },
        pathsFromRoot: function(path) {
          var paths = [path];
          var parts = path.replace(/\/$/, '').split('/');
          while (parts.length > 1) {
            parts.pop();
            paths.push(parts.join('/') + '/');
          }
          return paths;
        },
        md5sum: function(str) {
          function md5cycle(x, k) {
            var a = x[0],
                b = x[1],
                c = x[2],
                d = x[3];
            a = ff(a, b, c, d, k[0], 7, -680876936);
            d = ff(d, a, b, c, k[1], 12, -389564586);
            c = ff(c, d, a, b, k[2], 17, 606105819);
            b = ff(b, c, d, a, k[3], 22, -1044525330);
            a = ff(a, b, c, d, k[4], 7, -176418897);
            d = ff(d, a, b, c, k[5], 12, 1200080426);
            c = ff(c, d, a, b, k[6], 17, -1473231341);
            b = ff(b, c, d, a, k[7], 22, -45705983);
            a = ff(a, b, c, d, k[8], 7, 1770035416);
            d = ff(d, a, b, c, k[9], 12, -1958414417);
            c = ff(c, d, a, b, k[10], 17, -42063);
            b = ff(b, c, d, a, k[11], 22, -1990404162);
            a = ff(a, b, c, d, k[12], 7, 1804603682);
            d = ff(d, a, b, c, k[13], 12, -40341101);
            c = ff(c, d, a, b, k[14], 17, -1502002290);
            b = ff(b, c, d, a, k[15], 22, 1236535329);
            a = gg(a, b, c, d, k[1], 5, -165796510);
            d = gg(d, a, b, c, k[6], 9, -1069501632);
            c = gg(c, d, a, b, k[11], 14, 643717713);
            b = gg(b, c, d, a, k[0], 20, -373897302);
            a = gg(a, b, c, d, k[5], 5, -701558691);
            d = gg(d, a, b, c, k[10], 9, 38016083);
            c = gg(c, d, a, b, k[15], 14, -660478335);
            b = gg(b, c, d, a, k[4], 20, -405537848);
            a = gg(a, b, c, d, k[9], 5, 568446438);
            d = gg(d, a, b, c, k[14], 9, -1019803690);
            c = gg(c, d, a, b, k[3], 14, -187363961);
            b = gg(b, c, d, a, k[8], 20, 1163531501);
            a = gg(a, b, c, d, k[13], 5, -1444681467);
            d = gg(d, a, b, c, k[2], 9, -51403784);
            c = gg(c, d, a, b, k[7], 14, 1735328473);
            b = gg(b, c, d, a, k[12], 20, -1926607734);
            a = hh(a, b, c, d, k[5], 4, -378558);
            d = hh(d, a, b, c, k[8], 11, -2022574463);
            c = hh(c, d, a, b, k[11], 16, 1839030562);
            b = hh(b, c, d, a, k[14], 23, -35309556);
            a = hh(a, b, c, d, k[1], 4, -1530992060);
            d = hh(d, a, b, c, k[4], 11, 1272893353);
            c = hh(c, d, a, b, k[7], 16, -155497632);
            b = hh(b, c, d, a, k[10], 23, -1094730640);
            a = hh(a, b, c, d, k[13], 4, 681279174);
            d = hh(d, a, b, c, k[0], 11, -358537222);
            c = hh(c, d, a, b, k[3], 16, -722521979);
            b = hh(b, c, d, a, k[6], 23, 76029189);
            a = hh(a, b, c, d, k[9], 4, -640364487);
            d = hh(d, a, b, c, k[12], 11, -421815835);
            c = hh(c, d, a, b, k[15], 16, 530742520);
            b = hh(b, c, d, a, k[2], 23, -995338651);
            a = ii(a, b, c, d, k[0], 6, -198630844);
            d = ii(d, a, b, c, k[7], 10, 1126891415);
            c = ii(c, d, a, b, k[14], 15, -1416354905);
            b = ii(b, c, d, a, k[5], 21, -57434055);
            a = ii(a, b, c, d, k[12], 6, 1700485571);
            d = ii(d, a, b, c, k[3], 10, -1894986606);
            c = ii(c, d, a, b, k[10], 15, -1051523);
            b = ii(b, c, d, a, k[1], 21, -2054922799);
            a = ii(a, b, c, d, k[8], 6, 1873313359);
            d = ii(d, a, b, c, k[15], 10, -30611744);
            c = ii(c, d, a, b, k[6], 15, -1560198380);
            b = ii(b, c, d, a, k[13], 21, 1309151649);
            a = ii(a, b, c, d, k[4], 6, -145523070);
            d = ii(d, a, b, c, k[11], 10, -1120210379);
            c = ii(c, d, a, b, k[2], 15, 718787259);
            b = ii(b, c, d, a, k[9], 21, -343485551);
            x[0] = add32(a, x[0]);
            x[1] = add32(b, x[1]);
            x[2] = add32(c, x[2]);
            x[3] = add32(d, x[3]);
          }
          function cmn(q, a, b, x, s, t) {
            a = add32(add32(a, q), add32(x, t));
            return add32((a << s) | (a >>> (32 - s)), b);
          }
          function ff(a, b, c, d, x, s, t) {
            return cmn((b & c) | ((~b) & d), a, b, x, s, t);
          }
          function gg(a, b, c, d, x, s, t) {
            return cmn((b & d) | (c & (~d)), a, b, x, s, t);
          }
          function hh(a, b, c, d, x, s, t) {
            return cmn(b ^ c ^ d, a, b, x, s, t);
          }
          function ii(a, b, c, d, x, s, t) {
            return cmn(c ^ (b | (~d)), a, b, x, s, t);
          }
          function md51(s) {
            txt = '';
            var n = s.length,
                state = [1732584193, -271733879, -1732584194, 271733878],
                i;
            for (i = 64; i <= s.length; i += 64) {
              md5cycle(state, md5blk(s.substring(i - 64, i)));
            }
            s = s.substring(i - 64);
            var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (i = 0; i < s.length; i++)
              tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
            tail[i >> 2] |= 0x80 << ((i % 4) << 3);
            if (i > 55) {
              md5cycle(state, tail);
              for (i = 0; i < 16; i++)
                tail[i] = 0;
            }
            tail[14] = n * 8;
            md5cycle(state, tail);
            return state;
          }
          function md5blk(s) {
            var md5blks = [],
                i;
            for (i = 0; i < 64; i += 4) {
              md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
            }
            return md5blks;
          }
          var hex_chr = '0123456789abcdef'.split('');
          function rhex(n) {
            var s = '',
                j = 0;
            for (; j < 4; j++)
              s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
            return s;
          }
          function hex(x) {
            for (var i = 0; i < x.length; i++)
              x[i] = rhex(x[i]);
            return x.join('');
          }
          function md5(s) {
            return hex(md51(s));
          }
          var add32 = function(a, b) {
            return (a + b) & 0xFFFFFFFF;
          };
          if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {
            add32 = function(x, y) {
              var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                  msw = (x >> 16) + (y >> 16) + (lsw >> 16);
              return (msw << 16) | (lsw & 0xFFFF);
            };
          }
          return md5(str);
        }
      };
      if (!RemoteStorage.prototype.util) {
        Object.defineProperty(RemoteStorage.prototype, 'util', {get: function() {
            console.log('DEPRECATION WARNING: remoteStorage.util was moved to RemoteStorage.util');
            return RemoteStorage.util;
          }});
      }
    })();
    (function(global) {
      var methods = {
        addEventListener: function(eventName, handler) {
          if (typeof(eventName) !== 'string') {
            throw new Error('Argument eventName should be a string');
          }
          if (typeof(handler) !== 'function') {
            throw new Error('Argument handler should be a function');
          }
          RemoteStorage.log('[Eventhandling] Adding event listener', eventName, handler);
          this._validateEvent(eventName);
          this._handlers[eventName].push(handler);
        },
        removeEventListener: function(eventName, handler) {
          this._validateEvent(eventName);
          var hl = this._handlers[eventName].length;
          for (var i = 0; i < hl; i++) {
            if (this._handlers[eventName][i] === handler) {
              this._handlers[eventName].splice(i, 1);
              return;
            }
          }
        },
        _emit: function(eventName) {
          this._validateEvent(eventName);
          var args = Array.prototype.slice.call(arguments, 1);
          this._handlers[eventName].forEach(function(handler) {
            handler.apply(this, args);
          });
        },
        _validateEvent: function(eventName) {
          if (!(eventName in this._handlers)) {
            throw new Error("Unknown event: " + eventName);
          }
        },
        _delegateEvent: function(eventName, target) {
          target.on(eventName, function(event) {
            this._emit(eventName, event);
          }.bind(this));
        },
        _addEvent: function(eventName) {
          this._handlers[eventName] = [];
        }
      };
      methods.on = methods.addEventListener;
      RemoteStorage.eventHandling = function(object) {
        var eventNames = Array.prototype.slice.call(arguments, 1);
        for (var key in methods) {
          object[key] = methods[key];
        }
        object._handlers = {};
        eventNames.forEach(function(eventName) {
          object._addEvent(eventName);
        });
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var RS = RemoteStorage;
      var hasLocalStorage;
      var SETTINGS_KEY = 'remotestorage:wireclient';
      var API_2012 = 1,
          API_00 = 2,
          API_01 = 3,
          API_02 = 4,
          API_HEAD = 5;
      var STORAGE_APIS = {
        'draft-dejong-remotestorage-00': API_00,
        'draft-dejong-remotestorage-01': API_01,
        'draft-dejong-remotestorage-02': API_02,
        'https://www.w3.org/community/rww/wiki/read-write-web-00#simple': API_2012
      };
      var isArrayBufferView;
      if (typeof(ArrayBufferView) === 'function') {
        isArrayBufferView = function(object) {
          return object && (object instanceof ArrayBufferView);
        };
      } else {
        var arrayBufferViews = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        isArrayBufferView = function(object) {
          for (var i = 0; i < 8; i++) {
            if (object instanceof arrayBufferViews[i]) {
              return true;
            }
          }
          return false;
        };
      }
      var isFolder = RemoteStorage.util.isFolder;
      var cleanPath = RemoteStorage.util.cleanPath;
      function addQuotes(str) {
        if (typeof(str) !== 'string') {
          return str;
        }
        if (str === '*') {
          return '*';
        }
        return '"' + str + '"';
      }
      function stripQuotes(str) {
        if (typeof(str) !== 'string') {
          return str;
        }
        return str.replace(/^["']|["']$/g, '');
      }
      function readBinaryData(content, mimeType, callback) {
        var blob;
        global.BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder;
        if (typeof global.BlobBuilder !== 'undefined') {
          var bb = new global.BlobBuilder();
          bb.append(content);
          blob = bb.getBlob(mimeType);
        } else {
          blob = new Blob([content], {type: mimeType});
        }
        var reader = new FileReader();
        if (typeof reader.addEventListener === 'function') {
          reader.addEventListener('loadend', function() {
            callback(reader.result);
          });
        } else {
          reader.onloadend = function() {
            callback(reader.result);
          };
        }
        reader.readAsArrayBuffer(blob);
      }
      function getTextFromArrayBuffer(arrayBuffer, encoding) {
        var pending = Promise.defer();
        if (typeof Blob === 'undefined') {
          var buffer = new Buffer(new Uint8Array(arrayBuffer));
          pending.resolve(buffer.toString(encoding));
        } else {
          var blob;
          global.BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder;
          if (typeof global.BlobBuilder !== 'undefined') {
            var bb = new global.BlobBuilder();
            bb.append(arrayBuffer);
            blob = bb.getBlob();
          } else {
            blob = new Blob([arrayBuffer]);
          }
          var fileReader = new FileReader();
          if (typeof fileReader.addEventListener === 'function') {
            fileReader.addEventListener('loadend', function(evt) {
              pending.resolve(evt.target.result);
            });
          } else {
            fileReader.onloadend = function(evt) {
              pending.resolve(evt.target.result);
            };
          }
          fileReader.readAsText(blob, encoding);
        }
        return pending.promise;
      }
      function determineCharset(mimeType) {
        var charset = 'UTF-8';
        var charsetMatch;
        if (mimeType) {
          charsetMatch = mimeType.match(/charset=(.+)$/);
          if (charsetMatch) {
            charset = charsetMatch[1];
          }
        }
        return charset;
      }
      function isFolderDescription(body) {
        return ((body['@context'] === 'http://remotestorage.io/spec/folder-description') && (typeof(body['items']) === 'object'));
      }
      function isSuccessStatus(status) {
        return [201, 204, 304].indexOf(status) >= 0;
      }
      function isErrorStatus(status) {
        return [401, 403, 404, 412].indexOf(status) >= 0;
      }
      var onErrorCb;
      RS.WireClient = function(rs) {
        this.connected = false;
        RS.eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');
        onErrorCb = function(error) {
          if (error instanceof RemoteStorage.Unauthorized) {
            this.configure({token: null});
          }
        }.bind(this);
        rs.on('error', onErrorCb);
        if (hasLocalStorage) {
          var settings;
          try {
            settings = JSON.parse(localStorage[SETTINGS_KEY]);
          } catch (e) {}
          if (settings) {
            setTimeout(function() {
              this.configure(settings);
            }.bind(this), 0);
          }
        }
        this._revisionCache = {};
        if (this.connected) {
          setTimeout(this._emit.bind(this), 0, 'connected');
        }
      };
      RS.WireClient.REQUEST_TIMEOUT = 30000;
      RS.WireClient.prototype = {
        _request: function(method, uri, token, headers, body, getEtag, fakeRevision) {
          if ((method === 'PUT' || method === 'DELETE') && uri[uri.length - 1] === '/') {
            return Promise.reject('Don\'t ' + method + ' on directories!');
          }
          var revision;
          var reqType;
          var self = this;
          if (token !== RemoteStorage.Authorize.IMPLIED_FAKE_TOKEN) {
            headers['Authorization'] = 'Bearer ' + token;
          }
          this._emit('wire-busy', {
            method: method,
            isFolder: isFolder(uri)
          });
          return RS.WireClient.request(method, uri, {
            body: body,
            headers: headers,
            responseType: 'arraybuffer'
          }).then(function(response) {
            self._emit('wire-done', {
              method: method,
              isFolder: isFolder(uri),
              success: true
            });
            self.online = true;
            if (isErrorStatus(response.status)) {
              RemoteStorage.log('[WireClient] Error response status', response.status);
              if (getEtag) {
                revision = stripQuotes(response.getResponseHeader('ETag'));
              } else {
                revision = undefined;
              }
              return Promise.resolve({
                statusCode: response.status,
                revision: revision
              });
            } else if (isSuccessStatus(response.status) || (response.status === 200 && method !== 'GET')) {
              revision = stripQuotes(response.getResponseHeader('ETag'));
              RemoteStorage.log('[WireClient] Successful request', revision);
              return Promise.resolve({
                statusCode: response.status,
                revision: revision
              });
            } else {
              var mimeType = response.getResponseHeader('Content-Type');
              var body;
              if (getEtag) {
                revision = stripQuotes(response.getResponseHeader('ETag'));
              } else {
                revision = response.status === 200 ? fakeRevision : undefined;
              }
              var charset = determineCharset(mimeType);
              if ((!mimeType) || charset === 'binary') {
                RemoteStorage.log('[WireClient] Successful request with unknown or binary mime-type', revision);
                return Promise.resolve({
                  statusCode: response.status,
                  body: response.response,
                  contentType: mimeType,
                  revision: revision
                });
              } else {
                return getTextFromArrayBuffer(response.response, charset).then(function(body) {
                  RemoteStorage.log('[WireClient] Successful request', revision);
                  return Promise.resolve({
                    statusCode: response.status,
                    body: body,
                    contentType: mimeType,
                    revision: revision
                  });
                });
              }
            }
          }, function(error) {
            self._emit('wire-done', {
              method: method,
              isFolder: isFolder(uri),
              success: false
            });
            return Promise.reject(error);
          });
        },
        configure: function(settings) {
          if (typeof settings !== 'object') {
            throw new Error('WireClient configure settings parameter should be an object');
          }
          if (typeof settings.userAddress !== 'undefined') {
            this.userAddress = settings.userAddress;
          }
          if (typeof settings.href !== 'undefined') {
            this.href = settings.href;
          }
          if (typeof settings.storageApi !== 'undefined') {
            this.storageApi = settings.storageApi;
          }
          if (typeof settings.token !== 'undefined') {
            this.token = settings.token;
          }
          if (typeof settings.properties !== 'undefined') {
            this.properties = settings.properties;
          }
          if (typeof this.storageApi !== 'undefined') {
            this._storageApi = STORAGE_APIS[this.storageApi] || API_HEAD;
            this.supportsRevs = this._storageApi >= API_00;
          }
          if (this.href && this.token) {
            this.connected = true;
            this.online = true;
            this._emit('connected');
          } else {
            this.connected = false;
          }
          if (hasLocalStorage) {
            localStorage[SETTINGS_KEY] = JSON.stringify({
              userAddress: this.userAddress,
              href: this.href,
              storageApi: this.storageApi,
              token: this.token,
              properties: this.properties
            });
          }
        },
        stopWaitingForToken: function() {
          if (!this.connected) {
            this._emit('not-connected');
          }
        },
        get: function(path, options) {
          var self = this;
          if (!this.connected) {
            return Promise.reject('not connected (path: ' + path + ')');
          }
          if (!options) {
            options = {};
          }
          var headers = {};
          if (this.supportsRevs) {
            if (options.ifNoneMatch) {
              headers['If-None-Match'] = addQuotes(options.ifNoneMatch);
            }
          } else if (options.ifNoneMatch) {
            var oldRev = this._revisionCache[path];
          }
          return this._request('GET', this.href + cleanPath(path), this.token, headers, undefined, this.supportsRevs, this._revisionCache[path]).then(function(r) {
            if (!isFolder(path)) {
              return Promise.resolve(r);
            }
            var itemsMap = {};
            if (typeof(r.body) !== 'undefined') {
              try {
                r.body = JSON.parse(r.body);
              } catch (e) {
                return Promise.reject('Folder description at ' + self.href + cleanPath(path) + ' is not JSON');
              }
            }
            if (r.statusCode === 200 && typeof(r.body) === 'object') {
              if (Object.keys(r.body).length === 0) {
                r.statusCode = 404;
              } else if (isFolderDescription(r.body)) {
                for (var item in r.body.items) {
                  self._revisionCache[path + item] = r.body.items[item].ETag;
                }
                itemsMap = r.body.items;
              } else {
                Object.keys(r.body).forEach(function(key) {
                  self._revisionCache[path + key] = r.body[key];
                  itemsMap[key] = {'ETag': r.body[key]};
                });
              }
              r.body = itemsMap;
              return Promise.resolve(r);
            } else {
              return Promise.resolve(r);
            }
          });
        },
        put: function(path, body, contentType, options) {
          if (!this.connected) {
            return Promise.reject('not connected (path: ' + path + ')');
          }
          if (!options) {
            options = {};
          }
          if ((!contentType.match(/charset=/)) && (body instanceof ArrayBuffer || isArrayBufferView(body))) {
            contentType += '; charset=binary';
          }
          var headers = {'Content-Type': contentType};
          if (this.supportsRevs) {
            if (options.ifMatch) {
              headers['If-Match'] = addQuotes(options.ifMatch);
            }
            if (options.ifNoneMatch) {
              headers['If-None-Match'] = addQuotes(options.ifNoneMatch);
            }
          }
          return this._request('PUT', this.href + cleanPath(path), this.token, headers, body, this.supportsRevs);
        },
        'delete': function(path, options) {
          if (!this.connected) {
            throw new Error('not connected (path: ' + path + ')');
          }
          if (!options) {
            options = {};
          }
          var headers = {};
          if (this.supportsRevs) {
            if (options.ifMatch) {
              headers['If-Match'] = addQuotes(options.ifMatch);
            }
          }
          return this._request('DELETE', this.href + cleanPath(path), this.token, headers, undefined, this.supportsRevs);
        }
      };
      RS.WireClient.cleanPath = cleanPath;
      RS.WireClient.isArrayBufferView = isArrayBufferView;
      RS.WireClient.readBinaryData = readBinaryData;
      RS.WireClient.request = function(method, url, options) {
        var pending = Promise.defer();
        RemoteStorage.log('[WireClient]', method, url);
        var timedOut = false;
        var timer = setTimeout(function() {
          timedOut = true;
          pending.reject('timeout');
        }, RS.WireClient.REQUEST_TIMEOUT);
        var xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        if (options.headers) {
          for (var key in options.headers) {
            xhr.setRequestHeader(key, options.headers[key]);
          }
        }
        xhr.onload = function() {
          if (timedOut) {
            return;
          }
          clearTimeout(timer);
          pending.resolve(xhr);
        };
        xhr.onerror = function(error) {
          if (timedOut) {
            return;
          }
          clearTimeout(timer);
          pending.reject(error);
        };
        var body = options.body;
        if (typeof(body) === 'object' && !isArrayBufferView(body) && body instanceof ArrayBuffer) {
          body = new Uint8Array(body);
        }
        xhr.send(body);
        return pending.promise;
      };
      Object.defineProperty(RemoteStorage.WireClient.prototype, 'storageType', {get: function() {
          if (this.storageApi) {
            var spec = this.storageApi.match(/draft-dejong-(remotestorage-\d\d)/);
            return spec ? spec[1] : '2012.04';
          }
        }});
      RS.WireClient._rs_init = function(remoteStorage) {
        hasLocalStorage = remoteStorage.localStorageAvailable();
        remoteStorage.remote = new RS.WireClient(remoteStorage);
        this.online = true;
      };
      RS.WireClient._rs_supported = function() {
        return !!global.XMLHttpRequest;
      };
      RS.WireClient._rs_cleanup = function(remoteStorage) {
        if (hasLocalStorage) {
          delete localStorage[SETTINGS_KEY];
        }
        remoteStorage.removeEventListener('error', onErrorCb);
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var haveXMLHttpRequest,
          hasLocalStorage;
      var SETTINGS_KEY = 'remotestorage:discover';
      var cachedInfo = {};
      RemoteStorage.Discover = function(userAddress) {
        if (userAddress in cachedInfo) {
          return Promise.resolve(cachedInfo[userAddress]);
        }
        var webFinger = new WebFinger({
          tls_only: false,
          uri_fallback: true,
          request_timeout: 5000
        });
        var pending = Promise.defer();
        webFinger.lookup(userAddress, function(err, response) {
          if (err) {
            return pending.reject(err.message);
          } else if ((typeof response.idx.links.remotestorage !== 'object') || (typeof response.idx.links.remotestorage.length !== 'number') || (response.idx.links.remotestorage.length <= 0)) {
            RemoteStorage.log("[Discover] WebFinger record for " + userAddress + " does not have remotestorage defined in the links section ", JSON.stringify(response.json));
            return pending.reject("WebFinger record for " + userAddress + " does not have remotestorage defined in the links section.");
          }
          var rs = response.idx.links.remotestorage[0];
          var authURL = rs.properties['http://tools.ietf.org/html/rfc6749#section-4.2'] || rs.properties['auth-endpoint'];
          var storageType = rs.properties['http://remotestorage.io/spec/version'] || rs.type;
          cachedInfo[userAddress] = {
            href: rs.href,
            storageType: storageType,
            authURL: authURL,
            properties: rs.properties
          };
          if (hasLocalStorage) {
            localStorage[SETTINGS_KEY] = JSON.stringify({cache: cachedInfo});
          }
          return pending.resolve(cachedInfo[userAddress]);
        });
        return pending.promise;
      };
      RemoteStorage.Discover._rs_init = function(remoteStorage) {
        hasLocalStorage = remoteStorage.localStorageAvailable();
        if (hasLocalStorage) {
          var settings;
          try {
            settings = JSON.parse(localStorage[SETTINGS_KEY]);
          } catch (e) {}
          if (settings) {
            cachedInfo = settings.cache;
          }
        }
      };
      RemoteStorage.Discover._rs_supported = function() {
        haveXMLHttpRequest = !!global.XMLHttpRequest;
        return haveXMLHttpRequest;
      };
      RemoteStorage.Discover._rs_cleanup = function() {
        if (hasLocalStorage) {
          delete localStorage[SETTINGS_KEY];
        }
      };
    })(typeof(window) !== 'undefined' ? window : global);
    if (typeof XMLHttpRequest === 'undefined') {
      XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
    }
    (function(undefined) {
      var LINK_URI_MAPS = {
        'http://webfist.org/spec/rel': 'webfist',
        'http://webfinger.net/rel/avatar': 'avatar',
        'remotestorage': 'remotestorage',
        'http://tools.ietf.org/id/draft-dejong-remotestorage': 'remotestorage',
        'remoteStorage': 'remotestorage',
        'http://www.packetizer.com/rel/share': 'share',
        'http://webfinger.net/rel/profile-page': 'profile',
        'me': 'profile',
        'vcard': 'vcard',
        'blog': 'blog',
        'http://packetizer.com/rel/blog': 'blog',
        'http://schemas.google.com/g/2010#updates-from': 'updates',
        'https://camlistore.org/rel/server': 'camilstore'
      };
      var LINK_PROPERTIES = {
        'avatar': [],
        'remotestorage': [],
        'blog': [],
        'vcard': [],
        'updates': [],
        'share': [],
        'profile': [],
        'webfist': [],
        'camlistore': []
      };
      var URIS = ['webfinger', 'host-meta', 'host-meta.json'];
      function _err(obj) {
        obj.toString = function() {
          return this.message;
        };
        return obj;
      }
      function WebFinger(config) {
        if (typeof config !== 'object') {
          config = {};
        }
        this.config = {
          tls_only: (typeof config.tls_only !== 'undefined') ? config.tls_only : true,
          webfist_fallback: (typeof config.webfist_fallback !== 'undefined') ? config.webfist_fallback : false,
          uri_fallback: (typeof config.uri_fallback !== 'undefined') ? config.uri_fallback : false,
          request_timeout: (typeof config.request_timeout !== 'undefined') ? config.request_timeout : 10000
        };
      }
      WebFinger.prototype._fetchJRD = function(url, cb) {
        var self = this;
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              if (self._isValidJSON(xhr.responseText)) {
                cb(null, xhr.responseText);
              } else {
                cb(_err({
                  message: 'invalid json',
                  url: url,
                  status: xhr.status
                }));
              }
            } else if (xhr.status === 404) {
              cb(_err({
                message: 'endpoint unreachable',
                url: url,
                status: xhr.status
              }));
            } else {
              cb(_err({
                message: 'error during request',
                url: url,
                status: xhr.status
              }));
            }
          }
        };
        xhr.open('GET', url, true);
        xhr.setRequestHeader('Accept', 'application/jrd+json, application/json');
        xhr.send();
      };
      WebFinger.prototype._isValidJSON = function(str) {
        try {
          JSON.parse(str);
        } catch (e) {
          return false;
        }
        return true;
      };
      WebFinger.prototype._isLocalhost = function(host) {
        var local = /^localhost(\.localdomain)?(\:[0-9]+)?$/;
        return local.test(host);
      };
      WebFinger.prototype._processJRD = function(JRD, cb) {
        var self = this;
        var parsedJRD = JSON.parse(JRD);
        if ((typeof parsedJRD !== 'object') || (typeof parsedJRD.links !== 'object')) {
          if (typeof parsedJRD.error !== 'undefined') {
            cb(_err({message: parsedJRD.error}));
          } else {
            cb(_err({message: 'unknown response from server'}));
          }
          return false;
        }
        var links = parsedJRD.links;
        var result = {
          object: parsedJRD,
          json: JRD,
          idx: {}
        };
        result.idx.properties = {'name': undefined};
        result.idx.links = JSON.parse(JSON.stringify(LINK_PROPERTIES));
        links.map(function(link, i) {
          if (LINK_URI_MAPS.hasOwnProperty(link.rel)) {
            if (result.idx.links[LINK_URI_MAPS[link.rel]]) {
              var entry = {};
              Object.keys(link).map(function(item, n) {
                entry[item] = link[item];
              });
              result.idx.links[LINK_URI_MAPS[link.rel]].push(entry);
            }
          }
        });
        var props = JSON.parse(JRD).properties;
        for (var key in props) {
          if (props.hasOwnProperty(key)) {
            if (key === 'http://packetizer.com/ns/name') {
              result.idx.properties.name = props[key];
            }
          }
        }
        cb(null, result);
      };
      WebFinger.prototype.lookup = function(address, cb) {
        if (typeof address !== 'string') {
          throw new Error('first parameter must be a user address');
        } else if (typeof cb !== 'function') {
          throw new Error('second parameter must be a callback');
        }
        var self = this;
        var parts = address.replace(/ /g, '').split('@');
        var host = parts[1];
        var uri_index = 0;
        var protocol = 'https';
        if (parts.length !== 2) {
          cb(_err({message: 'invalid user address ' + address + ' ( expected format: user@host.com )'}));
          return false;
        } else if (self._isLocalhost(host)) {
          protocol = 'http';
        }
        function _buildURL() {
          return protocol + '://' + host + '/.well-known/' + URIS[uri_index] + '?resource=acct:' + address;
        }
        function _fallbackChecks(err) {
          if ((self.config.uri_fallback) && (host !== 'webfist.org') && (uri_index !== URIS.length - 1)) {
            uri_index = uri_index + 1;
            _call();
          } else if ((!self.config.tls_only) && (protocol === 'https')) {
            uri_index = 0;
            protocol = 'http';
            _call();
          } else if ((self.config.webfist_fallback) && (host !== 'webfist.org')) {
            uri_index = 0;
            protocol = 'http';
            host = 'webfist.org';
            self._fetchJRD(_buildURL(), function(err, data) {
              if (err) {
                cb(err);
                return false;
              }
              self._processJRD(data, function(err, result) {
                if ((typeof result.idx.links.webfist === 'object') && (typeof result.idx.links.webfist[0].href === 'string')) {
                  self._fetchJRD(result.idx.links.webfist[0].href, function(err, JRD) {
                    if (err) {
                      cb(err);
                    } else {
                      self._processJRD(JRD, cb);
                    }
                  });
                }
              });
            });
          } else {
            cb(err);
            return false;
          }
        }
        function _call() {
          self._fetchJRD(_buildURL(), function(err, JRD) {
            if (err) {
              _fallbackChecks(err);
            } else {
              self._processJRD(JRD, cb);
            }
          });
        }
        setTimeout(_call, 0);
      };
      WebFinger.prototype.lookupLink = function(address, rel, cb) {
        if (LINK_PROPERTIES.hasOwnProperty(rel)) {
          this.lookup(address, function(err, p) {
            var links = p.idx.links[rel];
            if (err) {
              cb(err);
            } else if (links.length === 0) {
              cb('no links found with rel="' + rel + '"');
            } else {
              cb(null, links[0]);
            }
          });
        } else {
          cb('unsupported rel ' + rel);
        }
      };
      if (typeof window === 'object') {
        window.WebFinger = WebFinger;
      } else if (typeof(define) === 'function' && define.amd) {
        define([], function() {
          return WebFinger;
        });
      } else {
        try {
          module.exports = WebFinger;
        } catch (e) {}
      }
    })();
    (function(global) {
      function extractParams(url) {
        var location = url || RemoteStorage.Authorize.getLocation().href,
            hashPos = location.indexOf('#'),
            hash;
        if (hashPos === -1) {
          return;
        }
        hash = location.substring(hashPos + 1);
        if (hash.indexOf('=') === -1) {
          return;
        }
        return hash.split('&').reduce(function(m, kvs) {
          var kv = kvs.split('=');
          m[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
          return m;
        }, {});
      }
      RemoteStorage.ImpliedAuth = function(storageApi, redirectUri) {
        RemoteStorage.log('ImpliedAuth proceeding due to absent authURL; storageApi = ' + storageApi + ' redirectUri = ' + redirectUri);
        remoteStorage.remote.configure({token: RemoteStorage.Authorize.IMPLIED_FAKE_TOKEN});
        document.location = redirectUri;
      };
      RemoteStorage.Authorize = function(authURL, scope, redirectUri, clientId) {
        RemoteStorage.log('[Authorize] authURL = ', authURL, 'scope = ', scope, 'redirectUri = ', redirectUri, 'clientId = ', clientId);
        var url = authURL,
            hashPos = redirectUri.indexOf('#');
        url += authURL.indexOf('?') > 0 ? '&' : '?';
        url += 'redirect_uri=' + encodeURIComponent(redirectUri.replace(/#.*$/, ''));
        url += '&scope=' + encodeURIComponent(scope);
        url += '&client_id=' + encodeURIComponent(clientId);
        if (hashPos !== -1) {
          url += '&state=' + encodeURIComponent(redirectUri.substring(hashPos + 1));
        }
        url += '&response_type=token';
        if (global.cordova) {
          return RemoteStorage.Authorize.openWindow(url, redirectUri, 'location=yes,clearsessioncache=yes,clearcache=yes').then(function(authResult) {
            remoteStorage.remote.configure({token: authResult.access_token});
            global.location.reload();
          }).then(null, function(error) {
            console.error(error);
            remoteStorage.widget.view.setState('initial');
          });
        }
        RemoteStorage.Authorize.setLocation(url);
      };
      RemoteStorage.Authorize.IMPLIED_FAKE_TOKEN = false;
      RemoteStorage.prototype.authorize = function(authURL, cordovaRedirectUri) {
        this.access.setStorageType(this.remote.storageType);
        var scope = this.access.scopeParameter;
        var redirectUri = global.cordova ? cordovaRedirectUri : String(RemoteStorage.Authorize.getLocation());
        var clientId = redirectUri.match(/^(https?:\/\/[^\/]+)/)[0];
        RemoteStorage.Authorize(authURL, scope, redirectUri, clientId);
      };
      RemoteStorage.Authorize.getLocation = function() {
        return global.document.location;
      };
      RemoteStorage.Authorize.setLocation = function(location) {
        if (typeof location === 'string') {
          global.document.location.href = location;
        } else if (typeof location === 'object') {
          global.document.location = location;
        } else {
          throw "Invalid location " + location;
        }
      };
      RemoteStorage.Authorize.openWindow = function(url, redirectUri, options) {
        var pending = Promise.defer();
        var newWindow = global.open(url, '_blank', options);
        if (!newWindow || newWindow.closed) {
          pending.reject('Authorization popup was blocked');
          return pending.promise;
        }
        var handleExit = function() {
          pending.reject('Authorization was canceled');
        };
        var handleLoadstart = function(event) {
          if (event.url.indexOf(redirectUri) !== 0) {
            return;
          }
          newWindow.removeEventListener('exit', handleExit);
          newWindow.close();
          var authResult = extractParams(event.url);
          if (!authResult) {
            return pending.reject('Authorization error');
          }
          return pending.resolve(authResult);
        };
        newWindow.addEventListener('loadstart', handleLoadstart);
        newWindow.addEventListener('exit', handleExit);
        return pending.promise;
      };
      RemoteStorage.prototype.impliedauth = function() {
        RemoteStorage.ImpliedAuth(this.remote.storageApi, String(document.location));
      };
      RemoteStorage.Authorize._rs_supported = function() {
        return typeof(document) !== 'undefined';
      };
      var onFeaturesLoaded;
      RemoteStorage.Authorize._rs_init = function(remoteStorage) {
        onFeaturesLoaded = function() {
          var authParamsUsed = false;
          if (params) {
            if (params.error) {
              throw "Authorization server errored: " + params.error;
            }
            if (params.access_token) {
              remoteStorage.remote.configure({token: params.access_token});
              authParamsUsed = true;
            }
            if (params.remotestorage) {
              remoteStorage.connect(params.remotestorage);
              authParamsUsed = true;
            }
            if (params.state) {
              RemoteStorage.Authorize.setLocation('#' + params.state);
            }
          }
          if (!authParamsUsed) {
            remoteStorage.remote.stopWaitingForToken();
          }
        };
        var params = extractParams(),
            location;
        if (params) {
          location = RemoteStorage.Authorize.getLocation();
          location.hash = '';
        }
        remoteStorage.on('features-loaded', onFeaturesLoaded);
      };
      RemoteStorage.Authorize._rs_cleanup = function(remoteStorage) {
        remoteStorage.removeEventListener('features-loaded', onFeaturesLoaded);
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var SETTINGS_KEY = "remotestorage:access";
      RemoteStorage.Access = function() {
        this.reset();
      };
      RemoteStorage.Access.prototype = {
        claim: function(scope, mode) {
          if (typeof(scope) !== 'string' || scope.indexOf('/') !== -1 || scope.length === 0) {
            throw new Error('Scope should be a non-empty string without forward slashes');
          }
          if (!mode.match(/^rw?$/)) {
            throw new Error('Mode should be either \'r\' or \'rw\'');
          }
          this._adjustRootPaths(scope);
          this.scopeModeMap[scope] = mode;
        },
        get: function(scope) {
          return this.scopeModeMap[scope];
        },
        remove: function(scope) {
          var savedMap = {};
          var name;
          for (name in this.scopeModeMap) {
            savedMap[name] = this.scopeModeMap[name];
          }
          this.reset();
          delete savedMap[scope];
          for (name in savedMap) {
            this.set(name, savedMap[name]);
          }
        },
        checkPermission: function(scope, mode) {
          var actualMode = this.get(scope);
          return actualMode && (mode === 'r' || actualMode === 'rw');
        },
        checkPathPermission: function(path, mode) {
          if (this.checkPermission('*', mode)) {
            return true;
          }
          return !!this.checkPermission(this._getModuleName(path), mode);
        },
        reset: function() {
          this.rootPaths = [];
          this.scopeModeMap = {};
        },
        _getModuleName: function(path) {
          if (path[0] !== '/') {
            throw new Error('Path should start with a slash');
          }
          var moduleMatch = path.replace(/^\/public/, '').match(/^\/([^\/]*)\//);
          return moduleMatch ? moduleMatch[1] : '*';
        },
        _adjustRootPaths: function(newScope) {
          if ('*' in this.scopeModeMap || newScope === '*') {
            this.rootPaths = ['/'];
          } else if (!(newScope in this.scopeModeMap)) {
            this.rootPaths.push('/' + newScope + '/');
            this.rootPaths.push('/public/' + newScope + '/');
          }
        },
        _scopeNameForParameter: function(scope) {
          if (scope.name === '*' && this.storageType) {
            if (this.storageType === '2012.04') {
              return '';
            } else if (this.storageType.match(/remotestorage-0[01]/)) {
              return 'root';
            }
          }
          return scope.name;
        },
        setStorageType: function(type) {
          this.storageType = type;
        }
      };
      Object.defineProperty(RemoteStorage.Access.prototype, 'scopes', {get: function() {
          return Object.keys(this.scopeModeMap).map(function(key) {
            return {
              name: key,
              mode: this.scopeModeMap[key]
            };
          }.bind(this));
        }});
      Object.defineProperty(RemoteStorage.Access.prototype, 'scopeParameter', {get: function() {
          return this.scopes.map(function(scope) {
            return this._scopeNameForParameter(scope) + ':' + scope.mode;
          }.bind(this)).join(' ');
        }});
      Object.defineProperty(RemoteStorage.prototype, 'access', {
        get: function() {
          var access = new RemoteStorage.Access();
          Object.defineProperty(this, 'access', {value: access});
          return access;
        },
        configurable: true
      });
      RemoteStorage.Access._rs_init = function() {};
    })(typeof(window) !== 'undefined' ? window : global);
    (function(pMode) {
      var mode = pMode,
          env = {},
          isBackground = false;
      RemoteStorage.Env = function() {
        return env;
      };
      RemoteStorage.Env.isBrowser = function() {
        return mode === "browser";
      };
      RemoteStorage.Env.isNode = function() {
        return mode === "node";
      };
      RemoteStorage.Env.goBackground = function() {
        isBackground = true;
        RemoteStorage.Env._emit("background");
      };
      RemoteStorage.Env.goForeground = function() {
        isBackground = false;
        RemoteStorage.Env._emit("foreground");
      };
      RemoteStorage.Env._rs_init = function(remoteStorage) {
        RemoteStorage.eventHandling(RemoteStorage.Env, "background", "foreground");
        function visibility() {
          if (document[env.hiddenProperty]) {
            RemoteStorage.Env.goBackground();
          } else {
            RemoteStorage.Env.goForeground();
          }
        }
        if (mode === 'browser') {
          if (typeof(document.hidden) !== "undefined") {
            env.hiddenProperty = "hidden";
            env.visibilityChangeEvent = "visibilitychange";
          } else if (typeof(document.mozHidden) !== "undefined") {
            env.hiddenProperty = "mozHidden";
            env.visibilityChangeEvent = "mozvisibilitychange";
          } else if (typeof(document.msHidden) !== "undefined") {
            env.hiddenProperty = "msHidden";
            env.visibilityChangeEvent = "msvisibilitychange";
          } else if (typeof(document.webkitHidden) !== "undefined") {
            env.hiddenProperty = "webkitHidden";
            env.visibilityChangeEvent = "webkitvisibilitychange";
          }
          document.addEventListener(env.visibilityChangeEvent, visibility, false);
          visibility();
        }
      };
      RemoteStorage.Env._rs_cleanup = function(remoteStorage) {};
    })(typeof(window) !== 'undefined' ? 'browser' : 'node');
    (function() {
      "use strict";
      var dictionary = {
        "view_info": 'This app allows you to use your own storage. <a href="http://remotestorage.io/" target="_blank">Learn more!</a>',
        "view_connect": "<strong>Connect</strong> remote storage",
        "view_connecting": "Connecting <strong>%s</strong>",
        "view_offline": "Offline",
        "view_error_occured": "Sorry! An error occured.",
        "view_invalid_key": "Wrong key!",
        "view_confirm_reset": "Are you sure you want to reset everything? This will clear your local data and reload the page.",
        "view_get_me_out": "Get me out of here!",
        "view_error_plz_report": 'If this problem persists, please <a href="http://remotestorage.io/community/" target="_blank">let us know</a>!',
        "view_unauthorized": "Unauthorized! Click here to reconnect."
      };
      RemoteStorage.I18n = {
        translate: function() {
          var str = arguments[0],
              params = Array.prototype.splice.call(arguments, 1);
          if (typeof dictionary[str] !== "string") {
            throw "Unknown translation string: " + str;
          } else {
            str = dictionary[str];
          }
          return (str.replace(/%s/g, function() {
            return params.shift();
          }));
        },
        getDictionary: function() {
          return dictionary;
        },
        setDictionary: function(newDictionary) {
          dictionary = newDictionary;
        }
      };
    })();
    RemoteStorage.Assets = {
      cipherIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTQiIHdpZHRoPSIyNS4xNzciIHZlcnNpb249IjEuMSIgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxwYXRoIGQ9Im0yNS4xNzcgNS41MzIzYy0wLjA1NjQtMC4xMTI5MS0wLjA1NjQtMC4yMjU4MS0wLjE2OTM2LTAuMzM4NzEtMC4xMTI5LTAuMTEyOS0wLjI4MjI1LTAuMTY5MzYtMC4zOTUxNi0wLjE2OTM2aC0xMS40MDNjLTAuNzMzLTIuODc5LTMuMzg2NC01LjAyNDItNi40OTEzLTUuMDI0Mi0zLjY2OTMgMC02LjcxNzcgMy4wNDg0LTYuNzE3NyA2LjcxNzcgMCAzLjcyNjMgMy4wNDg0IDYuNzE3MyA2LjcxNzcgNi43MTczIDMuMzMwNyAwIDYuMDQwMy0yLjQyNzQgNi42MDQ4LTUuNTg4N2gyLjU0MDN2My42Njk0YzAgMC4yODIyNiAwLjI4MjI2IDAuNTA4MDYgMC41NjQ1MiAwLjUwODA2aDEuNzVjMC4yODIyNiAwIDAuNTY0NTItMC4yMjU4IDAuNTY0NTItMC41MDgwNnYtMy42Njk0aDEuNDY3N3Y1LjY0NTJjMCAwLjI4MjI1IDAuMjI1OCAwLjUwODA2IDAuNTA4MDYgMC41MDgwNmgxLjgwNjRjMC4yODIyNiAwIDAuNTA4MDctMC4yMjU4MSAwLjU2NDUyLTAuNTA4MDZ2LTUuNjQ1MmgxLjUyNDJjMC4xMTI5MSAwIDAuMjgyMjYgMCAwLjM5NTE2LTAuMTEyOSAwLjExMjkxLTAuMTEyOSAwLjE2OTM2LTAuMjgyMjYgMC4xNjkzNi0wLjM5NTE2di0xLjgwNjR6bS0xOC40NTkgNS4wODA3Yy0yLjA4ODcgMC0zLjgzODctMS42OTM2LTMuODM4Ny0zLjgzODcgMC0yLjE0NTIgMS43NS0zLjgzODcgMy44Mzg3LTMuODM4NyAyLjE0NTIgMCAzLjgzODcgMS42OTM2IDMuODM4NyAzLjgzODcgMCAyLjE0NTItMS42OTM2IDMuODM4Ny0zLjgzODcgMy44Mzg3eiIgZmlsbD0iI2ZmZiIvPgo8L3N2Zz4K',
      connectIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAtMTAzNi40KSI+CiAgPHBhdGggZD0ibTEgMTA0Ny40di02aDd2LTRsNyA3LTcgN3YtNHoiIGZpbGw9IiNmZmYiLz4KIDwvZz4KPC9zdmc+Cg==',
      disconnectIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgdmVyc2lvbj0iMS4wIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxwYXRoIHN0eWxlPSJibG9jay1wcm9ncmVzc2lvbjp0Yjt0ZXh0LWluZGVudDowO2NvbG9yOiMwMDAwMDA7dGV4dC10cmFuc2Zvcm06bm9uZSIgZD0ibTguMDAwMSAwYy0wLjQ3MTQgMC0wLjk2MTAzIDAuNTQxOS0wLjk1IDF2NmMtMC4wMDc0NyAwLjUyODMxIDAuNDIxNjMgMSAwLjk1IDFzMC45NTc0Ny0wLjQ3MTY5IDAuOTUtMXYtNmMwLjAxNDYyMi0wLjYwNTEtMC40Nzg2LTEtMC45NS0xem0tMy4zNDM4IDIuNWMtMC4wODcxODYgMC4wMTkyOTQtMC4xNzE2MyAwLjA1MDk1OS0wLjI1IDAuMDkzNzUtMi45OTk1IDEuNTcxNS0zLjkxODQgNC43OTc5LTMuMTI1IDcuNDY4OCAwLjc5MzQgMi42NyAzLjI3OTkgNC45MzcgNi42ODc1IDQuOTM3IDMuMzU5MiAwIDUuODc3Mi0yLjE0OSA2LjcxOTItNC43ODEgMC44NDEtMi42MzIxLTAuMDU4LTUuODIzNC0zLjEyNS03LjU5NC0wLjQzNC0wLjI1MzYtMS4wNTktMC4wODk5LTEuMzEzIDAuMzQzNy0wLjI1MzYgMC40MzM2LTAuMDkgMS4wNTg5IDAuMzQ0IDEuMzEyNSAyLjM5MDggMS4zNzk4IDIuODgyNSAzLjQ5NDQgMi4yODEyIDUuMzc1LTAuNjAxMiAxLjg4MDYtMi4zNDQgMy40Mzc1LTQuOTA2MiAzLjQzNzUtMi41NzU5IDAtNC4yOTc2LTEuNjUwMi00Ljg3NS0zLjU5MzgtMC41Nzc2LTEuOTQzNS0wLjA0Ny00LjA0OCAyLjE4NzMtNS4yMTg3IDAuMzc4Ny0wLjIwNjMgMC41NzkxLTAuNjkyNSAwLjQ1NTgtMS4xMDU3LTAuMTIzMi0wLjQxMzMtMC41NTcyLTAuNzEwMy0wLjk4Ny0wLjY3NTUtMC4wMzEzLTAuMDAxNS0wLjA2MjYtMC4wMDE1LTAuMDkzOCAweiIgZmlsbD0iI2ZmZiIvPgo8L3N2Zz4K',
      dropbox: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QgPEBAhEOpfuQAABhZJREFUWMPVl31snVUdxz+/5/2577e3b7QbHaOD0nXshW4ZZkpGQmJYZkJUDAaZzCBGAxGd+pdZQsJIjCaKgFu09GWybIggm8yhMCsY92rcOkPHunbdtKOUbX36svX23uc+xz+eDsrWlztiNJzk5D7JPS+fc8739/2dA5+EsqJtyK18ZlCKbX9Lk6fd1uo5xbTVZmtwa4v35Np5Mry4TLYXCzAnyhsry2SwrmnokdnaTruq6i3e0lXl0tqQlkURCxwdDp9Th5p3+p9iS8afqk/VZq9kaZoDN8apdU3B1KFnmLde7AkezH0n3V0UQOJpz2hIsqEhLU+WOeAagmtCxISYBe1nVf4vfWrByYdSpyf3W9ziLapy6JgbAduAiBn2S1rCQBYODAQP7H01/zxby4JpAW5s8mproxypiRKNGIJrQNT8EMA1wTGEU8MBP/q7umPw0dSbAA3N3n3zI2yLG2oScPgbNYWICY4Be86o/le6g0W576bPXQWwcqvXdJ2t1idMsA1hJoCoCRfGYdOhwsa4TUWFrr7pGmDrzAiQCHfD//Xxwk/33Z/6HoA0tnhLXZ3XMoYqsy4PYs4M4Ohg6pB2ddqO+vR6BWL27AARXbBNiBjwh9Oqs+O8ukcT4eaopjLqGsJSCdSX29SX23x/lctXlzgE1zBAANxWIQuGxlWNACxr8WozJp0lljKsGXbA0qGu1GRBxsTUQRAGLgboIuQVvHI8S+f7eeK2TLsDSQd296rhPaeDm09+PdX/gQYqN3uZ+jh7ro+oRusKDdgmVEY1GqstSiOhdegCmoQAIoImIWTPYIHdXVlyBYhaVwLA70+rPz7fllvLi2W5KcPw9q3eS/VJ7kmYgm1A3BIWV5osq7IIlMLUQJOrAXQBXQtr1BR2d2XpOu8TtULR+gq2nQh+vv8rqUdnNaKGZm/9qnJpmp/U+fxCB5lYsaGFdTYAY9L3jmNj9F9S7OgKVh9/KNVelBVf8untv8TYSS8gbsrHyh8C2LqQtGE0z9CJYfVuUblgRZv3WGOJvJG0cF8/lWPNdo+O93xsHYoVuqkL/xzIs/HPHt2DPg0Zko+v0I8vbfHun9aKE5sH9YaobJsf5V4mRLXv33kSlmAYwspqgw23R7A1EJlahKYOSsHTB0cZHQ9IOBA3NSrjGo4hWAY82xH8rH1b/jF2laoPAOb80jPqYtKTMdRcTQNd+xAgbgmuJbiGELfh3lsc7q41KQSTABBcC1qPjLH/XzniNqScsP1kgMsm9nJ34e2mNcmFAMby1qFPZyz1WlxXrprhuEUgUPDbd8Y59n6edbe61KZ1TF14vSfPLw5dYjhXIOMIM6lGAV+u0+tv+ttI/2+6/LsMQVXpUFCAqJkS9MT5anB2NGDjWxf5Yp3DvjN5th/LUhETolaRTqigxMGIWVKtHVyX2tGTJd2X5agUIfi8CmvUFOKGT++gT8wqLlKUgnwATxwq7P32m35Z+32pPQZA54MpH1iSb/XWZmx2VthTD1AATCBlCZ+dpwNg6EJjlUH3hQIKRaCujhZFaOPtfUH+8HvBnQceSP11yjA8vC616+A5FevL8jt/YiCR0HiQcAUVrnDHHO0jHTUNllXrpC0NRXiefjAxM4rhHLzQpZqf+eFFd/LkM17JGlu9p+xC8IgPhGlaqE1rNJZrxOzQok0dnjviY+nhbSntCH3DAWN+QMIWEhYsqTD4wYHChrPfSP9kqnmM6QAMkYtz4xqmDqeGA+rLNObGZVozkglx1ZfqZAvC2ZGAz9RYlEbAlsLoNd+Kx5RqO5/njKXDsnKdhCXFOaFAZUzjznlhyt5xIjiSLbBz2oVO98fRdalOoGZ5m/dUQ4pvJZ3Zr/CXlS5A74gabzlYePztr6U2faxr+eRy/RYvtjgjHauvkxvi9oTDXaGBuAUJWyh1hb3vqsOvfiG5/L/yMAE483BqdNeuXO3LvcGX3vEUhsZVsaYL9IzACz3BXcVOXvQOfKRsupBZv8R4bnW19rmqGPzqHz4BcMGn5U/Hgod5oiT3P3kvVj7rrfnx/pHBu7d7Azc1eY3/l0drzWbPXNjsGXySy38AbtMqneWU7BkAAAAASUVORK5CYII=',
      googledrive: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QgPEA85ztzJcQAABZVJREFUWMPtl1uoXVcVhr8x5tprn7M1NG1i0pQqSG2jLcXipYJXjPogqFgpaHMSFUkpIjU+leKbDxIQSiHgjZgmrfXgQ6SKj5Ji7YVS05aUUqKQlNLQeDnN5Zzk9Jy99xy/D3OttU/StDlV33TBZM3FXmuMf/5jjv+fG/7XL1vti9tnv3Dtnnf+87JY8YmZNxEMM1sZ7tWpjz764mriVqvKvmfb1ONLy3+dGyWu6EWbvQwoydv5BMSqFuereakmfnls1GP25IDaBGYYjplhljDz5tk7YMtPfurAf6UE9Z6tNwDPAPXwtcxL1x9n4zRgDjjm1gCyC6JpCLoW/OX65of1nzCwG6gNo3aYeXF981mTvK2/WWFiMmoj7X+z5JcE0N87c4e7b3EvyTwZT5/r8ezZHu6GuWGpSegJ8/ZeBu6fHv35s1/7t0rQv29mjWF/ATZ1L4bQwohrpkYc/sBpwhJYAVdKYECzYAESIk4Am3sf+sPCW2LAzb9jbpvMDXfD3fEqkRIcGdbsevlt9LylPYG1K6/K3QzK75uAr78lBgb3b7sc2cl2Uaa21sDiGMvB2iQeu/EMm6bKHjD3SUsCEChnpEAKiLisd/PB+UsyMPjZNwzzh1ixcnOfsFCX51NU/PTvA6pkTUdYw4R3zyu1ArMDqyvBQB82+FiJUQJ4C8YgVT1SSvSTs+vEmkcwe7qEsUnt233Aij0BW4ZPbfngKpRQs7hXpYQNvRiuEtATWOW4bLi+z04pJbCnBAkBJggBQlIBIZCUJM0Cm9+QgcED2+/G7BprdMZaAFZExm1FWcz+NLdj32G/6XfPCB5GoJKp7H5FARHRtgRI1y0/+cm7Lwpg+v7t64DvNd5S2mqirKXHy6RoArp1Ykrc2hKtKCtXlNEyoQ6Ydi498fF1F2FAdwEbV9UnZne+8q19Z7o63vTb+TPnRneeWxwxHGdyziii6wApQNEydKUUd5wHYGrftvci7tKKLSME5bvCaruynI9rNL7vdZgiHhiP898Wl8bMnxty+uyIhcURo1FgjSg1DCDph4uPfuR9AFbvvS25p2cxbiyKVuh2o1O44n2lLLacb5v75v5fX6yl5h753IwUD+YcRAQ5B6FMMhj0jboSRhnAE258wvp7Z7aYcbCYCeCGt97ubfICLDP/q4WZ32x7M20fPfb+hxbH9ZdjHOQIIoR74EDywA3coa6MqtJnrP+LmRmcB63ob8dA1wllRm95LVc//22S16TGeKqqpqoHk10ESGJj/zjjgIhAISKCyJmcY6Uu8Pbq7C0V6ABh35dzvYWQG0QAhmSYCaUlNhzdCrlX2jpE6tV4b9DYcGFKEgG8svQucoicC4CsII8zeTxutAEQzx1duPL3vrxjdlnou0SDLdTulxJQmalXNzN98jpEJiSo+qTeoEnsnWC5lVZNRhkOZiq0G8XCmz1gpp3j/ZYdYLhj9qCkn3fJQ4QKeh9OccWxz6O0hGKM9wakeoBEZ1BmqfOMyYFk4gXS+edG4J4ju6/644VK+AOJhSIYpVRBpn/qPVRL65A51dRavJoG2UQkOqf0hgVrGG7u6syoJDObB+55nRANb589Afy40W0UwkY91h39CiLweg1UU+W3ohLNvC2VurJ1htR6A3QaYPCjI7uvOvGGOlfv2XoSuBzEhmNfZXDqBrweUPVqUlWodneSG+6J1NTevThfDpEjmnsmzuuCPPfCvRvfcakT0S2Aeq9tYPr0ZryeBvOOlZBKUIEiCAVZwTgy41x6v6hm0LFZ4o7N7IuXPA+EDx+XjQ+tP/4lUrW2vCI1ydR0iYgmWdtu4yzG7bOiAdn8iYlA0iFJh1Z1JJv+ye2b3n1419XRH2riP0aqqlKClABIjUMW+rtSlw5qmCpgsynnl56/d+M/+P91wfUvQjDgTzx9h9AAAAAASUVORK5CYII=',
      nocipherIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPgogPHBhdGggZD0ibSAxMy4yMDMxMjQsMTEuNzczNDM4IGMgMC4yODEyNSwwLjI4MTI1IDAuNDIxODc1LDAuNjA5Mzc1IDAuNDIxODc1LDEuMDMxMjUgMCwwLjM3NSAtMC4xNDA2MjUsMC43NSAtMC40MjE4NzUsMS4wMzEyNSAtMC4yODEyNSwwLjIzNDM3NSAtMC42MDkzNzUsMC4zNzUgLTEuMDMxMjUsMC4zNzUgLTAuMzc1LDAgLTAuNzUsLTAuMTQwNjI1IC0xLjAzMTI1LC0wLjM3NSAwLDAgLTMuMTg3NDk4MSwtMy42NTYyNSAtMy4xODc0OTgxLC0zLjY1NjI1IDAsMCAtMy4xNDA2MjUsMy42NTYyNSAtMy4xNDA2MjUsMy42NTYyNSAtMC4yODEyNSwwLjIzNDM3NSAtMC42NTYyNSwwLjM3NSAtMS4wMzEyNSwwLjM3NSAtMC40MjE4NzUsMCAtMC43NSwtMC4xNDA2MjUgLTEuMDMxMjUsLTAuMzc1IC0wLjI4MTI1LC0wLjI4MTI1IC0wLjM3NSwtMC42NTYyNSAtMC4zNzUsLTEuMDMxMjUgMCwtMC40MjE4NzUgMC4wOTM3NSwtMC43NSAwLjM3NSwtMS4wMzEyNSAwLDAgMy4zMjgxMjUsLTMuNzUwMDAwNSAzLjMyODEyNSwtMy43NTAwMDA1IDAsMCAtMy4zMjgxMjUsLTMuNzk2ODc1IC0zLjMyODEyNSwtMy43OTY4NzUgLTAuMjgxMjUsLTAuMjgxMjUgLTAuMzc1LC0wLjYwOTM3NSAtMC4zNzUsLTEuMDMxMjUgMCwtMC4zNzUgMC4wOTM3NSwtMC43NSAwLjM3NSwtMS4wMzEyNSAwLjI4MTI1LC0wLjIzNDM3NSAwLjYwOTM3NSwtMC4zNzUgMS4wMzEyNSwtMC4zNzUgMC4zNzUsMCAwLjc1LDAuMTQwNjI1IDEuMDMxMjUsMC4zNzUgMCwwIDMuMTQwNjI1LDMuNjU2MjUgMy4xNDA2MjUsMy42NTYyNSAwLDAgMy4xODc0OTgxLC0zLjY1NjI1IDMuMTg3NDk4MSwtMy42NTYyNSAwLjI4MTI1LC0wLjIzNDM3NSAwLjY1NjI1LC0wLjM3NSAxLjAzMTI1LC0wLjM3NSAwLjQyMTg3NSwwIDAuNzUsMC4xNDA2MjUgMS4wMzEyNSwwLjM3NSAwLjI4MTI1LDAuMjgxMjUgMC40MjE4NzUsMC42NTYyNSAwLjQyMTg3NSwxLjAzMTI1IDAsMC40MjE4NzUgLTAuMTQwNjI1LDAuNzUgLTAuNDIxODc1LDEuMDMxMjUgMCwwIC0zLjMyODEyMzEsMy43OTY4NzUgLTMuMzI4MTIzMSwzLjc5Njg3NSAwLDAgMy4zMjgxMjMxLDMuNzUwMDAwNSAzLjMyODEyMzEsMy43NTAwMDA1IiBmaWxsPSIjZmZmIi8+Cjwvc3ZnPgo=',
      remoteStorageIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMzIiIHdpZHRoPSIzMiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxkZWZzPgogIDxyYWRpYWxHcmFkaWVudCBpZD0iYSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGN5PSI1NzEuNDIiIGN4PSIxMDQ2LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE0NDMzIDAgMCAuMTY2NjcgMTIwMS41IDg3Ny4xMSkiIHI9Ijk2Ij4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2ZmNGEwNCIgc3RvcC1vcGFjaXR5PSIuNzYxNTQiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjZmY0YTA0IiBvZmZzZXQ9IjEiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogPC9kZWZzPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzMzYuNiAtOTU2LjM1KSI+CiAgPHBhdGggc3R5bGU9ImNvbG9yOiMwMDAwMDAiIGQ9Im0xMzUyLjYgOTU2LjM1IDAuMjg4NiAxNS4xMzYgMTMuNTY3LTcuMTM1Mi0xMy44NTUtOC4wMDExemwtMTMuODU1IDguMDAxMSAxMy41NjcgNy4xMzUyIDAuMjg4Ny0xNS4xMzZ6bS0xMy44NTUgOC4wMDExdjE1Ljk5OGwxMi45NTgtNy44MTYyLTEyLjk1OC04LjE4MTV6bTAgMTUuOTk4IDEzLjg1NSA4LjAwMTEtMC42MDg5LTE1LjMxNy0xMy4yNDYgNy4zMTU2em0xMy44NTUgOC4wMDExIDEzLjg1NS04LjAwMTEtMTMuMjUxLTcuMzE1Ni0wLjYwNDQgMTUuMzE3em0xMy44NTUtOC4wMDExdi0xNS45OThsLTEyLjk2MiA4LjE4MTUgMTIuOTYyIDcuODE2MnoiIGZpbGw9InVybCgjYSkiLz4KIDwvZz4KPC9zdmc+Cg==',
      remoteStorageIconCiphered: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMzIiIHdpZHRoPSIzMiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxkZWZzPgogIDxyYWRpYWxHcmFkaWVudCBpZD0iYSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGN5PSI1NzEuNDIiIGN4PSIxMDQ2LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE0NDMzIDAgMCAuMTY2NjcgMTIwMS41IDg3Ny4xMSkiIHI9Ijk2Ij4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2ZmNGEwNCIgc3RvcC1vcGFjaXR5PSIuNzYxNTQiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjZmY0YTA0IiBvZmZzZXQ9IjEiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogPC9kZWZzPgogPHBhdGggc3R5bGU9ImNvbG9yOiMwMDAwMDAiIGQ9Im0xNiAwbDAuMTI1IDYuMzc1YzIuMDk4IDAuMDY3IDMuNzUgMS43NTk1IDMuNzUgMy44NzV2MS45NjloMS45MzcgMC4wMzJsOC00LjIxOS0xMy44NDQtOHpsLTEzLjg0NCA4IDggNC4yMTloMC4wMzIgMS45MDZ2LTEuOTY5YzAtMi4xMTU1IDEuNjgzLTMuODA4IDMuNzgxLTMuODc1bDAuMTI1LTYuMzc1em0tMTMuODQ0IDh2MTZsNy45OTk4LTQuODQ0di02LjA5NGwtNy45OTk4LTUuMDYyem0wIDE2bDEzLjg0NCA4LTAuMzc1LTEwLjA2MmgtNS40Njl2LTIuMzQ0bC03Ljk5OTggNC40MDZ6bTEzLjg0NCA4bDEzLjg0NC04LTgtNC40MDZ2Mi4zNDRoLTUuNDY5bC0wLjM3NSAxMC4wNjJ6bTEzLjg0NC04di0xNmwtOCA1LjA2MnY2LjA5NGw4IDQuODQ0em0tMTMuOTY5LTE3Yy0xLjczNSAwLjA2NjYtMy4xMjUgMS40OTg3LTMuMTI1IDMuMjV2MS45NjloMy4wMzFsMC4wOTQtNS4yMTl6bTAuMjUgMGwwLjA5NCA1LjIxOWgzLjAzMXYtMS45NjljMC0xLjc1MTMtMS4zOS0zLjE4MzQtMy4xMjUtMy4yNXptLTQuNzUgNS44NDRsNC4zNDQgMi4yODEgMC4wMzEtMi4yODFoLTQuMzc1em00Ljg3NSAwbDAuMDMxIDIuMjgxIDQuMzQ0LTIuMjgxaC00LjM3NXptLTUuNDM4IDAuNjI1djUuMzEybDQuMjgyLTIuNTkzLTQuMjgyLTIuNzE5em0xMC4zNzYgMGwtNC4yODIgMi43MTkgNC4yODIgMi41OTN2LTUuMzEyem0tNS43ODIgMy4yMTlsLTQuNTk0IDIuNTMxdjIuMDYyaDQuNzgybC0wLjE4OC00LjU5M3ptMS4xODggMGwtMC4xODggNC41OTNoNC43ODJ2LTIuMDYybC00LjU5NC0yLjUzMXoiIGZpbGw9InVybCgjYSkiLz4KPC9zdmc+Cg==',
      remoteStorageIconError: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMzIiIHdpZHRoPSIzMiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxkZWZzPgogIDxyYWRpYWxHcmFkaWVudCBpZD0iYSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGN5PSI1NzEuNDIiIGN4PSIxMDQ2LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE0NDMzIDAgMCAuMTY2NjcgMTIwMS41IDg3Ny4xMSkiIHI9Ijk2Ij4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2U5MDAwMCIgc3RvcC1vcGFjaXR5PSIuNzYwNzgiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjZTkwMDAwIiBvZmZzZXQ9IjEiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogPC9kZWZzPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzMzYuNiAtOTU2LjM1KSI+CiAgPHBhdGggc3R5bGU9ImNvbG9yOiMwMDAwMDAiIGQ9Im0xMzUyLjYgOTU2LjM1IDAuMjg4NiAxNS4xMzYgMTMuNTY3LTcuMTM1Mi0xMy44NTUtOC4wMDExemwtMTMuODU1IDguMDAxMSAxMy41NjcgNy4xMzUyIDAuMjg4Ny0xNS4xMzZ6bS0xMy44NTUgOC4wMDExdjE1Ljk5OGwxMi45NTgtNy44MTYyLTEyLjk1OC04LjE4MTV6bTAgMTUuOTk4IDEzLjg1NSA4LjAwMTEtMC42MDg5LTE1LjMxNy0xMy4yNDYgNy4zMTU2em0xMy44NTUgOC4wMDExIDEzLjg1NS04LjAwMTEtMTMuMjUxLTcuMzE1Ni0wLjYwNDQgMTUuMzE3em0xMy44NTUtOC4wMDExdi0xNS45OThsLTEyLjk2MiA4LjE4MTUgMTIuOTYyIDcuODE2MnoiIGZpbGw9InVybCgjYSkiLz4KIDwvZz4KPC9zdmc+Cg==',
      remoteStorageIconOffline: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMzIiIHdpZHRoPSIzMiIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KIDxkZWZzPgogIDxyYWRpYWxHcmFkaWVudCBpZD0iYSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGN5PSI1NzEuNDIiIGN4PSIxMDQ2LjUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE0NDMzIDAgMCAuMTY2NjcgMTIwMS41IDg3Ny4xMSkiIHI9Ijk2Ij4KICAgPHN0b3Agc3RvcC1jb2xvcj0iIzY5Njk2OSIgc3RvcC1vcGFjaXR5PSIuNzYxNTQiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjNjc2NzY3IiBvZmZzZXQ9IjEiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogPC9kZWZzPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzMzYuNiAtOTU2LjM1KSI+CiAgPHBhdGggc3R5bGU9ImNvbG9yOiMwMDAwMDAiIGQ9Im0xMzUyLjYgOTU2LjM1IDAuMjg4NiAxNS4xMzYgMTMuNTY3LTcuMTM1Mi0xMy44NTUtOC4wMDExemwtMTMuODU1IDguMDAxMSAxMy41NjcgNy4xMzUyIDAuMjg4Ny0xNS4xMzZ6bS0xMy44NTUgOC4wMDExdjE1Ljk5OGwxMi45NTgtNy44MTYyLTEyLjk1OC04LjE4MTV6bTAgMTUuOTk4IDEzLjg1NSA4LjAwMTEtMC42MDg5LTE1LjMxNy0xMy4yNDYgNy4zMTU2em0xMy44NTUgOC4wMDExIDEzLjg1NS04LjAwMTEtMTMuMjUxLTcuMzE1Ni0wLjYwNDQgMTUuMzE3em0xMy44NTUtOC4wMDExdi0xNS45OThsLTEyLjk2MiA4LjE4MTUgMTIuOTYyIDcuODE2MnoiIGZpbGw9InVybCgjYSkiLz4KIDwvZz4KPC9zdmc+Cg==',
      syncIcon: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDg3LjUgMTAwIiB4bWw6c3BhY2U9InByZXNlcnZlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTUuOTk5OTk5IDE2IiB3aWR0aD0iMTYiIHZlcnNpb249IjEuMSIgeT0iMHB4IiB4PSIwcHgiIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01LjUxMTIgLTc2LjUyNSkiIGRpc3BsYXk9Im5vbmUiPgoJPHBhdGggZGlzcGxheT0iaW5saW5lIiBkPSJtNTEuNDczIDQyLjI1NS0yLjIwNSAyLjIxMmMxLjQ3OCAxLjQ3NyAyLjI5NSAzLjQ0MiAyLjI5NSA1LjUzMyAwIDQuMzA5LTMuNTA0IDcuODEyLTcuODEyIDcuODEydi0xLjU2MmwtMy4xMjUgMy4xMjUgMy4xMjQgMy4xMjV2LTEuNTYyYzYuMDI5IDAgMTAuOTM4LTQuOTA2IDEwLjkzOC0xMC45MzggMC0yLjkyNy0xLjE0MS01LjY3Ni0zLjIxNS03Ljc0NXoiLz4KCTxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0ibTQ2Ljg3NSA0MC42MjUtMy4xMjUtMy4xMjV2MS41NjJjLTYuMDMgMC0xMC45MzggNC45MDctMTAuOTM4IDEwLjkzOCAwIDIuOTI3IDEuMTQxIDUuNjc2IDMuMjE3IDcuNzQ1bDIuMjAzLTIuMjEyYy0xLjQ3Ny0xLjQ3OS0yLjI5NC0zLjQ0Mi0yLjI5NC01LjUzMyAwLTQuMzA5IDMuNTA0LTcuODEyIDcuODEyLTcuODEydjEuNTYybDMuMTI1LTMuMTI1eiIvPgo8L2c+CjxwYXRoIGZpbGw9IiNmZmYiIGQ9Im0xMCAwbC0wLjc1IDEuOTA2MmMtMS4wMDc4LTAuMjk0Mi0zLjQ1ODYtMC43NzA4LTUuNjU2MiAwLjkzNzYgMC0wLjAwMDItMy45MzAyIDIuNTk0MS0yLjA5MzggNy41OTQybDEuNjU2Mi0wLjcxOTJzLTEuNTM5OS0zLjExMjIgMS42ODc2LTUuNTMxM2MwIDAgMS42OTU3LTEuMTMzOSAzLjY4NzQtMC41OTM3bC0wLjcxODcgMS44MTI0IDMuODEyNS0xLjYyNS0xLjYyNS0zLjc4MTJ6Ii8+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTE0IDUuNTYyNWwtMS42NTYgMC43MTg3czEuNTQxIDMuMTEzNS0xLjY4OCA1LjUzMDhjMCAwLTEuNzI3MiAxLjEzNS0zLjcxODUgMC41OTRsMC43NS0xLjgxMi0zLjgxMjUgMS41OTQgMS41OTM4IDMuODEyIDAuNzgxMi0xLjkwNmMxLjAxMTMgMC4yOTUgMy40NjE1IDAuNzY2IDUuNjU2LTAuOTM4IDAgMCAzLjkyOC0yLjU5NCAyLjA5NC03LjU5MzV6Ii8+Cjwvc3ZnPgo=',
      widget: '<div class="rs-bubble rs-hidden">   <div class="rs-bubble-text remotestorage-initial remotestorage-error remotestorage-authing remotestorage-offline">     <span class="rs-status-text">{{view_connect}}</span>   </div>   <div class="rs-bubble-expandable">     <!-- error -->     <div class="remotestorage-error">       <pre class="rs-status-text rs-error-msg">{{ERROR_MSG}}</pre>       <button class="remotestorage-reset">{{view_get_me_out}}</button>       <p class="rs-centered-text rs-error-plz-report">{{view_error_plz_report}}</p>     </div>     <!-- connected -->     <div class="rs-bubble-text remotestorage-connected">       <strong class="userAddress">{{USER_ADDRESS}}</strong>       <p class="remotestorage-unauthorized">{{view_unauthorized}}</p>       <p class="remotestorage-invalid-key">{{view_invalid_key}}</p>       <form novalidate class="remotestorage-cipher-form">         <input placeholder="Secret key" name="userSecretKey" novalidate>         <button class="rs-cipher" name="rs-cipher" title="cipher" disabled="disabled">           <img>         </button>         <button class="rs-nocipher" name="rs-nocipher" title="no cipher">           <img>         </button>       </form>     </div>     <div class="rs-content remotestorage-connected">       <button class="rs-sync" title="sync"><img></button>       <button class="rs-disconnect" title="disconnect"><img></button>     </div>     <!-- initial -->     <form novalidate class="remotestorage-initial">       <input type="email" placeholder="user@provider.com" name="userAddress" novalidate>       <button class="connect" name="connect" title="connect" disabled="disabled">         <img>       </button>     </form>     <div class="rs-info-msg remotestorage-initial">{{view_info}}</div>   </div> </div> <img class="rs-dropbox rs-backends rs-action" alt="Connect to Dropbox"> <img class="rs-googledrive rs-backends rs-action" alt="Connect to Google Drive"> <img class="rs-cube rs-action"> ',
      widgetCss: '/** encoding:utf-8 **/ /* RESET */ #remotestorage-widget{text-align:left;}#remotestorage-widget input, #remotestorage-widget button{font-size:11px;}#remotestorage-widget form input[type=email]{margin-bottom:0;/* HTML5 Boilerplate */}#remotestorage-widget form input[type=submit]{margin-top:0;/* HTML5 Boilerplate */}/* /RESET */ #remotestorage-widget, #remotestorage-widget *{-moz-box-sizing:border-box;box-sizing:border-box;}#remotestorage-widget{position:absolute;right:10px;top:10px;font:normal 16px/100% sans-serif !important;user-select:none;-webkit-user-select:none;-moz-user-select:-moz-none;cursor:default;z-index:10000;}#remotestorage-widget .rs-bubble{background:rgba(80, 80, 80, .7);border-radius:5px 15px 5px 5px;color:white;font-size:0.8em;padding:5px;position:absolute;right:3px;top:9px;min-height:24px;white-space:nowrap;text-decoration:none;}.rs-bubble .rs-bubble-text{padding-right:32px;/* make sure the bubble doesn\'t "jump" when initially opening. */ min-width:182px;}#remotestorage-widget .rs-action{cursor:pointer;}/* less obtrusive cube when connected */ #remotestorage-widget.remotestorage-state-connected .rs-cube, #remotestorage-widget.remotestorage-state-busy .rs-cube{opacity:.3;-webkit-transition:opacity .3s ease;-moz-transition:opacity .3s ease;-ms-transition:opacity .3s ease;-o-transition:opacity .3s ease;transition:opacity .3s ease;}#remotestorage-widget.remotestorage-state-connected:hover .rs-cube, #remotestorage-widget.remotestorage-state-busy:hover .rs-cube, #remotestorage-widget.remotestorage-state-connected .rs-bubble:not(.rs-hidden) + .rs-cube{opacity:1 !important;}#remotestorage-widget .rs-backends{position:relative;top:5px;right:0;}#remotestorage-widget .rs-cube{position:relative;top:5px;right:0;}/* pulsing animation for cube when loading */ #remotestorage-widget .rs-cube.remotestorage-loading{-webkit-animation:remotestorage-loading .5s ease-in-out infinite alternate;-moz-animation:remotestorage-loading .5s ease-in-out infinite alternate;-o-animation:remotestorage-loading .5s ease-in-out infinite alternate;-ms-animation:remotestorage-loading .5s ease-in-out infinite alternate;animation:remotestorage-loading .5s ease-in-out infinite alternate;}@-webkit-keyframes remotestorage-loading{to{opacity:.7}}@-moz-keyframes remotestorage-loading{to{opacity:.7}}@-o-keyframes remotestorage-loading{to{opacity:.7}}@-ms-keyframes remotestorage-loading{to{opacity:.7}}@keyframes remotestorage-loading{to{opacity:.7}}#remotestorage-widget a{text-decoration:underline;color:inherit;}#remotestorage-widget form{margin-top:.7em;position:relative;}#remotestorage-widget form input{display:table-cell;vertical-align:top;border:none;border-radius:6px;font-weight:bold;color:white;outline:none;line-height:1.5em;height:2em;}#remotestorage-widget form input:disabled{color:#999;background:#444 !important;cursor:default !important;}#remotestorage-widget form input[type=email]:focus, #remotestorage-widget form input[type=password]:focus{background:#223;}#remotestorage-widget form input[type=email], #remotestorage-widget form input[type=password]{background:#000;width:100%;height:26px;padding:0 30px 0 5px;border-top:1px solid #111;border-bottom:1px solid #999;}#remotestorage-widget form input[type=email]:focus, #remotestorage-widget form input[type=password]:focus{background:#223;}#remotestorage-widget button:focus, #remotestorage-widget input:focus{box-shadow:0 0 4px #ccc;}#remotestorage-widget form input[type=email]::-webkit-input-placeholder, #remotestorage-widget form input[type=password]::-webkit-input-placeholder{color:#999;}#remotestorage-widget form input[type=email]:-moz-placeholder, #remotestorage-widget form input[type=password]:-moz-placeholder{color:#999;}#remotestorage-widget form input[type=email]::-moz-placeholder, #remotestorage-widget form input[type=password]::-moz-placeholder{color:#999;}#remotestorage-widget form input[type=email]:-ms-input-placeholder, #remotestorage-widget form input[type=password]:-ms-input-placeholder{color:#999;}#remotestorage-widget form input[type=submit]{background:#000;cursor:pointer;padding:0 5px;}#remotestorage-widget form input[type=submit]:hover{background:#333;}#remotestorage-widget .rs-info-msg{font-size:10px;color:#eee;margin-top:0.7em;white-space:normal;}#remotestorage-widget .rs-info-msg.last-synced-message{display:inline;white-space:nowrap;margin-bottom:.7em}#remotestorage-widget .rs-info-msg a:hover, #remotestorage-widget .rs-info-msg a:active{color:#fff;}#remotestorage-widget button img{vertical-align:baseline;}#remotestorage-widget button{border:none;border-radius:6px;font-weight:bold;color:white;outline:none;line-height:1.5em;height:26px;width:26px;background:#000;cursor:pointer;margin:0;padding:5px;}#remotestorage-widget button:hover{background:#333;}#remotestorage-widget .rs-bubble button.connect, #remotestorage-widget .rs-bubble button.rs-cipher, #remotestorage-widget .rs-bubble button.rs-nocipher{display:block;background:none;position:absolute;right:0;top:0;opacity:1;/* increase clickable area of connect, rs-cipher & rs-nocipher buttons */ margin:-5px;padding:10px;width:36px;height:36px;}#remotestorage-widget .rs-bubble button.rs-cipher{width:46px;}#remotestorage-widget .rs-bubble button.rs-nocipher{height:26px;margin:0;padding:4px 5px 5px;right:-32px;width:26px;}#remotestorage-widget .rs-bubble button.connect:not([disabled]):hover, #remotestorage-widget .rs-bubble button.rs-cipher:not([disabled]):hover, #remotestorage-widget .rs-bubble button.rs-nocipher:not([disabled]):hover{background:rgba(150,150,150,.5);}#remotestorage-widget .rs-bubble button.connect[disabled], #remotestorage-widget .rs-bubble button.rs-cipher[disabled]{opacity:.5;cursor:default !important;}#remotestorage-widget .rs-bubble button.rs-sync{position:relative;left:-5px;bottom:-5px;padding:4px 4px 0 4px;background:#555;}#remotestorage-widget .rs-bubble button.rs-sync:hover{background:#444;}#remotestorage-widget .rs-bubble button.rs-disconnect{background:#721;position:absolute;right:0;bottom:0;padding:4px 4px 0 4px;}#remotestorage-widget .rs-bubble button.rs-disconnect:hover{background:#921;}#remotestorage-widget .remotestorage-error-info{color:#f92;}#remotestorage-widget .remotestorage-reset{width:100%;background:#721;}#remotestorage-widget .remotestorage-reset:hover{background:#921;}#remotestorage-widget .rs-bubble .rs-content{margin-top:7px;}#remotestorage-widget pre{user-select:initial;-webkit-user-select:initial;-moz-user-select:text;max-width:27em;margin-top:1em;overflow:auto;}#remotestorage-widget .rs-centered-text{text-align:center;}#remotestorage-widget .rs-bubble.rs-hidden{padding-bottom:2px;border-radius:5px 15px 15px 5px;}#remotestorage-widget .rs-error-msg{min-height:5em;}.rs-bubble.rs-hidden .rs-bubble-expandable{display:none;}.remotestorage-state-connected .rs-bubble.rs-hidden{display:none;}.remotestorage-connected{display:none;}.remotestorage-state-connected .remotestorage-connected{display:block;}.remotestorage-cipher-form{display:none;}.remotestorage-cipher .remotestorage-cipher-form{display:block;}.remotestorage-invalid-key{display:none;}.remotestorage-invalid-key.remotestorage-cipher-error{display:block;}.remotestorage-initial{display:none;}.remotestorage-state-initial .remotestorage-initial{display:block;}.remotestorage-error{display:none;}.remotestorage-state-error .remotestorage-error{display:block;}.remotestorage-state-authing .remotestorage-authing{display:block;}.remotestorage-state-offline .remotestorage-connected, .remotestorage-state-offline .remotestorage-offline{display:block;}.remotestorage-unauthorized{display:none;}.remotestorage-state-unauthorized .rs-bubble.rs-hidden{display:none;}.remotestorage-state-unauthorized .remotestorage-connected, .remotestorage-state-unauthorized .remotestorage-unauthorized{display:block;}.remotestorage-state-unauthorized .rs-sync{display:none;}.remotestorage-state-busy .rs-bubble.rs-hidden{display:none;}.remotestorage-state-busy .rs-bubble{display:block;}.remotestorage-state-busy .remotestorage-connected{display:block;}.remotestorage-state-authing .rs-bubble-expandable{display:none;}'
    };
    (function(window) {
      var hasLocalStorage;
      var LS_STATE_KEY = 'remotestorage:widget:state';
      var VALID_ENTRY_STATES = {
        initial: true,
        connected: true,
        offline: true
      };
      RemoteStorage.Widget = function(remoteStorage) {
        var self = this;
        var requestsToFlashFor = 0;
        this.rs = remoteStorage;
        this.rs.remote.on('connected', stateSetter(this, 'connected'));
        this.rs.on('disconnected', stateSetter(this, 'initial'));
        this.rs.on('connecting', stateSetter(this, 'authing'));
        this.rs.on('authing', stateSetter(this, 'authing'));
        this.rs.on('error', errorsHandler(this));
        if (this.rs.remote) {
          this.rs.remote.on('wire-busy', function(evt) {
            if (flashFor(evt)) {
              requestsToFlashFor++;
              stateSetter(self, 'busy')();
            }
          });
          this.rs.remote.on('wire-done', function(evt) {
            if (flashFor(evt)) {
              requestsToFlashFor--;
            }
            if (requestsToFlashFor <= 0 && evt.success) {
              stateSetter(self, 'connected')();
            }
          });
        }
        if (hasLocalStorage) {
          var state = localStorage[LS_STATE_KEY];
          if (state && VALID_ENTRY_STATES[state]) {
            this._rememberedState = state;
          }
        }
      };
      RemoteStorage.Widget.prototype = {
        display: function(options) {
          if (typeof(options) === 'string') {
            options = {domID: options};
          } else if (typeof(options) === 'undefined') {
            options = {};
          }
          if (!this.view) {
            this.setView(new RemoteStorage.Widget.View(this.rs));
          }
          this.view.display(options);
          return this;
        },
        linkWidgetToSync: function() {
          if (typeof(this.rs.sync) === 'object' && typeof(this.rs.sync.sync) === 'function') {
            this.view.on('sync', this.rs.sync.sync.bind(this.rs.sync));
          } else {
            RemoteStorage.log('[Widget] typeof this.rs.sync check fail', this.rs.sync);
            setTimeout(this.linkWidgetToSync.bind(this), 1000);
          }
        },
        setView: function(view) {
          this.view = view;
          this.view.on('connect', function(options) {
            if (typeof(options) === 'string') {
              this.rs.connect(options);
            } else if (options.special) {
              this.rs[options.special].connect(options);
            }
          }.bind(this));
          this.view.on('secret-entered', function(secretKey) {
            this.view.setUserSecretKey(secretKey);
            stateSetter(this, 'ciphered')();
          }.bind(this));
          this.view.on('secret-cancelled', function() {
            stateSetter(this, 'notciphered')();
          }.bind(this));
          this.view.on('disconnect', this.rs.disconnect.bind(this.rs));
          this.linkWidgetToSync();
          try {
            this.view.on('reset', function() {
              var location = RemoteStorage.Authorize.getLocation();
              this.rs.on('disconnected', location.reload.bind(location));
              this.rs.disconnect();
            }.bind(this));
          } catch (e) {
            if (!(e.message && e.message.match(/Unknown event/))) {
              throw e;
            }
          }
          if (this._rememberedState) {
            setTimeout(stateSetter(this, this._rememberedState), 0);
            delete this._rememberedState;
          }
        }
      };
      RemoteStorage.prototype.displayWidget = function(options) {
        return this.widget.display(options);
      };
      RemoteStorage.Widget._rs_init = function(remoteStorage) {
        hasLocalStorage = remoteStorage.localStorageAvailable();
        if (!remoteStorage.widget) {
          remoteStorage.widget = new RemoteStorage.Widget(remoteStorage);
        }
      };
      RemoteStorage.Widget._rs_supported = function(remoteStorage) {
        return typeof(document) !== 'undefined';
      };
      function stateSetter(widget, state) {
        RemoteStorage.log('[Widget] Producing stateSetter for', state);
        return function() {
          RemoteStorage.log('[Widget] Setting state', state, arguments);
          if (hasLocalStorage) {
            localStorage[LS_STATE_KEY] = state;
          }
          if (widget.view) {
            if (widget.rs.remote) {
              widget.view.setUserAddress(widget.rs.remote.userAddress);
            }
            widget.view.setState(state, arguments);
          } else {
            widget._rememberedState = state;
          }
        };
      }
      function errorsHandler(widget) {
        return function(error) {
          var s;
          if (error instanceof RemoteStorage.DiscoveryError) {
            console.error('Discovery failed', error, '"' + error.message + '"');
            s = stateSetter(widget, 'initial', [error.message]);
          } else if (error instanceof RemoteStorage.SyncError) {
            s = stateSetter(widget, 'offline', []);
          } else if (error instanceof RemoteStorage.Unauthorized) {
            s = stateSetter(widget, 'unauthorized');
          } else {
            RemoteStorage.log('[Widget] Unknown error');
            s = stateSetter(widget, 'error', [error]);
          }
          s.apply();
        };
      }
      function flashFor(evt) {
        if (evt.method === 'GET' && evt.isFolder) {
          return false;
        }
        return true;
      }
    })(typeof(window) !== 'undefined' ? window : global);
    (function(window) {
      var t = RemoteStorage.I18n.translate;
      RemoteStorage.Widget.View = function(remoteStorage) {
        this.rs = remoteStorage;
        if (typeof(document) === 'undefined') {
          throw "Widget not supported";
        }
        RemoteStorage.eventHandling(this, 'connect', 'secret-entered', 'secret-cancelled', 'disconnect', 'sync', 'display', 'reset');
        for (var event in this.events) {
          this.events[event] = this.events[event].bind(this);
        }
        this.hideBubbleOnBodyClick = function(event) {
          for (var p = event.target; p !== document.body; p = p.parentElement) {
            if (p.id === 'remotestorage-widget') {
              return;
            }
          }
          this.hideBubble();
        }.bind(this);
      };
      RemoteStorage.Widget.View.prototype = {
        connectGdrive: function() {
          this._emit('connect', {special: 'googledrive'});
        },
        connectDropbox: function() {
          this._emit('connect', {special: 'dropbox'});
        },
        setState: function(state, args) {
          RemoteStorage.log('[View] widget.view.setState(', state, ',', args, ');');
          var s = this.states[state];
          if (typeof(s) === 'undefined') {
            throw new Error("Bad State assigned to view: " + state);
          }
          s.apply(this, args);
        },
        setUserAddress: function(addr) {
          this.userAddress = addr || '';
          var el;
          if (this.div && (el = this.div.querySelector('form.remotestorage-initial').userAddress)) {
            el.value = this.userAddress;
          }
        },
        setUserSecretKey: function(secretKey) {
          this.userSecretKey = secretKey;
        },
        toggleBubble: function(event) {
          if (this.bubble.className.search('rs-hidden') < 0) {
            this.hideBubble(event);
          } else {
            this.showBubble(event);
          }
        },
        hideBubble: function() {
          addClass(this.bubble, 'rs-hidden');
          document.body.removeEventListener('click', this.hideBubbleOnBodyClick);
        },
        showBubble: function(event) {
          removeClass(this.bubble, 'rs-hidden');
          if (typeof(event) !== 'undefined') {
            stopPropagation(event);
          }
          document.body.addEventListener('click', this.hideBubbleOnBodyClick);
          if (this.div.querySelector('.remotestorage-connected').classList.contains('remotestorage-cipher') && !this.userSecretKey) {
            this.bubble.querySelector('form.remotestorage-cipher-form').userSecretKey.focus();
          } else {
            this.bubble.querySelector('form.remotestorage-initial').userAddress.focus();
          }
        },
        display: function(options) {
          if (typeof this.div !== 'undefined') {
            return this.div;
          }
          var element = document.createElement('div');
          var style = document.createElement('style');
          style.innerHTML = RemoteStorage.Assets.widgetCss;
          element.id = "remotestorage-widget";
          element.innerHTML = RemoteStorage.Assets.widget;
          element.appendChild(style);
          if (options.domID) {
            var parent = document.getElementById(options.domID);
            if (!parent) {
              throw "Failed to find target DOM element with id=\"" + options.domID + "\"";
            }
            parent.appendChild(element);
          } else {
            document.body.appendChild(element);
          }
          setupButton(element, 'rs-sync', 'syncIcon', this.events.sync);
          setupButton(element, 'rs-disconnect', 'disconnectIcon', this.events.disconnect);
          setupButton(element, 'remotestorage-reset', undefined, this.events.reset);
          var connectButton = setupButton(element, 'connect', 'connectIcon', this.events.connect);
          this.form = element.querySelector('form.remotestorage-initial');
          var el = this.form.userAddress;
          el.addEventListener('load', handleButtonState);
          el.addEventListener('keyup', handleButtonState);
          if (this.userAddress) {
            el.value = this.userAddress;
          }
          if (options.encryption) {
            this.cipher = true;
            var secretKeyInput = element.querySelector('form.remotestorage-cipher-form').userSecretKey;
            secretKeyInput.type = 'password';
            var cipherButton = setupButton(element, 'rs-cipher', 'cipherIcon', this.events['secret-entered']);
            secretKeyInput.addEventListener('load', handleButtonState);
            secretKeyInput.addEventListener('keyup', handleButtonState);
            setupButton(element, 'rs-nocipher', 'nocipherIcon', this.events['secret-cancelled']);
          }
          this.cube = setupButton(element, 'rs-cube', 'remoteStorageIcon', this.toggleBubble.bind(this));
          setupButton(element, 'rs-dropbox', 'dropbox', this.connectDropbox.bind(this));
          setupButton(element, 'rs-googledrive', 'googledrive', this.connectGdrive.bind(this));
          var bubbleDontCatch = {
            INPUT: true,
            BUTTON: true,
            IMG: true
          };
          var eventListener = function(event) {
            if (!bubbleDontCatch[event.target.tagName] && !(this.div.classList.contains('remotestorage-state-unauthorized'))) {
              this.showBubble(event);
            }
          }.bind(this);
          this.bubble = setupButton(element, 'rs-bubble', undefined, eventListener);
          this.hideBubble();
          this.div = element;
          this.states.initial.call(this);
          this.events.display.call(this);
          return this.div;
        },
        states: {
          initial: function(message) {
            var cube = this.cube;
            var info = message || t("view_info");
            cube.src = RemoteStorage.Assets.remoteStorageIcon;
            this._renderTranslatedInitialContent();
            if (message) {
              cube.src = RemoteStorage.Assets.remoteStorageIconError;
              removeClass(this.cube, 'remotestorage-loading');
              this.showBubble();
              setTimeout(function() {
                cube.src = RemoteStorage.Assets.remoteStorageIcon;
              }, 2000);
            } else {
              this.hideBubble();
            }
            this.div.className = "remotestorage-state-initial";
            if (this.userSecretKey) {
              delete this.userSecretKey;
            }
            var backends = 1;
            if (this._activateBackend('dropbox')) {
              backends += 1;
            }
            if (this._activateBackend('googledrive')) {
              backends += 1;
            }
            this.div.querySelector('.rs-bubble-text').style.paddingRight = backends * 32 + 8 + 'px';
            var cb = this.div.querySelector('.connect');
            if (this.form.userAddress.value) {
              cb.removeAttribute('disabled');
            }
            var infoEl = this.div.querySelector('.rs-info-msg');
            infoEl.innerHTML = info;
            if (message) {
              infoEl.classList.add('remotestorage-error-info');
            } else {
              infoEl.classList.remove('remotestorage-error-info');
            }
          },
          authing: function() {
            this.div.removeEventListener('click', this.events.connect);
            this.div.className = "remotestorage-state-authing";
            this.div.querySelector('.rs-status-text').innerHTML = t("view_connecting", this.userAddress);
            addClass(this.cube, 'remotestorage-loading');
          },
          connected: function() {
            var cube = this.cube;
            this.div.className = "remotestorage-state-connected";
            this.div.querySelector('.userAddress').innerHTML = this.userAddress;
            cube.src = RemoteStorage.Assets.remoteStorageIcon;
            removeClass(cube, 'remotestorage-loading');
            if (this.cipher) {
              if (this.userSecretKey) {
                if (this.userSecretKeyError) {
                  cube.src = RemoteStorage.Assets.remoteStorageIconError;
                  addClass(this.div.querySelector('.remotestorage-connected'), 'remotestorage-cipher');
                  addClass(this.div.querySelector('.remotestorage-invalid-key'), 'remotestorage-cipher-error');
                  this.showBubble();
                  setTimeout(function() {
                    cube.src = RemoteStorage.Assets.remoteStorageIcon;
                  }, 5000);
                } else {
                  removeClass(this.div.querySelector('.remotestorage-invalid-key'), 'remotestorage-cipher-error');
                  cube.src = RemoteStorage.Assets.remoteStorageIconCiphered;
                }
              } else {
                addClass(this.div.querySelector('.remotestorage-connected'), 'remotestorage-cipher');
                this.showBubble();
              }
            }
            var icons = {
              googledrive: this.div.querySelector('.rs-googledrive'),
              dropbox: this.div.querySelector('.rs-dropbox')
            };
            icons.googledrive.style.display = icons.dropbox.style.display = 'none';
            if (icons[this.rs.backend]) {
              icons[this.rs.backend].style.display = 'inline-block';
              this.div.querySelector('.rs-bubble-text').style.paddingRight = 2 * 32 + 8 + 'px';
            } else {
              this.div.querySelector('.rs-bubble-text').style.paddingRight = 32 + 8 + 'px';
            }
          },
          ciphered: function() {
            this.div.querySelector('form.remotestorage-cipher-form').userSecretKey.value = '';
            removeClass(this.div.querySelector('.remotestorage-invalid-key'), 'remotestorage-cipher-error');
            removeClass(this.div.querySelector('.remotestorage-connected'), 'remotestorage-cipher');
            this.cube.src = RemoteStorage.Assets.remoteStorageIconCiphered;
            this.hideBubble();
          },
          notciphered: function() {
            this.cipher = false;
            removeClass(this.div.querySelector('.remotestorage-invalid-key'), 'remotestorage-cipher-error');
            removeClass(this.div.querySelector('.remotestorage-connected'), 'remotestorage-cipher');
            this.hideBubble();
          },
          busy: function() {
            this.div.className = "remotestorage-state-busy";
            addClass(this.cube, 'remotestorage-loading');
          },
          offline: function() {
            this.div.className = "remotestorage-state-offline";
            this.cube.src = RemoteStorage.Assets.remoteStorageIconOffline;
            this.div.querySelector('.rs-status-text').innerHTML = t("view_offline");
          },
          error: function(err) {
            var errorMsg = err;
            this.div.className = "remotestorage-state-error";
            this.div.querySelector('.rs-bubble-text').innerHTML = '<strong>' + t('view_error_occured') + '</strong>';
            if (err instanceof Error) {
              errorMsg = err.message + '\n\n' + err.stack;
            }
            this.div.querySelector('.rs-error-msg').textContent = errorMsg;
            this.cube.src = RemoteStorage.Assets.remoteStorageIconError;
            this.showBubble();
          },
          unauthorized: function() {
            this.div.className = "remotestorage-state-unauthorized";
            this.cube.src = RemoteStorage.Assets.remoteStorageIconError;
            this.showBubble();
            this.div.addEventListener('click', this.events.connect);
          }
        },
        events: {
          connect: function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('connect', this.div.querySelector('form.remotestorage-initial').userAddress.value);
          },
          'secret-entered': function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('secret-entered', this.div.querySelector('form.remotestorage-cipher-form').userSecretKey.value);
          },
          'secret-cancelled': function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('secret-cancelled');
          },
          sync: function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('sync');
          },
          disconnect: function(event) {
            stopPropagation(event);
            event.preventDefault();
            this._emit('disconnect');
          },
          reset: function(event) {
            event.preventDefault();
            var result = window.confirm(t('view_confirm_reset'));
            if (result) {
              this._emit('reset');
            }
          },
          display: function(event) {
            if (event) {
              event.preventDefault();
            }
            this._emit('display');
          }
        },
        _renderTranslatedInitialContent: function() {
          this.div.querySelector('.rs-status-text').innerHTML = t("view_connect");
          this.div.querySelector('.remotestorage-reset').innerHTML = t("view_get_me_out");
          this.div.querySelector('.rs-error-plz-report').innerHTML = t("view_error_plz_report");
          this.div.querySelector('.remotestorage-unauthorized').innerHTML = t("view_unauthorized");
          this.div.querySelector('.remotestorage-invalid-key').innerHTML = t("view_invalid_key");
        },
        _activateBackend: function activateBackend(backendName) {
          var className = 'rs-' + backendName;
          if (this.rs.apiKeys[backendName]) {
            this.div.querySelector('.' + className).style.display = 'inline-block';
            return true;
          } else {
            this.div.querySelector('.' + className).style.display = 'none';
            return false;
          }
        }
      };
      function removeClass(el, className) {
        return el.classList.remove(className);
      }
      function addClass(el, className) {
        return el.classList.add(className);
      }
      function stopPropagation(event) {
        if (typeof(event.stopPropagation) === 'function') {
          event.stopPropagation();
        } else {
          event.cancelBubble = true;
        }
      }
      function setupButton(parent, className, iconName, eventListener) {
        var element = parent.querySelector('.' + className);
        if (typeof iconName !== 'undefined') {
          var img = element.querySelector('img');
          (img || element).src = RemoteStorage.Assets[iconName];
        }
        element.addEventListener('click', eventListener);
        return element;
      }
      function handleButtonState(event) {
        if (event.target.value) {
          event.target.nextElementSibling.removeAttribute('disabled');
        } else {
          event.target.nextElementSibling.setAttribute('disabled', 'disabled');
        }
      }
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global, factory) {
      if (typeof define === 'function' && define.amd) {
        define([], factory);
      } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
      } else {
        global.tv4 = factory();
      }
    }(this, function() {
      if (!Object.keys) {
        Object.keys = (function() {
          var hasOwnProperty = Object.prototype.hasOwnProperty,
              hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
              dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
              dontEnumsLength = dontEnums.length;
          return function(obj) {
            if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
              throw new TypeError('Object.keys called on non-object');
            }
            var result = [];
            for (var prop in obj) {
              if (hasOwnProperty.call(obj, prop)) {
                result.push(prop);
              }
            }
            if (hasDontEnumBug) {
              for (var i = 0; i < dontEnumsLength; i++) {
                if (hasOwnProperty.call(obj, dontEnums[i])) {
                  result.push(dontEnums[i]);
                }
              }
            }
            return result;
          };
        })();
      }
      if (!Object.create) {
        Object.create = (function() {
          function F() {}
          return function(o) {
            if (arguments.length !== 1) {
              throw new Error('Object.create implementation only accepts one parameter.');
            }
            F.prototype = o;
            return new F();
          };
        })();
      }
      if (!Array.isArray) {
        Array.isArray = function(vArg) {
          return Object.prototype.toString.call(vArg) === "[object Array]";
        };
      }
      if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(searchElement) {
          if (this === null) {
            throw new TypeError();
          }
          var t = Object(this);
          var len = t.length >>> 0;
          if (len === 0) {
            return -1;
          }
          var n = 0;
          if (arguments.length > 1) {
            n = Number(arguments[1]);
            if (n !== n) {
              n = 0;
            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
              n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
          }
          if (n >= len) {
            return -1;
          }
          var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
          for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
              return k;
            }
          }
          return -1;
        };
      }
      if (!Object.isFrozen) {
        Object.isFrozen = function(obj) {
          var key = "tv4_test_frozen_key";
          while (obj.hasOwnProperty(key)) {
            key += Math.random();
          }
          try {
            obj[key] = true;
            delete obj[key];
            return false;
          } catch (e) {
            return true;
          }
        };
      }
      var uriTemplateGlobalModifiers = {
        "+": true,
        "#": true,
        ".": true,
        "/": true,
        ";": true,
        "?": true,
        "&": true
      };
      var uriTemplateSuffices = {"*": true};
      function notReallyPercentEncode(string) {
        return encodeURI(string).replace(/%25[0-9][0-9]/g, function(doubleEncoded) {
          return "%" + doubleEncoded.substring(3);
        });
      }
      function uriTemplateSubstitution(spec) {
        var modifier = "";
        if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
          modifier = spec.charAt(0);
          spec = spec.substring(1);
        }
        var separator = "";
        var prefix = "";
        var shouldEscape = true;
        var showVariables = false;
        var trimEmptyString = false;
        if (modifier === '+') {
          shouldEscape = false;
        } else if (modifier === ".") {
          prefix = ".";
          separator = ".";
        } else if (modifier === "/") {
          prefix = "/";
          separator = "/";
        } else if (modifier === '#') {
          prefix = "#";
          shouldEscape = false;
        } else if (modifier === ';') {
          prefix = ";";
          separator = ";";
          showVariables = true;
          trimEmptyString = true;
        } else if (modifier === '?') {
          prefix = "?";
          separator = "&";
          showVariables = true;
        } else if (modifier === '&') {
          prefix = "&";
          separator = "&";
          showVariables = true;
        }
        var varNames = [];
        var varList = spec.split(",");
        var varSpecs = [];
        var varSpecMap = {};
        for (var i = 0; i < varList.length; i++) {
          var varName = varList[i];
          var truncate = null;
          if (varName.indexOf(":") !== -1) {
            var parts = varName.split(":");
            varName = parts[0];
            truncate = parseInt(parts[1], 10);
          }
          var suffices = {};
          while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
            suffices[varName.charAt(varName.length - 1)] = true;
            varName = varName.substring(0, varName.length - 1);
          }
          var varSpec = {
            truncate: truncate,
            name: varName,
            suffices: suffices
          };
          varSpecs.push(varSpec);
          varSpecMap[varName] = varSpec;
          varNames.push(varName);
        }
        var subFunction = function(valueFunction) {
          var result = "";
          var startIndex = 0;
          for (var i = 0; i < varSpecs.length; i++) {
            var varSpec = varSpecs[i];
            var value = valueFunction(varSpec.name);
            if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
              startIndex++;
              continue;
            }
            if (i === startIndex) {
              result += prefix;
            } else {
              result += (separator || ",");
            }
            if (Array.isArray(value)) {
              if (showVariables) {
                result += varSpec.name + "=";
              }
              for (var j = 0; j < value.length; j++) {
                if (j > 0) {
                  result += varSpec.suffices['*'] ? (separator || ",") : ",";
                  if (varSpec.suffices['*'] && showVariables) {
                    result += varSpec.name + "=";
                  }
                }
                result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
              }
            } else if (typeof value === "object") {
              if (showVariables && !varSpec.suffices['*']) {
                result += varSpec.name + "=";
              }
              var first = true;
              for (var key in value) {
                if (!first) {
                  result += varSpec.suffices['*'] ? (separator || ",") : ",";
                }
                first = false;
                result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
                result += varSpec.suffices['*'] ? '=' : ",";
                result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
              }
            } else {
              if (showVariables) {
                result += varSpec.name;
                if (!trimEmptyString || value !== "") {
                  result += "=";
                }
              }
              if (varSpec.truncate != null) {
                value = value.substring(0, varSpec.truncate);
              }
              result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21") : notReallyPercentEncode(value);
            }
          }
          return result;
        };
        subFunction.varNames = varNames;
        return {
          prefix: prefix,
          substitution: subFunction
        };
      }
      function UriTemplate(template) {
        if (!(this instanceof UriTemplate)) {
          return new UriTemplate(template);
        }
        var parts = template.split("{");
        var textParts = [parts.shift()];
        var prefixes = [];
        var substitutions = [];
        var varNames = [];
        while (parts.length > 0) {
          var part = parts.shift();
          var spec = part.split("}")[0];
          var remainder = part.substring(spec.length + 1);
          var funcs = uriTemplateSubstitution(spec);
          substitutions.push(funcs.substitution);
          prefixes.push(funcs.prefix);
          textParts.push(remainder);
          varNames = varNames.concat(funcs.substitution.varNames);
        }
        this.fill = function(valueFunction) {
          var result = textParts[0];
          for (var i = 0; i < substitutions.length; i++) {
            var substitution = substitutions[i];
            result += substitution(valueFunction);
            result += textParts[i + 1];
          }
          return result;
        };
        this.varNames = varNames;
        this.template = template;
      }
      UriTemplate.prototype = {
        toString: function() {
          return this.template;
        },
        fillFromObject: function(obj) {
          return this.fill(function(varName) {
            return obj[varName];
          });
        }
      };
      var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
        this.missing = [];
        this.missingMap = {};
        this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
        this.schemas = parent ? Object.create(parent.schemas) : {};
        this.collectMultiple = collectMultiple;
        this.errors = [];
        this.handleError = collectMultiple ? this.collectError : this.returnError;
        if (checkRecursive) {
          this.checkRecursive = true;
          this.scanned = [];
          this.scannedFrozen = [];
          this.scannedFrozenSchemas = [];
          this.scannedFrozenValidationErrors = [];
          this.validatedSchemasKey = 'tv4_validation_id';
          this.validationErrorsKey = 'tv4_validation_errors_id';
        }
        if (trackUnknownProperties) {
          this.trackUnknownProperties = true;
          this.knownPropertyPaths = {};
          this.unknownPropertyPaths = {};
        }
        this.errorReporter = errorReporter || defaultErrorReporter('en');
        if (typeof this.errorReporter === 'string') {
          throw new Error('debug');
        }
        this.definedKeywords = {};
        if (parent) {
          for (var key in parent.definedKeywords) {
            this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
          }
        }
      };
      ValidatorContext.prototype.defineKeyword = function(keyword, keywordFunction) {
        this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
        this.definedKeywords[keyword].push(keywordFunction);
      };
      ValidatorContext.prototype.createError = function(code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
        var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
        error.message = this.errorReporter(error, data, schema);
        return error;
      };
      ValidatorContext.prototype.returnError = function(error) {
        return error;
      };
      ValidatorContext.prototype.collectError = function(error) {
        if (error) {
          this.errors.push(error);
        }
        return null;
      };
      ValidatorContext.prototype.prefixErrors = function(startIndex, dataPath, schemaPath) {
        for (var i = startIndex; i < this.errors.length; i++) {
          this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
        }
        return this;
      };
      ValidatorContext.prototype.banUnknownProperties = function(data, schema) {
        for (var unknownPath in this.unknownPropertyPaths) {
          var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "", null, data, schema);
          var result = this.handleError(error);
          if (result) {
            return result;
          }
        }
        return null;
      };
      ValidatorContext.prototype.addFormat = function(format, validator) {
        if (typeof format === 'object') {
          for (var key in format) {
            this.addFormat(key, format[key]);
          }
          return this;
        }
        this.formatValidators[format] = validator;
      };
      ValidatorContext.prototype.resolveRefs = function(schema, urlHistory) {
        if (schema['$ref'] !== undefined) {
          urlHistory = urlHistory || {};
          if (urlHistory[schema['$ref']]) {
            return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);
          }
          urlHistory[schema['$ref']] = true;
          schema = this.getSchema(schema['$ref'], urlHistory);
        }
        return schema;
      };
      ValidatorContext.prototype.getSchema = function(url, urlHistory) {
        var schema;
        if (this.schemas[url] !== undefined) {
          schema = this.schemas[url];
          return this.resolveRefs(schema, urlHistory);
        }
        var baseUrl = url;
        var fragment = "";
        if (url.indexOf('#') !== -1) {
          fragment = url.substring(url.indexOf("#") + 1);
          baseUrl = url.substring(0, url.indexOf("#"));
        }
        if (typeof this.schemas[baseUrl] === 'object') {
          schema = this.schemas[baseUrl];
          var pointerPath = decodeURIComponent(fragment);
          if (pointerPath === "") {
            return this.resolveRefs(schema, urlHistory);
          } else if (pointerPath.charAt(0) !== "/") {
            return undefined;
          }
          var parts = pointerPath.split("/").slice(1);
          for (var i = 0; i < parts.length; i++) {
            var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
            if (schema[component] === undefined) {
              schema = undefined;
              break;
            }
            schema = schema[component];
          }
          if (schema !== undefined) {
            return this.resolveRefs(schema, urlHistory);
          }
        }
        if (this.missing[baseUrl] === undefined) {
          this.missing.push(baseUrl);
          this.missing[baseUrl] = baseUrl;
          this.missingMap[baseUrl] = baseUrl;
        }
      };
      ValidatorContext.prototype.searchSchemas = function(schema, url) {
        if (Array.isArray(schema)) {
          for (var i = 0; i < schema.length; i++) {
            this.searchSchemas(schema[i], url);
          }
        } else if (schema && typeof schema === "object") {
          if (typeof schema.id === "string") {
            if (isTrustedUrl(url, schema.id)) {
              if (this.schemas[schema.id] === undefined) {
                this.schemas[schema.id] = schema;
              }
            }
          }
          for (var key in schema) {
            if (key !== "enum") {
              if (typeof schema[key] === "object") {
                this.searchSchemas(schema[key], url);
              } else if (key === "$ref") {
                var uri = getDocumentUri(schema[key]);
                if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
                  this.missingMap[uri] = uri;
                }
              }
            }
          }
        }
      };
      ValidatorContext.prototype.addSchema = function(url, schema) {
        if (typeof url !== 'string' || typeof schema === 'undefined') {
          if (typeof url === 'object' && typeof url.id === 'string') {
            schema = url;
            url = schema.id;
          } else {
            return;
          }
        }
        if (url === getDocumentUri(url) + "#") {
          url = getDocumentUri(url);
        }
        this.schemas[url] = schema;
        delete this.missingMap[url];
        normSchema(schema, url);
        this.searchSchemas(schema, url);
      };
      ValidatorContext.prototype.getSchemaMap = function() {
        var map = {};
        for (var key in this.schemas) {
          map[key] = this.schemas[key];
        }
        return map;
      };
      ValidatorContext.prototype.getSchemaUris = function(filterRegExp) {
        var list = [];
        for (var key in this.schemas) {
          if (!filterRegExp || filterRegExp.test(key)) {
            list.push(key);
          }
        }
        return list;
      };
      ValidatorContext.prototype.getMissingUris = function(filterRegExp) {
        var list = [];
        for (var key in this.missingMap) {
          if (!filterRegExp || filterRegExp.test(key)) {
            list.push(key);
          }
        }
        return list;
      };
      ValidatorContext.prototype.dropSchemas = function() {
        this.schemas = {};
        this.reset();
      };
      ValidatorContext.prototype.reset = function() {
        this.missing = [];
        this.missingMap = {};
        this.errors = [];
      };
      ValidatorContext.prototype.validateAll = function(data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
        var topLevel;
        schema = this.resolveRefs(schema);
        if (!schema) {
          return null;
        } else if (schema instanceof ValidationError) {
          this.errors.push(schema);
          return schema;
        }
        var startErrorCount = this.errors.length;
        var frozenIndex,
            scannedFrozenSchemaIndex = null,
            scannedSchemasIndex = null;
        if (this.checkRecursive && data && typeof data === 'object') {
          topLevel = !this.scanned.length;
          if (data[this.validatedSchemasKey]) {
            var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
            if (schemaIndex !== -1) {
              this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
              return null;
            }
          }
          if (Object.isFrozen(data)) {
            frozenIndex = this.scannedFrozen.indexOf(data);
            if (frozenIndex !== -1) {
              var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
              if (frozenSchemaIndex !== -1) {
                this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
                return null;
              }
            }
          }
          this.scanned.push(data);
          if (Object.isFrozen(data)) {
            if (frozenIndex === -1) {
              frozenIndex = this.scannedFrozen.length;
              this.scannedFrozen.push(data);
              this.scannedFrozenSchemas.push([]);
            }
            scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
            this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
            this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
          } else {
            if (!data[this.validatedSchemasKey]) {
              try {
                Object.defineProperty(data, this.validatedSchemasKey, {
                  value: [],
                  configurable: true
                });
                Object.defineProperty(data, this.validationErrorsKey, {
                  value: [],
                  configurable: true
                });
              } catch (e) {
                data[this.validatedSchemasKey] = [];
                data[this.validationErrorsKey] = [];
              }
            }
            scannedSchemasIndex = data[this.validatedSchemasKey].length;
            data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
            data[this.validationErrorsKey][scannedSchemasIndex] = [];
          }
        }
        var errorCount = this.errors.length;
        var error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateHypermedia(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;
        if (topLevel) {
          while (this.scanned.length) {
            var item = this.scanned.pop();
            delete item[this.validatedSchemasKey];
          }
          this.scannedFrozen = [];
          this.scannedFrozenSchemas = [];
        }
        if (error || errorCount !== this.errors.length) {
          while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
            var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
            var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
            if (error) {
              error = error.prefixWith(dataPart, schemaPart);
            }
            this.prefixErrors(errorCount, dataPart, schemaPart);
          }
        }
        if (scannedFrozenSchemaIndex !== null) {
          this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
        } else if (scannedSchemasIndex !== null) {
          data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
        }
        return this.handleError(error);
      };
      ValidatorContext.prototype.validateFormat = function(data, schema) {
        if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
          return null;
        }
        var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
        if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
          return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);
        } else if (errorMessage && typeof errorMessage === 'object') {
          return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || '', errorMessage.schemaPath || "/format", null, data, schema);
        }
        return null;
      };
      ValidatorContext.prototype.validateDefinedKeywords = function(data, schema, dataPointerPath) {
        for (var key in this.definedKeywords) {
          if (typeof schema[key] === 'undefined') {
            continue;
          }
          var validationFunctions = this.definedKeywords[key];
          for (var i = 0; i < validationFunctions.length; i++) {
            var func = validationFunctions[i];
            var result = func(data, schema[key], schema, dataPointerPath);
            if (typeof result === 'string' || typeof result === 'number') {
              return this.createError(ErrorCodes.KEYWORD_CUSTOM, {
                key: key,
                message: result
              }, '', '', null, data, schema).prefixWith(null, key);
            } else if (result && typeof result === 'object') {
              var code = result.code;
              if (typeof code === 'string') {
                if (!ErrorCodes[code]) {
                  throw new Error('Undefined error code (use defineError): ' + code);
                }
                code = ErrorCodes[code];
              } else if (typeof code !== 'number') {
                code = ErrorCodes.KEYWORD_CUSTOM;
              }
              var messageParams = (typeof result.message === 'object') ? result.message : {
                key: key,
                message: result.message || "?"
              };
              var schemaPath = result.schemaPath || ("/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
              return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
            }
          }
        }
        return null;
      };
      function recursiveCompare(A, B) {
        if (A === B) {
          return true;
        }
        if (A && B && typeof A === "object" && typeof B === "object") {
          if (Array.isArray(A) !== Array.isArray(B)) {
            return false;
          } else if (Array.isArray(A)) {
            if (A.length !== B.length) {
              return false;
            }
            for (var i = 0; i < A.length; i++) {
              if (!recursiveCompare(A[i], B[i])) {
                return false;
              }
            }
          } else {
            var key;
            for (key in A) {
              if (B[key] === undefined && A[key] !== undefined) {
                return false;
              }
            }
            for (key in B) {
              if (A[key] === undefined && B[key] !== undefined) {
                return false;
              }
            }
            for (key in A) {
              if (!recursiveCompare(A[key], B[key])) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
        var error;
        if (error = this.validateType(data, schema, dataPointerPath)) {
          return error.prefixWith(null, "type");
        }
        if (error = this.validateEnum(data, schema, dataPointerPath)) {
          return error.prefixWith(null, "type");
        }
        return null;
      };
      ValidatorContext.prototype.validateType = function validateType(data, schema) {
        if (schema.type === undefined) {
          return null;
        }
        var dataType = typeof data;
        if (data === null) {
          dataType = "null";
        } else if (Array.isArray(data)) {
          dataType = "array";
        }
        var allowedTypes = schema.type;
        if (!Array.isArray(allowedTypes)) {
          allowedTypes = [allowedTypes];
        }
        for (var i = 0; i < allowedTypes.length; i++) {
          var type = allowedTypes[i];
          if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
            return null;
          }
        }
        return this.createError(ErrorCodes.INVALID_TYPE, {
          type: dataType,
          expected: allowedTypes.join("/")
        }, '', '', null, data, schema);
      };
      ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
        if (schema["enum"] === undefined) {
          return null;
        }
        for (var i = 0; i < schema["enum"].length; i++) {
          var enumVal = schema["enum"][i];
          if (recursiveCompare(data, enumVal)) {
            return null;
          }
        }
        return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);
      };
      ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
        return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || this.validateNaN(data, schema, dataPointerPath) || null;
      };
      var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
      var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
      ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
        var multipleOf = schema.multipleOf || schema.divisibleBy;
        if (multipleOf === undefined) {
          return null;
        }
        if (typeof data === "number") {
          var remainder = (data / multipleOf) % 1;
          if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
            return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {
              value: data,
              multipleOf: multipleOf
            }, '', '', null, data, schema);
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
        if (typeof data !== "number") {
          return null;
        }
        if (schema.minimum !== undefined) {
          if (data < schema.minimum) {
            return this.createError(ErrorCodes.NUMBER_MINIMUM, {
              value: data,
              minimum: schema.minimum
            }, '', '/minimum', null, data, schema);
          }
          if (schema.exclusiveMinimum && data === schema.minimum) {
            return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {
              value: data,
              minimum: schema.minimum
            }, '', '/exclusiveMinimum', null, data, schema);
          }
        }
        if (schema.maximum !== undefined) {
          if (data > schema.maximum) {
            return this.createError(ErrorCodes.NUMBER_MAXIMUM, {
              value: data,
              maximum: schema.maximum
            }, '', '/maximum', null, data, schema);
          }
          if (schema.exclusiveMaximum && data === schema.maximum) {
            return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {
              value: data,
              maximum: schema.maximum
            }, '', '/exclusiveMaximum', null, data, schema);
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
        if (typeof data !== "number") {
          return null;
        }
        if (isNaN(data) === true || data === Infinity || data === -Infinity) {
          return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);
        }
        return null;
      };
      ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
        return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;
      };
      ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
        if (typeof data !== "string") {
          return null;
        }
        if (schema.minLength !== undefined) {
          if (data.length < schema.minLength) {
            return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {
              length: data.length,
              minimum: schema.minLength
            }, '', '/minLength', null, data, schema);
          }
        }
        if (schema.maxLength !== undefined) {
          if (data.length > schema.maxLength) {
            return this.createError(ErrorCodes.STRING_LENGTH_LONG, {
              length: data.length,
              maximum: schema.maxLength
            }, '', '/maxLength', null, data, schema);
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
        if (typeof data !== "string" || (typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp))) {
          return null;
        }
        var regexp;
        if (schema.pattern instanceof RegExp) {
          regexp = schema.pattern;
        } else {
          var body,
              flags = '';
          var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
          if (literal) {
            body = literal[1];
            flags = literal[2];
          } else {
            body = schema.pattern;
          }
          regexp = new RegExp(body, flags);
        }
        if (!regexp.test(data)) {
          return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);
        }
        return null;
      };
      ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
        if (!Array.isArray(data)) {
          return null;
        }
        return this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null;
      };
      ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
        var error;
        if (schema.minItems !== undefined) {
          if (data.length < schema.minItems) {
            error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {
              length: data.length,
              minimum: schema.minItems
            }, '', '/minItems', null, data, schema);
            if (this.handleError(error)) {
              return error;
            }
          }
        }
        if (schema.maxItems !== undefined) {
          if (data.length > schema.maxItems) {
            error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {
              length: data.length,
              maximum: schema.maxItems
            }, '', '/maxItems', null, data, schema);
            if (this.handleError(error)) {
              return error;
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
        if (schema.uniqueItems) {
          for (var i = 0; i < data.length; i++) {
            for (var j = i + 1; j < data.length; j++) {
              if (recursiveCompare(data[i], data[j])) {
                var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {
                  match1: i,
                  match2: j
                }, '', '/uniqueItems', null, data, schema);
                if (this.handleError(error)) {
                  return error;
                }
              }
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
        if (schema.items === undefined) {
          return null;
        }
        var error,
            i;
        if (Array.isArray(schema.items)) {
          for (i = 0; i < data.length; i++) {
            if (i < schema.items.length) {
              if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
                return error;
              }
            } else if (schema.additionalItems !== undefined) {
              if (typeof schema.additionalItems === "boolean") {
                if (!schema.additionalItems) {
                  error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));
                  if (this.handleError(error)) {
                    return error;
                  }
                }
              } else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
                return error;
              }
            }
          }
        } else {
          for (i = 0; i < data.length; i++) {
            if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
              return error;
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
        if (typeof data !== "object" || data === null || Array.isArray(data)) {
          return null;
        }
        return this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;
      };
      ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
        var keys = Object.keys(data);
        var error;
        if (schema.minProperties !== undefined) {
          if (keys.length < schema.minProperties) {
            error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {
              propertyCount: keys.length,
              minimum: schema.minProperties
            }, '', '/minProperties', null, data, schema);
            if (this.handleError(error)) {
              return error;
            }
          }
        }
        if (schema.maxProperties !== undefined) {
          if (keys.length > schema.maxProperties) {
            error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {
              propertyCount: keys.length,
              maximum: schema.maxProperties
            }, '', '/maxProperties', null, data, schema);
            if (this.handleError(error)) {
              return error;
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
        if (schema.required !== undefined) {
          for (var i = 0; i < schema.required.length; i++) {
            var key = schema.required[i];
            if (data[key] === undefined) {
              var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);
              if (this.handleError(error)) {
                return error;
              }
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
        var error;
        for (var key in data) {
          var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
          var foundMatch = false;
          if (schema.properties !== undefined && schema.properties[key] !== undefined) {
            foundMatch = true;
            if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
              return error;
            }
          }
          if (schema.patternProperties !== undefined) {
            for (var patternKey in schema.patternProperties) {
              var regexp = new RegExp(patternKey);
              if (regexp.test(key)) {
                foundMatch = true;
                if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
                  return error;
                }
              }
            }
          }
          if (!foundMatch) {
            if (schema.additionalProperties !== undefined) {
              if (this.trackUnknownProperties) {
                this.knownPropertyPaths[keyPointerPath] = true;
                delete this.unknownPropertyPaths[keyPointerPath];
              }
              if (typeof schema.additionalProperties === "boolean") {
                if (!schema.additionalProperties) {
                  error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);
                  if (this.handleError(error)) {
                    return error;
                  }
                }
              } else {
                if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
                  return error;
                }
              }
            } else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
              this.unknownPropertyPaths[keyPointerPath] = true;
            }
          } else if (this.trackUnknownProperties) {
            this.knownPropertyPaths[keyPointerPath] = true;
            delete this.unknownPropertyPaths[keyPointerPath];
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
        var error;
        if (schema.dependencies !== undefined) {
          for (var depKey in schema.dependencies) {
            if (data[depKey] !== undefined) {
              var dep = schema.dependencies[depKey];
              if (typeof dep === "string") {
                if (data[dep] === undefined) {
                  error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {
                    key: depKey,
                    missing: dep
                  }, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
                  if (this.handleError(error)) {
                    return error;
                  }
                }
              } else if (Array.isArray(dep)) {
                for (var i = 0; i < dep.length; i++) {
                  var requiredKey = dep[i];
                  if (data[requiredKey] === undefined) {
                    error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {
                      key: depKey,
                      missing: requiredKey
                    }, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
                    if (this.handleError(error)) {
                      return error;
                    }
                  }
                }
              } else {
                if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
                  return error;
                }
              }
            }
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
        return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;
      };
      ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
        if (schema.allOf === undefined) {
          return null;
        }
        var error;
        for (var i = 0; i < schema.allOf.length; i++) {
          var subSchema = schema.allOf[i];
          if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
            return error;
          }
        }
        return null;
      };
      ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
        if (schema.anyOf === undefined) {
          return null;
        }
        var errors = [];
        var startErrorCount = this.errors.length;
        var oldUnknownPropertyPaths,
            oldKnownPropertyPaths;
        if (this.trackUnknownProperties) {
          oldUnknownPropertyPaths = this.unknownPropertyPaths;
          oldKnownPropertyPaths = this.knownPropertyPaths;
        }
        var errorAtEnd = true;
        for (var i = 0; i < schema.anyOf.length; i++) {
          if (this.trackUnknownProperties) {
            this.unknownPropertyPaths = {};
            this.knownPropertyPaths = {};
          }
          var subSchema = schema.anyOf[i];
          var errorCount = this.errors.length;
          var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);
          if (error === null && errorCount === this.errors.length) {
            this.errors = this.errors.slice(0, startErrorCount);
            if (this.trackUnknownProperties) {
              for (var knownKey in this.knownPropertyPaths) {
                oldKnownPropertyPaths[knownKey] = true;
                delete oldUnknownPropertyPaths[knownKey];
              }
              for (var unknownKey in this.unknownPropertyPaths) {
                if (!oldKnownPropertyPaths[unknownKey]) {
                  oldUnknownPropertyPaths[unknownKey] = true;
                }
              }
              errorAtEnd = false;
              continue;
            }
            return null;
          }
          if (error) {
            errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
          }
        }
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = oldUnknownPropertyPaths;
          this.knownPropertyPaths = oldKnownPropertyPaths;
        }
        if (errorAtEnd) {
          errors = errors.concat(this.errors.slice(startErrorCount));
          this.errors = this.errors.slice(0, startErrorCount);
          return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
        }
      };
      ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
        if (schema.oneOf === undefined) {
          return null;
        }
        var validIndex = null;
        var errors = [];
        var startErrorCount = this.errors.length;
        var oldUnknownPropertyPaths,
            oldKnownPropertyPaths;
        if (this.trackUnknownProperties) {
          oldUnknownPropertyPaths = this.unknownPropertyPaths;
          oldKnownPropertyPaths = this.knownPropertyPaths;
        }
        for (var i = 0; i < schema.oneOf.length; i++) {
          if (this.trackUnknownProperties) {
            this.unknownPropertyPaths = {};
            this.knownPropertyPaths = {};
          }
          var subSchema = schema.oneOf[i];
          var errorCount = this.errors.length;
          var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);
          if (error === null && errorCount === this.errors.length) {
            if (validIndex === null) {
              validIndex = i;
            } else {
              this.errors = this.errors.slice(0, startErrorCount);
              return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {
                index1: validIndex,
                index2: i
              }, "", "/oneOf", null, data, schema);
            }
            if (this.trackUnknownProperties) {
              for (var knownKey in this.knownPropertyPaths) {
                oldKnownPropertyPaths[knownKey] = true;
                delete oldUnknownPropertyPaths[knownKey];
              }
              for (var unknownKey in this.unknownPropertyPaths) {
                if (!oldKnownPropertyPaths[unknownKey]) {
                  oldUnknownPropertyPaths[unknownKey] = true;
                }
              }
            }
          } else if (error) {
            errors.push(error);
          }
        }
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = oldUnknownPropertyPaths;
          this.knownPropertyPaths = oldKnownPropertyPaths;
        }
        if (validIndex === null) {
          errors = errors.concat(this.errors.slice(startErrorCount));
          this.errors = this.errors.slice(0, startErrorCount);
          return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
        } else {
          this.errors = this.errors.slice(0, startErrorCount);
        }
        return null;
      };
      ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
        if (schema.not === undefined) {
          return null;
        }
        var oldErrorCount = this.errors.length;
        var oldUnknownPropertyPaths,
            oldKnownPropertyPaths;
        if (this.trackUnknownProperties) {
          oldUnknownPropertyPaths = this.unknownPropertyPaths;
          oldKnownPropertyPaths = this.knownPropertyPaths;
          this.unknownPropertyPaths = {};
          this.knownPropertyPaths = {};
        }
        var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
        var notErrors = this.errors.slice(oldErrorCount);
        this.errors = this.errors.slice(0, oldErrorCount);
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = oldUnknownPropertyPaths;
          this.knownPropertyPaths = oldKnownPropertyPaths;
        }
        if (error === null && notErrors.length === 0) {
          return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
        }
        return null;
      };
      ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
        if (!schema.links) {
          return null;
        }
        var error;
        for (var i = 0; i < schema.links.length; i++) {
          var ldo = schema.links[i];
          if (ldo.rel === "describedby") {
            var template = new UriTemplate(ldo.href);
            var allPresent = true;
            for (var j = 0; j < template.varNames.length; j++) {
              if (!(template.varNames[j] in data)) {
                allPresent = false;
                break;
              }
            }
            if (allPresent) {
              var schemaUrl = template.fillFromObject(data);
              var subSchema = {"$ref": schemaUrl};
              if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
                return error;
              }
            }
          }
        }
      };
      function parseURI(url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return (m ? {
          href: m[0] || '',
          protocol: m[1] || '',
          authority: m[2] || '',
          host: m[3] || '',
          hostname: m[4] || '',
          port: m[5] || '',
          pathname: m[6] || '',
          search: m[7] || '',
          hash: m[8] || ''
        } : null);
      }
      function resolveUrl(base, href) {
        function removeDotSegments(input) {
          var output = [];
          input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function(p) {
            if (p === '/..') {
              output.pop();
            } else {
              output.push(p);
            }
          });
          return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) + (href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) + href.hash;
      }
      function getDocumentUri(uri) {
        return uri.split('#')[0];
      }
      function normSchema(schema, baseUri) {
        if (schema && typeof schema === "object") {
          if (baseUri === undefined) {
            baseUri = schema.id;
          } else if (typeof schema.id === "string") {
            baseUri = resolveUrl(baseUri, schema.id);
            schema.id = baseUri;
          }
          if (Array.isArray(schema)) {
            for (var i = 0; i < schema.length; i++) {
              normSchema(schema[i], baseUri);
            }
          } else {
            if (typeof schema['$ref'] === "string") {
              schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
            }
            for (var key in schema) {
              if (key !== "enum") {
                normSchema(schema[key], baseUri);
              }
            }
          }
        }
      }
      function defaultErrorReporter(language) {
        language = language || 'en';
        var errorMessages = languages[language];
        return function(error) {
          var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
          if (typeof messageTemplate !== 'string') {
            return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
          }
          var messageParams = error.params;
          return messageTemplate.replace(/\{([^{}]*)\}/g, function(whole, varName) {
            var subValue = messageParams[varName];
            return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
          });
        };
      }
      var ErrorCodes = {
        INVALID_TYPE: 0,
        ENUM_MISMATCH: 1,
        ANY_OF_MISSING: 10,
        ONE_OF_MISSING: 11,
        ONE_OF_MULTIPLE: 12,
        NOT_PASSED: 13,
        NUMBER_MULTIPLE_OF: 100,
        NUMBER_MINIMUM: 101,
        NUMBER_MINIMUM_EXCLUSIVE: 102,
        NUMBER_MAXIMUM: 103,
        NUMBER_MAXIMUM_EXCLUSIVE: 104,
        NUMBER_NOT_A_NUMBER: 105,
        STRING_LENGTH_SHORT: 200,
        STRING_LENGTH_LONG: 201,
        STRING_PATTERN: 202,
        OBJECT_PROPERTIES_MINIMUM: 300,
        OBJECT_PROPERTIES_MAXIMUM: 301,
        OBJECT_REQUIRED: 302,
        OBJECT_ADDITIONAL_PROPERTIES: 303,
        OBJECT_DEPENDENCY_KEY: 304,
        ARRAY_LENGTH_SHORT: 400,
        ARRAY_LENGTH_LONG: 401,
        ARRAY_UNIQUE: 402,
        ARRAY_ADDITIONAL_ITEMS: 403,
        FORMAT_CUSTOM: 500,
        KEYWORD_CUSTOM: 501,
        CIRCULAR_REFERENCE: 600,
        UNKNOWN_PROPERTY: 1000
      };
      var ErrorCodeLookup = {};
      for (var key in ErrorCodes) {
        ErrorCodeLookup[ErrorCodes[key]] = key;
      }
      var ErrorMessagesDefault = {
        INVALID_TYPE: "Invalid type: {type} (expected {expected})",
        ENUM_MISMATCH: "No enum match for: {value}",
        ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
        ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
        ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
        NOT_PASSED: "Data matches schema from \"not\"",
        NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
        NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
        NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
        NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
        NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
        NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
        STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
        STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
        STRING_PATTERN: "String does not match pattern: {pattern}",
        OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
        OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
        OBJECT_REQUIRED: "Missing required property: {key}",
        OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
        OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
        ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
        ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
        ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
        ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
        FORMAT_CUSTOM: "Format validation failed ({message})",
        KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
        CIRCULAR_REFERENCE: "Circular $refs: {urls}",
        UNKNOWN_PROPERTY: "Unknown property (not in schema)"
      };
      function ValidationError(code, params, dataPath, schemaPath, subErrors) {
        Error.call(this);
        if (code === undefined) {
          throw new Error("No error code supplied: " + schemaPath);
        }
        this.message = '';
        this.params = params;
        this.code = code;
        this.dataPath = dataPath || "";
        this.schemaPath = schemaPath || "";
        this.subErrors = subErrors || null;
        var err = new Error(this.message);
        this.stack = err.stack || err.stacktrace;
        if (!this.stack) {
          try {
            throw err;
          } catch (err) {
            this.stack = err.stack || err.stacktrace;
          }
        }
      }
      ValidationError.prototype = Object.create(Error.prototype);
      ValidationError.prototype.constructor = ValidationError;
      ValidationError.prototype.name = 'ValidationError';
      ValidationError.prototype.prefixWith = function(dataPrefix, schemaPrefix) {
        if (dataPrefix !== null) {
          dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
          this.dataPath = "/" + dataPrefix + this.dataPath;
        }
        if (schemaPrefix !== null) {
          schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
          this.schemaPath = "/" + schemaPrefix + this.schemaPath;
        }
        if (this.subErrors !== null) {
          for (var i = 0; i < this.subErrors.length; i++) {
            this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
          }
        }
        return this;
      };
      function isTrustedUrl(baseUrl, testUrl) {
        if (testUrl.substring(0, baseUrl.length) === baseUrl) {
          var remainder = testUrl.substring(baseUrl.length);
          if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/") || remainder.charAt(0) === "#" || remainder.charAt(0) === "?") {
            return true;
          }
        }
        return false;
      }
      var languages = {};
      function createApi(language) {
        var globalContext = new ValidatorContext();
        var currentLanguage;
        var customErrorReporter;
        var api = {
          setErrorReporter: function(reporter) {
            if (typeof reporter === 'string') {
              return this.language(reporter);
            }
            customErrorReporter = reporter;
            return true;
          },
          addFormat: function() {
            globalContext.addFormat.apply(globalContext, arguments);
          },
          language: function(code) {
            if (!code) {
              return currentLanguage;
            }
            if (!languages[code]) {
              code = code.split('-')[0];
            }
            if (languages[code]) {
              currentLanguage = code;
              return code;
            }
            return false;
          },
          addLanguage: function(code, messageMap) {
            var key;
            for (key in ErrorCodes) {
              if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
                messageMap[ErrorCodes[key]] = messageMap[key];
              }
            }
            var rootCode = code.split('-')[0];
            if (!languages[rootCode]) {
              languages[code] = messageMap;
              languages[rootCode] = messageMap;
            } else {
              languages[code] = Object.create(languages[rootCode]);
              for (key in messageMap) {
                if (typeof languages[rootCode][key] === 'undefined') {
                  languages[rootCode][key] = messageMap[key];
                }
                languages[code][key] = messageMap[key];
              }
            }
            return this;
          },
          freshApi: function(language) {
            var result = createApi();
            if (language) {
              result.language(language);
            }
            return result;
          },
          validate: function(data, schema, checkRecursive, banUnknownProperties) {
            var def = defaultErrorReporter(currentLanguage);
            var errorReporter = customErrorReporter ? function(error, data, schema) {
              return customErrorReporter(error, data, schema) || def(error, data, schema);
            } : def;
            var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
            if (typeof schema === "string") {
              schema = {"$ref": schema};
            }
            context.addSchema("", schema);
            var error = context.validateAll(data, schema, null, null, "");
            if (!error && banUnknownProperties) {
              error = context.banUnknownProperties(data, schema);
            }
            this.error = error;
            this.missing = context.missing;
            this.valid = (error === null);
            return this.valid;
          },
          validateResult: function() {
            var result = {};
            this.validate.apply(result, arguments);
            return result;
          },
          validateMultiple: function(data, schema, checkRecursive, banUnknownProperties) {
            var def = defaultErrorReporter(currentLanguage);
            var errorReporter = customErrorReporter ? function(error, data, schema) {
              return customErrorReporter(error, data, schema) || def(error, data, schema);
            } : def;
            var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
            if (typeof schema === "string") {
              schema = {"$ref": schema};
            }
            context.addSchema("", schema);
            context.validateAll(data, schema, null, null, "");
            if (banUnknownProperties) {
              context.banUnknownProperties(data, schema);
            }
            var result = {};
            result.errors = context.errors;
            result.missing = context.missing;
            result.valid = (result.errors.length === 0);
            return result;
          },
          addSchema: function() {
            return globalContext.addSchema.apply(globalContext, arguments);
          },
          getSchema: function() {
            return globalContext.getSchema.apply(globalContext, arguments);
          },
          getSchemaMap: function() {
            return globalContext.getSchemaMap.apply(globalContext, arguments);
          },
          getSchemaUris: function() {
            return globalContext.getSchemaUris.apply(globalContext, arguments);
          },
          getMissingUris: function() {
            return globalContext.getMissingUris.apply(globalContext, arguments);
          },
          dropSchemas: function() {
            globalContext.dropSchemas.apply(globalContext, arguments);
          },
          defineKeyword: function() {
            globalContext.defineKeyword.apply(globalContext, arguments);
          },
          defineError: function(codeName, codeNumber, defaultMessage) {
            if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
              throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
            }
            if (typeof codeNumber !== 'number' || codeNumber % 1 !== 0 || codeNumber < 10000) {
              throw new Error('Code number must be an integer > 10000');
            }
            if (typeof ErrorCodes[codeName] !== 'undefined') {
              throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
            }
            if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
              throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
            }
            ErrorCodes[codeName] = codeNumber;
            ErrorCodeLookup[codeNumber] = codeName;
            ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
            for (var langCode in languages) {
              var language = languages[langCode];
              if (language[codeName]) {
                language[codeNumber] = language[codeNumber] || language[codeName];
              }
            }
          },
          reset: function() {
            globalContext.reset();
            this.error = null;
            this.missing = [];
            this.valid = true;
          },
          missing: [],
          error: null,
          valid: true,
          normSchema: normSchema,
          resolveUrl: resolveUrl,
          getDocumentUri: getDocumentUri,
          errorCodes: ErrorCodes
        };
        api.language(language || 'en');
        return api;
      }
      var tv4 = createApi();
      tv4.addLanguage('en-gb', ErrorMessagesDefault);
      tv4.tv4 = tv4;
      return tv4;
    }));
    var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    Math.uuid = function(len, radix) {
      var chars = CHARS,
          uuid = [],
          i;
      radix = radix || chars.length;
      if (len) {
        for (i = 0; i < len; i++)
          uuid[i] = chars[0 | Math.random() * radix];
      } else {
        var r;
        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
        uuid[14] = '4';
        for (i = 0; i < 36; i++) {
          if (!uuid[i]) {
            r = 0 | Math.random() * 16;
            uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
          }
        }
      }
      return uuid.join('');
    };
    (function(global) {
      function deprecate(thing, replacement) {
        console.log('WARNING: ' + thing + ' is deprecated. Use ' + replacement + ' instead.');
      }
      var RS = RemoteStorage;
      RS.BaseClient = function(storage, base) {
        if (base[base.length - 1] !== '/') {
          throw "Not a folder: " + base;
        }
        if (base === '/') {
          this.makePath = function(path) {
            return (path[0] === '/' ? '' : '/') + path;
          };
        }
        this.storage = storage;
        this.base = base;
        var parts = this.base.split('/');
        if (parts.length > 2) {
          this.moduleName = parts[1];
        } else {
          this.moduleName = 'root';
        }
        RS.eventHandling(this, 'change');
        this.on = this.on.bind(this);
        storage.onChange(this.base, this._fireChange.bind(this));
      };
      RS.BaseClient.prototype = {
        extend: function(object) {
          for (var key in object) {
            this[key] = object[key];
          }
          return this;
        },
        scope: function(path) {
          return new RS.BaseClient(this.storage, this.makePath(path));
        },
        getListing: function(path, maxAge) {
          if (typeof(path) !== 'string') {
            path = '';
          } else if (path.length > 0 && path[path.length - 1] !== '/') {
            Promise.reject("Not a folder: " + path);
          }
          return this.storage.get(this.makePath(path), maxAge).then(function(r) {
            return (r.statusCode === 404) ? {} : r.body;
          });
        },
        getAll: function(path, maxAge) {
          if (typeof(path) !== 'string') {
            path = '';
          } else if (path.length > 0 && path[path.length - 1] !== '/') {
            return Promise.reject("Not a folder: " + path);
          }
          return this.storage.get(this.makePath(path), maxAge).then(function(r) {
            if (r.statusCode === 404) {
              return {};
            }
            if (typeof(r.body) === 'object') {
              var keys = Object.keys(r.body);
              if (keys.length === 0) {
                return {};
              }
              var calls = keys.map(function(key) {
                return this.storage.get(this.makePath(path + key), maxAge).then(function(o) {
                  if (typeof(o.body) === 'string') {
                    try {
                      o.body = JSON.parse(o.body);
                    } catch (e) {}
                  }
                  if (typeof(o.body) === 'object') {
                    r.body[key] = o.body;
                  }
                });
              }.bind(this));
              return Promise.all(calls).then(function() {
                return r.body;
              });
            }
          }.bind(this));
        },
        getFile: function(path, maxAge) {
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.getFile must be a string');
          }
          return this.storage.get(this.makePath(path), maxAge).then(function(r) {
            return {
              data: r.body,
              contentType: r.contentType,
              revision: r.revision
            };
          });
        },
        storeFile: function(mimeType, path, body) {
          if (typeof(mimeType) !== 'string') {
            return Promise.reject('Argument \'mimeType\' of baseClient.storeFile must be a string');
          }
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.storeFile must be a string');
          }
          if (typeof(body) !== 'string' && typeof(body) !== 'object') {
            return Promise.reject('Argument \'body\' of baseClient.storeFile must be a string, ArrayBuffer, or ArrayBufferView');
          }
          if (!this.storage.access.checkPathPermission(this.makePath(path), 'rw')) {
            console.warn('WARNING: Editing a document to which only read access (\'r\') was claimed');
          }
          return this.storage.put(this.makePath(path), body, mimeType).then(function(r) {
            if (r.statusCode === 200 || r.statusCode === 201) {
              return r.revision;
            } else {
              return Promise.reject("Request (PUT " + this.makePath(path) + ") failed with status: " + r.statusCode);
            }
          }.bind(this));
        },
        getObject: function(path, maxAge) {
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.getObject must be a string');
          }
          return this.storage.get(this.makePath(path), maxAge).then(function(r) {
            if (typeof(r.body) === 'object') {
              return r.body;
            } else if (typeof(r.body) === 'string') {
              try {
                return JSON.parse(r.body);
              } catch (e) {
                throw "Not valid JSON: " + this.makePath(path);
              }
            } else if (typeof(r.body) !== 'undefined' && r.statusCode === 200) {
              return Promise.reject("Not an object: " + this.makePath(path));
            }
          }.bind(this));
        },
        storeObject: function(typeAlias, path, object) {
          if (typeof(typeAlias) !== 'string') {
            return Promise.reject('Argument \'typeAlias\' of baseClient.storeObject must be a string');
          }
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.storeObject must be a string');
          }
          if (typeof(object) !== 'object') {
            return Promise.reject('Argument \'object\' of baseClient.storeObject must be an object');
          }
          this._attachType(object, typeAlias);
          try {
            var validationResult = this.validate(object);
            if (!validationResult.valid) {
              return Promise.reject(validationResult);
            }
          } catch (exc) {
            return Promise.reject(exc);
          }
          return this.storage.put(this.makePath(path), JSON.stringify(object), 'application/json; charset=UTF-8').then(function(r) {
            if (r.statusCode === 200 || r.statusCode === 201) {
              return r.revision;
            } else {
              return Promise.reject("Request (PUT " + this.makePath(path) + ") failed with status: " + r.statusCode);
            }
          }.bind(this));
        },
        remove: function(path) {
          if (typeof(path) !== 'string') {
            return Promise.reject('Argument \'path\' of baseClient.remove must be a string');
          }
          if (!this.storage.access.checkPathPermission(this.makePath(path), 'rw')) {
            console.warn('WARNING: Removing a document to which only read access (\'r\') was claimed');
          }
          return this.storage.delete(this.makePath(path));
        },
        cache: function(path, strategy) {
          if (typeof(path) !== 'string') {
            throw 'Argument \'path\' of baseClient.cache must be a string';
          }
          if (strategy === false) {
            deprecate('caching strategy <false>', '<"FLUSH">');
            strategy = 'FLUSH';
          } else if (strategy === undefined) {
            strategy = 'ALL';
          } else if (typeof(strategy) !== 'string') {
            deprecate('that caching strategy', '<"ALL">');
            strategy = 'ALL';
          }
          if (strategy !== 'FLUSH' && strategy !== 'SEEN' && strategy !== 'ALL') {
            throw 'Argument \'strategy\' of baseclient.cache must be one of ' + '["FLUSH", "SEEN", "ALL"]';
          }
          this.storage.caching.set(this.makePath(path), strategy);
          return this;
        },
        flush: function(path) {
          return this.storage.local.flush(path);
        },
        makePath: function(path) {
          return this.base + (path || '');
        },
        _fireChange: function(event) {
          if (RemoteStorage.config.changeEvents[event.origin]) {
            ['new', 'old', 'lastCommon'].forEach(function(fieldNamePrefix) {
              if ((!event[fieldNamePrefix + 'ContentType']) || (/^application\/(.*)json(.*)/.exec(event[fieldNamePrefix + 'ContentType']))) {
                if (typeof(event[fieldNamePrefix + 'Value']) === 'string') {
                  try {
                    event[fieldNamePrefix + 'Value'] = JSON.parse(event[fieldNamePrefix + 'Value']);
                  } catch (e) {}
                }
              }
            });
            this._emit('change', event);
          }
        },
        _cleanPath: RemoteStorage.util.cleanPath,
        getItemURL: function(path) {
          if (typeof(path) !== 'string') {
            throw 'Argument \'path\' of baseClient.getItemURL must be a string';
          }
          if (this.storage.connected) {
            path = this._cleanPath(this.makePath(path));
            return this.storage.remote.href + path;
          } else {
            return undefined;
          }
        },
        uuid: function() {
          return Math.uuid();
        }
      };
      RS.BaseClient._rs_init = function() {
        RS.prototype.scope = function(path) {
          if (typeof(path) !== 'string') {
            throw 'Argument \'path\' of baseClient.scope must be a string';
          }
          if (!this.access.checkPathPermission(path, 'r')) {
            var escapedPath = path.replace(/(['\\])/g, '\\$1');
            console.warn('WARNING: please call remoteStorage.access.claim(\'' + escapedPath + '\', \'r\') (read only) or remoteStorage.access.claim(\'' + escapedPath + '\', \'rw\') (read/write) first');
          }
          return new RS.BaseClient(this, path);
        };
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      RemoteStorage.BaseClient.Types = {
        uris: {},
        schemas: {},
        aliases: {},
        declare: function(moduleName, alias, uri, schema) {
          var fullAlias = moduleName + '/' + alias;
          if (schema.extends) {
            var extendedAlias;
            var parts = schema.extends.split('/');
            if (parts.length === 1) {
              extendedAlias = moduleName + '/' + parts.shift();
            } else {
              extendedAlias = parts.join('/');
            }
            var extendedUri = this.uris[extendedAlias];
            if (!extendedUri) {
              throw "Type '" + fullAlias + "' tries to extend unknown schema '" + extendedAlias + "'";
            }
            schema.extends = this.schemas[extendedUri];
          }
          this.uris[fullAlias] = uri;
          this.aliases[uri] = fullAlias;
          this.schemas[uri] = schema;
        },
        resolveAlias: function(alias) {
          return this.uris[alias];
        },
        getSchema: function(uri) {
          return this.schemas[uri];
        },
        inScope: function(moduleName) {
          var ml = moduleName.length;
          var schemas = {};
          for (var alias in this.uris) {
            if (alias.substr(0, ml + 1) === moduleName + '/') {
              var uri = this.uris[alias];
              schemas[uri] = this.schemas[uri];
            }
          }
          return schemas;
        }
      };
      var SchemaNotFound = function(uri) {
        var error = new Error("Schema not found: " + uri);
        error.name = "SchemaNotFound";
        return error;
      };
      SchemaNotFound.prototype = Error.prototype;
      RemoteStorage.BaseClient.Types.SchemaNotFound = SchemaNotFound;
      RemoteStorage.BaseClient.prototype.extend({
        declareType: function(alias, uri, schema) {
          if (!schema) {
            schema = uri;
            uri = this._defaultTypeURI(alias);
          }
          RemoteStorage.BaseClient.Types.declare(this.moduleName, alias, uri, schema);
        },
        validate: function(object) {
          var schema = RemoteStorage.BaseClient.Types.getSchema(object['@context']);
          if (schema) {
            return tv4.validateResult(object, schema);
          } else {
            throw new SchemaNotFound(object['@context']);
          }
        },
        _defaultTypeURI: function(alias) {
          return 'http://remotestorage.io/spec/modules/' + encodeURIComponent(this.moduleName) + '/' + encodeURIComponent(alias);
        },
        _attachType: function(object, alias) {
          object['@context'] = RemoteStorage.BaseClient.Types.resolveAlias(this.moduleName + '/' + alias) || this._defaultTypeURI(alias);
        }
      });
      Object.defineProperty(RemoteStorage.BaseClient.prototype, 'schemas', {
        configurable: true,
        get: function() {
          return RemoteStorage.BaseClient.Types.inScope(this.moduleName);
        }
      });
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var SETTINGS_KEY = "remotestorage:caching";
      var containingFolder = RemoteStorage.util.containingFolder;
      RemoteStorage.Caching = function() {
        this.reset();
      };
      RemoteStorage.Caching.prototype = {
        pendingActivations: [],
        set: function(path, strategy) {
          if (typeof path !== 'string') {
            throw new Error('path should be a string');
          }
          if (!RemoteStorage.util.isFolder(path)) {
            throw new Error('path should be a folder');
          }
          if (this._remoteStorage && this._remoteStorage.access && !this._remoteStorage.access.checkPathPermission(path, 'r')) {
            throw new Error('No access to path "' + path + '". You have to claim access to it first.');
          }
          if (!strategy.match(/^(FLUSH|SEEN|ALL)$/)) {
            throw new Error("strategy should be 'FLUSH', 'SEEN', or 'ALL'");
          }
          this._rootPaths[path] = strategy;
          if (strategy === 'ALL') {
            if (this.activateHandler) {
              this.activateHandler(path);
            } else {
              this.pendingActivations.push(path);
            }
          }
        },
        enable: function(path) {
          this.set(path, 'ALL');
        },
        disable: function(path) {
          this.set(path, 'FLUSH');
        },
        onActivate: function(cb) {
          var i;
          RemoteStorage.log('[Caching] Setting activate handler', cb, this.pendingActivations);
          this.activateHandler = cb;
          for (i = 0; i < this.pendingActivations.length; i++) {
            cb(this.pendingActivations[i]);
          }
          delete this.pendingActivations;
        },
        checkPath: function(path) {
          if (this._rootPaths[path] !== undefined) {
            return this._rootPaths[path];
          } else if (path === '/') {
            return 'SEEN';
          } else {
            return this.checkPath(containingFolder(path));
          }
        },
        reset: function() {
          this._rootPaths = {};
          this._remoteStorage = null;
        }
      };
      Object.defineProperty(RemoteStorage.prototype, 'caching', {
        configurable: true,
        get: function() {
          var caching = new RemoteStorage.Caching();
          Object.defineProperty(this, 'caching', {value: caching});
          return caching;
        }
      });
      RemoteStorage.Caching._rs_init = function(remoteStorage) {
        this._remoteStorage = remoteStorage;
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var syncInterval = 10000,
          backgroundSyncInterval = 60000,
          isBackground = false;
      var isFolder = RemoteStorage.util.isFolder;
      var isDocument = RemoteStorage.util.isDocument;
      var equal = RemoteStorage.util.equal;
      var deepClone = RemoteStorage.util.deepClone;
      var pathsFromRoot = RemoteStorage.util.pathsFromRoot;
      function taskFor(action, path, promise) {
        return {
          action: action,
          path: path,
          promise: promise
        };
      }
      function isStaleChild(node) {
        return node.remote && node.remote.revision && !node.remote.itemsMap && !node.remote.body;
      }
      function hasCommonRevision(node) {
        return node.common && node.common.revision;
      }
      function handleVisibility() {
        var hidden,
            visibilityChange,
            rs = this;
        function handleVisibilityChange(fg) {
          var oldValue,
              newValue;
          oldValue = rs.getCurrentSyncInterval();
          isBackground = !fg;
          newValue = rs.getCurrentSyncInterval();
          rs._emit('sync-interval-change', {
            oldValue: oldValue,
            newValue: newValue
          });
        }
        RemoteStorage.Env.on("background", function() {
          handleVisibilityChange(false);
        });
        RemoteStorage.Env.on("foreground", function() {
          handleVisibilityChange(true);
        });
      }
      function isValidInterval(interval) {
        return (typeof interval === 'number' && interval > 1000 && interval < 3600000);
      }
      RemoteStorage.Sync = function(setLocal, setRemote, setAccess, setCaching) {
        this.local = setLocal;
        this.local.onDiff(function(path) {
          this.addTask(path);
          this.doTasks();
        }.bind(this));
        this.remote = setRemote;
        this.access = setAccess;
        this.caching = setCaching;
        this._tasks = {};
        this._running = {};
        this._timeStarted = {};
        RemoteStorage.eventHandling(this, 'done', 'req-done');
        this.caching.onActivate(function(path) {
          this.addTask(path);
          this.doTasks();
        }.bind(this));
      };
      RemoteStorage.Sync.prototype = {
        now: function() {
          return new Date().getTime();
        },
        queueGetRequest: function(path) {
          var pending = Promise.defer();
          if (!this.remote.connected) {
            pending.reject('cannot fulfill maxAge requirement - remote is not connected');
          } else if (!this.remote.online) {
            pending.reject('cannot fulfill maxAge requirement - remote is not online');
          } else {
            this.addTask(path, function() {
              this.local.get(path).then(function(r) {
                return pending.resolve(r);
              });
            }.bind(this));
            this.doTasks();
          }
          return pending.promise;
        },
        corruptServerItemsMap: function(itemsMap, force02) {
          if ((typeof(itemsMap) !== 'object') || (Array.isArray(itemsMap))) {
            return true;
          }
          for (var itemName in itemsMap) {
            var item = itemsMap[itemName];
            if (typeof(item) !== 'object') {
              return true;
            }
            if (typeof(item.ETag) !== 'string') {
              return true;
            }
            if (isFolder(itemName)) {
              if (itemName.substring(0, itemName.length - 1).indexOf('/') !== -1) {
                return true;
              }
            } else {
              if (itemName.indexOf('/') !== -1) {
                return true;
              }
              if (force02) {
                if (typeof(item['Content-Type']) !== 'string') {
                  return true;
                }
                if (typeof(item['Content-Length']) !== 'number') {
                  return true;
                }
              }
            }
          }
          return false;
        },
        corruptItemsMap: function(itemsMap) {
          if ((typeof(itemsMap) !== 'object') || (Array.isArray(itemsMap))) {
            return true;
          }
          for (var itemName in itemsMap) {
            if (typeof(itemsMap[itemName]) !== 'boolean') {
              return true;
            }
          }
          return false;
        },
        corruptRevision: function(rev) {
          return ((typeof(rev) !== 'object') || (Array.isArray(rev)) || (rev.revision && typeof(rev.revision) !== 'string') || (rev.body && typeof(rev.body) !== 'string' && typeof(rev.body) !== 'object') || (rev.contentType && typeof(rev.contentType) !== 'string') || (rev.contentLength && typeof(rev.contentLength) !== 'number') || (rev.timestamp && typeof(rev.timestamp) !== 'number') || (rev.itemsMap && this.corruptItemsMap(rev.itemsMap)));
        },
        isCorrupt: function(node) {
          return ((typeof(node) !== 'object') || (Array.isArray(node)) || (typeof(node.path) !== 'string') || (this.corruptRevision(node.common)) || (node.local && this.corruptRevision(node.local)) || (node.remote && this.corruptRevision(node.remote)) || (node.push && this.corruptRevision(node.push)));
        },
        hasTasks: function() {
          return Object.getOwnPropertyNames(this._tasks).length > 0;
        },
        collectDiffTasks: function() {
          var num = 0;
          return this.local.forAllNodes(function(node) {
            if (num > 100) {
              return;
            }
            if (this.isCorrupt(node)) {
              RemoteStorage.log('[Sync] WARNING: corrupt node in local cache', node);
              if (typeof(node) === 'object' && node.path) {
                this.addTask(node.path);
                num++;
              }
            } else if (this.needsFetch(node) && this.access.checkPathPermission(node.path, 'r')) {
              this.addTask(node.path);
              num++;
            } else if (isDocument(node.path) && this.needsPush(node) && this.access.checkPathPermission(node.path, 'rw')) {
              this.addTask(node.path);
              num++;
            }
          }.bind(this)).then(function() {
            return num;
          }, function(err) {
            throw err;
          });
        },
        inConflict: function(node) {
          return (node.local && node.remote && (node.remote.body !== undefined || node.remote.itemsMap));
        },
        needsRefresh: function(node) {
          if (node.common) {
            if (!node.common.timestamp) {
              return true;
            }
            return (this.now() - node.common.timestamp > syncInterval);
          }
          return false;
        },
        needsFetch: function(node) {
          if (this.inConflict(node)) {
            return true;
          }
          if (node.common && node.common.itemsMap === undefined && node.common.body === undefined) {
            return true;
          }
          if (node.remote && node.remote.itemsMap === undefined && node.remote.body === undefined) {
            return true;
          }
          return false;
        },
        needsPush: function(node) {
          if (this.inConflict(node)) {
            return false;
          }
          if (node.local && !node.push) {
            return true;
          }
        },
        needsRemotePut: function(node) {
          return node.local && node.local.body;
        },
        needsRemoteDelete: function(node) {
          return node.local && node.local.body === false;
        },
        getParentPath: function(path) {
          var parts = path.match(/^(.*\/)([^\/]+\/?)$/);
          if (parts) {
            return parts[1];
          } else {
            throw new Error('Not a valid path: "' + path + '"');
          }
        },
        deleteChildPathsFromTasks: function() {
          for (var path in this._tasks) {
            var paths = pathsFromRoot(path);
            for (var i = 1; i < paths.length; i++) {
              if (this._tasks[paths[i]]) {
                delete this._tasks[path];
              }
            }
          }
        },
        collectRefreshTasks: function() {
          return this.local.forAllNodes(function(node) {
            var parentPath;
            if (this.needsRefresh(node)) {
              try {
                parentPath = this.getParentPath(node.path);
              } catch (e) {}
              if (parentPath && this.access.checkPathPermission(parentPath, 'r')) {
                this.addTask(parentPath);
              } else if (this.access.checkPathPermission(node.path, 'r')) {
                this.addTask(node.path);
              }
            }
          }.bind(this)).then(function() {
            this.deleteChildPathsFromTasks();
          }.bind(this), function(err) {
            throw err;
          });
        },
        flush: function(nodes) {
          for (var path in nodes) {
            if (this.caching.checkPath(path) === 'FLUSH' && nodes[path] && !nodes[path].local) {
              RemoteStorage.log('[Sync] Flushing', path);
              nodes[path] = undefined;
            }
          }
          return nodes;
        },
        doTask: function(path) {
          return this.local.getNodes([path]).then(function(nodes) {
            var node = nodes[path];
            if (typeof(node) === 'undefined') {
              return taskFor('get', path, this.remote.get(path));
            } else if (isStaleChild(node)) {
              return taskFor('get', path, this.remote.get(path));
            } else if (this.needsRemotePut(node)) {
              node.push = deepClone(node.local);
              node.push.timestamp = this.now();
              return this.local.setNodes(this.flush(nodes)).then(function() {
                var options;
                if (hasCommonRevision(node)) {
                  options = {ifMatch: node.common.revision};
                } else {
                  options = {ifNoneMatch: '*'};
                }
                return taskFor('put', path, this.remote.put(path, node.push.body, node.push.contentType, options));
              }.bind(this));
            } else if (this.needsRemoteDelete(node)) {
              node.push = {
                body: false,
                timestamp: this.now()
              };
              return this.local.setNodes(this.flush(nodes)).then(function() {
                if (hasCommonRevision(node)) {
                  return taskFor('delete', path, this.remote.delete(path, {ifMatch: node.common.revision}));
                } else {
                  return taskFor('get', path, this.remote.get(path));
                }
              }.bind(this));
            } else if (hasCommonRevision(node)) {
              return taskFor('get', path, this.remote.get(path, {ifNoneMatch: node.common.revision}));
            } else {
              return taskFor('get', path, this.remote.get(path));
            }
          }.bind(this));
        },
        autoMergeFolder: function(node) {
          if (node.remote.itemsMap) {
            node.common = node.remote;
            delete node.remote;
            if (node.common.itemsMap) {
              for (var itemName in node.common.itemsMap) {
                if (!node.local.itemsMap[itemName]) {
                  node.local.itemsMap[itemName] = false;
                }
              }
              if (equal(node.local.itemsMap, node.common.itemsMap)) {
                delete node.local;
              }
            }
          }
          return node;
        },
        autoMergeDocument: function(node) {
          hasNoRemoteChanges = function(node) {
            if (node.remote && node.remote.revision && node.remote.revision !== node.common.revision) {
              return false;
            }
            return (node.common.body === undefined && node.remote.body === false) || (node.remote.body === node.common.body && node.remote.contentType === node.common.contentType);
          };
          mergeMutualDeletion = function(node) {
            if (node.remote && node.remote.body === false && node.local && node.local.body === false) {
              delete node.local;
            }
            return node;
          };
          if (hasNoRemoteChanges(node)) {
            node = mergeMutualDeletion(node);
            delete node.remote;
          } else if (node.remote.body !== undefined) {
            RemoteStorage.log('[Sync] Emitting keep/revert');
            this.local._emitChange({
              origin: 'conflict',
              path: node.path,
              oldValue: node.local.body,
              newValue: node.remote.body,
              lastCommonValue: node.common.body,
              oldContentType: node.local.contentType,
              newContentType: node.remote.contentType,
              lastCommonContentType: node.common.contentType
            });
            if (node.remote.body) {
              node.common = node.remote;
            } else {
              node.common = {};
            }
            delete node.remote;
            delete node.local;
          }
          return node;
        },
        autoMerge: function(node) {
          if (node.remote) {
            if (node.local) {
              if (isFolder(node.path)) {
                return this.autoMergeFolder(node);
              } else {
                return this.autoMergeDocument(node);
              }
            } else {
              if (isFolder(node.path)) {
                if (node.remote.itemsMap !== undefined) {
                  node.common = node.remote;
                  delete node.remote;
                }
              } else {
                if (node.remote.body !== undefined) {
                  var change = {
                    origin: 'remote',
                    path: node.path,
                    oldValue: (node.common.body === false ? undefined : node.common.body),
                    newValue: (node.remote.body === false ? undefined : node.remote.body),
                    oldContentType: node.common.contentType,
                    newContentType: node.remote.contentType
                  };
                  if (change.oldValue || change.newValue) {
                    this.local._emitChange(change);
                  }
                  if (!node.remote.body) {
                    return;
                  }
                  node.common = node.remote;
                  delete node.remote;
                }
              }
            }
          } else {
            if (node.common.body) {
              this.local._emitChange({
                origin: 'remote',
                path: node.path,
                oldValue: node.common.body,
                newValue: undefined,
                oldContentType: node.common.contentType,
                newContentType: undefined
              });
            }
            return undefined;
          }
          return node;
        },
        updateCommonTimestamp: function(path, revision) {
          return this.local.getNodes([path]).then(function(nodes) {
            if (nodes[path] && nodes[path].common && nodes[path].common.revision === revision) {
              nodes[path].common.timestamp = this.now();
            }
            return this.local.setNodes(this.flush(nodes));
          }.bind(this));
        },
        markChildren: function(path, itemsMap, changedNodes, missingChildren) {
          var paths = [];
          var meta = {};
          var recurse = {};
          for (var item in itemsMap) {
            paths.push(path + item);
            meta[path + item] = itemsMap[item];
          }
          for (var childName in missingChildren) {
            paths.push(path + childName);
          }
          return this.local.getNodes(paths).then(function(nodes) {
            var cachingStrategy;
            var node;
            var nodeChanged = function(node, etag) {
              return node.common.revision !== etag && (!node.remote || node.remote.revision !== etag);
            };
            for (var nodePath in nodes) {
              node = nodes[nodePath];
              if (meta[nodePath]) {
                if (node && node.common) {
                  if (nodeChanged(node, meta[nodePath].ETag)) {
                    changedNodes[nodePath] = deepClone(node);
                    changedNodes[nodePath].remote = {
                      revision: meta[nodePath].ETag,
                      timestamp: this.now()
                    };
                    changedNodes[nodePath] = this.autoMerge(changedNodes[nodePath]);
                  }
                } else {
                  cachingStrategy = this.caching.checkPath(nodePath);
                  if (cachingStrategy === 'ALL') {
                    changedNodes[nodePath] = {
                      path: nodePath,
                      common: {timestamp: this.now()},
                      remote: {
                        revision: meta[nodePath].ETag,
                        timestamp: this.now()
                      }
                    };
                  }
                }
                if (changedNodes[nodePath] && meta[nodePath]['Content-Type']) {
                  changedNodes[nodePath].remote.contentType = meta[nodePath]['Content-Type'];
                }
                if (changedNodes[nodePath] && meta[nodePath]['Content-Length']) {
                  changedNodes[nodePath].remote.contentLength = meta[nodePath]['Content-Length'];
                }
              } else if (missingChildren[nodePath.substring(path.length)] && node && node.common) {
                if (node.common.itemsMap) {
                  for (var commonItem in node.common.itemsMap) {
                    recurse[nodePath + commonItem] = true;
                  }
                }
                if (node.local && node.local.itemsMap) {
                  for (var localItem in node.local.itemsMap) {
                    recurse[nodePath + localItem] = true;
                  }
                }
                if (node.remote || isFolder(nodePath)) {
                  changedNodes[nodePath] = undefined;
                } else {
                  changedNodes[nodePath] = this.autoMerge(node);
                  if (typeof changedNodes[nodePath] === 'undefined') {
                    var parentPath = this.getParentPath(nodePath);
                    var parentNode = changedNodes[parentPath];
                    var itemName = nodePath.substring(path.length);
                    if (parentNode && parentNode.local) {
                      delete parentNode.local.itemsMap[itemName];
                      if (equal(parentNode.local.itemsMap, parentNode.common.itemsMap)) {
                        delete parentNode.local;
                      }
                    }
                  }
                }
              }
            }
            return this.deleteRemoteTrees(Object.keys(recurse), changedNodes).then(function(changedObjs2) {
              return this.local.setNodes(this.flush(changedObjs2));
            }.bind(this));
          }.bind(this));
        },
        deleteRemoteTrees: function(paths, changedNodes) {
          if (paths.length === 0) {
            return Promise.resolve(changedNodes);
          }
          return this.local.getNodes(paths).then(function(nodes) {
            var subPaths = {};
            collectSubPaths = function(folder, path) {
              if (folder && folder.itemsMap) {
                for (var itemName in folder.itemsMap) {
                  subPaths[path + itemName] = true;
                }
              }
            };
            for (var path in nodes) {
              var node = nodes[path];
              if (!node) {
                continue;
              }
              if (isFolder(path)) {
                collectSubPaths(node.common, path);
                collectSubPaths(node.local, path);
              } else {
                if (node.common && typeof(node.common.body) !== undefined) {
                  changedNodes[path] = deepClone(node);
                  changedNodes[path].remote = {
                    body: false,
                    timestamp: this.now()
                  };
                  changedNodes[path] = this.autoMerge(changedNodes[path]);
                }
              }
            }
            return this.deleteRemoteTrees(Object.keys(subPaths), changedNodes).then(function(changedNodes2) {
              return this.local.setNodes(this.flush(changedNodes2));
            }.bind(this));
          }.bind(this));
        },
        completeFetch: function(path, bodyOrItemsMap, contentType, revision) {
          var paths;
          var parentPath;
          var pathsFromRootArr = pathsFromRoot(path);
          if (isFolder(path)) {
            paths = [path];
          } else {
            parentPath = pathsFromRootArr[1];
            paths = [path, parentPath];
          }
          return this.local.getNodes(paths).then(function(nodes) {
            var itemName;
            var missingChildren = {};
            var node = nodes[path];
            var parentNode;
            var collectMissingChildren = function(folder) {
              if (folder && folder.itemsMap) {
                for (var itemName in folder.itemsMap) {
                  if (!bodyOrItemsMap[itemName]) {
                    missingChildren[itemName] = true;
                  }
                }
              }
            };
            if (typeof(node) !== 'object' || node.path !== path || typeof(node.common) !== 'object') {
              node = {
                path: path,
                common: {}
              };
              nodes[path] = node;
            }
            node.remote = {
              revision: revision,
              timestamp: this.now()
            };
            if (isFolder(path)) {
              collectMissingChildren(node.common);
              collectMissingChildren(node.remote);
              node.remote.itemsMap = {};
              for (itemName in bodyOrItemsMap) {
                node.remote.itemsMap[itemName] = true;
              }
            } else {
              node.remote.body = bodyOrItemsMap;
              node.remote.contentType = contentType;
              parentNode = nodes[parentPath];
              if (parentNode && parentNode.local && parentNode.local.itemsMap) {
                itemName = path.substring(parentPath.length);
                parentNode.local.itemsMap[itemName] = true;
                if (equal(parentNode.local.itemsMap, parentNode.common.itemsMap)) {
                  delete parentNode.local;
                }
              }
            }
            nodes[path] = this.autoMerge(node);
            return {
              toBeSaved: nodes,
              missingChildren: missingChildren
            };
          }.bind(this));
        },
        completePush: function(path, action, conflict, revision) {
          return this.local.getNodes([path]).then(function(nodes) {
            var node = nodes[path];
            if (!node.push) {
              this.stopped = true;
              throw new Error('completePush called but no push version!');
            }
            if (conflict) {
              RemoteStorage.log('[Sync] We have a conflict');
              if (!node.remote || node.remote.revision !== revision) {
                node.remote = {
                  revision: revision || 'conflict',
                  timestamp: this.now()
                };
                delete node.push;
              }
              nodes[path] = this.autoMerge(node);
            } else {
              node.common = {
                revision: revision,
                timestamp: this.now()
              };
              if (action === 'put') {
                node.common.body = node.push.body;
                node.common.contentType = node.push.contentType;
                if (equal(node.local.body, node.push.body) && node.local.contentType === node.push.contentType) {
                  delete node.local;
                }
                delete node.push;
              } else if (action === 'delete') {
                if (node.local.body === false) {
                  nodes[path] = undefined;
                } else {
                  delete node.push;
                }
              }
            }
            return this.local.setNodes(this.flush(nodes));
          }.bind(this));
        },
        dealWithFailure: function(path, action, statusMeaning) {
          return this.local.getNodes([path]).then(function(nodes) {
            if (nodes[path]) {
              delete nodes[path].push;
              return this.local.setNodes(this.flush(nodes));
            }
          }.bind(this));
        },
        interpretStatus: function(statusCode) {
          if (statusCode === 'offline' || statusCode === 'timeout') {
            return {
              successful: false,
              networkProblems: true,
              statusCode: statusCode
            };
          }
          var series = Math.floor(statusCode / 100);
          return {
            successful: (series === 2 || statusCode === 304 || statusCode === 412 || statusCode === 404),
            conflict: (statusCode === 412),
            unAuth: ((statusCode === 401 && this.remote.token !== RemoteStorage.Authorize.IMPLIED_FAKE_TOKEN) || statusCode === 402 || statusCode === 403),
            notFound: (statusCode === 404),
            changed: (statusCode !== 304),
            statusCode: statusCode
          };
        },
        handleGetResponse: function(path, status, bodyOrItemsMap, contentType, revision) {
          if (status.notFound) {
            if (isFolder(path)) {
              bodyOrItemsMap = {};
            } else {
              bodyOrItemsMap = false;
            }
          }
          if (status.changed) {
            return this.completeFetch(path, bodyOrItemsMap, contentType, revision).then(function(dataFromFetch) {
              if (isFolder(path)) {
                if (this.corruptServerItemsMap(bodyOrItemsMap)) {
                  RemoteStorage.log('[Sync] WARNING: Discarding corrupt folder description from server for ' + path);
                  return false;
                } else {
                  return this.markChildren(path, bodyOrItemsMap, dataFromFetch.toBeSaved, dataFromFetch.missingChildren).then(function() {
                    return true;
                  });
                }
              } else {
                return this.local.setNodes(this.flush(dataFromFetch.toBeSaved)).then(function() {
                  return true;
                });
              }
            }.bind(this));
          } else {
            return this.updateCommonTimestamp(path, revision).then(function() {
              return true;
            });
          }
        },
        handleResponse: function(path, action, r) {
          var status = this.interpretStatus(r.statusCode);
          if (status.successful) {
            if (action === 'get') {
              return this.handleGetResponse(path, status, r.body, r.contentType, r.revision);
            } else if (action === 'put' || action === 'delete') {
              return this.completePush(path, action, status.conflict, r.revision).then(function() {
                return true;
              });
            } else {
              throw new Error('cannot handle response for unknown action', action);
            }
          } else {
            var error;
            if (status.unAuth) {
              error = new RemoteStorage.Unauthorized();
            } else if (status.networkProblems) {
              error = new RemoteStorage.SyncError('Network request failed.');
              this.remote.online = false;
            } else {
              error = new Error('HTTP response code ' + status.statusCode + ' received.');
            }
            return this.dealWithFailure(path, action, status).then(function() {
              remoteStorage._emit('error', error);
              throw error;
            });
          }
        },
        numThreads: 10,
        finishTask: function(task) {
          if (task.action === undefined) {
            delete this._running[task.path];
            return;
          }
          var self = this;
          return task.promise.then(function(r) {
            return self.handleResponse(task.path, task.action, r);
          }, function(err) {
            RemoteStorage.log('[Sync] wireclient rejects its promise!', task.path, task.action, err);
            return self.handleResponse(task.path, task.action, {statusCode: 'offline'});
          }).then(function(completed) {
            delete self._timeStarted[task.path];
            delete self._running[task.path];
            self.remote.online = true;
            if (completed) {
              if (self._tasks[task.path]) {
                for (var i = 0; i < self._tasks[task.path].length; i++) {
                  self._tasks[task.path][i]();
                }
                delete self._tasks[task.path];
              }
            }
            self._emit('req-done');
            self.collectTasks(false).then(function() {
              if (!self.hasTasks() || self.stopped) {
                RemoteStorage.log('[Sync] Sync is done! Reschedule?', Object.getOwnPropertyNames(self._tasks).length, self.stopped);
                if (!self.done) {
                  self.done = true;
                  self._emit('done');
                }
              } else {
                setTimeout(function() {
                  self.doTasks();
                }, 10);
              }
            });
          }, function(err) {
            console.error('[Sync] Error', err);
            delete self._timeStarted[task.path];
            delete self._running[task.path];
            self._emit('req-done');
            if (!self.done) {
              self.done = true;
              self._emit('done');
            }
          });
        },
        doTasks: function() {
          var numToHave,
              numAdded = 0,
              numToAdd,
              path;
          if (this.remote.connected) {
            if (this.remote.online) {
              numToHave = this.numThreads;
            } else {
              numToHave = 1;
            }
          } else {
            numToHave = 0;
          }
          numToAdd = numToHave - Object.getOwnPropertyNames(this._running).length;
          if (numToAdd <= 0) {
            return true;
          }
          for (path in this._tasks) {
            if (!this._running[path]) {
              this._timeStarted = this.now();
              this._running[path] = this.doTask(path);
              this._running[path].then(this.finishTask.bind(this));
              numAdded++;
              if (numAdded >= numToAdd) {
                return true;
              }
            }
          }
          return (numAdded >= numToAdd);
        },
        collectTasks: function(alsoCheckRefresh) {
          if (this.hasTasks() || this.stopped) {
            return Promise.resolve();
          }
          return this.collectDiffTasks().then(function(numDiffs) {
            if (numDiffs || alsoCheckRefresh === false) {
              return Promise.resolve();
            } else {
              return this.collectRefreshTasks();
            }
          }.bind(this), function(err) {
            throw err;
          });
        },
        addTask: function(path, cb) {
          if (!this._tasks[path]) {
            this._tasks[path] = [];
          }
          if (typeof(cb) === 'function') {
            this._tasks[path].push(cb);
          }
        },
        sync: function() {
          this.done = false;
          if (!this.doTasks()) {
            return this.collectTasks().then(function() {
              try {
                this.doTasks();
              } catch (e) {
                console.error('[Sync] doTasks error', e);
              }
            }.bind(this), function(e) {
              console.error('[Sync] Sync error', e);
              throw new Error('Local cache unavailable');
            });
          } else {
            return Promise.resolve();
          }
        }
      };
      RemoteStorage.prototype.getSyncInterval = function() {
        return syncInterval;
      };
      RemoteStorage.prototype.setSyncInterval = function(interval) {
        if (!isValidInterval(interval)) {
          throw interval + " is not a valid sync interval";
        }
        var oldValue = syncInterval;
        syncInterval = parseInt(interval, 10);
        this._emit('sync-interval-change', {
          oldValue: oldValue,
          newValue: interval
        });
      };
      RemoteStorage.prototype.getBackgroundSyncInterval = function() {
        return backgroundSyncInterval;
      };
      RemoteStorage.prototype.setBackgroundSyncInterval = function(interval) {
        if (!isValidInterval(interval)) {
          throw interval + " is not a valid sync interval";
        }
        var oldValue = backgroundSyncInterval;
        backgroundSyncInterval = parseInt(interval, 10);
        this._emit('sync-interval-change', {
          oldValue: oldValue,
          newValue: interval
        });
      };
      RemoteStorage.prototype.getCurrentSyncInterval = function() {
        return isBackground ? backgroundSyncInterval : syncInterval;
      };
      var SyncError = function(originalError) {
        var msg = 'Sync failed: ';
        if (typeof(originalError) === 'object' && 'message' in originalError) {
          msg += originalError.message;
        } else {
          msg += originalError;
        }
        this.originalError = originalError;
        this.message = msg;
      };
      SyncError.prototype = new Error();
      SyncError.prototype.constructor = SyncError;
      RemoteStorage.SyncError = SyncError;
      RemoteStorage.prototype.syncCycle = function() {
        if (this.sync.stopped) {
          return;
        }
        this.sync.on('done', function() {
          RemoteStorage.log('[Sync] Sync done. Setting timer to', this.getCurrentSyncInterval());
          if (!this.sync.stopped) {
            if (this._syncTimer) {
              clearTimeout(this._syncTimer);
            }
            this._syncTimer = setTimeout(this.sync.sync.bind(this.sync), this.getCurrentSyncInterval());
          }
        }.bind(this));
        this.sync.sync();
      };
      RemoteStorage.prototype.stopSync = function() {
        if (this.sync) {
          RemoteStorage.log('[Sync] Stopping sync');
          this.sync.stopped = true;
        } else {
          RemoteStorage.log('[Sync] Will instantiate sync stopped');
          this.syncStopped = true;
        }
      };
      RemoteStorage.prototype.startSync = function() {
        this.sync.stopped = false;
        this.syncStopped = false;
        this.sync.sync();
      };
      var syncCycleCb;
      RemoteStorage.Sync._rs_init = function(remoteStorage) {
        syncCycleCb = function() {
          RemoteStorage.log('[Sync] syncCycleCb calling syncCycle');
          if (RemoteStorage.Env.isBrowser()) {
            handleVisibility.bind(remoteStorage)();
          }
          if (!remoteStorage.sync) {
            remoteStorage.sync = new RemoteStorage.Sync(remoteStorage.local, remoteStorage.remote, remoteStorage.access, remoteStorage.caching);
            if (remoteStorage.syncStopped) {
              RemoteStorage.log('[Sync] Instantiating sync stopped');
              remoteStorage.sync.stopped = true;
              delete remoteStorage.syncStopped;
            }
          }
          RemoteStorage.log('[Sync] syncCycleCb calling syncCycle');
          remoteStorage.syncCycle();
        };
        remoteStorage.on('ready', syncCycleCb);
      };
      RemoteStorage.Sync._rs_cleanup = function(remoteStorage) {
        remoteStorage.stopSync();
        remoteStorage.removeEventListener('ready', syncCycleCb);
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function() {
      var isFolder = RemoteStorage.util.isFolder;
      var isDocument = RemoteStorage.util.isDocument;
      var deepClone = RemoteStorage.util.deepClone;
      var equal = RemoteStorage.util.equal;
      function getLatest(node) {
        if (typeof(node) !== 'object' || typeof(node.path) !== 'string') {
          return;
        }
        if (isFolder(node.path)) {
          if (node.local && node.local.itemsMap) {
            return node.local;
          }
          if (node.common && node.common.itemsMap) {
            return node.common;
          }
        } else {
          if (node.local && node.local.body && node.local.contentType) {
            return node.local;
          }
          if (node.common && node.common.body && node.common.contentType) {
            return node.common;
          }
          if (node.body && node.contentType) {
            return {
              body: node.body,
              contentType: node.contentType
            };
          }
        }
      }
      function isOutdated(nodes, maxAge) {
        var path,
            node;
        for (path in nodes) {
          if (nodes[path] && nodes[path].remote) {
            return true;
          }
          var nodeVersion = getLatest(nodes[path]);
          if (nodeVersion && nodeVersion.timestamp && (new Date().getTime()) - nodeVersion.timestamp <= maxAge) {
            return false;
          } else if (!nodeVersion) {
            return true;
          }
        }
        return true;
      }
      var pathsFromRoot = RemoteStorage.util.pathsFromRoot;
      function makeNode(path) {
        var node = {
          path: path,
          common: {}
        };
        if (isFolder(path)) {
          node.common.itemsMap = {};
        }
        return node;
      }
      function updateFolderNodeWithItemName(node, itemName) {
        if (!node.common) {
          node.common = {itemsMap: {}};
        }
        if (!node.common.itemsMap) {
          node.common.itemsMap = {};
        }
        if (!node.local) {
          node.local = deepClone(node.common);
        }
        if (!node.local.itemsMap) {
          node.local.itemsMap = node.common.itemsMap;
        }
        node.local.itemsMap[itemName] = true;
        return node;
      }
      var methods = {
        get: function(path, maxAge, queueGetRequest) {
          var self = this;
          if (typeof(maxAge) === 'number') {
            return self.getNodes(pathsFromRoot(path)).then(function(objs) {
              var node = getLatest(objs[path]);
              if (isOutdated(objs, maxAge)) {
                return queueGetRequest(path);
              } else if (node) {
                return {
                  statusCode: 200,
                  body: node.body || node.itemsMap,
                  contentType: node.contentType
                };
              } else {
                return {statusCode: 404};
              }
            });
          } else {
            return self.getNodes([path]).then(function(objs) {
              var node = getLatest(objs[path]);
              if (node) {
                if (isFolder(path)) {
                  for (var i in node.itemsMap) {
                    if (node.itemsMap.hasOwnProperty(i) && node.itemsMap[i] === false) {
                      delete node.itemsMap[i];
                    }
                  }
                }
                return {
                  statusCode: 200,
                  body: node.body || node.itemsMap,
                  contentType: node.contentType
                };
              } else {
                return {statusCode: 404};
              }
            });
          }
        },
        put: function(path, body, contentType) {
          var paths = pathsFromRoot(path);
          var self = this;
          function _processNodes(paths, nodes) {
            try {
              for (var i = 0,
                  len = paths.length; i < len; i++) {
                var path = paths[i];
                var node = nodes[path];
                var previous;
                if (!node) {
                  nodes[path] = node = makeNode(path);
                }
                if (i === 0) {
                  previous = getLatest(node);
                  node.local = {
                    body: body,
                    contentType: contentType,
                    previousBody: (previous ? previous.body : undefined),
                    previousContentType: (previous ? previous.contentType : undefined)
                  };
                } else {
                  var itemName = paths[i - 1].substring(path.length);
                  node = updateFolderNodeWithItemName(node, itemName);
                }
              }
              return nodes;
            } catch (e) {
              RemoteStorage.log('[Cachinglayer] Error during PUT', nodes, i, e);
              throw e;
            }
          }
          return this._updateNodes(paths, _processNodes);
        },
        delete: function(path) {
          var paths = pathsFromRoot(path);
          return this._updateNodes(paths, function(paths, nodes) {
            for (var i = 0,
                len = paths.length; i < len; i++) {
              var path = paths[i];
              var node = nodes[path];
              if (!node) {
                throw new Error('Cannot delete non-existing node ' + path);
              }
              if (i === 0) {
                previous = getLatest(node);
                node.local = {
                  body: false,
                  previousBody: (previous ? previous.body : undefined),
                  previousContentType: (previous ? previous.contentType : undefined)
                };
              } else {
                if (!node.local) {
                  node.local = deepClone(node.common);
                }
                var itemName = paths[i - 1].substring(path.length);
                delete node.local.itemsMap[itemName];
                if (Object.getOwnPropertyNames(node.local.itemsMap).length > 0) {
                  break;
                }
              }
            }
            return nodes;
          });
        },
        flush: function(path) {
          var self = this;
          return self._getAllDescendentPaths(path).then(function(paths) {
            return self.getNodes(paths);
          }).then(function(nodes) {
            for (var path in nodes) {
              var node = nodes[path];
              if (node && node.common && node.local) {
                self._emitChange({
                  path: node.path,
                  origin: 'local',
                  oldValue: (node.local.body === false ? undefined : node.local.body),
                  newValue: (node.common.body === false ? undefined : node.common.body)
                });
              }
              nodes[path] = undefined;
            }
            return self.setNodes(nodes);
          });
        },
        _emitChange: function(obj) {
          if (RemoteStorage.config.changeEvents[obj.origin]) {
            this._emit('change', obj);
          }
        },
        fireInitial: function() {
          if (!RemoteStorage.config.changeEvents.local) {
            return;
          }
          var self = this;
          self.forAllNodes(function(node) {
            var latest;
            if (isDocument(node.path)) {
              latest = getLatest(node);
              if (latest) {
                self._emitChange({
                  path: node.path,
                  origin: 'local',
                  oldValue: undefined,
                  oldContentType: undefined,
                  newValue: latest.body,
                  newContentType: latest.contentType
                });
              }
            }
          }).then(function() {
            self._emit('local-events-done');
          });
        },
        onDiff: function(diffHandler) {
          this.diffHandler = diffHandler;
        },
        migrate: function(node) {
          if (typeof(node) === 'object' && !node.common) {
            node.common = {};
            if (typeof(node.path) === 'string') {
              if (node.path.substr(-1) === '/' && typeof(node.body) === 'object') {
                node.common.itemsMap = node.body;
              }
            } else {
              if (!node.local) {
                node.local = {};
              }
              node.local.body = node.body;
              node.local.contentType = node.contentType;
            }
          }
          return node;
        },
        _updateNodesRunning: false,
        _updateNodesQueued: [],
        _updateNodes: function(paths, _processNodes) {
          var pending = Promise.defer();
          this._doUpdateNodes(paths, _processNodes, pending);
          return pending.promise;
        },
        _doUpdateNodes: function(paths, _processNodes, promise) {
          var self = this;
          if (self._updateNodesRunning) {
            self._updateNodesQueued.push({
              paths: paths,
              cb: _processNodes,
              promise: promise
            });
            return;
          } else {
            self._updateNodesRunning = true;
          }
          self.getNodes(paths).then(function(nodes) {
            var existingNodes = deepClone(nodes);
            var changeEvents = [];
            var node;
            nodes = _processNodes(paths, nodes);
            for (var path in nodes) {
              node = nodes[path];
              if (equal(node, existingNodes[path])) {
                delete nodes[path];
              } else if (isDocument(path)) {
                changeEvents.push({
                  path: path,
                  origin: 'window',
                  oldValue: node.local.previousBody,
                  newValue: node.local.body === false ? undefined : node.local.body,
                  oldContentType: node.local.previousContentType,
                  newContentType: node.local.contentType
                });
                delete node.local.previousBody;
                delete node.local.previousContentType;
              }
            }
            self.setNodes(nodes).then(function() {
              self._emitChangeEvents(changeEvents);
              promise.resolve({statusCode: 200});
            });
          }).then(function() {
            return Promise.resolve();
          }, function(err) {
            promise.reject(err);
          }).then(function() {
            self._updateNodesRunning = false;
            var nextJob = self._updateNodesQueued.shift();
            if (nextJob) {
              self._doUpdateNodes(nextJob.paths, nextJob.cb, nextJob.promise);
            }
          });
        },
        _emitChangeEvents: function(events) {
          for (var i = 0,
              len = events.length; i < len; i++) {
            this._emitChange(events[i]);
            if (this.diffHandler) {
              this.diffHandler(events[i].path);
            }
          }
        },
        _getAllDescendentPaths: function(path) {
          var self = this;
          if (isFolder(path)) {
            return self.getNodes([path]).then(function(nodes) {
              var allPaths = [path];
              var latest = getLatest(nodes[path]);
              var itemNames = Object.keys(latest.itemsMap);
              var calls = itemNames.map(function(itemName) {
                return self._getAllDescendentPaths(path + itemName).then(function(paths) {
                  for (var i = 0,
                      len = paths.length; i < len; i++) {
                    allPaths.push(paths[i]);
                  }
                });
              });
              return Promise.all(calls).then(function() {
                return allPaths;
              });
            });
          } else {
            return Promise.resolve([path]);
          }
        },
        _getInternals: function() {
          return {
            getLatest: getLatest,
            makeNode: makeNode,
            isOutdated: isOutdated
          };
        }
      };
      RemoteStorage.cachingLayer = function(object) {
        for (var key in methods) {
          object[key] = methods[key];
        }
      };
    })();
    (function(global) {
      var RS = RemoteStorage;
      var DB_VERSION = 2;
      var DEFAULT_DB_NAME = 'remotestorage';
      var DEFAULT_DB;
      RS.IndexedDB = function(database) {
        this.db = database || DEFAULT_DB;
        if (!this.db) {
          RemoteStorage.log("[IndexedDB] Failed to open DB");
          return undefined;
        }
        RS.cachingLayer(this);
        RS.eventHandling(this, 'change', 'local-events-done');
        this.getsRunning = 0;
        this.putsRunning = 0;
        this.changesQueued = {};
        this.changesRunning = {};
      };
      RS.IndexedDB.prototype = {
        getNodes: function(paths) {
          var misses = [],
              fromCache = {};
          for (var i = 0,
              len = paths.length; i < len; i++) {
            if (this.changesQueued[paths[i]] !== undefined) {
              fromCache[paths[i]] = RemoteStorage.util.deepClone(this.changesQueued[paths[i]] || undefined);
            } else if (this.changesRunning[paths[i]] !== undefined) {
              fromCache[paths[i]] = RemoteStorage.util.deepClone(this.changesRunning[paths[i]] || undefined);
            } else {
              misses.push(paths[i]);
            }
          }
          if (misses.length > 0) {
            return this.getNodesFromDb(misses).then(function(nodes) {
              for (var i in fromCache) {
                nodes[i] = fromCache[i];
              }
              return nodes;
            });
          } else {
            return Promise.resolve(fromCache);
          }
        },
        setNodes: function(nodes) {
          for (var i in nodes) {
            this.changesQueued[i] = nodes[i] || false;
          }
          this.maybeFlush();
          return Promise.resolve();
        },
        maybeFlush: function() {
          if (this.putsRunning === 0) {
            this.flushChangesQueued();
          } else {
            if (!this.commitSlownessWarning) {
              this.commitSlownessWarning = setInterval(function() {
                console.log('WARNING: waited more than 10 seconds for previous commit to finish');
              }, 10000);
            }
          }
        },
        flushChangesQueued: function() {
          if (this.commitSlownessWarning) {
            clearInterval(this.commitSlownessWarning);
            this.commitSlownessWarning = null;
          }
          if (Object.keys(this.changesQueued).length > 0) {
            this.changesRunning = this.changesQueued;
            this.changesQueued = {};
            this.setNodesInDb(this.changesRunning).then(this.flushChangesQueued.bind(this));
          }
        },
        getNodesFromDb: function(paths) {
          var pending = Promise.defer();
          var transaction = this.db.transaction(['nodes'], 'readonly');
          var nodes = transaction.objectStore('nodes');
          var retrievedNodes = {};
          var startTime = new Date().getTime();
          this.getsRunning++;
          paths.map(function(path, i) {
            nodes.get(path).onsuccess = function(evt) {
              retrievedNodes[path] = evt.target.result;
            };
          });
          transaction.oncomplete = function() {
            pending.resolve(retrievedNodes);
            this.getsRunning--;
          }.bind(this);
          transaction.onerror = transaction.onabort = function() {
            pending.reject('get transaction error/abort');
            this.getsRunning--;
          }.bind(this);
          return pending.promise;
        },
        setNodesInDb: function(nodes) {
          var pending = Promise.defer();
          var transaction = this.db.transaction(['nodes'], 'readwrite');
          var nodesStore = transaction.objectStore('nodes');
          var startTime = new Date().getTime();
          this.putsRunning++;
          RemoteStorage.log('[IndexedDB] Starting put', nodes, this.putsRunning);
          for (var path in nodes) {
            var node = nodes[path];
            if (typeof(node) === 'object') {
              try {
                nodesStore.put(node);
              } catch (e) {
                RemoteStorage.log('[IndexedDB] Error while putting', node, e);
                throw e;
              }
            } else {
              try {
                nodesStore.delete(path);
              } catch (e) {
                RemoteStorage.log('[IndexedDB] Error while removing', nodesStore, node, e);
                throw e;
              }
            }
          }
          transaction.oncomplete = function() {
            this.putsRunning--;
            RemoteStorage.log('[IndexedDB] Finished put', nodes, this.putsRunning, (new Date().getTime() - startTime) + 'ms');
            pending.resolve();
          }.bind(this);
          transaction.onerror = function() {
            this.putsRunning--;
            pending.reject('transaction error');
          }.bind(this);
          transaction.onabort = function() {
            pending.reject('transaction abort');
            this.putsRunning--;
          }.bind(this);
          return pending.promise;
        },
        reset: function(callback) {
          var dbName = this.db.name;
          var self = this;
          this.db.close();
          RS.IndexedDB.clean(this.db.name, function() {
            RS.IndexedDB.open(dbName, function(err, other) {
              if (err) {
                RemoteStorage.log('[IndexedDB] Error while resetting local storage', err);
              } else {
                self.db = other;
              }
              if (typeof callback === 'function') {
                callback(self);
              }
            });
          });
        },
        forAllNodes: function(cb) {
          var pending = Promise.defer();
          var transaction = this.db.transaction(['nodes'], 'readonly');
          var cursorReq = transaction.objectStore('nodes').openCursor();
          cursorReq.onsuccess = function(evt) {
            var cursor = evt.target.result;
            if (cursor) {
              cb(this.migrate(cursor.value));
              cursor.continue();
            } else {
              pending.resolve();
            }
          }.bind(this);
          return pending.promise;
        },
        closeDB: function() {
          this.db.close();
        }
      };
      RS.IndexedDB.open = function(name, callback) {
        var timer = setTimeout(function() {
          callback("timeout trying to open db");
        }, 10000);
        try {
          var req = indexedDB.open(name, DB_VERSION);
          req.onerror = function() {
            RemoteStorage.log('[IndexedDB] Opening DB failed', req);
            clearTimeout(timer);
            callback(req.error);
          };
          req.onupgradeneeded = function(event) {
            var db = req.result;
            RemoteStorage.log("[IndexedDB] Upgrade: from ", event.oldVersion, " to ", event.newVersion);
            if (event.oldVersion !== 1) {
              RemoteStorage.log("[IndexedDB] Creating object store: nodes");
              db.createObjectStore('nodes', {keyPath: 'path'});
            }
            RemoteStorage.log("[IndexedDB] Creating object store: changes");
            db.createObjectStore('changes', {keyPath: 'path'});
          };
          req.onsuccess = function() {
            clearTimeout(timer);
            var db = req.result;
            if (!db.objectStoreNames.contains('nodes') || !db.objectStoreNames.contains('changes')) {
              RemoteStorage.log("[IndexedDB] Missing object store. Resetting the database.");
              RS.IndexedDB.clean(name, function() {
                RS.IndexedDB.open(name, callback);
              });
              return;
            }
            callback(null, req.result);
          };
        } catch (error) {
          RemoteStorage.log("[IndexedDB] Failed to open database: " + error);
          RemoteStorage.log("[IndexedDB] Resetting database and trying again.");
          clearTimeout(timer);
          RS.IndexedDB.clean(name, function() {
            RS.IndexedDB.open(name, callback);
          });
        }
        ;
      };
      RS.IndexedDB.clean = function(databaseName, callback) {
        var req = indexedDB.deleteDatabase(databaseName);
        req.onsuccess = function() {
          RemoteStorage.log('[IndexedDB] Done removing DB');
          callback();
        };
        req.onerror = req.onabort = function(evt) {
          console.error('Failed to remove database "' + databaseName + '"', evt);
        };
      };
      RS.IndexedDB._rs_init = function(remoteStorage) {
        var pending = Promise.defer();
        RS.IndexedDB.open(DEFAULT_DB_NAME, function(err, db) {
          if (err) {
            pending.reject(err);
          } else {
            DEFAULT_DB = db;
            db.onerror = function() {
              remoteStorage._emit('error', err);
            };
            pending.resolve();
          }
        });
        return pending.promise;
      };
      RS.IndexedDB._rs_supported = function() {
        var pending = Promise.defer();
        global.indexedDB = global.indexedDB || global.webkitIndexedDB || global.mozIndexedDB || global.oIndexedDB || global.msIndexedDB;
        var poorIndexedDbSupport = false;
        if (typeof global.navigator !== 'undefined' && global.navigator.userAgent.match(/Android (2|3|4\.[0-3])/)) {
          if (!navigator.userAgent.match(/Chrome|Firefox/)) {
            poorIndexedDbSupport = true;
          }
        }
        if ('indexedDB' in global && !poorIndexedDbSupport) {
          try {
            var check = indexedDB.open("rs-check");
            check.onerror = function(event) {
              pending.reject();
            };
            check.onsuccess = function(event) {
              indexedDB.deleteDatabase("rs-check");
              pending.resolve();
            };
          } catch (e) {
            pending.reject();
          }
        } else {
          pending.reject();
        }
        return pending.promise;
      };
      RS.IndexedDB._rs_cleanup = function(remoteStorage) {
        var pending = Promise.defer();
        if (remoteStorage.local) {
          remoteStorage.local.closeDB();
        }
        RS.IndexedDB.clean(DEFAULT_DB_NAME, function() {
          pending.resolve();
        });
        return pending.promise;
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      var NODES_PREFIX = "remotestorage:cache:nodes:";
      var CHANGES_PREFIX = "remotestorage:cache:changes:";
      RemoteStorage.LocalStorage = function() {
        RemoteStorage.cachingLayer(this);
        RemoteStorage.log('[LocalStorage] Registering events');
        RemoteStorage.eventHandling(this, 'change', 'local-events-done');
      };
      function b64ToUint6(nChr) {
        return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
      }
      function isBinary(node) {
        return node.match(/charset=binary/);
      }
      function isRemoteStorageKey(key) {
        return key.substr(0, NODES_PREFIX.length) === NODES_PREFIX || key.substr(0, CHANGES_PREFIX.length) === CHANGES_PREFIX;
      }
      function isNodeKey(key) {
        return key.substr(0, NODES_PREFIX.length) === NODES_PREFIX;
      }
      RemoteStorage.LocalStorage.prototype = {
        getNodes: function(paths) {
          var nodes = {};
          for (var i = 0,
              len = paths.length; i < len; i++) {
            try {
              nodes[paths[i]] = JSON.parse(localStorage[NODES_PREFIX + paths[i]]);
            } catch (e) {
              nodes[paths[i]] = undefined;
            }
          }
          return Promise.resolve(nodes);
        },
        setNodes: function(nodes) {
          for (var path in nodes) {
            localStorage[NODES_PREFIX + path] = JSON.stringify(nodes[path]);
          }
          return Promise.resolve();
        },
        forAllNodes: function(cb) {
          var node;
          for (var i = 0,
              len = localStorage.length; i < len; i++) {
            if (isNodeKey(localStorage.key(i))) {
              try {
                node = this.migrate(JSON.parse(localStorage[localStorage.key(i)]));
              } catch (e) {
                node = undefined;
              }
              if (node) {
                cb(node);
              }
            }
          }
          return Promise.resolve();
        }
      };
      RemoteStorage.LocalStorage._rs_init = function() {};
      RemoteStorage.LocalStorage._rs_supported = function() {
        return 'localStorage' in global;
      };
      RemoteStorage.LocalStorage._rs_cleanup = function() {
        var keys = [];
        for (var i = 0,
            len = localStorage.length; i < len; i++) {
          var key = localStorage.key(i);
          if (isRemoteStorageKey(key)) {
            keys.push(key);
          }
        }
        keys.forEach(function(key) {
          RemoteStorage.log('[LocalStorage] Removing', key);
          delete localStorage[key];
        });
      };
    })(typeof(window) !== 'undefined' ? window : global);
    (function(global) {
      RemoteStorage.InMemoryStorage = function() {
        RemoteStorage.cachingLayer(this);
        RemoteStorage.log('[InMemoryStorage] Registering events');
        RemoteStorage.eventHandling(this, 'change', 'local-events-done');
        this._storage = {};
      };
      RemoteStorage.InMemoryStorage.prototype = {
        getNodes: function(paths) {
          var nodes = {};
          for (var i = 0,
              len = paths.length; i < len; i++) {
            nodes[paths[i]] = this._storage[paths[i]];
          }
          return Promise.resolve(nodes);
        },
        setNodes: function(nodes) {
          for (var path in nodes) {
            if (nodes[path] === undefined) {
              delete this._storage[path];
            } else {
              this._storage[path] = nodes[path];
            }
          }
          return Promise.resolve();
        },
        forAllNodes: function(cb) {
          for (var path in this._storage) {
            cb(this.migrate(this._storage[path]));
          }
          return Promise.resolve();
        }
      };
      RemoteStorage.InMemoryStorage._rs_init = function() {};
      RemoteStorage.InMemoryStorage._rs_supported = function() {
        return true;
      };
      RemoteStorage.InMemoryStorage._rs_cleanup = function() {};
    })(typeof(window) !== 'undefined' ? window : global);
    (function() {
      RemoteStorage.MODULES = {};
      RemoteStorage.defineModule = function(moduleName, builder) {
        RemoteStorage.MODULES[moduleName] = builder;
        Object.defineProperty(RemoteStorage.prototype, moduleName, {
          configurable: true,
          get: function() {
            var instance = this._loadModule(moduleName);
            Object.defineProperty(this, moduleName, {value: instance});
            return instance;
          }
        });
        if (moduleName.indexOf('-') !== -1) {
          var camelizedName = moduleName.replace(/\-[a-z]/g, function(s) {
            return s[1].toUpperCase();
          });
          Object.defineProperty(RemoteStorage.prototype, camelizedName, {get: function() {
              return this[moduleName];
            }});
        }
      };
      RemoteStorage.prototype._loadModule = function(moduleName) {
        var builder = RemoteStorage.MODULES[moduleName];
        if (builder) {
          var module = builder(new RemoteStorage.BaseClient(this, '/' + moduleName + '/'), new RemoteStorage.BaseClient(this, '/public/' + moduleName + '/'));
          return module.exports;
        } else {
          throw "Unknown module: " + moduleName;
        }
      };
      RemoteStorage.prototype.defineModule = function(moduleName) {
        console.log("remoteStorage.defineModule is deprecated, use RemoteStorage.defineModule instead!");
        RemoteStorage.defineModule.apply(RemoteStorage, arguments);
      };
    })();
    (function() {
      function loadTable(table, storage, paths) {
        table.setAttribute('border', '1');
        table.style.margin = '8px';
        table.style.color = 'white';
        table.innerHTML = '';
        var thead = document.createElement('thead');
        table.appendChild(thead);
        var titleRow = document.createElement('tr');
        thead.appendChild(titleRow);
        ['Path', 'Content-Type', 'Revision'].forEach(function(label) {
          var th = document.createElement('th');
          th.textContent = label;
          thead.appendChild(th);
        });
        var tbody = document.createElement('tbody');
        table.appendChild(tbody);
        function renderRow(tr, path, contentType, revision) {
          [path, contentType, revision].forEach(function(value) {
            var td = document.createElement('td');
            td.textContent = value || '';
            tr.appendChild(td);
          });
        }
        function loadRow(path) {
          if (storage.connected === false) {
            return;
          }
          function processRow(status, body, contentType, revision) {
            if (status === 200) {
              var tr = document.createElement('tr');
              tbody.appendChild(tr);
              renderRow(tr, path, contentType, revision);
              if (path[path.length - 1] === '/') {
                for (var key in body) {
                  loadRow(path + key);
                }
              }
            }
          }
          storage.get(path).then(processRow);
        }
        paths.forEach(loadRow);
      }
      function renderWrapper(title, table, storage, paths) {
        var wrapper = document.createElement('div');
        var heading = document.createElement('h2');
        heading.textContent = title;
        wrapper.appendChild(heading);
        var updateButton = document.createElement('button');
        updateButton.textContent = "Refresh";
        updateButton.onclick = function() {
          loadTable(table, storage, paths);
        };
        wrapper.appendChild(updateButton);
        if (storage.reset) {
          var resetButton = document.createElement('button');
          resetButton.textContent = "Reset";
          resetButton.onclick = function() {
            storage.reset(function(newStorage) {
              storage = newStorage;
              loadTable(table, storage, paths);
            });
          };
          wrapper.appendChild(resetButton);
        }
        wrapper.appendChild(table);
        loadTable(table, storage, paths);
        return wrapper;
      }
      function renderLocalChanges(local) {
        var wrapper = document.createElement('div');
        var heading = document.createElement('h2');
        heading.textContent = "Outgoing changes";
        wrapper.appendChild(heading);
        var updateButton = document.createElement('button');
        updateButton.textContent = "Refresh";
        wrapper.appendChild(updateButton);
        var list = document.createElement('ul');
        list.style.fontFamily = 'courier';
        wrapper.appendChild(list);
        function updateList() {
          list.innerHTML = '';
          local.forAllNodes(function(node) {
            if (node.local && node.local.body) {
              var el = document.createElement('li');
              el.textContent = JSON.stringify(node.local);
              list.appendChild(el);
            }
          });
        }
        updateButton.onclick = updateList;
        updateList();
        return wrapper;
      }
      RemoteStorage.prototype.inspect = function() {
        var widget = document.createElement('div');
        widget.id = 'remotestorage-inspect';
        widget.style.position = 'absolute';
        widget.style.top = 0;
        widget.style.left = 0;
        widget.style.background = 'black';
        widget.style.color = 'white';
        widget.style.border = 'groove 5px #ccc';
        var controls = document.createElement('div');
        controls.style.position = 'absolute';
        controls.style.top = 0;
        controls.style.left = 0;
        var heading = document.createElement('strong');
        heading.textContent = " remotestorage.js inspector ";
        controls.appendChild(heading);
        var syncButton;
        if (this.local) {
          syncButton = document.createElement('button');
          syncButton.textContent = "Synchronize";
          controls.appendChild(syncButton);
        }
        var closeButton = document.createElement('button');
        closeButton.textContent = "Close";
        closeButton.onclick = function() {
          document.body.removeChild(widget);
        };
        controls.appendChild(closeButton);
        widget.appendChild(controls);
        var remoteRootPaths = [];
        for (var path in this.caching._rootPaths) {
          if (this.caching._rootPaths.hasOwnProperty(path)) {
            remoteRootPaths.push(path);
          }
        }
        var remoteTable = document.createElement('table');
        var localTable = document.createElement('table');
        widget.appendChild(renderWrapper("Remote", remoteTable, this.remote, remoteRootPaths));
        if (this.local) {
          widget.appendChild(renderWrapper("Local", localTable, this.local, ['/']));
          widget.appendChild(renderLocalChanges(this.local));
          syncButton.onclick = function() {
            this.log('sync clicked');
            this.sync.sync().then(function() {
              this.log('SYNC FINISHED');
              loadTable(localTable, this.local, ['/']);
            }.bind(this), function(err) {
              console.error("SYNC FAILED", err, err.stack);
            });
          }.bind(this);
        }
        document.body.appendChild(widget);
      };
    })();
    (function(global) {
      var RS = RemoteStorage;
      var BASE_URL = 'https://www.googleapis.com';
      var AUTH_URL = 'https://accounts.google.com/o/oauth2/auth';
      var AUTH_SCOPE = 'https://www.googleapis.com/auth/drive';
      var GD_DIR_MIME_TYPE = 'application/vnd.google-apps.folder';
      var RS_DIR_MIME_TYPE = 'application/json; charset=UTF-8';
      function buildQueryString(params) {
        return Object.keys(params).map(function(key) {
          return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
        }).join('&');
      }
      function fileNameFromMeta(meta) {
        return encodeURIComponent(meta.title) + (meta.mimeType === GD_DIR_MIME_TYPE ? '/' : '');
      }
      function metaTitleFromFileName(filename) {
        if (filename.substr(-1) === '/') {
          filename = filename.substr(0, filename.length - 1);
        }
        return decodeURIComponent(filename);
      }
      function parentPath(path) {
        return path.replace(/[^\/]+\/?$/, '');
      }
      function baseName(path) {
        var parts = path.split('/');
        if (path.substr(-1) === '/') {
          return parts[parts.length - 2] + '/';
        } else {
          return parts[parts.length - 1];
        }
      }
      var Cache = function(maxAge) {
        this.maxAge = maxAge;
        this._items = {};
      };
      Cache.prototype = {
        get: function(key) {
          var item = this._items[key];
          var now = new Date().getTime();
          return (item && item.t >= (now - this.maxAge)) ? item.v : undefined;
        },
        set: function(key, value) {
          this._items[key] = {
            v: value,
            t: new Date().getTime()
          };
        }
      };
      RS.GoogleDrive = function(remoteStorage, clientId) {
        RS.eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');
        this.rs = remoteStorage;
        this.clientId = clientId;
        this._fileIdCache = new Cache(60 * 5);
      };
      RS.GoogleDrive.prototype = {
        connected: false,
        online: true,
        configure: function(settings) {
          if (settings.token) {
            localStorage['remotestorage:googledrive:token'] = settings.token;
            this.token = settings.token;
            this.connected = true;
            this._emit('connected');
          } else {
            this.connected = false;
            delete this.token;
            delete localStorage['remotestorage:googledrive:token'];
          }
        },
        connect: function() {
          this.rs.setBackend('googledrive');
          RS.Authorize(AUTH_URL, AUTH_SCOPE, String(RS.Authorize.getLocation()), this.clientId);
        },
        stopWaitingForToken: function() {
          if (!this.connected) {
            this._emit('not-connected');
          }
        },
        get: function(path, options) {
          if (path.substr(-1) === '/') {
            return this._getFolder(path, options);
          } else {
            return this._getFile(path, options);
          }
        },
        put: function(path, body, contentType, options) {
          var self = this;
          function putDone(response) {
            if (response.status >= 200 && response.status < 300) {
              var meta = JSON.parse(response.responseText);
              var etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);
              return Promise.resolve({
                statusCode: 200,
                contentType: meta.mimeType,
                revision: etagWithoutQuotes
              });
            } else if (response.status === 412) {
              return Promise.resolve({
                statusCode: 412,
                revision: 'conflict'
              });
            } else {
              return Promise.reject("PUT failed with status " + response.status + " (" + response.responseText + ")");
            }
          }
          return self._getFileId(path).then(function(id) {
            if (id) {
              if (options && (options.ifNoneMatch === '*')) {
                return putDone({status: 412});
              }
              return self._updateFile(id, path, body, contentType, options).then(putDone);
            } else {
              return self._createFile(path, body, contentType, options).then(putDone);
            }
          });
        },
        'delete': function(path, options) {
          var self = this;
          return self._getFileId(path).then(function(id) {
            if (!id) {
              return Promise.resolve({statusCode: 200});
            }
            return self._getMeta(id).then(function(meta) {
              var etagWithoutQuotes;
              if ((typeof meta === 'object') && (typeof meta.etag === 'string')) {
                etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);
              }
              if (options && options.ifMatch && (options.ifMatch !== etagWithoutQuotes)) {
                return {
                  statusCode: 412,
                  revision: etagWithoutQuotes
                };
              }
              return self._request('DELETE', BASE_URL + '/drive/v2/files/' + id, {}).then(function(response) {
                if (response.status === 200 || response.status === 204) {
                  return {statusCode: 200};
                } else {
                  return Promise.reject("Delete failed: " + response.status + " (" + response.responseText + ")");
                }
              });
            });
          });
        },
        _updateFile: function(id, path, body, contentType, options) {
          var self = this;
          var metadata = {mimeType: contentType};
          var headers = {'Content-Type': 'application/json; charset=UTF-8'};
          if (options && options.ifMatch) {
            headers['If-Match'] = '"' + options.ifMatch + '"';
          }
          return self._request('PUT', BASE_URL + '/upload/drive/v2/files/' + id + '?uploadType=resumable', {
            body: JSON.stringify(metadata),
            headers: headers
          }).then(function(response) {
            if (response.status === 412) {
              return (response);
            } else {
              return self._request('PUT', response.getResponseHeader('Location'), {body: contentType.match(/^application\/json/) ? JSON.stringify(body) : body});
            }
          });
        },
        _createFile: function(path, body, contentType, options) {
          var self = this;
          return self._getParentId(path).then(function(parentId) {
            var fileName = baseName(path);
            var metadata = {
              title: metaTitleFromFileName(fileName),
              mimeType: contentType,
              parents: [{
                kind: "drive#fileLink",
                id: parentId
              }]
            };
            return self._request('POST', BASE_URL + '/upload/drive/v2/files?uploadType=resumable', {
              body: JSON.stringify(metadata),
              headers: {'Content-Type': 'application/json; charset=UTF-8'}
            }).then(function(response) {
              return self._request('POST', response.getResponseHeader('Location'), {body: contentType.match(/^application\/json/) ? JSON.stringify(body) : body});
            });
          });
        },
        _getFile: function(path, options) {
          var self = this;
          return self._getFileId(path).then(function(id) {
            return self._getMeta(id).then(function(meta) {
              var etagWithoutQuotes;
              if (typeof(meta) === 'object' && typeof(meta.etag) === 'string') {
                etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);
              }
              if (options && options.ifNoneMatch && (etagWithoutQuotes === options.ifNoneMatch)) {
                return Promise.resolve({statusCode: 304});
              }
              var options2 = {};
              if (!meta.downloadUrl) {
                if (meta.exportLinks && meta.exportLinks['text/html']) {
                  meta.mimeType += ';export=text/html';
                  meta.downloadUrl = meta.exportLinks['text/html'];
                } else {
                  return Promise.resolve({
                    statusCode: 200,
                    body: '',
                    contentType: meta.mimeType,
                    revision: etagWithoutQuotes
                  });
                }
              }
              if (meta.mimeType.match(/charset=binary/)) {
                options2.responseType = 'blob';
              }
              return self._request('GET', meta.downloadUrl, options2).then(function(response) {
                var body = response.response;
                if (meta.mimeType.match(/^application\/json/)) {
                  try {
                    body = JSON.parse(body);
                  } catch (e) {}
                }
                return Promise.resolve({
                  statusCode: 200,
                  body: body,
                  contentType: meta.mimeType,
                  revision: etagWithoutQuotes
                });
              });
            });
          });
        },
        _getFolder: function(path, options) {
          var self = this;
          return self._getFileId(path).then(function(id) {
            var query,
                fields,
                data,
                i,
                etagWithoutQuotes,
                itemsMap;
            if (!id) {
              return Promise.resolve({statusCode: 404});
            }
            query = '\'' + id + '\' in parents';
            fields = 'items(downloadUrl,etag,fileSize,id,mimeType,title)';
            return self._request('GET', BASE_URL + '/drive/v2/files?' + 'q=' + encodeURIComponent(query) + '&fields=' + encodeURIComponent(fields) + '&maxResults=1000', {}).then(function(response) {
              if (response.status !== 200) {
                return Promise.reject('request failed or something: ' + response.status);
              }
              try {
                data = JSON.parse(response.responseText);
              } catch (e) {
                return Promise.reject('non-JSON response from GoogleDrive');
              }
              itemsMap = {};
              for (var i = 0,
                  len = data.items.length; i < len; i++) {
                etagWithoutQuotes = data.items[i].etag.substring(1, data.items[i].etag.length - 1);
                if (data.items[i].mimeType === GD_DIR_MIME_TYPE) {
                  self._fileIdCache.set(path + data.items[i].title + '/', data.items[i].id);
                  itemsMap[data.items[i].title + '/'] = {ETag: etagWithoutQuotes};
                } else {
                  self._fileIdCache.set(path + data.items[i].title, data.items[i].id);
                  itemsMap[data.items[i].title] = {
                    ETag: etagWithoutQuotes,
                    'Content-Type': data.items[i].mimeType,
                    'Content-Length': data.items[i].fileSize
                  };
                }
              }
              return Promise.resolve({
                statusCode: 200,
                body: itemsMap,
                contentType: RS_DIR_MIME_TYPE,
                revision: undefined
              });
            });
          });
        },
        _getParentId: function(path) {
          var foldername = parentPath(path);
          var self = this;
          return self._getFileId(foldername).then(function(parentId) {
            if (parentId) {
              return Promise.resolve(parentId);
            } else {
              return self._createFolder(foldername);
            }
          });
        },
        _createFolder: function(path) {
          var self = this;
          return self._getParentId(path).then(function(parentId) {
            return self._request('POST', BASE_URL + '/drive/v2/files', {
              body: JSON.stringify({
                title: metaTitleFromFileName(baseName(path)),
                mimeType: GD_DIR_MIME_TYPE,
                parents: [{id: parentId}]
              }),
              headers: {'Content-Type': 'application/json; charset=UTF-8'}
            }).then(function(response) {
              var meta = JSON.parse(response.responseText);
              return Promise.resolve(meta.id);
            });
          });
        },
        _getFileId: function(path) {
          var self = this;
          var id;
          if (path === '/') {
            return Promise.resolve('root');
          } else if ((id = this._fileIdCache.get(path))) {
            return Promise.resolve(id);
          }
          return self._getFolder(parentPath(path)).then(function() {
            id = self._fileIdCache.get(path);
            if (!id) {
              if (path.substr(-1) === '/') {
                return self._createFolder(path).then(function() {
                  return self._getFileId(path);
                });
              } else {
                return Promise.resolve();
              }
              return;
            }
            return Promise.resolve(id);
          });
        },
        _getMeta: function(id) {
          return this._request('GET', BASE_URL + '/drive/v2/files/' + id, {}).then(function(response) {
            if (response.status === 200) {
              return Promise.resolve(JSON.parse(response.responseText));
            } else {
              return Promise.reject("request (getting metadata for " + id + ") failed with status: " + response.status);
            }
          });
        },
        _request: function(method, url, options) {
          var self = this;
          if (!options.headers) {
            options.headers = {};
          }
          options.headers['Authorization'] = 'Bearer ' + self.token;
          return RS.WireClient.request(method, url, options).then(function(xhr) {
            if (xhr && xhr.status === 401) {
              self.connect();
              return;
            }
            return xhr;
          });
        }
      };
      RS.GoogleDrive._rs_init = function(remoteStorage) {
        var config = remoteStorage.apiKeys.googledrive;
        if (config) {
          remoteStorage.googledrive = new RS.GoogleDrive(remoteStorage, config.clientId);
          if (remoteStorage.backend === 'googledrive') {
            remoteStorage._origRemote = remoteStorage.remote;
            remoteStorage.remote = remoteStorage.googledrive;
          }
        }
      };
      RS.GoogleDrive._rs_supported = function(rs) {
        return true;
      };
      RS.GoogleDrive._rs_cleanup = function(remoteStorage) {
        remoteStorage.setBackend(undefined);
        if (remoteStorage._origRemote) {
          remoteStorage.remote = remoteStorage._origRemote;
          delete remoteStorage._origRemote;
        }
      };
    })(this);
    (function(global) {
      var RS = RemoteStorage;
      var hasLocalStorage;
      var AUTH_URL = 'https://www.dropbox.com/1/oauth2/authorize';
      var SETTINGS_KEY = 'remotestorage:dropbox';
      var cleanPath = RS.WireClient.cleanPath;
      function LowerCaseCache(defaultValue) {
        this.defaultValue = defaultValue;
        this._storage = {};
        this.set = this.justSet;
        this.delete = this.justDelete;
      }
      LowerCaseCache.prototype = {
        get: function(key) {
          key = key.toLowerCase();
          var stored = this._storage[key];
          if (typeof stored === 'undefined') {
            stored = this.defaultValue;
            this._storage[key] = stored;
          }
          return stored;
        },
        propagateSet: function(key, value) {
          key = key.toLowerCase();
          if (this._storage[key] === value) {
            return value;
          }
          this._propagate(key, value);
          this._storage[key] = value;
          return value;
        },
        propagateDelete: function(key) {
          key = key.toLowerCase();
          this._propagate(key, this._storage[key]);
          return delete this._storage[key];
        },
        _activatePropagation: function() {
          this.set = this.propagateSet;
          this.delete = this.propagateDelete;
          return true;
        },
        justSet: function(key, value) {
          key = key.toLowerCase();
          this._storage[key] = value;
          return value;
        },
        justDelete: function(key, value) {
          key = key.toLowerCase();
          return delete this._storage[key];
        },
        _propagate: function(key, rev) {
          var folders = key.split('/').slice(0, -1);
          var path = '';
          for (var i = 0,
              len = folders.length; i < len; i++) {
            path += folders[i] + '/';
            if (!rev) {
              rev = this._storage[path] + 1;
            }
            this._storage[path] = rev;
          }
        }
      };
      var onErrorCb;
      RS.Dropbox = function(rs) {
        this.rs = rs;
        this.connected = false;
        this.rs = rs;
        var self = this;
        onErrorCb = function(error) {
          if (error instanceof RemoteStorage.Unauthorized) {
            self.configure({
              userAddress: null,
              href: null,
              storageApi: null,
              token: null,
              options: null
            });
          }
        };
        RS.eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');
        rs.on('error', onErrorCb);
        this.clientId = rs.apiKeys.dropbox.appKey;
        this._revCache = new LowerCaseCache('rev');
        this._itemRefs = {};
        this._metadataCache = {};
        if (hasLocalStorage) {
          var settings;
          try {
            settings = JSON.parse(localStorage[SETTINGS_KEY]);
          } catch (e) {}
          if (settings) {
            this.configure(settings);
          }
          try {
            this._itemRefs = JSON.parse(localStorage[SETTINGS_KEY + ':shares']);
          } catch (e) {}
        }
        if (this.connected) {
          setTimeout(this._emit.bind(this), 0, 'connected');
        }
      };
      RS.Dropbox.prototype = {
        online: true,
        connect: function() {
          this.rs.setBackend('dropbox');
          if (this.token) {
            hookIt(this.rs);
          } else {
            RS.Authorize(AUTH_URL, '', String(RS.Authorize.getLocation()), this.clientId);
          }
        },
        configure: function(settings) {
          if (typeof settings.userAddress !== 'undefined') {
            this.userAddress = settings.userAddress;
          }
          if (typeof settings.token !== 'undefined') {
            this.token = settings.token;
          }
          if (this.token) {
            this.connected = true;
            if (!this.userAddress) {
              this.info().then(function(info) {
                this.userAddress = info.display_name;
                this.rs.widget.view.setUserAddress(this.userAddress);
                this._emit('connected');
              }.bind(this));
            }
          } else {
            this.connected = false;
          }
          if (hasLocalStorage) {
            localStorage[SETTINGS_KEY] = JSON.stringify({
              userAddress: this.userAddress,
              token: this.token
            });
          }
        },
        stopWaitingForToken: function() {
          if (!this.connected) {
            this._emit('not-connected');
          }
        },
        _getFolder: function(path, options) {
          var url = 'https://api.dropbox.com/1/metadata/auto' + cleanPath(path);
          var revCache = this._revCache;
          var self = this;
          return this._request('GET', url, {}).then(function(resp) {
            var status = resp.status;
            if (status === 304) {
              return Promise.resolve({statusCode: status});
            }
            var listing,
                body,
                mime,
                rev;
            try {
              body = JSON.parse(resp.responseText);
            } catch (e) {
              return Promise.reject(e);
            }
            rev = self._revCache.get(path);
            mime = 'application/json; charset=UTF-8';
            if (body.contents) {
              listing = body.contents.reduce(function(m, item) {
                var itemName = item.path.split('/').slice(-1)[0] + (item.is_dir ? '/' : '');
                if (item.is_dir) {
                  m[itemName] = {ETag: revCache.get(path + itemName)};
                } else {
                  m[itemName] = {ETag: item.rev};
                }
                return m;
              }, {});
            }
            return Promise.resolve({
              statusCode: status,
              body: listing,
              contentType: mime,
              revision: rev
            });
          });
        },
        get: function(path, options) {
          if (!this.connected) {
            return Promise.reject("not connected (path: " + path + ")");
          }
          var url = 'https://api-content.dropbox.com/1/files/auto' + cleanPath(path);
          var self = this;
          var savedRev = this._revCache.get(path);
          if (savedRev === null) {
            return Promise.resolve({statusCode: 404});
          }
          if (options && options.ifNoneMatch && savedRev && (savedRev === options.ifNoneMatch)) {
            return Promise.resolve({statusCode: 304});
          }
          if (path.substr(-1) === '/') {
            return this._getFolder(path, options);
          }
          return this._request('GET', url, {}).then(function(resp) {
            var status = resp.status;
            var meta,
                body,
                mime,
                rev;
            if (status !== 200) {
              return Promise.resolve({statusCode: status});
            }
            body = resp.responseText;
            try {
              meta = JSON.parse(resp.getResponseHeader('x-dropbox-metadata'));
            } catch (e) {
              return Promise.reject(e);
            }
            mime = meta.mime_type;
            rev = meta.rev;
            self._revCache.set(path, rev);
            self._shareIfNeeded(path);
            if (!resp.getResponseHeader('Content-Type') || resp.getResponseHeader('Content-Type').match(/charset=binary/)) {
              var pending = Promise.defer();
              RS.WireClient.readBinaryData(resp.response, mime, function(result) {
                pending.resolve({
                  statusCode: status,
                  body: result,
                  contentType: mime,
                  revision: rev
                });
              });
              return pending.promise;
            }
            if (mime && mime.search('application/json') >= 0 || true) {
              try {
                body = JSON.parse(body);
                mime = 'application/json; charset=UTF-8';
              } catch (e) {}
            }
            return Promise.resolve({
              statusCode: status,
              body: body,
              contentType: mime,
              revision: rev
            });
          });
        },
        put: function(path, body, contentType, options) {
          var self = this;
          if (!this.connected) {
            throw new Error("not connected (path: " + path + ")");
          }
          var savedRev = this._revCache.get(path);
          if (options && options.ifMatch && savedRev && (savedRev !== options.ifMatch)) {
            return Promise.resolve({
              statusCode: 412,
              revision: savedRev
            });
          }
          if (options && (options.ifNoneMatch === '*') && savedRev && (savedRev !== 'rev')) {
            return Promise.resolve({
              statusCode: 412,
              revision: savedRev
            });
          }
          if ((!contentType.match(/charset=/)) && (body instanceof ArrayBuffer || RS.WireClient.isArrayBufferView(body))) {
            contentType += '; charset=binary';
          }
          if (body.length > 150 * 1024 * 1024) {
            return Promise.reject(new Error("Cannot upload file larger than 150MB"));
          }
          var result;
          var needsMetadata = options && (options.ifMatch || (options.ifNoneMatch === '*'));
          var uploadParams = {
            body: body,
            contentType: contentType,
            path: path
          };
          if (needsMetadata) {
            result = this._getMetadata(path).then(function(metadata) {
              if (options && (options.ifNoneMatch === '*') && metadata) {
                return Promise.resolve({
                  statusCode: 412,
                  revision: metadata.rev
                });
              }
              if (options && options.ifMatch && metadata && (metadata.rev !== options.ifMatch)) {
                return Promise.resolve({
                  statusCode: 412,
                  revision: metadata.rev
                });
              }
              return self._uploadSimple(uploadParams);
            });
          } else {
            result = self._uploadSimple(uploadParams);
          }
          return result.then(function(ret) {
            self._shareIfNeeded(path);
            return ret;
          });
        },
        'delete': function(path, options) {
          var self = this;
          if (!this.connected) {
            throw new Error("not connected (path: " + path + ")");
          }
          var savedRev = this._revCache.get(path);
          if (options && options.ifMatch && savedRev && (options.ifMatch !== savedRev)) {
            return Promise.resolve({
              statusCode: 412,
              revision: savedRev
            });
          }
          if (options && options.ifMatch) {
            return this._getMetadata(path).then(function(metadata) {
              if (options && options.ifMatch && metadata && (metadata.rev !== options.ifMatch)) {
                return Promise.resolve({
                  statusCode: 412,
                  revision: metadata.rev
                });
              }
              return self._deleteSimple(path);
            });
          }
          return self._deleteSimple(path);
        },
        _shareIfNeeded: function(path) {
          if (path.match(/^\/public\/.*[^\/]$/) && this._itemRefs[path] === undefined) {
            this.share(path);
          }
        },
        share: function(path) {
          var self = this;
          var url = 'https://api.dropbox.com/1/media/auto/' + cleanPath(path);
          return this._request('POST', url, {}).then(function(response) {
            if (response.status !== 200) {
              return Promise.reject(new Error('Invalid Dropbox API response status when sharing "' + path + '":' + response.status));
            }
            try {
              response = JSON.parse(response.responseText);
            } catch (e) {
              return Promise.reject(new Error('Invalid Dropbox API response when sharing "' + path + '": ' + response.responseText));
            }
            self._itemRefs[path] = response.url;
            if (hasLocalStorage) {
              localStorage[SETTINGS_KEY + ':shares'] = JSON.stringify(self._itemRefs);
            }
            return Promise.resolve(url);
          }, function(error) {
            err.message = 'Sharing dropbox file or folder ("' + path + '") failed.' + err.message;
            return Promise.reject(error);
          });
        },
        info: function() {
          var url = 'https://api.dropbox.com/1/account/info';
          return this._request('GET', url, {}).then(function(resp) {
            try {
              var info = JSON.parse(resp.responseText);
              return Promise.resolve(info);
            } catch (e) {
              return Promise.reject(e);
            }
          });
        },
        _request: function(method, url, options) {
          var self = this;
          if (!options.headers) {
            options.headers = {};
          }
          options.headers['Authorization'] = 'Bearer ' + this.token;
          return RS.WireClient.request.call(this, method, url, options).then(function(xhr) {
            if (xhr && xhr.status === 503) {
              return global.setTimeout(self._request(method, url, options), 3210);
            } else {
              return Promise.resolve(xhr);
            }
          });
        },
        fetchDelta: function() {
          var args = Array.prototype.slice.call(arguments);
          var self = this;
          return self._request('POST', 'https://api.dropbox.com/1/delta', {
            body: self._deltaCursor ? ('cursor=' + encodeURIComponent(self._deltaCursor)) : '',
            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
          }).then(function(response) {
            if (response.status !== 200) {
              if (response.status === 400) {
                self.rs._emit('error', new RemoteStorage.Unauthorized());
                return Promise.resolve(args);
              } else {
                return Promise.reject("dropbox.fetchDelta returned " + response.status + response.responseText);
              }
              return;
            }
            var delta;
            try {
              delta = JSON.parse(response.responseText);
            } catch (error) {
              RS.log('fetchDeltas can not parse response', error);
              return Promise.reject("can not parse response of fetchDelta : " + error.message);
            }
            if (!delta.entries) {
              return Promise.reject('dropbox.fetchDeltas failed, no entries found');
            }
            if (delta.reset) {
              self._revCache = new LowerCaseCache('rev');
            }
            if (delta.cursor) {
              self._deltaCursor = delta.cursor;
            }
            RemoteStorage.log("Delta : ", delta.entries);
            delta.entries.forEach(function(entry) {
              var path = entry[0];
              var rev;
              if (!entry[1]) {
                rev = null;
              } else {
                if (entry[1].is_dir) {
                  return;
                }
                rev = entry[1].rev;
              }
              self._revCache.set(path, rev);
            });
            return Promise.resolve(args);
          }, function(err) {
            this.rs.log('fetchDeltas', err);
            this.rs._emit('error', new RemoteStorage.SyncError('fetchDeltas failed.' + err));
            promise.reject(err);
          }).then(function() {
            if (self._revCache) {
              var args = Array.prototype.slice.call(arguments);
              self._revCache._activatePropagation();
              return Promise.resolve(args);
            }
          });
        },
        _getMetadata: function(path, options) {
          var self = this;
          var cached = this._metadataCache[path];
          var url = 'https://api.dropbox.com/1/metadata/auto' + cleanPath(path);
          url += '?list=' + ((options && options.list) ? 'true' : 'false');
          if (cached && cached.hash) {
            url += '&hash=' + encodeURIComponent(cached.hash);
          }
          return this._request('GET', url, {}).then(function(resp) {
            if (resp.status === 304) {
              return Promise.resolve(cached);
            } else if (resp.status === 200) {
              var response = JSON.parse(resp.responseText);
              self._metadataCache[path] = response;
              return Promise.resolve(response);
            } else {
              return Promise.resolve();
            }
          });
        },
        _uploadSimple: function(params) {
          var self = this;
          var url = 'https://api-content.dropbox.com/1/files_put/auto' + cleanPath(params.path) + '?';
          if (params && params.ifMatch) {
            url += "parent_rev=" + encodeURIComponent(params.ifMatch);
          }
          return self._request('PUT', url, {
            body: params.body,
            headers: {'Content-Type': params.contentType}
          }).then(function(resp) {
            if (resp.status !== 200) {
              return Promise.resolve({statusCode: resp.status});
            }
            var response;
            try {
              response = JSON.parse(resp.responseText);
            } catch (e) {
              return Promise.reject(e);
            }
            if (response.path !== params.path) {
              var deleteUrl = 'https://api.dropbox.com/1/fileops/delete?root=auto&path=' + encodeURIComponent(response.path);
              self._request('POST', deleteUrl, {});
              return self._getMetadata(params.path).then(function(metadata) {
                return Promise.resolve({
                  statusCode: 412,
                  revision: metadata.rev
                });
              });
            }
            self._revCache.propagateSet(params.path, response.rev);
            return Promise.resolve({statusCode: resp.status});
          });
        },
        _deleteSimple: function(path) {
          var self = this;
          var url = 'https://api.dropbox.com/1/fileops/delete?root=auto&path=' + encodeURIComponent(path);
          return self._request('POST', url, {}).then(function(resp) {
            if (resp.status === 406) {
              return Promise.reject(new Error("Cannot delete '" + path + "': too many files involved"));
            }
            if (resp.status === 200) {
              self._revCache.delete(path);
              delete self._itemRefs[path];
            }
            return Promise.resolve({statusCode: resp.status});
          });
        }
      };
      function hookSync(rs) {
        if (rs._dropboxOrigSync) {
          return;
        }
        rs._dropboxOrigSync = rs.sync.bind(rs);
        rs.sync = function() {
          return this.dropbox.fetchDelta.apply(this.dropbox, arguments).then(rs._dropboxOrigSync, function(err) {
            rs._emit('error', new rs.SyncError(err));
          });
        };
      }
      function unHookSync(rs) {
        if (!rs._dropboxOrigSync) {
          return;
        }
        rs.sync = rs._dropboxOrigSync;
        delete rs._dropboxOrigSync;
      }
      function hookGetItemURL(rs) {
        if (rs._origBaseClientGetItemURL) {
          return;
        }
        rs._origBaseClientGetItemURL = RS.BaseClient.prototype.getItemURL;
        RS.BaseClient.prototype.getItemURL = function(path) {
          var ret = rs.dropbox._itemRefs[path];
          return ret ? ret : '';
        };
      }
      function unHookGetItemURL(rs) {
        if (!rs._origBaseClientGetItemURL) {
          return;
        }
        RS.BaseClient.prototype.getItemURL = rs._origBaseClientGetItemURL;
        delete rs._origBaseClientGetItemURL;
      }
      function hookRemote(rs) {
        if (rs._origRemote) {
          return;
        }
        rs._origRemote = rs.remote;
        rs.remote = rs.dropbox;
      }
      function unHookRemote(rs) {
        if (rs._origRemote) {
          rs.remote = rs._origRemote;
          delete rs._origRemote;
        }
      }
      function hookIt(rs) {
        hookRemote(rs);
        if (rs.sync) {
          hookSync(rs);
        }
        hookGetItemURL(rs);
      }
      function unHookIt(rs) {
        unHookRemote(rs);
        unHookSync(rs);
        unHookGetItemURL(rs);
      }
      RS.Dropbox._rs_init = function(rs) {
        hasLocalStorage = rs.localStorageAvailable();
        if (rs.apiKeys.dropbox) {
          rs.dropbox = new RS.Dropbox(rs);
        }
        if (rs.backend === 'dropbox') {
          hookIt(rs);
        }
      };
      RS.Dropbox._rs_supported = function() {
        return true;
      };
      RS.Dropbox._rs_cleanup = function(rs) {
        unHookIt(rs);
        if (hasLocalStorage) {
          delete localStorage[SETTINGS_KEY];
        }
        rs.removeEventListener('error', onErrorCb);
        rs.setBackend(undefined);
      };
    })(this);
    remoteStorage = new RemoteStorage();
    this["CHARS"] = CHARS;
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:remotestoragejs@0.12.1", ["npm:remotestoragejs@0.12.1/release/stable/remotestorage"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('npm:remotestoragejs@0.12.1/release/stable/remotestorage');
  global.define = __define;
  return module.exports;
});

System.register('libraries/remote-storage/remote-storage.js', ['github:angular/bower-angular@1.4.7', 'npm:remotestoragejs@0.12.1'], function (_export) {
  'use strict';

  var angular, remoteStorage;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_npmRemotestoragejs0121) {
      remoteStorage = _npmRemotestoragejs0121['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.remote-storage', []).factory('remoteStorage', /*@ngInject*/function () {
        return remoteStorage.remoteStorage;
      }));
    }
  };
});

System.registerDynamic("libraries/telehash/telehash-library.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "telehash", null);
  (function() {
    "format global";
    "exports telehash";
    (function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == "function" && require;
            if (!u && a)
              return a(o, !0);
            if (i)
              return i(o, !0);
            throw new Error("Cannot find module '" + o + "'");
          }
          var f = n[o] = {exports: {}};
          t[o][0].call(f.exports, function(e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == "function" && require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    })({
      1: [function(require, module, exports) {
        if (typeof window !== "undefined") {
          window.telehash = require('telehash');
        }
      }, {"telehash": 2}],
      2: [function(require, module, exports) {
        var thjs = require("telehash-js");
        exports.debug = thjs.debug;
        exports.info = thjs.info;
        exports.init = function(args, cbDone) {
          if (!args)
            args = {};
          var self = new thjs.switch();
          require("telehash-cs1a").install(self, args);
          if (args.cs2a)
            require("telehash-cs2a").install(self, args);
          require("telehash-http").install(self, args);
          require("telehash-webrtc").install(self, args);
          require("telehash-stream").install(self, args);
          require("telehash-telesocket").install(self, args);
          require("telehash-thtp").install(self, args);
          require("telehash-token").install(self, args);
          function seed() {
            require("telehash-seeds").install(self, args);
            self.online(function(err) {
              cbDone(err, self);
            });
            return self;
          }
          if (args.id) {
            if (typeof args.id == "string" && localStorage && localStorage.getItem(args.id))
              args.id = JSON.parse(localStorage.getItem(args.id));
            if (typeof args.id == "object") {
              var err;
              if ((err = self.load(args.id)))
                return cbDone("error loading id, " + err + ": " + JSON.stringify(args.id));
              return seed();
            }
          }
          self.make(function(err, id) {
            if (err)
              return cbDone("error creating id, " + err);
            if (typeof args.id == "string" && localStorage)
              localStorage.setItem(args.id, JSON.stringify(id));
            args.id = id;
            self.load(id);
            return seed();
          });
          return self;
        };
      }, {
        "telehash-cs1a": 3,
        "telehash-cs2a": 10,
        "telehash-http": 18,
        "telehash-js": 20,
        "telehash-seeds": 21,
        "telehash-stream": 23,
        "telehash-telesocket": 24,
        "telehash-thtp": 25,
        "telehash-token": 26,
        "telehash-webrtc": 27
      }],
      3: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var cs1a = require("./cs1a.js");
          var ecc = require("ecc-jsbn");
          require("./forge.min.js");
          cs1a.crypt(ecc, function(enc, key, iv, body) {
            var cipher = enc ? forge.aes.createEncryptionCipher(key.toString("binary"), "CTR") : forge.aes.createDecryptionCipher(key.toString("binary"), "CTR");
            cipher.start(iv.toString("binary"));
            cipher.update(forge.util.createBuffer(body.toString('binary')));
            cipher.finish();
            return new Buffer(cipher.output.getBytes(), "binary");
          });
          Object.keys(cs1a).forEach(function(f) {
            exports[f] = cs1a[f];
          });
        }).call(this, require("buffer").Buffer);
      }, {
        "./cs1a.js": 4,
        "./forge.min.js": 5,
        "buffer": 29,
        "crypto": 35,
        "ecc-jsbn": 6
      }],
      4: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var self;
          exports.install = function(telehash) {
            self = telehash;
            telehash.CSets["1a"] = exports;
          };
          exports.crypt = function(ecc, aes) {
            crypto.ecc = ecc;
            crypto.aes = aes;
          };
          function fold(count, buf) {
            if (!count || buf.length % 2)
              return buf;
            var ret = buf.slice(0, buf.length / 2);
            for (i = 0; i < ret.length; i++)
              ret[i] = ret[i] ^ buf[i + ret.length];
            return fold(count - 1, ret);
          }
          exports.genkey = function(ret, cbDone, cbStep) {
            var k = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1);
            ret["1a"] = k.PublicKey.slice(1).toString("base64");
            ret["1a_secret"] = k.PrivateKey.toString("base64");
            cbDone();
          };
          exports.loadkey = function(id, pub, priv) {
            if (typeof pub == "string")
              pub = new Buffer(pub, "base64");
            if (!Buffer.isBuffer(pub) || pub.length != 40)
              return "invalid public key";
            id.key = pub;
            id.public = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04", "hex"), id.key]), true);
            if (!id.public)
              return "public key load failed";
            if (priv) {
              if (typeof priv == "string")
                priv = new Buffer(priv, "base64");
              if (!Buffer.isBuffer(priv) || priv.length != 20)
                return "invalid private key";
              id.private = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, priv);
              if (!id.private)
                return "private key load failed";
            }
            return false;
          };
          exports.openize = function(id, to, inner) {
            if (!to.ecc)
              to.ecc = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1);
            var eccpub = to.ecc.PublicKey.slice(1);
            var secret = to.ecc.deriveSharedSecret(to.public);
            var key = fold(1, crypto.createHash("sha256").update(secret).digest());
            var iv = new Buffer("00000000000000000000000000000001", "hex");
            var body = (!Buffer.isBuffer(inner)) ? self.pencode(inner, id.cs["1a"].key) : inner;
            var cbody = crypto.aes(true, key, iv, body);
            var secret = id.cs["1a"].private.deriveSharedSecret(to.public);
            var macd = Buffer.concat([eccpub, cbody]);
            var hmac = fold(3, crypto.createHmac("sha256", secret).update(macd).digest());
            var body = Buffer.concat([hmac, macd]);
            return self.pencode(0x1a, body);
          }, exports.deopenize = function(id, open) {
            var ret = {verify: false};
            if (!open.body)
              return ret;
            var mac1 = open.body.slice(0, 4).toString("hex");
            var pub = open.body.slice(4, 44);
            var cbody = open.body.slice(44);
            try {
              ret.linepub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04", "hex"), pub]), true);
            } catch (E) {
              console.log("ecc err", E);
            }
            if (!ret.linepub)
              return ret;
            var secret = id.cs["1a"].private.deriveSharedSecret(ret.linepub);
            var key = fold(1, crypto.createHash("sha256").update(secret).digest());
            var iv = new Buffer("00000000000000000000000000000001", "hex");
            var body = crypto.aes(false, key, iv, cbody);
            var inner = self.pdecode(body);
            if (!inner)
              return ret;
            ret.inner = inner;
            var epub;
            if (!open.from) {
              epub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04", "hex"), inner.body]), true);
              if (!epub)
                return ret;
              ret.key = inner.body;
            } else {
              epub = open.from.public;
            }
            var secret = id.cs["1a"].private.deriveSharedSecret(epub);
            var mac2 = fold(3, crypto.createHmac("sha256", secret).update(open.body.slice(4)).digest()).toString("hex");
            if (mac2 != mac1)
              return ret;
            ret.verify = true;
            ret.js = inner.js;
            return ret;
          }, exports.openline = function(from, open) {
            from.lineIV = crypto.randomBytes(4).readUInt32LE(0);
            from.lineInB = new Buffer(from.lineIn, "hex");
            var ecdhe = from.ecc.deriveSharedSecret(open.linepub);
            from.encKey = fold(1, crypto.createHash("sha256").update(ecdhe).update(new Buffer(from.lineOut, "hex")).update(from.lineInB).digest());
            from.decKey = fold(1, crypto.createHash("sha256").update(ecdhe).update(from.lineInB).update(new Buffer(from.lineOut, "hex")).digest());
            return true;
          }, exports.lineize = function(to, packet) {
            var iv = new Buffer(16);
            iv.fill(0);
            iv.writeUInt32LE(to.lineIV++, 12);
            var cbody = crypto.aes(true, to.encKey, iv, self.pencode(packet.js, packet.body));
            var mac = fold(3, crypto.createHmac("sha256", to.encKey).update(Buffer.concat([iv.slice(12), cbody])).digest());
            var body = Buffer.concat([to.lineInB, mac, iv.slice(12), cbody]);
            return self.pencode(null, body);
          }, exports.delineize = function(from, packet) {
            if (!packet.body)
              return "no body";
            packet.body = packet.body.slice(16);
            var mac1 = packet.body.slice(0, 4).toString("hex");
            var mac2 = fold(3, crypto.createHmac("sha256", from.decKey).update(packet.body.slice(4)).digest()).toString("hex");
            if (mac1 != mac2)
              return "invalid hmac";
            var iv = packet.body.slice(4, 8);
            var ivz = new Buffer(12);
            ivz.fill(0);
            var body = packet.body.slice(8);
            var deciphered = self.pdecode(crypto.aes(false, from.decKey, Buffer.concat([ivz, iv]), body));
            if (!deciphered)
              return "invalid decrypted packet";
            packet.js = deciphered.js;
            packet.body = deciphered.body;
            return false;
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "crypto": 35
      }],
      5: [function(require, module, exports) {
        (function(process) {
          (function() {
            var e,
                t,
                n;
            (function(r) {
              function d(e, t) {
                return h.call(e, t);
              }
              function v(e, t) {
                var n,
                    r,
                    i,
                    s,
                    o,
                    u,
                    a,
                    f,
                    c,
                    h,
                    p,
                    v = t && t.split("/"),
                    m = l.map,
                    g = /\.js$/,
                    y = m && m["*"] || {};
                if (e && e.charAt(0) === ".")
                  if (t) {
                    v = v.slice(0, v.length - 1), e = e.split("/"), o = e.length - 1, l.pkgs && d(l.pkgs, v[0]) && g.test(e[o]) && (e[o] = e[o].replace(g, "")), e = v.concat(e);
                    for (c = 0; c < e.length; c += 1) {
                      p = e[c];
                      if (p === ".")
                        e.splice(c, 1), c -= 1;
                      else if (p === "..") {
                        if (c === 1 && (e[2] === ".." || e[0] === ".."))
                          break;
                        c > 0 && (e.splice(c - 1, 2), c -= 2);
                      }
                    }
                    e = e.join("/");
                  } else
                    e.indexOf("./") === 0 && (e = e.substring(2));
                if ((v || y) && m) {
                  n = e.split("/");
                  for (c = n.length; c > 0; c -= 1) {
                    r = n.slice(0, c).join("/");
                    if (v)
                      for (h = v.length; h > 0; h -= 1) {
                        i = m[v.slice(0, h).join("/")];
                        if (i) {
                          i = i[r];
                          if (i) {
                            s = i, u = c;
                            break;
                          }
                        }
                      }
                    if (s)
                      break;
                    !a && y && y[r] && (a = y[r], f = c);
                  }
                  !s && a && (s = a, u = f), s && (n.splice(0, u, s), e = n.join("/"));
                }
                return e;
              }
              function m(e, t) {
                return function() {
                  return s.apply(r, p.call(arguments, 0).concat([e, t]));
                };
              }
              function g(e) {
                return function(t) {
                  return v(t, e);
                };
              }
              function y(e) {
                return function(t) {
                  a[e] = t;
                };
              }
              function b(e) {
                if (d(f, e)) {
                  var t = f[e];
                  delete f[e], c[e] = !0, i.apply(r, t);
                }
                if (!d(a, e) && !d(c, e))
                  throw new Error("No " + e);
                return a[e];
              }
              function w(e) {
                var t,
                    n = e ? e.indexOf("!") : -1;
                return n > -1 && (t = e.substring(0, n), e = e.substring(n + 1, e.length)), [t, e];
              }
              function E(e) {
                return function() {
                  return l && l.config && l.config[e] || {};
                };
              }
              var i,
                  s,
                  o,
                  u,
                  a = {},
                  f = {},
                  l = {},
                  c = {},
                  h = Object.prototype.hasOwnProperty,
                  p = [].slice;
              o = function(e, t) {
                var n,
                    r = w(e),
                    i = r[0];
                return e = r[1], i && (i = v(i, t), n = b(i)), i ? n && n.normalize ? e = n.normalize(e, g(t)) : e = v(e, t) : (e = v(e, t), r = w(e), i = r[0], e = r[1], i && (n = b(i))), {
                  f: i ? i + "!" + e : e,
                  n: e,
                  pr: i,
                  p: n
                };
              }, u = {
                require: function(e) {
                  return m(e);
                },
                exports: function(e) {
                  var t = a[e];
                  return typeof t != "undefined" ? t : a[e] = {};
                },
                module: function(e) {
                  return {
                    id: e,
                    uri: "",
                    exports: a[e],
                    config: E(e)
                  };
                }
              }, i = function(e, t, n, i) {
                var s,
                    l,
                    h,
                    p,
                    v,
                    g = [],
                    w = typeof n,
                    E;
                i = i || e;
                if (w === "undefined" || w === "function") {
                  t = !t.length && n.length ? ["require", "exports", "module"] : t;
                  for (v = 0; v < t.length; v += 1) {
                    p = o(t[v], i), l = p.f;
                    if (l === "require")
                      g[v] = u.require(e);
                    else if (l === "exports")
                      g[v] = u.exports(e), E = !0;
                    else if (l === "module")
                      s = g[v] = u.module(e);
                    else if (d(a, l) || d(f, l) || d(c, l))
                      g[v] = b(l);
                    else {
                      if (!p.p)
                        throw new Error(e + " missing " + l);
                      p.p.load(p.n, m(i, !0), y(l), {}), g[v] = a[l];
                    }
                  }
                  h = n ? n.apply(a[e], g) : undefined;
                  if (e)
                    if (s && s.exports !== r && s.exports !== a[e])
                      a[e] = s.exports;
                    else if (h !== r || !E)
                      a[e] = h;
                } else
                  e && (a[e] = n);
              }, e = t = s = function(e, t, n, a, f) {
                var c,
                    h;
                if (typeof e == "string")
                  return u[e] ? u[e](t) : b(o(e, t).f);
                if (!e.splice) {
                  l = e, l.deps && s(l.deps, l.callback), h = l.packages;
                  if (l.packages) {
                    l.pkgs = {};
                    for (c = 0; c < h.length; c++)
                      l.pkgs[h[c].name || h[c]] = !0;
                  }
                  if (!t)
                    return;
                  t.splice ? (e = t, t = n, n = null) : e = r;
                }
                return t = t || function() {}, typeof n == "function" && (n = a, a = f), a ? i(r, e, t, n) : setTimeout(function() {
                  i(r, e, t, n);
                }, 4), s;
              }, s.config = function(e) {
                return s(e);
              }, e._defined = a, n = function(e, t, n) {
                t.splice || (n = t, t = []), !d(a, e) && !d(f, e) && (f[e] = [e, t, n]);
              }, n.amd = {jQuery: !0};
            })(), n("node_modules/almond/almond", function() {}), function() {
              function e(e) {
                var t = e.util = e.util || {};
                typeof process == "undefined" || !process.nextTick ? typeof setImmediate == "function" ? (t.setImmediate = setImmediate, t.nextTick = function(e) {
                  return setImmediate(e);
                }) : (t.setImmediate = function(e) {
                  setTimeout(e, 0);
                }, t.nextTick = t.setImmediate) : (t.nextTick = process.nextTick, typeof setImmediate == "function" ? t.setImmediate = setImmediate : t.setImmediate = t.nextTick), t.isArray = Array.isArray || function(e) {
                  return Object.prototype.toString.call(e) === "[object Array]";
                }, t.isArrayBuffer = function(e) {
                  return typeof ArrayBuffer != "undefined" && e instanceof ArrayBuffer;
                };
                var n = [];
                typeof Int8Array != "undefined" && n.push(Int8Array), typeof Uint8Array != "undefined" && n.push(Uint8Array), typeof Uint8ClampedArray != "undefined" && n.push(Uint8ClampedArray), typeof Int16Array != "undefined" && n.push(Int16Array), typeof Uint16Array != "undefined" && n.push(Uint16Array), typeof Int32Array != "undefined" && n.push(Int32Array), typeof Uint32Array != "undefined" && n.push(Uint32Array), typeof Float32Array != "undefined" && n.push(Float32Array), typeof Float64Array != "undefined" && n.push(Float64Array), t.isArrayBufferView = function(e) {
                  for (var t = 0; t < n.length; ++t)
                    if (e instanceof n[t])
                      return !0;
                  return !1;
                }, t.ByteBuffer = function(e) {
                  this.data = "", this.read = 0;
                  if (typeof e == "string")
                    this.data = e;
                  else if (t.isArrayBuffer(e) || t.isArrayBufferView(e)) {
                    var n = new Uint8Array(e);
                    try {
                      this.data = String.fromCharCode.apply(null, n);
                    } catch (r) {
                      for (var i = 0; i < n.length; ++i)
                        this.putByte(n[i]);
                    }
                  }
                }, t.ByteBuffer.prototype.length = function() {
                  return this.data.length - this.read;
                }, t.ByteBuffer.prototype.isEmpty = function() {
                  return this.length() <= 0;
                }, t.ByteBuffer.prototype.putByte = function(e) {
                  return this.data += String.fromCharCode(e), this;
                }, t.ByteBuffer.prototype.fillWithByte = function(e, t) {
                  e = String.fromCharCode(e);
                  var n = this.data;
                  while (t > 0)
                    t & 1 && (n += e), t >>>= 1, t > 0 && (e += e);
                  return this.data = n, this;
                }, t.ByteBuffer.prototype.putBytes = function(e) {
                  return this.data += e, this;
                }, t.ByteBuffer.prototype.putString = function(e) {
                  return this.data += t.encodeUtf8(e), this;
                }, t.ByteBuffer.prototype.putInt16 = function(e) {
                  return this.data += String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255), this;
                }, t.ByteBuffer.prototype.putInt24 = function(e) {
                  return this.data += String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255), this;
                }, t.ByteBuffer.prototype.putInt32 = function(e) {
                  return this.data += String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255), this;
                }, t.ByteBuffer.prototype.putInt16Le = function(e) {
                  return this.data += String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255), this;
                }, t.ByteBuffer.prototype.putInt24Le = function(e) {
                  return this.data += String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255), this;
                }, t.ByteBuffer.prototype.putInt32Le = function(e) {
                  return this.data += String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 24 & 255), this;
                }, t.ByteBuffer.prototype.putInt = function(e, t) {
                  do
                    t -= 8, this.data += String.fromCharCode(e >> t & 255);
 while (t > 0);
                  return this;
                }, t.ByteBuffer.prototype.putSignedInt = function(e, t) {
                  return e < 0 && (e += 2 << t - 1), this.putInt(e, t);
                }, t.ByteBuffer.prototype.putBuffer = function(e) {
                  return this.data += e.getBytes(), this;
                }, t.ByteBuffer.prototype.getByte = function() {
                  return this.data.charCodeAt(this.read++);
                }, t.ByteBuffer.prototype.getInt16 = function() {
                  var e = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
                  return this.read += 2, e;
                }, t.ByteBuffer.prototype.getInt24 = function() {
                  var e = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
                  return this.read += 3, e;
                }, t.ByteBuffer.prototype.getInt32 = function() {
                  var e = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
                  return this.read += 4, e;
                }, t.ByteBuffer.prototype.getInt16Le = function() {
                  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
                  return this.read += 2, e;
                }, t.ByteBuffer.prototype.getInt24Le = function() {
                  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
                  return this.read += 3, e;
                }, t.ByteBuffer.prototype.getInt32Le = function() {
                  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
                  return this.read += 4, e;
                }, t.ByteBuffer.prototype.getInt = function(e) {
                  var t = 0;
                  do
                    t = (t << 8) + this.data.charCodeAt(this.read++), e -= 8;
 while (e > 0);
                  return t;
                }, t.ByteBuffer.prototype.getSignedInt = function(e) {
                  var t = this.getInt(e),
                      n = 2 << e - 2;
                  return t >= n && (t -= n << 1), t;
                }, t.ByteBuffer.prototype.getBytes = function(e) {
                  var t;
                  return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : e === 0 ? t = "" : (t = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), t;
                }, t.ByteBuffer.prototype.bytes = function(e) {
                  return typeof e == "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e);
                }, t.ByteBuffer.prototype.at = function(e) {
                  return this.data.charCodeAt(this.read + e);
                }, t.ByteBuffer.prototype.setAt = function(e, t) {
                  return this.data = this.data.substr(0, this.read + e) + String.fromCharCode(t) + this.data.substr(this.read + e + 1), this;
                }, t.ByteBuffer.prototype.last = function() {
                  return this.data.charCodeAt(this.data.length - 1);
                }, t.ByteBuffer.prototype.copy = function() {
                  var e = t.createBuffer(this.data);
                  return e.read = this.read, e;
                }, t.ByteBuffer.prototype.compact = function() {
                  return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
                }, t.ByteBuffer.prototype.clear = function() {
                  return this.data = "", this.read = 0, this;
                }, t.ByteBuffer.prototype.truncate = function(e) {
                  var t = Math.max(0, this.length() - e);
                  return this.data = this.data.substr(this.read, t), this.read = 0, this;
                }, t.ByteBuffer.prototype.toHex = function() {
                  var e = "";
                  for (var t = this.read; t < this.data.length; ++t) {
                    var n = this.data.charCodeAt(t);
                    n < 16 && (e += "0"), e += n.toString(16);
                  }
                  return e;
                }, t.ByteBuffer.prototype.toString = function() {
                  return t.decodeUtf8(this.bytes());
                }, t.createBuffer = function(e, n) {
                  return n = n || "raw", e !== undefined && n === "utf8" && (e = t.encodeUtf8(e)), new t.ByteBuffer(e);
                }, t.fillString = function(e, t) {
                  var n = "";
                  while (t > 0)
                    t & 1 && (n += e), t >>>= 1, t > 0 && (e += e);
                  return n;
                }, t.xorBytes = function(e, t, n) {
                  var r = "",
                      i = "",
                      s = "",
                      o = 0,
                      u = 0;
                  for (; n > 0; --n, ++o)
                    i = e.charCodeAt(o) ^ t.charCodeAt(o), u >= 10 && (r += s, s = "", u = 0), s += String.fromCharCode(i), ++u;
                  return r += s, r;
                }, t.hexToBytes = function(e) {
                  var t = "",
                      n = 0;
                  e.length & !0 && (n = 1, t += String.fromCharCode(parseInt(e[0], 16)));
                  for (; n < e.length; n += 2)
                    t += String.fromCharCode(parseInt(e.substr(n, 2), 16));
                  return t;
                }, t.bytesToHex = function(e) {
                  return t.createBuffer(e).toHex();
                }, t.int32ToBytes = function(e) {
                  return String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255);
                };
                var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    i = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
                t.encode64 = function(e, t) {
                  var n = "",
                      i = "",
                      s,
                      o,
                      u,
                      a = 0;
                  while (a < e.length)
                    s = e.charCodeAt(a++), o = e.charCodeAt(a++), u = e.charCodeAt(a++), n += r.charAt(s >> 2), n += r.charAt((s & 3) << 4 | o >> 4), isNaN(o) ? n += "==" : (n += r.charAt((o & 15) << 2 | u >> 6), n += isNaN(u) ? "=" : r.charAt(u & 63)), t && n.length > t && (i += n.substr(0, t) + "\r\n", n = n.substr(t));
                  return i += n, i;
                }, t.decode64 = function(e) {
                  e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                  var t = "",
                      n,
                      r,
                      s,
                      o,
                      u = 0;
                  while (u < e.length)
                    n = i[e.charCodeAt(u++) - 43], r = i[e.charCodeAt(u++) - 43], s = i[e.charCodeAt(u++) - 43], o = i[e.charCodeAt(u++) - 43], t += String.fromCharCode(n << 2 | r >> 4), s !== 64 && (t += String.fromCharCode((r & 15) << 4 | s >> 2), o !== 64 && (t += String.fromCharCode((s & 3) << 6 | o)));
                  return t;
                }, t.encodeUtf8 = function(e) {
                  return unescape(encodeURIComponent(e));
                }, t.decodeUtf8 = function(e) {
                  return decodeURIComponent(escape(e));
                }, t.deflate = function(e, n, r) {
                  n = t.decode64(e.deflate(t.encode64(n)).rval);
                  if (r) {
                    var i = 2,
                        s = n.charCodeAt(1);
                    s & 32 && (i = 6), n = n.substring(i, n.length - 4);
                  }
                  return n;
                }, t.inflate = function(e, n, r) {
                  var i = e.inflate(t.encode64(n)).rval;
                  return i === null ? null : t.decode64(i);
                };
                var s = function(e, n, r) {
                  if (!e)
                    throw {message: "WebStorage not available."};
                  var i;
                  r === null ? i = e.removeItem(n) : (r = t.encode64(JSON.stringify(r)), i = e.setItem(n, r));
                  if (typeof i != "undefined" && i.rval !== !0)
                    throw i.error;
                },
                    o = function(e, n) {
                      if (!e)
                        throw {message: "WebStorage not available."};
                      var r = e.getItem(n);
                      if (e.init)
                        if (r.rval === null) {
                          if (r.error)
                            throw r.error;
                          r = null;
                        } else
                          r = r.rval;
                      return r !== null && (r = JSON.parse(t.decode64(r))), r;
                    },
                    u = function(e, t, n, r) {
                      var i = o(e, t);
                      i === null && (i = {}), i[n] = r, s(e, t, i);
                    },
                    a = function(e, t, n) {
                      var r = o(e, t);
                      return r !== null && (r = n in r ? r[n] : null), r;
                    },
                    f = function(e, t, n) {
                      var r = o(e, t);
                      if (r !== null && n in r) {
                        delete r[n];
                        var i = !0;
                        for (var u in r) {
                          i = !1;
                          break;
                        }
                        i && (r = null), s(e, t, r);
                      }
                    },
                    l = function(e, t) {
                      s(e, t, null);
                    },
                    c = function(e, t, n) {
                      var r = null;
                      typeof n == "undefined" && (n = ["web", "flash"]);
                      var i,
                          s = !1,
                          o = null;
                      for (var u in n) {
                        i = n[u];
                        try {
                          if (i === "flash" || i === "both") {
                            if (t[0] === null)
                              throw {message: "Flash local storage not available."};
                            r = e.apply(this, t), s = i === "flash";
                          }
                          if (i === "web" || i === "both")
                            t[0] = localStorage, r = e.apply(this, t), s = !0;
                        } catch (a) {
                          o = a;
                        }
                        if (s)
                          break;
                      }
                      if (!s)
                        throw o;
                      return r;
                    };
                t.setItem = function(e, t, n, r, i) {
                  c(u, arguments, i);
                }, t.getItem = function(e, t, n, r) {
                  return c(a, arguments, r);
                }, t.removeItem = function(e, t, n, r) {
                  c(f, arguments, r);
                }, t.clearItems = function(e, t, n) {
                  c(l, arguments, n);
                }, t.parseUrl = function(e) {
                  var t = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
                  t.lastIndex = 0;
                  var n = t.exec(e),
                      r = n === null ? null : {
                        full: e,
                        scheme: n[1],
                        host: n[2],
                        port: n[3],
                        path: n[4]
                      };
                  return r && (r.fullHost = r.host, r.port ? r.port !== 80 && r.scheme === "http" ? r.fullHost += ":" + r.port : r.port !== 443 && r.scheme === "https" && (r.fullHost += ":" + r.port) : r.scheme === "http" ? r.port = 80 : r.scheme === "https" && (r.port = 443), r.full = r.scheme + "://" + r.fullHost), r;
                };
                var h = null;
                t.getQueryVariables = function(e) {
                  var t = function(e) {
                    var t = {},
                        n = e.split("&");
                    for (var r = 0; r < n.length; r++) {
                      var i = n[r].indexOf("="),
                          s,
                          o;
                      i > 0 ? (s = n[r].substring(0, i), o = n[r].substring(i + 1)) : (s = n[r], o = null), s in t || (t[s] = []), !(s in Object.prototype) && o !== null && t[s].push(unescape(o));
                    }
                    return t;
                  },
                      n;
                  return typeof e == "undefined" ? (h === null && (typeof window == "undefined" ? h = {} : h = t(window.location.search.substring(1))), n = h) : n = t(e), n;
                }, t.parseFragment = function(e) {
                  var n = e,
                      r = "",
                      i = e.indexOf("?");
                  i > 0 && (n = e.substring(0, i), r = e.substring(i + 1));
                  var s = n.split("/");
                  s.length > 0 && s[0] === "" && s.shift();
                  var o = r === "" ? {} : t.getQueryVariables(r);
                  return {
                    pathString: n,
                    queryString: r,
                    path: s,
                    query: o
                  };
                }, t.makeRequest = function(e) {
                  var n = t.parseFragment(e),
                      r = {
                        path: n.pathString,
                        query: n.queryString,
                        getPath: function(e) {
                          return typeof e == "undefined" ? n.path : n.path[e];
                        },
                        getQuery: function(e, t) {
                          var r;
                          return typeof e == "undefined" ? r = n.query : (r = n.query[e], r && typeof t != "undefined" && (r = r[t])), r;
                        },
                        getQueryLast: function(e, t) {
                          var n,
                              i = r.getQuery(e);
                          return i ? n = i[i.length - 1] : n = t, n;
                        }
                      };
                  return r;
                }, t.makeLink = function(e, t, n) {
                  e = jQuery.isArray(e) ? e.join("/") : e;
                  var r = jQuery.param(t || {});
                  return n = n || "", e + (r.length > 0 ? "?" + r : "") + (n.length > 0 ? "#" + n : "");
                }, t.setPath = function(e, t, n) {
                  if (typeof e == "object" && e !== null) {
                    var r = 0,
                        i = t.length;
                    while (r < i) {
                      var s = t[r++];
                      if (r == i)
                        e[s] = n;
                      else {
                        var o = s in e;
                        if (!o || o && typeof e[s] != "object" || o && e[s] === null)
                          e[s] = {};
                        e = e[s];
                      }
                    }
                  }
                }, t.getPath = function(e, t, n) {
                  var r = 0,
                      i = t.length,
                      s = !0;
                  while (s && r < i && typeof e == "object" && e !== null) {
                    var o = t[r++];
                    s = o in e, s && (e = e[o]);
                  }
                  return s ? e : n;
                }, t.deletePath = function(e, t) {
                  if (typeof e == "object" && e !== null) {
                    var n = 0,
                        r = t.length;
                    while (n < r) {
                      var i = t[n++];
                      if (n == r)
                        delete e[i];
                      else {
                        if (!(i in e && typeof e[i] == "object" && e[i] !== null))
                          break;
                        e = e[i];
                      }
                    }
                  }
                }, t.isEmpty = function(e) {
                  for (var t in e)
                    if (e.hasOwnProperty(t))
                      return !1;
                  return !0;
                }, t.format = function(e) {
                  var t = /%./g,
                      n,
                      r,
                      i = 0,
                      s = [],
                      o = 0;
                  while (n = t.exec(e)) {
                    r = e.substring(o, t.lastIndex - 2), r.length > 0 && s.push(r), o = t.lastIndex;
                    var u = n[0][1];
                    switch (u) {
                      case "s":
                      case "o":
                        i < arguments.length ? s.push(arguments[i++ + 1]) : s.push("<?>");
                        break;
                      case "%":
                        s.push("%");
                        break;
                      default:
                        s.push("<%" + u + "?>");
                    }
                  }
                  return s.push(e.substring(o)), s.join("");
                }, t.formatNumber = function(e, t, n, r) {
                  var i = e,
                      s = isNaN(t = Math.abs(t)) ? 2 : t,
                      o = n === undefined ? "," : n,
                      u = r === undefined ? "." : r,
                      a = i < 0 ? "-" : "",
                      f = parseInt(i = Math.abs(+i || 0).toFixed(s), 10) + "",
                      l = f.length > 3 ? f.length % 3 : 0;
                  return a + (l ? f.substr(0, l) + u : "") + f.substr(l).replace(/(\d{3})(?=\d)/g, "$1" + u) + (s ? o + Math.abs(i - f).toFixed(s).slice(2) : "");
                }, t.formatSize = function(e) {
                  return e >= 1073741824 ? e = t.formatNumber(e / 1073741824, 2, ".", "") + " GiB" : e >= 1048576 ? e = t.formatNumber(e / 1048576, 2, ".", "") + " MiB" : e >= 1024 ? e = t.formatNumber(e / 1024, 0) + " KiB" : e = t.formatNumber(e, 0) + " bytes", e;
                }, t.bytesFromIP = function(e) {
                  return e.indexOf(".") !== -1 ? t.bytesFromIPv4(e) : e.indexOf(":") !== -1 ? t.bytesFromIPv6(e) : null;
                }, t.bytesFromIPv4 = function(e) {
                  e = e.split(".");
                  if (e.length !== 4)
                    return null;
                  var n = t.createBuffer();
                  for (var r = 0; r < e.length; ++r) {
                    var i = parseInt(e[r], 10);
                    if (isNaN(i))
                      return null;
                    n.putByte(i);
                  }
                  return n.getBytes();
                }, t.bytesFromIPv6 = function(e) {
                  var n = 0;
                  e = e.split(":").filter(function(e) {
                    return e.length === 0 && ++n, !0;
                  });
                  var r = (8 - e.length + n) * 2,
                      i = t.createBuffer();
                  for (var s = 0; s < 8; ++s) {
                    if (!e[s] || e[s].length === 0) {
                      i.fillWithByte(0, r), r = 0;
                      continue;
                    }
                    var o = t.hexToBytes(e[s]);
                    o.length < 2 && i.putByte(0), i.putBytes(o);
                  }
                  return i.getBytes();
                }, t.bytesToIP = function(e) {
                  return e.length === 4 ? t.bytesToIPv4(e) : e.length === 16 ? t.bytesToIPv6(e) : null;
                }, t.bytesToIPv4 = function(e) {
                  if (e.length !== 4)
                    return null;
                  var t = [];
                  for (var n = 0; n < e.length; ++n)
                    t.push(e.charCodeAt(n));
                  return t.join(".");
                }, t.bytesToIPv6 = function(e) {
                  if (e.length !== 16)
                    return null;
                  var n = [],
                      r = [],
                      i = 0;
                  for (var s = 0; s < e.length; s += 2) {
                    var o = t.bytesToHex(e[s] + e[s + 1]);
                    while (o[0] === "0" && o !== "0")
                      o = o.substr(1);
                    if (o === "0") {
                      var u = r[r.length - 1],
                          a = n.length;
                      !u || a !== u.end + 1 ? r.push({
                        start: a,
                        end: a
                      }) : (u.end = a, u.end - u.start > r[i].end - r[i].start && (i = r.length - 1));
                    }
                    n.push(o);
                  }
                  if (r.length > 0) {
                    var f = r[i];
                    f.end - f.start > 0 && (n.splice(f.start, f.end - f.start + 1, ""), f.start === 0 && n.unshift(""), f.end === 7 && n.push(""));
                  }
                  return n.join(":");
                };
              }
              var r = "util";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/util", ["require", "module"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = !1,
                    n = 4,
                    r,
                    i,
                    s,
                    o,
                    u,
                    a = function() {
                      t = !0, s = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                      var e = new Array(256);
                      for (var n = 0; n < 128; ++n)
                        e[n] = n << 1, e[n + 128] = n + 128 << 1 ^ 283;
                      r = new Array(256), i = new Array(256), o = new Array(4), u = new Array(4);
                      for (var n = 0; n < 4; ++n)
                        o[n] = new Array(256), u[n] = new Array(256);
                      var a = 0,
                          f = 0,
                          l,
                          c,
                          h,
                          p,
                          d,
                          v,
                          m;
                      for (var n = 0; n < 256; ++n) {
                        p = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4, p = p >> 8 ^ p & 255 ^ 99, r[a] = p, i[p] = a, d = e[p], l = e[a], c = e[l], h = e[c], v = d << 24 ^ p << 16 ^ p << 8 ^ (p ^ d), m = (l ^ c ^ h) << 24 ^ (a ^ h) << 16 ^ (a ^ c ^ h) << 8 ^ (a ^ l ^ h);
                        for (var g = 0; g < 4; ++g)
                          o[g][a] = v, u[g][p] = m, v = v << 24 | v >>> 8, m = m << 24 | m >>> 8;
                        a === 0 ? a = f = 1 : (a = l ^ e[e[e[l ^ h]]], f ^= e[e[f]]);
                      }
                    },
                    f = function(e, t) {
                      var i = e.slice(0),
                          o,
                          a = 1,
                          f = i.length,
                          l = f + 6 + 1,
                          c = n * l;
                      for (var h = f; h < c; ++h)
                        o = i[h - 1], h % f === 0 ? (o = r[o >>> 16 & 255] << 24 ^ r[o >>> 8 & 255] << 16 ^ r[o & 255] << 8 ^ r[o >>> 24] ^ s[a] << 24, a++) : f > 6 && h % f === 4 && (o = r[o >>> 24] << 24 ^ r[o >>> 16 & 255] << 16 ^ r[o >>> 8 & 255] << 8 ^ r[o & 255]), i[h] = i[h - f] ^ o;
                      if (t) {
                        var p,
                            d = u[0],
                            v = u[1],
                            m = u[2],
                            g = u[3],
                            y = i.slice(0),
                            c = i.length;
                        for (var h = 0,
                            b = c - n; h < c; h += n, b -= n)
                          if (h === 0 || h === c - n)
                            y[h] = i[b], y[h + 1] = i[b + 3], y[h + 2] = i[b + 2], y[h + 3] = i[b + 1];
                          else
                            for (var w = 0; w < n; ++w)
                              p = i[b + w], y[h + (3 & -w)] = d[r[p >>> 24]] ^ v[r[p >>> 16 & 255]] ^ m[r[p >>> 8 & 255]] ^ g[r[p & 255]];
                        i = y;
                      }
                      return i;
                    },
                    l = function(e, t, n, s) {
                      var a = e.length / 4 - 1,
                          f,
                          l,
                          c,
                          h,
                          p;
                      s ? (f = u[0], l = u[1], c = u[2], h = u[3], p = i) : (f = o[0], l = o[1], c = o[2], h = o[3], p = r);
                      var d,
                          v,
                          m,
                          g,
                          y,
                          b,
                          w;
                      d = t[0] ^ e[0], v = t[s ? 3 : 1] ^ e[1], m = t[2] ^ e[2], g = t[s ? 1 : 3] ^ e[3];
                      var E = 3;
                      for (var S = 1; S < a; ++S)
                        y = f[d >>> 24] ^ l[v >>> 16 & 255] ^ c[m >>> 8 & 255] ^ h[g & 255] ^ e[++E], b = f[v >>> 24] ^ l[m >>> 16 & 255] ^ c[g >>> 8 & 255] ^ h[d & 255] ^ e[++E], w = f[m >>> 24] ^ l[g >>> 16 & 255] ^ c[d >>> 8 & 255] ^ h[v & 255] ^ e[++E], g = f[g >>> 24] ^ l[d >>> 16 & 255] ^ c[v >>> 8 & 255] ^ h[m & 255] ^ e[++E], d = y, v = b, m = w;
                      n[0] = p[d >>> 24] << 24 ^ p[v >>> 16 & 255] << 16 ^ p[m >>> 8 & 255] << 8 ^ p[g & 255] ^ e[++E], n[s ? 3 : 1] = p[v >>> 24] << 24 ^ p[m >>> 16 & 255] << 16 ^ p[g >>> 8 & 255] << 8 ^ p[d & 255] ^ e[++E], n[2] = p[m >>> 24] << 24 ^ p[g >>> 16 & 255] << 16 ^ p[d >>> 8 & 255] << 8 ^ p[v & 255] ^ e[++E], n[s ? 1 : 3] = p[g >>> 24] << 24 ^ p[d >>> 16 & 255] << 16 ^ p[v >>> 8 & 255] << 8 ^ p[m & 255] ^ e[++E];
                    },
                    c = function(r, i, s, o, u) {
                      function C() {
                        if (o)
                          for (var e = 0; e < n; ++e)
                            E[e] = b.getInt32();
                        else
                          for (var e = 0; e < n; ++e)
                            E[e] = x[e] ^ b.getInt32();
                        l(g, E, S, o);
                        if (o) {
                          for (var e = 0; e < n; ++e)
                            w.putInt32(x[e] ^ S[e]);
                          x = E.slice(0);
                        } else {
                          for (var e = 0; e < n; ++e)
                            w.putInt32(S[e]);
                          x = S;
                        }
                      }
                      function k() {
                        l(g, E, S, !1);
                        for (var e = 0; e < n; ++e)
                          E[e] = b.getInt32();
                        for (var e = 0; e < n; ++e) {
                          var t = E[e] ^ S[e];
                          o || (E[e] = t), w.putInt32(t);
                        }
                      }
                      function L() {
                        l(g, E, S, !1);
                        for (var e = 0; e < n; ++e)
                          E[e] = b.getInt32();
                        for (var e = 0; e < n; ++e)
                          w.putInt32(E[e] ^ S[e]), E[e] = S[e];
                      }
                      function A() {
                        l(g, E, S, !1);
                        for (var e = n - 1; e >= 0; --e) {
                          if (E[e] !== 4294967295) {
                            ++E[e];
                            break;
                          }
                          E[e] = 0;
                        }
                        for (var e = 0; e < n; ++e)
                          w.putInt32(b.getInt32() ^ S[e]);
                      }
                      var c = null;
                      t || a(), u = (u || "CBC").toUpperCase();
                      if (typeof r != "string" || r.length !== 16 && r.length !== 24 && r.length !== 32) {
                        if (e.util.isArray(r) && (r.length === 16 || r.length === 24 || r.length === 32)) {
                          var h = r,
                              r = e.util.createBuffer();
                          for (var p = 0; p < h.length; ++p)
                            r.putByte(h[p]);
                        }
                      } else
                        r = e.util.createBuffer(r);
                      if (!e.util.isArray(r)) {
                        var h = r;
                        r = [];
                        var d = h.length();
                        if (d === 16 || d === 24 || d === 32) {
                          d >>>= 2;
                          for (var p = 0; p < d; ++p)
                            r.push(h.getInt32());
                        }
                      }
                      if (!e.util.isArray(r) || r.length !== 4 && r.length !== 6 && r.length !== 8)
                        return c;
                      var v = ["CFB", "OFB", "CTR"].indexOf(u) !== -1,
                          m = u === "CBC",
                          g = f(r, o && !v),
                          y = n << 2,
                          b,
                          w,
                          E,
                          S,
                          x,
                          T,
                          N;
                      c = {output: null};
                      if (u === "CBC")
                        N = C;
                      else if (u === "CFB")
                        N = k;
                      else if (u === "OFB")
                        N = L;
                      else {
                        if (u !== "CTR")
                          throw {message: 'Unsupported block cipher mode of operation: "' + u + '"'};
                        N = A;
                      }
                      return c.update = function(e) {
                        T || b.putBuffer(e);
                        while (b.length() >= y || b.length() > 0 && T)
                          N();
                      }, c.finish = function(e) {
                        var t = !0,
                            r = b.length() % y;
                        if (!o)
                          if (e)
                            t = e(y, b, o);
                          else if (m) {
                            var i = b.length() === y ? y : y - b.length();
                            b.fillWithByte(i, i);
                          }
                        t && (T = !0, c.update());
                        if (o) {
                          m && (t = r === 0);
                          if (t)
                            if (e)
                              t = e(y, w, o);
                            else if (m) {
                              var s = w.length(),
                                  u = w.at(s - 1);
                              u > n << 2 ? t = !1 : w.truncate(u);
                            }
                        }
                        return !m && !e && r > 0 && w.truncate(y - r), t;
                      }, c.start = function(t, r) {
                        t === null && (t = x.slice(0));
                        if (typeof t == "string" && t.length === 16)
                          t = e.util.createBuffer(t);
                        else if (e.util.isArray(t) && t.length === 16) {
                          var i = t,
                              t = e.util.createBuffer();
                          for (var s = 0; s < 16; ++s)
                            t.putByte(i[s]);
                        }
                        if (!e.util.isArray(t)) {
                          var i = t;
                          t = new Array(4), t[0] = i.getInt32(), t[1] = i.getInt32(), t[2] = i.getInt32(), t[3] = i.getInt32();
                        }
                        b = e.util.createBuffer(), w = r || e.util.createBuffer(), x = t.slice(0), E = new Array(n), S = new Array(n), T = !1, c.output = w;
                        if (["CFB", "OFB", "CTR"].indexOf(u) !== -1) {
                          for (var s = 0; s < n; ++s)
                            E[s] = x[s];
                          x = null;
                        }
                      }, i !== null && c.start(i, s), c;
                    };
                e.aes = e.aes || {}, e.aes.startEncrypting = function(e, t, n, r) {
                  return c(e, t, n, !1, r);
                }, e.aes.createEncryptionCipher = function(e, t) {
                  return c(e, null, null, !1, t);
                }, e.aes.startDecrypting = function(e, t, n, r) {
                  return c(e, t, n, !0, r);
                }, e.aes.createDecryptionCipher = function(e, t) {
                  return c(e, null, null, !0, t);
                }, e.aes._expandKey = function(e, n) {
                  return t || a(), f(e, n);
                }, e.aes._updateBlock = l;
              }
              var r = "aes";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/aes", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.pki = e.pki || {};
                var t = e.pki.oids = e.oids = e.oids || {};
                t["1.2.840.113549.1.1.1"] = "rsaEncryption", t.rsaEncryption = "1.2.840.113549.1.1.1", t["1.2.840.113549.1.1.4"] = "md5WithRSAEncryption", t.md5WithRSAEncryption = "1.2.840.113549.1.1.4", t["1.2.840.113549.1.1.5"] = "sha1WithRSAEncryption", t.sha1WithRSAEncryption = "1.2.840.113549.1.1.5", t["1.2.840.113549.1.1.7"] = "RSAES-OAEP", t["RSAES-OAEP"] = "1.2.840.113549.1.1.7", t["1.2.840.113549.1.1.8"] = "mgf1", t.mgf1 = "1.2.840.113549.1.1.8", t["1.2.840.113549.1.1.9"] = "pSpecified", t.pSpecified = "1.2.840.113549.1.1.9", t["1.2.840.113549.1.1.10"] = "RSASSA-PSS", t["RSASSA-PSS"] = "1.2.840.113549.1.1.10", t["1.2.840.113549.1.1.11"] = "sha256WithRSAEncryption", t.sha256WithRSAEncryption = "1.2.840.113549.1.1.11", t["1.2.840.113549.1.1.12"] = "sha384WithRSAEncryption", t.sha384WithRSAEncryption = "1.2.840.113549.1.1.12", t["1.2.840.113549.1.1.13"] = "sha512WithRSAEncryption", t.sha512WithRSAEncryption = "1.2.840.113549.1.1.13", t["1.3.14.3.2.7"] = "desCBC", t.desCBC = "1.3.14.3.2.7", t["1.3.14.3.2.26"] = "sha1", t.sha1 = "1.3.14.3.2.26", t["2.16.840.1.101.3.4.2.1"] = "sha256", t.sha256 = "2.16.840.1.101.3.4.2.1", t["2.16.840.1.101.3.4.2.2"] = "sha384", t.sha384 = "2.16.840.1.101.3.4.2.2", t["2.16.840.1.101.3.4.2.3"] = "sha512", t.sha512 = "2.16.840.1.101.3.4.2.3", t["1.2.840.113549.2.5"] = "md5", t.md5 = "1.2.840.113549.2.5", t["1.2.840.113549.1.7.1"] = "data", t.data = "1.2.840.113549.1.7.1", t["1.2.840.113549.1.7.2"] = "signedData", t.signedData = "1.2.840.113549.1.7.2", t["1.2.840.113549.1.7.3"] = "envelopedData", t.envelopedData = "1.2.840.113549.1.7.3", t["1.2.840.113549.1.7.4"] = "signedAndEnvelopedData", t.signedAndEnvelopedData = "1.2.840.113549.1.7.4", t["1.2.840.113549.1.7.5"] = "digestedData", t.digestedData = "1.2.840.113549.1.7.5", t["1.2.840.113549.1.7.6"] = "encryptedData", t.encryptedData = "1.2.840.113549.1.7.6", t["1.2.840.113549.1.9.1"] = "emailAddress", t.emailAddress = "1.2.840.113549.1.9.1", t["1.2.840.113549.1.9.2"] = "unstructuredName", t.unstructuredName = "1.2.840.113549.1.9.2", t["1.2.840.113549.1.9.3"] = "contentType", t.contentType = "1.2.840.113549.1.9.3", t["1.2.840.113549.1.9.4"] = "messageDigest", t.messageDigest = "1.2.840.113549.1.9.4", t["1.2.840.113549.1.9.5"] = "signingTime", t.signingTime = "1.2.840.113549.1.9.5", t["1.2.840.113549.1.9.6"] = "counterSignature", t.counterSignature = "1.2.840.113549.1.9.6", t["1.2.840.113549.1.9.7"] = "challengePassword", t.challengePassword = "1.2.840.113549.1.9.7", t["1.2.840.113549.1.9.8"] = "unstructuredAddress", t.unstructuredAddress = "1.2.840.113549.1.9.8", t["1.2.840.113549.1.9.20"] = "friendlyName", t.friendlyName = "1.2.840.113549.1.9.20", t["1.2.840.113549.1.9.21"] = "localKeyId", t.localKeyId = "1.2.840.113549.1.9.21", t["1.2.840.113549.1.9.22.1"] = "x509Certificate", t.x509Certificate = "1.2.840.113549.1.9.22.1", t["1.2.840.113549.1.12.10.1.1"] = "keyBag", t.keyBag = "1.2.840.113549.1.12.10.1.1", t["1.2.840.113549.1.12.10.1.2"] = "pkcs8ShroudedKeyBag", t.pkcs8ShroudedKeyBag = "1.2.840.113549.1.12.10.1.2", t["1.2.840.113549.1.12.10.1.3"] = "certBag", t.certBag = "1.2.840.113549.1.12.10.1.3", t["1.2.840.113549.1.12.10.1.4"] = "crlBag", t.crlBag = "1.2.840.113549.1.12.10.1.4", t["1.2.840.113549.1.12.10.1.5"] = "secretBag", t.secretBag = "1.2.840.113549.1.12.10.1.5", t["1.2.840.113549.1.12.10.1.6"] = "safeContentsBag", t.safeContentsBag = "1.2.840.113549.1.12.10.1.6", t["1.2.840.113549.1.5.13"] = "pkcs5PBES2", t.pkcs5PBES2 = "1.2.840.113549.1.5.13", t["1.2.840.113549.1.5.12"] = "pkcs5PBKDF2", t.pkcs5PBKDF2 = "1.2.840.113549.1.5.12", t["1.2.840.113549.1.12.1.1"] = "pbeWithSHAAnd128BitRC4", t.pbeWithSHAAnd128BitRC4 = "1.2.840.113549.1.12.1.1", t["1.2.840.113549.1.12.1.2"] = "pbeWithSHAAnd40BitRC4", t.pbeWithSHAAnd40BitRC4 = "1.2.840.113549.1.12.1.2", t["1.2.840.113549.1.12.1.3"] = "pbeWithSHAAnd3-KeyTripleDES-CBC", t["pbeWithSHAAnd3-KeyTripleDES-CBC"] = "1.2.840.113549.1.12.1.3", t["1.2.840.113549.1.12.1.4"] = "pbeWithSHAAnd2-KeyTripleDES-CBC", t["pbeWithSHAAnd2-KeyTripleDES-CBC"] = "1.2.840.113549.1.12.1.4", t["1.2.840.113549.1.12.1.5"] = "pbeWithSHAAnd128BitRC2-CBC", t["pbeWithSHAAnd128BitRC2-CBC"] = "1.2.840.113549.1.12.1.5", t["1.2.840.113549.1.12.1.6"] = "pbewithSHAAnd40BitRC2-CBC", t["pbewithSHAAnd40BitRC2-CBC"] = "1.2.840.113549.1.12.1.6", t["1.2.840.113549.3.7"] = "des-EDE3-CBC", t["des-EDE3-CBC"] = "1.2.840.113549.3.7", t["2.16.840.1.101.3.4.1.2"] = "aes128-CBC", t["aes128-CBC"] = "2.16.840.1.101.3.4.1.2", t["2.16.840.1.101.3.4.1.22"] = "aes192-CBC", t["aes192-CBC"] = "2.16.840.1.101.3.4.1.22", t["2.16.840.1.101.3.4.1.42"] = "aes256-CBC", t["aes256-CBC"] = "2.16.840.1.101.3.4.1.42", t["2.5.4.3"] = "commonName", t.commonName = "2.5.4.3", t["2.5.4.5"] = "serialName", t.serialName = "2.5.4.5", t["2.5.4.6"] = "countryName", t.countryName = "2.5.4.6", t["2.5.4.7"] = "localityName", t.localityName = "2.5.4.7", t["2.5.4.8"] = "stateOrProvinceName", t.stateOrProvinceName = "2.5.4.8", t["2.5.4.10"] = "organizationName", t.organizationName = "2.5.4.10", t["2.5.4.11"] = "organizationalUnitName", t.organizationalUnitName = "2.5.4.11", t["2.16.840.1.113730.1.1"] = "nsCertType", t.nsCertType = "2.16.840.1.113730.1.1", t["2.5.29.1"] = "authorityKeyIdentifier", t["2.5.29.2"] = "keyAttributes", t["2.5.29.3"] = "certificatePolicies", t["2.5.29.4"] = "keyUsageRestriction", t["2.5.29.5"] = "policyMapping", t["2.5.29.6"] = "subtreesConstraint", t["2.5.29.7"] = "subjectAltName", t["2.5.29.8"] = "issuerAltName", t["2.5.29.9"] = "subjectDirectoryAttributes", t["2.5.29.10"] = "basicConstraints", t["2.5.29.11"] = "nameConstraints", t["2.5.29.12"] = "policyConstraints", t["2.5.29.13"] = "basicConstraints", t["2.5.29.14"] = "subjectKeyIdentifier", t.subjectKeyIdentifier = "2.5.29.14", t["2.5.29.15"] = "keyUsage", t.keyUsage = "2.5.29.15", t["2.5.29.16"] = "privateKeyUsagePeriod", t["2.5.29.17"] = "subjectAltName", t.subjectAltName = "2.5.29.17", t["2.5.29.18"] = "issuerAltName", t.issuerAltName = "2.5.29.18", t["2.5.29.19"] = "basicConstraints", t.basicConstraints = "2.5.29.19", t["2.5.29.20"] = "cRLNumber", t["2.5.29.21"] = "cRLReason", t["2.5.29.22"] = "expirationDate", t["2.5.29.23"] = "instructionCode", t["2.5.29.24"] = "invalidityDate", t["2.5.29.25"] = "cRLDistributionPoints", t["2.5.29.26"] = "issuingDistributionPoint", t["2.5.29.27"] = "deltaCRLIndicator", t["2.5.29.28"] = "issuingDistributionPoint", t["2.5.29.29"] = "certificateIssuer", t["2.5.29.30"] = "nameConstraints", t["2.5.29.31"] = "cRLDistributionPoints", t["2.5.29.32"] = "certificatePolicies", t["2.5.29.33"] = "policyMappings", t["2.5.29.34"] = "policyConstraints", t["2.5.29.35"] = "authorityKeyIdentifier", t["2.5.29.36"] = "policyConstraints", t["2.5.29.37"] = "extKeyUsage", t.extKeyUsage = "2.5.29.37", t["2.5.29.46"] = "freshestCRL", t["2.5.29.54"] = "inhibitAnyPolicy", t["1.3.6.1.5.5.7.3.1"] = "serverAuth", t.serverAuth = "1.3.6.1.5.5.7.3.1", t["1.3.6.1.5.5.7.3.2"] = "clientAuth", t.clientAuth = "1.3.6.1.5.5.7.3.2", t["1.3.6.1.5.5.7.3.3"] = "codeSigning", t.codeSigning = "1.3.6.1.5.5.7.3.3", t["1.3.6.1.5.5.7.3.4"] = "emailProtection", t.emailProtection = "1.3.6.1.5.5.7.3.4", t["1.3.6.1.5.5.7.3.8"] = "timeStamping", t.timeStamping = "1.3.6.1.5.5.7.3.8";
              }
              var r = "oids";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/oids", ["require", "module"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.asn1 = e.asn1 || {};
                t.Class = {
                  UNIVERSAL: 0,
                  APPLICATION: 64,
                  CONTEXT_SPECIFIC: 128,
                  PRIVATE: 192
                }, t.Type = {
                  NONE: 0,
                  BOOLEAN: 1,
                  INTEGER: 2,
                  BITSTRING: 3,
                  OCTETSTRING: 4,
                  NULL: 5,
                  OID: 6,
                  ODESC: 7,
                  EXTERNAL: 8,
                  REAL: 9,
                  ENUMERATED: 10,
                  EMBEDDED: 11,
                  UTF8: 12,
                  ROID: 13,
                  SEQUENCE: 16,
                  SET: 17,
                  PRINTABLESTRING: 19,
                  IA5STRING: 22,
                  UTCTIME: 23,
                  GENERALIZEDTIME: 24,
                  BMPSTRING: 30
                }, t.create = function(t, n, r, i) {
                  if (e.util.isArray(i)) {
                    var s = [];
                    for (var o = 0; o < i.length; ++o)
                      i[o] !== undefined && s.push(i[o]);
                    i = s;
                  }
                  return {
                    tagClass: t,
                    type: n,
                    constructed: r,
                    composed: r || e.util.isArray(i),
                    value: i
                  };
                };
                var n = function(e) {
                  var t = e.getByte();
                  if (t === 128)
                    return undefined;
                  var n,
                      r = t & 128;
                  return r ? n = e.getInt((t & 127) << 3) : n = t, n;
                };
                t.fromDer = function(r, i) {
                  i === undefined && (i = !0), typeof r == "string" && (r = e.util.createBuffer(r));
                  if (r.length() < 2)
                    throw {
                      message: "Too few bytes to parse DER.",
                      bytes: r.length()
                    };
                  var s = r.getByte(),
                      o = s & 192,
                      u = s & 31,
                      a = n(r);
                  if (r.length() < a) {
                    if (i)
                      throw {
                        message: "Too few bytes to read ASN.1 value.",
                        detail: r.length() + " < " + a
                      };
                    a = r.length();
                  }
                  var f,
                      l = (s & 32) === 32,
                      c = l;
                  if (!c && o === t.Class.UNIVERSAL && u === t.Type.BITSTRING && a > 1) {
                    var h = r.read,
                        p = r.getByte();
                    if (p === 0) {
                      s = r.getByte();
                      var d = s & 192;
                      if (d === t.Class.UNIVERSAL || d === t.Class.CONTEXT_SPECIFIC)
                        try {
                          var v = n(r);
                          c = v === a - (r.read - h), c && (++h, --a);
                        } catch (m) {}
                    }
                    r.read = h;
                  }
                  if (c) {
                    f = [];
                    if (a === undefined)
                      for (; ; ) {
                        if (r.bytes(2) === String.fromCharCode(0, 0)) {
                          r.getBytes(2);
                          break;
                        }
                        f.push(t.fromDer(r, i));
                      }
                    else {
                      var g = r.length();
                      while (a > 0)
                        f.push(t.fromDer(r, i)), a -= g - r.length(), g = r.length();
                    }
                  } else {
                    if (a === undefined) {
                      if (i)
                        throw {message: "Non-constructed ASN.1 object of indefinite length."};
                      a = r.length();
                    }
                    if (u === t.Type.BMPSTRING) {
                      f = "";
                      for (var y = 0; y < a; y += 2)
                        f += String.fromCharCode(r.getInt16());
                    } else
                      f = r.getBytes(a);
                  }
                  return t.create(o, u, l, f);
                }, t.toDer = function(n) {
                  var r = e.util.createBuffer(),
                      i = n.tagClass | n.type,
                      s = e.util.createBuffer();
                  if (n.composed) {
                    n.constructed ? i |= 32 : s.putByte(0);
                    for (var o = 0; o < n.value.length; ++o)
                      n.value[o] !== undefined && s.putBuffer(t.toDer(n.value[o]));
                  } else if (n.type === t.Type.BMPSTRING)
                    for (var o = 0; o < n.value.length; ++o)
                      s.putInt16(n.value.charCodeAt(o));
                  else
                    s.putBytes(n.value);
                  r.putByte(i);
                  if (s.length() <= 127)
                    r.putByte(s.length() & 127);
                  else {
                    var u = s.length(),
                        a = "";
                    do
                      a += String.fromCharCode(u & 255), u >>>= 8;
 while (u > 0);
                    r.putByte(a.length | 128);
                    for (var o = a.length - 1; o >= 0; --o)
                      r.putByte(a.charCodeAt(o));
                  }
                  return r.putBuffer(s), r;
                }, t.oidToDer = function(t) {
                  var n = t.split("."),
                      r = e.util.createBuffer();
                  r.putByte(40 * parseInt(n[0], 10) + parseInt(n[1], 10));
                  var i,
                      s,
                      o,
                      u;
                  for (var a = 2; a < n.length; ++a) {
                    i = !0, s = [], o = parseInt(n[a], 10);
                    do
                      u = o & 127, o >>>= 7, i || (u |= 128), s.push(u), i = !1;
 while (o > 0);
                    for (var f = s.length - 1; f >= 0; --f)
                      r.putByte(s[f]);
                  }
                  return r;
                }, t.derToOid = function(t) {
                  var n;
                  typeof t == "string" && (t = e.util.createBuffer(t));
                  var r = t.getByte();
                  n = Math.floor(r / 40) + "." + r % 40;
                  var i = 0;
                  while (t.length() > 0)
                    r = t.getByte(), i <<= 7, r & 128 ? i += r & 127 : (n += "." + (i + r), i = 0);
                  return n;
                }, t.utcTimeToDate = function(e) {
                  var t = new Date,
                      n = parseInt(e.substr(0, 2), 10);
                  n = n >= 50 ? 1900 + n : 2e3 + n;
                  var r = parseInt(e.substr(2, 2), 10) - 1,
                      i = parseInt(e.substr(4, 2), 10),
                      s = parseInt(e.substr(6, 2), 10),
                      o = parseInt(e.substr(8, 2), 10),
                      u = 0;
                  if (e.length > 11) {
                    var a = e.charAt(10),
                        f = 10;
                    a !== "+" && a !== "-" && (u = parseInt(e.substr(10, 2), 10), f += 2);
                  }
                  t.setUTCFullYear(n, r, i), t.setUTCHours(s, o, u, 0);
                  if (f) {
                    a = e.charAt(f);
                    if (a === "+" || a === "-") {
                      var l = parseInt(e.substr(f + 1, 2), 10),
                          c = parseInt(e.substr(f + 4, 2), 10),
                          h = l * 60 + c;
                      h *= 6e4, a === "+" ? t.setTime(+t - h) : t.setTime(+t + h);
                    }
                  }
                  return t;
                }, t.generalizedTimeToDate = function(e) {
                  var t = new Date,
                      n = parseInt(e.substr(0, 4), 10),
                      r = parseInt(e.substr(4, 2), 10) - 1,
                      i = parseInt(e.substr(6, 2), 10),
                      s = parseInt(e.substr(8, 2), 10),
                      o = parseInt(e.substr(10, 2), 10),
                      u = parseInt(e.substr(12, 2), 10),
                      a = 0,
                      f = 0,
                      l = !1;
                  e.charAt(e.length - 1) === "Z" && (l = !0);
                  var c = e.length - 5,
                      h = e.charAt(c);
                  if (h === "+" || h === "-") {
                    var p = parseInt(e.substr(c + 1, 2), 10),
                        d = parseInt(e.substr(c + 4, 2), 10);
                    f = p * 60 + d, f *= 6e4, h === "+" && (f *= -1), l = !0;
                  }
                  return e.charAt(14) === "." && (a = parseFloat(e.substr(14), 10) * 1e3), l ? (t.setUTCFullYear(n, r, i), t.setUTCHours(s, o, u, a), t.setTime(+t + f)) : (t.setFullYear(n, r, i), t.setHours(s, o, u, a)), t;
                }, t.dateToUtcTime = function(e) {
                  var t = "",
                      n = [];
                  n.push(("" + e.getUTCFullYear()).substr(2)), n.push("" + (e.getUTCMonth() + 1)), n.push("" + e.getUTCDate()), n.push("" + e.getUTCHours()), n.push("" + e.getUTCMinutes()), n.push("" + e.getUTCSeconds());
                  for (var r = 0; r < n.length; ++r)
                    n[r].length < 2 && (t += "0"), t += n[r];
                  return t += "Z", t;
                }, t.integerToDer = function(t) {
                  var n = e.util.createBuffer();
                  if (t >= -128 && t < 128)
                    return n.putSignedInt(t, 8);
                  if (t >= -32768 && t < 32768)
                    return n.putSignedInt(t, 16);
                  if (t >= -8388608 && t < 8388608)
                    return n.putSignedInt(t, 24);
                  if (t >= -2147483648 && t < 2147483648)
                    return n.putSignedInt(t, 32);
                  throw {
                    message: "Integer too large; max is 32-bits.",
                    integer: t
                  };
                }, t.derToInteger = function(t) {
                  typeof t == "string" && (t = e.util.createBuffer(t));
                  var n = t.length() * 8;
                  if (n > 32)
                    throw {message: "Integer too large; max is 32-bits."};
                  return t.getSignedInt(n);
                }, t.validate = function(n, r, i, s) {
                  var o = !1;
                  if (n.tagClass !== r.tagClass && typeof r.tagClass != "undefined" || n.type !== r.type && typeof r.type != "undefined")
                    s && (n.tagClass !== r.tagClass && s.push("[" + r.name + "] " + 'Expected tag class "' + r.tagClass + '", got "' + n.tagClass + '"'), n.type !== r.type && s.push("[" + r.name + "] " + 'Expected type "' + r.type + '", got "' + n.type + '"'));
                  else if (n.constructed === r.constructed || typeof r.constructed == "undefined") {
                    o = !0;
                    if (r.value && e.util.isArray(r.value)) {
                      var u = 0;
                      for (var a = 0; o && a < r.value.length; ++a)
                        o = r.value[a].optional || !1, n.value[u] && (o = t.validate(n.value[u], r.value[a], i, s), o ? ++u : r.value[a].optional && (o = !0)), !o && s && s.push("[" + r.name + "] " + 'Tag class "' + r.tagClass + '", type "' + r.type + '" expected value length "' + r.value.length + '", got "' + n.value.length + '"');
                    }
                    o && i && (r.capture && (i[r.capture] = n.value), r.captureAsn1 && (i[r.captureAsn1] = n));
                  } else
                    s && s.push("[" + r.name + "] " + 'Expected constructed "' + r.constructed + '", got "' + n.constructed + '"');
                  return o;
                };
                var r = /[^\\u0000-\\u00ff]/;
                t.prettyPrint = function(n, i, s) {
                  var o = "";
                  i = i || 0, s = s || 2, i > 0 && (o += "\n");
                  var u = "";
                  for (var a = 0; a < i * s; ++a)
                    u += " ";
                  o += u + "Tag: ";
                  switch (n.tagClass) {
                    case t.Class.UNIVERSAL:
                      o += "Universal:";
                      break;
                    case t.Class.APPLICATION:
                      o += "Application:";
                      break;
                    case t.Class.CONTEXT_SPECIFIC:
                      o += "Context-Specific:";
                      break;
                    case t.Class.PRIVATE:
                      o += "Private:";
                  }
                  if (n.tagClass === t.Class.UNIVERSAL) {
                    o += n.type;
                    switch (n.type) {
                      case t.Type.NONE:
                        o += " (None)";
                        break;
                      case t.Type.BOOLEAN:
                        o += " (Boolean)";
                        break;
                      case t.Type.BITSTRING:
                        o += " (Bit string)";
                        break;
                      case t.Type.INTEGER:
                        o += " (Integer)";
                        break;
                      case t.Type.OCTETSTRING:
                        o += " (Octet string)";
                        break;
                      case t.Type.NULL:
                        o += " (Null)";
                        break;
                      case t.Type.OID:
                        o += " (Object Identifier)";
                        break;
                      case t.Type.ODESC:
                        o += " (Object Descriptor)";
                        break;
                      case t.Type.EXTERNAL:
                        o += " (External or Instance of)";
                        break;
                      case t.Type.REAL:
                        o += " (Real)";
                        break;
                      case t.Type.ENUMERATED:
                        o += " (Enumerated)";
                        break;
                      case t.Type.EMBEDDED:
                        o += " (Embedded PDV)";
                        break;
                      case t.Type.UTF8:
                        o += " (UTF8)";
                        break;
                      case t.Type.ROID:
                        o += " (Relative Object Identifier)";
                        break;
                      case t.Type.SEQUENCE:
                        o += " (Sequence)";
                        break;
                      case t.Type.SET:
                        o += " (Set)";
                        break;
                      case t.Type.PRINTABLESTRING:
                        o += " (Printable String)";
                        break;
                      case t.Type.IA5String:
                        o += " (IA5String (ASCII))";
                        break;
                      case t.Type.UTCTIME:
                        o += " (UTC time)";
                        break;
                      case t.Type.GENERALIZEDTIME:
                        o += " (Generalized time)";
                        break;
                      case t.Type.BMPSTRING:
                        o += " (BMP String)";
                    }
                  } else
                    o += n.type;
                  o += "\n", o += u + "Constructed: " + n.constructed + "\n";
                  if (n.composed) {
                    var f = 0,
                        l = "";
                    for (var a = 0; a < n.value.length; ++a)
                      n.value[a] !== undefined && (f += 1, l += t.prettyPrint(n.value[a], i + 1, s), a + 1 < n.value.length && (l += ","));
                    o += u + "Sub values: " + f + l;
                  } else {
                    o += u + "Value: ";
                    if (n.type === t.Type.OID) {
                      var c = t.derToOid(n.value);
                      o += c, e.pki && e.pki.oids && c in e.pki.oids && (o += " (" + e.pki.oids[c] + ")");
                    }
                    if (n.type === t.Type.INTEGER)
                      try {
                        o += t.derToInteger(n.value);
                      } catch (h) {
                        o += "0x" + e.util.bytesToHex(n.value);
                      }
                    else
                      r.test(n.value) ? o += "0x" + e.util.createBuffer(n.value, "utf8").toHex() : n.value.length === 0 ? o += "[null]" : o += n.value;
                  }
                  return o;
                };
              }
              var r = "asn1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/asn1", ["require", "module", "./util", "./oids"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.md5 = e.md5 || {};
                e.md = e.md || {}, e.md.algorithms = e.md.algorithms || {}, e.md.md5 = e.md.algorithms.md5 = t;
                var n = null,
                    r = null,
                    i = null,
                    s = null,
                    o = !1,
                    u = function() {
                      n = String.fromCharCode(128), n += e.util.fillString(String.fromCharCode(0), 64), r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9], i = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], s = new Array(64);
                      for (var t = 0; t < 64; ++t)
                        s[t] = Math.floor(Math.abs(Math.sin(t + 1)) * 4294967296);
                      o = !0;
                    },
                    a = function(e, t, n) {
                      var o,
                          u,
                          a,
                          f,
                          l,
                          c,
                          h,
                          p,
                          d = n.length();
                      while (d >= 64) {
                        u = e.h0, a = e.h1, f = e.h2, l = e.h3;
                        for (p = 0; p < 16; ++p)
                          t[p] = n.getInt32Le(), c = l ^ a & (f ^ l), o = u + c + s[p] + t[p], h = i[p], u = l, l = f, f = a, a += o << h | o >>> 32 - h;
                        for (; p < 32; ++p)
                          c = f ^ l & (a ^ f), o = u + c + s[p] + t[r[p]], h = i[p], u = l, l = f, f = a, a += o << h | o >>> 32 - h;
                        for (; p < 48; ++p)
                          c = a ^ f ^ l, o = u + c + s[p] + t[r[p]], h = i[p], u = l, l = f, f = a, a += o << h | o >>> 32 - h;
                        for (; p < 64; ++p)
                          c = f ^ (a | ~l), o = u + c + s[p] + t[r[p]], h = i[p], u = l, l = f, f = a, a += o << h | o >>> 32 - h;
                        e.h0 = e.h0 + u & 4294967295, e.h1 = e.h1 + a & 4294967295, e.h2 = e.h2 + f & 4294967295, e.h3 = e.h3 + l & 4294967295, d -= 64;
                      }
                    };
                t.create = function() {
                  o || u();
                  var t = null,
                      r = e.util.createBuffer(),
                      i = new Array(16),
                      s = {
                        algorithm: "md5",
                        blockLength: 64,
                        digestLength: 16,
                        messageLength: 0
                      };
                  return s.start = function() {
                    return s.messageLength = 0, r = e.util.createBuffer(), t = {
                      h0: 1732584193,
                      h1: 4023233417,
                      h2: 2562383102,
                      h3: 271733878
                    }, s;
                  }, s.start(), s.update = function(n, o) {
                    return o === "utf8" && (n = e.util.encodeUtf8(n)), s.messageLength += n.length, r.putBytes(n), a(t, i, r), (r.read > 2048 || r.length() === 0) && r.compact(), s;
                  }, s.digest = function() {
                    var o = s.messageLength,
                        u = e.util.createBuffer();
                    u.putBytes(r.bytes()), u.putBytes(n.substr(0, 64 - (o + 8) % 64)), u.putInt32Le(o << 3 & 4294967295), u.putInt32Le(o >>> 29 & 255);
                    var f = {
                      h0: t.h0,
                      h1: t.h1,
                      h2: t.h2,
                      h3: t.h3
                    };
                    a(f, i, u);
                    var l = e.util.createBuffer();
                    return l.putInt32Le(f.h0), l.putInt32Le(f.h1), l.putInt32Le(f.h2), l.putInt32Le(f.h3), l;
                  }, s;
                };
              }
              var r = "md5";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/md5", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.sha1 = e.sha1 || {};
                e.md = e.md || {}, e.md.algorithms = e.md.algorithms || {}, e.md.sha1 = e.md.algorithms.sha1 = t;
                var n = null,
                    r = !1,
                    i = function() {
                      n = String.fromCharCode(128), n += e.util.fillString(String.fromCharCode(0), 64), r = !0;
                    },
                    s = function(e, t, n) {
                      var r,
                          i,
                          s,
                          o,
                          u,
                          a,
                          f,
                          l,
                          c = n.length();
                      while (c >= 64) {
                        i = e.h0, s = e.h1, o = e.h2, u = e.h3, a = e.h4;
                        for (l = 0; l < 16; ++l)
                          r = n.getInt32(), t[l] = r, f = u ^ s & (o ^ u), r = (i << 5 | i >>> 27) + f + a + 1518500249 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 20; ++l)
                          r = t[l - 3] ^ t[l - 8] ^ t[l - 14] ^ t[l - 16], r = r << 1 | r >>> 31, t[l] = r, f = u ^ s & (o ^ u), r = (i << 5 | i >>> 27) + f + a + 1518500249 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 32; ++l)
                          r = t[l - 3] ^ t[l - 8] ^ t[l - 14] ^ t[l - 16], r = r << 1 | r >>> 31, t[l] = r, f = s ^ o ^ u, r = (i << 5 | i >>> 27) + f + a + 1859775393 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 40; ++l)
                          r = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], r = r << 2 | r >>> 30, t[l] = r, f = s ^ o ^ u, r = (i << 5 | i >>> 27) + f + a + 1859775393 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 60; ++l)
                          r = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], r = r << 2 | r >>> 30, t[l] = r, f = s & o | u & (s ^ o), r = (i << 5 | i >>> 27) + f + a + 2400959708 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        for (; l < 80; ++l)
                          r = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], r = r << 2 | r >>> 30, t[l] = r, f = s ^ o ^ u, r = (i << 5 | i >>> 27) + f + a + 3395469782 + r, a = u, u = o, o = s << 30 | s >>> 2, s = i, i = r;
                        e.h0 += i, e.h1 += s, e.h2 += o, e.h3 += u, e.h4 += a, c -= 64;
                      }
                    };
                t.create = function() {
                  r || i();
                  var t = null,
                      o = e.util.createBuffer(),
                      u = new Array(80),
                      a = {
                        algorithm: "sha1",
                        blockLength: 64,
                        digestLength: 20,
                        messageLength: 0
                      };
                  return a.start = function() {
                    return a.messageLength = 0, o = e.util.createBuffer(), t = {
                      h0: 1732584193,
                      h1: 4023233417,
                      h2: 2562383102,
                      h3: 271733878,
                      h4: 3285377520
                    }, a;
                  }, a.start(), a.update = function(n, r) {
                    return r === "utf8" && (n = e.util.encodeUtf8(n)), a.messageLength += n.length, o.putBytes(n), s(t, u, o), (o.read > 2048 || o.length() === 0) && o.compact(), a;
                  }, a.digest = function() {
                    var r = a.messageLength,
                        i = e.util.createBuffer();
                    i.putBytes(o.bytes()), i.putBytes(n.substr(0, 64 - (r + 8) % 64)), i.putInt32(r >>> 29 & 255), i.putInt32(r << 3 & 4294967295);
                    var f = {
                      h0: t.h0,
                      h1: t.h1,
                      h2: t.h2,
                      h3: t.h3,
                      h4: t.h4
                    };
                    s(f, u, i);
                    var l = e.util.createBuffer();
                    return l.putInt32(f.h0), l.putInt32(f.h1), l.putInt32(f.h2), l.putInt32(f.h3), l.putInt32(f.h4), l;
                  }, a;
                };
              }
              var r = "sha1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/sha1", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.sha256 = e.sha256 || {};
                e.md = e.md || {}, e.md.algorithms = e.md.algorithms || {}, e.md.sha256 = e.md.algorithms.sha256 = t;
                var n = null,
                    r = !1,
                    i = null,
                    s = function() {
                      n = String.fromCharCode(128), n += e.util.fillString(String.fromCharCode(0), 64), i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], r = !0;
                    },
                    o = function(e, t, n) {
                      var r,
                          s,
                          o,
                          u,
                          a,
                          f,
                          l,
                          c,
                          h,
                          p,
                          d,
                          v,
                          m,
                          g,
                          y,
                          b = n.length();
                      while (b >= 64) {
                        for (l = 0; l < 16; ++l)
                          t[l] = n.getInt32();
                        for (; l < 64; ++l)
                          r = t[l - 2], r = (r >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10, s = t[l - 15], s = (s >>> 7 | s << 25) ^ (s >>> 18 | s << 14) ^ s >>> 3, t[l] = r + t[l - 7] + s + t[l - 16] & 4294967295;
                        c = e.h0, h = e.h1, p = e.h2, d = e.h3, v = e.h4, m = e.h5, g = e.h6, y = e.h7;
                        for (l = 0; l < 64; ++l)
                          u = (v >>> 6 | v << 26) ^ (v >>> 11 | v << 21) ^ (v >>> 25 | v << 7), a = g ^ v & (m ^ g), o = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), f = c & h | p & (c ^ h), r = y + u + a + i[l] + t[l], s = o + f, y = g, g = m, m = v, v = d + r & 4294967295, d = p, p = h, h = c, c = r + s & 4294967295;
                        e.h0 = e.h0 + c & 4294967295, e.h1 = e.h1 + h & 4294967295, e.h2 = e.h2 + p & 4294967295, e.h3 = e.h3 + d & 4294967295, e.h4 = e.h4 + v & 4294967295, e.h5 = e.h5 + m & 4294967295, e.h6 = e.h6 + g & 4294967295, e.h7 = e.h7 + y & 4294967295, b -= 64;
                      }
                    };
                t.create = function() {
                  r || s();
                  var t = null,
                      i = e.util.createBuffer(),
                      u = new Array(64),
                      a = {
                        algorithm: "sha256",
                        blockLength: 64,
                        digestLength: 32,
                        messageLength: 0
                      };
                  return a.start = function() {
                    return a.messageLength = 0, i = e.util.createBuffer(), t = {
                      h0: 1779033703,
                      h1: 3144134277,
                      h2: 1013904242,
                      h3: 2773480762,
                      h4: 1359893119,
                      h5: 2600822924,
                      h6: 528734635,
                      h7: 1541459225
                    }, a;
                  }, a.start(), a.update = function(n, r) {
                    return r === "utf8" && (n = e.util.encodeUtf8(n)), a.messageLength += n.length, i.putBytes(n), o(t, u, i), (i.read > 2048 || i.length() === 0) && i.compact(), a;
                  }, a.digest = function() {
                    var r = a.messageLength,
                        s = e.util.createBuffer();
                    s.putBytes(i.bytes()), s.putBytes(n.substr(0, 64 - (r + 8) % 64)), s.putInt32(r >>> 29 & 255), s.putInt32(r << 3 & 4294967295);
                    var f = {
                      h0: t.h0,
                      h1: t.h1,
                      h2: t.h2,
                      h3: t.h3,
                      h4: t.h4,
                      h5: t.h5,
                      h6: t.h6,
                      h7: t.h7
                    };
                    o(f, u, s);
                    var l = e.util.createBuffer();
                    return l.putInt32(f.h0), l.putInt32(f.h1), l.putInt32(f.h2), l.putInt32(f.h3), l.putInt32(f.h4), l.putInt32(f.h5), l.putInt32(f.h6), l.putInt32(f.h7), l;
                  }, a;
                };
              }
              var r = "sha256";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/sha256", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.md = e.md || {}, e.md.algorithms = {
                  md5: e.md5,
                  sha1: e.sha1,
                  sha256: e.sha256
                }, e.md.md5 = e.md5, e.md.sha1 = e.sha1, e.md.sha256 = e.sha256;
              }
              var r = "md";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/md", ["require", "module", "./md5", "./sha1", "./sha256"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.hmac = e.hmac || {};
                t.create = function() {
                  var t = null,
                      n = null,
                      r = null,
                      i = null,
                      s = {};
                  return s.start = function(s, o) {
                    if (s !== null)
                      if (typeof s == "string") {
                        s = s.toLowerCase();
                        if (!(s in e.md.algorithms))
                          throw 'Unknown hash algorithm "' + s + '"';
                        n = e.md.algorithms[s].create();
                      } else
                        n = s;
                    if (o === null)
                      o = t;
                    else {
                      if (typeof o == "string")
                        o = e.util.createBuffer(o);
                      else if (e.util.isArray(o)) {
                        var u = o;
                        o = e.util.createBuffer();
                        for (var a = 0; a < u.length; ++a)
                          o.putByte(u[a]);
                      }
                      var f = o.length();
                      f > n.blockLength && (n.start(), n.update(o.bytes()), o = n.digest()), r = e.util.createBuffer(), i = e.util.createBuffer(), f = o.length();
                      for (var a = 0; a < f; ++a) {
                        var u = o.at(a);
                        r.putByte(54 ^ u), i.putByte(92 ^ u);
                      }
                      if (f < n.blockLength) {
                        var u = n.blockLength - f;
                        for (var a = 0; a < u; ++a)
                          r.putByte(54), i.putByte(92);
                      }
                      t = o, r = r.bytes(), i = i.bytes();
                    }
                    n.start(), n.update(r);
                  }, s.update = function(e) {
                    n.update(e);
                  }, s.getMac = function() {
                    var e = n.digest().bytes();
                    return n.start(), n.update(i), n.update(e), n.digest();
                  }, s.digest = s.getMac, s;
                };
              }
              var r = "hmac";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/hmac", ["require", "module", "./md", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function n(e) {
                  var t = e.name + ": ",
                      n = [];
                  for (var r = 0; r < e.values.length; ++r)
                    n.push(e.values[r].replace(/^(\S+\r\n)/, function(e, t) {
                      return " " + t;
                    }));
                  t += n.join(",") + "\r\n";
                  var i = 0,
                      s = -1;
                  for (var r = 0; r < t.length; ++r, ++i)
                    if (i > 65 && s !== -1) {
                      var o = t[s];
                      o === "," ? (++s, t = t.substr(0, s) + "\r\n " + t.substr(s)) : t = t.substr(0, s) + "\r\n" + o + t.substr(s + 1), i = r - s - 1, s = -1, ++r;
                    } else if (t[r] === " " || t[r] === "	" || t[r] === ",")
                      s = r;
                  return t;
                }
                function r(e) {
                  return e.replace(/^\s+/, "");
                }
                var t = e.pem = e.pem || {};
                t.encode = function(t, r) {
                  r = r || {};
                  var i = "-----BEGIN " + t.type + "-----\r\n",
                      s;
                  t.procType && (s = {
                    name: "Proc-Type",
                    values: [String(t.procType.version), t.procType.type]
                  }, i += n(s)), t.contentDomain && (s = {
                    name: "Content-Domain",
                    values: [t.contentDomain]
                  }, i += n(s)), t.dekInfo && (s = {
                    name: "DEK-Info",
                    values: [t.dekInfo.algorithm]
                  }, t.dekInfo.parameters && s.values.push(t.dekInfo.parameters), i += n(s));
                  if (t.headers)
                    for (var o = 0; o < t.headers.length; ++o)
                      i += n(t.headers[o]);
                  return t.procType && (i += "\r\n"), i += e.util.encode64(t.body, r.maxline || 64) + "\r\n", i += "-----END " + t.type + "-----\r\n", i;
                }, t.decode = function(t) {
                  var n = [],
                      i = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,
                      s = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,
                      o = /\r?\n/,
                      u;
                  for (; ; ) {
                    u = i.exec(t);
                    if (!u)
                      break;
                    var a = {
                      type: u[1],
                      procType: null,
                      contentDomain: null,
                      dekInfo: null,
                      headers: [],
                      body: e.util.decode64(u[3])
                    };
                    n.push(a);
                    if (!u[2])
                      continue;
                    var f = u[2].split(o),
                        l = 0;
                    while (u && l < f.length) {
                      var c = f[l].replace(/\s+$/, "");
                      for (var h = l + 1; h < f.length; ++h) {
                        var p = f[h];
                        if (!/\s/.test(p[0]))
                          break;
                        c += p, l = h;
                      }
                      u = c.match(s);
                      if (u) {
                        var d = {
                          name: u[1],
                          values: []
                        },
                            v = u[2].split(",");
                        for (var m = 0; m < v.length; ++m)
                          d.values.push(r(v[m]));
                        if (!a.procType) {
                          if (d.name !== "Proc-Type")
                            throw {message: 'Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".'};
                          if (d.values.length !== 2)
                            throw {message: 'Invalid PEM formatted message. The "Proc-Type" header must have two subfields.'};
                          a.procType = {
                            version: v[0],
                            type: v[1]
                          };
                        } else if (!a.contentDomain && d.name === "Content-Domain")
                          a.contentDomain = v[0] || "";
                        else if (!a.dekInfo && d.name === "DEK-Info") {
                          if (d.values.length === 0)
                            throw {message: 'Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.'};
                          a.dekInfo = {
                            algorithm: v[0],
                            parameters: v[1] || null
                          };
                        } else
                          a.headers.push(d);
                      }
                      ++l;
                    }
                    if (a.procType === "ENCRYPTED" && !a.dekInfo)
                      throw {message: 'Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".'};
                  }
                  if (n.length === 0)
                    throw {message: "Invalid PEM formatted message."};
                  return n;
                };
              }
              var r = "pem";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pem", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function f(e) {
                  var t = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964],
                      n = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697],
                      r = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272],
                      i = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144],
                      s = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256],
                      o = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488],
                      u = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746],
                      a = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568],
                      f = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578],
                      l = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488],
                      c = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800],
                      h = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744],
                      p = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128],
                      d = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261],
                      v = e.length() > 8 ? 3 : 1,
                      m = [],
                      g = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
                      y = 0,
                      b;
                  for (var w = 0; w < v; w++) {
                    var E = e.getInt32(),
                        S = e.getInt32();
                    b = (E >>> 4 ^ S) & 252645135, S ^= b, E ^= b << 4, b = (S >>> -16 ^ E) & 65535, E ^= b, S ^= b << -16, b = (E >>> 2 ^ S) & 858993459, S ^= b, E ^= b << 2, b = (S >>> -16 ^ E) & 65535, E ^= b, S ^= b << -16, b = (E >>> 1 ^ S) & 1431655765, S ^= b, E ^= b << 1, b = (S >>> 8 ^ E) & 16711935, E ^= b, S ^= b << 8, b = (E >>> 1 ^ S) & 1431655765, S ^= b, E ^= b << 1, b = E << 8 | S >>> 20 & 240, E = S << 24 | S << 8 & 16711680 | S >>> 8 & 65280 | S >>> 24 & 240, S = b;
                    for (var x = 0; x < g.length; x++) {
                      g[x] ? (E = E << 2 | E >>> 26, S = S << 2 | S >>> 26) : (E = E << 1 | E >>> 27, S = S << 1 | S >>> 27), E &= -15, S &= -15;
                      var T = t[E >>> 28] | n[E >>> 24 & 15] | r[E >>> 20 & 15] | i[E >>> 16 & 15] | s[E >>> 12 & 15] | o[E >>> 8 & 15] | u[E >>> 4 & 15],
                          N = a[S >>> 28] | f[S >>> 24 & 15] | l[S >>> 20 & 15] | c[S >>> 16 & 15] | h[S >>> 12 & 15] | p[S >>> 8 & 15] | d[S >>> 4 & 15];
                      b = (N >>> 16 ^ T) & 65535, m[y++] = T ^ b, m[y++] = N ^ b << 16;
                    }
                  }
                  return m;
                }
                var t = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756],
                    n = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344],
                    r = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584],
                    i = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928],
                    s = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080],
                    o = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312],
                    u = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154],
                    a = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696],
                    l = function(l, c) {
                      typeof l == "string" && (l.length === 8 || l.length === 24) && (l = e.util.createBuffer(l));
                      var h = f(l),
                          p = 1,
                          d = 0,
                          v = 0,
                          m = 0,
                          g = 0,
                          y = !1,
                          b = null,
                          w = null,
                          E = h.length === 32 ? 3 : 9,
                          S;
                      E === 3 ? S = c ? [0, 32, 2] : [30, -2, -2] : S = c ? [0, 32, 2, 62, 30, -2, 64, 96, 2] : [94, 62, -2, 32, 64, 2, 30, -2, -2];
                      var x = null;
                      return x = {
                        start: function(t, n) {
                          t ? (typeof t == "string" && t.length === 8 && (t = e.util.createBuffer(t)), p = 1, d = t.getInt32(), m = t.getInt32()) : p = 0, y = !1, b = e.util.createBuffer(), w = n || e.util.createBuffer(), x.output = w;
                        },
                        update: function(e) {
                          y || b.putBuffer(e);
                          while (b.length() >= 8) {
                            var f,
                                l = b.getInt32(),
                                x = b.getInt32();
                            p === 1 && (c ? (l ^= d, x ^= m) : (v = d, g = m, d = l, m = x)), f = (l >>> 4 ^ x) & 252645135, x ^= f, l ^= f << 4, f = (l >>> 16 ^ x) & 65535, x ^= f, l ^= f << 16, f = (x >>> 2 ^ l) & 858993459, l ^= f, x ^= f << 2, f = (x >>> 8 ^ l) & 16711935, l ^= f, x ^= f << 8, f = (l >>> 1 ^ x) & 1431655765, x ^= f, l ^= f << 1, l = l << 1 | l >>> 31, x = x << 1 | x >>> 31;
                            for (var T = 0; T < E; T += 3) {
                              var N = S[T + 1],
                                  C = S[T + 2];
                              for (var k = S[T]; k != N; k += C) {
                                var L = x ^ h[k],
                                    A = (x >>> 4 | x << 28) ^ h[k + 1];
                                f = l, l = x, x = f ^ (n[L >>> 24 & 63] | i[L >>> 16 & 63] | o[L >>> 8 & 63] | a[L & 63] | t[A >>> 24 & 63] | r[A >>> 16 & 63] | s[A >>> 8 & 63] | u[A & 63]);
                              }
                              f = l, l = x, x = f;
                            }
                            l = l >>> 1 | l << 31, x = x >>> 1 | x << 31, f = (l >>> 1 ^ x) & 1431655765, x ^= f, l ^= f << 1, f = (x >>> 8 ^ l) & 16711935, l ^= f, x ^= f << 8, f = (x >>> 2 ^ l) & 858993459, l ^= f, x ^= f << 2, f = (l >>> 16 ^ x) & 65535, x ^= f, l ^= f << 16, f = (l >>> 4 ^ x) & 252645135, x ^= f, l ^= f << 4, p === 1 && (c ? (d = l, m = x) : (l ^= v, x ^= g)), w.putInt32(l), w.putInt32(x);
                          }
                        },
                        finish: function(e) {
                          var t = !0;
                          if (c)
                            if (e)
                              t = e(8, b, !c);
                            else {
                              var n = b.length() === 8 ? 8 : 8 - b.length();
                              b.fillWithByte(n, n);
                            }
                          t && (y = !0, x.update());
                          if (!c) {
                            t = b.length() === 0;
                            if (t)
                              if (e)
                                t = e(8, w, !c);
                              else {
                                var r = w.length(),
                                    i = w.at(r - 1);
                                i > r ? t = !1 : w.truncate(i);
                              }
                          }
                          return t;
                        }
                      }, x;
                    };
                e.des = e.des || {}, e.des.startEncrypting = function(e, t, n) {
                  var r = l(e, !0);
                  return r.start(t, n), r;
                }, e.des.createEncryptionCipher = function(e) {
                  return l(e, !0);
                }, e.des.startDecrypting = function(e, t, n) {
                  var r = l(e, !1);
                  return r.start(t, n), r;
                }, e.des.createDecryptionCipher = function(e) {
                  return l(e, !1);
                };
              }
              var r = "des";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/des", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.pkcs5 = e.pkcs5 || {};
                e.pbkdf2 = t.pbkdf2 = function(t, n, r, i, s) {
                  if (typeof s == "undefined" || s === null)
                    s = e.md.sha1.create();
                  var o = s.digestLength;
                  if (i > 4294967295 * o)
                    throw {message: "Derived key is too long."};
                  var u = Math.ceil(i / o),
                      a = i - (u - 1) * o,
                      f = e.hmac.create();
                  f.start(s, t);
                  var l = "",
                      c,
                      h,
                      p;
                  for (var d = 1; d <= u; ++d) {
                    f.start(null, null), f.update(n), f.update(e.util.int32ToBytes(d)), c = p = f.digest().getBytes();
                    for (var v = 2; v <= r; ++v)
                      f.start(null, null), f.update(p), h = f.digest().getBytes(), c = e.util.xorBytes(c, h, o), p = h;
                    l += d < u ? c : c.substr(0, a);
                  }
                  return l;
                };
              }
              var r = "pbkdf2";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pbkdf2", ["require", "module", "./hmac", "./md", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var n = typeof process != "undefined" && process.versions && process.versions.node,
                    r = null;
                !e.disableNativeCode && n && (r = t("crypto"));
                var i = e.prng = e.prng || {};
                i.create = function(t) {
                  function u(e) {
                    if (n.pools[0].messageLength >= 32)
                      return f(), e();
                    var t = 32 - n.pools[0].messageLength << 5;
                    n.seedFile(t, function(t, r) {
                      if (t)
                        return e(t);
                      n.collect(r), f(), e();
                    });
                  }
                  function a() {
                    if (n.pools[0].messageLength >= 32)
                      return f();
                    var e = 32 - n.pools[0].messageLength << 5;
                    n.collect(n.seedFileSync(e)), f();
                  }
                  function f() {
                    var t = e.md.sha1.create();
                    t.update(n.pools[0].digest().getBytes()), n.pools[0].start();
                    var r = 1;
                    for (var i = 1; i < 32; ++i)
                      r = r === 31 ? 2147483648 : r << 2, r % n.reseeds === 0 && (t.update(n.pools[i].digest().getBytes()), n.pools[i].start());
                    var s = t.digest().getBytes();
                    t.start(), t.update(s);
                    var o = t.digest().getBytes();
                    n.key = n.plugin.formatKey(s), n.seed = n.plugin.formatSeed(o), ++n.reseeds, n.generated = 0, n.time = +(new Date);
                  }
                  function l(t) {
                    var n = null;
                    if (typeof window != "undefined") {
                      var r = window.crypto || window.msCrypto;
                      r && r.getRandomValues && (n = function(e) {
                        return r.getRandomValues(e);
                      });
                    }
                    var i = e.util.createBuffer();
                    if (n)
                      while (i.length() < t) {
                        var s = Math.max(1, Math.min(t - i.length(), 65536) / 4),
                            o = new Uint32Array(Math.floor(s));
                        try {
                          n(o);
                          for (var u = 0; u < o.length; ++u)
                            i.putInt32(o[u]);
                        } catch (a) {
                          if (!(typeof QuotaExceededError != "undefined" && a instanceof QuotaExceededError))
                            throw a;
                        }
                      }
                    if (i.length() < t) {
                      var f,
                          l,
                          c,
                          h = Math.floor(Math.random() * 65536);
                      while (i.length() < t) {
                        l = 16807 * (h & 65535), f = 16807 * (h >> 16), l += (f & 32767) << 16, l += f >> 15, l = (l & 2147483647) + (l >> 31), h = l & 4294967295;
                        for (var u = 0; u < 3; ++u)
                          c = h >>> (u << 3), c ^= Math.floor(Math.random() * 256), i.putByte(String.fromCharCode(c & 255));
                      }
                    }
                    return i.getBytes(t);
                  }
                  var n = {
                    plugin: t,
                    key: null,
                    seed: null,
                    time: null,
                    reseeds: 0,
                    generated: 0
                  },
                      i = t.md,
                      s = new Array(32);
                  for (var o = 0; o < 32; ++o)
                    s[o] = i.create();
                  return n.pools = s, n.pool = 0, n.generate = function(t, r) {
                    function l(c) {
                      if (c)
                        return r(c);
                      if (f.length() >= t)
                        return r(null, f.getBytes(t));
                      if (n.generated >= 1048576) {
                        var h = +(new Date);
                        if (n.time === null || h - n.time > 100)
                          n.key = null;
                      }
                      if (n.key === null)
                        return u(l);
                      var p = i(n.key, n.seed);
                      n.generated += p.length, f.putBytes(p), n.key = o(i(n.key, s(n.seed))), n.seed = a(i(n.key, n.seed)), e.util.setImmediate(l);
                    }
                    if (!r)
                      return n.generateSync(t);
                    var i = n.plugin.cipher,
                        s = n.plugin.increment,
                        o = n.plugin.formatKey,
                        a = n.plugin.formatSeed,
                        f = e.util.createBuffer();
                    l();
                  }, n.generateSync = function(t) {
                    var r = n.plugin.cipher,
                        i = n.plugin.increment,
                        s = n.plugin.formatKey,
                        o = n.plugin.formatSeed,
                        u = e.util.createBuffer();
                    while (u.length() < t) {
                      if (n.generated >= 1048576) {
                        var f = +(new Date);
                        if (n.time === null || f - n.time > 100)
                          n.key = null;
                      }
                      n.key === null && a();
                      var l = r(n.key, n.seed);
                      n.generated += l.length, u.putBytes(l), n.key = s(r(n.key, i(n.seed))), n.seed = o(r(n.key, n.seed));
                    }
                    return u.getBytes(t);
                  }, r ? (n.seedFile = function(e, t) {
                    r.randomBytes(e, function(e, n) {
                      if (e)
                        return t(e);
                      t(null, n.toString());
                    });
                  }, n.seedFileSync = function(e) {
                    return r.randomBytes(e).toString();
                  }) : (n.seedFile = function(e, t) {
                    try {
                      t(null, l(e));
                    } catch (n) {
                      t(n);
                    }
                  }, n.seedFileSync = l), n.collect = function(e) {
                    var t = e.length;
                    for (var r = 0; r < t; ++r)
                      n.pools[n.pool].update(e.substr(r, 1)), n.pool = n.pool === 31 ? 0 : n.pool + 1;
                  }, n.collectInt = function(e, t) {
                    var r = "";
                    for (var i = 0; i < t; i += 8)
                      r += String.fromCharCode(e >> i & 255);
                    n.collect(r);
                  }, n.registerWorker = function(e) {
                    if (e === self)
                      n.seedFile = function(e, t) {
                        function n(e) {
                          var r = e.data;
                          r.forge && r.forge.prng && (self.removeEventListener("message", n), t(r.forge.prng.err, r.forge.prng.bytes));
                        }
                        self.addEventListener("message", n), self.postMessage({forge: {prng: {needed: e}}});
                      };
                    else {
                      function t(t) {
                        var r = t.data;
                        r.forge && r.forge.prng && n.seedFile(r.forge.prng.needed, function(t, n) {
                          e.postMessage({forge: {prng: {
                                err: t,
                                bytes: n
                              }}});
                        });
                      }
                      e.addEventListener("message", t);
                    }
                  }, n;
                };
              }
              var r = "prng";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/prng", ["require", "module", "./md", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                if (e.random && e.random.getBytes)
                  return;
                (function(t) {
                  var n = {},
                      r = new Array(4),
                      i = e.util.createBuffer();
                  n.formatKey = function(t) {
                    var n = e.util.createBuffer(t);
                    return t = new Array(4), t[0] = n.getInt32(), t[1] = n.getInt32(), t[2] = n.getInt32(), t[3] = n.getInt32(), e.aes._expandKey(t, !1);
                  }, n.formatSeed = function(t) {
                    var n = e.util.createBuffer(t);
                    return t = new Array(4), t[0] = n.getInt32(), t[1] = n.getInt32(), t[2] = n.getInt32(), t[3] = n.getInt32(), t;
                  }, n.cipher = function(t, n) {
                    return e.aes._updateBlock(t, n, r, !1), i.putInt32(r[0]), i.putInt32(r[1]), i.putInt32(r[2]), i.putInt32(r[3]), i.getBytes();
                  }, n.increment = function(e) {
                    return ++e[3], e;
                  }, n.md = e.md.sha1;
                  var s = e.prng.create(n),
                      o = typeof process != "undefined" && process.versions && process.versions.node,
                      u = null;
                  if (typeof window != "undefined") {
                    var a = window.crypto || window.msCrypto;
                    a && a.getRandomValues && (u = function(e) {
                      return a.getRandomValues(e);
                    });
                  }
                  if (e.disableNativeCode || !o && !u) {
                    typeof window == "undefined" || window.document === undefined, s.collectInt(+(new Date), 32);
                    if (typeof navigator != "undefined") {
                      var f = "";
                      for (var l in navigator)
                        try {
                          typeof navigator[l] == "string" && (f += navigator[l]);
                        } catch (c) {}
                      s.collect(f), f = null;
                    }
                    t && (t().mousemove(function(e) {
                      s.collectInt(e.clientX, 16), s.collectInt(e.clientY, 16);
                    }), t().keypress(function(e) {
                      s.collectInt(e.charCode, 8);
                    }));
                  }
                  if (!e.random)
                    e.random = s;
                  else
                    for (var l in s)
                      e.random[l] = s[l];
                  e.random.getBytes = function(t, n) {
                    return e.random.generate(t, n);
                  }, e.random.getBytesSync = function(t) {
                    return e.random.generate(t);
                  };
                })(typeof jQuery != "undefined" ? jQuery : null);
              }
              var r = "random";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/random", ["require", "module", "./aes", "./md", "./prng", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173],
                    n = [1, 2, 3, 5],
                    r = function(e, t) {
                      return e << t & 65535 | (e & 65535) >> 16 - t;
                    },
                    i = function(e, t) {
                      return (e & 65535) >> t | e << 16 - t & 65535;
                    };
                e.rc2 = e.rc2 || {}, e.rc2.expandKey = function(n, r) {
                  typeof n == "string" && (n = e.util.createBuffer(n)), r = r || 128;
                  var i = n,
                      s = n.length(),
                      o = r,
                      u = Math.ceil(o / 8),
                      a = 255 >> (o & 7),
                      f;
                  for (f = s; f < 128; f++)
                    i.putByte(t[i.at(f - 1) + i.at(f - s) & 255]);
                  i.setAt(128 - u, t[i.at(128 - u) & a]);
                  for (f = 127 - u; f >= 0; f--)
                    i.setAt(f, t[i.at(f + 1) ^ i.at(f + u)]);
                  return i;
                };
                var s = function(t, s, o) {
                  var u = !1,
                      a = null,
                      f = null,
                      l = null,
                      c,
                      h,
                      p,
                      d,
                      v = [];
                  t = e.rc2.expandKey(t, s);
                  for (p = 0; p < 64; p++)
                    v.push(t.getInt16Le());
                  o ? (c = function(e) {
                    for (p = 0; p < 4; p++)
                      e[p] += v[d] + (e[(p + 3) % 4] & e[(p + 2) % 4]) + (~e[(p + 3) % 4] & e[(p + 1) % 4]), e[p] = r(e[p], n[p]), d++;
                  }, h = function(e) {
                    for (p = 0; p < 4; p++)
                      e[p] += v[e[(p + 3) % 4] & 63];
                  }) : (c = function(e) {
                    for (p = 3; p >= 0; p--)
                      e[p] = i(e[p], n[p]), e[p] -= v[d] + (e[(p + 3) % 4] & e[(p + 2) % 4]) + (~e[(p + 3) % 4] & e[(p + 1) % 4]), d--;
                  }, h = function(e) {
                    for (p = 3; p >= 0; p--)
                      e[p] -= v[e[(p + 3) % 4] & 63];
                  });
                  var m = function(e) {
                    var t = [];
                    for (p = 0; p < 4; p++) {
                      var n = a.getInt16Le();
                      l !== null && (o ? n ^= l.getInt16Le() : l.putInt16Le(n)), t.push(n & 65535);
                    }
                    d = o ? 0 : 63;
                    for (var r = 0; r < e.length; r++)
                      for (var i = 0; i < e[r][0]; i++)
                        e[r][1](t);
                    for (p = 0; p < 4; p++)
                      l !== null && (o ? l.putInt16Le(t[p]) : t[p] ^= l.getInt16Le()), f.putInt16Le(t[p]);
                  },
                      g = null;
                  return g = {
                    start: function(t, n) {
                      t && typeof t == "string" && (t = e.util.createBuffer(t)), u = !1, a = e.util.createBuffer(), f = n || new e.util.createBuffer, l = t, g.output = f;
                    },
                    update: function(e) {
                      u || a.putBuffer(e);
                      while (a.length() >= 8)
                        m([[5, c], [1, h], [6, c], [1, h], [5, c]]);
                    },
                    finish: function(e) {
                      var t = !0;
                      if (o)
                        if (e)
                          t = e(8, a, !o);
                        else {
                          var n = a.length() === 8 ? 8 : 8 - a.length();
                          a.fillWithByte(n, n);
                        }
                      t && (u = !0, g.update());
                      if (!o) {
                        t = a.length() === 0;
                        if (t)
                          if (e)
                            t = e(8, f, !o);
                          else {
                            var r = f.length(),
                                i = f.at(r - 1);
                            i > r ? t = !1 : f.truncate(i);
                          }
                      }
                      return t;
                    }
                  }, g;
                };
                e.rc2.startEncrypting = function(t, n, r) {
                  var i = e.rc2.createEncryptionCipher(t, 128);
                  return i.start(n, r), i;
                }, e.rc2.createEncryptionCipher = function(e, t) {
                  return s(e, t, !0);
                }, e.rc2.startDecrypting = function(t, n, r) {
                  var i = e.rc2.createDecryptionCipher(t, 128);
                  return i.start(n, r), i;
                }, e.rc2.createDecryptionCipher = function(e, t) {
                  return s(e, t, !1);
                };
              }
              var r = "rc2";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/rc2", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function i(e, t, n) {
                  this.data = [], e != null && ("number" == typeof e ? this.fromNumber(e, t, n) : t == null && "string" != typeof e ? this.fromString(e, 256) : this.fromString(e, t));
                }
                function s() {
                  return new i(null);
                }
                function o(e, t, n, r, i, s) {
                  while (--s >= 0) {
                    var o = t * this.data[e++] + n.data[r] + i;
                    i = Math.floor(o / 67108864), n.data[r++] = o & 67108863;
                  }
                  return i;
                }
                function u(e, t, n, r, i, s) {
                  var o = t & 32767,
                      u = t >> 15;
                  while (--s >= 0) {
                    var a = this.data[e] & 32767,
                        f = this.data[e++] >> 15,
                        l = u * a + f * o;
                    a = o * a + ((l & 32767) << 15) + n.data[r] + (i & 1073741823), i = (a >>> 30) + (l >>> 15) + u * f + (i >>> 30), n.data[r++] = a & 1073741823;
                  }
                  return i;
                }
                function a(e, t, n, r, i, s) {
                  var o = t & 16383,
                      u = t >> 14;
                  while (--s >= 0) {
                    var a = this.data[e] & 16383,
                        f = this.data[e++] >> 14,
                        l = u * a + f * o;
                    a = o * a + ((l & 16383) << 14) + n.data[r] + i, i = (a >> 28) + (l >> 14) + u * f, n.data[r++] = a & 268435455;
                  }
                  return i;
                }
                function d(e) {
                  return l.charAt(e);
                }
                function v(e, t) {
                  var n = c[e.charCodeAt(t)];
                  return n == null ? -1 : n;
                }
                function m(e) {
                  for (var t = this.t - 1; t >= 0; --t)
                    e.data[t] = this.data[t];
                  e.t = this.t, e.s = this.s;
                }
                function g(e) {
                  this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this.data[0] = e : e < -1 ? this.data[0] = e + this.DV : this.t = 0;
                }
                function y(e) {
                  var t = s();
                  return t.fromInt(e), t;
                }
                function b(e, t) {
                  var n;
                  if (t == 16)
                    n = 4;
                  else if (t == 8)
                    n = 3;
                  else if (t == 256)
                    n = 8;
                  else if (t == 2)
                    n = 1;
                  else if (t == 32)
                    n = 5;
                  else {
                    if (t != 4) {
                      this.fromRadix(e, t);
                      return;
                    }
                    n = 2;
                  }
                  this.t = 0, this.s = 0;
                  var r = e.length,
                      s = !1,
                      o = 0;
                  while (--r >= 0) {
                    var u = n == 8 ? e[r] & 255 : v(e, r);
                    if (u < 0) {
                      e.charAt(r) == "-" && (s = !0);
                      continue;
                    }
                    s = !1, o == 0 ? this.data[this.t++] = u : o + n > this.DB ? (this.data[this.t - 1] |= (u & (1 << this.DB - o) - 1) << o, this.data[this.t++] = u >> this.DB - o) : this.data[this.t - 1] |= u << o, o += n, o >= this.DB && (o -= this.DB);
                  }
                  n == 8 && (e[0] & 128) != 0 && (this.s = -1, o > 0 && (this.data[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), s && i.ZERO.subTo(this, this);
                }
                function w() {
                  var e = this.s & this.DM;
                  while (this.t > 0 && this.data[this.t - 1] == e)
                    --this.t;
                }
                function E(e) {
                  if (this.s < 0)
                    return "-" + this.negate().toString(e);
                  var t;
                  if (e == 16)
                    t = 4;
                  else if (e == 8)
                    t = 3;
                  else if (e == 2)
                    t = 1;
                  else if (e == 32)
                    t = 5;
                  else {
                    if (e != 4)
                      return this.toRadix(e);
                    t = 2;
                  }
                  var n = (1 << t) - 1,
                      r,
                      i = !1,
                      s = "",
                      o = this.t,
                      u = this.DB - o * this.DB % t;
                  if (o-- > 0) {
                    u < this.DB && (r = this.data[o] >> u) > 0 && (i = !0, s = d(r));
                    while (o >= 0)
                      u < t ? (r = (this.data[o] & (1 << u) - 1) << t - u, r |= this.data[--o] >> (u += this.DB - t)) : (r = this.data[o] >> (u -= t) & n, u <= 0 && (u += this.DB, --o)), r > 0 && (i = !0), i && (s += d(r));
                  }
                  return i ? s : "0";
                }
                function S() {
                  var e = s();
                  return i.ZERO.subTo(this, e), e;
                }
                function x() {
                  return this.s < 0 ? this.negate() : this;
                }
                function T(e) {
                  var t = this.s - e.s;
                  if (t != 0)
                    return t;
                  var n = this.t;
                  t = n - e.t;
                  if (t != 0)
                    return this.s < 0 ? -t : t;
                  while (--n >= 0)
                    if ((t = this.data[n] - e.data[n]) != 0)
                      return t;
                  return 0;
                }
                function N(e) {
                  var t = 1,
                      n;
                  return (n = e >>> 16) != 0 && (e = n, t += 16), (n = e >> 8) != 0 && (e = n, t += 8), (n = e >> 4) != 0 && (e = n, t += 4), (n = e >> 2) != 0 && (e = n, t += 2), (n = e >> 1) != 0 && (e = n, t += 1), t;
                }
                function C() {
                  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + N(this.data[this.t - 1] ^ this.s & this.DM);
                }
                function k(e, t) {
                  var n;
                  for (n = this.t - 1; n >= 0; --n)
                    t.data[n + e] = this.data[n];
                  for (n = e - 1; n >= 0; --n)
                    t.data[n] = 0;
                  t.t = this.t + e, t.s = this.s;
                }
                function L(e, t) {
                  for (var n = e; n < this.t; ++n)
                    t.data[n - e] = this.data[n];
                  t.t = Math.max(this.t - e, 0), t.s = this.s;
                }
                function A(e, t) {
                  var n = e % this.DB,
                      r = this.DB - n,
                      i = (1 << r) - 1,
                      s = Math.floor(e / this.DB),
                      o = this.s << n & this.DM,
                      u;
                  for (u = this.t - 1; u >= 0; --u)
                    t.data[u + s + 1] = this.data[u] >> r | o, o = (this.data[u] & i) << n;
                  for (u = s - 1; u >= 0; --u)
                    t.data[u] = 0;
                  t.data[s] = o, t.t = this.t + s + 1, t.s = this.s, t.clamp();
                }
                function O(e, t) {
                  t.s = this.s;
                  var n = Math.floor(e / this.DB);
                  if (n >= this.t) {
                    t.t = 0;
                    return;
                  }
                  var r = e % this.DB,
                      i = this.DB - r,
                      s = (1 << r) - 1;
                  t.data[0] = this.data[n] >> r;
                  for (var o = n + 1; o < this.t; ++o)
                    t.data[o - n - 1] |= (this.data[o] & s) << i, t.data[o - n] = this.data[o] >> r;
                  r > 0 && (t.data[this.t - n - 1] |= (this.s & s) << i), t.t = this.t - n, t.clamp();
                }
                function M(e, t) {
                  var n = 0,
                      r = 0,
                      i = Math.min(e.t, this.t);
                  while (n < i)
                    r += this.data[n] - e.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                  if (e.t < this.t) {
                    r -= e.s;
                    while (n < this.t)
                      r += this.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                    r += this.s;
                  } else {
                    r += this.s;
                    while (n < e.t)
                      r -= e.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                    r -= e.s;
                  }
                  t.s = r < 0 ? -1 : 0, r < -1 ? t.data[n++] = this.DV + r : r > 0 && (t.data[n++] = r), t.t = n, t.clamp();
                }
                function _(e, t) {
                  var n = this.abs(),
                      r = e.abs(),
                      s = n.t;
                  t.t = s + r.t;
                  while (--s >= 0)
                    t.data[s] = 0;
                  for (s = 0; s < r.t; ++s)
                    t.data[s + n.t] = n.am(0, r.data[s], t, s, 0, n.t);
                  t.s = 0, t.clamp(), this.s != e.s && i.ZERO.subTo(t, t);
                }
                function D(e) {
                  var t = this.abs(),
                      n = e.t = 2 * t.t;
                  while (--n >= 0)
                    e.data[n] = 0;
                  for (n = 0; n < t.t - 1; ++n) {
                    var r = t.am(n, t.data[n], e, 2 * n, 0, 1);
                    (e.data[n + t.t] += t.am(n + 1, 2 * t.data[n], e, 2 * n + 1, r, t.t - n - 1)) >= t.DV && (e.data[n + t.t] -= t.DV, e.data[n + t.t + 1] = 1);
                  }
                  e.t > 0 && (e.data[e.t - 1] += t.am(n, t.data[n], e, 2 * n, 0, 1)), e.s = 0, e.clamp();
                }
                function P(e, t, n) {
                  var r = e.abs();
                  if (r.t <= 0)
                    return;
                  var o = this.abs();
                  if (o.t < r.t) {
                    t != null && t.fromInt(0), n != null && this.copyTo(n);
                    return;
                  }
                  n == null && (n = s());
                  var u = s(),
                      a = this.s,
                      f = e.s,
                      l = this.DB - N(r.data[r.t - 1]);
                  l > 0 ? (r.lShiftTo(l, u), o.lShiftTo(l, n)) : (r.copyTo(u), o.copyTo(n));
                  var c = u.t,
                      h = u.data[c - 1];
                  if (h == 0)
                    return;
                  var p = h * (1 << this.F1) + (c > 1 ? u.data[c - 2] >> this.F2 : 0),
                      d = this.FV / p,
                      v = (1 << this.F1) / p,
                      m = 1 << this.F2,
                      g = n.t,
                      y = g - c,
                      b = t == null ? s() : t;
                  u.dlShiftTo(y, b), n.compareTo(b) >= 0 && (n.data[n.t++] = 1, n.subTo(b, n)), i.ONE.dlShiftTo(c, b), b.subTo(u, u);
                  while (u.t < c)
                    u.data[u.t++] = 0;
                  while (--y >= 0) {
                    var w = n.data[--g] == h ? this.DM : Math.floor(n.data[g] * d + (n.data[g - 1] + m) * v);
                    if ((n.data[g] += u.am(0, w, n, y, 0, c)) < w) {
                      u.dlShiftTo(y, b), n.subTo(b, n);
                      while (n.data[g] < --w)
                        n.subTo(b, n);
                    }
                  }
                  t != null && (n.drShiftTo(c, t), a != f && i.ZERO.subTo(t, t)), n.t = c, n.clamp(), l > 0 && n.rShiftTo(l, n), a < 0 && i.ZERO.subTo(n, n);
                }
                function H(e) {
                  var t = s();
                  return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(i.ZERO) > 0 && e.subTo(t, t), t;
                }
                function B(e) {
                  this.m = e;
                }
                function j(e) {
                  return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e;
                }
                function F(e) {
                  return e;
                }
                function I(e) {
                  e.divRemTo(this.m, null, e);
                }
                function q(e, t, n) {
                  e.multiplyTo(t, n), this.reduce(n);
                }
                function R(e, t) {
                  e.squareTo(t), this.reduce(t);
                }
                function U() {
                  if (this.t < 1)
                    return 0;
                  var e = this.data[0];
                  if ((e & 1) == 0)
                    return 0;
                  var t = e & 3;
                  return t = t * (2 - (e & 15) * t) & 15, t = t * (2 - (e & 255) * t) & 255, t = t * (2 - ((e & 65535) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
                }
                function z(e) {
                  this.m = e, this.mp = e.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t;
                }
                function W(e) {
                  var t = s();
                  return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(i.ZERO) > 0 && this.m.subTo(t, t), t;
                }
                function X(e) {
                  var t = s();
                  return e.copyTo(t), this.reduce(t), t;
                }
                function V(e) {
                  while (e.t <= this.mt2)
                    e.data[e.t++] = 0;
                  for (var t = 0; t < this.m.t; ++t) {
                    var n = e.data[t] & 32767,
                        r = n * this.mpl + ((n * this.mph + (e.data[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
                    n = t + this.m.t, e.data[n] += this.m.am(0, r, e, t, 0, this.m.t);
                    while (e.data[n] >= e.DV)
                      e.data[n] -= e.DV, e.data[++n]++;
                  }
                  e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e);
                }
                function $(e, t) {
                  e.squareTo(t), this.reduce(t);
                }
                function J(e, t, n) {
                  e.multiplyTo(t, n), this.reduce(n);
                }
                function K() {
                  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
                }
                function Q(e, t) {
                  if (e > 4294967295 || e < 1)
                    return i.ONE;
                  var n = s(),
                      r = s(),
                      o = t.convert(this),
                      u = N(e) - 1;
                  o.copyTo(n);
                  while (--u >= 0) {
                    t.sqrTo(n, r);
                    if ((e & 1 << u) > 0)
                      t.mulTo(r, o, n);
                    else {
                      var a = n;
                      n = r, r = a;
                    }
                  }
                  return t.revert(n);
                }
                function G(e, t) {
                  var n;
                  return e < 256 || t.isEven() ? n = new B(t) : n = new z(t), this.exp(e, n);
                }
                function Y() {
                  var e = s();
                  return this.copyTo(e), e;
                }
                function Z() {
                  if (this.s < 0) {
                    if (this.t == 1)
                      return this.data[0] - this.DV;
                    if (this.t == 0)
                      return -1;
                  } else {
                    if (this.t == 1)
                      return this.data[0];
                    if (this.t == 0)
                      return 0;
                  }
                  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
                }
                function et() {
                  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
                }
                function tt() {
                  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
                }
                function nt(e) {
                  return Math.floor(Math.LN2 * this.DB / Math.log(e));
                }
                function rt() {
                  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
                }
                function it(e) {
                  e == null && (e = 10);
                  if (this.signum() == 0 || e < 2 || e > 36)
                    return "0";
                  var t = this.chunkSize(e),
                      n = Math.pow(e, t),
                      r = y(n),
                      i = s(),
                      o = s(),
                      u = "";
                  this.divRemTo(r, i, o);
                  while (i.signum() > 0)
                    u = (n + o.intValue()).toString(e).substr(1) + u, i.divRemTo(r, i, o);
                  return o.intValue().toString(e) + u;
                }
                function st(e, t) {
                  this.fromInt(0), t == null && (t = 10);
                  var n = this.chunkSize(t),
                      r = Math.pow(t, n),
                      s = !1,
                      o = 0,
                      u = 0;
                  for (var a = 0; a < e.length; ++a) {
                    var f = v(e, a);
                    if (f < 0) {
                      e.charAt(a) == "-" && this.signum() == 0 && (s = !0);
                      continue;
                    }
                    u = t * u + f, ++o >= n && (this.dMultiply(r), this.dAddOffset(u, 0), o = 0, u = 0);
                  }
                  o > 0 && (this.dMultiply(Math.pow(t, o)), this.dAddOffset(u, 0)), s && i.ZERO.subTo(this, this);
                }
                function ot(e, t, n) {
                  if ("number" == typeof t)
                    if (e < 2)
                      this.fromInt(1);
                    else {
                      this.fromNumber(e, n), this.testBit(e - 1) || this.bitwiseTo(i.ONE.shiftLeft(e - 1), dt, this), this.isEven() && this.dAddOffset(1, 0);
                      while (!this.isProbablePrime(t))
                        this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(i.ONE.shiftLeft(e - 1), this);
                    }
                  else {
                    var r = new Array,
                        s = e & 7;
                    r.length = (e >> 3) + 1, t.nextBytes(r), s > 0 ? r[0] &= (1 << s) - 1 : r[0] = 0, this.fromString(r, 256);
                  }
                }
                function ut() {
                  var e = this.t,
                      t = new Array;
                  t[0] = this.s;
                  var n = this.DB - e * this.DB % 8,
                      r,
                      i = 0;
                  if (e-- > 0) {
                    n < this.DB && (r = this.data[e] >> n) != (this.s & this.DM) >> n && (t[i++] = r | this.s << this.DB - n);
                    while (e >= 0) {
                      n < 8 ? (r = (this.data[e] & (1 << n) - 1) << 8 - n, r |= this.data[--e] >> (n += this.DB - 8)) : (r = this.data[e] >> (n -= 8) & 255, n <= 0 && (n += this.DB, --e)), (r & 128) != 0 && (r |= -256), i == 0 && (this.s & 128) != (r & 128) && ++i;
                      if (i > 0 || r != this.s)
                        t[i++] = r;
                    }
                  }
                  return t;
                }
                function at(e) {
                  return this.compareTo(e) == 0;
                }
                function ft(e) {
                  return this.compareTo(e) < 0 ? this : e;
                }
                function lt(e) {
                  return this.compareTo(e) > 0 ? this : e;
                }
                function ct(e, t, n) {
                  var r,
                      i,
                      s = Math.min(e.t, this.t);
                  for (r = 0; r < s; ++r)
                    n.data[r] = t(this.data[r], e.data[r]);
                  if (e.t < this.t) {
                    i = e.s & this.DM;
                    for (r = s; r < this.t; ++r)
                      n.data[r] = t(this.data[r], i);
                    n.t = this.t;
                  } else {
                    i = this.s & this.DM;
                    for (r = s; r < e.t; ++r)
                      n.data[r] = t(i, e.data[r]);
                    n.t = e.t;
                  }
                  n.s = t(this.s, e.s), n.clamp();
                }
                function ht(e, t) {
                  return e & t;
                }
                function pt(e) {
                  var t = s();
                  return this.bitwiseTo(e, ht, t), t;
                }
                function dt(e, t) {
                  return e | t;
                }
                function vt(e) {
                  var t = s();
                  return this.bitwiseTo(e, dt, t), t;
                }
                function mt(e, t) {
                  return e ^ t;
                }
                function gt(e) {
                  var t = s();
                  return this.bitwiseTo(e, mt, t), t;
                }
                function yt(e, t) {
                  return e & ~t;
                }
                function bt(e) {
                  var t = s();
                  return this.bitwiseTo(e, yt, t), t;
                }
                function wt() {
                  var e = s();
                  for (var t = 0; t < this.t; ++t)
                    e.data[t] = this.DM & ~this.data[t];
                  return e.t = this.t, e.s = ~this.s, e;
                }
                function Et(e) {
                  var t = s();
                  return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t;
                }
                function St(e) {
                  var t = s();
                  return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t;
                }
                function xt(e) {
                  if (e == 0)
                    return -1;
                  var t = 0;
                  return (e & 65535) == 0 && (e >>= 16, t += 16), (e & 255) == 0 && (e >>= 8, t += 8), (e & 15) == 0 && (e >>= 4, t += 4), (e & 3) == 0 && (e >>= 2, t += 2), (e & 1) == 0 && ++t, t;
                }
                function Tt() {
                  for (var e = 0; e < this.t; ++e)
                    if (this.data[e] != 0)
                      return e * this.DB + xt(this.data[e]);
                  return this.s < 0 ? this.t * this.DB : -1;
                }
                function Nt(e) {
                  var t = 0;
                  while (e != 0)
                    e &= e - 1, ++t;
                  return t;
                }
                function Ct() {
                  var e = 0,
                      t = this.s & this.DM;
                  for (var n = 0; n < this.t; ++n)
                    e += Nt(this.data[n] ^ t);
                  return e;
                }
                function kt(e) {
                  var t = Math.floor(e / this.DB);
                  return t >= this.t ? this.s != 0 : (this.data[t] & 1 << e % this.DB) != 0;
                }
                function Lt(e, t) {
                  var n = i.ONE.shiftLeft(e);
                  return this.bitwiseTo(n, t, n), n;
                }
                function At(e) {
                  return this.changeBit(e, dt);
                }
                function Ot(e) {
                  return this.changeBit(e, yt);
                }
                function Mt(e) {
                  return this.changeBit(e, mt);
                }
                function _t(e, t) {
                  var n = 0,
                      r = 0,
                      i = Math.min(e.t, this.t);
                  while (n < i)
                    r += this.data[n] + e.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                  if (e.t < this.t) {
                    r += e.s;
                    while (n < this.t)
                      r += this.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                    r += this.s;
                  } else {
                    r += this.s;
                    while (n < e.t)
                      r += e.data[n], t.data[n++] = r & this.DM, r >>= this.DB;
                    r += e.s;
                  }
                  t.s = r < 0 ? -1 : 0, r > 0 ? t.data[n++] = r : r < -1 && (t.data[n++] = this.DV + r), t.t = n, t.clamp();
                }
                function Dt(e) {
                  var t = s();
                  return this.addTo(e, t), t;
                }
                function Pt(e) {
                  var t = s();
                  return this.subTo(e, t), t;
                }
                function Ht(e) {
                  var t = s();
                  return this.multiplyTo(e, t), t;
                }
                function Bt(e) {
                  var t = s();
                  return this.divRemTo(e, t, null), t;
                }
                function jt(e) {
                  var t = s();
                  return this.divRemTo(e, null, t), t;
                }
                function Ft(e) {
                  var t = s(),
                      n = s();
                  return this.divRemTo(e, t, n), new Array(t, n);
                }
                function It(e) {
                  this.data[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp();
                }
                function qt(e, t) {
                  if (e == 0)
                    return;
                  while (this.t <= t)
                    this.data[this.t++] = 0;
                  this.data[t] += e;
                  while (this.data[t] >= this.DV)
                    this.data[t] -= this.DV, ++t >= this.t && (this.data[this.t++] = 0), ++this.data[t];
                }
                function Rt() {}
                function Ut(e) {
                  return e;
                }
                function zt(e, t, n) {
                  e.multiplyTo(t, n);
                }
                function Wt(e, t) {
                  e.squareTo(t);
                }
                function Xt(e) {
                  return this.exp(e, new Rt);
                }
                function Vt(e, t, n) {
                  var r = Math.min(this.t + e.t, t);
                  n.s = 0, n.t = r;
                  while (r > 0)
                    n.data[--r] = 0;
                  var i;
                  for (i = n.t - this.t; r < i; ++r)
                    n.data[r + this.t] = this.am(0, e.data[r], n, r, 0, this.t);
                  for (i = Math.min(e.t, t); r < i; ++r)
                    this.am(0, e.data[r], n, r, 0, t - r);
                  n.clamp();
                }
                function $t(e, t, n) {
                  --t;
                  var r = n.t = this.t + e.t - t;
                  n.s = 0;
                  while (--r >= 0)
                    n.data[r] = 0;
                  for (r = Math.max(t - this.t, 0); r < e.t; ++r)
                    n.data[this.t + r - t] = this.am(t - r, e.data[r], n, 0, 0, this.t + r - t);
                  n.clamp(), n.drShiftTo(1, n);
                }
                function Jt(e) {
                  this.r2 = s(), this.q3 = s(), i.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e;
                }
                function Kt(e) {
                  if (e.s < 0 || e.t > 2 * this.m.t)
                    return e.mod(this.m);
                  if (e.compareTo(this.m) < 0)
                    return e;
                  var t = s();
                  return e.copyTo(t), this.reduce(t), t;
                }
                function Qt(e) {
                  return e;
                }
                function Gt(e) {
                  e.drShiftTo(this.m.t - 1, this.r2), e.t > this.m.t + 1 && (e.t = this.m.t + 1, e.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
                  while (e.compareTo(this.r2) < 0)
                    e.dAddOffset(1, this.m.t + 1);
                  e.subTo(this.r2, e);
                  while (e.compareTo(this.m) >= 0)
                    e.subTo(this.m, e);
                }
                function Yt(e, t) {
                  e.squareTo(t), this.reduce(t);
                }
                function Zt(e, t, n) {
                  e.multiplyTo(t, n), this.reduce(n);
                }
                function en(e, t) {
                  var n = e.bitLength(),
                      r,
                      i = y(1),
                      o;
                  if (n <= 0)
                    return i;
                  n < 18 ? r = 1 : n < 48 ? r = 3 : n < 144 ? r = 4 : n < 768 ? r = 5 : r = 6, n < 8 ? o = new B(t) : t.isEven() ? o = new Jt(t) : o = new z(t);
                  var u = new Array,
                      a = 3,
                      f = r - 1,
                      l = (1 << r) - 1;
                  u[1] = o.convert(this);
                  if (r > 1) {
                    var c = s();
                    o.sqrTo(u[1], c);
                    while (a <= l)
                      u[a] = s(), o.mulTo(c, u[a - 2], u[a]), a += 2;
                  }
                  var h = e.t - 1,
                      p,
                      d = !0,
                      v = s(),
                      m;
                  n = N(e.data[h]) - 1;
                  while (h >= 0) {
                    n >= f ? p = e.data[h] >> n - f & l : (p = (e.data[h] & (1 << n + 1) - 1) << f - n, h > 0 && (p |= e.data[h - 1] >> this.DB + n - f)), a = r;
                    while ((p & 1) == 0)
                      p >>= 1, --a;
                    (n -= a) < 0 && (n += this.DB, --h);
                    if (d)
                      u[p].copyTo(i), d = !1;
                    else {
                      while (a > 1)
                        o.sqrTo(i, v), o.sqrTo(v, i), a -= 2;
                      a > 0 ? o.sqrTo(i, v) : (m = i, i = v, v = m), o.mulTo(v, u[p], i);
                    }
                    while (h >= 0 && (e.data[h] & 1 << n) == 0)
                      o.sqrTo(i, v), m = i, i = v, v = m, --n < 0 && (n = this.DB - 1, --h);
                  }
                  return o.revert(i);
                }
                function tn(e) {
                  var t = this.s < 0 ? this.negate() : this.clone(),
                      n = e.s < 0 ? e.negate() : e.clone();
                  if (t.compareTo(n) < 0) {
                    var r = t;
                    t = n, n = r;
                  }
                  var i = t.getLowestSetBit(),
                      s = n.getLowestSetBit();
                  if (s < 0)
                    return t;
                  i < s && (s = i), s > 0 && (t.rShiftTo(s, t), n.rShiftTo(s, n));
                  while (t.signum() > 0)
                    (i = t.getLowestSetBit()) > 0 && t.rShiftTo(i, t), (i = n.getLowestSetBit()) > 0 && n.rShiftTo(i, n), t.compareTo(n) >= 0 ? (t.subTo(n, t), t.rShiftTo(1, t)) : (n.subTo(t, n), n.rShiftTo(1, n));
                  return s > 0 && n.lShiftTo(s, n), n;
                }
                function nn(e) {
                  if (e <= 0)
                    return 0;
                  var t = this.DV % e,
                      n = this.s < 0 ? e - 1 : 0;
                  if (this.t > 0)
                    if (t == 0)
                      n = this.data[0] % e;
                    else
                      for (var r = this.t - 1; r >= 0; --r)
                        n = (t * n + this.data[r]) % e;
                  return n;
                }
                function rn(e) {
                  var t = e.isEven();
                  if (this.isEven() && t || e.signum() == 0)
                    return i.ZERO;
                  var n = e.clone(),
                      r = this.clone(),
                      s = y(1),
                      o = y(0),
                      u = y(0),
                      a = y(1);
                  while (n.signum() != 0) {
                    while (n.isEven()) {
                      n.rShiftTo(1, n);
                      if (t) {
                        if (!s.isEven() || !o.isEven())
                          s.addTo(this, s), o.subTo(e, o);
                        s.rShiftTo(1, s);
                      } else
                        o.isEven() || o.subTo(e, o);
                      o.rShiftTo(1, o);
                    }
                    while (r.isEven()) {
                      r.rShiftTo(1, r);
                      if (t) {
                        if (!u.isEven() || !a.isEven())
                          u.addTo(this, u), a.subTo(e, a);
                        u.rShiftTo(1, u);
                      } else
                        a.isEven() || a.subTo(e, a);
                      a.rShiftTo(1, a);
                    }
                    n.compareTo(r) >= 0 ? (n.subTo(r, n), t && s.subTo(u, s), o.subTo(a, o)) : (r.subTo(n, r), t && u.subTo(s, u), a.subTo(o, a));
                  }
                  return r.compareTo(i.ONE) != 0 ? i.ZERO : a.compareTo(e) >= 0 ? a.subtract(e) : a.signum() < 0 ? (a.addTo(e, a), a.signum() < 0 ? a.add(e) : a) : a;
                }
                function un(e) {
                  var t,
                      n = this.abs();
                  if (n.t == 1 && n.data[0] <= sn[sn.length - 1]) {
                    for (t = 0; t < sn.length; ++t)
                      if (n.data[0] == sn[t])
                        return !0;
                    return !1;
                  }
                  if (n.isEven())
                    return !1;
                  t = 1;
                  while (t < sn.length) {
                    var r = sn[t],
                        i = t + 1;
                    while (i < sn.length && r < on)
                      r *= sn[i++];
                    r = n.modInt(r);
                    while (t < i)
                      if (r % sn[t++] == 0)
                        return !1;
                  }
                  return n.millerRabin(e);
                }
                function an(e) {
                  var t = this.subtract(i.ONE),
                      n = t.getLowestSetBit();
                  if (n <= 0)
                    return !1;
                  var r = t.shiftRight(n),
                      s = fn(),
                      o;
                  for (var u = 0; u < e; ++u) {
                    do
                      o = new i(this.bitLength(), s);
 while (o.compareTo(i.ONE) <= 0 || o.compareTo(t) >= 0);
                    var a = o.modPow(r, this);
                    if (a.compareTo(i.ONE) != 0 && a.compareTo(t) != 0) {
                      var f = 1;
                      while (f++ < n && a.compareTo(t) != 0) {
                        a = a.modPowInt(2, this);
                        if (a.compareTo(i.ONE) == 0)
                          return !1;
                      }
                      if (a.compareTo(t) != 0)
                        return !1;
                    }
                  }
                  return !0;
                }
                function fn() {
                  return {nextBytes: function(e) {
                      for (var t = 0; t < e.length; ++t)
                        e[t] = Math.floor(Math.random() * 255);
                    }};
                }
                var t,
                    n = 0xdeadbeefcafe,
                    r = (n & 16777215) == 15715070;
                typeof navigator == "undefined" ? (i.prototype.am = a, t = 28) : r && navigator.appName == "Microsoft Internet Explorer" ? (i.prototype.am = u, t = 30) : r && navigator.appName != "Netscape" ? (i.prototype.am = o, t = 26) : (i.prototype.am = a, t = 28), i.prototype.DB = t, i.prototype.DM = (1 << t) - 1, i.prototype.DV = 1 << t;
                var f = 52;
                i.prototype.FV = Math.pow(2, f), i.prototype.F1 = f - t, i.prototype.F2 = 2 * t - f;
                var l = "0123456789abcdefghijklmnopqrstuvwxyz",
                    c = new Array,
                    h,
                    p;
                h = "0".charCodeAt(0);
                for (p = 0; p <= 9; ++p)
                  c[h++] = p;
                h = "a".charCodeAt(0);
                for (p = 10; p < 36; ++p)
                  c[h++] = p;
                h = "A".charCodeAt(0);
                for (p = 10; p < 36; ++p)
                  c[h++] = p;
                B.prototype.convert = j, B.prototype.revert = F, B.prototype.reduce = I, B.prototype.mulTo = q, B.prototype.sqrTo = R, z.prototype.convert = W, z.prototype.revert = X, z.prototype.reduce = V, z.prototype.mulTo = J, z.prototype.sqrTo = $, i.prototype.copyTo = m, i.prototype.fromInt = g, i.prototype.fromString = b, i.prototype.clamp = w, i.prototype.dlShiftTo = k, i.prototype.drShiftTo = L, i.prototype.lShiftTo = A, i.prototype.rShiftTo = O, i.prototype.subTo = M, i.prototype.multiplyTo = _, i.prototype.squareTo = D, i.prototype.divRemTo = P, i.prototype.invDigit = U, i.prototype.isEven = K, i.prototype.exp = Q, i.prototype.toString = E, i.prototype.negate = S, i.prototype.abs = x, i.prototype.compareTo = T, i.prototype.bitLength = C, i.prototype.mod = H, i.prototype.modPowInt = G, i.ZERO = y(0), i.ONE = y(1), Rt.prototype.convert = Ut, Rt.prototype.revert = Ut, Rt.prototype.mulTo = zt, Rt.prototype.sqrTo = Wt, Jt.prototype.convert = Kt, Jt.prototype.revert = Qt, Jt.prototype.reduce = Gt, Jt.prototype.mulTo = Zt, Jt.prototype.sqrTo = Yt;
                var sn = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509],
                    on = (1 << 26) / sn[sn.length - 1];
                i.prototype.chunkSize = nt, i.prototype.toRadix = it, i.prototype.fromRadix = st, i.prototype.fromNumber = ot, i.prototype.bitwiseTo = ct, i.prototype.changeBit = Lt, i.prototype.addTo = _t, i.prototype.dMultiply = It, i.prototype.dAddOffset = qt, i.prototype.multiplyLowerTo = Vt, i.prototype.multiplyUpperTo = $t, i.prototype.modInt = nn, i.prototype.millerRabin = an, i.prototype.clone = Y, i.prototype.intValue = Z, i.prototype.byteValue = et, i.prototype.shortValue = tt, i.prototype.signum = rt, i.prototype.toByteArray = ut, i.prototype.equals = at, i.prototype.min = ft, i.prototype.max = lt, i.prototype.and = pt, i.prototype.or = vt, i.prototype.xor = gt, i.prototype.andNot = bt, i.prototype.not = wt, i.prototype.shiftLeft = Et, i.prototype.shiftRight = St, i.prototype.getLowestSetBit = Tt, i.prototype.bitCount = Ct, i.prototype.testBit = kt, i.prototype.setBit = At, i.prototype.clearBit = Ot, i.prototype.flipBit = Mt, i.prototype.add = Dt, i.prototype.subtract = Pt, i.prototype.multiply = Ht, i.prototype.divide = Bt, i.prototype.remainder = jt, i.prototype.divideAndRemainder = Ft, i.prototype.modPow = en, i.prototype.modInverse = rn, i.prototype.pow = Xt, i.prototype.gcd = tn, i.prototype.isProbablePrime = un, e.jsbn = e.jsbn || {}, e.jsbn.BigInteger = i;
              }
              var r = "jsbn";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/jsbn", ["require", "module"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function n(e, t, n) {
                  var r = "",
                      i = Math.ceil(t / n.digestLength);
                  for (var s = 0; s < i; ++s) {
                    var o = String.fromCharCode(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, s & 255);
                    n.start(), n.update(e + o), r += n.digest().getBytes();
                  }
                  return r.substring(0, t);
                }
                var t = e.pkcs1 = e.pkcs1 || {};
                t.encode_rsa_oaep = function(t, r, i) {
                  var s = undefined,
                      o = undefined,
                      u = undefined;
                  typeof i == "string" ? (s = i, o = arguments[3] || undefined, u = arguments[4] || undefined) : i && (s = i.label || undefined, o = i.seed || undefined, u = i.md || undefined), u ? u.start() : u = e.md.sha1.create();
                  var a = Math.ceil(t.n.bitLength() / 8),
                      f = a - 2 * u.digestLength - 2;
                  if (r.length > f)
                    throw {
                      message: "RSAES-OAEP input message length is too long.",
                      length: r.length,
                      maxLength: f
                    };
                  s || (s = ""), u.update(s, "raw");
                  var l = u.digest(),
                      c = "",
                      h = f - r.length;
                  for (var p = 0; p < h; p++)
                    c += "\0";
                  var d = l.getBytes() + c + "" + r;
                  if (!o)
                    o = e.random.getBytes(u.digestLength);
                  else if (o.length !== u.digestLength)
                    throw {
                      message: "Invalid RSAES-OAEP seed. The seed length must match the digest length.",
                      seedLength: o.length,
                      digestLength: u.digestLength
                    };
                  var v = n(o, a - u.digestLength - 1, u),
                      m = e.util.xorBytes(d, v, d.length),
                      g = n(m, u.digestLength, u),
                      y = e.util.xorBytes(o, g, o.length);
                  return "\0" + y + m;
                }, t.decode_rsa_oaep = function(t, r, i) {
                  var s = undefined,
                      o = undefined;
                  typeof i == "string" ? (s = i, o = arguments[3] || undefined) : i && (s = i.label || undefined, o = i.md || undefined);
                  var u = Math.ceil(t.n.bitLength() / 8);
                  if (r.length !== u)
                    throw {
                      message: "RSAES-OAEP encoded message length is invalid.",
                      length: r.length,
                      expectedLength: u
                    };
                  o === undefined ? o = e.md.sha1.create() : o.start();
                  if (u < 2 * o.digestLength + 2)
                    throw {message: "RSAES-OAEP key is too short for the hash function."};
                  s || (s = ""), o.update(s, "raw");
                  var a = o.digest().getBytes(),
                      f = r.charAt(0),
                      l = r.substring(1, o.digestLength + 1),
                      c = r.substring(1 + o.digestLength),
                      h = n(c, o.digestLength, o),
                      p = e.util.xorBytes(l, h, l.length),
                      d = n(p, u - o.digestLength - 1, o),
                      v = e.util.xorBytes(c, d, c.length),
                      m = v.substring(0, o.digestLength),
                      g = f !== "\0";
                  for (var y = 0; y < o.digestLength; ++y)
                    g |= a.charAt(y) !== m.charAt(y);
                  var b = 1,
                      w = o.digestLength;
                  for (var E = o.digestLength; E < v.length; E++) {
                    var S = v.charCodeAt(E),
                        x = S & 1 ^ 1,
                        T = b ? 65534 : 0;
                    g |= S & T, b &= x, w += b;
                  }
                  if (g || v.charCodeAt(w) !== 1)
                    throw {message: "Invalid RSAES-OAEP padding."};
                  return v.substring(w + 1);
                };
              }
              var r = "pkcs1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pkcs1", ["require", "module", "./util", "./random", "./sha1"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function c(t, n, r) {
                  var i = e.util.createBuffer(),
                      s = Math.ceil(n.n.bitLength() / 8);
                  if (t.length > s - 11)
                    throw {
                      message: "Message is too long for PKCS#1 v1.5 padding.",
                      length: t.length,
                      max: s - 11
                    };
                  i.putByte(0), i.putByte(r);
                  var o = s - 3 - t.length,
                      u;
                  if (r === 0 || r === 1) {
                    u = r === 0 ? 0 : 255;
                    for (var a = 0; a < o; ++a)
                      i.putByte(u);
                  } else
                    while (o > 0) {
                      var f = 0,
                          l = e.random.getBytes(o);
                      for (var a = 0; a < o; ++a)
                        u = l.charCodeAt(a), u === 0 ? ++f : i.putByte(u);
                      o = f;
                    }
                  return i.putByte(0), i.putBytes(t), i;
                }
                function h(t, n, r, i) {
                  var s = Math.ceil(n.n.bitLength() / 8),
                      o = e.util.createBuffer(t),
                      u = o.getByte(),
                      a = o.getByte();
                  if (u !== 0 || r && a !== 0 && a !== 1 || !r && a != 2 || r && a === 0 && typeof i == "undefined")
                    throw {message: "Encryption block is invalid."};
                  var f = 0;
                  if (a === 0) {
                    f = s - 3 - i;
                    for (var l = 0; l < f; ++l)
                      if (o.getByte() !== 0)
                        throw {message: "Encryption block is invalid."};
                  } else if (a === 1) {
                    f = 0;
                    while (o.length() > 1) {
                      if (o.getByte() !== 255) {
                        --o.read;
                        break;
                      }
                      ++f;
                    }
                  } else if (a === 2) {
                    f = 0;
                    while (o.length() > 1) {
                      if (o.getByte() === 0) {
                        --o.read;
                        break;
                      }
                      ++f;
                    }
                  }
                  var c = o.getByte();
                  if (c !== 0 || f !== s - 3 - o.length())
                    throw {message: "Encryption block is invalid."};
                  return o.getBytes();
                }
                function p(n, i, s) {
                  function p() {
                    d(n.pBits, function(e, t) {
                      if (e)
                        return s(e);
                      n.p = t, d(n.qBits, v);
                    });
                  }
                  function d(e, r) {
                    function p() {
                      var r = e - 1,
                          i = new t(e, n.rng);
                      return i.testBit(r) || i.bitwiseTo(t.ONE.shiftLeft(r), h, i), i.dAddOffset(31 - i.mod(c).byteValue(), 0), i;
                    }
                    function v(s) {
                      if (d)
                        return;
                      --o;
                      var u = s.data;
                      if (u.found) {
                        for (var c = 0; c < i.length; ++c)
                          i[c].terminate();
                        return d = !0, r(null, new t(u.prime, 16));
                      }
                      l.bitLength() > e && (l = p());
                      var h = l.toString(16);
                      s.target.postMessage({
                        e: n.eInt,
                        hex: h,
                        workLoad: a
                      }), l.dAddOffset(f, 0);
                    }
                    var i = [];
                    for (var s = 0; s < u; ++s)
                      i[s] = new Worker("./forge/prime.worker.js");
                    var o = u,
                        l = p();
                    for (var s = 0; s < u; ++s)
                      i[s].addEventListener("message", v);
                    var d = !1;
                  }
                  function v(e, i) {
                    n.q = i;
                    if (n.p.compareTo(n.q) < 0) {
                      var o = n.p;
                      n.p = n.q, n.q = o;
                    }
                    n.p1 = n.p.subtract(t.ONE), n.q1 = n.q.subtract(t.ONE), n.phi = n.p1.multiply(n.q1);
                    if (n.phi.gcd(n.e).compareTo(t.ONE) !== 0) {
                      n.p = n.q = null, p();
                      return;
                    }
                    n.n = n.p.multiply(n.q);
                    if (n.n.bitLength() !== n.bits) {
                      n.q = null, d(n.qBits, v);
                      return;
                    }
                    var u = n.e.modInverse(n.phi);
                    n.keys = {
                      privateKey: r.rsa.setPrivateKey(n.n, n.e, u, n.p, n.q, u.mod(n.p1), u.mod(n.q1), n.q.modInverse(n.p)),
                      publicKey: r.rsa.setPublicKey(n.n, n.e)
                    }, s(null, n.keys);
                  }
                  typeof i == "function" && (s = i, i = {});
                  if (typeof Worker == "undefined") {
                    function o() {
                      if (r.rsa.stepKeyPairGenerationState(n, 10))
                        return s(null, n.keys);
                      e.util.setImmediate(o);
                    }
                    return o();
                  }
                  var u = i.workers || 2,
                      a = i.workLoad || 100,
                      f = a * 30 / 8,
                      l = i.workerScript || "forge/prime.worker.js",
                      c = new t(null);
                  c.fromInt(30);
                  var h = function(e, t) {
                    return e | t;
                  };
                  p();
                }
                function d(t) {
                  var n = t.toString(16);
                  return n[0] >= "8" && (n = "00" + n), e.util.hexToBytes(n);
                }
                function v(e) {
                  return e <= 100 ? 27 : e <= 150 ? 18 : e <= 200 ? 15 : e <= 250 ? 12 : e <= 300 ? 9 : e <= 350 ? 8 : e <= 400 ? 7 : e <= 500 ? 6 : e <= 600 ? 5 : e <= 800 ? 4 : e <= 1250 ? 3 : 2;
                }
                if (typeof t == "undefined")
                  var t = e.jsbn.BigInteger;
                var n = e.asn1;
                e.pki = e.pki || {}, e.pki.rsa = e.rsa = e.rsa || {};
                var r = e.pki,
                    i = [6, 4, 2, 4, 2, 4, 6, 2],
                    s = {
                      name: "PrivateKeyInfo",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "PrivateKeyInfo.version",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyVersion"
                      }, {
                        name: "PrivateKeyInfo.privateKeyAlgorithm",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "AlgorithmIdentifier.algorithm",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "privateKeyOid"
                        }]
                      }, {
                        name: "PrivateKeyInfo",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.OCTETSTRING,
                        constructed: !1,
                        capture: "privateKey"
                      }]
                    },
                    o = {
                      name: "RSAPrivateKey",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "RSAPrivateKey.version",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyVersion"
                      }, {
                        name: "RSAPrivateKey.modulus",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyModulus"
                      }, {
                        name: "RSAPrivateKey.publicExponent",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyPublicExponent"
                      }, {
                        name: "RSAPrivateKey.privateExponent",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyPrivateExponent"
                      }, {
                        name: "RSAPrivateKey.prime1",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyPrime1"
                      }, {
                        name: "RSAPrivateKey.prime2",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyPrime2"
                      }, {
                        name: "RSAPrivateKey.exponent1",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyExponent1"
                      }, {
                        name: "RSAPrivateKey.exponent2",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyExponent2"
                      }, {
                        name: "RSAPrivateKey.coefficient",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "privateKeyCoefficient"
                      }]
                    },
                    u = {
                      name: "RSAPublicKey",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "RSAPublicKey.modulus",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "publicKeyModulus"
                      }, {
                        name: "RSAPublicKey.exponent",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "publicKeyExponent"
                      }]
                    },
                    a = e.pki.rsa.publicKeyValidator = {
                      name: "SubjectPublicKeyInfo",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      captureAsn1: "subjectPublicKeyInfo",
                      value: [{
                        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "AlgorithmIdentifier.algorithm",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "publicKeyOid"
                        }]
                      }, {
                        name: "SubjectPublicKeyInfo.subjectPublicKey",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.BITSTRING,
                        constructed: !1,
                        value: [{
                          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.SEQUENCE,
                          constructed: !0,
                          optional: !0,
                          captureAsn1: "rsaPublicKey"
                        }]
                      }]
                    },
                    f = function(e) {
                      var t;
                      if (e.algorithm in r.oids) {
                        t = r.oids[e.algorithm];
                        var i = n.oidToDer(t).getBytes(),
                            s = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, []),
                            o = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, []);
                        o.value.push(n.create(n.Class.UNIVERSAL, n.Type.OID, !1, i)), o.value.push(n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, ""));
                        var u = n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, e.digest().getBytes());
                        return s.value.push(o), s.value.push(u), n.toDer(s).getBytes();
                      }
                      throw {
                        message: "Unknown message digest algorithm.",
                        algorithm: e.algorithm
                      };
                    },
                    l = function(e, n, r) {
                      var i;
                      if (r)
                        i = e.modPow(n.e, n.n);
                      else if (!n.p || !n.q)
                        i = e.modPow(n.d, n.n);
                      else {
                        n.dP || (n.dP = n.d.mod(n.p.subtract(t.ONE))), n.dQ || (n.dQ = n.d.mod(n.q.subtract(t.ONE))), n.qInv || (n.qInv = n.q.modInverse(n.p));
                        var s = e.mod(n.p).modPow(n.dP, n.p),
                            o = e.mod(n.q).modPow(n.dQ, n.q);
                        while (s.compareTo(o) < 0)
                          s = s.add(n.p);
                        i = s.subtract(o).multiply(n.qInv).mod(n.p).multiply(n.q).add(o);
                      }
                      return i;
                    };
                r.rsa.encrypt = function(n, r, i) {
                  var s = i,
                      o,
                      u = Math.ceil(r.n.bitLength() / 8);
                  i !== !1 && i !== !0 ? (s = i === 2, o = c(n, r, i)) : (o = e.util.createBuffer(), o.putBytes(n));
                  var a = new t(o.toHex(), 16),
                      f = l(a, r, s),
                      h = f.toString(16),
                      p = e.util.createBuffer(),
                      d = u - Math.ceil(h.length / 2);
                  while (d > 0)
                    p.putByte(0), --d;
                  return p.putBytes(e.util.hexToBytes(h)), p.getBytes();
                }, r.rsa.decrypt = function(n, r, i, s) {
                  var o = Math.ceil(r.n.bitLength() / 8);
                  if (n.length !== o)
                    throw {
                      message: "Encrypted message length is invalid.",
                      length: n.length,
                      expected: o
                    };
                  var u = new t(e.util.createBuffer(n).toHex(), 16);
                  if (u.compareTo(r.n) >= 0)
                    throw {message: "Encrypted message is invalid."};
                  var a = l(u, r, i),
                      f = a.toString(16),
                      c = e.util.createBuffer(),
                      p = o - Math.ceil(f.length / 2);
                  while (p > 0)
                    c.putByte(0), --p;
                  return c.putBytes(e.util.hexToBytes(f)), s !== !1 ? h(c.getBytes(), r, i) : c.getBytes();
                }, r.rsa.createKeyPairGenerationState = function(n, r) {
                  typeof n == "string" && (n = parseInt(n, 10)), n = n || 2048;
                  var i = {nextBytes: function(t) {
                      var n = e.random.getBytes(t.length);
                      for (var r = 0; r < t.length; ++r)
                        t[r] = n.charCodeAt(r);
                    }},
                      s = {
                        state: 0,
                        bits: n,
                        rng: i,
                        eInt: r || 65537,
                        e: new t(null),
                        p: null,
                        q: null,
                        qBits: n >> 1,
                        pBits: n - (n >> 1),
                        pqState: 0,
                        num: null,
                        keys: null
                      };
                  return s.e.fromInt(s.eInt), s;
                }, r.rsa.stepKeyPairGenerationState = function(e, n) {
                  var s = new t(null);
                  s.fromInt(30);
                  var o = 0,
                      u = function(e, t) {
                        return e | t;
                      },
                      a = +(new Date),
                      f,
                      l = 0;
                  while (e.keys === null && (n <= 0 || l < n)) {
                    if (e.state === 0) {
                      var c = e.p === null ? e.pBits : e.qBits,
                          h = c - 1;
                      e.pqState === 0 ? (e.num = new t(c, e.rng), e.num.testBit(h) || e.num.bitwiseTo(t.ONE.shiftLeft(h), u, e.num), e.num.dAddOffset(31 - e.num.mod(s).byteValue(), 0), o = 0, ++e.pqState) : e.pqState === 1 ? e.num.bitLength() > c ? e.pqState = 0 : e.num.isProbablePrime(v(e.num.bitLength())) ? ++e.pqState : e.num.dAddOffset(i[o++ % 8], 0) : e.pqState === 2 ? e.pqState = e.num.subtract(t.ONE).gcd(e.e).compareTo(t.ONE) === 0 ? 3 : 0 : e.pqState === 3 && (e.pqState = 0, e.p === null ? e.p = e.num : e.q = e.num, e.p !== null && e.q !== null && ++e.state, e.num = null);
                    } else if (e.state === 1)
                      e.p.compareTo(e.q) < 0 && (e.num = e.p, e.p = e.q, e.q = e.num), ++e.state;
                    else if (e.state === 2)
                      e.p1 = e.p.subtract(t.ONE), e.q1 = e.q.subtract(t.ONE), e.phi = e.p1.multiply(e.q1), ++e.state;
                    else if (e.state === 3)
                      e.phi.gcd(e.e).compareTo(t.ONE) === 0 ? ++e.state : (e.p = null, e.q = null, e.state = 0);
                    else if (e.state === 4)
                      e.n = e.p.multiply(e.q), e.n.bitLength() === e.bits ? ++e.state : (e.q = null, e.state = 0);
                    else if (e.state === 5) {
                      var p = e.e.modInverse(e.phi);
                      e.keys = {
                        privateKey: r.rsa.setPrivateKey(e.n, e.e, p, e.p, e.q, p.mod(e.p1), p.mod(e.q1), e.q.modInverse(e.p)),
                        publicKey: r.rsa.setPublicKey(e.n, e.e)
                      };
                    }
                    f = +(new Date), l += f - a, a = f;
                  }
                  return e.keys !== null;
                }, r.rsa.generateKeyPair = function(e, t, n, i) {
                  arguments.length === 1 ? typeof e == "object" ? (n = e, e = undefined) : typeof e == "function" && (i = e, e = undefined) : arguments.length === 2 ? (typeof e == "number" ? typeof t == "function" ? i = t : n = t : (n = e, i = t, e = undefined), t = undefined) : arguments.length === 3 && (typeof t == "number" ? typeof n == "function" && (i = n, n = undefined) : (i = n, n = t, t = undefined)), n = n || {}, e === undefined && (e = n.bits || 2048), t === undefined && (t = n.e || 65537);
                  var s = r.rsa.createKeyPairGenerationState(e, t);
                  if (!i)
                    return r.rsa.stepKeyPairGenerationState(s, 0), s.keys;
                  p(s, n, i);
                }, r.setRsaPublicKey = r.rsa.setPublicKey = function(t, i) {
                  var s = {
                    n: t,
                    e: i
                  };
                  return s.encrypt = function(t, n, i) {
                    typeof n == "string" ? n = n.toUpperCase() : n === undefined && (n = "RSAES-PKCS1-V1_5");
                    if (n === "RSAES-PKCS1-V1_5")
                      n = {encode: function(e, t, n) {
                          return c(e, t, 2).getBytes();
                        }};
                    else if (n === "RSA-OAEP" || n === "RSAES-OAEP")
                      n = {encode: function(t, n) {
                          return e.pkcs1.encode_rsa_oaep(n, t, i);
                        }};
                    else {
                      if (["RAW", "NONE", "NULL", null].indexOf(n) === -1)
                        throw {message: 'Unsupported encryption scheme: "' + n + '".'};
                      n = {encode: function(e) {
                          return e;
                        }};
                    }
                    var o = n.encode(t, s, !0);
                    return r.rsa.encrypt(o, s, !0);
                  }, s.verify = function(e, t, i) {
                    typeof i == "string" ? i = i.toUpperCase() : i === undefined && (i = "RSASSA-PKCS1-V1_5");
                    if (i === "RSASSA-PKCS1-V1_5")
                      i = {verify: function(e, t) {
                          t = h(t, s, !0);
                          var r = n.fromDer(t);
                          return e === r.value[1].value;
                        }};
                    else if (i === "NONE" || i === "NULL" || i === null)
                      i = {verify: function(e, t) {
                          return t = h(t, s, !0), e === t;
                        }};
                    var o = r.rsa.decrypt(t, s, !0, !1);
                    return i.verify(e, o, s.n.bitLength());
                  }, s;
                }, r.setRsaPrivateKey = r.rsa.setPrivateKey = function(t, n, i, s, o, u, a, l) {
                  var c = {
                    n: t,
                    e: n,
                    d: i,
                    p: s,
                    q: o,
                    dP: u,
                    dQ: a,
                    qInv: l
                  };
                  return c.decrypt = function(t, n, i) {
                    typeof n == "string" ? n = n.toUpperCase() : n === undefined && (n = "RSAES-PKCS1-V1_5");
                    var s = r.rsa.decrypt(t, c, !1, !1);
                    if (n === "RSAES-PKCS1-V1_5")
                      n = {decode: h};
                    else if (n === "RSA-OAEP" || n === "RSAES-OAEP")
                      n = {decode: function(t, n) {
                          return e.pkcs1.decode_rsa_oaep(n, t, i);
                        }};
                    else {
                      if (["RAW", "NONE", "NULL", null].indexOf(n) === -1)
                        throw {message: 'Unsupported encryption scheme: "' + n + '".'};
                      n = {decode: function(e) {
                          return e;
                        }};
                    }
                    return n.decode(s, c, !1);
                  }, c.sign = function(e, t) {
                    var n = !1;
                    typeof t == "string" && (t = t.toUpperCase());
                    if (t === undefined || t === "RSASSA-PKCS1-V1_5")
                      t = {encode: f}, n = 1;
                    else if (t === "NONE" || t === "NULL" || t === null)
                      t = {encode: function() {
                          return e;
                        }}, n = 1;
                    var i = t.encode(e, c.n.bitLength());
                    return r.rsa.encrypt(i, c, n);
                  }, c;
                }, r.wrapRsaPrivateKey = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(0).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(r.oids.rsaEncryption).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, "")]), n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, n.toDer(e).getBytes())]);
                }, r.wrapRsaPrivateKey = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(0).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(r.oids.rsaEncryption).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, "")]), n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, n.toDer(e).getBytes())]);
                }, r.privateKeyFromAsn1 = function(i) {
                  var u = {},
                      a = [];
                  n.validate(i, s, u, a) && (i = n.fromDer(e.util.createBuffer(u.privateKey))), u = {}, a = [];
                  if (!n.validate(i, o, u, a))
                    throw {
                      message: "Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.",
                      errors: a
                    };
                  var f,
                      l,
                      c,
                      h,
                      p,
                      d,
                      v,
                      m;
                  return f = e.util.createBuffer(u.privateKeyModulus).toHex(), l = e.util.createBuffer(u.privateKeyPublicExponent).toHex(), c = e.util.createBuffer(u.privateKeyPrivateExponent).toHex(), h = e.util.createBuffer(u.privateKeyPrime1).toHex(), p = e.util.createBuffer(u.privateKeyPrime2).toHex(), d = e.util.createBuffer(u.privateKeyExponent1).toHex(), v = e.util.createBuffer(u.privateKeyExponent2).toHex(), m = e.util.createBuffer(u.privateKeyCoefficient).toHex(), r.setRsaPrivateKey(new t(f, 16), new t(l, 16), new t(c, 16), new t(h, 16), new t(p, 16), new t(d, 16), new t(v, 16), new t(m, 16));
                }, r.privateKeyToAsn1 = r.privateKeyToRSAPrivateKey = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(0).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.n)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.e)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.d)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.p)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.q)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.dP)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.dQ)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.qInv))]);
                }, r.publicKeyFromAsn1 = function(i) {
                  var s = {},
                      o = [];
                  if (n.validate(i, a, s, o)) {
                    var f = n.derToOid(s.publicKeyOid);
                    if (f !== r.oids.rsaEncryption)
                      throw {
                        message: "Cannot read public key. Unknown OID.",
                        oid: f
                      };
                    i = s.rsaPublicKey;
                  }
                  o = [];
                  if (!n.validate(i, u, s, o))
                    throw {
                      message: "Cannot read public key. ASN.1 object does not contain an RSAPublicKey.",
                      errors: o
                    };
                  var l = e.util.createBuffer(s.publicKeyModulus).toHex(),
                      c = e.util.createBuffer(s.publicKeyExponent).toHex();
                  return r.setRsaPublicKey(new t(l, 16), new t(c, 16));
                }, r.publicKeyToAsn1 = r.publicKeyToSubjectPublicKeyInfo = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(r.oids.rsaEncryption).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, "")]), n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, [r.publicKeyToRSAPublicKey(e)])]);
                }, r.publicKeyToRSAPublicKey = function(e) {
                  return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.n)), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, d(e.e))]);
                };
              }
              var r = "rsa";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/rsa", ["require", "module", "./asn1", "./oids", "./random", "./util", "./jsbn", "./pkcs1"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function a(e, t, n) {
                  var r = [f(e + t)];
                  for (var i = 16,
                      s = 1; i < n; ++s, i += 16)
                    r.push(f(r[s - 1] + e + t));
                  return r.join("").substr(0, n);
                }
                function f(t) {
                  return e.md.md5.create().update(t).digest().getBytes();
                }
                if (typeof t == "undefined")
                  var t = e.jsbn.BigInteger;
                var n = e.asn1,
                    r = e.pki = e.pki || {};
                r.pbe = e.pbe = e.pbe || {};
                var i = r.oids,
                    s = {
                      name: "EncryptedPrivateKeyInfo",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "AlgorithmIdentifier.algorithm",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "encryptionOid"
                        }, {
                          name: "AlgorithmIdentifier.parameters",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.SEQUENCE,
                          constructed: !0,
                          captureAsn1: "encryptionParams"
                        }]
                      }, {
                        name: "EncryptedPrivateKeyInfo.encryptedData",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.OCTETSTRING,
                        constructed: !1,
                        capture: "encryptedData"
                      }]
                    },
                    o = {
                      name: "PBES2Algorithms",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "PBES2Algorithms.keyDerivationFunc",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "PBES2Algorithms.keyDerivationFunc.oid",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "kdfOid"
                        }, {
                          name: "PBES2Algorithms.params",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "PBES2Algorithms.params.salt",
                            tagClass: n.Class.UNIVERSAL,
                            type: n.Type.OCTETSTRING,
                            constructed: !1,
                            capture: "kdfSalt"
                          }, {
                            name: "PBES2Algorithms.params.iterationCount",
                            tagClass: n.Class.UNIVERSAL,
                            type: n.Type.INTEGER,
                            onstructed: !0,
                            capture: "kdfIterationCount"
                          }]
                        }]
                      }, {
                        name: "PBES2Algorithms.encryptionScheme",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "PBES2Algorithms.encryptionScheme.oid",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: "encOid"
                        }, {
                          name: "PBES2Algorithms.encryptionScheme.iv",
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OCTETSTRING,
                          constructed: !1,
                          capture: "encIv"
                        }]
                      }]
                    },
                    u = {
                      name: "pkcs-12PbeParams",
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "pkcs-12PbeParams.salt",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.OCTETSTRING,
                        constructed: !1,
                        capture: "salt"
                      }, {
                        name: "pkcs-12PbeParams.iterations",
                        tagClass: n.Class.UNIVERSAL,
                        type: n.Type.INTEGER,
                        constructed: !1,
                        capture: "iterations"
                      }]
                    };
                r.encryptPrivateKeyInfo = function(t, s, o) {
                  o = o || {}, o.saltSize = o.saltSize || 8, o.count = o.count || 2048, o.algorithm = o.algorithm || "aes128";
                  var u = e.random.getBytes(o.saltSize),
                      a = o.count,
                      f = n.integerToDer(a),
                      l,
                      c,
                      h;
                  if (o.algorithm.indexOf("aes") === 0) {
                    var p;
                    if (o.algorithm === "aes128")
                      l = 16, p = i["aes128-CBC"];
                    else if (o.algorithm === "aes192")
                      l = 24, p = i["aes192-CBC"];
                    else {
                      if (o.algorithm !== "aes256")
                        throw {
                          message: "Cannot encrypt private key. Unknown encryption algorithm.",
                          algorithm: o.algorithm
                        };
                      l = 32, p = i["aes256-CBC"];
                    }
                    var d = e.pkcs5.pbkdf2(s, u, a, l),
                        v = e.random.getBytes(16),
                        m = e.aes.createEncryptionCipher(d);
                    m.start(v), m.update(n.toDer(t)), m.finish(), h = m.output.getBytes(), c = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(i.pkcs5PBES2).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(i.pkcs5PBKDF2).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, u), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, f.getBytes())])]), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(p).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, v)])])]);
                  } else {
                    if (o.algorithm !== "3des")
                      throw {
                        message: "Cannot encrypt private key. Unknown encryption algorithm.",
                        algorithm: o.algorithm
                      };
                    l = 24;
                    var g = new e.util.ByteBuffer(u),
                        d = r.pbe.generatePkcs12Key(s, g, 1, a, l),
                        v = r.pbe.generatePkcs12Key(s, g, 2, a, l),
                        m = e.des.createEncryptionCipher(d);
                    m.start(v), m.update(n.toDer(t)), m.finish(), h = m.output.getBytes(), c = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(i["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, u), n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, f.getBytes())])]);
                  }
                  var y = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [c, n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, h)]);
                  return y;
                }, r.decryptPrivateKeyInfo = function(t, i) {
                  var o = null,
                      u = {},
                      a = [];
                  if (!n.validate(t, s, u, a))
                    throw {
                      message: "Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
                      errors: a
                    };
                  var f = n.derToOid(u.encryptionOid),
                      l = r.pbe.getCipher(f, u.encryptionParams, i),
                      c = e.util.createBuffer(u.encryptedData);
                  return l.update(c), l.finish() && (o = n.fromDer(l.output)), o;
                }, r.encryptedPrivateKeyToPem = function(t, r) {
                  var i = {
                    type: "ENCRYPTED PRIVATE KEY",
                    body: n.toDer(t).getBytes()
                  };
                  return e.pem.encode(i, {maxline: r});
                }, r.encryptedPrivateKeyFromPem = function(t) {
                  var r = e.pem.decode(t)[0];
                  if (r.type !== "ENCRYPTED PRIVATE KEY")
                    throw {
                      message: 'Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".',
                      headerType: r.type
                    };
                  if (r.procType && r.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert encrypted private key from PEM; PEM is encrypted."};
                  return n.fromDer(r.body);
                }, r.encryptRsaPrivateKey = function(t, i, s) {
                  s = s || {};
                  if (!s.legacy) {
                    var o = r.wrapRsaPrivateKey(r.privateKeyToAsn1(t));
                    return o = r.encryptPrivateKeyInfo(o, i, s), r.encryptedPrivateKeyToPem(o);
                  }
                  var u,
                      f,
                      l,
                      c;
                  switch (s.algorithm) {
                    case "aes128":
                      u = "AES-128-CBC", l = 16, f = e.random.getBytes(16), c = e.aes.createEncryptionCipher;
                      break;
                    case "aes192":
                      u = "AES-192-CBC", l = 24, f = e.random.getBytes(16), c = e.aes.createEncryptionCipher;
                      break;
                    case "aes256":
                      u = "AES-256-CBC", l = 32, f = e.random.getBytes(16), c = e.aes.createEncryptionCipher;
                      break;
                    case "3des":
                      u = "DES-EDE3-CBC", l = 24, f = e.random.getBytes(8), c = e.des.createEncryptionCipher;
                      break;
                    default:
                      throw {
                        message: 'Could not encrypt RSA private key; unsupported encryption algorithm "' + s.algorithm + '".',
                        algorithm: s.algorithm
                      };
                  }
                  var h = a(i, f.substr(0, 8), l),
                      p = c(h);
                  p.start(f), p.update(n.toDer(r.privateKeyToAsn1(t))), p.finish();
                  var d = {
                    type: "RSA PRIVATE KEY",
                    procType: {
                      version: "4",
                      type: "ENCRYPTED"
                    },
                    dekInfo: {
                      algorithm: u,
                      parameters: e.util.bytesToHex(f).toUpperCase()
                    },
                    body: p.output.getBytes()
                  };
                  return e.pem.encode(d);
                }, r.decryptRsaPrivateKey = function(t, i) {
                  var s = null,
                      o = e.pem.decode(t)[0];
                  if (o.type !== "ENCRYPTED PRIVATE KEY" && o.type !== "PRIVATE KEY" && o.type !== "RSA PRIVATE KEY")
                    throw {
                      message: 'Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".',
                      headerType: o.type
                    };
                  if (o.procType && o.procType.type === "ENCRYPTED") {
                    var u,
                        f;
                    switch (o.dekInfo.algorithm) {
                      case "DES-EDE3-CBC":
                        u = 24, f = e.des.createDecryptionCipher;
                        break;
                      case "AES-128-CBC":
                        u = 16, f = e.aes.createDecryptionCipher;
                        break;
                      case "AES-192-CBC":
                        u = 24, f = e.aes.createDecryptionCipher;
                        break;
                      case "AES-256-CBC":
                        u = 32, f = e.aes.createDecryptionCipher;
                        break;
                      case "RC2-40-CBC":
                        u = 5, f = function(t) {
                          return e.rc2.createDecryptionCipher(t, 40);
                        };
                        break;
                      case "RC2-64-CBC":
                        u = 8, f = function(t) {
                          return e.rc2.createDecryptionCipher(t, 64);
                        };
                        break;
                      case "RC2-128-CBC":
                        u = 16, f = function(t) {
                          return e.rc2.createDecryptionCipher(t, 128);
                        };
                        break;
                      default:
                        throw {
                          message: 'Could not decrypt private key; unsupported encryption algorithm "' + o.dekInfo.algorithm + '".',
                          algorithm: o.dekInfo.algorithm
                        };
                    }
                    var l = e.util.hexToBytes(o.dekInfo.parameters),
                        c = a(i, l.substr(0, 8), u),
                        h = f(c);
                    h.start(l), h.update(e.util.createBuffer(o.body));
                    if (!h.finish())
                      return s;
                    s = h.output.getBytes();
                  } else
                    s = o.body;
                  return o.type === "ENCRYPTED PRIVATE KEY" ? s = r.decryptPrivateKeyInfo(n.fromDer(s), i) : s = n.fromDer(s), s !== null && (s = r.privateKeyFromAsn1(s)), s;
                }, r.pbe.generatePkcs12Key = function(t, n, r, i, s, o) {
                  var u,
                      a;
                  if (typeof o == "undefined" || o === null)
                    o = e.md.sha1.create();
                  var f = o.digestLength,
                      l = o.blockLength,
                      c = new e.util.ByteBuffer,
                      h = new e.util.ByteBuffer;
                  for (a = 0; a < t.length; a++)
                    h.putInt16(t.charCodeAt(a));
                  h.putInt16(0);
                  var p = h.length(),
                      d = n.length(),
                      v = new e.util.ByteBuffer;
                  v.fillWithByte(r, l);
                  var m = l * Math.ceil(d / l),
                      g = new e.util.ByteBuffer;
                  for (a = 0; a < m; a++)
                    g.putByte(n.at(a % d));
                  var y = l * Math.ceil(p / l),
                      b = new e.util.ByteBuffer;
                  for (a = 0; a < y; a++)
                    b.putByte(h.at(a % p));
                  var w = g;
                  w.putBuffer(b);
                  var E = Math.ceil(s / f);
                  for (var S = 1; S <= E; S++) {
                    var x = new e.util.ByteBuffer;
                    x.putBytes(v.bytes()), x.putBytes(w.bytes());
                    for (var T = 0; T < i; T++)
                      o.start(), o.update(x.getBytes()), x = o.digest();
                    var N = new e.util.ByteBuffer;
                    for (a = 0; a < l; a++)
                      N.putByte(x.at(a % f));
                    var C = Math.ceil(d / l) + Math.ceil(p / l),
                        k = new e.util.ByteBuffer;
                    for (u = 0; u < C; u++) {
                      var L = new e.util.ByteBuffer(w.getBytes(l)),
                          A = 511;
                      for (a = N.length() - 1; a >= 0; a--)
                        A >>= 8, A += N.at(a) + L.at(a), L.setAt(a, A & 255);
                      k.putBuffer(L);
                    }
                    w = k, c.putBuffer(x);
                  }
                  return c.truncate(c.length() - s), c;
                }, r.pbe.getCipher = function(e, t, n) {
                  switch (e) {
                    case r.oids.pkcs5PBES2:
                      return r.pbe.getCipherForPBES2(e, t, n);
                    case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                    case r.oids["pbewithSHAAnd40BitRC2-CBC"]:
                      return r.pbe.getCipherForPKCS12PBE(e, t, n);
                    default:
                      throw {
                        message: "Cannot read encrypted PBE data block. Unsupported OID.",
                        oid: e,
                        supportedOids: ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"]
                      };
                  }
                }, r.pbe.getCipherForPBES2 = function(t, i, s) {
                  var u = {},
                      a = [];
                  if (!n.validate(i, o, u, a))
                    throw {
                      message: "Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
                      errors: a
                    };
                  t = n.derToOid(u.kdfOid);
                  if (t !== r.oids.pkcs5PBKDF2)
                    throw {
                      message: "Cannot read encrypted private key. Unsupported key derivation function OID.",
                      oid: t,
                      supportedOids: ["pkcs5PBKDF2"]
                    };
                  t = n.derToOid(u.encOid);
                  if (t !== r.oids["aes128-CBC"] && t !== r.oids["aes192-CBC"] && t !== r.oids["aes256-CBC"])
                    throw {
                      message: "Cannot read encrypted private key. Unsupported encryption scheme OID.",
                      oid: t,
                      supportedOids: ["aes128-CBC", "aes192-CBC", "aes256-CBC"]
                    };
                  var f = u.kdfSalt,
                      l = e.util.createBuffer(u.kdfIterationCount);
                  l = l.getInt(l.length() << 3);
                  var c;
                  t === r.oids["aes128-CBC"] ? c = 16 : t === r.oids["aes192-CBC"] ? c = 24 : t === r.oids["aes256-CBC"] && (c = 32);
                  var h = e.pkcs5.pbkdf2(s, f, l, c),
                      p = u.encIv,
                      d = e.aes.createDecryptionCipher(h);
                  return d.start(p), d;
                }, r.pbe.getCipherForPKCS12PBE = function(t, i, s) {
                  var o = {},
                      a = [];
                  if (!n.validate(i, u, o, a))
                    throw {
                      message: "Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
                      errors: a
                    };
                  var f = e.util.createBuffer(o.salt),
                      l = e.util.createBuffer(o.iterations);
                  l = l.getInt(l.length() << 3);
                  var c,
                      h,
                      p;
                  switch (t) {
                    case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                      c = 24, h = 8, p = e.des.startDecrypting;
                      break;
                    case r.oids["pbewithSHAAnd40BitRC2-CBC"]:
                      c = 5, h = 8, p = function(t, n) {
                        var r = e.rc2.createDecryptionCipher(t, 40);
                        return r.start(n, null), r;
                      };
                      break;
                    default:
                      throw {
                        message: "Cannot read PKCS #12 PBE data block. Unsupported OID.",
                        oid: t
                      };
                  }
                  var d = r.pbe.generatePkcs12Key(s, f, 1, l, c),
                      v = r.pbe.generatePkcs12Key(s, f, 2, l, h);
                  return p(d, v);
                };
              }
              var r = "pbe";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pbe", ["require", "module", "./aes", "./asn1", "./des", "./md", "./oids", "./pem", "./pbkdf2", "./random", "./rc2", "./rsa", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.asn1,
                    n = e.pkcs7asn1 = e.pkcs7asn1 || {};
                e.pkcs7 = e.pkcs7 || {}, e.pkcs7.asn1 = n;
                var r = {
                  name: "ContentInfo",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "ContentInfo.ContentType",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.OID,
                    constructed: !1,
                    capture: "contentType"
                  }, {
                    name: "ContentInfo.content",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 0,
                    constructed: !0,
                    optional: !0,
                    captureAsn1: "content"
                  }]
                };
                n.contentInfoValidator = r;
                var i = {
                  name: "EncryptedContentInfo",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "EncryptedContentInfo.contentType",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.OID,
                    constructed: !1,
                    capture: "contentType"
                  }, {
                    name: "EncryptedContentInfo.contentEncryptionAlgorithm",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0,
                    value: [{
                      name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OID,
                      constructed: !1,
                      capture: "encAlgorithm"
                    }, {
                      name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
                      tagClass: t.Class.UNIVERSAL,
                      captureAsn1: "encParameter"
                    }]
                  }, {
                    name: "EncryptedContentInfo.encryptedContent",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 0,
                    capture: "encryptedContent"
                  }]
                };
                n.envelopedDataValidator = {
                  name: "EnvelopedData",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "EnvelopedData.Version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1,
                    capture: "version"
                  }, {
                    name: "EnvelopedData.RecipientInfos",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SET,
                    constructed: !0,
                    captureAsn1: "recipientInfos"
                  }].concat(i)
                }, n.encryptedDataValidator = {
                  name: "EncryptedData",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "EncryptedData.Version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1,
                    capture: "version"
                  }].concat(i)
                };
                var s = {
                  name: "SignerInfo",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "SignerInfo.Version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1
                  }, {
                    name: "SignerInfo.IssuerAndSerialNumber",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0
                  }, {
                    name: "SignerInfo.DigestAlgorithm",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0
                  }, {
                    name: "SignerInfo.AuthenticatedAttributes",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 0,
                    constructed: !0,
                    optional: !0,
                    capture: "authenticatedAttributes"
                  }, {
                    name: "SignerInfo.DigestEncryptionAlgorithm",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0
                  }, {
                    name: "SignerInfo.EncryptedDigest",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.OCTETSTRING,
                    constructed: !1,
                    capture: "signature"
                  }, {
                    name: "SignerInfo.UnauthenticatedAttributes",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 1,
                    constructed: !0,
                    optional: !0
                  }]
                };
                n.signedDataValidator = {
                  name: "SignedData",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "SignedData.Version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1,
                    capture: "version"
                  }, {
                    name: "SignedData.DigestAlgorithms",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SET,
                    constructed: !0,
                    captureAsn1: "digestAlgorithms"
                  }, r, {
                    name: "SignedData.Certificates",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 0,
                    optional: !0,
                    captureAsn1: "certificates"
                  }, {
                    name: "SignedData.CertificateRevocationLists",
                    tagClass: t.Class.CONTEXT_SPECIFIC,
                    type: 1,
                    optional: !0,
                    captureAsn1: "crls"
                  }, {
                    name: "SignedData.SignerInfos",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SET,
                    capture: "signerInfos",
                    optional: !0,
                    value: [s]
                  }]
                }, n.recipientInfoValidator = {
                  name: "RecipientInfo",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: !0,
                  value: [{
                    name: "RecipientInfo.version",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.INTEGER,
                    constructed: !1,
                    capture: "version"
                  }, {
                    name: "RecipientInfo.issuerAndSerial",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0,
                    value: [{
                      name: "RecipientInfo.issuerAndSerial.issuer",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      captureAsn1: "issuer"
                    }, {
                      name: "RecipientInfo.issuerAndSerial.serialNumber",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.INTEGER,
                      constructed: !1,
                      capture: "serial"
                    }]
                  }, {
                    name: "RecipientInfo.keyEncryptionAlgorithm",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.SEQUENCE,
                    constructed: !0,
                    value: [{
                      name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OID,
                      constructed: !1,
                      capture: "encAlgorithm"
                    }, {
                      name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
                      tagClass: t.Class.UNIVERSAL,
                      constructed: !1,
                      captureAsn1: "encParameter"
                    }]
                  }, {
                    name: "RecipientInfo.encryptedKey",
                    tagClass: t.Class.UNIVERSAL,
                    type: t.Type.OCTETSTRING,
                    constructed: !1,
                    capture: "encKey"
                  }]
                };
              }
              var r = "pkcs7asn1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pkcs7asn1", ["require", "module", "./asn1", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.mgf = e.mgf || {};
                var t = e.mgf.mgf1 = e.mgf1 = e.mgf1 || {};
                t.create = function(t) {
                  var n = {generate: function(n, r) {
                      var i = new e.util.ByteBuffer,
                          s = Math.ceil(r / t.digestLength);
                      for (var o = 0; o < s; o++) {
                        var u = new e.util.ByteBuffer;
                        u.putInt32(o), t.start(), t.update(n + u.getBytes()), i.putBuffer(t.digest());
                      }
                      return i.truncate(i.length() - r), i.getBytes();
                    }};
                  return n;
                };
              }
              var r = "mgf1";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/mgf1", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.mgf = e.mgf || {}, e.mgf.mgf1 = e.mgf1;
              }
              var r = "mgf";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/mgf", ["require", "module", "./mgf1"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.pss = e.pss || {};
                t.create = function(t, n, r) {
                  var i = t.digestLength,
                      s = {};
                  return s.verify = function(s, o, u) {
                    var a,
                        f = u - 1,
                        l = Math.ceil(f / 8);
                    o = o.substr(-l);
                    if (l < i + r + 2)
                      throw {message: "Inconsistent parameters to PSS signature verification."};
                    if (o.charCodeAt(l - 1) !== 188)
                      throw {message: "Encoded message does not end in 0xBC."};
                    var c = l - i - 1,
                        h = o.substr(0, c),
                        p = o.substr(c, i),
                        d = 65280 >> 8 * l - f & 255;
                    if ((h.charCodeAt(0) & d) !== 0)
                      throw {message: "Bits beyond keysize not zero as expected."};
                    var v = n.generate(p, c),
                        m = "";
                    for (a = 0; a < c; a++)
                      m += String.fromCharCode(h.charCodeAt(a) ^ v.charCodeAt(a));
                    m = String.fromCharCode(m.charCodeAt(0) & ~d) + m.substr(1);
                    var g = l - i - r - 2;
                    for (a = 0; a < g; a++)
                      if (m.charCodeAt(a) !== 0)
                        throw {message: "Leftmost octets not zero as expected"};
                    if (m.charCodeAt(g) !== 1)
                      throw {message: "Inconsistent PSS signature, 0x01 marker not found"};
                    var y = m.substr(-r),
                        b = new e.util.ByteBuffer;
                    b.fillWithByte(0, 8), b.putBytes(s), b.putBytes(y), t.start(), t.update(b.getBytes());
                    var w = t.digest().getBytes();
                    return p === w;
                  }, s.encode = function(s, o) {
                    var u,
                        a = o - 1,
                        f = Math.ceil(a / 8),
                        l = s.digest().getBytes();
                    if (f < i + r + 2)
                      throw {message: "Message is too long to encrypt"};
                    var c = e.random.getBytes(r),
                        h = new e.util.ByteBuffer;
                    h.fillWithByte(0, 8), h.putBytes(l), h.putBytes(c), t.start(), t.update(h.getBytes());
                    var p = t.digest().getBytes(),
                        d = new e.util.ByteBuffer;
                    d.fillWithByte(0, f - r - i - 2), d.putByte(1), d.putBytes(c);
                    var v = d.getBytes(),
                        m = f - i - 1,
                        g = n.generate(p, m),
                        y = "";
                    for (u = 0; u < m; u++)
                      y += String.fromCharCode(v.charCodeAt(u) ^ g.charCodeAt(u));
                    var b = 65280 >> 8 * f - a & 255;
                    return y = String.fromCharCode(y.charCodeAt(0) & ~b) + y.substr(1), y + p + String.fromCharCode(188);
                  }, s;
                };
              }
              var r = "pss";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pss", ["require", "module", "./random", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function l(e, t) {
                  typeof t == "string" && (t = {shortName: t});
                  var n = null,
                      r;
                  for (var i = 0; n === null && i < e.attributes.length; ++i)
                    r = e.attributes[i], t.type && t.type === r.type ? n = r : t.name && t.name === r.name ? n = r : t.shortName && t.shortName === r.shortName && (n = r);
                  return n;
                }
                function p(n) {
                  var r = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []),
                      i,
                      s,
                      o = n.attributes;
                  for (var u = 0; u < o.length; ++u) {
                    i = o[u];
                    var a = i.value,
                        f = t.Type.PRINTABLESTRING;
                    "valueTagClass" in i && (f = i.valueTagClass, f === t.Type.UTF8 && (a = e.util.encodeUtf8(a))), s = t.create(t.Class.UNIVERSAL, t.Type.SET, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(i.type).getBytes()), t.create(t.Class.UNIVERSAL, f, !1, a)])]), r.value.push(s);
                  }
                  return r;
                }
                function d(e) {
                  var n = t.create(t.Class.CONTEXT_SPECIFIC, 3, !0, []),
                      r = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []);
                  n.value.push(r);
                  var i,
                      s;
                  for (var o = 0; o < e.length; ++o) {
                    i = e[o], s = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []), r.value.push(s), s.value.push(t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(i.id).getBytes())), i.critical && s.value.push(t.create(t.Class.UNIVERSAL, t.Type.BOOLEAN, !1, String.fromCharCode(255)));
                    var u = i.value;
                    typeof i.value != "string" && (u = t.toDer(u).getBytes()), s.value.push(t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, u));
                  }
                  return n;
                }
                function v(n) {
                  var r = {};
                  for (var i = 0; i < n.length; ++i) {
                    var s = n[i];
                    console.log("attr", s);
                    if (s.shortName && (s.valueTagClass === t.Type.UTF8 || s.valueTagClass === t.Type.PRINTABLESTRING || s.valueTagClass === t.Type.IA5String)) {
                      var o = s.value;
                      s.valueTagClass === t.Type.UTF8 && (o = e.util.encodeUtf8(s.value)), s.shortName in r ? e.util.isArray(r[s.shortName]) ? r[s.shortName].push(o) : r[s.shortName] = [r[s.shortName], o] : r[s.shortName] = o;
                    }
                  }
                  return r;
                }
                function m(e) {
                  var t;
                  for (var r = 0; r < e.length; ++r) {
                    t = e[r], typeof t.name == "undefined" && (t.type && t.type in n.oids ? t.name = n.oids[t.type] : t.shortName && t.shortName in i && (t.name = n.oids[i[t.shortName]]));
                    if (typeof t.type == "undefined") {
                      if (!(t.name && t.name in n.oids))
                        throw {
                          message: "Attribute type not specified.",
                          attribute: t
                        };
                      t.type = n.oids[t.name];
                    }
                    typeof t.shortName == "undefined" && t.name && t.name in i && (t.shortName = i[t.name]);
                    if (typeof t.value == "undefined")
                      throw {
                        message: "Attribute value not specified.",
                        attribute: t
                      };
                  }
                }
                function g(e, n) {
                  switch (e) {
                    case r["RSASSA-PSS"]:
                      var i = [];
                      return n.hash.algorithmOid !== undefined && i.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.hash.algorithmOid).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "")])])), n.mgf.algorithmOid !== undefined && i.push(t.create(t.Class.CONTEXT_SPECIFIC, 1, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.mgf.algorithmOid).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.mgf.hash.algorithmOid).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "")])])])), n.saltLength !== undefined && i.push(t.create(t.Class.CONTEXT_SPECIFIC, 2, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(n.saltLength).getBytes())])), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, i);
                    default:
                      return t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "");
                  }
                }
                function y(n) {
                  var r = t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, []);
                  if (n.attributes.length === 0)
                    return r;
                  var i = n.attributes;
                  for (var s = 0; s < i.length; ++s) {
                    var o = i[s],
                        u = o.value,
                        a = t.Type.UTF8;
                    "valueTagClass" in o && (a = o.valueTagClass), a === t.Type.UTF8 && (u = e.util.encodeUtf8(u));
                    var f = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(o.type).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, [t.create(t.Class.UNIVERSAL, a, !1, u)])]);
                    r.value.push(f);
                  }
                  return r;
                }
                var t = e.asn1,
                    n = e.pki = e.pki || {},
                    r = n.oids,
                    i = {};
                i.CN = r.commonName, i.commonName = "CN", i.C = r.countryName, i.countryName = "C", i.L = r.localityName, i.localityName = "L", i.ST = r.stateOrProvinceName, i.stateOrProvinceName = "ST", i.O = r.organizationName, i.organizationName = "O", i.OU = r.organizationalUnitName, i.organizationalUnitName = "OU", i.E = r.emailAddress, i.emailAddress = "E";
                var s = e.pki.rsa.publicKeyValidator,
                    o = {
                      name: "Certificate",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "Certificate.TBSCertificate",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        captureAsn1: "tbsCertificate",
                        value: [{
                          name: "Certificate.TBSCertificate.version",
                          tagClass: t.Class.CONTEXT_SPECIFIC,
                          type: 0,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.version.integer",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.INTEGER,
                            constructed: !1,
                            capture: "certVersion"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.serialNumber",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.INTEGER,
                          constructed: !1,
                          capture: "certSerialNumber"
                        }, {
                          name: "Certificate.TBSCertificate.signature",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.signature.algorithm",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OID,
                            constructed: !1,
                            capture: "certinfoSignatureOid"
                          }, {
                            name: "Certificate.TBSCertificate.signature.parameters",
                            tagClass: t.Class.UNIVERSAL,
                            optional: !0,
                            captureAsn1: "certinfoSignatureParams"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.issuer",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          captureAsn1: "certIssuer"
                        }, {
                          name: "Certificate.TBSCertificate.validity",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.UTCTIME,
                            constructed: !1,
                            optional: !0,
                            capture: "certValidity1UTCTime"
                          }, {
                            name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.GENERALIZEDTIME,
                            constructed: !1,
                            optional: !0,
                            capture: "certValidity2GeneralizedTime"
                          }, {
                            name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.UTCTIME,
                            constructed: !1,
                            optional: !0,
                            capture: "certValidity3UTCTime"
                          }, {
                            name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.GENERALIZEDTIME,
                            constructed: !1,
                            optional: !0,
                            capture: "certValidity4GeneralizedTime"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.subject",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          captureAsn1: "certSubject"
                        }, s, {
                          name: "Certificate.TBSCertificate.issuerUniqueID",
                          tagClass: t.Class.CONTEXT_SPECIFIC,
                          type: 1,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.issuerUniqueID.id",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.BITSTRING,
                            constructed: !1,
                            capture: "certIssuerUniqueId"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.subjectUniqueID",
                          tagClass: t.Class.CONTEXT_SPECIFIC,
                          type: 2,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "Certificate.TBSCertificate.subjectUniqueID.id",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.BITSTRING,
                            constructed: !1,
                            capture: "certSubjectUniqueId"
                          }]
                        }, {
                          name: "Certificate.TBSCertificate.extensions",
                          tagClass: t.Class.CONTEXT_SPECIFIC,
                          type: 3,
                          constructed: !0,
                          captureAsn1: "certExtensions",
                          optional: !0
                        }]
                      }, {
                        name: "Certificate.signatureAlgorithm",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "Certificate.signatureAlgorithm.algorithm",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.OID,
                          constructed: !1,
                          capture: "certSignatureOid"
                        }, {
                          name: "Certificate.TBSCertificate.signature.parameters",
                          tagClass: t.Class.UNIVERSAL,
                          optional: !0,
                          captureAsn1: "certSignatureParams"
                        }]
                      }, {
                        name: "Certificate.signatureValue",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.BITSTRING,
                        constructed: !1,
                        capture: "certSignature"
                      }]
                    },
                    u = {
                      name: "rsapss",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "rsapss.hashAlgorithm",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 0,
                        constructed: !0,
                        value: [{
                          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.SEQUENCE,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OID,
                            constructed: !1,
                            capture: "hashOid"
                          }]
                        }]
                      }, {
                        name: "rsapss.maskGenAlgorithm",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 1,
                        constructed: !0,
                        value: [{
                          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.SEQUENCE,
                          constructed: !0,
                          optional: !0,
                          value: [{
                            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OID,
                            constructed: !1,
                            capture: "maskGenOid"
                          }, {
                            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                              tagClass: t.Class.UNIVERSAL,
                              type: t.Type.OID,
                              constructed: !1,
                              capture: "maskGenHashOid"
                            }]
                          }]
                        }]
                      }, {
                        name: "rsapss.saltLength",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 2,
                        optional: !0,
                        value: [{
                          name: "rsapss.saltLength.saltLength",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.INTEGER,
                          constructed: !1,
                          capture: "saltLength"
                        }]
                      }, {
                        name: "rsapss.trailerField",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 3,
                        optional: !0,
                        value: [{
                          name: "rsapss.trailer.trailer",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.INTEGER,
                          constructed: !1,
                          capture: "trailer"
                        }]
                      }]
                    },
                    a = {
                      name: "CertificationRequestInfo",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      captureAsn1: "certificationRequestInfo",
                      value: [{
                        name: "CertificationRequestInfo.integer",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.INTEGER,
                        constructed: !1,
                        capture: "certificationRequestInfoVersion"
                      }, {
                        name: "CertificationRequestInfo.subject",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        captureAsn1: "certificationRequestInfoSubject"
                      }, s, {
                        name: "CertificationRequestInfo.attributes",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        type: 0,
                        constructed: !0,
                        optional: !0,
                        capture: "certificationRequestInfoAttributes",
                        value: [{
                          name: "CertificationRequestInfo.attributes",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "CertificationRequestInfo.attributes.type",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OID,
                            constructed: !1
                          }, {
                            name: "CertificationRequestInfo.attributes.value",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.SET,
                            constructed: !0
                          }]
                        }]
                      }]
                    },
                    f = {
                      name: "CertificationRequest",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      captureAsn1: "csr",
                      value: [a, {
                        name: "CertificationRequest.signatureAlgorithm",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                          name: "CertificationRequest.signatureAlgorithm.algorithm",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.OID,
                          constructed: !1,
                          capture: "csrSignatureOid"
                        }, {
                          name: "CertificationRequest.signatureAlgorithm.parameters",
                          tagClass: t.Class.UNIVERSAL,
                          optional: !0,
                          captureAsn1: "csrSignatureParams"
                        }]
                      }, {
                        name: "CertificationRequest.signature",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.BITSTRING,
                        constructed: !1,
                        capture: "csrSignature"
                      }]
                    };
                n.RDNAttributesAsArray = function(e, n) {
                  var s = [],
                      o,
                      u,
                      a;
                  for (var f = 0; f < e.value.length; ++f) {
                    o = e.value[f];
                    for (var l = 0; l < o.value.length; ++l)
                      a = {}, u = o.value[l], a.type = t.derToOid(u.value[0].value), a.value = u.value[1].value, a.valueTagClass = u.value[1].type, a.type in r && (a.name = r[a.type], a.name in i && (a.shortName = i[a.name])), n && (n.update(a.type), n.update(a.value)), s.push(a);
                  }
                  return s;
                }, n.CRIAttributesAsArray = function(e) {
                  var n = [];
                  for (var s = 0; s < e.length; ++s) {
                    var o = e[s],
                        u = t.derToOid(o.value[0].value),
                        a = o.value[1].value;
                    for (var f = 0; f < a.length; ++f) {
                      var l = {};
                      l.type = u, l.value = a[f].value, l.valueTagClass = a[f].type, l.type in r && (l.name = r[l.type], l.name in i && (l.shortName = i[l.name])), n.push(l);
                    }
                  }
                  return n;
                };
                var c = function(n) {
                  var i = [],
                      s,
                      o,
                      u;
                  for (var a = 0; a < n.value.length; ++a) {
                    u = n.value[a];
                    for (var f = 0; f < u.value.length; ++f) {
                      o = u.value[f], s = {}, s.id = t.derToOid(o.value[0].value), s.critical = !1, o.value[1].type === t.Type.BOOLEAN ? (s.critical = o.value[1].value.charCodeAt(0) !== 0, s.value = o.value[2].value) : s.value = o.value[1].value;
                      if (s.id in r) {
                        s.name = r[s.id];
                        if (s.name === "keyUsage") {
                          var l = t.fromDer(s.value),
                              c = 0,
                              h = 0;
                          l.value.length > 1 && (c = l.value.charCodeAt(1), h = l.value.length > 2 ? l.value.charCodeAt(2) : 0), s.digitalSignature = (c & 128) === 128, s.nonRepudiation = (c & 64) === 64, s.keyEncipherment = (c & 32) === 32, s.dataEncipherment = (c & 16) === 16, s.keyAgreement = (c & 8) === 8, s.keyCertSign = (c & 4) === 4, s.cRLSign = (c & 2) === 2, s.encipherOnly = (c & 1) === 1, s.decipherOnly = (h & 128) === 128;
                        } else if (s.name === "basicConstraints") {
                          var l = t.fromDer(s.value);
                          l.value.length > 0 && l.value[0].type === t.Type.BOOLEAN ? s.cA = l.value[0].value.charCodeAt(0) !== 0 : s.cA = !1;
                          var p = null;
                          l.value.length > 0 && l.value[0].type === t.Type.INTEGER ? p = l.value[0].value : l.value.length > 1 && (p = l.value[1].value), p !== null && (s.pathLenConstraint = t.derToInteger(p));
                        } else if (s.name === "extKeyUsage") {
                          var l = t.fromDer(s.value);
                          for (var d = 0; d < l.value.length; ++d) {
                            var v = t.derToOid(l.value[d].value);
                            v in r ? s[r[v]] = !0 : s[v] = !0;
                          }
                        } else if (s.name === "nsCertType") {
                          var l = t.fromDer(s.value),
                              c = 0;
                          l.value.length > 1 && (c = l.value.charCodeAt(1)), s.client = (c & 128) === 128, s.server = (c & 64) === 64, s.email = (c & 32) === 32, s.objsign = (c & 16) === 16, s.reserved = (c & 8) === 8, s.sslCA = (c & 4) === 4, s.emailCA = (c & 2) === 2, s.objCA = (c & 1) === 1;
                        } else if (s.name === "subjectAltName" || s.name === "issuerAltName") {
                          s.altNames = [];
                          var m,
                              l = t.fromDer(s.value);
                          for (var g = 0; g < l.value.length; ++g) {
                            m = l.value[g];
                            var y = {
                              type: m.type,
                              value: m.value
                            };
                            s.altNames.push(y);
                            switch (m.type) {
                              case 1:
                              case 2:
                              case 6:
                                break;
                              case 7:
                                y.ip = e.util.bytesToIP(m.value);
                                break;
                              case 8:
                                y.oid = t.derToOid(m.value);
                                break;
                              default:
                            }
                          }
                        } else if (s.name === "subjectKeyIdentifier") {
                          var l = t.fromDer(s.value);
                          s.subjectKeyIdentifier = e.util.bytesToHex(l.value);
                        }
                      }
                      i.push(s);
                    }
                  }
                  return i;
                },
                    h = function(e, n, i) {
                      var s = {};
                      if (e !== r["RSASSA-PSS"])
                        return s;
                      i && (s = {
                        hash: {algorithmOid: r.sha1},
                        mgf: {
                          algorithmOid: r.mgf1,
                          hash: {algorithmOid: r.sha1}
                        },
                        saltLength: 20
                      });
                      var o = {},
                          a = [];
                      if (!t.validate(n, u, o, a))
                        throw {
                          message: "Cannot read RSASSA-PSS parameter block.",
                          errors: a
                        };
                      return o.hashOid !== undefined && (s.hash = s.hash || {}, s.hash.algorithmOid = t.derToOid(o.hashOid)), o.maskGenOid !== undefined && (s.mgf = s.mgf || {}, s.mgf.algorithmOid = t.derToOid(o.maskGenOid), s.mgf.hash = s.mgf.hash || {}, s.mgf.hash.algorithmOid = t.derToOid(o.maskGenHashOid)), o.saltLength !== undefined && (s.saltLength = o.saltLength.charCodeAt(0)), s;
                    };
                n.certificateFromPem = function(r, i, s) {
                  var o = e.pem.decode(r)[0];
                  if (o.type !== "CERTIFICATE" && o.type !== "X509 CERTIFICATE" && o.type !== "TRUSTED CERTIFICATE")
                    throw {
                      message: 'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',
                      headerType: o.type
                    };
                  if (o.procType && o.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert certificate from PEM; PEM is encrypted."};
                  var u = t.fromDer(o.body, s);
                  return n.certificateFromAsn1(u, i);
                }, n.certificateToPem = function(r, i) {
                  var s = {
                    type: "CERTIFICATE",
                    body: t.toDer(n.certificateToAsn1(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                }, n.publicKeyFromPem = function(r) {
                  var i = e.pem.decode(r)[0];
                  if (i.type !== "PUBLIC KEY" && i.type !== "RSA PUBLIC KEY")
                    throw {
                      message: 'Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".',
                      headerType: i.type
                    };
                  if (i.procType && i.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert public key from PEM; PEM is encrypted."};
                  var s = t.fromDer(i.body);
                  return n.publicKeyFromAsn1(s);
                }, n.publicKeyToPem = function(r, i) {
                  var s = {
                    type: "PUBLIC KEY",
                    body: t.toDer(n.publicKeyToAsn1(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                }, n.publicKeyToRSAPublicKeyPem = function(r, i) {
                  var s = {
                    type: "RSA PUBLIC KEY",
                    body: t.toDer(n.publicKeyToRSAPublicKey(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                }, n.certificationRequestFromPem = function(r, i, s) {
                  var o = e.pem.decode(r)[0];
                  if (o.type !== "CERTIFICATE REQUEST")
                    throw {
                      message: 'Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".',
                      headerType: o.type
                    };
                  if (o.procType && o.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert certification request from PEM; PEM is encrypted."};
                  var u = t.fromDer(o.body, s);
                  return n.certificationRequestFromAsn1(u, i);
                }, n.certificationRequestToPem = function(r, i) {
                  var s = {
                    type: "CERTIFICATE REQUEST",
                    body: t.toDer(n.certificationRequestToAsn1(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                }, n.createCertificate = function() {
                  var i = {};
                  return i.version = 2, i.serialNumber = "00", i.signatureOid = null, i.signature = null, i.siginfo = {}, i.siginfo.algorithmOid = null, i.validity = {}, i.validity.notBefore = new Date, i.validity.notAfter = new Date, i.issuer = {}, i.issuer.getField = function(e) {
                    return l(i.issuer, e);
                  }, i.issuer.addField = function(e) {
                    m([e]), i.issuer.attributes.push(e);
                  }, i.issuer.attributes = [], i.issuer.hash = null, i.subject = {}, i.subject.getField = function(e) {
                    return l(i.subject, e);
                  }, i.subject.addField = function(e) {
                    m([e]), i.subject.attributes.push(e);
                  }, i.subject.attributes = [], i.subject.hash = null, i.extensions = [], i.publicKey = null, i.md = null, i.setSubject = function(e, t) {
                    m(e), i.subject.attributes = e, delete i.subject.uniqueId, t && (i.subject.uniqueId = t), i.subject.hash = null;
                  }, i.setIssuer = function(e, t) {
                    m(e), i.issuer.attributes = e, delete i.issuer.uniqueId, t && (i.issuer.uniqueId = t), i.issuer.hash = null;
                  }, i.setExtensions = function(s) {
                    var o;
                    for (var u = 0; u < s.length; ++u) {
                      o = s[u], typeof o.name == "undefined" && o.id && o.id in n.oids && (o.name = n.oids[o.id]);
                      if (typeof o.id == "undefined") {
                        if (!(o.name && o.name in n.oids))
                          throw {
                            message: "Extension ID not specified.",
                            extension: o
                          };
                        o.id = n.oids[o.name];
                      }
                      if (typeof o.value == "undefined") {
                        if (o.name === "keyUsage") {
                          var a = 0,
                              f = 0,
                              l = 0;
                          o.digitalSignature && (f |= 128, a = 7), o.nonRepudiation && (f |= 64, a = 6), o.keyEncipherment && (f |= 32, a = 5), o.dataEncipherment && (f |= 16, a = 4), o.keyAgreement && (f |= 8, a = 3), o.keyCertSign && (f |= 4, a = 2), o.cRLSign && (f |= 2, a = 1), o.encipherOnly && (f |= 1, a = 0), o.decipherOnly && (l |= 128, a = 7);
                          var c = String.fromCharCode(a);
                          l !== 0 ? c += String.fromCharCode(f) + String.fromCharCode(l) : f !== 0 && (c += String.fromCharCode(f)), o.value = t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, c);
                        } else if (o.name === "basicConstraints")
                          o.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []), o.cA && o.value.value.push(t.create(t.Class.UNIVERSAL, t.Type.BOOLEAN, !1, String.fromCharCode(255))), "pathLenConstraint" in o && o.value.value.push(t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(o.pathLenConstraint).getBytes()));
                        else if (o.name === "extKeyUsage") {
                          o.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []);
                          var h = o.value.value;
                          for (var p in o) {
                            if (o[p] !== !0)
                              continue;
                            p in r ? h.push(t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(r[p]).getBytes())) : p.indexOf(".") !== -1 && h.push(t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(p).getBytes()));
                          }
                        } else if (o.name === "nsCertType") {
                          var a = 0,
                              f = 0;
                          o.client && (f |= 128, a = 7), o.server && (f |= 64, a = 6), o.email && (f |= 32, a = 5), o.objsign && (f |= 16, a = 4), o.reserved && (f |= 8, a = 3), o.sslCA && (f |= 4, a = 2), o.emailCA && (f |= 2, a = 1), o.objCA && (f |= 1, a = 0);
                          var c = String.fromCharCode(a);
                          f !== 0 && (c += String.fromCharCode(f)), o.value = t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, c);
                        } else if (o.name === "subjectAltName" || o.name === "issuerAltName") {
                          o.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, []);
                          var d;
                          for (var v = 0; v < o.altNames.length; ++v) {
                            d = o.altNames[v];
                            var c = d.value;
                            if (d.type === 7 && d.ip) {
                              c = e.util.bytesFromIP(d.ip);
                              if (c === null)
                                throw {
                                  message: 'Extension "ip" value is not a valid IPv4 or IPv6 address.',
                                  extension: o
                                };
                            } else
                              d.type === 8 && (d.oid ? c = t.oidToDer(t.oidToDer(d.oid)) : c = t.oidToDer(c));
                            o.value.value.push(t.create(t.Class.CONTEXT_SPECIFIC, d.type, !1, c));
                          }
                        } else if (o.name === "subjectKeyIdentifier") {
                          var m = i.generateSubjectKeyIdentifier();
                          o.subjectKeyIdentifier = m.toHex(), o.value = t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, m.getBytes());
                        }
                        if (typeof o.value == "undefined")
                          throw {
                            message: "Extension value not specified.",
                            extension: o
                          };
                      }
                    }
                    i.extensions = s;
                  }, i.getExtension = function(e) {
                    typeof e == "string" && (e = {name: e});
                    var t = null,
                        n;
                    for (var r = 0; t === null && r < i.extensions.length; ++r)
                      n = i.extensions[r], e.id && n.id === e.id ? t = n : e.name && n.name === e.name && (t = n);
                    return t;
                  }, i.sign = function(s, o) {
                    i.md = o || e.md.sha1.create();
                    var u = r[i.md.algorithm + "WithRSAEncryption"];
                    if (!u)
                      throw {
                        message: "Could not compute certificate digest. Unknown message digest algorithm OID.",
                        algorithm: i.md.algorithm
                      };
                    i.signatureOid = i.siginfo.algorithmOid = u, i.tbsCertificate = n.getTBSCertificate(i);
                    var a = t.toDer(i.tbsCertificate);
                    i.md.update(a.getBytes()), i.signature = s.sign(i.md);
                  }, i.verify = function(s) {
                    var o = !1;
                    if (!i.issued(s)) {
                      var u = s.issuer,
                          a = i.subject;
                      throw {
                        message: "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.",
                        expectedIssuer: u.attributes,
                        actualIssuer: a.attributes
                      };
                    }
                    var f = s.md;
                    if (f === null) {
                      if (s.signatureOid in r) {
                        var l = r[s.signatureOid];
                        switch (l) {
                          case "sha1WithRSAEncryption":
                            f = e.md.sha1.create();
                            break;
                          case "md5WithRSAEncryption":
                            f = e.md.md5.create();
                            break;
                          case "sha256WithRSAEncryption":
                            f = e.md.sha256.create();
                            break;
                          case "RSASSA-PSS":
                            f = e.md.sha256.create();
                        }
                      }
                      if (f === null)
                        throw {
                          message: "Could not compute certificate digest. Unknown signature OID.",
                          signatureOid: s.signatureOid
                        };
                      var c = s.tbsCertificate || n.getTBSCertificate(s),
                          h = t.toDer(c);
                      f.update(h.getBytes());
                    }
                    if (f !== null) {
                      var p = undefined;
                      switch (s.signatureOid) {
                        case r.sha1WithRSAEncryption:
                          p = undefined;
                          break;
                        case r["RSASSA-PSS"]:
                          var d,
                              v;
                          d = r[s.signatureParameters.mgf.hash.algorithmOid];
                          if (d === undefined || e.md[d] === undefined)
                            throw {
                              message: "Unsupported MGF hash function.",
                              oid: s.signatureParameters.mgf.hash.algorithmOid,
                              name: d
                            };
                          v = r[s.signatureParameters.mgf.algorithmOid];
                          if (v === undefined || e.mgf[v] === undefined)
                            throw {
                              message: "Unsupported MGF function.",
                              oid: s.signatureParameters.mgf.algorithmOid,
                              name: v
                            };
                          v = e.mgf[v].create(e.md[d].create()), d = r[s.signatureParameters.hash.algorithmOid];
                          if (d === undefined || e.md[d] === undefined)
                            throw {
                              message: "Unsupported RSASSA-PSS hash function.",
                              oid: s.signatureParameters.hash.algorithmOid,
                              name: d
                            };
                          p = e.pss.create(e.md[d].create(), v, s.signatureParameters.saltLength);
                      }
                      o = i.publicKey.verify(f.digest().getBytes(), s.signature, p);
                    }
                    return o;
                  }, i.isIssuer = function(e) {
                    var t = !1,
                        n = i.issuer,
                        r = e.subject;
                    if (n.hash && r.hash)
                      t = n.hash === r.hash;
                    else if (n.attributes.length === r.attributes.length) {
                      t = !0;
                      var s,
                          o;
                      for (var u = 0; t && u < n.attributes.length; ++u) {
                        s = n.attributes[u], o = r.attributes[u];
                        if (s.type !== o.type || s.value !== o.value)
                          t = !1;
                      }
                    }
                    return t;
                  }, i.issued = function(e) {
                    return e.isIssuer(i);
                  }, i.generateSubjectKeyIdentifier = function() {
                    var r = t.toDer(n.publicKeyToRSAPublicKey(i.publicKey)),
                        s = e.md.sha1.create();
                    return s.update(r.getBytes()), s.digest();
                  }, i.verifySubjectKeyIdentifier = function() {
                    var t = r.subjectKeyIdentifier;
                    for (var n = 0; n < i.extensions.length; ++n) {
                      var s = i.extensions[n];
                      if (s.id === t) {
                        var o = i.generateSubjectKeyIdentifier().getBytes();
                        return e.util.hexToBytes(s.subjectKeyIdentifier) === o;
                      }
                    }
                    return !1;
                  }, i;
                }, n.certificateFromAsn1 = function(i, s) {
                  var u = {},
                      a = [];
                  if (!t.validate(i, o, u, a))
                    throw {
                      message: "Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.",
                      errors: a
                    };
                  if (typeof u.certSignature != "string") {
                    var f = "\0";
                    for (var p = 0; p < u.certSignature.length; ++p)
                      f += t.toDer(u.certSignature[p]).getBytes();
                    u.certSignature = f;
                  }
                  var d = t.derToOid(u.publicKeyOid);
                  if (d !== n.oids.rsaEncryption)
                    throw {message: "Cannot read public key. OID is not RSA."};
                  var v = n.createCertificate();
                  v.version = u.certVersion ? u.certVersion.charCodeAt(0) : 0;
                  var g = e.util.createBuffer(u.certSerialNumber);
                  v.serialNumber = g.toHex(), v.signatureOid = e.asn1.derToOid(u.certSignatureOid), v.signatureParameters = h(v.signatureOid, u.certSignatureParams, !0), v.siginfo.algorithmOid = e.asn1.derToOid(u.certinfoSignatureOid), v.siginfo.parameters = h(v.siginfo.algorithmOid, u.certinfoSignatureParams, !1);
                  var y = e.util.createBuffer(u.certSignature);
                  ++y.read, v.signature = y.getBytes();
                  var b = [];
                  u.certValidity1UTCTime !== undefined && b.push(t.utcTimeToDate(u.certValidity1UTCTime)), u.certValidity2GeneralizedTime !== undefined && b.push(t.generalizedTimeToDate(u.certValidity2GeneralizedTime)), u.certValidity3UTCTime !== undefined && b.push(t.utcTimeToDate(u.certValidity3UTCTime)), u.certValidity4GeneralizedTime !== undefined && b.push(t.generalizedTimeToDate(u.certValidity4GeneralizedTime));
                  if (b.length > 2)
                    throw {message: "Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate."};
                  if (b.length < 2)
                    throw {message: "Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime."};
                  v.validity.notBefore = b[0], v.validity.notAfter = b[1], v.tbsCertificate = u.tbsCertificate;
                  if (s) {
                    v.md = null;
                    if (v.signatureOid in r) {
                      var d = r[v.signatureOid];
                      switch (d) {
                        case "sha1WithRSAEncryption":
                          v.md = e.md.sha1.create();
                          break;
                        case "md5WithRSAEncryption":
                          v.md = e.md.md5.create();
                          break;
                        case "sha256WithRSAEncryption":
                          v.md = e.md.sha256.create();
                          break;
                        case "RSASSA-PSS":
                          v.md = e.md.sha256.create();
                      }
                    }
                    if (v.md === null)
                      throw {
                        message: "Could not compute certificate digest. Unknown signature OID.",
                        signatureOid: v.signatureOid
                      };
                    var w = t.toDer(v.tbsCertificate);
                    v.md.update(w.getBytes());
                  }
                  var E = e.md.sha1.create();
                  v.issuer.getField = function(e) {
                    return l(v.issuer, e);
                  }, v.issuer.addField = function(e) {
                    m([e]), v.issuer.attributes.push(e);
                  }, v.issuer.attributes = n.RDNAttributesAsArray(u.certIssuer, E), u.certIssuerUniqueId && (v.issuer.uniqueId = u.certIssuerUniqueId), v.issuer.hash = E.digest().toHex();
                  var S = e.md.sha1.create();
                  return v.subject.getField = function(e) {
                    return l(v.subject, e);
                  }, v.subject.addField = function(e) {
                    m([e]), v.subject.attributes.push(e);
                  }, v.subject.attributes = n.RDNAttributesAsArray(u.certSubject, S), u.certSubjectUniqueId && (v.subject.uniqueId = u.certSubjectUniqueId), v.subject.hash = S.digest().toHex(), u.certExtensions ? v.extensions = c(u.certExtensions) : v.extensions = [], v.publicKey = n.publicKeyFromAsn1(u.subjectPublicKeyInfo), v;
                }, n.certificationRequestFromAsn1 = function(i, s) {
                  var o = {},
                      u = [];
                  if (!t.validate(i, f, o, u))
                    throw {
                      message: "Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.",
                      errors: u
                    };
                  if (typeof o.csrSignature != "string") {
                    var a = "\0";
                    for (var c = 0; c < o.csrSignature.length; ++c)
                      a += t.toDer(o.csrSignature[c]).getBytes();
                    o.csrSignature = a;
                  }
                  var p = t.derToOid(o.publicKeyOid);
                  if (p !== n.oids.rsaEncryption)
                    throw {message: "Cannot read public key. OID is not RSA."};
                  var d = n.createCertificationRequest();
                  d.version = o.csrVersion ? o.csrVersion.charCodeAt(0) : 0, d.signatureOid = e.asn1.derToOid(o.csrSignatureOid), d.signatureParameters = h(d.signatureOid, o.csrSignatureParams, !0), d.siginfo.algorithmOid = e.asn1.derToOid(o.csrSignatureOid), d.siginfo.parameters = h(d.siginfo.algorithmOid, o.csrSignatureParams, !1);
                  var v = e.util.createBuffer(o.csrSignature);
                  ++v.read, d.signature = v.getBytes(), d.certificationRequestInfo = o.certificationRequestInfo;
                  if (s) {
                    d.md = null;
                    if (d.signatureOid in r) {
                      var p = r[d.signatureOid];
                      switch (p) {
                        case "sha1WithRSAEncryption":
                          d.md = e.md.sha1.create();
                          break;
                        case "md5WithRSAEncryption":
                          d.md = e.md.md5.create();
                          break;
                        case "sha256WithRSAEncryption":
                          d.md = e.md.sha256.create();
                          break;
                        case "RSASSA-PSS":
                          d.md = e.md.sha256.create();
                      }
                    }
                    if (d.md === null)
                      throw {
                        message: "Could not compute certification request digest. Unknown signature OID.",
                        signatureOid: d.signatureOid
                      };
                    var g = t.toDer(d.certificationRequestInfo);
                    d.md.update(g.getBytes());
                  }
                  var y = e.md.sha1.create();
                  return d.subject.getField = function(e) {
                    return l(d.subject, e);
                  }, d.subject.addField = function(e) {
                    m([e]), d.subject.attributes.push(e);
                  }, d.subject.attributes = n.RDNAttributesAsArray(o.certificationRequestInfoSubject, y), d.subject.hash = y.digest().toHex(), d.publicKey = n.publicKeyFromAsn1(o.subjectPublicKeyInfo), d.getAttribute = function(e) {
                    return l(d.attributes, e);
                  }, d.addAttribute = function(e) {
                    m([e]), d.attributes.push(e);
                  }, d.attributes = n.CRIAttributesAsArray(o.certificationRequestInfoAttributes), d;
                }, n.createCertificationRequest = function() {
                  var i = {};
                  return i.version = 0, i.signatureOid = null, i.signature = null, i.siginfo = {}, i.siginfo.algorithmOid = null, i.subject = {}, i.subject.getField = function(e) {
                    return l(i.subject, e);
                  }, i.subject.addField = function(e) {
                    m([e]), i.subject.attributes.push(e);
                  }, i.subject.attributes = [], i.subject.hash = null, i.publicKey = null, i.attributes = [], i.getAttribute = function(e) {
                    return l(i.attributes, e);
                  }, i.addAttribute = function(e) {
                    m([e]), i.attributes.push(e);
                  }, i.md = null, i.setSubject = function(e) {
                    m(e), i.subject.attributes = e, i.subject.hash = null;
                  }, i.setAttributes = function(e) {
                    m(e), i.attributes = e;
                  }, i.sign = function(s, o) {
                    i.md = o || e.md.sha1.create();
                    var u = r[i.md.algorithm + "WithRSAEncryption"];
                    if (!u)
                      throw {
                        message: "Could not compute certification request digest. Unknown message digest algorithm OID.",
                        algorithm: i.md.algorithm
                      };
                    i.signatureOid = i.siginfo.algorithmOid = u, i.certificationRequestInfo = n.getCertificationRequestInfo(i);
                    var a = t.toDer(i.certificationRequestInfo);
                    i.md.update(a.getBytes()), i.signature = s.sign(i.md);
                  }, i.verify = function() {
                    var s = !1,
                        o = i.md;
                    if (o === null) {
                      if (i.signatureOid in r) {
                        var u = r[i.signatureOid];
                        switch (u) {
                          case "sha1WithRSAEncryption":
                            o = e.md.sha1.create();
                            break;
                          case "md5WithRSAEncryption":
                            o = e.md.md5.create();
                            break;
                          case "sha256WithRSAEncryption":
                            o = e.md.sha256.create();
                            break;
                          case "RSASSA-PSS":
                            o = e.md.sha256.create();
                        }
                      }
                      if (o === null)
                        throw {
                          message: "Could not compute certification request digest. Unknown signature OID.",
                          signatureOid: i.signatureOid
                        };
                      var a = i.certificationRequestInfo || n.getCertificationRequestInfo(i),
                          f = t.toDer(a);
                      o.update(f.getBytes());
                    }
                    if (o !== null) {
                      var l;
                      switch (i.signatureOid) {
                        case r.sha1WithRSAEncryption:
                          break;
                        case r["RSASSA-PSS"]:
                          var c,
                              h;
                          c = r[i.signatureParameters.mgf.hash.algorithmOid];
                          if (c === undefined || e.md[c] === undefined)
                            throw {
                              message: "Unsupported MGF hash function.",
                              oid: i.signatureParameters.mgf.hash.algorithmOid,
                              name: c
                            };
                          h = r[i.signatureParameters.mgf.algorithmOid];
                          if (h === undefined || e.mgf[h] === undefined)
                            throw {
                              message: "Unsupported MGF function.",
                              oid: i.signatureParameters.mgf.algorithmOid,
                              name: h
                            };
                          h = e.mgf[h].create(e.md[c].create()), c = r[i.signatureParameters.hash.algorithmOid];
                          if (c === undefined || e.md[c] === undefined)
                            throw {
                              message: "Unsupported RSASSA-PSS hash function.",
                              oid: i.signatureParameters.hash.algorithmOid,
                              name: c
                            };
                          l = e.pss.create(e.md[c].create(), h, i.signatureParameters.saltLength);
                      }
                      s = i.publicKey.verify(o.digest().getBytes(), i.signature, l);
                    }
                    return s;
                  }, i;
                }, n.getTBSCertificate = function(r) {
                  var i = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(r.version).getBytes())]), t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, e.util.hexToBytes(r.serialNumber)), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(r.siginfo.algorithmOid).getBytes()), g(r.siginfo.algorithmOid, r.siginfo.parameters)]), p(r.issuer), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.UTCTIME, !1, t.dateToUtcTime(r.validity.notBefore)), t.create(t.Class.UNIVERSAL, t.Type.UTCTIME, !1, t.dateToUtcTime(r.validity.notAfter))]), p(r.subject), n.publicKeyToAsn1(r.publicKey)]);
                  return r.issuer.uniqueId && i.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 1, !0, [t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, String.fromCharCode(0) + r.issuer.uniqueId)])), r.subject.uniqueId && i.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 2, !0, [t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, String.fromCharCode(0) + r.subject.uniqueId)])), r.extensions.length > 0 && i.value.push(d(r.extensions)), i;
                }, n.getCertificationRequestInfo = function(e) {
                  var r = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(e.version).getBytes()), p(e.subject), n.publicKeyToAsn1(e.publicKey), y(e)]);
                  return r;
                }, n.distinguishedNameToAsn1 = function(e) {
                  return p(e);
                }, n.certificateToAsn1 = function(e) {
                  var r = e.tbsCertificate || n.getTBSCertificate(e);
                  return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [r, t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(e.signatureOid).getBytes()), g(e.signatureOid, e.signatureParameters)]), t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, String.fromCharCode(0) + e.signature)]);
                }, n.certificationRequestToAsn1 = function(e) {
                  var r = e.certificationRequestInfo || n.getCertificationRequestInfo(e);
                  return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [r, t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(e.signatureOid).getBytes()), g(e.signatureOid, e.signatureParameters)]), t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, !1, String.fromCharCode(0) + e.signature)]);
                }, n.createCaStore = function(t) {
                  var r = {certs: {}};
                  r.getIssuer = function(t) {
                    var i = null;
                    if (!t.issuer.hash) {
                      var s = e.md.sha1.create();
                      t.issuer.attributes = n.RDNAttributesAsArray(p(t.issuer), s), t.issuer.hash = s.digest().toHex();
                    }
                    if (t.issuer.hash in r.certs) {
                      i = r.certs[t.issuer.hash];
                      if (e.util.isArray(i))
                        throw {message: "Resolving multiple issuer matches not implemented yet."};
                    }
                    return i;
                  }, r.addCertificate = function(t) {
                    typeof t == "string" && (t = e.pki.certificateFromPem(t));
                    if (!t.subject.hash) {
                      var i = e.md.sha1.create();
                      t.subject.attributes = n.RDNAttributesAsArray(p(t.subject), i), t.subject.hash = i.digest().toHex();
                    }
                    if (t.subject.hash in r.certs) {
                      var s = r.certs[t.subject.hash];
                      e.util.isArray(s) || (s = [s]), s.push(t);
                    } else
                      r.certs[t.subject.hash] = t;
                  };
                  if (t)
                    for (var i = 0; i < t.length; ++i) {
                      var s = t[i];
                      r.addCertificate(s);
                    }
                  return r;
                }, n.certificateError = {
                  bad_certificate: "forge.pki.BadCertificate",
                  unsupported_certificate: "forge.pki.UnsupportedCertificate",
                  certificate_revoked: "forge.pki.CertificateRevoked",
                  certificate_expired: "forge.pki.CertificateExpired",
                  certificate_unknown: "forge.pki.CertificateUnknown",
                  unknown_ca: "forge.pki.UnknownCertificateAuthority"
                }, n.verifyCertificateChain = function(t, r, i) {
                  r = r.slice(0);
                  var s = r.slice(0),
                      o = new Date,
                      u = !0,
                      a = null,
                      f = 0,
                      l = null;
                  do {
                    var c = r.shift();
                    if (o < c.validity.notBefore || o > c.validity.notAfter)
                      a = {
                        message: "Certificate is not valid yet or has expired.",
                        error: n.certificateError.certificate_expired,
                        notBefore: c.validity.notBefore,
                        notAfter: c.validity.notAfter,
                        now: o
                      };
                    else {
                      var h = !1;
                      if (r.length > 0) {
                        l = r[0];
                        try {
                          h = l.verify(c);
                        } catch (p) {}
                      } else {
                        var d = t.getIssuer(c);
                        if (d === null)
                          a = {
                            message: "Certificate is not trusted.",
                            error: n.certificateError.unknown_ca
                          };
                        else {
                          e.util.isArray(d) || (d = [d]);
                          while (!h && d.length > 0) {
                            l = d.shift();
                            try {
                              h = l.verify(c);
                            } catch (p) {}
                          }
                        }
                      }
                      a === null && !h && (a = {
                        message: "Certificate signature is invalid.",
                        error: n.certificateError.bad_certificate
                      });
                    }
                    a === null && !c.isIssuer(l) && (a = {
                      message: "Certificate issuer is invalid.",
                      error: n.certificateError.bad_certificate
                    });
                    if (a === null) {
                      var v = {
                        keyUsage: !0,
                        basicConstraints: !0
                      };
                      for (var m = 0; a === null && m < c.extensions.length; ++m) {
                        var g = c.extensions[m];
                        g.critical && !(g.name in v) && (a = {
                          message: "Certificate has an unsupported critical extension.",
                          error: n.certificateError.unsupported_certificate
                        });
                      }
                    }
                    if (!u || r.length === 0 && !l) {
                      var y = c.getExtension("basicConstraints"),
                          b = c.getExtension("keyUsage");
                      b !== null && (!b.keyCertSign || y === null) && (a = {
                        message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                        error: n.certificateError.bad_certificate
                      }), a === null && y !== null && !y.cA && (a = {
                        message: "Certificate basicConstraints indicates the certificate is not a CA.",
                        error: n.certificateError.bad_certificate
                      });
                      if (a === null && b !== null && "pathLenConstraint" in y) {
                        var w = 0;
                        for (var m = 1; m < r.length - 1; ++m)
                          r[m].isIssuer(r[m]) && ++w;
                        var E = y.pathLenConstraint + 1;
                        r.length - w > E && (a = {
                          message: "Certificate basicConstraints pathLenConstraint violated.",
                          error: n.certificateError.bad_certificate
                        });
                      }
                    }
                    var S = a === null ? !0 : a.error,
                        x = i ? i(S, f, s) : S;
                    if (x !== !0) {
                      S === !0 && (a = {
                        message: "The application rejected the certificate.",
                        error: n.certificateError.bad_certificate
                      });
                      if (x || x === 0)
                        typeof x == "object" && !e.util.isArray(x) ? (x.message && (a.message = x.message), x.error && (a.error = x.error)) : typeof x == "string" && (a.error = x);
                      throw a;
                    }
                    a = null, u = !1, ++f;
                  } while (r.length > 0);
                  return !0;
                };
              }
              var r = "x509";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n.pki;
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/x509", ["require", "module", "./aes", "./asn1", "./des", "./md", "./mgf", "./oids", "./pem", "./pss", "./rsa", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function f(e, t, n, r) {
                  var i = [];
                  for (var s = 0; s < e.length; s++)
                    for (var o = 0; o < e[s].safeBags.length; o++) {
                      var u = e[s].safeBags[o];
                      if (r !== undefined && u.type !== r)
                        continue;
                      u.attributes[t] !== undefined && u.attributes[t].indexOf(n) >= 0 && i.push(u);
                    }
                  return i;
                }
                function l(e, r, s, o) {
                  r = t.fromDer(r, s);
                  if (r.tagClass !== t.Class.UNIVERSAL || r.type !== t.Type.SEQUENCE || r.constructed !== !0)
                    throw {message: "PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo"};
                  for (var u = 0; u < r.value.length; u++) {
                    var a = r.value[u],
                        f = {},
                        l = [];
                    if (!t.validate(a, i, f, l))
                      throw {
                        message: "Cannot read ContentInfo.",
                        errors: l
                      };
                    var p = {encrypted: !1},
                        d = null,
                        v = f.content.value[0];
                    switch (t.derToOid(f.contentType)) {
                      case n.oids.data:
                        if (v.tagClass !== t.Class.UNIVERSAL || v.type !== t.Type.OCTETSTRING)
                          throw {message: "PKCS#12 SafeContents Data is not an OCTET STRING."};
                        d = v.value;
                        break;
                      case n.oids.encryptedData:
                        if (o === undefined)
                          throw {message: "Found PKCS#12 Encrypted SafeContents Data but no password available."};
                        d = c(v, o), p.encrypted = !0;
                        break;
                      default:
                        throw {
                          message: "Unsupported PKCS#12 contentType.",
                          contentType: t.derToOid(f.contentType)
                        };
                    }
                    p.safeBags = h(d, s, o), e.safeContents.push(p);
                  }
                }
                function c(r, i) {
                  var s = {},
                      o = [];
                  if (!t.validate(r, e.pkcs7.asn1.encryptedDataValidator, s, o))
                    throw {
                      message: "Cannot read EncryptedContentInfo. ",
                      errors: o
                    };
                  var u = t.derToOid(s.contentType);
                  if (u !== n.oids.data)
                    throw {
                      message: "PKCS#12 EncryptedContentInfo ContentType is not Data.",
                      oid: u
                    };
                  u = t.derToOid(s.encAlgorithm);
                  var a = n.pbe.getCipher(u, s.encParameter, i),
                      f = e.util.createBuffer(s.encryptedContent);
                  a.update(f);
                  if (!a.finish())
                    throw {message: "Failed to decrypt PKCS#12 SafeContents."};
                  return a.output.getBytes();
                }
                function h(e, r, i) {
                  e = t.fromDer(e, r);
                  if (e.tagClass !== t.Class.UNIVERSAL || e.type !== t.Type.SEQUENCE || e.constructed !== !0)
                    throw {message: "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag"};
                  var s = [];
                  for (var u = 0; u < e.value.length; u++) {
                    var f = e.value[u],
                        l = {},
                        c = [];
                    if (!t.validate(f, o, l, c))
                      throw {
                        message: "Cannot read SafeBag.",
                        errors: c
                      };
                    var h = {
                      type: t.derToOid(l.bagId),
                      attributes: p(l.bagAttributes)
                    };
                    s.push(h);
                    var d,
                        v,
                        m = l.bagValue.value[0];
                    switch (h.type) {
                      case n.oids.pkcs8ShroudedKeyBag:
                        if (i === undefined)
                          throw {message: "Found PKCS#8 ShroudedKeyBag but no password available."};
                        m = n.decryptPrivateKeyInfo(m, i);
                        if (m === null)
                          throw {message: "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"};
                      case n.oids.keyBag:
                        h.key = n.privateKeyFromAsn1(m);
                        continue;
                      case n.oids.certBag:
                        d = a, v = function() {
                          if (t.derToOid(l.certId) !== n.oids.x509Certificate)
                            throw {
                              message: "Unsupported certificate type, only X.509 supported.",
                              oid: t.derToOid(l.certId)
                            };
                          h.cert = n.certificateFromAsn1(t.fromDer(l.cert, r), !0);
                        };
                        break;
                      default:
                        throw {
                          message: "Unsupported PKCS#12 SafeBag type.",
                          oid: h.type
                        };
                    }
                    if (d !== undefined && !t.validate(m, d, l, c))
                      throw {
                        message: "Cannot read PKCS#12 " + d.name,
                        errors: c
                      };
                    v();
                  }
                  return s;
                }
                function p(e) {
                  var r = {};
                  if (e !== undefined)
                    for (var i = 0; i < e.length; ++i) {
                      var s = {},
                          o = [];
                      if (!t.validate(e[i], u, s, o))
                        throw {
                          message: "Cannot read PKCS#12 BagAttribute.",
                          errors: o
                        };
                      var a = t.derToOid(s.oid);
                      if (n.oids[a] === undefined)
                        continue;
                      r[n.oids[a]] = [];
                      for (var f = 0; f < s.values.length; ++f)
                        r[n.oids[a]].push(s.values[f].value);
                    }
                  return r;
                }
                var t = e.asn1,
                    n = e.pki,
                    r = e.pkcs12 = e.pkcs12 || {},
                    i = {
                      name: "ContentInfo",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "ContentInfo.contentType",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.OID,
                        constructed: !1,
                        capture: "contentType"
                      }, {
                        name: "ContentInfo.content",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        constructed: !0,
                        captureAsn1: "content"
                      }]
                    },
                    s = {
                      name: "PFX",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "PFX.version",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.INTEGER,
                        constructed: !1,
                        capture: "version"
                      }, i, {
                        name: "PFX.macData",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SEQUENCE,
                        constructed: !0,
                        optional: !0,
                        captureAsn1: "mac",
                        value: [{
                          name: "PFX.macData.mac",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.SEQUENCE,
                          constructed: !0,
                          value: [{
                            name: "PFX.macData.mac.digestAlgorithm",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                              name: "PFX.macData.mac.digestAlgorithm.algorithm",
                              tagClass: t.Class.UNIVERSAL,
                              type: t.Type.OID,
                              constructed: !1,
                              capture: "macAlgorithm"
                            }, {
                              name: "PFX.macData.mac.digestAlgorithm.parameters",
                              tagClass: t.Class.UNIVERSAL,
                              captureAsn1: "macAlgorithmParameters"
                            }]
                          }, {
                            name: "PFX.macData.mac.digest",
                            tagClass: t.Class.UNIVERSAL,
                            type: t.Type.OCTETSTRING,
                            constructed: !1,
                            capture: "macDigest"
                          }]
                        }, {
                          name: "PFX.macData.macSalt",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.OCTETSTRING,
                          constructed: !1,
                          capture: "macSalt"
                        }, {
                          name: "PFX.macData.iterations",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.INTEGER,
                          constructed: !1,
                          optional: !0,
                          capture: "macIterations"
                        }]
                      }]
                    },
                    o = {
                      name: "SafeBag",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "SafeBag.bagId",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.OID,
                        constructed: !1,
                        capture: "bagId"
                      }, {
                        name: "SafeBag.bagValue",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        constructed: !0,
                        captureAsn1: "bagValue"
                      }, {
                        name: "SafeBag.bagAttributes",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SET,
                        constructed: !0,
                        optional: !0,
                        capture: "bagAttributes"
                      }]
                    },
                    u = {
                      name: "Attribute",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "Attribute.attrId",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.OID,
                        constructed: !1,
                        capture: "oid"
                      }, {
                        name: "Attribute.attrValues",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.SET,
                        constructed: !0,
                        capture: "values"
                      }]
                    },
                    a = {
                      name: "CertBag",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: !0,
                      value: [{
                        name: "CertBag.certId",
                        tagClass: t.Class.UNIVERSAL,
                        type: t.Type.OID,
                        constructed: !1,
                        capture: "certId"
                      }, {
                        name: "CertBag.certValue",
                        tagClass: t.Class.CONTEXT_SPECIFIC,
                        constructed: !0,
                        value: [{
                          name: "CertBag.certValue[0]",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Class.OCTETSTRING,
                          constructed: !1,
                          capture: "cert"
                        }]
                      }]
                    };
                r.pkcs12FromAsn1 = function(i, o, u) {
                  typeof o == "string" ? (u = o, o = !0) : o === undefined && (o = !0);
                  var a = {},
                      c = [];
                  if (!t.validate(i, s, a, c))
                    throw {
                      message: "Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.",
                      errors: c
                    };
                  var h = {
                    version: a.version.charCodeAt(0),
                    safeContents: [],
                    getBags: function(t) {
                      var n = {},
                          r;
                      return "localKeyId" in t ? r = t.localKeyId : "localKeyIdHex" in t && (r = e.util.hexToBytes(t.localKeyIdHex)), r !== undefined && (n.localKeyId = f(h.safeContents, "localKeyId", r, t.bagType)), "friendlyName" in t && (n.friendlyName = f(h.safeContents, "friendlyName", t.friendlyName, t.bagType)), n;
                    },
                    getBagsByFriendlyName: function(e, t) {
                      return f(h.safeContents, "friendlyName", e, t);
                    },
                    getBagsByLocalKeyId: function(e, t) {
                      return f(h.safeContents, "localKeyId", e, t);
                    }
                  };
                  if (a.version.charCodeAt(0) !== 3)
                    throw {
                      message: "PKCS#12 PFX of version other than 3 not supported.",
                      version: a.version.charCodeAt(0)
                    };
                  if (t.derToOid(a.contentType) !== n.oids.data)
                    throw {
                      message: "Only PKCS#12 PFX in password integrity mode supported.",
                      oid: t.derToOid(a.contentType)
                    };
                  var p = a.content.value[0];
                  if (p.tagClass !== t.Class.UNIVERSAL || p.type !== t.Type.OCTETSTRING)
                    throw {message: "PKCS#12 authSafe content data is not an OCTET STRING."};
                  if (a.mac) {
                    var d = null,
                        v = 0,
                        m = t.derToOid(a.macAlgorithm);
                    switch (m) {
                      case n.oids.sha1:
                        d = e.md.sha1.create(), v = 20;
                        break;
                      case n.oids.sha256:
                        d = e.md.sha256.create(), v = 32;
                        break;
                      case n.oids.sha384:
                        d = e.md.sha384.create(), v = 48;
                        break;
                      case n.oids.sha512:
                        d = e.md.sha512.create(), v = 64;
                        break;
                      case n.oids.md5:
                        d = e.md.md5.create(), v = 16;
                    }
                    if (d === null)
                      throw {message: "PKCS#12 uses unsupported MAC algorithm: " + m};
                    var g = new e.util.ByteBuffer(a.macSalt),
                        y = "macIterations" in a ? parseInt(e.util.bytesToHex(a.macIterations), 16) : 1,
                        b = r.generateKey(u || "", g, 3, y, v, d),
                        w = e.hmac.create();
                    w.start(d, b), w.update(p.value);
                    var E = w.getMac();
                    if (E.getBytes() !== a.macDigest)
                      throw {message: "PKCS#12 MAC could not be verified. Invalid password?"};
                  }
                  return l(h, p.value, o, u), h;
                }, r.toPkcs12Asn1 = function(i, s, o, u) {
                  u = u || {}, u.saltSize = u.saltSize || 8, u.count = u.count || 2048, u.algorithm = u.algorithm || u.encAlgorithm || "aes128", "useMac" in u || (u.useMac = !0), "localKeyId" in u || (u.localKeyId = null), "generateLocalKeyId" in u || (u.generateLocalKeyId = !0);
                  var a = u.localKeyId,
                      f;
                  if (a !== null)
                    a = e.util.hexToBytes(a);
                  else if (u.generateLocalKeyId)
                    if (s) {
                      var l = e.util.isArray(s) ? s[0] : s;
                      typeof l == "string" && (l = n.certificateFromPem(l));
                      var c = e.md.sha1.create();
                      c.update(t.toDer(n.certificateToAsn1(l)).getBytes()), a = c.digest().getBytes();
                    } else
                      a = e.random.getBytes(20);
                  var h = [];
                  a !== null && h.push(t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.localKeyId).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, a)])])), "friendlyName" in u && h.push(t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.friendlyName).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, [t.create(t.Class.UNIVERSAL, t.Type.BMPSTRING, !1, u.friendlyName)])])), h.length > 0 && (f = t.create(t.Class.UNIVERSAL, t.Type.SET, !0, h));
                  var p = [],
                      d = [];
                  s !== null && (e.util.isArray(s) ? d = s : d = [s]);
                  var v = [];
                  for (var m = 0; m < d.length; ++m) {
                    s = d[m], typeof s == "string" && (s = n.certificateFromPem(s));
                    var g = m === 0 ? f : undefined,
                        y = n.certificateToAsn1(s),
                        b = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.certBag).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.x509Certificate).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, t.toDer(y).getBytes())])])]), g]);
                    v.push(b);
                  }
                  if (v.length > 0) {
                    var w = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, v),
                        E = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.data).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, t.toDer(w).getBytes())])]);
                    p.push(E);
                  }
                  var S = null;
                  if (i !== null) {
                    var x = n.wrapRsaPrivateKey(n.privateKeyToAsn1(i));
                    o === null ? S = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.keyBag).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [x]), f]) : S = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.pkcs8ShroudedKeyBag).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [n.encryptPrivateKeyInfo(x, o, u)]), f]);
                    var T = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [S]),
                        N = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.data).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, t.toDer(T).getBytes())])]);
                    p.push(N);
                  }
                  var C = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, p),
                      k;
                  if (u.useMac) {
                    var c = e.md.sha1.create(),
                        L = new e.util.ByteBuffer(e.random.getBytes(u.saltSize)),
                        A = u.count,
                        i = r.generateKey(o || "", L, 3, A, 20),
                        O = e.hmac.create();
                    O.start(c, i), O.update(t.toDer(C).getBytes());
                    var M = O.getMac();
                    k = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.sha1).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "")]), t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, M.getBytes())]), t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, L.getBytes()), t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(A).getBytes())]);
                  }
                  return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(3).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.oids.data).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, t.toDer(C).getBytes())])]), k]);
                }, r.generateKey = e.pbe.generatePkcs12Key;
              }
              var r = "pkcs12";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pkcs12", ["require", "module", "./asn1", "./hmac", "./oids", "./pkcs7asn1", "./pbe", "./random", "./rsa", "./sha1", "./util", "./x509"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.asn1,
                    n = e.pki = e.pki || {};
                n.pemToDer = function(t) {
                  var n = e.pem.decode(t)[0];
                  if (n.procType && n.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert PEM to DER; PEM is encrypted."};
                  return e.util.createBuffer(n.body);
                }, n.privateKeyFromPem = function(r) {
                  var i = e.pem.decode(r)[0];
                  if (i.type !== "PRIVATE KEY" && i.type !== "RSA PRIVATE KEY")
                    throw {
                      message: 'Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".',
                      headerType: i.type
                    };
                  if (i.procType && i.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert private key from PEM; PEM is encrypted."};
                  var s = t.fromDer(i.body);
                  return n.privateKeyFromAsn1(s);
                }, n.privateKeyToPem = function(r, i) {
                  var s = {
                    type: "RSA PRIVATE KEY",
                    body: t.toDer(n.privateKeyToAsn1(r)).getBytes()
                  };
                  return e.pem.encode(s, {maxline: i});
                };
              }
              var r = "pki";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pki", ["require", "module", "./asn1", "./oids", "./pbe", "./pem", "./pbkdf2", "./pkcs12", "./pss", "./rsa", "./util", "./x509"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = function(t, n, r, i) {
                  var s = e.util.createBuffer(),
                      o = t.length >> 1,
                      u = o + (t.length & 1),
                      a = t.substr(0, u),
                      f = t.substr(o, u),
                      l = e.util.createBuffer(),
                      c = e.hmac.create();
                  r = n + r;
                  var h = Math.ceil(i / 16),
                      p = Math.ceil(i / 20);
                  c.start("MD5", a);
                  var d = e.util.createBuffer();
                  l.putBytes(r);
                  for (var v = 0; v < h; ++v)
                    c.start(null, null), c.update(l.getBytes()), l.putBuffer(c.digest()), c.start(null, null), c.update(l.bytes() + r), d.putBuffer(c.digest());
                  c.start("SHA1", f);
                  var m = e.util.createBuffer();
                  l.clear(), l.putBytes(r);
                  for (var v = 0; v < p; ++v)
                    c.start(null, null), c.update(l.getBytes()), l.putBuffer(c.digest()), c.start(null, null), c.update(l.bytes() + r), m.putBuffer(c.digest());
                  return s.putBytes(e.util.xorBytes(d.getBytes(), m.getBytes(), i)), s;
                },
                    n = function(e, t, n, r) {},
                    r = function(t, n, r) {
                      var i = e.hmac.create();
                      i.start("SHA1", t);
                      var s = e.util.createBuffer();
                      return s.putInt32(n[0]), s.putInt32(n[1]), s.putByte(r.type), s.putByte(r.version.major), s.putByte(r.version.minor), s.putInt16(r.length), s.putBytes(r.fragment.bytes()), i.update(s.getBytes()), i.digest().getBytes();
                    },
                    i = function(t, n, r) {
                      var i = !1;
                      try {
                        var s = t.deflate(n.fragment.getBytes());
                        n.fragment = e.util.createBuffer(s), n.length = s.length, i = !0;
                      } catch (o) {}
                      return i;
                    },
                    s = function(t, n, r) {
                      var i = !1;
                      try {
                        var s = t.inflate(n.fragment.getBytes());
                        n.fragment = e.util.createBuffer(s), n.length = s.length, i = !0;
                      } catch (o) {}
                      return i;
                    },
                    o = function(t, n) {
                      var r = 0;
                      switch (n) {
                        case 1:
                          r = t.getByte();
                          break;
                        case 2:
                          r = t.getInt16();
                          break;
                        case 3:
                          r = t.getInt24();
                          break;
                        case 4:
                          r = t.getInt32();
                      }
                      return e.util.createBuffer(t.getBytes(r));
                    },
                    u = function(e, t, n) {
                      e.putInt(n.length(), t << 3), e.putBuffer(n);
                    },
                    a = {};
                a.Version = {
                  major: 3,
                  minor: 1
                }, a.MaxFragment = 15360, a.ConnectionEnd = {
                  server: 0,
                  client: 1
                }, a.PRFAlgorithm = {tls_prf_sha256: 0}, a.BulkCipherAlgorithm = {
                  none: null,
                  rc4: 0,
                  des3: 1,
                  aes: 2
                }, a.CipherType = {
                  stream: 0,
                  block: 1,
                  aead: 2
                }, a.MACAlgorithm = {
                  none: null,
                  hmac_md5: 0,
                  hmac_sha1: 1,
                  hmac_sha256: 2,
                  hmac_sha384: 3,
                  hmac_sha512: 4
                }, a.CompressionMethod = {
                  none: 0,
                  deflate: 1
                }, a.ContentType = {
                  change_cipher_spec: 20,
                  alert: 21,
                  handshake: 22,
                  application_data: 23
                }, a.HandshakeType = {
                  hello_request: 0,
                  client_hello: 1,
                  server_hello: 2,
                  certificate: 11,
                  server_key_exchange: 12,
                  certificate_request: 13,
                  server_hello_done: 14,
                  certificate_verify: 15,
                  client_key_exchange: 16,
                  finished: 20
                }, a.Alert = {}, a.Alert.Level = {
                  warning: 1,
                  fatal: 2
                }, a.Alert.Description = {
                  close_notify: 0,
                  unexpected_message: 10,
                  bad_record_mac: 20,
                  decryption_failed: 21,
                  record_overflow: 22,
                  decompression_failure: 30,
                  handshake_failure: 40,
                  bad_certificate: 42,
                  unsupported_certificate: 43,
                  certificate_revoked: 44,
                  certificate_expired: 45,
                  certificate_unknown: 46,
                  illegal_parameter: 47,
                  unknown_ca: 48,
                  access_denied: 49,
                  decode_error: 50,
                  decrypt_error: 51,
                  export_restriction: 60,
                  protocol_version: 70,
                  insufficient_security: 71,
                  internal_error: 80,
                  user_canceled: 90,
                  no_renegotiation: 100
                }, a.CipherSuites = {}, a.getCipherSuite = function(e) {
                  var t = null;
                  for (var n in a.CipherSuites) {
                    var r = a.CipherSuites[n];
                    if (r.id[0] === e.charCodeAt(0) && r.id[1] === e.charCodeAt(1)) {
                      t = r;
                      break;
                    }
                  }
                  return t;
                }, a.handleUnexpected = function(e, t) {
                  var n = !e.open && e.entity === a.ConnectionEnd.client;
                  n || e.error(e, {
                    message: "Unexpected message. Received TLS record out of order.",
                    send: !0,
                    alert: {
                      level: a.Alert.Level.fatal,
                      description: a.Alert.Description.unexpected_message
                    }
                  });
                }, a.handleHelloRequest = function(e, t, n) {
                  !e.handshaking && e.handshakes > 0 && (a.queue(e, a.createAlert({
                    level: a.Alert.Level.warning,
                    description: a.Alert.Description.no_renegotiation
                  })), a.flush(e)), e.process();
                }, a.parseHelloMessage = function(t, n, r) {
                  var i = null,
                      s = t.entity === a.ConnectionEnd.client;
                  if (r < 38)
                    t.error(t, {
                      message: s ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var u = n.fragment,
                        f = u.length();
                    i = {
                      version: {
                        major: u.getByte(),
                        minor: u.getByte()
                      },
                      random: e.util.createBuffer(u.getBytes(32)),
                      session_id: o(u, 1),
                      extensions: []
                    }, s ? (i.cipher_suite = u.getBytes(2), i.compression_method = u.getByte()) : (i.cipher_suites = o(u, 2), i.compression_methods = o(u, 1)), f = r - (f - u.length());
                    if (f > 0) {
                      var l = o(u, 2);
                      while (l.length() > 0)
                        i.extensions.push({
                          type: [l.getByte(), l.getByte()],
                          data: o(l, 2)
                        });
                      if (!s)
                        for (var c = 0; c < i.extensions.length; ++c) {
                          var h = i.extensions[c];
                          if (h.type[0] === 0 && h.type[1] === 0) {
                            var p = o(h.data, 2);
                            while (p.length() > 0) {
                              var d = p.getByte();
                              if (d !== 0)
                                break;
                              t.session.serverNameList.push(o(p, 2).getBytes());
                            }
                          }
                        }
                    }
                    (i.version.major !== a.Version.major || i.version.minor !== a.Version.minor) && t.error(t, {
                      message: "Incompatible TLS version.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.protocol_version
                      }
                    });
                    if (s)
                      t.session.cipherSuite = a.getCipherSuite(i.cipher_suite);
                    else {
                      var v = e.util.createBuffer(i.cipher_suites.bytes());
                      while (v.length() > 0) {
                        t.session.cipherSuite = a.getCipherSuite(v.getBytes(2));
                        if (t.session.cipherSuite !== null)
                          break;
                      }
                    }
                    if (t.session.cipherSuite === null)
                      return t.error(t, {
                        message: "No cipher suites in common.",
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.handshake_failure
                        },
                        cipherSuite: e.util.bytesToHex(i.cipher_suite)
                      });
                    s ? t.session.compressionMethod = i.compression_method : t.session.compressionMethod = a.CompressionMethod.none;
                  }
                  return i;
                }, a.createSecurityParameters = function(e, t) {
                  var n = e.entity === a.ConnectionEnd.client,
                      r = t.random.bytes(),
                      i = n ? e.session.sp.client_random : r,
                      s = n ? r : a.createRandom().getBytes();
                  e.session.sp = {
                    entity: e.entity,
                    prf_algorithm: a.PRFAlgorithm.tls_prf_sha256,
                    bulk_cipher_algorithm: null,
                    cipher_type: null,
                    enc_key_length: null,
                    block_length: null,
                    fixed_iv_length: null,
                    record_iv_length: null,
                    mac_algorithm: null,
                    mac_length: null,
                    mac_key_length: null,
                    compression_algorithm: e.session.compressionMethod,
                    pre_master_secret: null,
                    master_secret: null,
                    client_random: i,
                    server_random: s
                  };
                }, a.handleServerHello = function(e, t, n) {
                  var r = a.parseHelloMessage(e, t, n);
                  if (!e.fail) {
                    var i = r.session_id.bytes();
                    i.length > 0 && i === e.session.id ? (e.expect = d, e.session.resuming = !0, e.session.sp.server_random = r.random.bytes()) : (e.expect = l, e.session.resuming = !1, a.createSecurityParameters(e, r)), e.session.id = i, e.process();
                  }
                }, a.handleClientHello = function(t, n, r) {
                  var i = a.parseHelloMessage(t, n, r);
                  if (!t.fail) {
                    var s = i.session_id.bytes(),
                        o = null;
                    t.sessionCache && (o = t.sessionCache.getSession(s), o === null && (s = "")), s.length === 0 && (s = e.random.getBytes(32)), t.session.id = s, t.session.clientHelloVersion = i.version, t.session.sp = o ? o.sp : {}, o !== null ? (t.expect = S, t.session.resuming = !0, t.session.sp.client_random = i.random.bytes()) : (t.expect = t.verifyClient !== !1 ? b : w, t.session.resuming = !1, a.createSecurityParameters(t, i)), t.open = !0, a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createServerHello(t)
                    })), t.session.resuming ? (a.queue(t, a.createRecord({
                      type: a.ContentType.change_cipher_spec,
                      data: a.createChangeCipherSpec()
                    })), t.state.pending = a.createConnectionState(t), t.state.current.write = t.state.pending.write, a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createFinished(t)
                    }))) : (a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createCertificate(t)
                    })), t.fail || (a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createServerKeyExchange(t)
                    })), t.verifyClient !== !1 && a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createCertificateRequest(t)
                    })), a.queue(t, a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createServerHelloDone(t)
                    })))), a.flush(t), t.process();
                  }
                }, a.handleCertificate = function(t, n, r) {
                  if (r < 3)
                    t.error(t, {
                      message: "Invalid Certificate message. Message too short.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var i = n.fragment,
                        s = {certificate_list: o(i, 3)},
                        u,
                        f,
                        l = [];
                    try {
                      while (s.certificate_list.length() > 0)
                        u = o(s.certificate_list, 3), f = e.asn1.fromDer(u), u = e.pki.certificateFromAsn1(f, !0), l.push(u);
                    } catch (h) {
                      t.error(t, {
                        message: "Could not parse certificate list.",
                        cause: h,
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.bad_certificate
                        }
                      });
                    }
                    if (!t.fail) {
                      var p = t.entity === a.ConnectionEnd.client;
                      !p && t.verifyClient !== !0 || l.length !== 0 ? l.length === 0 ? t.expect = p ? c : w : (p ? t.session.serverCertificate = l[0] : t.session.clientCertificate = l[0], a.verifyCertificateChain(t, l) && (t.expect = p ? c : w)) : t.error(t, {
                        message: p ? "No server certificate provided." : "No client certificate provided.",
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.illegal_parameter
                        }
                      }), t.process();
                    }
                  }
                }, a.handleServerKeyExchange = function(e, t, n) {
                  n > 0 ? e.error(e, {
                    message: "Invalid key parameters. Only RSA is supported.",
                    send: !0,
                    alert: {
                      level: a.Alert.Level.fatal,
                      description: a.Alert.Description.unsupported_certificate
                    }
                  }) : (e.expect = h, e.process());
                }, a.handleClientKeyExchange = function(t, n, r) {
                  if (r < 48)
                    t.error(t, {
                      message: "Invalid key parameters. Only RSA is supported.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.unsupported_certificate
                      }
                    });
                  else {
                    var i = n.fragment,
                        s = {enc_pre_master_secret: o(i, 2).getBytes()},
                        u = null;
                    if (t.getPrivateKey)
                      try {
                        u = t.getPrivateKey(t, t.session.serverCertificate), u = e.pki.privateKeyFromPem(u);
                      } catch (f) {
                        t.error(t, {
                          message: "Could not get private key.",
                          cause: f,
                          send: !0,
                          alert: {
                            level: a.Alert.Level.fatal,
                            description: a.Alert.Description.internal_error
                          }
                        });
                      }
                    if (u === null)
                      t.error(t, {
                        message: "No private key set.",
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.internal_error
                        }
                      });
                    else
                      try {
                        var l = t.session.sp;
                        l.pre_master_secret = u.decrypt(s.enc_pre_master_secret);
                        var c = t.session.clientHelloVersion;
                        if (c.major !== l.pre_master_secret.charCodeAt(0) || c.minor !== l.pre_master_secret.charCodeAt(1))
                          throw {message: "TLS version rollback attack detected."};
                      } catch (f) {
                        l.pre_master_secret = e.random.getBytes(48);
                      }
                  }
                  t.fail || (t.expect = S, t.session.clientCertificate !== null && (t.expect = E), t.process());
                }, a.handleCertificateRequest = function(e, t, n) {
                  if (n < 3)
                    e.error(e, {
                      message: "Invalid CertificateRequest. Message too short.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var r = t.fragment,
                        i = {
                          certificate_types: o(r, 1),
                          certificate_authorities: o(r, 2)
                        };
                    e.session.certificateRequest = i, e.expect = p, e.process();
                  }
                }, a.handleCertificateVerify = function(t, n, r) {
                  if (r < 2)
                    t.error(t, {
                      message: "Invalid CertificateVerify. Message too short.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var i = n.fragment;
                    i.read -= 4;
                    var s = i.bytes();
                    i.read += 4;
                    var u = {signature: o(i, 2).getBytes()},
                        f = e.util.createBuffer();
                    f.putBuffer(t.session.md5.digest()), f.putBuffer(t.session.sha1.digest()), f = f.getBytes();
                    try {
                      var l = t.session.clientCertificate;
                      if (!l.publicKey.verify(f, u.signature, "NONE"))
                        throw {message: "CertificateVerify signature does not match."};
                      t.session.md5.update(s), t.session.sha1.update(s);
                    } catch (c) {
                      t.error(t, {
                        message: "Bad signature in CertificateVerify.",
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.handshake_failure
                        }
                      });
                    }
                    t.fail || (t.expect = S, t.process());
                  }
                }, a.handleServerHelloDone = function(t, n, r) {
                  if (r > 0)
                    t.error(t, {
                      message: "Invalid ServerHelloDone message. Invalid length.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.record_overflow
                      }
                    });
                  else if (t.serverCertificate === null) {
                    var i = {
                      message: "No server certificate provided. Not enough security.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.insufficient_security
                      }
                    },
                        s = t.verify(t, i.alert.description, depth, []);
                    if (s === !0)
                      i = null;
                    else {
                      if (s || s === 0)
                        typeof s == "object" && !e.util.isArray(s) ? (s.message && (i.message = s.message), s.alert && (i.alert.description = s.alert)) : typeof s == "number" && (i.alert.description = s);
                      t.error(t, i);
                    }
                  }
                  !t.fail && t.session.certificateRequest !== null && (n = a.createRecord({
                    type: a.ContentType.handshake,
                    data: a.createCertificate(t)
                  }), a.queue(t, n));
                  if (!t.fail) {
                    n = a.createRecord({
                      type: a.ContentType.handshake,
                      data: a.createClientKeyExchange(t)
                    }), a.queue(t, n), t.expect = g;
                    var o = function(e, t) {
                      e.session.certificateRequest !== null && e.session.clientCertificate !== null && a.queue(e, a.createRecord({
                        type: a.ContentType.handshake,
                        data: a.createCertificateVerify(e, t)
                      })), a.queue(e, a.createRecord({
                        type: a.ContentType.change_cipher_spec,
                        data: a.createChangeCipherSpec()
                      })), e.state.pending = a.createConnectionState(e), e.state.current.write = e.state.pending.write, a.queue(e, a.createRecord({
                        type: a.ContentType.handshake,
                        data: a.createFinished(e)
                      })), e.expect = d, a.flush(e), e.process();
                    };
                    t.session.certificateRequest === null || t.session.clientCertificate === null ? o(t, null) : a.getClientSignature(t, o);
                  }
                }, a.handleChangeCipherSpec = function(e, t) {
                  if (t.fragment.getByte() !== 1)
                    e.error(e, {
                      message: "Invalid ChangeCipherSpec message received.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.illegal_parameter
                      }
                    });
                  else {
                    var n = e.entity === a.ConnectionEnd.client;
                    if (e.session.resuming && n || !e.session.resuming && !n)
                      e.state.pending = a.createConnectionState(e);
                    e.state.current.read = e.state.pending.read;
                    if (!e.session.resuming && n || e.session.resuming && !n)
                      e.state.pending = null;
                    e.expect = n ? v : x, e.process();
                  }
                }, a.handleFinished = function(n, r, i) {
                  var s = r.fragment;
                  s.read -= 4;
                  var o = s.bytes();
                  s.read += 4;
                  var u = r.fragment.getBytes();
                  s = e.util.createBuffer(), s.putBuffer(n.session.md5.digest()), s.putBuffer(n.session.sha1.digest());
                  var f = n.entity === a.ConnectionEnd.client,
                      l = f ? "server finished" : "client finished",
                      c = n.session.sp,
                      h = 12,
                      p = t;
                  s = p(c.master_secret, l, s.getBytes(), h);
                  if (s.getBytes() !== u)
                    n.error(n, {
                      message: "Invalid verify_data in Finished message.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.decrypt_error
                      }
                    });
                  else {
                    n.session.md5.update(o), n.session.sha1.update(o);
                    if (n.session.resuming && f || !n.session.resuming && !f)
                      a.queue(n, a.createRecord({
                        type: a.ContentType.change_cipher_spec,
                        data: a.createChangeCipherSpec()
                      })), n.state.current.write = n.state.pending.write, n.state.pending = null, a.queue(n, a.createRecord({
                        type: a.ContentType.handshake,
                        data: a.createFinished(n)
                      }));
                    n.expect = f ? m : T, n.handshaking = !1, ++n.handshakes, n.peerCertificate = f ? n.session.serverCertificate : n.session.clientCertificate, n.sessionCache ? (n.session = {
                      id: n.session.id,
                      sp: n.session.sp
                    }, n.session.sp.keys = null) : n.session = null, a.flush(n), n.isConnected = !0, n.connected(n), n.process();
                  }
                }, a.handleAlert = function(e, t) {
                  var n = t.fragment,
                      r = {
                        level: n.getByte(),
                        description: n.getByte()
                      },
                      i;
                  switch (r.description) {
                    case a.Alert.Description.close_notify:
                      i = "Connection closed.";
                      break;
                    case a.Alert.Description.unexpected_message:
                      i = "Unexpected message.";
                      break;
                    case a.Alert.Description.bad_record_mac:
                      i = "Bad record MAC.";
                      break;
                    case a.Alert.Description.decryption_failed:
                      i = "Decryption failed.";
                      break;
                    case a.Alert.Description.record_overflow:
                      i = "Record overflow.";
                      break;
                    case a.Alert.Description.decompression_failure:
                      i = "Decompression failed.";
                      break;
                    case a.Alert.Description.handshake_failure:
                      i = "Handshake failure.";
                      break;
                    case a.Alert.Description.bad_certificate:
                      i = "Bad certificate.";
                      break;
                    case a.Alert.Description.unsupported_certificate:
                      i = "Unsupported certificate.";
                      break;
                    case a.Alert.Description.certificate_revoked:
                      i = "Certificate revoked.";
                      break;
                    case a.Alert.Description.certificate_expired:
                      i = "Certificate expired.";
                      break;
                    case a.Alert.Description.certificate_unknown:
                      i = "Certificate unknown.";
                      break;
                    case a.Alert.Description.illegal_parameter:
                      i = "Illegal parameter.";
                      break;
                    case a.Alert.Description.unknown_ca:
                      i = "Unknown certificate authority.";
                      break;
                    case a.Alert.Description.access_denied:
                      i = "Access denied.";
                      break;
                    case a.Alert.Description.decode_error:
                      i = "Decode error.";
                      break;
                    case a.Alert.Description.decrypt_error:
                      i = "Decrypt error.";
                      break;
                    case a.Alert.Description.export_restriction:
                      i = "Export restriction.";
                      break;
                    case a.Alert.Description.protocol_version:
                      i = "Unsupported protocol version.";
                      break;
                    case a.Alert.Description.insufficient_security:
                      i = "Insufficient security.";
                      break;
                    case a.Alert.Description.internal_error:
                      i = "Internal error.";
                      break;
                    case a.Alert.Description.user_canceled:
                      i = "User canceled.";
                      break;
                    case a.Alert.Description.no_renegotiation:
                      i = "Renegotiation not supported.";
                      break;
                    default:
                      i = "Unknown error.";
                  }
                  r.description === a.Alert.Description.close_notify ? e.close() : (e.error(e, {
                    message: i,
                    send: !1,
                    origin: e.entity === a.ConnectionEnd.client ? "server" : "client",
                    alert: r
                  }), e.process());
                }, a.handleHandshake = function(t, n) {
                  var r = n.fragment,
                      i = r.getByte(),
                      s = r.getInt24();
                  if (s > r.length())
                    t.fragmented = n, n.fragment = e.util.createBuffer(), r.read -= 4, t.process();
                  else {
                    t.fragmented = null, r.read -= 4;
                    var o = r.bytes(s + 4);
                    r.read += 4, i in I[t.entity][t.expect] ? (t.entity === a.ConnectionEnd.server && !t.open && !t.fail && (t.handshaking = !0, t.session = {
                      serverNameList: [],
                      cipherSuite: null,
                      compressionMethod: null,
                      serverCertificate: null,
                      clientCertificate: null,
                      md5: e.md.md5.create(),
                      sha1: e.md.sha1.create()
                    }), i !== a.HandshakeType.hello_request && i !== a.HandshakeType.certificate_verify && i !== a.HandshakeType.finished && (t.session.md5.update(o), t.session.sha1.update(o)), I[t.entity][t.expect][i](t, n, s)) : a.handleUnexpected(t, n);
                  }
                }, a.handleApplicationData = function(e, t) {
                  e.data.putBuffer(t.fragment), e.dataReady(e), e.process();
                };
                var f = 0,
                    l = 1,
                    c = 2,
                    h = 3,
                    p = 4,
                    d = 5,
                    v = 6,
                    m = 7,
                    g = 8,
                    y = 0,
                    b = 1,
                    w = 2,
                    E = 3,
                    S = 4,
                    x = 5,
                    T = 6,
                    N = 7,
                    C = a.handleUnexpected,
                    k = a.handleChangeCipherSpec,
                    L = a.handleAlert,
                    A = a.handleHandshake,
                    O = a.handleApplicationData,
                    M = [];
                M[a.ConnectionEnd.client] = [[C, L, A, C], [C, L, A, C], [C, L, A, C], [C, L, A, C], [C, L, A, C], [k, L, C, C], [C, L, A, C], [C, L, A, O], [C, L, A, C]], M[a.ConnectionEnd.server] = [[C, L, A, C], [C, L, A, C], [C, L, A, C], [C, L, A, C], [k, L, C, C], [C, L, A, C], [C, L, A, O], [C, L, A, C]];
                var _ = a.handleHelloRequest,
                    D = a.handleServerHello,
                    P = a.handleCertificate,
                    H = a.handleServerKeyExchange,
                    B = a.handleCertificateRequest,
                    j = a.handleServerHelloDone,
                    F = a.handleFinished,
                    I = [];
                I[a.ConnectionEnd.client] = [[C, C, D, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, P, H, B, j, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, H, B, j, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, B, j, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, j, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, F], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [_, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C]];
                var q = a.handleClientHello,
                    R = a.handleClientKeyExchange,
                    U = a.handleCertificateVerify;
                I[a.ConnectionEnd.server] = [[C, q, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, P, C, C, C, C, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, R, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, U, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, F], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C], [C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C]], a.generateKeys = function(e, n) {
                  var r = t,
                      i = n.client_random + n.server_random;
                  e.session.resuming || (n.master_secret = r(n.pre_master_secret, "master secret", i, 48).bytes(), n.pre_master_secret = null), i = n.server_random + n.client_random;
                  var s = 2 * n.mac_key_length + 2 * n.enc_key_length + 2 * n.fixed_iv_length,
                      o = r(n.master_secret, "key expansion", i, s);
                  return {
                    client_write_MAC_key: o.getBytes(n.mac_key_length),
                    server_write_MAC_key: o.getBytes(n.mac_key_length),
                    client_write_key: o.getBytes(n.enc_key_length),
                    server_write_key: o.getBytes(n.enc_key_length),
                    client_write_IV: o.getBytes(n.fixed_iv_length),
                    server_write_IV: o.getBytes(n.fixed_iv_length)
                  };
                }, a.createConnectionState = function(e) {
                  var t = e.entity === a.ConnectionEnd.client,
                      n = function() {
                        var e = {
                          sequenceNumber: [0, 0],
                          macKey: null,
                          macLength: 0,
                          macFunction: null,
                          cipherState: null,
                          cipherFunction: function(e) {
                            return !0;
                          },
                          compressionState: null,
                          compressFunction: function(e) {
                            return !0;
                          },
                          updateSequenceNumber: function() {
                            e.sequenceNumber[1] === 4294967295 ? (e.sequenceNumber[1] = 0, ++e.sequenceNumber[0]) : ++e.sequenceNumber[1];
                          }
                        };
                        return e;
                      },
                      r = {
                        read: n(),
                        write: n()
                      };
                  r.read.update = function(e, t) {
                    return r.read.cipherFunction(t, r.read) ? r.read.compressFunction(e, t, r.read) || e.error(e, {
                      message: "Could not decompress record.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.decompression_failure
                      }
                    }) : e.error(e, {
                      message: "Could not decrypt record or bad MAC.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.bad_record_mac
                      }
                    }), !e.fail;
                  }, r.write.update = function(e, t) {
                    return r.write.compressFunction(e, t, r.write) ? r.write.cipherFunction(t, r.write) || e.error(e, {
                      message: "Could not encrypt record.",
                      send: !1,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.internal_error
                      }
                    }) : e.error(e, {
                      message: "Could not compress record.",
                      send: !1,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.internal_error
                      }
                    }), !e.fail;
                  };
                  if (e.session) {
                    var o = e.session.sp;
                    e.session.cipherSuite.initSecurityParameters(o), o.keys = a.generateKeys(e, o), r.read.macKey = t ? o.keys.server_write_MAC_key : o.keys.client_write_MAC_key, r.write.macKey = t ? o.keys.client_write_MAC_key : o.keys.server_write_MAC_key, e.session.cipherSuite.initConnectionState(r, e, o);
                    switch (o.compression_algorithm) {
                      case a.CompressionMethod.none:
                        break;
                      case a.CompressionMethod.deflate:
                        r.read.compressFunction = s, r.write.compressFunction = i;
                        break;
                      default:
                        throw {message: "Unsupported compression algorithm."};
                    }
                  }
                  return r;
                }, a.createRandom = function() {
                  var t = new Date,
                      n = +t + t.getTimezoneOffset() * 6e4,
                      r = e.util.createBuffer();
                  return r.putInt32(n), r.putBytes(e.random.getBytes(28)), r;
                }, a.createRecord = function(e) {
                  if (!e.data)
                    return null;
                  var t = {
                    type: e.type,
                    version: {
                      major: a.Version.major,
                      minor: a.Version.minor
                    },
                    length: e.data.length(),
                    fragment: e.data
                  };
                  return t;
                }, a.createAlert = function(t) {
                  var n = e.util.createBuffer();
                  return n.putByte(t.level), n.putByte(t.description), a.createRecord({
                    type: a.ContentType.alert,
                    data: n
                  });
                }, a.createClientHello = function(t) {
                  var n = e.util.createBuffer();
                  for (var r = 0; r < t.cipherSuites.length; ++r) {
                    var i = t.cipherSuites[r];
                    n.putByte(i.id[0]), n.putByte(i.id[1]);
                  }
                  var s = n.length(),
                      o = e.util.createBuffer();
                  o.putByte(a.CompressionMethod.none);
                  var f = o.length(),
                      l = e.util.createBuffer();
                  if (t.virtualHost) {
                    var c = e.util.createBuffer();
                    c.putByte(0), c.putByte(0);
                    var h = e.util.createBuffer();
                    h.putByte(0), u(h, 2, e.util.createBuffer(t.virtualHost));
                    var p = e.util.createBuffer();
                    u(p, 2, h), u(c, 2, p), l.putBuffer(c);
                  }
                  var d = l.length();
                  d > 0 && (d += 2);
                  var v = t.session.id,
                      m = v.length + 1 + 2 + 4 + 28 + 2 + s + 1 + f + d,
                      g = e.util.createBuffer();
                  return g.putByte(a.HandshakeType.client_hello), g.putInt24(m), g.putByte(a.Version.major), g.putByte(a.Version.minor), g.putBytes(t.session.sp.client_random), u(g, 1, e.util.createBuffer(v)), u(g, 2, n), u(g, 1, o), d > 0 && u(g, 2, l), g;
                }, a.createServerHello = function(t) {
                  var n = t.session.id,
                      r = n.length + 1 + 2 + 4 + 28 + 2 + 1,
                      i = e.util.createBuffer();
                  return i.putByte(a.HandshakeType.server_hello), i.putInt24(r), i.putByte(a.Version.major), i.putByte(a.Version.minor), i.putBytes(t.session.sp.server_random), u(i, 1, e.util.createBuffer(n)), i.putByte(t.session.cipherSuite.id[0]), i.putByte(t.session.cipherSuite.id[1]), i.putByte(t.session.compressionMethod), i;
                }, a.createCertificate = function(t) {
                  var n = t.entity === a.ConnectionEnd.client,
                      r = null;
                  t.getCertificate && (r = t.getCertificate(t, n ? t.session.certificateRequest : t.session.serverNameList));
                  var i = e.util.createBuffer();
                  if (r !== null)
                    try {
                      e.util.isArray(r) || (r = [r]);
                      var s = null;
                      for (var o = 0; o < r.length; ++o) {
                        var f = e.pem.decode(r[o])[0];
                        if (f.type !== "CERTIFICATE" && f.type !== "X509 CERTIFICATE" && f.type !== "TRUSTED CERTIFICATE")
                          throw {
                            message: 'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',
                            headerType: f.type
                          };
                        if (f.procType && f.procType.type === "ENCRYPTED")
                          throw {message: "Could not convert certificate from PEM; PEM is encrypted."};
                        var l = e.util.createBuffer(f.body);
                        s === null && (s = e.asn1.fromDer(l.bytes(), !1));
                        var c = e.util.createBuffer();
                        u(c, 3, l), i.putBuffer(c);
                      }
                      r = e.pki.certificateFromAsn1(s), n ? t.session.clientCertificate = r : t.session.serverCertificate = r;
                    } catch (h) {
                      return t.error(t, {
                        message: "Could not send certificate list.",
                        cause: h,
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: a.Alert.Description.bad_certificate
                        }
                      });
                    }
                  var p = 3 + i.length(),
                      d = e.util.createBuffer();
                  return d.putByte(a.HandshakeType.certificate), d.putInt24(p), u(d, 3, i), d;
                }, a.createClientKeyExchange = function(t) {
                  var n = e.util.createBuffer();
                  n.putByte(a.Version.major), n.putByte(a.Version.minor), n.putBytes(e.random.getBytes(46));
                  var r = t.session.sp;
                  r.pre_master_secret = n.getBytes();
                  var i = t.session.serverCertificate.publicKey;
                  n = i.encrypt(r.pre_master_secret);
                  var s = n.length + 2,
                      o = e.util.createBuffer();
                  return o.putByte(a.HandshakeType.client_key_exchange), o.putInt24(s), o.putInt16(n.length), o.putBytes(n), o;
                }, a.createServerKeyExchange = function(t) {
                  var n = 0,
                      r = e.util.createBuffer();
                  return n > 0 && (r.putByte(a.HandshakeType.server_key_exchange), r.putInt24(n)), r;
                }, a.getClientSignature = function(t, n) {
                  var r = e.util.createBuffer();
                  r.putBuffer(t.session.md5.digest()), r.putBuffer(t.session.sha1.digest()), r = r.getBytes(), t.getSignature = t.getSignature || function(t, n, r) {
                    var i = null;
                    if (t.getPrivateKey)
                      try {
                        i = t.getPrivateKey(t, t.session.clientCertificate), i = e.pki.privateKeyFromPem(i);
                      } catch (s) {
                        t.error(t, {
                          message: "Could not get private key.",
                          cause: s,
                          send: !0,
                          alert: {
                            level: a.Alert.Level.fatal,
                            description: a.Alert.Description.internal_error
                          }
                        });
                      }
                    i === null ? t.error(t, {
                      message: "No private key set.",
                      send: !0,
                      alert: {
                        level: a.Alert.Level.fatal,
                        description: a.Alert.Description.internal_error
                      }
                    }) : n = i.sign(n, null), r(t, n);
                  }, t.getSignature(t, r, n);
                }, a.createCertificateVerify = function(t, n) {
                  var r = n.length + 2,
                      i = e.util.createBuffer();
                  return i.putByte(a.HandshakeType.certificate_verify), i.putInt24(r), i.putInt16(n.length), i.putBytes(n), i;
                }, a.createCertificateRequest = function(t) {
                  var n = e.util.createBuffer();
                  n.putByte(1);
                  var r = e.util.createBuffer();
                  for (var i in t.caStore.certs) {
                    var s = t.caStore.certs[i],
                        o = e.pki.distinguishedNameToAsn1(s.subject);
                    r.putBuffer(e.asn1.toDer(o));
                  }
                  var f = 1 + n.length() + 2 + r.length(),
                      l = e.util.createBuffer();
                  return l.putByte(a.HandshakeType.certificate_request), l.putInt24(f), u(l, 1, n), u(l, 2, r), l;
                }, a.createServerHelloDone = function(t) {
                  var n = e.util.createBuffer();
                  return n.putByte(a.HandshakeType.server_hello_done), n.putInt24(0), n;
                }, a.createChangeCipherSpec = function() {
                  var t = e.util.createBuffer();
                  return t.putByte(1), t;
                }, a.createFinished = function(n) {
                  var r = e.util.createBuffer();
                  r.putBuffer(n.session.md5.digest()), r.putBuffer(n.session.sha1.digest());
                  var i = n.entity === a.ConnectionEnd.client,
                      s = n.session.sp,
                      o = 12,
                      u = t,
                      f = i ? "client finished" : "server finished";
                  r = u(s.master_secret, f, r.getBytes(), o);
                  var l = e.util.createBuffer();
                  return l.putByte(a.HandshakeType.finished), l.putInt24(r.length()), l.putBuffer(r), l;
                }, a.queue = function(t, n) {
                  if (!n)
                    return;
                  if (n.type === a.ContentType.handshake) {
                    var r = n.fragment.bytes();
                    t.session.md5.update(r), t.session.sha1.update(r), r = null;
                  }
                  var i;
                  if (n.fragment.length() <= a.MaxFragment)
                    i = [n];
                  else {
                    i = [];
                    var s = n.fragment.bytes();
                    while (s.length > a.MaxFragment)
                      i.push(a.createRecord({
                        type: n.type,
                        data: e.util.createBuffer(s.slice(0, a.MaxFragment))
                      })), s = s.slice(a.MaxFragment);
                    s.length > 0 && i.push(a.createRecord({
                      type: n.type,
                      data: e.util.createBuffer(s)
                    }));
                  }
                  for (var o = 0; o < i.length && !t.fail; ++o) {
                    var u = i[o],
                        f = t.state.current.write;
                    f.update(t, u) && t.records.push(u);
                  }
                }, a.flush = function(e) {
                  for (var t = 0; t < e.records.length; ++t) {
                    var n = e.records[t];
                    e.tlsData.putByte(n.type), e.tlsData.putByte(n.version.major), e.tlsData.putByte(n.version.minor), e.tlsData.putInt16(n.fragment.length()), e.tlsData.putBuffer(e.records[t].fragment);
                  }
                  return e.records = [], e.tlsDataReady(e);
                };
                var z = function(t) {
                  switch (t) {
                    case !0:
                      return !0;
                    case e.pki.certificateError.bad_certificate:
                      return a.Alert.Description.bad_certificate;
                    case e.pki.certificateError.unsupported_certificate:
                      return a.Alert.Description.unsupported_certificate;
                    case e.pki.certificateError.certificate_revoked:
                      return a.Alert.Description.certificate_revoked;
                    case e.pki.certificateError.certificate_expired:
                      return a.Alert.Description.certificate_expired;
                    case e.pki.certificateError.certificate_unknown:
                      return a.Alert.Description.certificate_unknown;
                    case e.pki.certificateError.unknown_ca:
                      return a.Alert.Description.unknown_ca;
                    default:
                      return a.Alert.Description.bad_certificate;
                  }
                },
                    W = function(t) {
                      switch (t) {
                        case !0:
                          return !0;
                        case a.Alert.Description.bad_certificate:
                          return e.pki.certificateError.bad_certificate;
                        case a.Alert.Description.unsupported_certificate:
                          return e.pki.certificateError.unsupported_certificate;
                        case a.Alert.Description.certificate_revoked:
                          return e.pki.certificateError.certificate_revoked;
                        case a.Alert.Description.certificate_expired:
                          return e.pki.certificateError.certificate_expired;
                        case a.Alert.Description.certificate_unknown:
                          return e.pki.certificateError.certificate_unknown;
                        case a.Alert.Description.unknown_ca:
                          return e.pki.certificateError.unknown_ca;
                        default:
                          return e.pki.certificateError.bad_certificate;
                      }
                    };
                a.verifyCertificateChain = function(t, n) {
                  try {
                    e.pki.verifyCertificateChain(t.caStore, n, function(r, i, s) {
                      var o = z(r),
                          u = t.verify(t, r, i, s);
                      if (u !== !0) {
                        if (typeof u == "object" && !e.util.isArray(u)) {
                          var f = {
                            message: "The application rejected the certificate.",
                            send: !0,
                            alert: {
                              level: a.Alert.Level.fatal,
                              description: a.Alert.Description.bad_certificate
                            }
                          };
                          throw u.message && (f.message = u.message), u.alert && (f.alert.description = u.alert), f;
                        }
                        u !== r && (u = W(u));
                      }
                      return u;
                    });
                  } catch (r) {
                    if (typeof r != "object" || e.util.isArray(r))
                      r = {
                        send: !0,
                        alert: {
                          level: a.Alert.Level.fatal,
                          description: z(r)
                        }
                      };
                    "send" in r || (r.send = !0), "alert" in r || (r.alert = {
                      level: a.Alert.Level.fatal,
                      description: z(r.error)
                    }), t.error(t, r);
                  }
                  return !t.fail;
                }, a.createSessionCache = function(t, n) {
                  var r = null;
                  if (t && t.getSession && t.setSession && t.order)
                    r = t;
                  else {
                    r = {}, r.cache = t || {}, r.capacity = Math.max(n || 100, 1), r.order = [];
                    for (var i in t)
                      r.order.length <= n ? r.order.push(i) : delete t[i];
                    r.getSession = function(t) {
                      var n = null,
                          i = null;
                      t ? i = e.util.bytesToHex(t) : r.order.length > 0 && (i = r.order[0]);
                      if (i !== null && i in r.cache) {
                        n = r.cache[i], delete r.cache[i];
                        for (var s in r.order)
                          if (r.order[s] === i) {
                            r.order.splice(s, 1);
                            break;
                          }
                      }
                      return n;
                    }, r.setSession = function(t, n) {
                      if (r.order.length === r.capacity) {
                        var i = r.order.shift();
                        delete r.cache[i];
                      }
                      var i = e.util.bytesToHex(t);
                      r.order.push(i), r.cache[i] = n;
                    };
                  }
                  return r;
                }, a.createConnection = function(t) {
                  var n = null;
                  t.caStore ? e.util.isArray(t.caStore) ? n = e.pki.createCaStore(t.caStore) : n = t.caStore : n = e.pki.createCaStore();
                  var r = t.cipherSuites || null;
                  if (r === null) {
                    r = [];
                    for (var i in a.CipherSuites)
                      r.push(a.CipherSuites[i]);
                  }
                  var s = t.server || !1 ? a.ConnectionEnd.server : a.ConnectionEnd.client,
                      o = t.sessionCache ? a.createSessionCache(t.sessionCache) : null,
                      u = {
                        entity: s,
                        sessionId: t.sessionId,
                        caStore: n,
                        sessionCache: o,
                        cipherSuites: r,
                        connected: t.connected,
                        virtualHost: t.virtualHost || null,
                        verifyClient: t.verifyClient || !1,
                        verify: t.verify || function(e, t, n, r) {
                          return t;
                        },
                        getCertificate: t.getCertificate || null,
                        getPrivateKey: t.getPrivateKey || null,
                        getSignature: t.getSignature || null,
                        input: e.util.createBuffer(),
                        tlsData: e.util.createBuffer(),
                        data: e.util.createBuffer(),
                        tlsDataReady: t.tlsDataReady,
                        dataReady: t.dataReady,
                        closed: t.closed,
                        error: function(e, n) {
                          n.origin = n.origin || (e.entity === a.ConnectionEnd.client ? "client" : "server"), n.send && (a.queue(e, a.createAlert(n.alert)), a.flush(e));
                          var r = n.fatal !== !1;
                          r && (e.fail = !0), t.error(e, n), r && e.close(!1);
                        },
                        deflate: t.deflate || null,
                        inflate: t.inflate || null
                      };
                  u.reset = function(e) {
                    u.record = null, u.session = null, u.peerCertificate = null, u.state = {
                      pending: null,
                      current: null
                    }, u.expect = u.entity === a.ConnectionEnd.client ? f : y, u.fragmented = null, u.records = [], u.open = !1, u.handshakes = 0, u.handshaking = !1, u.isConnected = !1, u.fail = !e && typeof e != "undefined", u.input.clear(), u.tlsData.clear(), u.data.clear(), u.state.current = a.createConnectionState(u);
                  }, u.reset();
                  var l = function(e, t) {
                    var n = t.type - a.ContentType.change_cipher_spec,
                        r = M[e.entity][e.expect];
                    n in r ? r[n](e, t) : a.handleUnexpected(e, t);
                  },
                      c = function(t) {
                        var n = 0,
                            r = t.input,
                            i = r.length();
                        return i < 5 ? n = 5 - i : (t.record = {
                          type: r.getByte(),
                          version: {
                            major: r.getByte(),
                            minor: r.getByte()
                          },
                          length: r.getInt16(),
                          fragment: e.util.createBuffer(),
                          ready: !1
                        }, (t.record.version.major !== a.Version.major || t.record.version.minor !== a.Version.minor) && t.error(t, {
                          message: "Incompatible TLS version.",
                          send: !0,
                          alert: {
                            level: a.Alert.Level.fatal,
                            description: a.Alert.Description.protocol_version
                          }
                        })), n;
                      },
                      h = function(e) {
                        var t = 0,
                            n = e.input,
                            r = n.length();
                        if (r < e.record.length)
                          t = e.record.length - r;
                        else {
                          e.record.fragment.putBytes(n.getBytes(e.record.length)), n.compact();
                          var i = e.state.current.read;
                          i.update(e, e.record) && (e.fragmented !== null && (e.fragmented.type === e.record.type ? (e.fragmented.fragment.putBuffer(e.record.fragment), e.record = e.fragmented) : e.error(e, {
                            message: "Invalid fragmented record.",
                            send: !0,
                            alert: {
                              level: a.Alert.Level.fatal,
                              description: a.Alert.Description.unexpected_message
                            }
                          })), e.record.ready = !0);
                        }
                        return t;
                      };
                  return u.handshake = function(t) {
                    if (u.entity !== a.ConnectionEnd.client)
                      u.error(u, {
                        message: "Cannot initiate handshake as a server.",
                        fatal: !1
                      });
                    else if (u.handshaking)
                      u.error(u, {
                        message: "Handshake already in progress.",
                        fatal: !1
                      });
                    else {
                      u.fail && !u.open && u.handshakes === 0 && (u.fail = !1), u.handshaking = !0, t = t || "";
                      var n = null;
                      t.length > 0 && (u.sessionCache && (n = u.sessionCache.getSession(t)), n === null && (t = "")), t.length === 0 && u.sessionCache && (n = u.sessionCache.getSession(), n !== null && (t = n.id)), u.session = {
                        id: t,
                        cipherSuite: null,
                        compressionMethod: null,
                        serverCertificate: null,
                        certificateRequest: null,
                        clientCertificate: null,
                        sp: n ? n.sp : {},
                        md5: e.md.md5.create(),
                        sha1: e.md.sha1.create()
                      }, u.session.sp.client_random = a.createRandom().getBytes(), u.open = !0, a.queue(u, a.createRecord({
                        type: a.ContentType.handshake,
                        data: a.createClientHello(u)
                      })), a.flush(u);
                    }
                  }, u.process = function(e) {
                    var t = 0;
                    return e && u.input.putBytes(e), u.fail || (u.record !== null && u.record.ready && u.record.fragment.isEmpty() && (u.record = null), u.record === null && (t = c(u)), !u.fail && u.record !== null && !u.record.ready && (t = h(u)), !u.fail && u.record !== null && u.record.ready && l(u, u.record)), t;
                  }, u.prepare = function(t) {
                    return a.queue(u, a.createRecord({
                      type: a.ContentType.application_data,
                      data: e.util.createBuffer(t)
                    })), a.flush(u);
                  }, u.close = function(e) {
                    !u.fail && u.sessionCache && u.session && u.sessionCache.setSession(u.session.id, u.session);
                    if (u.open) {
                      u.open = !1, u.input.clear();
                      if (u.isConnected || u.handshaking)
                        u.isConnected = u.handshaking = !1, a.queue(u, a.createAlert({
                          level: a.Alert.Level.warning,
                          description: a.Alert.Description.close_notify
                        })), a.flush(u);
                      u.closed(u);
                    }
                    u.reset(e);
                  }, u;
                }, e.tls = e.tls || {};
                for (var X in a)
                  typeof a[X] != "function" && (e.tls[X] = a[X]);
                e.tls.prf_tls1 = t, e.tls.hmac_sha1 = r, e.tls.createSessionCache = a.createSessionCache, e.tls.createConnection = a.createConnection;
              }
              var r = "tls";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/tls", ["require", "module", "./asn1", "./hmac", "./md", "./pem", "./pki", "./random", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                function n(n, i, s) {
                  var u = i.entity === e.tls.ConnectionEnd.client;
                  n.read.cipherState = {
                    init: !1,
                    cipher: e.aes.createDecryptionCipher(u ? s.keys.server_write_key : s.keys.client_write_key),
                    iv: u ? s.keys.server_write_IV : s.keys.client_write_IV
                  }, n.write.cipherState = {
                    init: !1,
                    cipher: e.aes.createEncryptionCipher(u ? s.keys.client_write_key : s.keys.server_write_key),
                    iv: u ? s.keys.client_write_IV : s.keys.server_write_IV
                  }, n.read.cipherFunction = o, n.write.cipherFunction = r, n.read.macLength = n.write.macLength = s.mac_length, n.read.macFunction = n.write.macFunction = t.hmac_sha1;
                }
                function r(t, n) {
                  var r = !1,
                      s = n.macFunction(n.macKey, n.sequenceNumber, t);
                  t.fragment.putBytes(s), n.updateSequenceNumber();
                  var o;
                  t.version.minor > 1 ? o = e.random.getBytes(16) : o = n.cipherState.init ? null : n.cipherState.iv, n.cipherState.init = !0;
                  var u = n.cipherState.cipher;
                  return u.start(o), t.version.minor > 1 && u.output.putBytes(o), u.update(t.fragment), u.finish(i) && (t.fragment = u.output, t.length = t.fragment.length(), r = !0), r;
                }
                function i(e, t, n) {
                  if (!n) {
                    var r = e - t.length() % e;
                    t.fillWithByte(r - 1, r);
                  }
                  return !0;
                }
                function s(e, t, n) {
                  var r = !0;
                  if (n) {
                    var i = t.length(),
                        s = t.last();
                    for (var o = i - 1 - s; o < i - 1; ++o)
                      r = r && t.at(o) == s;
                    r && t.truncate(s + 1);
                  }
                  return r;
                }
                function o(t, n) {
                  var r = !1,
                      i = n.cipherState.init ? null : n.cipherState.iv;
                  n.cipherState.init = !0;
                  var o = n.cipherState.cipher;
                  o.start(i), o.update(t.fragment), r = o.finish(s);
                  var u = n.macLength,
                      a = "";
                  for (var f = 0; f < u; ++f)
                    a += String.fromCharCode(0);
                  var l = o.output.length();
                  l >= u ? (t.fragment = o.output.getBytes(l - u), a = o.output.getBytes(u)) : t.fragment = o.output.getBytes(), t.fragment = e.util.createBuffer(t.fragment), t.length = t.fragment.length();
                  var c = n.macFunction(n.macKey, n.sequenceNumber, t);
                  return n.updateSequenceNumber(), r = c === a && r, r;
                }
                var t = e.tls;
                t.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
                  id: [0, 47],
                  name: "TLS_RSA_WITH_AES_128_CBC_SHA",
                  initSecurityParameters: function(e) {
                    e.bulk_cipher_algorithm = t.BulkCipherAlgorithm.aes, e.cipher_type = t.CipherType.block, e.enc_key_length = 16, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = t.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
                  },
                  initConnectionState: n
                }, t.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
                  id: [0, 53],
                  name: "TLS_RSA_WITH_AES_256_CBC_SHA",
                  initSecurityParameters: function(e) {
                    e.bulk_cipher_algorithm = t.BulkCipherAlgorithm.aes, e.cipher_type = t.CipherType.block, e.enc_key_length = 32, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = t.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
                  },
                  initConnectionState: n
                };
              }
              var r = "aesCipherSuites";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/aesCipherSuites", ["require", "module", "./aes", "./tls"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.debug = e.debug || {}, e.debug.storage = {}, e.debug.get = function(t, n) {
                  var r;
                  return typeof t == "undefined" ? r = e.debug.storage : t in e.debug.storage && (typeof n == "undefined" ? r = e.debug.storage[t] : r = e.debug.storage[t][n]), r;
                }, e.debug.set = function(t, n, r) {
                  t in e.debug.storage || (e.debug.storage[t] = {}), e.debug.storage[t][n] = r;
                }, e.debug.clear = function(t, n) {
                  typeof t == "undefined" ? e.debug.storage = {} : t in e.debug.storage && (typeof n == "undefined" ? delete e.debug.storage[t] : delete e.debug.storage[t][n]);
                };
              }
              var r = "debug";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/debug", ["require", "module"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                e.log = e.log || {}, e.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"];
                var t = {},
                    n = [],
                    r = null;
                e.log.LEVEL_LOCKED = 2, e.log.NO_LEVEL_CHECK = 4, e.log.INTERPOLATE = 8;
                for (var i = 0; i < e.log.levels.length; ++i) {
                  var s = e.log.levels[i];
                  t[s] = {
                    index: i,
                    name: s.toUpperCase()
                  };
                }
                e.log.logMessage = function(r) {
                  var i = t[r.level].index;
                  for (var s = 0; s < n.length; ++s) {
                    var o = n[s];
                    if (o.flags & e.log.NO_LEVEL_CHECK)
                      o.f(r);
                    else {
                      var u = t[o.level].index;
                      i <= u && o.f(o, r);
                    }
                  }
                }, e.log.prepareStandard = function(e) {
                  "standard" in e || (e.standard = t[e.level].name + " [" + e.category + "] " + e.message);
                }, e.log.prepareFull = function(t) {
                  if (!("full" in t)) {
                    var n = [t.message];
                    n = n.concat([] || t.arguments), t.full = e.util.format.apply(this, n);
                  }
                }, e.log.prepareStandardFull = function(t) {
                  "standardFull" in t || (e.log.prepareStandard(t), t.standardFull = t.standard);
                };
                var o = ["error", "warning", "info", "debug", "verbose"];
                for (var i = 0; i < o.length; ++i)
                  (function(t) {
                    e.log[t] = function(n, r) {
                      var i = Array.prototype.slice.call(arguments).slice(2),
                          s = {
                            timestamp: new Date,
                            level: t,
                            category: n,
                            message: r,
                            arguments: i
                          };
                      e.log.logMessage(s);
                    };
                  })(o[i]);
                e.log.makeLogger = function(t) {
                  var n = {
                    flags: 0,
                    f: t
                  };
                  return e.log.setLevel(n, "none"), n;
                }, e.log.setLevel = function(t, n) {
                  var r = !1;
                  if (t && !(t.flags & e.log.LEVEL_LOCKED))
                    for (var i = 0; i < e.log.levels.length; ++i) {
                      var s = e.log.levels[i];
                      if (n == s) {
                        t.level = n, r = !0;
                        break;
                      }
                    }
                  return r;
                }, e.log.lock = function(t, n) {
                  typeof n == "undefined" || n ? t.flags |= e.log.LEVEL_LOCKED : t.flags &= ~e.log.LEVEL_LOCKED;
                }, e.log.addLogger = function(e) {
                  n.push(e);
                };
                if (typeof console != "undefined" && "log" in console) {
                  var u;
                  if (console.error && console.warn && console.info && console.debug) {
                    var a = {
                      error: console.error,
                      warning: console.warn,
                      info: console.info,
                      debug: console.debug,
                      verbose: console.debug
                    },
                        f = function(t, n) {
                          e.log.prepareStandard(n);
                          var r = a[n.level],
                              i = [n.standard];
                          i = i.concat(n.arguments.slice()), r.apply(console, i);
                        };
                    u = e.log.makeLogger(f);
                  } else {
                    var f = function(t, n) {
                      e.log.prepareStandardFull(n), console.log(n.standardFull);
                    };
                    u = e.log.makeLogger(f);
                  }
                  e.log.setLevel(u, "debug"), e.log.addLogger(u), r = u;
                } else
                  console = {log: function() {}};
                if (r !== null) {
                  var l = e.util.getQueryVariables();
                  "console.level" in l && e.log.setLevel(r, l["console.level"].slice(-1)[0]);
                  if ("console.lock" in l) {
                    var c = l["console.lock"].slice(-1)[0];
                    c == "true" && e.log.lock(r);
                  }
                }
                e.log.consoleLogger = r;
              }
              var r = "log";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/log", ["require", "module", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = e.asn1,
                    n = e.pkcs7 = e.pkcs7 || {};
                n.messageFromPem = function(r) {
                  var i = e.pem.decode(r)[0];
                  if (i.type !== "PKCS7")
                    throw {
                      message: 'Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".',
                      headerType: i.type
                    };
                  if (i.procType && i.procType.type === "ENCRYPTED")
                    throw {message: "Could not convert PKCS#7 message from PEM; PEM is encrypted."};
                  var s = t.fromDer(i.body);
                  return n.messageFromAsn1(s);
                }, n.messageToPem = function(n, r) {
                  var i = {
                    type: "PKCS7",
                    body: t.toDer(n.toAsn1()).getBytes()
                  };
                  return e.pem.encode(i, {maxline: r});
                }, n.messageFromAsn1 = function(r) {
                  var i = {},
                      s = [];
                  if (!t.validate(r, n.asn1.contentInfoValidator, i, s))
                    throw {
                      message: "Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.",
                      errors: s
                    };
                  var o = t.derToOid(i.contentType),
                      u;
                  switch (o) {
                    case e.pki.oids.envelopedData:
                      u = n.createEnvelopedData();
                      break;
                    case e.pki.oids.encryptedData:
                      u = n.createEncryptedData();
                      break;
                    case e.pki.oids.signedData:
                      u = n.createSignedData();
                      break;
                    default:
                      throw {message: "Cannot read PKCS#7 message. ContentType with OID " + o + " is not (yet) supported."};
                  }
                  return u.fromAsn1(i.content.value[0]), u;
                };
                var r = function(r) {
                  var i = {},
                      s = [];
                  if (!t.validate(r, n.asn1.recipientInfoValidator, i, s))
                    throw {
                      message: "Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 EnvelopedData.",
                      errors: s
                    };
                  return {
                    version: i.version.charCodeAt(0),
                    issuer: e.pki.RDNAttributesAsArray(i.issuer),
                    serialNumber: e.util.createBuffer(i.serial).toHex(),
                    encryptedContent: {
                      algorithm: t.derToOid(i.encAlgorithm),
                      parameter: i.encParameter.value,
                      content: i.encKey
                    }
                  };
                },
                    i = function(n) {
                      return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(n.version).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [e.pki.distinguishedNameToAsn1({attributes: n.issuer}), t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, e.util.hexToBytes(n.serialNumber))]), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.encryptedContent.algorithm).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.NULL, !1, "")]), t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, n.encryptedContent.content)]);
                    },
                    s = function(e) {
                      var t = [];
                      for (var n = 0; n < e.length; n++)
                        t.push(r(e[n]));
                      return t;
                    },
                    o = function(e) {
                      var t = [];
                      for (var n = 0; n < e.length; n++)
                        t.push(i(e[n]));
                      return t;
                    },
                    u = function(n) {
                      return [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(e.pki.oids.data).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(n.algorithm).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, n.parameter.getBytes())]), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, n.content.getBytes())])];
                    },
                    a = function(n, r, i) {
                      var s = {},
                          o = [];
                      if (!t.validate(r, i, s, o))
                        throw {
                          message: "Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.",
                          errors: o
                        };
                      var u = t.derToOid(s.contentType);
                      if (u !== e.pki.oids.data)
                        throw {message: "Unsupported PKCS#7 message. Only wrapped ContentType Data supported."};
                      if (s.encryptedContent) {
                        var a = "";
                        if (e.util.isArray(s.encryptedContent))
                          for (var f = 0; f < s.encryptedContent.length; ++f) {
                            if (s.encryptedContent[f].type !== t.Type.OCTETSTRING)
                              throw {message: "Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects."};
                            a += s.encryptedContent[f].value;
                          }
                        else
                          a = s.encryptedContent;
                        n.encryptedContent = {
                          algorithm: t.derToOid(s.encAlgorithm),
                          parameter: e.util.createBuffer(s.encParameter.value),
                          content: e.util.createBuffer(a)
                        };
                      }
                      if (s.content) {
                        var a = "";
                        if (e.util.isArray(s.content))
                          for (var f = 0; f < s.content.length; ++f) {
                            if (s.content[f].type !== t.Type.OCTETSTRING)
                              throw {message: "Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects."};
                            a += s.content[f].value;
                          }
                        else
                          a = s.content;
                        n.content = e.util.createBuffer(a);
                      }
                      return n.version = s.version.charCodeAt(0), n.rawCapture = s, s;
                    },
                    f = function(t) {
                      if (t.encryptedContent.key === undefined)
                        throw {message: "Symmetric key not available."};
                      if (t.content === undefined) {
                        var n;
                        switch (t.encryptedContent.algorithm) {
                          case e.pki.oids["aes128-CBC"]:
                          case e.pki.oids["aes192-CBC"]:
                          case e.pki.oids["aes256-CBC"]:
                            n = e.aes.createDecryptionCipher(t.encryptedContent.key);
                            break;
                          case e.pki.oids.desCBC:
                          case e.pki.oids["des-EDE3-CBC"]:
                            n = e.des.createDecryptionCipher(t.encryptedContent.key);
                            break;
                          default:
                            throw {message: "Unsupported symmetric cipher, OID " + t.encryptedContent.algorithm};
                        }
                        n.start(t.encryptedContent.parameter), n.update(t.encryptedContent.content);
                        if (!n.finish())
                          throw {message: "Symmetric decryption failed."};
                        t.content = n.output;
                      }
                    };
                n.createSignedData = function() {
                  var r = null;
                  return r = {
                    type: e.pki.oids.signedData,
                    version: 1,
                    certificates: [],
                    crls: [],
                    digestAlgorithmIdentifiers: [],
                    contentInfo: null,
                    signerInfos: [],
                    fromAsn1: function(t) {
                      a(r, t, n.asn1.signedDataValidator), r.certificates = [], r.crls = [], r.digestAlgorithmIdentifiers = [], r.contentInfo = null, r.signerInfos = [];
                      var i = r.rawCapture.certificates.value;
                      for (var s = 0; s < i.length; ++s)
                        r.certificates.push(e.pki.certificateFromAsn1(i[s]));
                    },
                    toAsn1: function() {
                      if ("content" in r)
                        throw "Signing PKCS#7 content not yet implemented.";
                      r.contentInfo || r.sign();
                      var n = [];
                      for (var i = 0; i < r.certificates.length; ++i)
                        n.push(e.pki.certificateToAsn1(r.certificates[0]));
                      var s = [];
                      return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(r.type).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(r.version).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, r.digestAlgorithmIdentifiers), r.contentInfo, t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, n), t.create(t.Class.CONTEXT_SPECIFIC, 1, !0, s), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, r.signerInfos)])])]);
                    },
                    sign: function(n) {
                      if ("content" in r)
                        throw "PKCS#7 signing not yet implemented.";
                      typeof r.content != "object" && (r.contentInfo = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(e.pki.oids.data).getBytes())]), "content" in r && r.contentInfo.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, !1, r.content)])));
                    },
                    verify: function() {
                      throw "PKCS#7 signature verification not yet implemented.";
                    },
                    addCertificate: function(t) {
                      typeof t == "string" && (t = e.pki.certificateFromPem(t)), r.certificates.push(t);
                    },
                    addCertificateRevokationList: function(e) {
                      throw "PKCS#7 CRL support not yet implemented.";
                    }
                  }, r;
                }, n.createEncryptedData = function() {
                  var t = null;
                  return t = {
                    type: e.pki.oids.encryptedData,
                    version: 0,
                    encryptedContent: {algorithm: e.pki.oids["aes256-CBC"]},
                    fromAsn1: function(e) {
                      a(t, e, n.asn1.encryptedDataValidator);
                    },
                    decrypt: function(e) {
                      e !== undefined && (t.encryptedContent.key = e), f(t);
                    }
                  }, t;
                }, n.createEnvelopedData = function() {
                  var r = null;
                  return r = {
                    type: e.pki.oids.envelopedData,
                    version: 0,
                    recipients: [],
                    encryptedContent: {algorithm: e.pki.oids["aes256-CBC"]},
                    fromAsn1: function(e) {
                      var t = a(r, e, n.asn1.envelopedDataValidator);
                      r.recipients = s(t.recipientInfos.value);
                    },
                    toAsn1: function() {
                      return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.OID, !1, t.oidToDer(r.type).getBytes()), t.create(t.Class.CONTEXT_SPECIFIC, 0, !0, [t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, [t.create(t.Class.UNIVERSAL, t.Type.INTEGER, !1, t.integerToDer(r.version).getBytes()), t.create(t.Class.UNIVERSAL, t.Type.SET, !0, o(r.recipients)), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, !0, u(r.encryptedContent))])])]);
                    },
                    findRecipient: function(e) {
                      var t = e.issuer.attributes;
                      for (var n = 0; n < r.recipients.length; ++n) {
                        var i = r.recipients[n],
                            s = i.issuer;
                        if (i.serialNumber !== e.serialNumber)
                          continue;
                        if (s.length !== t.length)
                          continue;
                        var o = !0;
                        for (var u = 0; u < t.length; ++u)
                          if (s[u].type !== t[u].type || s[u].value !== t[u].value) {
                            o = !1;
                            break;
                          }
                        if (o)
                          return i;
                      }
                      return null;
                    },
                    decrypt: function(t, n) {
                      if (r.encryptedContent.key === undefined && t !== undefined && n !== undefined)
                        switch (t.encryptedContent.algorithm) {
                          case e.pki.oids.rsaEncryption:
                          case e.pki.oids.desCBC:
                            var i = n.decrypt(t.encryptedContent.content);
                            r.encryptedContent.key = e.util.createBuffer(i);
                            break;
                          default:
                            throw {message: "Unsupported asymmetric cipher, OID " + t.encryptedContent.algorithm};
                        }
                      f(r);
                    },
                    addRecipient: function(t) {
                      r.recipients.push({
                        version: 0,
                        issuer: t.subject.attributes,
                        serialNumber: t.serialNumber,
                        encryptedContent: {
                          algorithm: e.pki.oids.rsaEncryption,
                          key: t.publicKey
                        }
                      });
                    },
                    encrypt: function(t, n) {
                      if (r.encryptedContent.content === undefined) {
                        n = n || r.encryptedContent.algorithm, t = t || r.encryptedContent.key;
                        var i,
                            s,
                            o;
                        switch (n) {
                          case e.pki.oids["aes128-CBC"]:
                            i = 16, s = 16, o = e.aes.createEncryptionCipher;
                            break;
                          case e.pki.oids["aes192-CBC"]:
                            i = 24, s = 16, o = e.aes.createEncryptionCipher;
                            break;
                          case e.pki.oids["aes256-CBC"]:
                            i = 32, s = 16, o = e.aes.createEncryptionCipher;
                            break;
                          case e.pki.oids["des-EDE3-CBC"]:
                            i = 24, s = 8, o = e.des.createEncryptionCipher;
                            break;
                          default:
                            throw {message: "Unsupported symmetric cipher, OID " + n};
                        }
                        if (t === undefined)
                          t = e.util.createBuffer(e.random.getBytes(i));
                        else if (t.length() != i)
                          throw {message: "Symmetric key has wrong length, got " + t.length() + " bytes, expected " + i};
                        r.encryptedContent.algorithm = n, r.encryptedContent.key = t, r.encryptedContent.parameter = e.util.createBuffer(e.random.getBytes(s));
                        var u = o(t);
                        u.start(r.encryptedContent.parameter.copy()), u.update(r.content);
                        if (!u.finish())
                          throw {message: "Symmetric encryption failed."};
                        r.encryptedContent.content = u.output;
                      }
                      for (var a = 0; a < r.recipients.length; a++) {
                        var f = r.recipients[a];
                        if (f.encryptedContent.content !== undefined)
                          continue;
                        switch (f.encryptedContent.algorithm) {
                          case e.pki.oids.rsaEncryption:
                            f.encryptedContent.content = f.encryptedContent.key.encrypt(r.encryptedContent.key.data);
                            break;
                          default:
                            throw {message: "Unsupported asymmetric cipher, OID " + f.encryptedContent.algorithm};
                        }
                      }
                    }
                  }, r;
                };
              }
              var r = "pkcs7";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/pkcs7", ["require", "module", "./aes", "./asn1", "./des", "./oids", "./pem", "./pkcs7asn1", "./random", "./util", "./x509"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              function e(e) {
                var t = "forge.task",
                    n = 0,
                    r = {},
                    i = 0;
                e.debug.set(t, "tasks", r);
                var s = {};
                e.debug.set(t, "queues", s);
                var o = "?",
                    u = 30,
                    a = 20,
                    f = "ready",
                    l = "running",
                    c = "blocked",
                    h = "sleeping",
                    p = "done",
                    d = "error",
                    v = "stop",
                    m = "start",
                    g = "block",
                    y = "unblock",
                    b = "sleep",
                    w = "wakeup",
                    E = "cancel",
                    S = "fail",
                    x = {};
                x[f] = {}, x[f][v] = f, x[f][m] = l, x[f][E] = p, x[f][S] = d, x[l] = {}, x[l][v] = f, x[l][m] = l, x[l][g] = c, x[l][y] = l, x[l][b] = h, x[l][w] = l, x[l][E] = p, x[l][S] = d, x[c] = {}, x[c][v] = c, x[c][m] = c, x[c][g] = c, x[c][y] = c, x[c][b] = c, x[c][w] = c, x[c][E] = p, x[c][S] = d, x[h] = {}, x[h][v] = h, x[h][m] = h, x[h][g] = h, x[h][y] = h, x[h][b] = h, x[h][w] = h, x[h][E] = p, x[h][S] = d, x[p] = {}, x[p][v] = p, x[p][m] = p, x[p][g] = p, x[p][y] = p, x[p][b] = p, x[p][w] = p, x[p][E] = p, x[p][S] = d, x[d] = {}, x[d][v] = d, x[d][m] = d, x[d][g] = d, x[d][y] = d, x[d][b] = d, x[d][w] = d, x[d][E] = d, x[d][S] = d;
                var T = function(s) {
                  this.id = -1, this.name = s.name || o, this.parent = s.parent || null, this.run = s.run, this.subtasks = [], this.error = !1, this.state = f, this.blocks = 0, this.timeoutId = null, this.swapTime = null, this.userData = null, this.id = i++, r[this.id] = this, n >= 1 && e.log.verbose(t, "[%s][%s] init", this.id, this.name, this);
                };
                T.prototype.debug = function(n) {
                  n = n || "", e.log.debug(t, n, "[%s][%s] task:", this.id, this.name, this, "subtasks:", this.subtasks.length, "queue:", s);
                }, T.prototype.next = function(e, t) {
                  typeof e == "function" && (t = e, e = this.name);
                  var n = new T({
                    run: t,
                    name: e,
                    parent: this
                  });
                  return n.state = l, n.type = this.type, n.successCallback = this.successCallback || null, n.failureCallback = this.failureCallback || null, this.subtasks.push(n), this;
                }, T.prototype.parallel = function(t, n) {
                  return e.util.isArray(t) && (n = t, t = this.name), this.next(t, function(r) {
                    var i = r;
                    i.block(n.length);
                    var s = function(t, r) {
                      e.task.start({
                        type: t,
                        run: function(e) {
                          n[r](e);
                        },
                        success: function(e) {
                          i.unblock();
                        },
                        failure: function(e) {
                          i.unblock();
                        }
                      });
                    };
                    for (var o = 0; o < n.length; o++) {
                      var u = t + "__parallel-" + r.id + "-" + o,
                          a = o;
                      s(u, a);
                    }
                  });
                }, T.prototype.stop = function() {
                  this.state = x[this.state][v];
                }, T.prototype.start = function() {
                  this.error = !1, this.state = x[this.state][m], this.state === l && (this.start = new Date, this.run(this), C(this, 0));
                }, T.prototype.block = function(e) {
                  e = typeof e == "undefined" ? 1 : e, this.blocks += e, this.blocks > 0 && (this.state = x[this.state][g]);
                }, T.prototype.unblock = function(e) {
                  return e = typeof e == "undefined" ? 1 : e, this.blocks -= e, this.blocks === 0 && this.state !== p && (this.state = l, C(this, 0)), this.blocks;
                }, T.prototype.sleep = function(e) {
                  e = typeof e == "undefined" ? 0 : e, this.state = x[this.state][b];
                  var t = this;
                  this.timeoutId = setTimeout(function() {
                    t.timeoutId = null, t.state = l, C(t, 0);
                  }, e);
                }, T.prototype.wait = function(e) {
                  e.wait(this);
                }, T.prototype.wakeup = function() {
                  this.state === h && (cancelTimeout(this.timeoutId), this.timeoutId = null, this.state = l, C(this, 0));
                }, T.prototype.cancel = function() {
                  this.state = x[this.state][E], this.permitsNeeded = 0, this.timeoutId !== null && (cancelTimeout(this.timeoutId), this.timeoutId = null), this.subtasks = [];
                }, T.prototype.fail = function(e) {
                  this.error = !0, k(this, !0);
                  if (e)
                    e.error = this.error, e.swapTime = this.swapTime, e.userData = this.userData, C(e, 0);
                  else {
                    if (this.parent !== null) {
                      var t = this.parent;
                      while (t.parent !== null)
                        t.error = this.error, t.swapTime = this.swapTime, t.userData = this.userData, t = t.parent;
                      k(t, !0);
                    }
                    this.failureCallback && this.failureCallback(this);
                  }
                };
                var N = function(e) {
                  e.error = !1, e.state = x[e.state][m], setTimeout(function() {
                    e.state === l && (e.swapTime = +(new Date), e.run(e), C(e, 0));
                  }, 0);
                },
                    C = function(e, t) {
                      var n = t > u || +(new Date) - e.swapTime > a,
                          r = function(t) {
                            t++;
                            if (e.state === l) {
                              n && (e.swapTime = +(new Date));
                              if (e.subtasks.length > 0) {
                                var r = e.subtasks.shift();
                                r.error = e.error, r.swapTime = e.swapTime, r.userData = e.userData, r.run(r), r.error || C(r, t);
                              } else
                                k(e), e.error || e.parent !== null && (e.parent.error = e.error, e.parent.swapTime = e.swapTime, e.parent.userData = e.userData, C(e.parent, t));
                            }
                          };
                      n ? setTimeout(r, 0) : r(t);
                    },
                    k = function(i, o) {
                      i.state = p, delete r[i.id], n >= 1 && e.log.verbose(t, "[%s][%s] finish", i.id, i.name, i), i.parent === null && (i.type in s ? s[i.type].length === 0 ? e.log.error(t, "[%s][%s] task queue empty [%s]", i.id, i.name, i.type) : s[i.type][0] !== i ? e.log.error(t, "[%s][%s] task not first in queue [%s]", i.id, i.name, i.type) : (s[i.type].shift(), s[i.type].length === 0 ? (n >= 1 && e.log.verbose(t, "[%s][%s] delete queue [%s]", i.id, i.name, i.type), delete s[i.type]) : (n >= 1 && e.log.verbose(t, "[%s][%s] queue start next [%s] remain:%s", i.id, i.name, i.type, s[i.type].length), s[i.type][0].start())) : e.log.error(t, "[%s][%s] task queue missing [%s]", i.id, i.name, i.type), o || (i.error && i.failureCallback ? i.failureCallback(i) : !i.error && i.successCallback && i.successCallback(i)));
                    };
                e.task = e.task || {}, e.task.start = function(r) {
                  var i = new T({
                    run: r.run,
                    name: r.name || o
                  });
                  i.type = r.type, i.successCallback = r.success || null, i.failureCallback = r.failure || null, i.type in s ? s[r.type].push(i) : (n >= 1 && e.log.verbose(t, "[%s][%s] create queue [%s]", i.id, i.name, i.type), s[i.type] = [i], N(i));
                }, e.task.cancel = function(e) {
                  e in s && (s[e] = [s[e][0]]);
                }, e.task.createCondition = function() {
                  var e = {tasks: {}};
                  return e.wait = function(t) {
                    t.id in e.tasks || (t.block(), e.tasks[t.id] = t);
                  }, e.notify = function() {
                    var t = e.tasks;
                    e.tasks = {};
                    for (var n in t)
                      t[n].unblock();
                  }, e;
                };
              }
              var r = "task";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports)
                  return typeof forge == "undefined" && (forge = {}), e(forge);
                var i = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var s,
                  o = function(t, n) {
                    n.exports = function(n) {
                      var i = s.map(function(e) {
                        return t(e);
                      }).concat(e);
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[r])
                        return n[r];
                      n.defined[r] = !0;
                      for (var o = 0; o < i.length; ++o)
                        i[o](n);
                      return n[r];
                    };
                  },
                  u = n;
              n = function(e, t) {
                return s = typeof e == "string" ? t.slice(2) : e.slice(2), i ? (delete n, u.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = u, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/task", ["require", "module", "./debug", "./log", "./util"], function() {
                o.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), function() {
              var e = "forge";
              if (typeof n != "function") {
                if (typeof module != "object" || !module.exports) {
                  typeof forge == "undefined" && (forge = {disableNativeCode: !1});
                  return;
                }
                var r = !0;
                n = function(e, n) {
                  n(t, module);
                };
              }
              var i,
                  s = function(t, n) {
                    n.exports = function(n) {
                      var r = i.map(function(e) {
                        return t(e);
                      });
                      n = n || {}, n.defined = n.defined || {};
                      if (n.defined[e])
                        return n[e];
                      n.defined[e] = !0;
                      for (var s = 0; s < r.length; ++s)
                        r[s](n);
                      return n;
                    }, n.exports.disableNativeCode = !1, n.exports(n.exports);
                  },
                  o = n;
              n = function(e, t) {
                return i = typeof e == "string" ? t.slice(2) : e.slice(2), r ? (delete n, o.apply(null, Array.prototype.slice.call(arguments, 0))) : (n = o, n.apply(null, Array.prototype.slice.call(arguments, 0)));
              }, n("js/forge", ["require", "module", "./aes", "./aesCipherSuites", "./asn1", "./debug", "./des", "./hmac", "./log", "./pbkdf2", "./pem", "./pkcs7", "./pkcs1", "./pkcs12", "./pki", "./prng", "./pss", "./random", "./rc2", "./task", "./tls", "./util", "./md", "./mgf1"], function() {
                s.apply(null, Array.prototype.slice.call(arguments, 0));
              });
            }(), window.forge = t("js/forge");
          })();
        }).call(this, require("sycGbZ"));
      }, {"sycGbZ": 51}],
      6: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var BigInteger = require("jsbn");
          var ECPointFp = require("./lib/ec.js").ECPointFp;
          exports.ECCurves = require("./lib/sec.js");
          function unstupid(hex, len) {
            return (hex.length >= len) ? hex : unstupid("0" + hex, len);
          }
          exports.ECKey = function(curve, key, isPublic) {
            var priv;
            var c = curve();
            var n = c.getN();
            var bytes = Math.floor(n.bitLength() / 8);
            if (key) {
              if (isPublic) {
                if (key.length != bytes * 2 + 1)
                  return false;
                var curve = c.getCurve();
                var x = key.slice(1, bytes + 1);
                var y = key.slice(bytes + 1);
                this.P = new ECPointFp(curve, curve.fromBigInteger(new BigInteger(x.toString("hex"), 16)), curve.fromBigInteger(new BigInteger(y.toString("hex"), 16)));
              } else {
                if (key.length != bytes)
                  return false;
                priv = new BigInteger(key.toString("hex"), 16);
              }
            } else {
              var n1 = n.subtract(BigInteger.ONE);
              var r = new BigInteger(crypto.randomBytes(n.bitLength()));
              priv = r.mod(n1).add(BigInteger.ONE);
              this.P = c.getG().multiply(priv);
            }
            if (this.P) {
              var pubhex = unstupid(this.P.getX().toBigInteger().toString(16), bytes * 2) + unstupid(this.P.getY().toBigInteger().toString(16), bytes * 2);
              this.PublicKey = new Buffer("04" + pubhex, "hex");
            }
            if (priv) {
              this.PrivateKey = new Buffer(unstupid(priv.toString(16), bytes * 2), "hex");
              this.deriveSharedSecret = function(key) {
                if (!key || !key.P)
                  return false;
                var S = key.P.multiply(priv);
                return new Buffer(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
              };
            }
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "./lib/ec.js": 7,
        "./lib/sec.js": 8,
        "buffer": 29,
        "crypto": 35,
        "jsbn": 9
      }],
      7: [function(require, module, exports) {
        var BigInteger = require('jsbn');
        var Barrett = BigInteger.prototype.Barrett;
        function ECFieldElementFp(q, x) {
          this.x = x;
          this.q = q;
        }
        function feFpEquals(other) {
          if (other == this)
            return true;
          return (this.q.equals(other.q) && this.x.equals(other.x));
        }
        function feFpToBigInteger() {
          return this.x;
        }
        function feFpNegate() {
          return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
        }
        function feFpAdd(b) {
          return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
        }
        function feFpSubtract(b) {
          return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
        }
        function feFpMultiply(b) {
          return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
        }
        function feFpSquare() {
          return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
        }
        function feFpDivide(b) {
          return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
        }
        ECFieldElementFp.prototype.equals = feFpEquals;
        ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
        ECFieldElementFp.prototype.negate = feFpNegate;
        ECFieldElementFp.prototype.add = feFpAdd;
        ECFieldElementFp.prototype.subtract = feFpSubtract;
        ECFieldElementFp.prototype.multiply = feFpMultiply;
        ECFieldElementFp.prototype.square = feFpSquare;
        ECFieldElementFp.prototype.divide = feFpDivide;
        function ECPointFp(curve, x, y, z) {
          this.curve = curve;
          this.x = x;
          this.y = y;
          if (z == null) {
            this.z = BigInteger.ONE;
          } else {
            this.z = z;
          }
          this.zinv = null;
        }
        function pointFpGetX() {
          if (this.zinv == null) {
            this.zinv = this.z.modInverse(this.curve.q);
          }
          var r = this.x.toBigInteger().multiply(this.zinv);
          this.curve.reduce(r);
          return this.curve.fromBigInteger(r);
        }
        function pointFpGetY() {
          if (this.zinv == null) {
            this.zinv = this.z.modInverse(this.curve.q);
          }
          var r = this.y.toBigInteger().multiply(this.zinv);
          this.curve.reduce(r);
          return this.curve.fromBigInteger(r);
        }
        function pointFpEquals(other) {
          if (other == this)
            return true;
          if (this.isInfinity())
            return other.isInfinity();
          if (other.isInfinity())
            return this.isInfinity();
          var u,
              v;
          u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
          if (!u.equals(BigInteger.ZERO))
            return false;
          v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
          return v.equals(BigInteger.ZERO);
        }
        function pointFpIsInfinity() {
          if ((this.x == null) && (this.y == null))
            return true;
          return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
        }
        function pointFpNegate() {
          return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
        }
        function pointFpAdd(b) {
          if (this.isInfinity())
            return b;
          if (b.isInfinity())
            return this;
          var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
          var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
          if (BigInteger.ZERO.equals(v)) {
            if (BigInteger.ZERO.equals(u)) {
              return this.twice();
            }
            return this.curve.getInfinity();
          }
          var THREE = new BigInteger("3");
          var x1 = this.x.toBigInteger();
          var y1 = this.y.toBigInteger();
          var x2 = b.x.toBigInteger();
          var y2 = b.y.toBigInteger();
          var v2 = v.square();
          var v3 = v2.multiply(v);
          var x1v2 = x1.multiply(v2);
          var zu2 = u.square().multiply(this.z);
          var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
          var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
          var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
          return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
        }
        function pointFpTwice() {
          if (this.isInfinity())
            return this;
          if (this.y.toBigInteger().signum() == 0)
            return this.curve.getInfinity();
          var THREE = new BigInteger("3");
          var x1 = this.x.toBigInteger();
          var y1 = this.y.toBigInteger();
          var y1z1 = y1.multiply(this.z);
          var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
          var a = this.curve.a.toBigInteger();
          var w = x1.square().multiply(THREE);
          if (!BigInteger.ZERO.equals(a)) {
            w = w.add(this.z.square().multiply(a));
          }
          w = w.mod(this.curve.q);
          var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
          var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
          var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
          return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
        }
        function pointFpMultiply(k) {
          if (this.isInfinity())
            return this;
          if (k.signum() == 0)
            return this.curve.getInfinity();
          var e = k;
          var h = e.multiply(new BigInteger("3"));
          var neg = this.negate();
          var R = this;
          var i;
          for (i = h.bitLength() - 2; i > 0; --i) {
            R = R.twice();
            var hBit = h.testBit(i);
            var eBit = e.testBit(i);
            if (hBit != eBit) {
              R = R.add(hBit ? this : neg);
            }
          }
          return R;
        }
        function pointFpMultiplyTwo(j, x, k) {
          var i;
          if (j.bitLength() > k.bitLength())
            i = j.bitLength() - 1;
          else
            i = k.bitLength() - 1;
          var R = this.curve.getInfinity();
          var both = this.add(x);
          while (i >= 0) {
            R = R.twice();
            if (j.testBit(i)) {
              if (k.testBit(i)) {
                R = R.add(both);
              } else {
                R = R.add(this);
              }
            } else {
              if (k.testBit(i)) {
                R = R.add(x);
              }
            }
            --i;
          }
          return R;
        }
        ECPointFp.prototype.getX = pointFpGetX;
        ECPointFp.prototype.getY = pointFpGetY;
        ECPointFp.prototype.equals = pointFpEquals;
        ECPointFp.prototype.isInfinity = pointFpIsInfinity;
        ECPointFp.prototype.negate = pointFpNegate;
        ECPointFp.prototype.add = pointFpAdd;
        ECPointFp.prototype.twice = pointFpTwice;
        ECPointFp.prototype.multiply = pointFpMultiply;
        ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
        function ECCurveFp(q, a, b) {
          this.q = q;
          this.a = this.fromBigInteger(a);
          this.b = this.fromBigInteger(b);
          this.infinity = new ECPointFp(this, null, null);
          this.reducer = new Barrett(this.q);
        }
        function curveFpGetQ() {
          return this.q;
        }
        function curveFpGetA() {
          return this.a;
        }
        function curveFpGetB() {
          return this.b;
        }
        function curveFpEquals(other) {
          if (other == this)
            return true;
          return (this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
        }
        function curveFpGetInfinity() {
          return this.infinity;
        }
        function curveFpFromBigInteger(x) {
          return new ECFieldElementFp(this.q, x);
        }
        function curveReduce(x) {
          this.reducer.reduce(x);
        }
        function curveFpDecodePointHex(s) {
          switch (parseInt(s.substr(0, 2), 16)) {
            case 0:
              return this.infinity;
            case 2:
            case 3:
              return null;
            case 4:
            case 6:
            case 7:
              var len = (s.length - 2) / 2;
              var xHex = s.substr(2, len);
              var yHex = s.substr(len + 2, len);
              return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));
            default:
              return null;
          }
        }
        function curveFpEncodePointHex(p) {
          if (p.isInfinity())
            return "00";
          var xHex = p.getX().toBigInteger().toString(16);
          var yHex = p.getY().toBigInteger().toString(16);
          var oLen = this.getQ().toString(16).length;
          if ((oLen % 2) != 0)
            oLen++;
          while (xHex.length < oLen) {
            xHex = "0" + xHex;
          }
          while (yHex.length < oLen) {
            yHex = "0" + yHex;
          }
          return "04" + xHex + yHex;
        }
        ECCurveFp.prototype.getQ = curveFpGetQ;
        ECCurveFp.prototype.getA = curveFpGetA;
        ECCurveFp.prototype.getB = curveFpGetB;
        ECCurveFp.prototype.equals = curveFpEquals;
        ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
        ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
        ECCurveFp.prototype.reduce = curveReduce;
        ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
        ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
        var exports = {
          ECCurveFp: ECCurveFp,
          ECPointFp: ECPointFp,
          ECFieldElementFp: ECFieldElementFp
        };
        module.exports = exports;
      }, {"jsbn": 9}],
      8: [function(require, module, exports) {
        var BigInteger = require('jsbn');
        var ECCurveFp = require('./ec.js').ECCurveFp;
        function X9ECParameters(curve, g, n, h) {
          this.curve = curve;
          this.g = g;
          this.n = n;
          this.h = h;
        }
        function x9getCurve() {
          return this.curve;
        }
        function x9getG() {
          return this.g;
        }
        function x9getN() {
          return this.n;
        }
        function x9getH() {
          return this.h;
        }
        X9ECParameters.prototype.getCurve = x9getCurve;
        X9ECParameters.prototype.getG = x9getG;
        X9ECParameters.prototype.getN = x9getN;
        X9ECParameters.prototype.getH = x9getH;
        function fromHex(s) {
          return new BigInteger(s, 16);
        }
        function secp128r1() {
          var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
          var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
          var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "161FF7528B899B2D0C28607CA52C5B86" + "CF5AC8395BAFEB13C02DA292DDED7A83");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp160k1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
          var a = BigInteger.ZERO;
          var b = fromHex("7");
          var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB" + "938CF935318FDCED6BC28286531733C3F03C4FEE");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp160r1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
          var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
          var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "4A96B5688EF573284664698968C38BB913CBFC82" + "23A628553168947D59DCC912042351377AC5FB32");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp192k1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
          var a = BigInteger.ZERO;
          var b = fromHex("3");
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D" + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp192r1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
          var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012" + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp224r1() {
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
          var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21" + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
          return new X9ECParameters(curve, G, n, h);
        }
        function secp256r1() {
          var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
          var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
          var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04" + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296" + "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
          return new X9ECParameters(curve, G, n, h);
        }
        function getSECCurveByName(name) {
          if (name == "secp128r1")
            return secp128r1();
          if (name == "secp160k1")
            return secp160k1();
          if (name == "secp160r1")
            return secp160r1();
          if (name == "secp192k1")
            return secp192k1();
          if (name == "secp192r1")
            return secp192r1();
          if (name == "secp224r1")
            return secp224r1();
          if (name == "secp256r1")
            return secp256r1();
          return null;
        }
        module.exports = {
          "secp128r1": secp128r1,
          "secp160k1": secp160k1,
          "secp160r1": secp160r1,
          "secp192k1": secp192k1,
          "secp192r1": secp192r1,
          "secp224r1": secp224r1,
          "secp256r1": secp256r1
        };
      }, {
        "./ec.js": 7,
        "jsbn": 9
      }],
      9: [function(require, module, exports) {
        (function() {
          var dbits;
          var canary = 0xdeadbeefcafe;
          var j_lm = ((canary & 0xffffff) == 0xefcafe);
          function BigInteger(a, b, c) {
            if (a != null)
              if ("number" == typeof a)
                this.fromNumber(a, b, c);
              else if (b == null && "string" != typeof a)
                this.fromString(a, 256);
              else
                this.fromString(a, b);
          }
          function nbi() {
            return new BigInteger(null);
          }
          function am1(i, x, w, j, c, n) {
            while (--n >= 0) {
              var v = x * this[i++] + w[j] + c;
              c = Math.floor(v / 0x4000000);
              w[j++] = v & 0x3ffffff;
            }
            return c;
          }
          function am2(i, x, w, j, c, n) {
            var xl = x & 0x7fff,
                xh = x >> 15;
            while (--n >= 0) {
              var l = this[i] & 0x7fff;
              var h = this[i++] >> 15;
              var m = xh * l + h * xl;
              l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
              c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
              w[j++] = l & 0x3fffffff;
            }
            return c;
          }
          function am3(i, x, w, j, c, n) {
            var xl = x & 0x3fff,
                xh = x >> 14;
            while (--n >= 0) {
              var l = this[i] & 0x3fff;
              var h = this[i++] >> 14;
              var m = xh * l + h * xl;
              l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
              c = (l >> 28) + (m >> 14) + xh * h;
              w[j++] = l & 0xfffffff;
            }
            return c;
          }
          var inBrowser = typeof navigator !== "undefined";
          if (inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
            BigInteger.prototype.am = am2;
            dbits = 30;
          } else if (inBrowser && j_lm && (navigator.appName != "Netscape")) {
            BigInteger.prototype.am = am1;
            dbits = 26;
          } else {
            BigInteger.prototype.am = am3;
            dbits = 28;
          }
          BigInteger.prototype.DB = dbits;
          BigInteger.prototype.DM = ((1 << dbits) - 1);
          BigInteger.prototype.DV = (1 << dbits);
          var BI_FP = 52;
          BigInteger.prototype.FV = Math.pow(2, BI_FP);
          BigInteger.prototype.F1 = BI_FP - dbits;
          BigInteger.prototype.F2 = 2 * dbits - BI_FP;
          var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
          var BI_RC = new Array();
          var rr,
              vv;
          rr = "0".charCodeAt(0);
          for (vv = 0; vv <= 9; ++vv)
            BI_RC[rr++] = vv;
          rr = "a".charCodeAt(0);
          for (vv = 10; vv < 36; ++vv)
            BI_RC[rr++] = vv;
          rr = "A".charCodeAt(0);
          for (vv = 10; vv < 36; ++vv)
            BI_RC[rr++] = vv;
          function int2char(n) {
            return BI_RM.charAt(n);
          }
          function intAt(s, i) {
            var c = BI_RC[s.charCodeAt(i)];
            return (c == null) ? -1 : c;
          }
          function bnpCopyTo(r) {
            for (var i = this.t - 1; i >= 0; --i)
              r[i] = this[i];
            r.t = this.t;
            r.s = this.s;
          }
          function bnpFromInt(x) {
            this.t = 1;
            this.s = (x < 0) ? -1 : 0;
            if (x > 0)
              this[0] = x;
            else if (x < -1)
              this[0] = x + DV;
            else
              this.t = 0;
          }
          function nbv(i) {
            var r = nbi();
            r.fromInt(i);
            return r;
          }
          function bnpFromString(s, b) {
            var k;
            if (b == 16)
              k = 4;
            else if (b == 8)
              k = 3;
            else if (b == 256)
              k = 8;
            else if (b == 2)
              k = 1;
            else if (b == 32)
              k = 5;
            else if (b == 4)
              k = 2;
            else {
              this.fromRadix(s, b);
              return;
            }
            this.t = 0;
            this.s = 0;
            var i = s.length,
                mi = false,
                sh = 0;
            while (--i >= 0) {
              var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
              if (x < 0) {
                if (s.charAt(i) == "-")
                  mi = true;
                continue;
              }
              mi = false;
              if (sh == 0)
                this[this.t++] = x;
              else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
              } else
                this[this.t - 1] |= x << sh;
              sh += k;
              if (sh >= this.DB)
                sh -= this.DB;
            }
            if (k == 8 && (s[0] & 0x80) != 0) {
              this.s = -1;
              if (sh > 0)
                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
            this.clamp();
            if (mi)
              BigInteger.ZERO.subTo(this, this);
          }
          function bnpClamp() {
            var c = this.s & this.DM;
            while (this.t > 0 && this[this.t - 1] == c)
              --this.t;
          }
          function bnToString(b) {
            if (this.s < 0)
              return "-" + this.negate().toString(b);
            var k;
            if (b == 16)
              k = 4;
            else if (b == 8)
              k = 3;
            else if (b == 2)
              k = 1;
            else if (b == 32)
              k = 5;
            else if (b == 4)
              k = 2;
            else
              return this.toRadix(b);
            var km = (1 << k) - 1,
                d,
                m = false,
                r = "",
                i = this.t;
            var p = this.DB - (i * this.DB) % k;
            if (i-- > 0) {
              if (p < this.DB && (d = this[i] >> p) > 0) {
                m = true;
                r = int2char(d);
              }
              while (i >= 0) {
                if (p < k) {
                  d = (this[i] & ((1 << p) - 1)) << (k - p);
                  d |= this[--i] >> (p += this.DB - k);
                } else {
                  d = (this[i] >> (p -= k)) & km;
                  if (p <= 0) {
                    p += this.DB;
                    --i;
                  }
                }
                if (d > 0)
                  m = true;
                if (m)
                  r += int2char(d);
              }
            }
            return m ? r : "0";
          }
          function bnNegate() {
            var r = nbi();
            BigInteger.ZERO.subTo(this, r);
            return r;
          }
          function bnAbs() {
            return (this.s < 0) ? this.negate() : this;
          }
          function bnCompareTo(a) {
            var r = this.s - a.s;
            if (r != 0)
              return r;
            var i = this.t;
            r = i - a.t;
            if (r != 0)
              return (this.s < 0) ? -r : r;
            while (--i >= 0)
              if ((r = this[i] - a[i]) != 0)
                return r;
            return 0;
          }
          function nbits(x) {
            var r = 1,
                t;
            if ((t = x >>> 16) != 0) {
              x = t;
              r += 16;
            }
            if ((t = x >> 8) != 0) {
              x = t;
              r += 8;
            }
            if ((t = x >> 4) != 0) {
              x = t;
              r += 4;
            }
            if ((t = x >> 2) != 0) {
              x = t;
              r += 2;
            }
            if ((t = x >> 1) != 0) {
              x = t;
              r += 1;
            }
            return r;
          }
          function bnBitLength() {
            if (this.t <= 0)
              return 0;
            return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
          }
          function bnpDLShiftTo(n, r) {
            var i;
            for (i = this.t - 1; i >= 0; --i)
              r[i + n] = this[i];
            for (i = n - 1; i >= 0; --i)
              r[i] = 0;
            r.t = this.t + n;
            r.s = this.s;
          }
          function bnpDRShiftTo(n, r) {
            for (var i = n; i < this.t; ++i)
              r[i - n] = this[i];
            r.t = Math.max(this.t - n, 0);
            r.s = this.s;
          }
          function bnpLShiftTo(n, r) {
            var bs = n % this.DB;
            var cbs = this.DB - bs;
            var bm = (1 << cbs) - 1;
            var ds = Math.floor(n / this.DB),
                c = (this.s << bs) & this.DM,
                i;
            for (i = this.t - 1; i >= 0; --i) {
              r[i + ds + 1] = (this[i] >> cbs) | c;
              c = (this[i] & bm) << bs;
            }
            for (i = ds - 1; i >= 0; --i)
              r[i] = 0;
            r[ds] = c;
            r.t = this.t + ds + 1;
            r.s = this.s;
            r.clamp();
          }
          function bnpRShiftTo(n, r) {
            r.s = this.s;
            var ds = Math.floor(n / this.DB);
            if (ds >= this.t) {
              r.t = 0;
              return;
            }
            var bs = n % this.DB;
            var cbs = this.DB - bs;
            var bm = (1 << bs) - 1;
            r[0] = this[ds] >> bs;
            for (var i = ds + 1; i < this.t; ++i) {
              r[i - ds - 1] |= (this[i] & bm) << cbs;
              r[i - ds] = this[i] >> bs;
            }
            if (bs > 0)
              r[this.t - ds - 1] |= (this.s & bm) << cbs;
            r.t = this.t - ds;
            r.clamp();
          }
          function bnpSubTo(a, r) {
            var i = 0,
                c = 0,
                m = Math.min(a.t, this.t);
            while (i < m) {
              c += this[i] - a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            if (a.t < this.t) {
              c -= a.s;
              while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += this.s;
            } else {
              c += this.s;
              while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
              }
              c -= a.s;
            }
            r.s = (c < 0) ? -1 : 0;
            if (c < -1)
              r[i++] = this.DV + c;
            else if (c > 0)
              r[i++] = c;
            r.t = i;
            r.clamp();
          }
          function bnpMultiplyTo(a, r) {
            var x = this.abs(),
                y = a.abs();
            var i = x.t;
            r.t = i + y.t;
            while (--i >= 0)
              r[i] = 0;
            for (i = 0; i < y.t; ++i)
              r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
            r.s = 0;
            r.clamp();
            if (this.s != a.s)
              BigInteger.ZERO.subTo(r, r);
          }
          function bnpSquareTo(r) {
            var x = this.abs();
            var i = r.t = 2 * x.t;
            while (--i >= 0)
              r[i] = 0;
            for (i = 0; i < x.t - 1; ++i) {
              var c = x.am(i, x[i], r, 2 * i, 0, 1);
              if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
              }
            }
            if (r.t > 0)
              r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
            r.s = 0;
            r.clamp();
          }
          function bnpDivRemTo(m, q, r) {
            var pm = m.abs();
            if (pm.t <= 0)
              return;
            var pt = this.abs();
            if (pt.t < pm.t) {
              if (q != null)
                q.fromInt(0);
              if (r != null)
                this.copyTo(r);
              return;
            }
            if (r == null)
              r = nbi();
            var y = nbi(),
                ts = this.s,
                ms = m.s;
            var nsh = this.DB - nbits(pm[pm.t - 1]);
            if (nsh > 0) {
              pm.lShiftTo(nsh, y);
              pt.lShiftTo(nsh, r);
            } else {
              pm.copyTo(y);
              pt.copyTo(r);
            }
            var ys = y.t;
            var y0 = y[ys - 1];
            if (y0 == 0)
              return;
            var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
            var d1 = this.FV / yt,
                d2 = (1 << this.F1) / yt,
                e = 1 << this.F2;
            var i = r.t,
                j = i - ys,
                t = (q == null) ? nbi() : q;
            y.dlShiftTo(j, t);
            if (r.compareTo(t) >= 0) {
              r[r.t++] = 1;
              r.subTo(t, r);
            }
            BigInteger.ONE.dlShiftTo(ys, t);
            t.subTo(y, y);
            while (y.t < ys)
              y[y.t++] = 0;
            while (--j >= 0) {
              var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
              if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd)
                  r.subTo(t, r);
              }
            }
            if (q != null) {
              r.drShiftTo(ys, q);
              if (ts != ms)
                BigInteger.ZERO.subTo(q, q);
            }
            r.t = ys;
            r.clamp();
            if (nsh > 0)
              r.rShiftTo(nsh, r);
            if (ts < 0)
              BigInteger.ZERO.subTo(r, r);
          }
          function bnMod(a) {
            var r = nbi();
            this.abs().divRemTo(a, null, r);
            if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
              a.subTo(r, r);
            return r;
          }
          function Classic(m) {
            this.m = m;
          }
          function cConvert(x) {
            if (x.s < 0 || x.compareTo(this.m) >= 0)
              return x.mod(this.m);
            else
              return x;
          }
          function cRevert(x) {
            return x;
          }
          function cReduce(x) {
            x.divRemTo(this.m, null, x);
          }
          function cMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          function cSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          Classic.prototype.convert = cConvert;
          Classic.prototype.revert = cRevert;
          Classic.prototype.reduce = cReduce;
          Classic.prototype.mulTo = cMulTo;
          Classic.prototype.sqrTo = cSqrTo;
          function bnpInvDigit() {
            if (this.t < 1)
              return 0;
            var x = this[0];
            if ((x & 1) == 0)
              return 0;
            var y = x & 3;
            y = (y * (2 - (x & 0xf) * y)) & 0xf;
            y = (y * (2 - (x & 0xff) * y)) & 0xff;
            y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;
            y = (y * (2 - x * y % this.DV)) % this.DV;
            return (y > 0) ? this.DV - y : -y;
          }
          function Montgomery(m) {
            this.m = m;
            this.mp = m.invDigit();
            this.mpl = this.mp & 0x7fff;
            this.mph = this.mp >> 15;
            this.um = (1 << (m.DB - 15)) - 1;
            this.mt2 = 2 * m.t;
          }
          function montConvert(x) {
            var r = nbi();
            x.abs().dlShiftTo(this.m.t, r);
            r.divRemTo(this.m, null, r);
            if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
              this.m.subTo(r, r);
            return r;
          }
          function montRevert(x) {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
          }
          function montReduce(x) {
            while (x.t <= this.mt2)
              x[x.t++] = 0;
            for (var i = 0; i < this.m.t; ++i) {
              var j = x[i] & 0x7fff;
              var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
              j = i + this.m.t;
              x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
              while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
              }
            }
            x.clamp();
            x.drShiftTo(this.m.t, x);
            if (x.compareTo(this.m) >= 0)
              x.subTo(this.m, x);
          }
          function montSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          function montMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          Montgomery.prototype.convert = montConvert;
          Montgomery.prototype.revert = montRevert;
          Montgomery.prototype.reduce = montReduce;
          Montgomery.prototype.mulTo = montMulTo;
          Montgomery.prototype.sqrTo = montSqrTo;
          function bnpIsEven() {
            return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
          }
          function bnpExp(e, z) {
            if (e > 0xffffffff || e < 1)
              return BigInteger.ONE;
            var r = nbi(),
                r2 = nbi(),
                g = z.convert(this),
                i = nbits(e) - 1;
            g.copyTo(r);
            while (--i >= 0) {
              z.sqrTo(r, r2);
              if ((e & (1 << i)) > 0)
                z.mulTo(r2, g, r);
              else {
                var t = r;
                r = r2;
                r2 = t;
              }
            }
            return z.revert(r);
          }
          function bnModPowInt(e, m) {
            var z;
            if (e < 256 || m.isEven())
              z = new Classic(m);
            else
              z = new Montgomery(m);
            return this.exp(e, z);
          }
          BigInteger.prototype.copyTo = bnpCopyTo;
          BigInteger.prototype.fromInt = bnpFromInt;
          BigInteger.prototype.fromString = bnpFromString;
          BigInteger.prototype.clamp = bnpClamp;
          BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
          BigInteger.prototype.drShiftTo = bnpDRShiftTo;
          BigInteger.prototype.lShiftTo = bnpLShiftTo;
          BigInteger.prototype.rShiftTo = bnpRShiftTo;
          BigInteger.prototype.subTo = bnpSubTo;
          BigInteger.prototype.multiplyTo = bnpMultiplyTo;
          BigInteger.prototype.squareTo = bnpSquareTo;
          BigInteger.prototype.divRemTo = bnpDivRemTo;
          BigInteger.prototype.invDigit = bnpInvDigit;
          BigInteger.prototype.isEven = bnpIsEven;
          BigInteger.prototype.exp = bnpExp;
          BigInteger.prototype.toString = bnToString;
          BigInteger.prototype.negate = bnNegate;
          BigInteger.prototype.abs = bnAbs;
          BigInteger.prototype.compareTo = bnCompareTo;
          BigInteger.prototype.bitLength = bnBitLength;
          BigInteger.prototype.mod = bnMod;
          BigInteger.prototype.modPowInt = bnModPowInt;
          BigInteger.ZERO = nbv(0);
          BigInteger.ONE = nbv(1);
          function bnClone() {
            var r = nbi();
            this.copyTo(r);
            return r;
          }
          function bnIntValue() {
            if (this.s < 0) {
              if (this.t == 1)
                return this[0] - this.DV;
              else if (this.t == 0)
                return -1;
            } else if (this.t == 1)
              return this[0];
            else if (this.t == 0)
              return 0;
            return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
          }
          function bnByteValue() {
            return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
          }
          function bnShortValue() {
            return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
          }
          function bnpChunkSize(r) {
            return Math.floor(Math.LN2 * this.DB / Math.log(r));
          }
          function bnSigNum() {
            if (this.s < 0)
              return -1;
            else if (this.t <= 0 || (this.t == 1 && this[0] <= 0))
              return 0;
            else
              return 1;
          }
          function bnpToRadix(b) {
            if (b == null)
              b = 10;
            if (this.signum() == 0 || b < 2 || b > 36)
              return "0";
            var cs = this.chunkSize(b);
            var a = Math.pow(b, cs);
            var d = nbv(a),
                y = nbi(),
                z = nbi(),
                r = "";
            this.divRemTo(d, y, z);
            while (y.signum() > 0) {
              r = (a + z.intValue()).toString(b).substr(1) + r;
              y.divRemTo(d, y, z);
            }
            return z.intValue().toString(b) + r;
          }
          function bnpFromRadix(s, b) {
            this.fromInt(0);
            if (b == null)
              b = 10;
            var cs = this.chunkSize(b);
            var d = Math.pow(b, cs),
                mi = false,
                j = 0,
                w = 0;
            for (var i = 0; i < s.length; ++i) {
              var x = intAt(s, i);
              if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0)
                  mi = true;
                continue;
              }
              w = b * w + x;
              if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
              }
            }
            if (j > 0) {
              this.dMultiply(Math.pow(b, j));
              this.dAddOffset(w, 0);
            }
            if (mi)
              BigInteger.ZERO.subTo(this, this);
          }
          function bnpFromNumber(a, b, c) {
            if ("number" == typeof b) {
              if (a < 2)
                this.fromInt(1);
              else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1))
                  this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                if (this.isEven())
                  this.dAddOffset(1, 0);
                while (!this.isProbablePrime(b)) {
                  this.dAddOffset(2, 0);
                  if (this.bitLength() > a)
                    this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                }
              }
            } else {
              var x = new Array(),
                  t = a & 7;
              x.length = (a >> 3) + 1;
              b.nextBytes(x);
              if (t > 0)
                x[0] &= ((1 << t) - 1);
              else
                x[0] = 0;
              this.fromString(x, 256);
            }
          }
          function bnToByteArray() {
            var i = this.t,
                r = new Array();
            r[0] = this.s;
            var p = this.DB - (i * this.DB) % 8,
                d,
                k = 0;
            if (i-- > 0) {
              if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
                r[k++] = d | (this.s << (this.DB - p));
              while (i >= 0) {
                if (p < 8) {
                  d = (this[i] & ((1 << p) - 1)) << (8 - p);
                  d |= this[--i] >> (p += this.DB - 8);
                } else {
                  d = (this[i] >> (p -= 8)) & 0xff;
                  if (p <= 0) {
                    p += this.DB;
                    --i;
                  }
                }
                if ((d & 0x80) != 0)
                  d |= -256;
                if (k == 0 && (this.s & 0x80) != (d & 0x80))
                  ++k;
                if (k > 0 || d != this.s)
                  r[k++] = d;
              }
            }
            return r;
          }
          function bnEquals(a) {
            return (this.compareTo(a) == 0);
          }
          function bnMin(a) {
            return (this.compareTo(a) < 0) ? this : a;
          }
          function bnMax(a) {
            return (this.compareTo(a) > 0) ? this : a;
          }
          function bnpBitwiseTo(a, op, r) {
            var i,
                f,
                m = Math.min(a.t, this.t);
            for (i = 0; i < m; ++i)
              r[i] = op(this[i], a[i]);
            if (a.t < this.t) {
              f = a.s & this.DM;
              for (i = m; i < this.t; ++i)
                r[i] = op(this[i], f);
              r.t = this.t;
            } else {
              f = this.s & this.DM;
              for (i = m; i < a.t; ++i)
                r[i] = op(f, a[i]);
              r.t = a.t;
            }
            r.s = op(this.s, a.s);
            r.clamp();
          }
          function op_and(x, y) {
            return x & y;
          }
          function bnAnd(a) {
            var r = nbi();
            this.bitwiseTo(a, op_and, r);
            return r;
          }
          function op_or(x, y) {
            return x | y;
          }
          function bnOr(a) {
            var r = nbi();
            this.bitwiseTo(a, op_or, r);
            return r;
          }
          function op_xor(x, y) {
            return x ^ y;
          }
          function bnXor(a) {
            var r = nbi();
            this.bitwiseTo(a, op_xor, r);
            return r;
          }
          function op_andnot(x, y) {
            return x & ~y;
          }
          function bnAndNot(a) {
            var r = nbi();
            this.bitwiseTo(a, op_andnot, r);
            return r;
          }
          function bnNot() {
            var r = nbi();
            for (var i = 0; i < this.t; ++i)
              r[i] = this.DM & ~this[i];
            r.t = this.t;
            r.s = ~this.s;
            return r;
          }
          function bnShiftLeft(n) {
            var r = nbi();
            if (n < 0)
              this.rShiftTo(-n, r);
            else
              this.lShiftTo(n, r);
            return r;
          }
          function bnShiftRight(n) {
            var r = nbi();
            if (n < 0)
              this.lShiftTo(-n, r);
            else
              this.rShiftTo(n, r);
            return r;
          }
          function lbit(x) {
            if (x == 0)
              return -1;
            var r = 0;
            if ((x & 0xffff) == 0) {
              x >>= 16;
              r += 16;
            }
            if ((x & 0xff) == 0) {
              x >>= 8;
              r += 8;
            }
            if ((x & 0xf) == 0) {
              x >>= 4;
              r += 4;
            }
            if ((x & 3) == 0) {
              x >>= 2;
              r += 2;
            }
            if ((x & 1) == 0)
              ++r;
            return r;
          }
          function bnGetLowestSetBit() {
            for (var i = 0; i < this.t; ++i)
              if (this[i] != 0)
                return i * this.DB + lbit(this[i]);
            if (this.s < 0)
              return this.t * this.DB;
            return -1;
          }
          function cbit(x) {
            var r = 0;
            while (x != 0) {
              x &= x - 1;
              ++r;
            }
            return r;
          }
          function bnBitCount() {
            var r = 0,
                x = this.s & this.DM;
            for (var i = 0; i < this.t; ++i)
              r += cbit(this[i] ^ x);
            return r;
          }
          function bnTestBit(n) {
            var j = Math.floor(n / this.DB);
            if (j >= this.t)
              return (this.s != 0);
            return ((this[j] & (1 << (n % this.DB))) != 0);
          }
          function bnpChangeBit(n, op) {
            var r = BigInteger.ONE.shiftLeft(n);
            this.bitwiseTo(r, op, r);
            return r;
          }
          function bnSetBit(n) {
            return this.changeBit(n, op_or);
          }
          function bnClearBit(n) {
            return this.changeBit(n, op_andnot);
          }
          function bnFlipBit(n) {
            return this.changeBit(n, op_xor);
          }
          function bnpAddTo(a, r) {
            var i = 0,
                c = 0,
                m = Math.min(a.t, this.t);
            while (i < m) {
              c += this[i] + a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            if (a.t < this.t) {
              c += a.s;
              while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += this.s;
            } else {
              c += this.s;
              while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += a.s;
            }
            r.s = (c < 0) ? -1 : 0;
            if (c > 0)
              r[i++] = c;
            else if (c < -1)
              r[i++] = this.DV + c;
            r.t = i;
            r.clamp();
          }
          function bnAdd(a) {
            var r = nbi();
            this.addTo(a, r);
            return r;
          }
          function bnSubtract(a) {
            var r = nbi();
            this.subTo(a, r);
            return r;
          }
          function bnMultiply(a) {
            var r = nbi();
            this.multiplyTo(a, r);
            return r;
          }
          function bnSquare() {
            var r = nbi();
            this.squareTo(r);
            return r;
          }
          function bnDivide(a) {
            var r = nbi();
            this.divRemTo(a, r, null);
            return r;
          }
          function bnRemainder(a) {
            var r = nbi();
            this.divRemTo(a, null, r);
            return r;
          }
          function bnDivideAndRemainder(a) {
            var q = nbi(),
                r = nbi();
            this.divRemTo(a, q, r);
            return new Array(q, r);
          }
          function bnpDMultiply(n) {
            this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
            ++this.t;
            this.clamp();
          }
          function bnpDAddOffset(n, w) {
            if (n == 0)
              return;
            while (this.t <= w)
              this[this.t++] = 0;
            this[w] += n;
            while (this[w] >= this.DV) {
              this[w] -= this.DV;
              if (++w >= this.t)
                this[this.t++] = 0;
              ++this[w];
            }
          }
          function NullExp() {}
          function nNop(x) {
            return x;
          }
          function nMulTo(x, y, r) {
            x.multiplyTo(y, r);
          }
          function nSqrTo(x, r) {
            x.squareTo(r);
          }
          NullExp.prototype.convert = nNop;
          NullExp.prototype.revert = nNop;
          NullExp.prototype.mulTo = nMulTo;
          NullExp.prototype.sqrTo = nSqrTo;
          function bnPow(e) {
            return this.exp(e, new NullExp());
          }
          function bnpMultiplyLowerTo(a, n, r) {
            var i = Math.min(this.t + a.t, n);
            r.s = 0;
            r.t = i;
            while (i > 0)
              r[--i] = 0;
            var j;
            for (j = r.t - this.t; i < j; ++i)
              r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
            for (j = Math.min(a.t, n); i < j; ++i)
              this.am(0, a[i], r, i, 0, n - i);
            r.clamp();
          }
          function bnpMultiplyUpperTo(a, n, r) {
            --n;
            var i = r.t = this.t + a.t - n;
            r.s = 0;
            while (--i >= 0)
              r[i] = 0;
            for (i = Math.max(n - this.t, 0); i < a.t; ++i)
              r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
            r.clamp();
            r.drShiftTo(1, r);
          }
          function Barrett(m) {
            this.r2 = nbi();
            this.q3 = nbi();
            BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
            this.mu = this.r2.divide(m);
            this.m = m;
          }
          function barrettConvert(x) {
            if (x.s < 0 || x.t > 2 * this.m.t)
              return x.mod(this.m);
            else if (x.compareTo(this.m) < 0)
              return x;
            else {
              var r = nbi();
              x.copyTo(r);
              this.reduce(r);
              return r;
            }
          }
          function barrettRevert(x) {
            return x;
          }
          function barrettReduce(x) {
            x.drShiftTo(this.m.t - 1, this.r2);
            if (x.t > this.m.t + 1) {
              x.t = this.m.t + 1;
              x.clamp();
            }
            this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
            this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
            while (x.compareTo(this.r2) < 0)
              x.dAddOffset(1, this.m.t + 1);
            x.subTo(this.r2, x);
            while (x.compareTo(this.m) >= 0)
              x.subTo(this.m, x);
          }
          function barrettSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          function barrettMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          Barrett.prototype.convert = barrettConvert;
          Barrett.prototype.revert = barrettRevert;
          Barrett.prototype.reduce = barrettReduce;
          Barrett.prototype.mulTo = barrettMulTo;
          Barrett.prototype.sqrTo = barrettSqrTo;
          function bnModPow(e, m) {
            var i = e.bitLength(),
                k,
                r = nbv(1),
                z;
            if (i <= 0)
              return r;
            else if (i < 18)
              k = 1;
            else if (i < 48)
              k = 3;
            else if (i < 144)
              k = 4;
            else if (i < 768)
              k = 5;
            else
              k = 6;
            if (i < 8)
              z = new Classic(m);
            else if (m.isEven())
              z = new Barrett(m);
            else
              z = new Montgomery(m);
            var g = new Array(),
                n = 3,
                k1 = k - 1,
                km = (1 << k) - 1;
            g[1] = z.convert(this);
            if (k > 1) {
              var g2 = nbi();
              z.sqrTo(g[1], g2);
              while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
              }
            }
            var j = e.t - 1,
                w,
                is1 = true,
                r2 = nbi(),
                t;
            i = nbits(e[j]) - 1;
            while (j >= 0) {
              if (i >= k1)
                w = (e[j] >> (i - k1)) & km;
              else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0)
                  w |= e[j - 1] >> (this.DB + i - k1);
              }
              n = k;
              while ((w & 1) == 0) {
                w >>= 1;
                --n;
              }
              if ((i -= n) < 0) {
                i += this.DB;
                --j;
              }
              if (is1) {
                g[w].copyTo(r);
                is1 = false;
              } else {
                while (n > 1) {
                  z.sqrTo(r, r2);
                  z.sqrTo(r2, r);
                  n -= 2;
                }
                if (n > 0)
                  z.sqrTo(r, r2);
                else {
                  t = r;
                  r = r2;
                  r2 = t;
                }
                z.mulTo(r2, g[w], r);
              }
              while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                  i = this.DB - 1;
                  --j;
                }
              }
            }
            return z.revert(r);
          }
          function bnGCD(a) {
            var x = (this.s < 0) ? this.negate() : this.clone();
            var y = (a.s < 0) ? a.negate() : a.clone();
            if (x.compareTo(y) < 0) {
              var t = x;
              x = y;
              y = t;
            }
            var i = x.getLowestSetBit(),
                g = y.getLowestSetBit();
            if (g < 0)
              return x;
            if (i < g)
              g = i;
            if (g > 0) {
              x.rShiftTo(g, x);
              y.rShiftTo(g, y);
            }
            while (x.signum() > 0) {
              if ((i = x.getLowestSetBit()) > 0)
                x.rShiftTo(i, x);
              if ((i = y.getLowestSetBit()) > 0)
                y.rShiftTo(i, y);
              if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
              } else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
              }
            }
            if (g > 0)
              y.lShiftTo(g, y);
            return y;
          }
          function bnpModInt(n) {
            if (n <= 0)
              return 0;
            var d = this.DV % n,
                r = (this.s < 0) ? n - 1 : 0;
            if (this.t > 0)
              if (d == 0)
                r = this[0] % n;
              else
                for (var i = this.t - 1; i >= 0; --i)
                  r = (d * r + this[i]) % n;
            return r;
          }
          function bnModInverse(m) {
            var ac = m.isEven();
            if ((this.isEven() && ac) || m.signum() == 0)
              return BigInteger.ZERO;
            var u = m.clone(),
                v = this.clone();
            var a = nbv(1),
                b = nbv(0),
                c = nbv(0),
                d = nbv(1);
            while (u.signum() != 0) {
              while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                  if (!a.isEven() || !b.isEven()) {
                    a.addTo(this, a);
                    b.subTo(m, b);
                  }
                  a.rShiftTo(1, a);
                } else if (!b.isEven())
                  b.subTo(m, b);
                b.rShiftTo(1, b);
              }
              while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                  if (!c.isEven() || !d.isEven()) {
                    c.addTo(this, c);
                    d.subTo(m, d);
                  }
                  c.rShiftTo(1, c);
                } else if (!d.isEven())
                  d.subTo(m, d);
                d.rShiftTo(1, d);
              }
              if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac)
                  a.subTo(c, a);
                b.subTo(d, b);
              } else {
                v.subTo(u, v);
                if (ac)
                  c.subTo(a, c);
                d.subTo(b, d);
              }
            }
            if (v.compareTo(BigInteger.ONE) != 0)
              return BigInteger.ZERO;
            if (d.compareTo(m) >= 0)
              return d.subtract(m);
            if (d.signum() < 0)
              d.addTo(m, d);
            else
              return d;
            if (d.signum() < 0)
              return d.add(m);
            else
              return d;
          }
          var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
          var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
          function bnIsProbablePrime(t) {
            var i,
                x = this.abs();
            if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
              for (i = 0; i < lowprimes.length; ++i)
                if (x[0] == lowprimes[i])
                  return true;
              return false;
            }
            if (x.isEven())
              return false;
            i = 1;
            while (i < lowprimes.length) {
              var m = lowprimes[i],
                  j = i + 1;
              while (j < lowprimes.length && m < lplim)
                m *= lowprimes[j++];
              m = x.modInt(m);
              while (i < j)
                if (m % lowprimes[i++] == 0)
                  return false;
            }
            return x.millerRabin(t);
          }
          function bnpMillerRabin(t) {
            var n1 = this.subtract(BigInteger.ONE);
            var k = n1.getLowestSetBit();
            if (k <= 0)
              return false;
            var r = n1.shiftRight(k);
            t = (t + 1) >> 1;
            if (t > lowprimes.length)
              t = lowprimes.length;
            var a = nbi();
            for (var i = 0; i < t; ++i) {
              a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
              var y = a.modPow(r, this);
              if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                  y = y.modPowInt(2, this);
                  if (y.compareTo(BigInteger.ONE) == 0)
                    return false;
                }
                if (y.compareTo(n1) != 0)
                  return false;
              }
            }
            return true;
          }
          BigInteger.prototype.chunkSize = bnpChunkSize;
          BigInteger.prototype.toRadix = bnpToRadix;
          BigInteger.prototype.fromRadix = bnpFromRadix;
          BigInteger.prototype.fromNumber = bnpFromNumber;
          BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
          BigInteger.prototype.changeBit = bnpChangeBit;
          BigInteger.prototype.addTo = bnpAddTo;
          BigInteger.prototype.dMultiply = bnpDMultiply;
          BigInteger.prototype.dAddOffset = bnpDAddOffset;
          BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
          BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
          BigInteger.prototype.modInt = bnpModInt;
          BigInteger.prototype.millerRabin = bnpMillerRabin;
          BigInteger.prototype.clone = bnClone;
          BigInteger.prototype.intValue = bnIntValue;
          BigInteger.prototype.byteValue = bnByteValue;
          BigInteger.prototype.shortValue = bnShortValue;
          BigInteger.prototype.signum = bnSigNum;
          BigInteger.prototype.toByteArray = bnToByteArray;
          BigInteger.prototype.equals = bnEquals;
          BigInteger.prototype.min = bnMin;
          BigInteger.prototype.max = bnMax;
          BigInteger.prototype.and = bnAnd;
          BigInteger.prototype.or = bnOr;
          BigInteger.prototype.xor = bnXor;
          BigInteger.prototype.andNot = bnAndNot;
          BigInteger.prototype.not = bnNot;
          BigInteger.prototype.shiftLeft = bnShiftLeft;
          BigInteger.prototype.shiftRight = bnShiftRight;
          BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
          BigInteger.prototype.bitCount = bnBitCount;
          BigInteger.prototype.testBit = bnTestBit;
          BigInteger.prototype.setBit = bnSetBit;
          BigInteger.prototype.clearBit = bnClearBit;
          BigInteger.prototype.flipBit = bnFlipBit;
          BigInteger.prototype.add = bnAdd;
          BigInteger.prototype.subtract = bnSubtract;
          BigInteger.prototype.multiply = bnMultiply;
          BigInteger.prototype.divide = bnDivide;
          BigInteger.prototype.remainder = bnRemainder;
          BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
          BigInteger.prototype.modPow = bnModPow;
          BigInteger.prototype.modInverse = bnModInverse;
          BigInteger.prototype.pow = bnPow;
          BigInteger.prototype.gcd = bnGCD;
          BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
          BigInteger.prototype.square = bnSquare;
          BigInteger.prototype.Barrett = Barrett;
          if (typeof exports !== 'undefined') {
            exports = module.exports = BigInteger;
          } else {
            this.BigInteger = BigInteger;
          }
        }).call(this);
      }, {}],
      10: [function(require, module, exports) {
        var cs2a = require("./cs2a.js");
        var ecc = require("ecc-jsbn");
        require("./forge.min.js");
        cs2a.crypt(ecc, forge);
        Object.keys(cs2a).forEach(function(f) {
          exports[f] = cs2a[f];
        });
      }, {
        "./cs2a.js": 11,
        "./forge.min.js": 12,
        "ecc-jsbn": 13
      }],
      11: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var sjcl = require("sjcl");
          var self;
          exports.install = function(telehash) {
            self = telehash;
            telehash.CSets["2a"] = exports;
          };
          var forge;
          exports.crypt = function(ecc, f) {
            crypto.ecc = ecc;
            forge = f;
          };
          exports.genkey = function(ret, cbDone, cbStep) {
            var state = forge.rsa.createKeyPairGenerationState(2048, 0x10001);
            var step = function() {
              if (!forge.rsa.stepKeyPairGenerationState(state, 100)) {
                if (cbStep)
                  cbStep();
                setTimeout(step, 10);
              } else {
                var key = forge.asn1.toDer(forge.pki.publicKeyToAsn1(state.keys.publicKey)).bytes();
                ret["2a"] = forge.util.encode64(key);
                ret["2a_secret"] = forge.util.encode64(forge.asn1.toDer(forge.pki.privateKeyToAsn1(state.keys.privateKey)).bytes());
                cbDone();
              }
            };
            setTimeout(step);
          };
          exports.loadkey = function(id, pub, priv) {
            if (pub.length > 300) {
              if (pub.substr(0, 1) == "-")
                pub = forge.asn1.toDer(forge.pki.publicKeyToAsn1(forge.pki.publicKeyFromPem(key))).bytes();
              else
                pub = forge.util.decode64(pub);
            }
            id.key = pub;
            var pk = forge.pki.publicKeyFromAsn1(forge.asn1.fromDer(pub));
            id.encrypt = function(buf) {
              return new Buffer(pk.encrypt(buf.toString("binary"), "RSA-OAEP"), "binary");
            };
            id.verify = function(a, b) {
              return pk.verify(a.toString("binary"), b.toString("binary"));
            };
            if (priv) {
              var sk = (priv.substr(0, 1) == "-") ? forge.pki.privateKeyFromPem(priv) : forge.pki.privateKeyFromAsn1(forge.asn1.fromDer(forge.util.decode64(priv)));
              id.sign = function(buf) {
                var md = forge.md.sha256.create();
                md.update(buf.toString("binary"));
                return new Buffer(sk.sign(md), "binary");
              };
              id.decrypt = function(buf) {
                return new Buffer(sk.decrypt(buf.toString("binary"), "RSA-OAEP"), "binary");
              };
            }
            return false;
          };
          exports.openize = function(id, to, inner) {
            if (!to.ecc)
              to.ecc = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp256r1);
            var eccpub = to.ecc.PublicKey.slice(1);
            var ibody = (!Buffer.isBuffer(inner)) ? self.pencode(inner, id.cs["2a"].key) : inner;
            var keyhex = crypto.createHash("sha256").update(eccpub).digest("hex");
            var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
            var iv = sjcl.codec.hex.toBits("00000000000000000000000000000001");
            var cipher = sjcl.mode.gcm.encrypt(key, sjcl.codec.hex.toBits(ibody.toString("hex")), iv, [], 128);
            var cbody = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            var sig = id.cs["2a"].sign(cbody);
            if (!to.lineOut)
              to.lineOut = "";
            var keyhex = crypto.createHash("sha256").update(Buffer.concat([eccpub, new Buffer(to.lineOut, "hex")])).digest("hex");
            var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
            var cipher = sjcl.mode.gcm.encrypt(key, sjcl.codec.hex.toBits(sig.toString("hex")), iv, [], 32);
            var csig = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            var ekey = to.encrypt(eccpub);
            var body = Buffer.concat([ekey, csig, cbody]);
            var packet = self.pencode(0x2a, body);
            return packet;
          };
          exports.deopenize = function(id, open) {
            var ret = {verify: false};
            var ekey = open.body.slice(0, 256);
            var csig = open.body.slice(256, 256 + 260);
            var cbody = open.body.slice(256 + 260);
            var eccpub = id.cs["2a"].decrypt(ekey);
            if (!eccpub)
              return ret;
            try {
              ret.linepub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp256r1, Buffer.concat([new Buffer("04", "hex"), eccpub]), true);
            } catch (E) {}
            ;
            if (!ret.linepub)
              return ret;
            var keyhex = crypto.createHash("sha256").update(eccpub).digest("hex");
            var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
            var iv = sjcl.codec.hex.toBits("00000000000000000000000000000001");
            var cipher = sjcl.mode.gcm.decrypt(key, sjcl.codec.hex.toBits(cbody.toString("hex")), iv, [], 128);
            var ibody = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            var deciphered = self.pdecode(ibody);
            if (!deciphered || !deciphered.body)
              return ret;
            ret.js = deciphered.js;
            ret.inner = deciphered;
            var from = {};
            var lineIn;
            if (!open.from) {
              ret.key = deciphered.body;
              if (exports.loadkey(from, deciphered.body))
                return ret;
              lineIn = deciphered.js.line;
            } else {
              from = open.from;
              lineIn = "";
            }
            var keyhex = crypto.createHash("sha256").update(Buffer.concat([eccpub, new Buffer(lineIn, "hex")])).digest("hex");
            var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
            var cipher = sjcl.mode.gcm.decrypt(key, sjcl.codec.hex.toBits(csig.toString("hex")), iv, [], 32);
            var sig = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            ret.verify = from.verify(cbody, sig);
            return ret;
          };
          exports.openline = function(from, open) {
            var ecdhe = from.ecc.deriveSharedSecret(open.linepub);
            from.lineInB = new Buffer(from.lineIn, "hex");
            var hex = crypto.createHash("sha256").update(ecdhe).update(new Buffer(from.lineOut, "hex")).update(new Buffer(from.lineIn, "hex")).digest("hex");
            from.encKey = new sjcl.cipher.aes(sjcl.codec.hex.toBits(hex));
            var hex = crypto.createHash("sha256").update(ecdhe).update(new Buffer(from.lineIn, "hex")).update(new Buffer(from.lineOut, "hex")).digest("hex");
            from.decKey = new sjcl.cipher.aes(sjcl.codec.hex.toBits(hex));
            return true;
          };
          exports.lineize = function(to, packet) {
            var iv = crypto.randomBytes(16);
            var buf = self.pencode(packet.js, packet.body);
            var cipher = sjcl.mode.gcm.encrypt(to.encKey, sjcl.codec.hex.toBits(buf.toString("hex")), sjcl.codec.hex.toBits(iv.toString("hex")), [], 128);
            var cbody = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
            var body = Buffer.concat([to.lineInB, iv, cbody]);
            return self.pencode(null, body);
          }, exports.delineize = function(from, packet) {
            if (!packet.body)
              return "missing body";
            packet.body = packet.body.slice(16);
            var iv = sjcl.codec.hex.toBits(packet.body.slice(0, 16).toString("hex"));
            try {
              var cipher = sjcl.mode.gcm.decrypt(from.decKey, sjcl.codec.hex.toBits(packet.body.slice(16).toString("hex")), iv, [], 128);
            } catch (E) {
              return E;
            }
            if (!cipher)
              return "no cipher output";
            var deciphered = self.pdecode(new Buffer(sjcl.codec.hex.fromBits(cipher), "hex"));
            if (!deciphered)
              return "invalid decrypted packet";
            packet.js = deciphered.js;
            packet.body = deciphered.body;
            return false;
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "crypto": 35,
        "sjcl": 17
      }],
      12: [function(require, module, exports) {
        module.exports = require(5);
      }, {"sycGbZ": 51}],
      13: [function(require, module, exports) {
        module.exports = require(6);
      }, {
        "./lib/ec.js": 14,
        "./lib/sec.js": 15,
        "buffer": 29,
        "crypto": 35,
        "jsbn": 16
      }],
      14: [function(require, module, exports) {
        module.exports = require(7);
      }, {"jsbn": 16}],
      15: [function(require, module, exports) {
        module.exports = require(8);
      }, {
        "./ec.js": 14,
        "jsbn": 16
      }],
      16: [function(require, module, exports) {
        module.exports = require(9);
      }, {}],
      17: [function(require, module, exports) {
        "use strict";
        function q(a) {
          throw a;
        }
        var t = void 0,
            u = !1;
        var sjcl = {
          cipher: {},
          hash: {},
          keyexchange: {},
          mode: {},
          misc: {},
          codec: {},
          exception: {
            corrupt: function(a) {
              this.toString = function() {
                return "CORRUPT: " + this.message;
              };
              this.message = a;
            },
            invalid: function(a) {
              this.toString = function() {
                return "INVALID: " + this.message;
              };
              this.message = a;
            },
            bug: function(a) {
              this.toString = function() {
                return "BUG: " + this.message;
              };
              this.message = a;
            },
            notReady: function(a) {
              this.toString = function() {
                return "NOT READY: " + this.message;
              };
              this.message = a;
            }
          }
        };
        "undefined" !== typeof module && module.exports && (module.exports = sjcl);
        sjcl.cipher.aes = function(a) {
          this.k[0][0][0] || this.D();
          var b,
              c,
              d,
              e,
              f = this.k[0][4],
              g = this.k[1];
          b = a.length;
          var h = 1;
          4 !== b && (6 !== b && 8 !== b) && q(new sjcl.exception.invalid("invalid aes key size"));
          this.b = [d = a.slice(0), e = []];
          for (a = b; a < 4 * b + 28; a++) {
            c = d[a - 1];
            if (0 === a % b || 8 === b && 4 === a % b)
              c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255], 0 === a % b && (c = c << 8 ^ c >>> 24 ^ h << 24, h = h << 1 ^ 283 * (h >> 7));
            d[a] = d[a - b] ^ c;
          }
          for (b = 0; a; b++, a--)
            c = d[b & 3 ? a : a - 4], e[b] = 4 >= a || 4 > b ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c & 255]];
        };
        sjcl.cipher.aes.prototype = {
          encrypt: function(a) {
            return y(this, a, 0);
          },
          decrypt: function(a) {
            return y(this, a, 1);
          },
          k: [[[], [], [], [], []], [[], [], [], [], []]],
          D: function() {
            var a = this.k[0],
                b = this.k[1],
                c = a[4],
                d = b[4],
                e,
                f,
                g,
                h = [],
                l = [],
                k,
                n,
                m,
                p;
            for (e = 0; 0x100 > e; e++)
              l[(h[e] = e << 1 ^ 283 * (e >> 7)) ^ e] = e;
            for (f = g = 0; !c[f]; f ^= k || 1, g = l[g] || 1) {
              m = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
              m = m >> 8 ^ m & 255 ^ 99;
              c[f] = m;
              d[m] = f;
              n = h[e = h[k = h[f]]];
              p = 0x1010101 * n ^ 0x10001 * e ^ 0x101 * k ^ 0x1010100 * f;
              n = 0x101 * h[m] ^ 0x1010100 * m;
              for (e = 0; 4 > e; e++)
                a[e][f] = n = n << 24 ^ n >>> 8, b[e][m] = p = p << 24 ^ p >>> 8;
            }
            for (e = 0; 5 > e; e++)
              a[e] = a[e].slice(0), b[e] = b[e].slice(0);
          }
        };
        function y(a, b, c) {
          4 !== b.length && q(new sjcl.exception.invalid("invalid aes block size"));
          var d = a.b[c],
              e = b[0] ^ d[0],
              f = b[c ? 3 : 1] ^ d[1],
              g = b[2] ^ d[2];
          b = b[c ? 1 : 3] ^ d[3];
          var h,
              l,
              k,
              n = d.length / 4 - 2,
              m,
              p = 4,
              s = [0, 0, 0, 0];
          h = a.k[c];
          a = h[0];
          var r = h[1],
              v = h[2],
              w = h[3],
              x = h[4];
          for (m = 0; m < n; m++)
            h = a[e >>> 24] ^ r[f >> 16 & 255] ^ v[g >> 8 & 255] ^ w[b & 255] ^ d[p], l = a[f >>> 24] ^ r[g >> 16 & 255] ^ v[b >> 8 & 255] ^ w[e & 255] ^ d[p + 1], k = a[g >>> 24] ^ r[b >> 16 & 255] ^ v[e >> 8 & 255] ^ w[f & 255] ^ d[p + 2], b = a[b >>> 24] ^ r[e >> 16 & 255] ^ v[f >> 8 & 255] ^ w[g & 255] ^ d[p + 3], p += 4, e = h, f = l, g = k;
          for (m = 0; 4 > m; m++)
            s[c ? 3 & -m : m] = x[e >>> 24] << 24 ^ x[f >> 16 & 255] << 16 ^ x[g >> 8 & 255] << 8 ^ x[b & 255] ^ d[p++], h = e, e = f, f = g, g = b, b = h;
          return s;
        }
        sjcl.bitArray = {
          bitSlice: function(a, b, c) {
            a = sjcl.bitArray.P(a.slice(b / 32), 32 - (b & 31)).slice(1);
            return c === t ? a : sjcl.bitArray.clamp(a, c - b);
          },
          extract: function(a, b, c) {
            var d = Math.floor(-b - c & 31);
            return ((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1;
          },
          concat: function(a, b) {
            if (0 === a.length || 0 === b.length)
              return a.concat(b);
            var c = a[a.length - 1],
                d = sjcl.bitArray.getPartial(c);
            return 32 === d ? a.concat(b) : sjcl.bitArray.P(b, d, c | 0, a.slice(0, a.length - 1));
          },
          bitLength: function(a) {
            var b = a.length;
            return 0 === b ? 0 : 32 * (b - 1) + sjcl.bitArray.getPartial(a[b - 1]);
          },
          clamp: function(a, b) {
            if (32 * a.length < b)
              return a;
            a = a.slice(0, Math.ceil(b / 32));
            var c = a.length;
            b &= 31;
            0 < c && b && (a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1));
            return a;
          },
          partial: function(a, b, c) {
            return 32 === a ? b : (c ? b | 0 : b << 32 - a) + 0x10000000000 * a;
          },
          getPartial: function(a) {
            return Math.round(a / 0x10000000000) || 32;
          },
          equal: function(a, b) {
            if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b))
              return u;
            var c = 0,
                d;
            for (d = 0; d < a.length; d++)
              c |= a[d] ^ b[d];
            return 0 === c;
          },
          P: function(a, b, c, d) {
            var e;
            e = 0;
            for (d === t && (d = []); 32 <= b; b -= 32)
              d.push(c), c = 0;
            if (0 === b)
              return d.concat(a);
            for (e = 0; e < a.length; e++)
              d.push(c | a[e] >>> b), c = a[e] << 32 - b;
            e = a.length ? a[a.length - 1] : 0;
            a = sjcl.bitArray.getPartial(e);
            d.push(sjcl.bitArray.partial(b + a & 31, 32 < b + a ? c : d.pop(), 1));
            return d;
          },
          l: function(a, b) {
            return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]];
          }
        };
        sjcl.codec.utf8String = {
          fromBits: function(a) {
            var b = "",
                c = sjcl.bitArray.bitLength(a),
                d,
                e;
            for (d = 0; d < c / 8; d++)
              0 === (d & 3) && (e = a[d / 4]), b += String.fromCharCode(e >>> 24), e <<= 8;
            return decodeURIComponent(escape(b));
          },
          toBits: function(a) {
            a = unescape(encodeURIComponent(a));
            var b = [],
                c,
                d = 0;
            for (c = 0; c < a.length; c++)
              d = d << 8 | a.charCodeAt(c), 3 === (c & 3) && (b.push(d), d = 0);
            c & 3 && b.push(sjcl.bitArray.partial(8 * (c & 3), d));
            return b;
          }
        };
        sjcl.codec.hex = {
          fromBits: function(a) {
            var b = "",
                c;
            for (c = 0; c < a.length; c++)
              b += ((a[c] | 0) + 0xf00000000000).toString(16).substr(4);
            return b.substr(0, sjcl.bitArray.bitLength(a) / 4);
          },
          toBits: function(a) {
            var b,
                c = [],
                d;
            a = a.replace(/\s|0x/g, "");
            d = a.length;
            a += "00000000";
            for (b = 0; b < a.length; b += 8)
              c.push(parseInt(a.substr(b, 8), 16) ^ 0);
            return sjcl.bitArray.clamp(c, 4 * d);
          }
        };
        sjcl.codec.base64 = {
          J: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          fromBits: function(a, b, c) {
            var d = "",
                e = 0,
                f = sjcl.codec.base64.J,
                g = 0,
                h = sjcl.bitArray.bitLength(a);
            c && (f = f.substr(0, 62) + "-_");
            for (c = 0; 6 * d.length < h; )
              d += f.charAt((g ^ a[c] >>> e) >>> 26), 6 > e ? (g = a[c] << 6 - e, e += 26, c++) : (g <<= 6, e -= 6);
            for (; d.length & 3 && !b; )
              d += "=";
            return d;
          },
          toBits: function(a, b) {
            a = a.replace(/\s|=/g, "");
            var c = [],
                d,
                e = 0,
                f = sjcl.codec.base64.J,
                g = 0,
                h;
            b && (f = f.substr(0, 62) + "-_");
            for (d = 0; d < a.length; d++)
              h = f.indexOf(a.charAt(d)), 0 > h && q(new sjcl.exception.invalid("this isn't base64!")), 26 < e ? (e -= 26, c.push(g ^ h >>> e), g = h << 32 - e) : (e += 6, g ^= h << 32 - e);
            e & 56 && c.push(sjcl.bitArray.partial(e & 56, g, 1));
            return c;
          }
        };
        sjcl.codec.base64url = {
          fromBits: function(a) {
            return sjcl.codec.base64.fromBits(a, 1, 1);
          },
          toBits: function(a) {
            return sjcl.codec.base64.toBits(a, 1);
          }
        };
        sjcl.hash.sha256 = function(a) {
          this.b[0] || this.D();
          a ? (this.r = a.r.slice(0), this.o = a.o.slice(0), this.h = a.h) : this.reset();
        };
        sjcl.hash.sha256.hash = function(a) {
          return (new sjcl.hash.sha256).update(a).finalize();
        };
        sjcl.hash.sha256.prototype = {
          blockSize: 512,
          reset: function() {
            this.r = this.N.slice(0);
            this.o = [];
            this.h = 0;
            return this;
          },
          update: function(a) {
            "string" === typeof a && (a = sjcl.codec.utf8String.toBits(a));
            var b,
                c = this.o = sjcl.bitArray.concat(this.o, a);
            b = this.h;
            a = this.h = b + sjcl.bitArray.bitLength(a);
            for (b = 512 + b & -512; b <= a; b += 512)
              z(this, c.splice(0, 16));
            return this;
          },
          finalize: function() {
            var a,
                b = this.o,
                c = this.r,
                b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
            for (a = b.length + 2; a & 15; a++)
              b.push(0);
            b.push(Math.floor(this.h / 4294967296));
            for (b.push(this.h | 0); b.length; )
              z(this, b.splice(0, 16));
            this.reset();
            return c;
          },
          N: [],
          b: [],
          D: function() {
            function a(a) {
              return 0x100000000 * (a - Math.floor(a)) | 0;
            }
            var b = 0,
                c = 2,
                d;
            a: for (; 64 > b; c++) {
              for (d = 2; d * d <= c; d++)
                if (0 === c % d)
                  continue a;
              8 > b && (this.N[b] = a(Math.pow(c, 0.5)));
              this.b[b] = a(Math.pow(c, 1 / 3));
              b++;
            }
          }
        };
        function z(a, b) {
          var c,
              d,
              e,
              f = b.slice(0),
              g = a.r,
              h = a.b,
              l = g[0],
              k = g[1],
              n = g[2],
              m = g[3],
              p = g[4],
              s = g[5],
              r = g[6],
              v = g[7];
          for (c = 0; 64 > c; c++)
            16 > c ? d = f[c] : (d = f[c + 1 & 15], e = f[c + 14 & 15], d = f[c & 15] = (d >>> 7 ^ d >>> 18 ^ d >>> 3 ^ d << 25 ^ d << 14) + (e >>> 17 ^ e >>> 19 ^ e >>> 10 ^ e << 15 ^ e << 13) + f[c & 15] + f[c + 9 & 15] | 0), d = d + v + (p >>> 6 ^ p >>> 11 ^ p >>> 25 ^ p << 26 ^ p << 21 ^ p << 7) + (r ^ p & (s ^ r)) + h[c], v = r, r = s, s = p, p = m + d | 0, m = n, n = k, k = l, l = d + (k & n ^ m & (k ^ n)) + (k >>> 2 ^ k >>> 13 ^ k >>> 22 ^ k << 30 ^ k << 19 ^ k << 10) | 0;
          g[0] = g[0] + l | 0;
          g[1] = g[1] + k | 0;
          g[2] = g[2] + n | 0;
          g[3] = g[3] + m | 0;
          g[4] = g[4] + p | 0;
          g[5] = g[5] + s | 0;
          g[6] = g[6] + r | 0;
          g[7] = g[7] + v | 0;
        }
        sjcl.mode.ccm = {
          name: "ccm",
          encrypt: function(a, b, c, d, e) {
            var f,
                g = b.slice(0),
                h = sjcl.bitArray,
                l = h.bitLength(c) / 8,
                k = h.bitLength(g) / 8;
            e = e || 64;
            d = d || [];
            7 > l && q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes"));
            for (f = 2; 4 > f && k >>> 8 * f; f++)
              ;
            f < 15 - l && (f = 15 - l);
            c = h.clamp(c, 8 * (15 - f));
            b = sjcl.mode.ccm.L(a, b, c, d, e, f);
            g = sjcl.mode.ccm.p(a, g, c, b, e, f);
            return h.concat(g.data, g.tag);
          },
          decrypt: function(a, b, c, d, e) {
            e = e || 64;
            d = d || [];
            var f = sjcl.bitArray,
                g = f.bitLength(c) / 8,
                h = f.bitLength(b),
                l = f.clamp(b, h - e),
                k = f.bitSlice(b, h - e),
                h = (h - e) / 8;
            7 > g && q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes"));
            for (b = 2; 4 > b && h >>> 8 * b; b++)
              ;
            b < 15 - g && (b = 15 - g);
            c = f.clamp(c, 8 * (15 - b));
            l = sjcl.mode.ccm.p(a, l, c, k, e, b);
            a = sjcl.mode.ccm.L(a, l.data, c, d, e, b);
            f.equal(l.tag, a) || q(new sjcl.exception.corrupt("ccm: tag doesn't match"));
            return l.data;
          },
          L: function(a, b, c, d, e, f) {
            var g = [],
                h = sjcl.bitArray,
                l = h.l;
            e /= 8;
            (e % 2 || 4 > e || 16 < e) && q(new sjcl.exception.invalid("ccm: invalid tag length"));
            (0xffffffff < d.length || 0xffffffff < b.length) && q(new sjcl.exception.bug("ccm: can't deal with 4GiB or more data"));
            f = [h.partial(8, (d.length ? 64 : 0) | e - 2 << 2 | f - 1)];
            f = h.concat(f, c);
            f[3] |= h.bitLength(b) / 8;
            f = a.encrypt(f);
            if (d.length) {
              c = h.bitLength(d) / 8;
              65279 >= c ? g = [h.partial(16, c)] : 0xffffffff >= c && (g = h.concat([h.partial(16, 65534)], [c]));
              g = h.concat(g, d);
              for (d = 0; d < g.length; d += 4)
                f = a.encrypt(l(f, g.slice(d, d + 4).concat([0, 0, 0])));
            }
            for (d = 0; d < b.length; d += 4)
              f = a.encrypt(l(f, b.slice(d, d + 4).concat([0, 0, 0])));
            return h.clamp(f, 8 * e);
          },
          p: function(a, b, c, d, e, f) {
            var g,
                h = sjcl.bitArray;
            g = h.l;
            var l = b.length,
                k = h.bitLength(b);
            c = h.concat([h.partial(8, f - 1)], c).concat([0, 0, 0]).slice(0, 4);
            d = h.bitSlice(g(d, a.encrypt(c)), 0, e);
            if (!l)
              return {
                tag: d,
                data: []
              };
            for (g = 0; g < l; g += 4)
              c[3]++, e = a.encrypt(c), b[g] ^= e[0], b[g + 1] ^= e[1], b[g + 2] ^= e[2], b[g + 3] ^= e[3];
            return {
              tag: d,
              data: h.clamp(b, k)
            };
          }
        };
        sjcl.mode.ocb2 = {
          name: "ocb2",
          encrypt: function(a, b, c, d, e, f) {
            128 !== sjcl.bitArray.bitLength(c) && q(new sjcl.exception.invalid("ocb iv must be 128 bits"));
            var g,
                h = sjcl.mode.ocb2.H,
                l = sjcl.bitArray,
                k = l.l,
                n = [0, 0, 0, 0];
            c = h(a.encrypt(c));
            var m,
                p = [];
            d = d || [];
            e = e || 64;
            for (g = 0; g + 4 < b.length; g += 4)
              m = b.slice(g, g + 4), n = k(n, m), p = p.concat(k(c, a.encrypt(k(c, m)))), c = h(c);
            m = b.slice(g);
            b = l.bitLength(m);
            g = a.encrypt(k(c, [0, 0, 0, b]));
            m = l.clamp(k(m.concat([0, 0, 0]), g), b);
            n = k(n, k(m.concat([0, 0, 0]), g));
            n = a.encrypt(k(n, k(c, h(c))));
            d.length && (n = k(n, f ? d : sjcl.mode.ocb2.pmac(a, d)));
            return p.concat(l.concat(m, l.clamp(n, e)));
          },
          decrypt: function(a, b, c, d, e, f) {
            128 !== sjcl.bitArray.bitLength(c) && q(new sjcl.exception.invalid("ocb iv must be 128 bits"));
            e = e || 64;
            var g = sjcl.mode.ocb2.H,
                h = sjcl.bitArray,
                l = h.l,
                k = [0, 0, 0, 0],
                n = g(a.encrypt(c)),
                m,
                p,
                s = sjcl.bitArray.bitLength(b) - e,
                r = [];
            d = d || [];
            for (c = 0; c + 4 < s / 32; c += 4)
              m = l(n, a.decrypt(l(n, b.slice(c, c + 4)))), k = l(k, m), r = r.concat(m), n = g(n);
            p = s - 32 * c;
            m = a.encrypt(l(n, [0, 0, 0, p]));
            m = l(m, h.clamp(b.slice(c), p).concat([0, 0, 0]));
            k = l(k, m);
            k = a.encrypt(l(k, l(n, g(n))));
            d.length && (k = l(k, f ? d : sjcl.mode.ocb2.pmac(a, d)));
            h.equal(h.clamp(k, e), h.bitSlice(b, s)) || q(new sjcl.exception.corrupt("ocb: tag doesn't match"));
            return r.concat(h.clamp(m, p));
          },
          pmac: function(a, b) {
            var c,
                d = sjcl.mode.ocb2.H,
                e = sjcl.bitArray,
                f = e.l,
                g = [0, 0, 0, 0],
                h = a.encrypt([0, 0, 0, 0]),
                h = f(h, d(d(h)));
            for (c = 0; c + 4 < b.length; c += 4)
              h = d(h), g = f(g, a.encrypt(f(h, b.slice(c, c + 4))));
            c = b.slice(c);
            128 > e.bitLength(c) && (h = f(h, d(h)), c = e.concat(c, [-2147483648, 0, 0, 0]));
            g = f(g, c);
            return a.encrypt(f(d(f(h, d(h))), g));
          },
          H: function(a) {
            return [a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ 135 * (a[0] >>> 31)];
          }
        };
        sjcl.mode.gcm = {
          name: "gcm",
          encrypt: function(a, b, c, d, e) {
            var f = b.slice(0);
            b = sjcl.bitArray;
            d = d || [];
            a = sjcl.mode.gcm.p(!0, a, f, d, c, e || 128);
            return b.concat(a.data, a.tag);
          },
          decrypt: function(a, b, c, d, e) {
            var f = b.slice(0),
                g = sjcl.bitArray,
                h = g.bitLength(f);
            e = e || 128;
            d = d || [];
            e <= h ? (b = g.bitSlice(f, h - e), f = g.bitSlice(f, 0, h - e)) : (b = f, f = []);
            a = sjcl.mode.gcm.p(u, a, f, d, c, e);
            g.equal(a.tag, b) || q(new sjcl.exception.corrupt("gcm: tag doesn't match"));
            return a.data;
          },
          Z: function(a, b) {
            var c,
                d,
                e,
                f,
                g,
                h = sjcl.bitArray.l;
            e = [0, 0, 0, 0];
            f = b.slice(0);
            for (c = 0; 128 > c; c++) {
              (d = 0 !== (a[Math.floor(c / 32)] & 1 << 31 - c % 32)) && (e = h(e, f));
              g = 0 !== (f[3] & 1);
              for (d = 3; 0 < d; d--)
                f[d] = f[d] >>> 1 | (f[d - 1] & 1) << 31;
              f[0] >>>= 1;
              g && (f[0] ^= -0x1f000000);
            }
            return e;
          },
          g: function(a, b, c) {
            var d,
                e = c.length;
            b = b.slice(0);
            for (d = 0; d < e; d += 4)
              b[0] ^= 0xffffffff & c[d], b[1] ^= 0xffffffff & c[d + 1], b[2] ^= 0xffffffff & c[d + 2], b[3] ^= 0xffffffff & c[d + 3], b = sjcl.mode.gcm.Z(b, a);
            return b;
          },
          p: function(a, b, c, d, e, f) {
            var g,
                h,
                l,
                k,
                n,
                m,
                p,
                s,
                r = sjcl.bitArray;
            m = c.length;
            p = r.bitLength(c);
            s = r.bitLength(d);
            h = r.bitLength(e);
            g = b.encrypt([0, 0, 0, 0]);
            96 === h ? (e = e.slice(0), e = r.concat(e, [1])) : (e = sjcl.mode.gcm.g(g, [0, 0, 0, 0], e), e = sjcl.mode.gcm.g(g, e, [0, 0, Math.floor(h / 0x100000000), h & 0xffffffff]));
            h = sjcl.mode.gcm.g(g, [0, 0, 0, 0], d);
            n = e.slice(0);
            d = h.slice(0);
            a || (d = sjcl.mode.gcm.g(g, h, c));
            for (k = 0; k < m; k += 4)
              n[3]++, l = b.encrypt(n), c[k] ^= l[0], c[k + 1] ^= l[1], c[k + 2] ^= l[2], c[k + 3] ^= l[3];
            c = r.clamp(c, p);
            a && (d = sjcl.mode.gcm.g(g, h, c));
            a = [Math.floor(s / 0x100000000), s & 0xffffffff, Math.floor(p / 0x100000000), p & 0xffffffff];
            d = sjcl.mode.gcm.g(g, d, a);
            l = b.encrypt(e);
            d[0] ^= l[0];
            d[1] ^= l[1];
            d[2] ^= l[2];
            d[3] ^= l[3];
            return {
              tag: r.bitSlice(d, 0, f),
              data: c
            };
          }
        };
        sjcl.misc.hmac = function(a, b) {
          this.M = b = b || sjcl.hash.sha256;
          var c = [[], []],
              d,
              e = b.prototype.blockSize / 32;
          this.n = [new b, new b];
          a.length > e && (a = b.hash(a));
          for (d = 0; d < e; d++)
            c[0][d] = a[d] ^ 909522486, c[1][d] = a[d] ^ 1549556828;
          this.n[0].update(c[0]);
          this.n[1].update(c[1]);
          this.G = new b(this.n[0]);
        };
        sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function(a) {
          this.Q && q(new sjcl.exception.invalid("encrypt on already updated hmac called!"));
          this.update(a);
          return this.digest(a);
        };
        sjcl.misc.hmac.prototype.reset = function() {
          this.G = new this.M(this.n[0]);
          this.Q = u;
        };
        sjcl.misc.hmac.prototype.update = function(a) {
          this.Q = !0;
          this.G.update(a);
        };
        sjcl.misc.hmac.prototype.digest = function() {
          var a = this.G.finalize(),
              a = (new this.M(this.n[1])).update(a).finalize();
          this.reset();
          return a;
        };
        sjcl.misc.pbkdf2 = function(a, b, c, d, e) {
          c = c || 1E3;
          (0 > d || 0 > c) && q(sjcl.exception.invalid("invalid params to pbkdf2"));
          "string" === typeof a && (a = sjcl.codec.utf8String.toBits(a));
          "string" === typeof b && (b = sjcl.codec.utf8String.toBits(b));
          e = e || sjcl.misc.hmac;
          a = new e(a);
          var f,
              g,
              h,
              l,
              k = [],
              n = sjcl.bitArray;
          for (l = 1; 32 * k.length < (d || 1); l++) {
            e = f = a.encrypt(n.concat(b, [l]));
            for (g = 1; g < c; g++) {
              f = a.encrypt(f);
              for (h = 0; h < f.length; h++)
                e[h] ^= f[h];
            }
            k = k.concat(e);
          }
          d && (k = n.clamp(k, d));
          return k;
        };
        sjcl.prng = function(a) {
          this.c = [new sjcl.hash.sha256];
          this.i = [0];
          this.F = 0;
          this.s = {};
          this.C = 0;
          this.K = {};
          this.O = this.d = this.j = this.W = 0;
          this.b = [0, 0, 0, 0, 0, 0, 0, 0];
          this.f = [0, 0, 0, 0];
          this.A = t;
          this.B = a;
          this.q = u;
          this.w = {
            progress: {},
            seeded: {}
          };
          this.m = this.V = 0;
          this.t = 1;
          this.u = 2;
          this.S = 0x10000;
          this.I = [0, 48, 64, 96, 128, 192, 0x100, 384, 512, 768, 1024];
          this.T = 3E4;
          this.R = 80;
        };
        sjcl.prng.prototype = {
          randomWords: function(a, b) {
            var c = [],
                d;
            d = this.isReady(b);
            var e;
            d === this.m && q(new sjcl.exception.notReady("generator isn't seeded"));
            if (d & this.u) {
              d = !(d & this.t);
              e = [];
              var f = 0,
                  g;
              this.O = e[0] = (new Date).valueOf() + this.T;
              for (g = 0; 16 > g; g++)
                e.push(0x100000000 * Math.random() | 0);
              for (g = 0; g < this.c.length && !(e = e.concat(this.c[g].finalize()), f += this.i[g], this.i[g] = 0, !d && this.F & 1 << g); g++)
                ;
              this.F >= 1 << this.c.length && (this.c.push(new sjcl.hash.sha256), this.i.push(0));
              this.d -= f;
              f > this.j && (this.j = f);
              this.F++;
              this.b = sjcl.hash.sha256.hash(this.b.concat(e));
              this.A = new sjcl.cipher.aes(this.b);
              for (d = 0; 4 > d && !(this.f[d] = this.f[d] + 1 | 0, this.f[d]); d++)
                ;
            }
            for (d = 0; d < a; d += 4)
              0 === (d + 1) % this.S && A(this), e = B(this), c.push(e[0], e[1], e[2], e[3]);
            A(this);
            return c.slice(0, a);
          },
          setDefaultParanoia: function(a, b) {
            0 === a && "Setting paranoia=0 will ruin your security; use it only for testing" !== b && q("Setting paranoia=0 will ruin your security; use it only for testing");
            this.B = a;
          },
          addEntropy: function(a, b, c) {
            c = c || "user";
            var d,
                e,
                f = (new Date).valueOf(),
                g = this.s[c],
                h = this.isReady(),
                l = 0;
            d = this.K[c];
            d === t && (d = this.K[c] = this.W++);
            g === t && (g = this.s[c] = 0);
            this.s[c] = (this.s[c] + 1) % this.c.length;
            switch (typeof a) {
              case "number":
                b === t && (b = 1);
                this.c[g].update([d, this.C++, 1, b, f, 1, a | 0]);
                break;
              case "object":
                c = Object.prototype.toString.call(a);
                if ("[object Uint32Array]" === c) {
                  e = [];
                  for (c = 0; c < a.length; c++)
                    e.push(a[c]);
                  a = e;
                } else {
                  "[object Array]" !== c && (l = 1);
                  for (c = 0; c < a.length && !l; c++)
                    "number" !== typeof a[c] && (l = 1);
                }
                if (!l) {
                  if (b === t)
                    for (c = b = 0; c < a.length; c++)
                      for (e = a[c]; 0 < e; )
                        b++, e >>>= 1;
                  this.c[g].update([d, this.C++, 2, b, f, a.length].concat(a));
                }
                break;
              case "string":
                b === t && (b = a.length);
                this.c[g].update([d, this.C++, 3, b, f, a.length]);
                this.c[g].update(a);
                break;
              default:
                l = 1;
            }
            l && q(new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string"));
            this.i[g] += b;
            this.d += b;
            h === this.m && (this.isReady() !== this.m && C("seeded", Math.max(this.j, this.d)), C("progress", this.getProgress()));
          },
          isReady: function(a) {
            a = this.I[a !== t ? a : this.B];
            return this.j && this.j >= a ? this.i[0] > this.R && (new Date).valueOf() > this.O ? this.u | this.t : this.t : this.d >= a ? this.u | this.m : this.m;
          },
          getProgress: function(a) {
            a = this.I[a ? a : this.B];
            return this.j >= a ? 1 : this.d > a ? 1 : this.d / a;
          },
          startCollectors: function() {
            this.q || (this.a = {
              loadTimeCollector: D(this, this.aa),
              mouseCollector: D(this, this.ba),
              keyboardCollector: D(this, this.$),
              accelerometerCollector: D(this, this.U)
            }, window.addEventListener ? (window.addEventListener("load", this.a.loadTimeCollector, u), window.addEventListener("mousemove", this.a.mouseCollector, u), window.addEventListener("keypress", this.a.keyboardCollector, u), window.addEventListener("devicemotion", this.a.accelerometerCollector, u)) : document.attachEvent ? (document.attachEvent("onload", this.a.loadTimeCollector), document.attachEvent("onmousemove", this.a.mouseCollector), document.attachEvent("keypress", this.a.keyboardCollector)) : q(new sjcl.exception.bug("can't attach event")), this.q = !0);
          },
          stopCollectors: function() {
            this.q && (window.removeEventListener ? (window.removeEventListener("load", this.a.loadTimeCollector, u), window.removeEventListener("mousemove", this.a.mouseCollector, u), window.removeEventListener("keypress", this.a.keyboardCollector, u), window.removeEventListener("devicemotion", this.a.accelerometerCollector, u)) : document.detachEvent && (document.detachEvent("onload", this.a.loadTimeCollector), document.detachEvent("onmousemove", this.a.mouseCollector), document.detachEvent("keypress", this.a.keyboardCollector)), this.q = u);
          },
          addEventListener: function(a, b) {
            this.w[a][this.V++] = b;
          },
          removeEventListener: function(a, b) {
            var c,
                d,
                e = this.w[a],
                f = [];
            for (d in e)
              e.hasOwnProperty(d) && e[d] === b && f.push(d);
            for (c = 0; c < f.length; c++)
              d = f[c], delete e[d];
          },
          $: function() {
            E(1);
          },
          ba: function(a) {
            sjcl.random.addEntropy([a.x || a.clientX || a.offsetX || 0, a.y || a.clientY || a.offsetY || 0], 2, "mouse");
            E(0);
          },
          aa: function() {
            E(2);
          },
          U: function(a) {
            a = a.accelerationIncludingGravity.x || a.accelerationIncludingGravity.y || a.accelerationIncludingGravity.z;
            if (window.orientation) {
              var b = window.orientation;
              "number" === typeof b && sjcl.random.addEntropy(b, 1, "accelerometer");
            }
            a && sjcl.random.addEntropy(a, 2, "accelerometer");
            E(0);
          }
        };
        function C(a, b) {
          var c,
              d = sjcl.random.w[a],
              e = [];
          for (c in d)
            d.hasOwnProperty(c) && e.push(d[c]);
          for (c = 0; c < e.length; c++)
            e[c](b);
        }
        function E(a) {
          window && window.performance && "function" === typeof window.performance.now ? sjcl.random.addEntropy(window.performance.now(), a, "loadtime") : sjcl.random.addEntropy((new Date).valueOf(), a, "loadtime");
        }
        function A(a) {
          a.b = B(a).concat(B(a));
          a.A = new sjcl.cipher.aes(a.b);
        }
        function B(a) {
          for (var b = 0; 4 > b && !(a.f[b] = a.f[b] + 1 | 0, a.f[b]); b++)
            ;
          return a.A.encrypt(a.f);
        }
        function D(a, b) {
          return function() {
            b.apply(a, arguments);
          };
        }
        sjcl.random = new sjcl.prng(6);
        a: try {
          var F,
              G,
              H,
              I;
          if (I = "undefined" !== typeof module) {
            var J;
            if (J = module.exports) {
              var K;
              try {
                K = require("crypto");
              } catch (L) {
                K = null;
              }
              J = (G = K) && G.randomBytes;
            }
            I = J;
          }
          if (I)
            F = G.randomBytes(128), F = new Uint32Array((new Uint8Array(F)).buffer), sjcl.random.addEntropy(F, 1024, "crypto['randomBytes']");
          else if (window && Uint32Array) {
            H = new Uint32Array(32);
            if (window.crypto && window.crypto.getRandomValues)
              window.crypto.getRandomValues(H);
            else if (window.msCrypto && window.msCrypto.getRandomValues)
              window.msCrypto.getRandomValues(H);
            else
              break a;
            sjcl.random.addEntropy(H, 1024, "crypto['getRandomValues']");
          }
        } catch (M) {
          "undefined" !== typeof window && window.console && (console.log("There was an error collecting entropy from the browser:"), console.log(M));
        }
        sjcl.json = {
          defaults: {
            v: 1,
            iter: 1E3,
            ks: 128,
            ts: 64,
            mode: "ccm",
            adata: "",
            cipher: "aes"
          },
          Y: function(a, b, c, d) {
            c = c || {};
            d = d || {};
            var e = sjcl.json,
                f = e.e({iv: sjcl.random.randomWords(4, 0)}, e.defaults),
                g;
            e.e(f, c);
            c = f.adata;
            "string" === typeof f.salt && (f.salt = sjcl.codec.base64.toBits(f.salt));
            "string" === typeof f.iv && (f.iv = sjcl.codec.base64.toBits(f.iv));
            (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || "string" === typeof a && 100 >= f.iter || 64 !== f.ts && 96 !== f.ts && 128 !== f.ts || 128 !== f.ks && 192 !== f.ks && 0x100 !== f.ks || 2 > f.iv.length || 4 < f.iv.length) && q(new sjcl.exception.invalid("json encrypt: invalid parameters"));
            "string" === typeof a ? (g = sjcl.misc.cachedPbkdf2(a, f), a = g.key.slice(0, f.ks / 32), f.salt = g.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.publicKey && (g = a.kem(), f.kemtag = g.tag, a = g.key.slice(0, f.ks / 32));
            "string" === typeof b && (b = sjcl.codec.utf8String.toBits(b));
            "string" === typeof c && (c = sjcl.codec.utf8String.toBits(c));
            g = new sjcl.cipher[f.cipher](a);
            e.e(d, f);
            d.key = a;
            f.ct = sjcl.mode[f.mode].encrypt(g, b, f.iv, c, f.ts);
            return f;
          },
          encrypt: function(a, b, c, d) {
            var e = sjcl.json,
                f = e.Y.apply(e, arguments);
            return e.encode(f);
          },
          X: function(a, b, c, d) {
            c = c || {};
            d = d || {};
            var e = sjcl.json;
            b = e.e(e.e(e.e({}, e.defaults), b), c, !0);
            var f;
            c = b.adata;
            "string" === typeof b.salt && (b.salt = sjcl.codec.base64.toBits(b.salt));
            "string" === typeof b.iv && (b.iv = sjcl.codec.base64.toBits(b.iv));
            (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || "string" === typeof a && 100 >= b.iter || 64 !== b.ts && 96 !== b.ts && 128 !== b.ts || 128 !== b.ks && 192 !== b.ks && 0x100 !== b.ks || !b.iv || 2 > b.iv.length || 4 < b.iv.length) && q(new sjcl.exception.invalid("json decrypt: invalid parameters"));
            "string" === typeof a ? (f = sjcl.misc.cachedPbkdf2(a, b), a = f.key.slice(0, b.ks / 32), b.salt = f.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.secretKey && (a = a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0, b.ks / 32));
            "string" === typeof c && (c = sjcl.codec.utf8String.toBits(c));
            f = new sjcl.cipher[b.cipher](a);
            c = sjcl.mode[b.mode].decrypt(f, b.ct, b.iv, c, b.ts);
            e.e(d, b);
            d.key = a;
            return sjcl.codec.utf8String.fromBits(c);
          },
          decrypt: function(a, b, c, d) {
            var e = sjcl.json;
            return e.X(a, e.decode(b), c, d);
          },
          encode: function(a) {
            var b,
                c = "{",
                d = "";
            for (b in a)
              if (a.hasOwnProperty(b))
                switch (b.match(/^[a-z0-9]+$/i) || q(new sjcl.exception.invalid("json encode: invalid property name")), c += d + '"' + b + '":', d = ",", typeof a[b]) {
                  case "number":
                  case "boolean":
                    c += a[b];
                    break;
                  case "string":
                    c += '"' + escape(a[b]) + '"';
                    break;
                  case "object":
                    c += '"' + sjcl.codec.base64.fromBits(a[b], 0) + '"';
                    break;
                  default:
                    q(new sjcl.exception.bug("json encode: unsupported type"));
                }
            return c + "}";
          },
          decode: function(a) {
            a = a.replace(/\s/g, "");
            a.match(/^\{.*\}$/) || q(new sjcl.exception.invalid("json decode: this isn't json!"));
            a = a.replace(/^\{|\}$/g, "").split(/,/);
            var b = {},
                c,
                d;
            for (c = 0; c < a.length; c++)
              (d = a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i)) || q(new sjcl.exception.invalid("json decode: this isn't json!")), b[d[2]] = d[3] ? parseInt(d[3], 10) : d[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(d[4]) : unescape(d[4]);
            return b;
          },
          e: function(a, b, c) {
            a === t && (a = {});
            if (b === t)
              return a;
            for (var d in b)
              b.hasOwnProperty(d) && (c && (a[d] !== t && a[d] !== b[d]) && q(new sjcl.exception.invalid("required parameter overridden")), a[d] = b[d]);
            return a;
          },
          ea: function(a, b) {
            var c = {},
                d;
            for (d in a)
              a.hasOwnProperty(d) && a[d] !== b[d] && (c[d] = a[d]);
            return c;
          },
          da: function(a, b) {
            var c = {},
                d;
            for (d = 0; d < b.length; d++)
              a[b[d]] !== t && (c[b[d]] = a[b[d]]);
            return c;
          }
        };
        sjcl.encrypt = sjcl.json.encrypt;
        sjcl.decrypt = sjcl.json.decrypt;
        sjcl.misc.ca = {};
        sjcl.misc.cachedPbkdf2 = function(a, b) {
          var c = sjcl.misc.ca,
              d;
          b = b || {};
          d = b.iter || 1E3;
          c = c[a] = c[a] || {};
          d = c[d] = c[d] || {firstSalt: b.salt && b.salt.length ? b.salt.slice(0) : sjcl.random.randomWords(2, 0)};
          c = b.salt === t ? d.firstSalt : b.salt;
          d[c] = d[c] || sjcl.misc.pbkdf2(a, c, b.iter);
          return {
            key: d[c].slice(0),
            salt: c.slice(0)
          };
        };
      }, {"crypto": 35}],
      18: [function(require, module, exports) {
        (function(Buffer) {
          var io = require("socket.io-client");
          exports.install = function(self) {
            var sockets = {};
            self.deliver("http", function(path, msg, to) {
              if (!sockets[path.http]) {
                sockets[path.http] = io.connect(path.http);
                sockets[path.http].on("packet", function(packet) {
                  self.receive((new Buffer(packet.data, "base64")).toString("binary"), path);
                });
              }
              sockets[path.http].emit("packet", {data: msg.toString("base64")});
            });
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "socket.io-client": 19
      }],
      19: [function(require, module, exports) {
        var io = ('undefined' === typeof module ? {} : module.exports);
        (function() {
          (function(exports, global) {
            var io = exports;
            io.version = '0.9.17';
            io.protocol = 1;
            io.transports = [];
            io.j = [];
            io.sockets = {};
            io.connect = function(host, details) {
              var uri = io.util.parseUri(host),
                  uuri,
                  socket;
              if (global && global.location) {
                uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);
                uri.host = uri.host || (global.document ? global.document.domain : global.location.hostname);
                uri.port = uri.port || global.location.port;
              }
              uuri = io.util.uniqueUri(uri);
              var options = {
                host: uri.host,
                secure: 'https' == uri.protocol,
                port: uri.port || ('https' == uri.protocol ? 443 : 80),
                query: uri.query || ''
              };
              io.util.merge(options, details);
              if (options['force new connection'] || !io.sockets[uuri] || (!io.sockets[uuri].connected && !io.sockets[uuri].connecting && !io.sockets[uuri].open && !io.sockets[uuri].reconnecting)) {
                socket = new io.Socket(options);
              }
              if (!options['force new connection'] && socket) {
                io.sockets[uuri] = socket;
              }
              socket = socket || io.sockets[uuri];
              return socket.of(uri.path.length > 1 ? uri.path : '');
            };
          })('object' === typeof module ? module.exports : (this.io = {}), this);
          (function(exports, global) {
            var util = exports.util = {};
            var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
            var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
            util.parseUri = function(str) {
              var m = re.exec(str || ''),
                  uri = {},
                  i = 14;
              while (i--) {
                uri[parts[i]] = m[i] || '';
              }
              return uri;
            };
            util.uniqueUri = function(uri) {
              var protocol = uri.protocol,
                  host = uri.host,
                  port = uri.port;
              if ('document' in global) {
                host = host || document.domain;
                port = port || (protocol == 'https' && document.location.protocol !== 'https:' ? 443 : document.location.port);
              } else {
                host = host || 'localhost';
                if (!port && protocol == 'https') {
                  port = 443;
                }
              }
              return (protocol || 'http') + '://' + host + ':' + (port || 80);
            };
            util.query = function(base, addition) {
              var query = util.chunkQuery(base || ''),
                  components = [];
              util.merge(query, util.chunkQuery(addition || ''));
              for (var part in query) {
                if (query.hasOwnProperty(part)) {
                  components.push(part + '=' + query[part]);
                }
              }
              return components.length ? '?' + components.join('&') : '';
            };
            util.chunkQuery = function(qs) {
              var query = {},
                  params = qs.split('&'),
                  i = 0,
                  l = params.length,
                  kv;
              for (; i < l; ++i) {
                kv = params[i].split('=');
                if (kv[0]) {
                  query[kv[0]] = kv[1];
                }
              }
              return query;
            };
            var pageLoaded = false;
            util.load = function(fn) {
              if ('document' in global && document.readyState === 'complete' || pageLoaded) {
                return fn();
              }
              util.on(global, 'load', fn, false);
            };
            util.on = function(element, event, fn, capture) {
              if (element.attachEvent) {
                element.attachEvent('on' + event, fn);
              } else if (element.addEventListener) {
                element.addEventListener(event, fn, capture);
              }
            };
            util.request = function(xdomain) {
              if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {
                return new XDomainRequest();
              }
              if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {
                return new XMLHttpRequest();
              }
              if (!xdomain) {
                try {
                  return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');
                } catch (e) {}
              }
              return null;
            };
            if ('undefined' != typeof window) {
              util.load(function() {
                pageLoaded = true;
              });
            }
            util.defer = function(fn) {
              if (!util.ua.webkit || 'undefined' != typeof importScripts) {
                return fn();
              }
              util.load(function() {
                setTimeout(fn, 100);
              });
            };
            util.merge = function merge(target, additional, deep, lastseen) {
              var seen = lastseen || [],
                  depth = typeof deep == 'undefined' ? 2 : deep,
                  prop;
              for (prop in additional) {
                if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {
                  if (typeof target[prop] !== 'object' || !depth) {
                    target[prop] = additional[prop];
                    seen.push(additional[prop]);
                  } else {
                    util.merge(target[prop], additional[prop], depth - 1, seen);
                  }
                }
              }
              return target;
            };
            util.mixin = function(ctor, ctor2) {
              util.merge(ctor.prototype, ctor2.prototype);
            };
            util.inherit = function(ctor, ctor2) {
              function f() {}
              ;
              f.prototype = ctor2.prototype;
              ctor.prototype = new f;
            };
            util.isArray = Array.isArray || function(obj) {
              return Object.prototype.toString.call(obj) === '[object Array]';
            };
            util.intersect = function(arr, arr2) {
              var ret = [],
                  longest = arr.length > arr2.length ? arr : arr2,
                  shortest = arr.length > arr2.length ? arr2 : arr;
              for (var i = 0,
                  l = shortest.length; i < l; i++) {
                if (~util.indexOf(longest, shortest[i]))
                  ret.push(shortest[i]);
              }
              return ret;
            };
            util.indexOf = function(arr, o, i) {
              for (var j = arr.length,
                  i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0; i < j && arr[i] !== o; i++) {}
              return j <= i ? -1 : i;
            };
            util.toArray = function(enu) {
              var arr = [];
              for (var i = 0,
                  l = enu.length; i < l; i++)
                arr.push(enu[i]);
              return arr;
            };
            util.ua = {};
            util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function() {
              try {
                var a = new XMLHttpRequest();
              } catch (e) {
                return false;
              }
              return a.withCredentials != undefined;
            })();
            util.ua.webkit = 'undefined' != typeof navigator && /webkit/i.test(navigator.userAgent);
            util.ua.iDevice = 'undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent);
          })('undefined' != typeof io ? io : module.exports, this);
          (function(exports, io) {
            exports.EventEmitter = EventEmitter;
            function EventEmitter() {}
            ;
            EventEmitter.prototype.on = function(name, fn) {
              if (!this.$events) {
                this.$events = {};
              }
              if (!this.$events[name]) {
                this.$events[name] = fn;
              } else if (io.util.isArray(this.$events[name])) {
                this.$events[name].push(fn);
              } else {
                this.$events[name] = [this.$events[name], fn];
              }
              return this;
            };
            EventEmitter.prototype.addListener = EventEmitter.prototype.on;
            EventEmitter.prototype.once = function(name, fn) {
              var self = this;
              function on() {
                self.removeListener(name, on);
                fn.apply(this, arguments);
              }
              ;
              on.listener = fn;
              this.on(name, on);
              return this;
            };
            EventEmitter.prototype.removeListener = function(name, fn) {
              if (this.$events && this.$events[name]) {
                var list = this.$events[name];
                if (io.util.isArray(list)) {
                  var pos = -1;
                  for (var i = 0,
                      l = list.length; i < l; i++) {
                    if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
                      pos = i;
                      break;
                    }
                  }
                  if (pos < 0) {
                    return this;
                  }
                  list.splice(pos, 1);
                  if (!list.length) {
                    delete this.$events[name];
                  }
                } else if (list === fn || (list.listener && list.listener === fn)) {
                  delete this.$events[name];
                }
              }
              return this;
            };
            EventEmitter.prototype.removeAllListeners = function(name) {
              if (name === undefined) {
                this.$events = {};
                return this;
              }
              if (this.$events && this.$events[name]) {
                this.$events[name] = null;
              }
              return this;
            };
            EventEmitter.prototype.listeners = function(name) {
              if (!this.$events) {
                this.$events = {};
              }
              if (!this.$events[name]) {
                this.$events[name] = [];
              }
              if (!io.util.isArray(this.$events[name])) {
                this.$events[name] = [this.$events[name]];
              }
              return this.$events[name];
            };
            EventEmitter.prototype.emit = function(name) {
              if (!this.$events) {
                return false;
              }
              var handler = this.$events[name];
              if (!handler) {
                return false;
              }
              var args = Array.prototype.slice.call(arguments, 1);
              if ('function' == typeof handler) {
                handler.apply(this, args);
              } else if (io.util.isArray(handler)) {
                var listeners = handler.slice();
                for (var i = 0,
                    l = listeners.length; i < l; i++) {
                  listeners[i].apply(this, args);
                }
              } else {
                return false;
              }
              return true;
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, nativeJSON) {
            "use strict";
            if (nativeJSON && nativeJSON.parse) {
              return exports.JSON = {
                parse: nativeJSON.parse,
                stringify: nativeJSON.stringify
              };
            }
            var JSON = exports.JSON = {};
            function f(n) {
              return n < 10 ? '0' + n : n;
            }
            function date(d, key) {
              return isFinite(d.valueOf()) ? d.getUTCFullYear() + '-' + f(d.getUTCMonth() + 1) + '-' + f(d.getUTCDate()) + 'T' + f(d.getUTCHours()) + ':' + f(d.getUTCMinutes()) + ':' + f(d.getUTCSeconds()) + 'Z' : null;
            }
            ;
            var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                gap,
                indent,
                meta = {
                  '\b': '\\b',
                  '\t': '\\t',
                  '\n': '\\n',
                  '\f': '\\f',
                  '\r': '\\r',
                  '"': '\\"',
                  '\\': '\\\\'
                },
                rep;
            function quote(string) {
              escapable.lastIndex = 0;
              return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
                var c = meta[a];
                return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
              }) + '"' : '"' + string + '"';
            }
            function str(key, holder) {
              var i,
                  k,
                  v,
                  length,
                  mind = gap,
                  partial,
                  value = holder[key];
              if (value instanceof Date) {
                value = date(key);
              }
              if (typeof rep === 'function') {
                value = rep.call(holder, key, value);
              }
              switch (typeof value) {
                case 'string':
                  return quote(value);
                case 'number':
                  return isFinite(value) ? String(value) : 'null';
                case 'boolean':
                case 'null':
                  return String(value);
                case 'object':
                  if (!value) {
                    return 'null';
                  }
                  gap += indent;
                  partial = [];
                  if (Object.prototype.toString.apply(value) === '[object Array]') {
                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                      partial[i] = str(i, value) || 'null';
                    }
                    v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                  }
                  if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                      if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                      }
                    }
                  } else {
                    for (k in value) {
                      if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                      }
                    }
                  }
                  v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
                  gap = mind;
                  return v;
              }
            }
            JSON.stringify = function(value, replacer, space) {
              var i;
              gap = '';
              indent = '';
              if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                  indent += ' ';
                }
              } else if (typeof space === 'string') {
                indent = space;
              }
              rep = replacer;
              if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
              }
              return str('', {'': value});
            };
            JSON.parse = function(text, reviver) {
              var j;
              function walk(holder, key) {
                var k,
                    v,
                    value = holder[key];
                if (value && typeof value === 'object') {
                  for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = walk(value, k);
                      if (v !== undefined) {
                        value[k] = v;
                      } else {
                        delete value[k];
                      }
                    }
                  }
                }
                return reviver.call(holder, key, value);
              }
              text = String(text);
              cx.lastIndex = 0;
              if (cx.test(text)) {
                text = text.replace(cx, function(a) {
                  return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
              }
              if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
                j = eval('(' + text + ')');
                return typeof reviver === 'function' ? walk({'': j}, '') : j;
              }
              throw new SyntaxError('JSON.parse');
            };
          })('undefined' != typeof io ? io : module.exports, typeof JSON !== 'undefined' ? JSON : undefined);
          (function(exports, io) {
            var parser = exports.parser = {};
            var packets = parser.packets = ['disconnect', 'connect', 'heartbeat', 'message', 'json', 'event', 'ack', 'error', 'noop'];
            var reasons = parser.reasons = ['transport not supported', 'client not handshaken', 'unauthorized'];
            var advice = parser.advice = ['reconnect'];
            var JSON = io.JSON,
                indexOf = io.util.indexOf;
            parser.encodePacket = function(packet) {
              var type = indexOf(packets, packet.type),
                  id = packet.id || '',
                  endpoint = packet.endpoint || '',
                  ack = packet.ack,
                  data = null;
              switch (packet.type) {
                case 'error':
                  var reason = packet.reason ? indexOf(reasons, packet.reason) : '',
                      adv = packet.advice ? indexOf(advice, packet.advice) : '';
                  if (reason !== '' || adv !== '')
                    data = reason + (adv !== '' ? ('+' + adv) : '');
                  break;
                case 'message':
                  if (packet.data !== '')
                    data = packet.data;
                  break;
                case 'event':
                  var ev = {name: packet.name};
                  if (packet.args && packet.args.length) {
                    ev.args = packet.args;
                  }
                  data = JSON.stringify(ev);
                  break;
                case 'json':
                  data = JSON.stringify(packet.data);
                  break;
                case 'connect':
                  if (packet.qs)
                    data = packet.qs;
                  break;
                case 'ack':
                  data = packet.ackId + (packet.args && packet.args.length ? '+' + JSON.stringify(packet.args) : '');
                  break;
              }
              var encoded = [type, id + (ack == 'data' ? '+' : ''), endpoint];
              if (data !== null && data !== undefined)
                encoded.push(data);
              return encoded.join(':');
            };
            parser.encodePayload = function(packets) {
              var decoded = '';
              if (packets.length == 1)
                return packets[0];
              for (var i = 0,
                  l = packets.length; i < l; i++) {
                var packet = packets[i];
                decoded += '\ufffd' + packet.length + '\ufffd' + packets[i];
              }
              return decoded;
            };
            var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
            parser.decodePacket = function(data) {
              var pieces = data.match(regexp);
              if (!pieces)
                return {};
              var id = pieces[2] || '',
                  data = pieces[5] || '',
                  packet = {
                    type: packets[pieces[1]],
                    endpoint: pieces[4] || ''
                  };
              if (id) {
                packet.id = id;
                if (pieces[3])
                  packet.ack = 'data';
                else
                  packet.ack = true;
              }
              switch (packet.type) {
                case 'error':
                  var pieces = data.split('+');
                  packet.reason = reasons[pieces[0]] || '';
                  packet.advice = advice[pieces[1]] || '';
                  break;
                case 'message':
                  packet.data = data || '';
                  break;
                case 'event':
                  try {
                    var opts = JSON.parse(data);
                    packet.name = opts.name;
                    packet.args = opts.args;
                  } catch (e) {}
                  packet.args = packet.args || [];
                  break;
                case 'json':
                  try {
                    packet.data = JSON.parse(data);
                  } catch (e) {}
                  break;
                case 'connect':
                  packet.qs = data || '';
                  break;
                case 'ack':
                  var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
                  if (pieces) {
                    packet.ackId = pieces[1];
                    packet.args = [];
                    if (pieces[3]) {
                      try {
                        packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
                      } catch (e) {}
                    }
                  }
                  break;
                case 'disconnect':
                case 'heartbeat':
                  break;
              }
              ;
              return packet;
            };
            parser.decodePayload = function(data) {
              if (data.charAt(0) == '\ufffd') {
                var ret = [];
                for (var i = 1,
                    length = ''; i < data.length; i++) {
                  if (data.charAt(i) == '\ufffd') {
                    ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));
                    i += Number(length) + 1;
                    length = '';
                  } else {
                    length += data.charAt(i);
                  }
                }
                return ret;
              } else {
                return [parser.decodePacket(data)];
              }
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, io) {
            exports.Transport = Transport;
            function Transport(socket, sessid) {
              this.socket = socket;
              this.sessid = sessid;
            }
            ;
            io.util.mixin(Transport, io.EventEmitter);
            Transport.prototype.heartbeats = function() {
              return true;
            };
            Transport.prototype.onData = function(data) {
              this.clearCloseTimeout();
              if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {
                this.setCloseTimeout();
              }
              if (data !== '') {
                var msgs = io.parser.decodePayload(data);
                if (msgs && msgs.length) {
                  for (var i = 0,
                      l = msgs.length; i < l; i++) {
                    this.onPacket(msgs[i]);
                  }
                }
              }
              return this;
            };
            Transport.prototype.onPacket = function(packet) {
              this.socket.setHeartbeatTimeout();
              if (packet.type == 'heartbeat') {
                return this.onHeartbeat();
              }
              if (packet.type == 'connect' && packet.endpoint == '') {
                this.onConnect();
              }
              if (packet.type == 'error' && packet.advice == 'reconnect') {
                this.isOpen = false;
              }
              this.socket.onPacket(packet);
              return this;
            };
            Transport.prototype.setCloseTimeout = function() {
              if (!this.closeTimeout) {
                var self = this;
                this.closeTimeout = setTimeout(function() {
                  self.onDisconnect();
                }, this.socket.closeTimeout);
              }
            };
            Transport.prototype.onDisconnect = function() {
              if (this.isOpen)
                this.close();
              this.clearTimeouts();
              this.socket.onDisconnect();
              return this;
            };
            Transport.prototype.onConnect = function() {
              this.socket.onConnect();
              return this;
            };
            Transport.prototype.clearCloseTimeout = function() {
              if (this.closeTimeout) {
                clearTimeout(this.closeTimeout);
                this.closeTimeout = null;
              }
            };
            Transport.prototype.clearTimeouts = function() {
              this.clearCloseTimeout();
              if (this.reopenTimeout) {
                clearTimeout(this.reopenTimeout);
              }
            };
            Transport.prototype.packet = function(packet) {
              this.send(io.parser.encodePacket(packet));
            };
            Transport.prototype.onHeartbeat = function(heartbeat) {
              this.packet({type: 'heartbeat'});
            };
            Transport.prototype.onOpen = function() {
              this.isOpen = true;
              this.clearCloseTimeout();
              this.socket.onOpen();
            };
            Transport.prototype.onClose = function() {
              var self = this;
              this.isOpen = false;
              this.socket.onClose();
              this.onDisconnect();
            };
            Transport.prototype.prepareUrl = function() {
              var options = this.socket.options;
              return this.scheme() + '://' + options.host + ':' + options.port + '/' + options.resource + '/' + io.protocol + '/' + this.name + '/' + this.sessid;
            };
            Transport.prototype.ready = function(socket, fn) {
              fn.call(this);
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, io, global) {
            exports.Socket = Socket;
            function Socket(options) {
              this.options = {
                port: 80,
                secure: false,
                document: 'document' in global ? document : false,
                resource: 'socket.io',
                transports: io.transports,
                'connect timeout': 10000,
                'try multiple transports': true,
                'reconnect': true,
                'reconnection delay': 500,
                'reconnection limit': Infinity,
                'reopen delay': 3000,
                'max reconnection attempts': 10,
                'sync disconnect on unload': false,
                'auto connect': true,
                'flash policy port': 10843,
                'manualFlush': false
              };
              io.util.merge(this.options, options);
              this.connected = false;
              this.open = false;
              this.connecting = false;
              this.reconnecting = false;
              this.namespaces = {};
              this.buffer = [];
              this.doBuffer = false;
              if (this.options['sync disconnect on unload'] && (!this.isXDomain() || io.util.ua.hasCORS)) {
                var self = this;
                io.util.on(global, 'beforeunload', function() {
                  self.disconnectSync();
                }, false);
              }
              if (this.options['auto connect']) {
                this.connect();
              }
            }
            ;
            io.util.mixin(Socket, io.EventEmitter);
            Socket.prototype.of = function(name) {
              if (!this.namespaces[name]) {
                this.namespaces[name] = new io.SocketNamespace(this, name);
                if (name !== '') {
                  this.namespaces[name].packet({type: 'connect'});
                }
              }
              return this.namespaces[name];
            };
            Socket.prototype.publish = function() {
              this.emit.apply(this, arguments);
              var nsp;
              for (var i in this.namespaces) {
                if (this.namespaces.hasOwnProperty(i)) {
                  nsp = this.of(i);
                  nsp.$emit.apply(nsp, arguments);
                }
              }
            };
            function empty() {}
            ;
            Socket.prototype.handshake = function(fn) {
              var self = this,
                  options = this.options;
              function complete(data) {
                if (data instanceof Error) {
                  self.connecting = false;
                  self.onError(data.message);
                } else {
                  fn.apply(null, data.split(':'));
                }
              }
              ;
              var url = ['http' + (options.secure ? 's' : '') + ':/', options.host + ':' + options.port, options.resource, io.protocol, io.util.query(this.options.query, 't=' + +new Date)].join('/');
              if (this.isXDomain() && !io.util.ua.hasCORS) {
                var insertAt = document.getElementsByTagName('script')[0],
                    script = document.createElement('script');
                script.src = url + '&jsonp=' + io.j.length;
                insertAt.parentNode.insertBefore(script, insertAt);
                io.j.push(function(data) {
                  complete(data);
                  script.parentNode.removeChild(script);
                });
              } else {
                var xhr = io.util.request();
                xhr.open('GET', url, true);
                if (this.isXDomain()) {
                  xhr.withCredentials = true;
                }
                xhr.onreadystatechange = function() {
                  if (xhr.readyState == 4) {
                    xhr.onreadystatechange = empty;
                    if (xhr.status == 200) {
                      complete(xhr.responseText);
                    } else if (xhr.status == 403) {
                      self.onError(xhr.responseText);
                    } else {
                      self.connecting = false;
                      !self.reconnecting && self.onError(xhr.responseText);
                    }
                  }
                };
                xhr.send(null);
              }
            };
            Socket.prototype.getTransport = function(override) {
              var transports = override || this.transports,
                  match;
              for (var i = 0,
                  transport; transport = transports[i]; i++) {
                if (io.Transport[transport] && io.Transport[transport].check(this) && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {
                  return new io.Transport[transport](this, this.sessionid);
                }
              }
              return null;
            };
            Socket.prototype.connect = function(fn) {
              if (this.connecting) {
                return this;
              }
              var self = this;
              self.connecting = true;
              this.handshake(function(sid, heartbeat, close, transports) {
                self.sessionid = sid;
                self.closeTimeout = close * 1000;
                self.heartbeatTimeout = heartbeat * 1000;
                if (!self.transports)
                  self.transports = self.origTransports = (transports ? io.util.intersect(transports.split(','), self.options.transports) : self.options.transports);
                self.setHeartbeatTimeout();
                function connect(transports) {
                  if (self.transport)
                    self.transport.clearTimeouts();
                  self.transport = self.getTransport(transports);
                  if (!self.transport)
                    return self.publish('connect_failed');
                  self.transport.ready(self, function() {
                    self.connecting = true;
                    self.publish('connecting', self.transport.name);
                    self.transport.open();
                    if (self.options['connect timeout']) {
                      self.connectTimeoutTimer = setTimeout(function() {
                        if (!self.connected) {
                          self.connecting = false;
                          if (self.options['try multiple transports']) {
                            var remaining = self.transports;
                            while (remaining.length > 0 && remaining.splice(0, 1)[0] != self.transport.name) {}
                            if (remaining.length) {
                              connect(remaining);
                            } else {
                              self.publish('connect_failed');
                            }
                          }
                        }
                      }, self.options['connect timeout']);
                    }
                  });
                }
                connect(self.transports);
                self.once('connect', function() {
                  clearTimeout(self.connectTimeoutTimer);
                  fn && typeof fn == 'function' && fn();
                });
              });
              return this;
            };
            Socket.prototype.setHeartbeatTimeout = function() {
              clearTimeout(this.heartbeatTimeoutTimer);
              if (this.transport && !this.transport.heartbeats())
                return;
              var self = this;
              this.heartbeatTimeoutTimer = setTimeout(function() {
                self.transport.onClose();
              }, this.heartbeatTimeout);
            };
            Socket.prototype.packet = function(data) {
              if (this.connected && !this.doBuffer) {
                this.transport.packet(data);
              } else {
                this.buffer.push(data);
              }
              return this;
            };
            Socket.prototype.setBuffer = function(v) {
              this.doBuffer = v;
              if (!v && this.connected && this.buffer.length) {
                if (!this.options['manualFlush']) {
                  this.flushBuffer();
                }
              }
            };
            Socket.prototype.flushBuffer = function() {
              this.transport.payload(this.buffer);
              this.buffer = [];
            };
            Socket.prototype.disconnect = function() {
              if (this.connected || this.connecting) {
                if (this.open) {
                  this.of('').packet({type: 'disconnect'});
                }
                this.onDisconnect('booted');
              }
              return this;
            };
            Socket.prototype.disconnectSync = function() {
              var xhr = io.util.request();
              var uri = ['http' + (this.options.secure ? 's' : '') + ':/', this.options.host + ':' + this.options.port, this.options.resource, io.protocol, '', this.sessionid].join('/') + '/?disconnect=1';
              xhr.open('GET', uri, false);
              xhr.send(null);
              this.onDisconnect('booted');
            };
            Socket.prototype.isXDomain = function() {
              var port = global.location.port || ('https:' == global.location.protocol ? 443 : 80);
              return this.options.host !== global.location.hostname || this.options.port != port;
            };
            Socket.prototype.onConnect = function() {
              if (!this.connected) {
                this.connected = true;
                this.connecting = false;
                if (!this.doBuffer) {
                  this.setBuffer(false);
                }
                this.emit('connect');
              }
            };
            Socket.prototype.onOpen = function() {
              this.open = true;
            };
            Socket.prototype.onClose = function() {
              this.open = false;
              clearTimeout(this.heartbeatTimeoutTimer);
            };
            Socket.prototype.onPacket = function(packet) {
              this.of(packet.endpoint).onPacket(packet);
            };
            Socket.prototype.onError = function(err) {
              if (err && err.advice) {
                if (err.advice === 'reconnect' && (this.connected || this.connecting)) {
                  this.disconnect();
                  if (this.options.reconnect) {
                    this.reconnect();
                  }
                }
              }
              this.publish('error', err && err.reason ? err.reason : err);
            };
            Socket.prototype.onDisconnect = function(reason) {
              var wasConnected = this.connected,
                  wasConnecting = this.connecting;
              this.connected = false;
              this.connecting = false;
              this.open = false;
              if (wasConnected || wasConnecting) {
                this.transport.close();
                this.transport.clearTimeouts();
                if (wasConnected) {
                  this.publish('disconnect', reason);
                  if ('booted' != reason && this.options.reconnect && !this.reconnecting) {
                    this.reconnect();
                  }
                }
              }
            };
            Socket.prototype.reconnect = function() {
              this.reconnecting = true;
              this.reconnectionAttempts = 0;
              this.reconnectionDelay = this.options['reconnection delay'];
              var self = this,
                  maxAttempts = this.options['max reconnection attempts'],
                  tryMultiple = this.options['try multiple transports'],
                  limit = this.options['reconnection limit'];
              function reset() {
                if (self.connected) {
                  for (var i in self.namespaces) {
                    if (self.namespaces.hasOwnProperty(i) && '' !== i) {
                      self.namespaces[i].packet({type: 'connect'});
                    }
                  }
                  self.publish('reconnect', self.transport.name, self.reconnectionAttempts);
                }
                clearTimeout(self.reconnectionTimer);
                self.removeListener('connect_failed', maybeReconnect);
                self.removeListener('connect', maybeReconnect);
                self.reconnecting = false;
                delete self.reconnectionAttempts;
                delete self.reconnectionDelay;
                delete self.reconnectionTimer;
                delete self.redoTransports;
                self.options['try multiple transports'] = tryMultiple;
              }
              ;
              function maybeReconnect() {
                if (!self.reconnecting) {
                  return;
                }
                if (self.connected) {
                  return reset();
                }
                ;
                if (self.connecting && self.reconnecting) {
                  return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);
                }
                if (self.reconnectionAttempts++ >= maxAttempts) {
                  if (!self.redoTransports) {
                    self.on('connect_failed', maybeReconnect);
                    self.options['try multiple transports'] = true;
                    self.transports = self.origTransports;
                    self.transport = self.getTransport();
                    self.redoTransports = true;
                    self.connect();
                  } else {
                    self.publish('reconnect_failed');
                    reset();
                  }
                } else {
                  if (self.reconnectionDelay < limit) {
                    self.reconnectionDelay *= 2;
                  }
                  self.connect();
                  self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);
                  self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
                }
              }
              ;
              this.options['try multiple transports'] = false;
              this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);
              this.on('connect', maybeReconnect);
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          (function(exports, io) {
            exports.SocketNamespace = SocketNamespace;
            function SocketNamespace(socket, name) {
              this.socket = socket;
              this.name = name || '';
              this.flags = {};
              this.json = new Flag(this, 'json');
              this.ackPackets = 0;
              this.acks = {};
            }
            ;
            io.util.mixin(SocketNamespace, io.EventEmitter);
            SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;
            SocketNamespace.prototype.of = function() {
              return this.socket.of.apply(this.socket, arguments);
            };
            SocketNamespace.prototype.packet = function(packet) {
              packet.endpoint = this.name;
              this.socket.packet(packet);
              this.flags = {};
              return this;
            };
            SocketNamespace.prototype.send = function(data, fn) {
              var packet = {
                type: this.flags.json ? 'json' : 'message',
                data: data
              };
              if ('function' == typeof fn) {
                packet.id = ++this.ackPackets;
                packet.ack = true;
                this.acks[packet.id] = fn;
              }
              return this.packet(packet);
            };
            SocketNamespace.prototype.emit = function(name) {
              var args = Array.prototype.slice.call(arguments, 1),
                  lastArg = args[args.length - 1],
                  packet = {
                    type: 'event',
                    name: name
                  };
              if ('function' == typeof lastArg) {
                packet.id = ++this.ackPackets;
                packet.ack = 'data';
                this.acks[packet.id] = lastArg;
                args = args.slice(0, args.length - 1);
              }
              packet.args = args;
              return this.packet(packet);
            };
            SocketNamespace.prototype.disconnect = function() {
              if (this.name === '') {
                this.socket.disconnect();
              } else {
                this.packet({type: 'disconnect'});
                this.$emit('disconnect');
              }
              return this;
            };
            SocketNamespace.prototype.onPacket = function(packet) {
              var self = this;
              function ack() {
                self.packet({
                  type: 'ack',
                  args: io.util.toArray(arguments),
                  ackId: packet.id
                });
              }
              ;
              switch (packet.type) {
                case 'connect':
                  this.$emit('connect');
                  break;
                case 'disconnect':
                  if (this.name === '') {
                    this.socket.onDisconnect(packet.reason || 'booted');
                  } else {
                    this.$emit('disconnect', packet.reason);
                  }
                  break;
                case 'message':
                case 'json':
                  var params = ['message', packet.data];
                  if (packet.ack == 'data') {
                    params.push(ack);
                  } else if (packet.ack) {
                    this.packet({
                      type: 'ack',
                      ackId: packet.id
                    });
                  }
                  this.$emit.apply(this, params);
                  break;
                case 'event':
                  var params = [packet.name].concat(packet.args);
                  if (packet.ack == 'data')
                    params.push(ack);
                  this.$emit.apply(this, params);
                  break;
                case 'ack':
                  if (this.acks[packet.ackId]) {
                    this.acks[packet.ackId].apply(this, packet.args);
                    delete this.acks[packet.ackId];
                  }
                  break;
                case 'error':
                  if (packet.advice) {
                    this.socket.onError(packet);
                  } else {
                    if (packet.reason == 'unauthorized') {
                      this.$emit('connect_failed', packet.reason);
                    } else {
                      this.$emit('error', packet.reason);
                    }
                  }
                  break;
              }
            };
            function Flag(nsp, name) {
              this.namespace = nsp;
              this.name = name;
            }
            ;
            Flag.prototype.send = function() {
              this.namespace.flags[this.name] = true;
              this.namespace.send.apply(this.namespace, arguments);
            };
            Flag.prototype.emit = function() {
              this.namespace.flags[this.name] = true;
              this.namespace.emit.apply(this.namespace, arguments);
            };
          })('undefined' != typeof io ? io : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, io, global) {
            exports.websocket = WS;
            function WS(socket) {
              io.Transport.apply(this, arguments);
            }
            ;
            io.util.inherit(WS, io.Transport);
            WS.prototype.name = 'websocket';
            WS.prototype.open = function() {
              var query = io.util.query(this.socket.options.query),
                  self = this,
                  Socket;
              if (!Socket) {
                Socket = global.MozWebSocket || global.WebSocket;
              }
              this.websocket = new Socket(this.prepareUrl() + query);
              this.websocket.onopen = function() {
                self.onOpen();
                self.socket.setBuffer(false);
              };
              this.websocket.onmessage = function(ev) {
                self.onData(ev.data);
              };
              this.websocket.onclose = function() {
                self.onClose();
                self.socket.setBuffer(true);
              };
              this.websocket.onerror = function(e) {
                self.onError(e);
              };
              return this;
            };
            if (io.util.ua.iDevice) {
              WS.prototype.send = function(data) {
                var self = this;
                setTimeout(function() {
                  self.websocket.send(data);
                }, 0);
                return this;
              };
            } else {
              WS.prototype.send = function(data) {
                this.websocket.send(data);
                return this;
              };
            }
            WS.prototype.payload = function(arr) {
              for (var i = 0,
                  l = arr.length; i < l; i++) {
                this.packet(arr[i]);
              }
              return this;
            };
            WS.prototype.close = function() {
              this.websocket.close();
              return this;
            };
            WS.prototype.onError = function(e) {
              this.socket.onError(e);
            };
            WS.prototype.scheme = function() {
              return this.socket.options.secure ? 'wss' : 'ws';
            };
            WS.check = function() {
              return ('WebSocket' in global && !('__addTask' in WebSocket)) || 'MozWebSocket' in global;
            };
            WS.xdomainCheck = function() {
              return true;
            };
            io.transports.push('websocket');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          (function(exports, io) {
            exports.flashsocket = Flashsocket;
            function Flashsocket() {
              io.Transport.websocket.apply(this, arguments);
            }
            ;
            io.util.inherit(Flashsocket, io.Transport.websocket);
            Flashsocket.prototype.name = 'flashsocket';
            Flashsocket.prototype.open = function() {
              var self = this,
                  args = arguments;
              WebSocket.__addTask(function() {
                io.Transport.websocket.prototype.open.apply(self, args);
              });
              return this;
            };
            Flashsocket.prototype.send = function() {
              var self = this,
                  args = arguments;
              WebSocket.__addTask(function() {
                io.Transport.websocket.prototype.send.apply(self, args);
              });
              return this;
            };
            Flashsocket.prototype.close = function() {
              WebSocket.__tasks.length = 0;
              io.Transport.websocket.prototype.close.call(this);
              return this;
            };
            Flashsocket.prototype.ready = function(socket, fn) {
              function init() {
                var options = socket.options,
                    port = options['flash policy port'],
                    path = ['http' + (options.secure ? 's' : '') + ':/', options.host + ':' + options.port, options.resource, 'static/flashsocket', 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'];
                if (!Flashsocket.loaded) {
                  if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {
                    WEB_SOCKET_SWF_LOCATION = path.join('/');
                  }
                  if (port !== 843) {
                    WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);
                  }
                  WebSocket.__initialize();
                  Flashsocket.loaded = true;
                }
                fn.call(self);
              }
              var self = this;
              if (document.body)
                return init();
              io.util.load(init);
            };
            Flashsocket.check = function() {
              if (typeof WebSocket == 'undefined' || !('__initialize' in WebSocket) || !swfobject)
                return false;
              return swfobject.getFlashPlayerVersion().major >= 10;
            };
            Flashsocket.xdomainCheck = function() {
              return true;
            };
            if (typeof window != 'undefined') {
              WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;
            }
            io.transports.push('flashsocket');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function() {
            if ('undefined' == typeof window || window.WebSocket)
              return;
            var console = window.console;
            if (!console || !console.log || !console.error) {
              console = {
                log: function() {},
                error: function() {}
              };
            }
            if (!swfobject.hasFlashPlayerVersion("10.0.0")) {
              console.error("Flash Player >= 10.0.0 is required.");
              return;
            }
            if (location.protocol == "file:") {
              console.error("WARNING: web-socket-js doesn't work in file:///... URL " + "unless you set Flash Security Settings properly. " + "Open the page via Web server i.e. http://...");
            }
            WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
              var self = this;
              self.__id = WebSocket.__nextId++;
              WebSocket.__instances[self.__id] = self;
              self.readyState = WebSocket.CONNECTING;
              self.bufferedAmount = 0;
              self.__events = {};
              if (!protocols) {
                protocols = [];
              } else if (typeof protocols == "string") {
                protocols = [protocols];
              }
              setTimeout(function() {
                WebSocket.__addTask(function() {
                  WebSocket.__flash.create(self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
                });
              }, 0);
            };
            WebSocket.prototype.send = function(data) {
              if (this.readyState == WebSocket.CONNECTING) {
                throw "INVALID_STATE_ERR: Web Socket connection has not been established";
              }
              var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
              if (result < 0) {
                return true;
              } else {
                this.bufferedAmount += result;
                return false;
              }
            };
            WebSocket.prototype.close = function() {
              if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
                return;
              }
              this.readyState = WebSocket.CLOSING;
              WebSocket.__flash.close(this.__id);
            };
            WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
              if (!(type in this.__events)) {
                this.__events[type] = [];
              }
              this.__events[type].push(listener);
            };
            WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
              if (!(type in this.__events))
                return;
              var events = this.__events[type];
              for (var i = events.length - 1; i >= 0; --i) {
                if (events[i] === listener) {
                  events.splice(i, 1);
                  break;
                }
              }
            };
            WebSocket.prototype.dispatchEvent = function(event) {
              var events = this.__events[event.type] || [];
              for (var i = 0; i < events.length; ++i) {
                events[i](event);
              }
              var handler = this["on" + event.type];
              if (handler)
                handler(event);
            };
            WebSocket.prototype.__handleEvent = function(flashEvent) {
              if ("readyState" in flashEvent) {
                this.readyState = flashEvent.readyState;
              }
              if ("protocol" in flashEvent) {
                this.protocol = flashEvent.protocol;
              }
              var jsEvent;
              if (flashEvent.type == "open" || flashEvent.type == "error") {
                jsEvent = this.__createSimpleEvent(flashEvent.type);
              } else if (flashEvent.type == "close") {
                jsEvent = this.__createSimpleEvent("close");
              } else if (flashEvent.type == "message") {
                var data = decodeURIComponent(flashEvent.message);
                jsEvent = this.__createMessageEvent("message", data);
              } else {
                throw "unknown event type: " + flashEvent.type;
              }
              this.dispatchEvent(jsEvent);
            };
            WebSocket.prototype.__createSimpleEvent = function(type) {
              if (document.createEvent && window.Event) {
                var event = document.createEvent("Event");
                event.initEvent(type, false, false);
                return event;
              } else {
                return {
                  type: type,
                  bubbles: false,
                  cancelable: false
                };
              }
            };
            WebSocket.prototype.__createMessageEvent = function(type, data) {
              if (document.createEvent && window.MessageEvent && !window.opera) {
                var event = document.createEvent("MessageEvent");
                event.initMessageEvent("message", false, false, data, null, null, window, null);
                return event;
              } else {
                return {
                  type: type,
                  data: data,
                  bubbles: false,
                  cancelable: false
                };
              }
            };
            WebSocket.CONNECTING = 0;
            WebSocket.OPEN = 1;
            WebSocket.CLOSING = 2;
            WebSocket.CLOSED = 3;
            WebSocket.__flash = null;
            WebSocket.__instances = {};
            WebSocket.__tasks = [];
            WebSocket.__nextId = 0;
            WebSocket.loadFlashPolicyFile = function(url) {
              WebSocket.__addTask(function() {
                WebSocket.__flash.loadManualPolicyFile(url);
              });
            };
            WebSocket.__initialize = function() {
              if (WebSocket.__flash)
                return;
              if (WebSocket.__swfLocation) {
                window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
              }
              if (!window.WEB_SOCKET_SWF_LOCATION) {
                console.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
                return;
              }
              var container = document.createElement("div");
              container.id = "webSocketContainer";
              container.style.position = "absolute";
              if (WebSocket.__isFlashLite()) {
                container.style.left = "0px";
                container.style.top = "0px";
              } else {
                container.style.left = "-100px";
                container.style.top = "-100px";
              }
              var holder = document.createElement("div");
              holder.id = "webSocketFlash";
              container.appendChild(holder);
              document.body.appendChild(container);
              swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION, "webSocketFlash", "1", "1", "10.0.0", null, null, {
                hasPriority: true,
                swliveconnect: true,
                allowScriptAccess: "always"
              }, null, function(e) {
                if (!e.success) {
                  console.error("[WebSocket] swfobject.embedSWF failed");
                }
              });
            };
            WebSocket.__onFlashInitialized = function() {
              setTimeout(function() {
                WebSocket.__flash = document.getElementById("webSocketFlash");
                WebSocket.__flash.setCallerUrl(location.href);
                WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
                for (var i = 0; i < WebSocket.__tasks.length; ++i) {
                  WebSocket.__tasks[i]();
                }
                WebSocket.__tasks = [];
              }, 0);
            };
            WebSocket.__onFlashEvent = function() {
              setTimeout(function() {
                try {
                  var events = WebSocket.__flash.receiveEvents();
                  for (var i = 0; i < events.length; ++i) {
                    WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
                  }
                } catch (e) {
                  console.error(e);
                }
              }, 0);
              return true;
            };
            WebSocket.__log = function(message) {
              console.log(decodeURIComponent(message));
            };
            WebSocket.__error = function(message) {
              console.error(decodeURIComponent(message));
            };
            WebSocket.__addTask = function(task) {
              if (WebSocket.__flash) {
                task();
              } else {
                WebSocket.__tasks.push(task);
              }
            };
            WebSocket.__isFlashLite = function() {
              if (!window.navigator || !window.navigator.mimeTypes) {
                return false;
              }
              var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
              if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
                return false;
              }
              return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
            };
            if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
              if (window.addEventListener) {
                window.addEventListener("load", function() {
                  WebSocket.__initialize();
                }, false);
              } else {
                window.attachEvent("onload", function() {
                  WebSocket.__initialize();
                });
              }
            }
          })();
          (function(exports, io, global) {
            exports.XHR = XHR;
            function XHR(socket) {
              if (!socket)
                return;
              io.Transport.apply(this, arguments);
              this.sendBuffer = [];
            }
            ;
            io.util.inherit(XHR, io.Transport);
            XHR.prototype.open = function() {
              this.socket.setBuffer(false);
              this.onOpen();
              this.get();
              this.setCloseTimeout();
              return this;
            };
            XHR.prototype.payload = function(payload) {
              var msgs = [];
              for (var i = 0,
                  l = payload.length; i < l; i++) {
                msgs.push(io.parser.encodePacket(payload[i]));
              }
              this.send(io.parser.encodePayload(msgs));
            };
            XHR.prototype.send = function(data) {
              this.post(data);
              return this;
            };
            function empty() {}
            ;
            XHR.prototype.post = function(data) {
              var self = this;
              this.socket.setBuffer(true);
              function stateChange() {
                if (this.readyState == 4) {
                  this.onreadystatechange = empty;
                  self.posting = false;
                  if (this.status == 200) {
                    self.socket.setBuffer(false);
                  } else {
                    self.onClose();
                  }
                }
              }
              function onload() {
                this.onload = empty;
                self.socket.setBuffer(false);
              }
              ;
              this.sendXHR = this.request('POST');
              if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {
                this.sendXHR.onload = this.sendXHR.onerror = onload;
              } else {
                this.sendXHR.onreadystatechange = stateChange;
              }
              this.sendXHR.send(data);
            };
            XHR.prototype.close = function() {
              this.onClose();
              return this;
            };
            XHR.prototype.request = function(method) {
              var req = io.util.request(this.socket.isXDomain()),
                  query = io.util.query(this.socket.options.query, 't=' + +new Date);
              req.open(method || 'GET', this.prepareUrl() + query, true);
              if (method == 'POST') {
                try {
                  if (req.setRequestHeader) {
                    req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
                  } else {
                    req.contentType = 'text/plain';
                  }
                } catch (e) {}
              }
              return req;
            };
            XHR.prototype.scheme = function() {
              return this.socket.options.secure ? 'https' : 'http';
            };
            XHR.check = function(socket, xdomain) {
              try {
                var request = io.util.request(xdomain),
                    usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),
                    socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),
                    isXProtocol = (global.location && socketProtocol != global.location.protocol);
                if (request && !(usesXDomReq && isXProtocol)) {
                  return true;
                }
              } catch (e) {}
              return false;
            };
            XHR.xdomainCheck = function(socket) {
              return XHR.check(socket, true);
            };
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          (function(exports, io) {
            exports.htmlfile = HTMLFile;
            function HTMLFile(socket) {
              io.Transport.XHR.apply(this, arguments);
            }
            ;
            io.util.inherit(HTMLFile, io.Transport.XHR);
            HTMLFile.prototype.name = 'htmlfile';
            HTMLFile.prototype.get = function() {
              this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
              this.doc.open();
              this.doc.write('<html></html>');
              this.doc.close();
              this.doc.parentWindow.s = this;
              var iframeC = this.doc.createElement('div');
              iframeC.className = 'socketio';
              this.doc.body.appendChild(iframeC);
              this.iframe = this.doc.createElement('iframe');
              iframeC.appendChild(this.iframe);
              var self = this,
                  query = io.util.query(this.socket.options.query, 't=' + +new Date);
              this.iframe.src = this.prepareUrl() + query;
              io.util.on(window, 'unload', function() {
                self.destroy();
              });
            };
            HTMLFile.prototype._ = function(data, doc) {
              data = data.replace(/\\\//g, '/');
              this.onData(data);
              try {
                var script = doc.getElementsByTagName('script')[0];
                script.parentNode.removeChild(script);
              } catch (e) {}
            };
            HTMLFile.prototype.destroy = function() {
              if (this.iframe) {
                try {
                  this.iframe.src = 'about:blank';
                } catch (e) {}
                this.doc = null;
                this.iframe.parentNode.removeChild(this.iframe);
                this.iframe = null;
                CollectGarbage();
              }
            };
            HTMLFile.prototype.close = function() {
              this.destroy();
              return io.Transport.XHR.prototype.close.call(this);
            };
            HTMLFile.check = function(socket) {
              if (typeof window != "undefined" && (['Active'].concat('Object').join('X')) in window) {
                try {
                  var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
                  return a && io.Transport.XHR.check(socket);
                } catch (e) {}
              }
              return false;
            };
            HTMLFile.xdomainCheck = function() {
              return false;
            };
            io.transports.push('htmlfile');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports);
          (function(exports, io, global) {
            exports['xhr-polling'] = XHRPolling;
            function XHRPolling() {
              io.Transport.XHR.apply(this, arguments);
            }
            ;
            io.util.inherit(XHRPolling, io.Transport.XHR);
            io.util.merge(XHRPolling, io.Transport.XHR);
            XHRPolling.prototype.name = 'xhr-polling';
            XHRPolling.prototype.heartbeats = function() {
              return false;
            };
            XHRPolling.prototype.open = function() {
              var self = this;
              io.Transport.XHR.prototype.open.call(self);
              return false;
            };
            function empty() {}
            ;
            XHRPolling.prototype.get = function() {
              if (!this.isOpen)
                return;
              var self = this;
              function stateChange() {
                if (this.readyState == 4) {
                  this.onreadystatechange = empty;
                  if (this.status == 200) {
                    self.onData(this.responseText);
                    self.get();
                  } else {
                    self.onClose();
                  }
                }
              }
              ;
              function onload() {
                this.onload = empty;
                this.onerror = empty;
                self.retryCounter = 1;
                self.onData(this.responseText);
                self.get();
              }
              ;
              function onerror() {
                self.retryCounter++;
                if (!self.retryCounter || self.retryCounter > 3) {
                  self.onClose();
                } else {
                  self.get();
                }
              }
              ;
              this.xhr = this.request();
              if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {
                this.xhr.onload = onload;
                this.xhr.onerror = onerror;
              } else {
                this.xhr.onreadystatechange = stateChange;
              }
              this.xhr.send(null);
            };
            XHRPolling.prototype.onClose = function() {
              io.Transport.XHR.prototype.onClose.call(this);
              if (this.xhr) {
                this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
                try {
                  this.xhr.abort();
                } catch (e) {}
                this.xhr = null;
              }
            };
            XHRPolling.prototype.ready = function(socket, fn) {
              var self = this;
              io.util.defer(function() {
                fn.call(self);
              });
            };
            io.transports.push('xhr-polling');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
          (function(exports, io, global) {
            var indicator = global.document && "MozAppearance" in global.document.documentElement.style;
            exports['jsonp-polling'] = JSONPPolling;
            function JSONPPolling(socket) {
              io.Transport['xhr-polling'].apply(this, arguments);
              this.index = io.j.length;
              var self = this;
              io.j.push(function(msg) {
                self._(msg);
              });
            }
            ;
            io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);
            JSONPPolling.prototype.name = 'jsonp-polling';
            JSONPPolling.prototype.post = function(data) {
              var self = this,
                  query = io.util.query(this.socket.options.query, 't=' + (+new Date) + '&i=' + this.index);
              if (!this.form) {
                var form = document.createElement('form'),
                    area = document.createElement('textarea'),
                    id = this.iframeId = 'socketio_iframe_' + this.index,
                    iframe;
                form.className = 'socketio';
                form.style.position = 'absolute';
                form.style.top = '0px';
                form.style.left = '0px';
                form.style.display = 'none';
                form.target = id;
                form.method = 'POST';
                form.setAttribute('accept-charset', 'utf-8');
                area.name = 'd';
                form.appendChild(area);
                document.body.appendChild(form);
                this.form = form;
                this.area = area;
              }
              this.form.action = this.prepareUrl() + query;
              function complete() {
                initIframe();
                self.socket.setBuffer(false);
              }
              ;
              function initIframe() {
                if (self.iframe) {
                  self.form.removeChild(self.iframe);
                }
                try {
                  iframe = document.createElement('<iframe name="' + self.iframeId + '">');
                } catch (e) {
                  iframe = document.createElement('iframe');
                  iframe.name = self.iframeId;
                }
                iframe.id = self.iframeId;
                self.form.appendChild(iframe);
                self.iframe = iframe;
              }
              ;
              initIframe();
              this.area.value = io.JSON.stringify(data);
              try {
                this.form.submit();
              } catch (e) {}
              if (this.iframe.attachEvent) {
                iframe.onreadystatechange = function() {
                  if (self.iframe.readyState == 'complete') {
                    complete();
                  }
                };
              } else {
                this.iframe.onload = complete;
              }
              this.socket.setBuffer(true);
            };
            JSONPPolling.prototype.get = function() {
              var self = this,
                  script = document.createElement('script'),
                  query = io.util.query(this.socket.options.query, 't=' + (+new Date) + '&i=' + this.index);
              if (this.script) {
                this.script.parentNode.removeChild(this.script);
                this.script = null;
              }
              script.async = true;
              script.src = this.prepareUrl() + query;
              script.onerror = function() {
                self.onClose();
              };
              var insertAt = document.getElementsByTagName('script')[0];
              insertAt.parentNode.insertBefore(script, insertAt);
              this.script = script;
              if (indicator) {
                setTimeout(function() {
                  var iframe = document.createElement('iframe');
                  document.body.appendChild(iframe);
                  document.body.removeChild(iframe);
                }, 100);
              }
            };
            JSONPPolling.prototype._ = function(msg) {
              this.onData(msg);
              if (this.isOpen) {
                this.get();
              }
              return this;
            };
            JSONPPolling.prototype.ready = function(socket, fn) {
              var self = this;
              if (!indicator)
                return fn.call(this);
              io.util.load(function() {
                fn.call(self);
              });
            };
            JSONPPolling.check = function() {
              return 'document' in global;
            };
            JSONPPolling.xdomainCheck = function() {
              return true;
            };
            io.transports.push('jsonp-polling');
          })('undefined' != typeof io ? io.Transport : module.exports, 'undefined' != typeof io ? io : module.parent.exports, this);
        })();
      }, {}],
      20: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          var warn = function() {
            console.log.apply(console, arguments);
            return undefined;
          };
          var debug = function() {};
          exports.debug = function(cb) {
            debug = cb;
          };
          var info = function() {};
          exports.info = function(cb) {
            info = cb;
          };
          var defaults = exports.defaults = {};
          defaults.chan_timeout = 10000;
          defaults.seek_timeout = 3000;
          defaults.chan_autoack = 1000;
          defaults.chan_resend = 2000;
          defaults.chan_outbuf = 100;
          defaults.chan_inbuf = 50;
          defaults.nat_timeout = 30 * 1000;
          defaults.idle_timeout = 2 * defaults.nat_timeout;
          defaults.link_timer = defaults.nat_timeout - (5 * 1000);
          defaults.link_max = 256;
          defaults.link_k = 8;
          var pathShareOrder = ["bluetooth", "webrtc", "ipv6", "ipv4", "http"];
          exports.switch = function() {
            var self = {
              seeds: [],
              locals: [],
              lines: {},
              bridges: {},
              bridgeLine: {},
              all: {},
              buckets: [],
              capacity: [],
              rels: {},
              raws: {},
              paths: [],
              bridgeCache: {},
              networks: {},
              CSets: {}
            };
            self.load = function(id) {
              if (typeof id != "object")
                return "bad keys";
              self.id = id;
              var err = loadkeys(self);
              if (err)
                return err;
              if (Object.keys(self.cs).length == 0)
                return "missing cipher sets";
              self.hashname = parts2hn(self.parts);
              return false;
            };
            self.make = keysgen;
            self.seed = true;
            self.pcounter = 1;
            self.receive = receive;
            self.deliver = function(type, callback) {
              self.networks[type] = callback;
            };
            self.send = function(path, msg, to) {
              if (!msg)
                return debug("send called w/ no packet, dropping", new Error().stack) && false;
              if (!path)
                return debug("send called w/ no path, dropping", new Error().stack) && false;
              if (!self.networks[path.type])
                return false;
              if (to)
                path = to.pathOut(path);
              debug("<<<<", Date(), msg.length, path && [path.type, path.ip, path.port, path.id].join(","), to && to.hashname);
              return self.networks[path.type](path, msg, to);
            };
            self.pathSet = function(path, del) {
              var existing;
              if (!path)
                return;
              if ((existing = pathMatch(path, self.paths))) {
                if (del)
                  self.paths.splice(self.paths.indexOf(existing), 1);
                return;
              }
              debug("local path add", JSON.stringify(path));
              info("self", path.type, JSON.stringify(path));
              self.paths.push(path);
              if (self.isOnline) {
                linkMaint(self);
              }
            };
            self.addSeed = addSeed;
            self.whois = whois;
            self.whokey = whokey;
            self.start = function(hashname, type, arg, cb) {
              var hn = self.whois(hashname);
              if (!hn)
                return cb("invalid hashname");
              return hn.start(type, arg, cb);
            };
            self.online = online;
            self.listen = function(type, callback) {
              if (typeof type != "string" || typeof callback != "function")
                return warn("invalid arguments to listen");
              if (type.substr(0, 1) !== "_")
                type = "_" + type;
              self.rels[type] = callback;
            };
            self.raw = function(type, callback) {
              if (typeof type != "string" || typeof callback != "function")
                return warn("invalid arguments to raw");
              self.raws[type] = callback;
            };
            self.raws["peer"] = inPeer;
            self.raws["connect"] = inConnect;
            self.raws["seek"] = inSeek;
            self.raws["path"] = inPath;
            self.raws["link"] = inLink;
            self.seek = seek;
            self.pencode = pencode;
            self.pdecode = pdecode;
            self.isLocalIP = isLocalIP;
            self.randomHEX = randomHEX;
            self.uriparse = uriparse;
            self.pathMatch = pathMatch;
            self.isHashname = function(hex) {
              return isHEX(hex, 64);
            };
            self.isBridge = isBridge;
            self.wraps = channelWraps;
            self.waits = [];
            self.waiting = false;
            self.wait = function(bool) {
              if (bool)
                return self.waits.push(true);
              self.waits.pop();
              if (self.waiting && self.waits.length == 0)
                self.waiting();
            };
            self.ping = function() {
              if (!self.tracer)
                self.tracer = randomHEX(16);
              var js = {
                type: "ping",
                trace: self.tracer
              };
              Object.keys(self.parts).forEach(function(csid) {
                js[csid] = true;
              });
              return js;
            };
            linkLoop(self);
            return self;
          };
          var channelWraps = {"bulk": function(chan) {
              var bulkIn = "";
              chan.callback = function(end, packet, chan, cb) {
                cb();
                if (packet.body)
                  bulkIn += packet.body;
                if (!chan.onBulk)
                  return;
                if (end)
                  chan.onBulk(end !== true ? end : false, bulkIn);
              };
              chan.bulk = function(data, callback) {
                while (data) {
                  var chunk = data.substr(0, 1000);
                  data = data.substr(1000);
                  var packet = {body: chunk};
                  if (!data)
                    packet.callback = callback;
                  chan.send(packet);
                }
                chan.end();
              };
            }};
          function linkLoop(self) {
            self.bridgeCache = {};
            linkMaint(self);
            setTimeout(function() {
              linkLoop(self);
            }, defaults.link_timer);
          }
          function hnReap(self) {
            var hn;
            function del(why) {
              if (hn.lineOut)
                delete self.lines[hn.lineOut];
              delete self.all[hn.hashname];
              debug("reaping ", hn.hashname, why);
            }
            Object.keys(self.all).forEach(function(h) {
              hn = self.all[h];
              debug("reap check", hn.hashname, Date.now() - hn.sentAt, Date.now() - hn.recvAt, Object.keys(hn.chans).length);
              if (hn.isSeed)
                return;
              if (Object.keys(hn.chans).length > 0)
                return;
              if (Date.now() - hn.at < hn.timeout())
                return;
              if (!hn.sentAt)
                return del("never sent anything, gc");
              if (!hn.recvAt)
                return del("sent open, never received");
              if (Date.now() - hn.sentAt > hn.timeout())
                return del("we stopped sending to them");
              if (Date.now() - hn.recvAt > hn.timeout())
                return del("they stopped responding to us");
            });
          }
          function linkMaint(self) {
            Object.keys(self.buckets).forEach(function(bucket) {
              var sorted = self.buckets[bucket].sort(function(a, b) {
                return a.age - b.age;
              });
              if (sorted.length)
                debug("link maintenance on bucket", bucket, sorted.length);
              sorted.slice(0, defaults.link_k).forEach(function(hn) {
                if (!hn.linked || !pathValid(hn.to))
                  return;
                if ((Date.now() - hn.linked.sentAt) < Math.ceil(defaults.link_timer / 2))
                  return;
                hn.linked.send({js: {seed: self.seed}});
              });
            });
          }
          function isBridge(arg) {
            var self = this;
            if (arg === true)
              self.bridging = true;
            if (self.bridging)
              return true;
            if (!arg)
              return self.bridging;
            var check = (typeof arg == "string") ? self.whois(arg) : arg;
            if (check && check.bridging)
              return true;
            return false;
          }
          function addSeed(arg) {
            var self = this;
            if (!arg.parts)
              return warn("invalid args to addSeed", arg);
            var seed = self.whokey(arg.parts, false, arg.keys);
            if (!seed)
              return warn("invalid seed info", arg);
            if (Array.isArray(arg.paths))
              arg.paths.forEach(function(path) {
                path = seed.pathGet(path);
                path.seed = true;
              });
            seed.isSeed = true;
            self.seeds.push(seed);
          }
          function online(callback) {
            var self = this;
            if (self.waits.length > 0)
              return self.waiting = function() {
                self.online(callback);
              };
            self.isOnline = true;
            self.send({type: "lan"}, pencode(self.ping()));
            var dones = self.seeds.length;
            if (!dones) {
              warn("no seeds");
              return callback(null, 0);
            }
            function done() {
              if (!dones)
                return;
              var alive = self.seeds.filter(function(seed) {
                return pathValid(seed.to);
              }).length;
              if (alive) {
                callback(null, alive);
                dones = 0;
                return;
              }
              dones--;
              if (!dones)
                callback(self.locals.length ? null : "offline", self.locals.length);
            }
            self.seeds.forEach(function(seed) {
              seed.link(function() {
                if (pathValid(seed.to))
                  seed.pathSync();
                done();
              });
            });
          }
          function receive(msg, path) {
            var self = this;
            var packet = pdecode(msg);
            if (!packet)
              return warn("failed to decode a packet from", path, (new Buffer(msg)).toString("hex"));
            if (packet.length == 2)
              return;
            packet.sender = path;
            packet.id = self.pcounter++;
            packet.at = Date.now();
            debug(">>>>", Date(), msg.length, packet.head.length, path && [path.type, path.ip, path.port, path.id].join(","));
            if (packet.js.type == "ping")
              return inPing(self, packet);
            if (packet.js.type == "pong")
              return inPong(self, packet);
            if (packet.head.length == 1) {
              var open = deopenize(self, packet);
              if (!open || !open.verify)
                return warn("couldn't decode open (possibly using the wrong public key?)", open && open.err);
              if (!isHEX(open.js.line, 32))
                return warn("invalid line id enclosed", open.js.line);
              if (open.js.to !== self.hashname)
                return warn("open for wrong hashname", open.js.to);
              var csid = partsMatch(self.parts, open.js.from);
              if (csid != open.csid)
                return warn("open with mismatch CSID", csid, open.csid);
              var from = self.whokey(open.js.from, open.key);
              if (!from)
                return warn("invalid hashname", open.js.from);
              from.csid = open.csid;
              if (typeof open.js.at != "number")
                return warn("invalid at", open.js.at);
              if (from.openAt && open.js.at < from.openAt)
                return debug("dropping older open");
              from.openAt = open.js.at;
              debug("inOpen verified", from.hashname, path && JSON.stringify(path.json));
              if (open.js.line == from.lineIn) {
                var age = Date.now() - (from.openAcked || 0);
                if ((age < defaults.seek_timeout) || (age < defaults.nat_timeout && from.openDup >= 3))
                  return;
                from.openDup++;
              } else {
                from.openDup = 0;
              }
              var openAck = from.open();
              from.active();
              from.openAcked = Date.now();
              path = from.pathIn(path);
              if (path)
                self.send(path, openAck, from);
              else if (from.relayChan)
                from.relayChan.send({body: openAck});
              if (open.js.line != from.lineIn) {
                from.lineIn = open.js.line;
                debug("new line", from.lineIn, from.lineOut);
                self.CSets[open.csid].openline(from, open);
                self.lines[from.lineOut] = from;
                Object.keys(from.chans).forEach(function(id) {
                  var chan = from.chans[id];
                  if (chan) {
                    if (!chan.recvAt)
                      return;
                    from.receive({js: {
                        c: chan.id,
                        err: "reset"
                      }});
                  }
                  delete from.chans[id];
                });
              }
              return;
            }
            if (packet.head.length == 0) {
              var lineID = packet.body.slice(0, 16).toString("hex");
              var from = self.lines[lineID];
              if (!from) {
                if (!self.bridgeLine[lineID])
                  return debug("unknown line received", lineID, packet.sender);
                debug("BRIDGE", JSON.stringify(self.bridgeLine[lineID]), lineID);
                var id = crypto.createHash("sha256").update(packet.body).digest("hex");
                if (self.bridgeCache[id])
                  return;
                self.bridgeCache[id] = true;
                return self.send(self.bridgeLine[lineID], pencode(false, packet.body));
              }
              var err;
              if ((err = self.CSets[from.csid].delineize(from, packet)))
                return debug("couldn't decrypt line", err, packet.sender);
              from.linedAt = from.openAt;
              from.active();
              from.receive(packet);
              return;
            }
            if (Object.keys(packet.js).length > 0)
              warn("dropping incoming packet of unknown type", packet.js, packet.sender);
          }
          function whokey(parts, key, keys) {
            var self = this;
            if (typeof parts != "object")
              return false;
            var csid = partsMatch(self.parts, parts);
            if (!csid)
              return false;
            var hn = self.whois(parts2hn(parts));
            if (!hn)
              return false;
            if (keys)
              key = keys[csid];
            var err = loadkey(self, hn, csid, key);
            if (err) {
              warn("whokey err", hn.hashname, err);
              return false;
            }
            if (crypto.createHash("sha256").update(hn.key).digest("hex") != parts[csid]) {
              warn("whokey part mismatch", hn.hashname, csid, parts[csid], crypto.createHash("sha256").update(hn.key).digest("hex"));
              delete hn.key;
              return false;
            }
            hn.parts = parts;
            return hn;
          }
          function whois(hashname) {
            var self = this;
            if (!hashname) {
              warn("whois called without a hashname", hashname, new Error().stack);
              return false;
            }
            if (typeof hashname != "string") {
              warn("wrong type, should be string", typeof hashname, hashname);
              return false;
            }
            if (!isHEX(hashname, 64)) {
              warn("whois called without a valid hashname", hashname);
              return false;
            }
            if (hashname === self.hashname) {
              debug("whois called for self");
              return false;
            }
            var hn = self.all[hashname];
            if (hn)
              return hn;
            hn = self.all[hashname] = {
              hashname: hashname,
              chans: {},
              self: self,
              paths: [],
              isAlive: 0,
              sendwait: []
            };
            hn.at = Date.now();
            hn.bucket = dhash(self.hashname, hashname);
            if (!self.buckets[hn.bucket])
              self.buckets[hn.bucket] = [];
            var sort = [self.hashname, hashname].sort();
            hn.chanOut = (sort[0] == self.hashname) ? 2 : 1;
            hn.start = channel;
            hn.raw = raw;
            hn.pathGet = function(path) {
              if (typeof path != "object" || typeof path.type != "string")
                return false;
              var match = pathMatch(path, hn.paths);
              if (match)
                return match;
              path = JSON.parse(JSON.stringify(path));
              if (!path.json)
                path.json = JSON.parse(JSON.stringify(path));
              debug("adding new path", hn.paths.length, JSON.stringify(path.json));
              info(hn.hashname, path.type, JSON.stringify(path.json));
              hn.paths.push(path);
              if (!isLocalPath(path))
                hn.isPublic = true;
              if (path.type == "ipv4")
                self.paths.forEach(function(path2) {
                  if (path2.type == "ipv4" && path2.ip == path.ip)
                    hn.isLocal = true;
                });
              return path;
            };
            hn.pathOut = function(path) {
              path = hn.pathGet(path);
              if (!path)
                return false;
              if (!path.sentAt && path.type == "ipv4")
                self.send(path, pencode());
              path.sentAt = Date.now();
              if (!pathValid(hn.to) && pathValid(path))
                hn.to = path;
              return path;
            };
            hn.pathEnd = function(path) {
              if (path.seed)
                return false;
              if (hn.to == path)
                hn.to = false;
              path.gone = true;
              var index = hn.paths.indexOf(path);
              if (index >= 0)
                hn.paths.splice(index, 1);
              debug("PATH END", JSON.stringify(path.json));
              return false;
            };
            hn.pathIn = function(path) {
              path = hn.pathGet(path);
              if (!path)
                return false;
              if (!path.recvAt && !path.sentAt) {
                debug("PATH INNEW", isLocalPath(path) ? "local" : "public", JSON.stringify(path.json), hn.paths.map(function(p) {
                  return JSON.stringify(p.json);
                }));
                if (path.type == "ipv4" && !isLocalIP(path.ip)) {
                  hn.ip = path.ip;
                  hn.port = path.port;
                }
                hn.paths.forEach(function(other) {
                  if (other == path)
                    return;
                  if (other.type != path.type)
                    return;
                  if (!pathValid(other))
                    return hn.pathEnd(other);
                  if (path.ip && other.ip == path.ip)
                    return hn.pathEnd(other);
                  if (path.type == "http")
                    return hn.pathEnd(other);
                });
                if (pathShareOrder.indexOf(path.type) == -1)
                  hn.bridging = true;
                if (isLocalPath(path) && !hn.isLocal) {
                  hn.isLocal = true;
                  hn.pathSync();
                }
              }
              path.recvAt = Date.now();
              hn.to = path;
              return path;
            };
            hn.active = function() {
              self.recvAt = Date.now();
              if (!hn.recvAt || (Date.now() - hn.recvAt) > defaults.nat_timeout)
                setTimeout(function() {
                  hn.pathSync();
                }, 10);
              hn.recvAt = Date.now();
              hn.sendwait.forEach(function(packet) {
                if (!hn.chans[packet.js.c])
                  return;
                hn.send(packet);
              });
              hn.sendwait = [];
            };
            hn.send = function(packet) {
              if (Buffer.isBuffer(packet))
                console.log("lined packet?!", hn.hashname, typeof hn.sendwait.length, new Error().stack);
              if (hn.lineIn) {
                debug("line sending", hn.hashname, hn.lineIn);
                var lined = self.CSets[hn.csid].lineize(hn, packet);
                hn.sentAt = Date.now();
                if (packet.to)
                  return self.send(packet.to, lined, hn);
                if (pathValid(hn.to))
                  return self.send(hn.to, lined, hn);
                if (hn.relayChan)
                  return hn.relayChan.send({body: lined});
              }
              hn.openAt = false;
              if (hn.sendwait.indexOf(packet) == -1)
                hn.sendwait.push(packet);
              debug("alive failthrough", hn.sendSeek, Object.keys(hn.vias || {}));
              if (hn.open())
                hn.paths.forEach(function(path) {
                  self.send(path, hn.open(), hn);
                });
              function vias() {
                if (!hn.vias)
                  return;
                var todo = hn.vias;
                delete hn.vias;
                Object.keys(todo).forEach(function(via) {
                  self.whois(via).peer(hn.hashname, todo[via]);
                });
              }
              if (hn.vias)
                return vias();
              if (!hn.sendSeek || (Date.now() - hn.sendSeek) > 5000) {
                hn.sendSeek = Date.now();
                self.seek(hn, function(err) {
                  if (!hn.sendwait.length)
                    return;
                  vias();
                });
              }
            };
            hn.receive = function(packet) {
              if (!packet.js || typeof packet.js.c != "number")
                return warn("dropping invalid channel packet", packet.js);
              packet.sender = hn.pathIn(packet.sender);
              packet.from = hn;
              var chan = hn.chans[packet.js.c];
              debug("LINEIN", chan && chan.type, JSON.stringify(packet.js), packet.body && packet.body.length);
              if (chan === false)
                return;
              if (chan)
                return chan.receive(packet);
              var listening = {};
              if (typeof packet.js.seq == "undefined")
                listening = self.raws;
              if (packet.js.seq === 0)
                listening = self.rels;
              if (!listening[packet.js.type])
                return;
              if (packet.js.c % 2 == hn.chanOut % 2)
                return warn("channel id incorrect", packet.js.c, hn.chanOut);
              var kind = (listening == self.raws) ? "raw" : "start";
              var chan = hn[kind](packet.js.type, {
                bare: true,
                id: packet.js.c
              }, listening[packet.js.type]);
              chan.receive(packet);
            };
            hn.chanEnded = function(id) {
              if (!hn.chans[id])
                return;
              debug("channel ended", id, hn.chans[id].type, hn.hashname);
              hn.chans[id] = false;
            };
            hn.sees = function(address) {
              if (typeof address != "string")
                warn("invalid see address", address, hn.hashname);
              if (typeof address != "string")
                return false;
              var parts = address.split(",");
              if (!self.isHashname(parts[0]) || parts[0] == self.hashname)
                return false;
              var see = self.whois(parts[0]);
              if (!see)
                return false;
              if (parts.length >= 4 && parts[2].split(".").length == 4 && parseInt(parts[3]) > 0)
                see.pathGet({
                  type: "ipv4",
                  ip: parts[2],
                  port: parseInt(parts[3])
                });
              if (!see.vias)
                see.vias = {};
              see.vias[hn.hashname] = see.cisd || parts[1];
              return see;
            };
            hn.seek = function(hashname, callback) {
              var bucket = dhash(hn.hashname, hashname);
              var prefix = hashname.substr(0, Math.ceil((255 - bucket) / 4) + 2);
              hn.raw("seek", {
                timeout: defaults.seek_timeout,
                retry: 3,
                js: {"seek": prefix}
              }, function(err, packet, chan) {
                callback(packet.js.err, Array.isArray(packet.js.see) ? packet.js.see : []);
              });
            };
            hn.address = function(to) {
              if (!to)
                return "";
              var csid = partsMatch(hn.parts, to.parts);
              if (!csid)
                return "";
              if (!hn.ip)
                return [hn.hashname, csid].join(",");
              return [hn.hashname, csid, hn.ip, hn.port].join(",");
            };
            hn.link = function(callback) {
              if (!callback)
                callback = function() {};
              debug("LINKTRY", hn.hashname);
              var js = {seed: self.seed};
              js.see = self.buckets[hn.bucket].sort(function(a, b) {
                return a.age - b.age;
              }).filter(function(a) {
                return a.seed;
              }).map(function(seed) {
                return seed.address(hn);
              }).slice(0, 8);
              if (js.see.length < 8)
                Object.keys(self.buckets).forEach(function(bucket) {
                  if (js.see.length >= 8)
                    return;
                  self.buckets[bucket].sort(function(a, b) {
                    return a.age - b.age;
                  }).forEach(function(seed) {
                    if (js.see.length >= 8 || !seed.seed || js.see.indexOf(seed.address(hn)) != -1)
                      return;
                    js.see.push(seed.address(hn));
                  });
                });
              if (self.isBridge(hn))
                js.bridges = self.paths.filter(function(path) {
                  return !isLocalPath(path);
                }).map(function(path) {
                  return path.type;
                });
              if (hn.linked) {
                hn.linked.send({js: js});
                return callback();
              }
              hn.linked = hn.raw("link", {
                retry: 3,
                js: js,
                timeout: defaults.idle_timeout
              }, function(err, packet, chan) {
                inLink(err, packet, chan);
                callback(packet.js.err);
              });
            };
            hn.peer = function(hashname, csid) {
              if (!csid || !self.parts[csid])
                return;
              var js = {"peer": hashname};
              js.paths = hn.pathsOut();
              hn.raw("peer", {
                timeout: defaults.nat_timeout,
                js: js,
                body: getkey(self, csid)
              }, function(err, packet, chan) {
                if (!chan.relayTo)
                  chan.relayTo = self.whois(hashname);
                inRelay(chan, packet);
              });
            };
            hn.open = function() {
              if (!hn.parts)
                return false;
              if (!hn.opened)
                hn.opened = openize(self, hn);
              return hn.opened;
            };
            hn.pathsOut = function() {
              var paths = [];
              self.paths.forEach(function(path) {
                if (isLocalPath(path) && !hn.isLocal)
                  return;
                paths.push(path);
              });
              return paths;
            };
            hn.pathSync = function() {
              if (hn.pathSyncing)
                return;
              hn.pathSyncing = true;
              debug("pathSync", hn.hashname);
              var js = {};
              var paths = hn.pathsOut();
              if (paths.length > 0)
                js.paths = paths;
              var alive = [];
              hn.raw("path", {
                js: js,
                timeout: 10 * 1000
              }, function(err, packet) {
                if (err) {
                  hn.pathSyncing = false;
                  return;
                }
                if (packet.from.isSeed && typeof packet.js.path == "object" && packet.js.path.type == "ipv4" && !isLocalIP(packet.js.path.ip)) {
                  debug("updating public ipv4", JSON.stringify(self.pub4), JSON.stringify(packet.js.path));
                  self.pathSet(self.pub4, true);
                  self.pub4 = {
                    type: "ipv4",
                    ip: packet.js.path.ip,
                    port: parseInt(packet.js.path.port)
                  };
                  self.pathSet(self.pub4);
                }
                if (!packet.sender)
                  return;
                alive.push(packet.sender);
                var best = packet.sender;
                alive.forEach(function(path) {
                  if (pathShareOrder.indexOf(best.type) < pathShareOrder.indexOf(path.type))
                    return;
                  if (isLocalPath(best))
                    return;
                  best = path;
                });
                debug("pathSync best", hn.hashname, JSON.stringify(best.json));
                hn.to = best;
              });
            };
            hn.ticket = function(packet) {
              if (self.pencode(packet).length > 1024)
                return false;
              return ticketize(self, hn, packet);
            };
            hn.ticketed = function(ticket) {
              packet = pdecode(ticket);
              if (!packet)
                return false;
              return deticketize(self, hn, packet);
            };
            return hn;
          }
          function seek(hn, callback) {
            var self = this;
            if (typeof hn == "string")
              hn = self.whois(hn);
            if (!callback)
              callback = function() {};
            if (!hn)
              return callback("invalid hashname");
            var did = {};
            var doing = {};
            var queue = [];
            var wise = {};
            var closest = 255;
            var seeds = [];
            Object.keys(self.buckets).forEach(function(bucket) {
              self.buckets[bucket].forEach(function(link) {
                if (link.hashname == hn)
                  return;
                if (link.seed && pathValid(link.to))
                  seeds.push(link);
              });
            });
            seeds.sort(function(a, b) {
              return dhash(hn.hashname, a.hashname) - dhash(hn.hashname, b.hashname);
            }).slice(0, 3).forEach(function(seed) {
              wise[seed.hashname] = true;
              queue.push(seed.hashname);
            });
            debug("seek starting with", queue, seeds.length);
            function sort() {
              queue = queue.sort(function(a, b) {
                return dhash(hn.hashname, a) - dhash(hn.hashname, b);
              });
            }
            function done(err) {
              Object.keys(did).forEach(function(k) {
                if (queue.indexOf(k) == -1)
                  queue.push(k);
              });
              Object.keys(doing).forEach(function(k) {
                if (queue.indexOf(k) == -1)
                  queue.push(k);
              });
              sort();
              while (cb = hn.seeking.shift())
                cb(err, queue.slice());
            }
            if (!hn.seeking)
              hn.seeking = [];
            hn.seeking.push(callback);
            if (hn.seeking.length > 1)
              return;
            function loop(onetime) {
              if (!hn.seeking.length)
                return;
              debug("SEEK LOOP", queue);
              if (Object.keys(doing).length == 0 && queue.length == 0)
                return done("failed to find the hashname");
              var mine = onetime || queue.shift();
              if (!mine)
                return;
              if (mine == hn.hashname)
                return done();
              if (did[mine] || doing[mine])
                return onetime || loop();
              var distance = dhash(hn.hashname, mine);
              if (distance > closest)
                return onetime || loop();
              if (wise[mine])
                closest = distance;
              doing[mine] = true;
              var to = self.whois(mine);
              to.seek(hn.hashname, function(err, sees) {
                sees.forEach(function(address) {
                  var see = to.sees(address);
                  if (!see)
                    return;
                  if (wise[to.hashname] && sees.indexOf(address) == 0)
                    wise[see.hashname] = true;
                  queue.push(see.hashname);
                });
                sort();
                did[mine] = true;
                delete doing[mine];
                onetime || loop();
              });
            }
            loop();
            loop();
            loop();
            self.locals.forEach(function(local) {
              loop(local.hashname);
            });
          }
          function raw(type, arg, callback) {
            var hn = this;
            var chan = {
              type: type,
              callback: callback
            };
            chan.id = arg.id;
            chan.startAt = Date.now();
            if (!chan.id) {
              chan.id = hn.chanOut;
              hn.chanOut += 2;
            }
            chan.isOut = (chan.id % 2 == hn.chanOut % 2);
            hn.chans[chan.id] = chan;
            function timer() {
              if (chan.timer)
                clearTimeout(chan.timer);
              chan.timer = setTimeout(function() {
                if (!chan.ended)
                  return hn.receive({js: {
                      err: "timeout",
                      c: chan.id
                    }});
                hn.chanEnded(chan.id);
              }, arg.timeout);
            }
            chan.timeout = function(timeout) {
              arg.timeout = timeout;
              timer();
            };
            chan.timeout(arg.timeout || defaults.chan_timeout);
            chan.hashname = hn.hashname;
            debug("new unreliable channel", hn.hashname, chan.type, chan.id);
            chan.receive = function(packet) {
              if (!hn.chans[chan.id])
                return debug("dropping receive packet to dead channel", chan.id, packet.js);
              chan.opened = true;
              chan.ended = chan.ended || packet.js.err || packet.js.end;
              chan.recvAt = Date.now();
              chan.last = packet.sender;
              chan.callback(chan.ended, packet, chan);
              timer();
            };
            chan.send = function(packet) {
              if (!hn.chans[chan.id])
                return debug("dropping send packet to dead channel", chan.id, packet.js);
              if (!packet.js)
                packet.js = {};
              packet.js.c = chan.id;
              chan.ended = chan.ended || packet.js.err || packet.js.end;
              chan.sentAt = Date.now();
              debug("SEND", chan.type, JSON.stringify(packet.js), packet.body && packet.body.length);
              hn.send(packet);
            };
            chan.end = function() {
              if (chan.ended)
                return;
              chan.send({js: {end: true}});
            };
            chan.fail = function(err) {
              if (chan.ended)
                return;
              chan.ended = err || "failed";
              hn.send({js: {
                  err: chan.ended,
                  c: chan.id
                }});
            };
            if (arg.js) {
              arg.js.type = type;
              chan.send(arg);
              if (arg.retry) {
                var at = 1000;
                function retry() {
                  if (chan.ended || chan.opened)
                    return;
                  chan.send(arg);
                  if (at < 4000)
                    at *= 2;
                  arg.retry--;
                  if (arg.retry)
                    setTimeout(retry, at);
                }
                ;
                setTimeout(retry, at);
              }
            }
            return chan;
          }
          function channel(type, arg, callback) {
            var hn = this;
            var chan = {
              inq: [],
              outq: [],
              outSeq: 0,
              inDone: -1,
              outConfirmed: -1,
              lastAck: -1,
              callback: callback
            };
            chan.id = arg.id;
            chan.startAt = Date.now();
            if (!chan.id) {
              chan.id = hn.chanOut;
              hn.chanOut += 2;
            }
            chan.isOut = (chan.id % 2 == hn.chanOut % 2);
            hn.chans[chan.id] = chan;
            if (!arg.bare && type.substr(0, 1) !== "_")
              type = "_" + type;
            chan.type = type;
            if (chan.type.substr(0, 1) != "_")
              chan.safe = true;
            chan.hashname = hn.hashname;
            debug("new channel", hn.hashname, chan.type, chan.id);
            chan.timeout = function(timeout) {
              arg.timeout = timeout;
            };
            chan.timeout(arg.timeout || defaults.chan_timeout);
            chan.wrap = function(wrap) {
              if (!channelWraps[wrap])
                return false;
              return channelWraps[wrap](chan);
            };
            function cleanup() {
              if (chan.timer)
                clearTimeout(chan.timer);
              chan.timer = setTimeout(function() {
                chan.ended = chan.ended || true;
                hn.chanEnded(chan.id);
              }, arg.timeout);
            }
            chan.receive = function(packet) {
              if (packet.js.err) {
                chan.inq = [];
                chan.ended = packet.js.err;
                chan.callback(packet.js.err, packet, chan, function() {});
                cleanup();
                return;
              }
              chan.recvAt = Date.now();
              chan.opened = true;
              chan.last = packet.sender;
              var ack = parseInt(packet.js.ack);
              if (ack > chan.outSeq)
                return warn("bad ack, dropping entirely", chan.outSeq, ack);
              var miss = Array.isArray(packet.js.miss) ? packet.js.miss : [];
              if (miss.length > 100) {
                warn("too many misses", miss.length, chan.id, packet.from.hashname);
                miss = miss.slice(0, 100);
              }
              if (miss.length > 0 || ack > chan.lastAck) {
                debug("miss processing", ack, chan.lastAck, miss, chan.outq.length);
                chan.lastAck = ack;
                var outq = chan.outq;
                chan.outq = [];
                outq.forEach(function(pold) {
                  if (pold.js.seq <= ack) {
                    if (pold.callback)
                      pold.callback();
                    if (pold.js.end)
                      cleanup();
                    return;
                  }
                  chan.outq.push(pold);
                  if (miss.indexOf(pold.js.seq) == -1)
                    return;
                  if (Date.now() - pold.resentAt < 1000)
                    return;
                  pold.resentAt = Date.now();
                  chan.ack(pold);
                });
              }
              var seq = packet.js.seq;
              if (!(seq >= 0))
                return;
              if (!chan.acker)
                chan.acker = setTimeout(function() {
                  delete chan.acker;
                  chan.ack();
                }, defaults.chan_autoack);
              if (seq <= chan.inDone || chan.inq[seq - (chan.inDone + 1)])
                return chan.forceAck = true;
              if (seq - chan.inDone > defaults.chan_inbuf) {
                warn("chan too far behind, dropping", seq, chan.inDone, chan.id, packet.from.hashname);
                return chan.forceAck = true;
              }
              chan.inq[seq - (chan.inDone + 1)] = packet;
              debug("INQ", Object.keys(chan.inq), chan.inDone, chan.handling);
              chan.handler();
            };
            chan.handler = function() {
              if (chan.handling)
                return;
              var packet = chan.inq[0];
              if (!packet && chan.inq.length > 0)
                chan.forceAck = true;
              if (!packet)
                return;
              chan.handling = true;
              chan.ended = chan.ended || packet.js.end;
              if (!chan.safe)
                packet.js = packet.js._ || {};
              chan.callback(chan.ended, packet, chan, function(ack) {
                chan.inq.shift();
                chan.inDone++;
                chan.handling = false;
                if (ack)
                  chan.ack();
                if (chan.ended)
                  cleanup();
                chan.handler();
              });
            };
            chan.resend = function() {
              if (chan.ended)
                return;
              if (!chan.outq.length)
                return;
              var lastpacket = chan.outq[chan.outq.length - 1];
              if (Date.now() - lastpacket.sentAt > arg.timeout) {
                hn.receive({js: {
                    err: "timeout",
                    c: chan.id
                  }});
                return;
              }
              debug("channel resending");
              chan.ack(lastpacket);
              setTimeout(function() {
                chan.resend();
              }, defaults.chan_resend);
            };
            chan.ack = function(packet) {
              if (!packet)
                debug("ACK CHECK", chan.id, chan.outConfirmed, chan.inDone);
              if (!packet) {
                if (!chan.forceAck && chan.outConfirmed == chan.inDone)
                  return;
                packet = {js: {}};
              }
              chan.forceAck = false;
              if (chan.inDone >= 0)
                chan.outConfirmed = packet.js.ack = chan.inDone;
              delete packet.js.miss;
              if (chan.inq.length > 0) {
                packet.js.miss = [];
                for (var i = 0; i < chan.inq.length; i++) {
                  if (!chan.inq[i])
                    packet.js.miss.push(chan.inDone + i + 1);
                }
              }
              packet.js.c = chan.id;
              debug("SEND", chan.type, JSON.stringify(packet.js));
              cleanup();
              hn.send(packet);
            };
            chan.send = function(arg) {
              if (!arg)
                arg = {};
              if (arg.err) {
                if (chan.ended)
                  return;
                chan.ended = arg.err;
                hn.send({js: {
                    err: arg.err,
                    c: chan.id
                  }});
                return cleanup();
              }
              var packet = {};
              packet.js = chan.safe ? arg.js : {_: arg.js};
              if (arg.type)
                packet.js.type = arg.type;
              if (arg.end)
                packet.js.end = arg.end;
              packet.body = arg.body;
              packet.callback = arg.callback;
              packet.js.seq = chan.outSeq++;
              packet.sentAt = Date.now();
              chan.outq.push(packet);
              chan.ack(packet);
              if (chan.resender)
                clearTimeout(chan.resender);
              chan.resender = setTimeout(function() {
                chan.resend();
              }, defaults.chan_resend);
              return chan;
            };
            chan.end = function() {
              if (chan.ended)
                return chan.ack();
              chan.send({js: {end: true}});
            };
            chan.fail = function(arg) {
              var err = "failed";
              if (typeof arg == "string")
                err = arg;
              if (typeof arg == "object" && arg.js && arg.js.err)
                err = arg.js.err;
              chan.send({err: err});
            };
            if (arg.js) {
              arg.type = type;
              chan.send(arg);
            }
            return chan;
          }
          function inRelay(chan, packet) {
            var to = chan.relayTo;
            var self = packet.from.self;
            if ((packet.js.err || packet.js.warn) && !chan.migrating && to.relayChan == chan && !to.to) {
              debug("relay failing, trying to migrate", to.hashname);
              chan.migrating = true;
              var bridges = [];
              to.paths.forEach(function(path) {
                if (!self.bridges[path.type])
                  return;
                Object.keys(self.bridges[path.type]).forEach(function(id) {
                  if (bridges.indexOf(id) == -1)
                    bridges.push(id);
                });
              });
              var done;
              bridges.forEach(function(id) {
                if (done)
                  return;
                if (id == to.hashname || id == packet.from.hashname)
                  return;
                var hn = self.whois(id);
                if (!pathValid(hn.to))
                  return;
                done = hn.peer(to.hashname, to.csid);
              });
            }
            if (packet.js.err || packet.js.end) {
              debug("ending relay from", chan.hashname, "to", to.hashname, packet.js.err || packet.js.end);
              if (to.relayChan == chan)
                to.relayChan = false;
              return;
            }
            if (to.to && to.to.recvAt < chan.startAt)
              to.to = false;
            to.relayChan = chan;
            var path = (packet.js.bridge) ? JSON.parse(JSON.stringify(packet.sender.json)) : false;
            if (packet.body && packet.body.length)
              self.receive(packet.body, path);
            to.pathSync();
          }
          function inConnect(err, packet, chan) {
            if (chan.relayTo)
              return inRelay(chan, packet);
            var to = chan.relayTo = packet.from.self.whokey(packet.js.from, packet.body);
            if (!chan.relayTo)
              return warn("invalid connect request from", packet.from.hashname, packet.js);
            chan.timeout(defaults.nat_timeout);
            if (Array.isArray(packet.js.paths))
              packet.js.paths.forEach(function(path) {
                if (typeof path.type != "string")
                  return debug("bad path", JSON.stringify(path));
                packet.from.self.send(path, to.open(), to);
              });
            chan.send({body: to.open()});
            packet.from.sees(to.hashname);
          }
          function relay(self, from, to, packet) {
            if (from.ended && !to.ended)
              return to.send({js: {err: "disconnected"}});
            if (to.ended && !from.ended)
              return from.send({js: {err: "disconnected"}});
            var js = {};
            if (self.isBridge(from.hashname) || self.isBridge(to.hashname)) {
              var bp = pdecode(packet.body);
              var id = bp && bp.body && bp.body.length > 16 && bp.body.slice(0, 16).toString("hex");
              if (id && bp.head.length == 0 && !to.bridged && to.last && !self.lines[id]) {
                to.bridged = true;
                debug("auto-bridging", to.hashname, id, JSON.stringify(to.last.json));
                self.bridgeLine[id] = JSON.parse(JSON.stringify(to.last.json));
              }
            }
            if (from.bridged && to.bridged)
              js = {"bridge": true};
            if (!from.relayed || Date.now() - from.relayed > 1000) {
              from.relayed = Date.now();
              from.relays = 0;
            }
            from.relays++;
            if (from.relays > 5) {
              debug("relay too fast, warning", from.relays);
              js.warn = "toofast";
            }
            from.relayed = Date.now();
            to.send({
              js: js,
              body: packet.body
            });
          }
          function inPeer(err, packet, chan) {
            if (err)
              return;
            var self = packet.from.self;
            if (chan.relay)
              return relay(self, chan, chan.relay, packet);
            if (!isHEX(packet.js.peer, 64))
              return;
            var peer = self.whois(packet.js.peer);
            if (!peer)
              return;
            if (!(pathValid(peer.to) || self.isBridge(packet.from.hashname) || self.isBridge(peer.hashname)))
              return debug("disconnected peer request");
            if (!Array.isArray(packet.js.paths))
              packet.js.paths = [];
            packet.from.paths.forEach(function(path) {
              if (!path.recvAt)
                return;
              if (pathShareOrder.indexOf(path.type) == -1)
                return;
              if (isLocalPath(path) && !peer.isLocal)
                return;
              packet.js.paths.push(path.json);
            });
            var js = {
              from: packet.from.parts,
              paths: []
            };
            packet.js.paths.forEach(function(path) {
              if (typeof path.type != "string")
                return;
              if (pathMatch(path, js.paths))
                return;
              js.paths.push(path);
            });
            chan.timeout(defaults.nat_timeout);
            chan.relay = peer.raw("connect", {
              js: js,
              body: packet.body
            }, function(err, packet, chan2) {
              if (err)
                return;
              relay(self, chan2, chan, packet);
            });
          }
          function inSeek(err, packet, chan) {
            if (err)
              return;
            if (!isHEX(packet.js.seek))
              return warn("invalid seek of ", packet.js.seek, "from:", packet.from.hashname);
            var self = packet.from.self;
            var seek = packet.js.seek;
            var see = [];
            var seen = {};
            var bucket = dhash(self.hashname, packet.js.seek);
            var links = self.buckets[bucket] ? self.buckets[bucket] : [];
            links.sort(function(a, b) {
              return a.age - b.age;
            }).forEach(function(seed) {
              if (see.length)
                return;
              if (!seed.seed)
                return;
              see.push(seed.address(packet.from));
              seen[seed.hashname] = true;
            });
            links.sort(function(a, b) {
              return dhash(seek, a.hashname) - dhash(seek, b.hashname);
            }).forEach(function(link) {
              if (seen[link.hashname])
                return;
              if (link.seed || link.hashname.substr(0, seek.length) == seek) {
                see.push(link.address(packet.from));
                seen[link.hashname] = true;
              }
            });
            var answer = {
              end: true,
              see: see.filter(function(x) {
                return x;
              }).slice(0, 8)
            };
            chan.send({js: answer});
          }
          function inLink(err, packet, chan) {
            if (err)
              return;
            var self = packet.from.self;
            chan.timeout(defaults.nat_timeout * 2);
            debug("LINKUP", packet.from.hashname);
            if (!packet.from.age)
              packet.from.age = Date.now();
            packet.from.linked = chan;
            packet.from.seed = packet.js.seed;
            if (self.buckets[packet.from.bucket].indexOf(packet.from) == -1)
              self.buckets[packet.from.bucket].push(packet.from);
            if (packet.from.seed && packet.from.isLocal && self.locals.indexOf(packet.from) == -1)
              self.locals.push(packet.from);
            if (!chan.sentAt)
              packet.from.link();
            if (Array.isArray(packet.js.see))
              packet.js.see.forEach(function(address) {
                var hn = packet.from.sees(address);
                if (!hn || hn.linked)
                  return;
                if (self.buckets[hn.bucket].length < defaults.link_k)
                  hn.link();
              });
            if (Array.isArray(packet.js.bridges))
              packet.js.bridges.forEach(function(type) {
                if (!self.bridges[type])
                  self.bridges[type] = {};
                self.bridges[type][packet.from.hashname] = Date.now();
              });
            chan.callback = inMaintenance;
          }
          function inMaintenance(err, packet, chan) {
            if (!packet.from || !packet.from.linked || packet.from.linked != chan)
              return;
            var self = packet.from.self;
            if (err) {
              debug("LINKDOWN", packet.from.hashname, err);
              delete packet.from.linked;
              var index = self.buckets[packet.from.bucket].indexOf(packet.from);
              if (index > -1)
                self.buckets[packet.from.bucket].splice(index, 1);
              if (chan.recvAt)
                packet.from.link();
              return;
            }
            packet.from.seed = packet.js.seed;
            if ((Date.now() - chan.sentAt) > Math.ceil(defaults.link_timer / 2))
              chan.send({js: {seed: self.seed}});
          }
          function inPath(err, packet, chan) {
            if (err)
              return;
            var self = packet.from.self;
            if (Array.isArray(packet.js.paths))
              packet.js.paths.forEach(function(path) {
                packet.from.pathGet(path);
              });
            packet.from.paths.forEach(function(path) {
              var js = {};
              if (pathShareOrder.indexOf(path.type) >= 0)
                js.path = path.json;
              chan.send({
                js: js,
                to: path
              });
            });
          }
          function inPing(self, packet) {
            if (packet.js.trace == self.tracer)
              return;
            if (self.locals.length > 1)
              return;
            if (self.lanSkip && self.lanSkip == packet.js.trace)
              return;
            debug("PING-PONG", packet.js, packet.sender);
            self.lanSkip = packet.js.trace;
            var csid = partsMatch(self.parts, packet.js);
            if (!csid)
              return;
            var js = {
              type: "pong",
              from: self.parts,
              trace: packet.js.trace
            };
            self.send(packet.sender, pencode(js, getkey(self, csid)));
          }
          function inPong(self, packet) {
            debug("PONG", JSON.stringify(packet.js), JSON.stringify(packet.sender));
            if (packet.js.trace != self.tracer)
              return;
            if (self.locals.length >= 5)
              return warn("locals full");
            if (!packet.body || packet.body.length == 0)
              return;
            var to = self.whokey(packet.js.from, packet.body);
            if (!to)
              return warn("invalid lan request from", packet.js.from, packet.sender);
            to.local = true;
            debug("local seed open", to.hashname, JSON.stringify(packet.sender));
            self.send(packet.sender, to.open(), to);
            to.link();
          }
          function isHEX(str, len) {
            if (typeof str !== "string")
              return false;
            if (len && str.length !== len)
              return false;
            if (str.replace(/[a-f0-9]+/i, "").length !== 0)
              return false;
            return true;
          }
          function dhash(h1, h2) {
            var n1 = hex2nib(h1);
            var n2 = hex2nib(h2);
            if (!n1.length || !n2.length)
              return -1;
            var sbtab = [-1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3];
            var ret = 252;
            for (var i = 0; i < n1.length; i++) {
              if (!n2[i])
                return ret;
              var diff = n1[i] ^ n2[i];
              if (diff)
                return ret + sbtab[diff];
              ret -= 4;
            }
            return ret;
          }
          function hex2nib(hex) {
            var ret = [];
            for (var i = 0; i < hex.length / 2; i++) {
              var bite = parseInt(hex.substr(i * 2, 2), 16);
              if (isNaN(bite))
                return [];
              ret[ret.length] = bite >> 4;
              ret[ret.length] = bite & 0xf;
            }
            return ret;
          }
          function pathMatch(path1, paths) {
            var match;
            if (!path1 || !Array.isArray(paths))
              return match;
            paths.forEach(function(path2) {
              if (!path2 || path2.type != path1.type)
                return;
              switch (path1.type) {
                case "ipv4":
                case "ipv6":
                  if (path1.ip == path2.ip && path1.port == path2.port)
                    match = path2;
                  break;
                case "http":
                  if (path1.http == path2.http)
                    match = path2;
                  break;
                default:
                  if (path1.id === path2.id)
                    match = path2;
              }
            });
            return match;
          }
          function pathValid(path) {
            if (!path || path.gone)
              return false;
            if (!path.recvAt)
              return false;
            if (Date.now() - path.recvAt < defaults.nat_timeout)
              return true;
            return false;
          }
          function partsMatch(parts1, parts2) {
            if (typeof parts1 != "object" || typeof parts2 != "object")
              return false;
            var ids = Object.keys(parts1).sort();
            var csid;
            while (csid = ids.pop())
              if (parts2[csid])
                return csid;
            return false;
          }
          function isLocalPath(path) {
            if (!path || !path.type)
              return false;
            if (path.type == "bluetooth")
              return true;
            if (path.type == "http" && typeof path.http == "string")
              return isLocalIP(require("url").parse(path.http).hostname);
            if (["ipv4", "ipv6"].indexOf(path.type) >= 0)
              return isLocalIP(path.ip);
            return false;
          }
          function isLocalIP(ip) {
            if (ip.indexOf(":") >= 0) {
              if (ip.indexOf("::") == 0)
                return true;
              if (ip.indexOf("fc00") == 0)
                return true;
              if (ip.indexOf("fe80") == 0)
                return true;
              return false;
            }
            var parts = ip.split(".");
            if (parts[0] == "0")
              return true;
            if (parts[0] == "127")
              return true;
            if (parts[0] == "10")
              return true;
            if (parts[0] == "192" && parts[1] == "168")
              return true;
            if (parts[0] == "172" && parts[1] >= 16 && parts[1] <= 31)
              return true;
            if (parts[0] == "169" && parts[1] == "254")
              return true;
            return false;
          }
          function randomHEX(len) {
            return crypto.randomBytes(len).toString("hex");
          }
          function parts2hn(parts) {
            var rollup = new Buffer(0);
            Object.keys(parts).sort().forEach(function(id) {
              rollup = crypto.createHash("sha256").update(Buffer.concat([rollup, new Buffer(id)])).digest();
              rollup = crypto.createHash("sha256").update(Buffer.concat([rollup, new Buffer(parts[id])])).digest();
            });
            return rollup.toString("hex");
          }
          function pencode(js, body) {
            if (!body && js && js.js) {
              body = js.body;
              js = js.js;
            }
            var head = (typeof js == "number") ? new Buffer(String.fromCharCode(js)) : new Buffer(js ? JSON.stringify(js) : "", "utf8");
            if (typeof body == "string")
              body = new Buffer(body, "binary");
            body = body || new Buffer(0);
            var len = new Buffer(2);
            len.writeInt16BE(head.length, 0);
            return Buffer.concat([len, head, body]);
          }
          function pdecode(packet) {
            if (!packet)
              return undefined;
            var buf = (typeof packet == "string") ? new Buffer(packet, "binary") : packet;
            if (packet.length < 2)
              return undefined;
            var len = buf.readUInt16BE(0);
            if (len > (buf.length - 2))
              return undefined;
            var head = buf.slice(2, len + 2);
            var body = buf.slice(len + 2);
            var js = {};
            if (len > 1) {
              try {
                js = JSON.parse(head.toString("utf8"));
              } catch (E) {
                console.log("couldn't parse JS", buf.toString("hex"), E);
                return undefined;
              }
            }
            return {
              js: js,
              length: buf.length,
              head: head.toString("binary"),
              body: body
            };
          }
          function getkey(id, csid) {
            return id.cs && id.cs[csid] && id.cs[csid].key;
          }
          function loadkeys(self) {
            self.cs = {};
            self.keys = {};
            self.parts = {};
            var err = false;
            Object.keys(self.id).forEach(function(csid) {
              if (csid.length != 2)
                return;
              self.cs[csid] = {};
              if (!self.CSets[csid])
                err = csid + " not supported";
              err = err || self.CSets[csid].loadkey(self.cs[csid], self.id[csid], self.id[csid + "_secret"]);
              self.keys[csid] = self.id[csid];
              self.parts[csid] = crypto.createHash("sha256").update(self.cs[csid].key).digest("hex");
            });
            return err;
          }
          function loadkey(self, id, csid, key) {
            id.csid = csid;
            return self.CSets[csid].loadkey(id, key);
          }
          function keysgen(cbDone, cbStep) {
            var self = this;
            var ret = {};
            var todo = Object.keys(self.CSets);
            if (todo.length == 0)
              return cbDone("no sets supported");
            function pop(err) {
              if (err)
                return cbDone(err);
              var csid = todo.pop();
              if (!csid) {
                self.load(ret);
                return cbDone(null, ret);
              }
              self.CSets[csid].genkey(ret, pop, cbStep);
            }
            pop();
          }
          function ticketize(self, to, inner) {
            if (!to.csid) {
              console.log("can't ticket w/ no key");
              return false;
            }
            var tcs = {};
            self.CSets[to.csid].loadkey(tcs, to.key);
            return self.CSets[to.csid].openize(self, tcs, pencode(inner));
          }
          function deticketize(self, from, open) {
            var ret;
            var csid = open.head.charCodeAt().toString(16);
            if (!self.CSets[csid] || csid != from.csid)
              ret = {err: "invalid CSID of " + csid};
            else {
              open.from = from;
              try {
                ret = self.CSets[csid].deopenize(self, open);
              } catch (E) {
                ret = {err: E};
              }
            }
            if (ret.err || !ret.inner) {
              debug("deticketize failed", ret.err);
              return false;
            }
            return ret.inner;
          }
          function openize(self, to) {
            if (!to.csid) {
              console.log("can't open w/ no key");
              return undefined;
            }
            if (!to.lineOut)
              to.lineOut = randomHEX(16);
            if (!to.lineAt)
              to.lineAt = Date.now();
            var inner = {};
            inner.at = to.lineAt;
            inner.to = to.hashname;
            inner.from = self.parts;
            inner.line = to.lineOut;
            return self.CSets[to.csid].openize(self, to, inner);
          }
          function deopenize(self, open) {
            var ret;
            var csid = open.head.charCodeAt().toString(16);
            if (!self.CSets[csid])
              return {err: "unknown CSID of " + csid};
            try {
              ret = self.CSets[csid].deopenize(self, open);
            } catch (E) {
              return {err: E};
            }
            ret.csid = csid;
            return ret;
          }
          var urllib = require("url");
          function uriparse(uri) {
            if (typeof uri !== "string")
              uri = "";
            var hashname = uri.match(/[0-9A-Fa-f]{64}/);
            if (!hashname)
              return urllib.parse(uri);
            var full = hashname[0];
            var part = full.substr(0, 32);
            var u = urllib.parse(uri.replace(full, part));
            if (u.hostname != part)
              return urllib.parse(uri);
            Object.keys(u).forEach(function(k) {
              if (typeof u[k] != "string")
                return;
              u[k] = u[k].replace(part, full);
            });
            return u;
          }
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "crypto": 35,
        "url": 70
      }],
      21: [function(require, module, exports) {
        exports.json = require("./seeds.json");
        exports.install = function(self, args) {
          var seeds = exports.json;
          if (args && args.seeds) {
            if (typeof args.seeds == "string")
              seeds = require(args.seeds);
            if (typeof args.seeds == "object")
              seeds = args.seeds;
          }
          Object.keys(seeds).forEach(function(seed) {
            self.addSeed(seeds[seed]);
          });
        };
      }, {"./seeds.json": 22}],
      22: [function(require, module, exports) {
        module.exports = {"876d5ce8956009afc010fc908ca29617a444db660cd5598d81bb6a5a2635ba7a": {
            "paths": [{
              "type": "http",
              "http": "http://azure.lewisl.net:42424"
            }],
            "parts": {
              "2a": "a9b3da6d514c8aeb1cc001f5423dbf80f0c523a000b1087286fd1b18168d9e3e",
              "1a": "fc1c470beb1ca7fdb6ecf7a7e3b542e087e0e7705d91666e7a124bc2aeeea9bf"
            },
            "keys": {
              "2a": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Lb4LwKUW1D3XI/jK5cBtbO17e/6oSD5myO/wYOIyRcJpDgRe////94ugsPGO/FtDnNdWTJ8/bpRGkxnlHadSGA0K3hukx+SOSdddzB/wAp86l0eCuiIBeDfnBYvxC4KmiRHFHMXSRYq2HWSzH2Knz65g/6VI/Qe/F4M8+A19Wxq1RBDtLcigJtkUdJ/y4TUdSwAPaM/mcQFwjCqssC8sgH6LzqPP43+yloxqG5Hx4IsWgcnBzaCQh8yYbP04nH7fd19gPXyWCSjo3CdSwnvfCHiU/eulXT1wubMhR0ZI/XrF3fC8tglgAOsqSxBdwpWo7iZzrTX2sxV8QWnZ5xsmwIDAQAB",
              "1a": "BO7ZnXZ6VorqlSXhXLfkHtPwctqM53eL3WRqRX/RHGVB2QuTYwLMnw=="
            }
          }};
      }, {}],
      23: [function(require, module, exports) {
        (function(Buffer) {
          exports.install = function(self) {
            self.sock = function(req) {
              if (self.isHashname(req))
                req = {to: req};
              if (typeof req != "object")
                return console.log("invalid args") && false;
              var to = self.whois(req.to);
              if (!to)
                return console.log("invalid to hashname", req.to) && false;
              delete req.to;
              var chan = to.start("sock", {
                bare: true,
                js: req
              });
              return chan.wrap("stream");
            };
            self.onSock = function(cbSock) {
              self.rels["sock"] = function(err, packet, chan, callback) {
                if (err)
                  return;
                callback();
                cbSock(chan.wrap("stream"));
              };
            };
            self.wraps["stream"] = function(chan) {
              var pipe = new require("stream").Duplex();
              pipe.on("finish", function() {
                chan.send({js: {end: true}});
              });
              pipe.on("error", function(err) {
                chan.fail({js: {err: err}});
              });
              pipe._write = function(data, enc, cbWrite) {
                if (chan.ended)
                  return cbWrite("closed");
                while (data.length) {
                  var chunk = data.slice(0, 1000);
                  data = data.slice(1000);
                  var packet = {
                    js: {},
                    body: chunk
                  };
                  if (!data.length) {
                    packet.callback = cbWrite;
                    if (pipe.ended)
                      packet.js.end = true;
                  }
                  chan.send(packet);
                }
              };
              pipe.end = function(data) {
                pipe.ended = true;
                if (!data)
                  data = new Buffer(0);
                pipe.write(data);
              };
              var more = false;
              pipe._read = function(size) {
                if (more)
                  more();
                more = false;
              };
              chan.callback = function(err, packet, chan, cbMore) {
                if (packet.body)
                  if (!pipe.push(packet.body))
                    more = cbMore;
                if (err)
                  pipe.push(null);
                if (!more)
                  cbMore();
              };
              return pipe;
            };
          };
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      24: [function(require, module, exports) {
        exports.install = function(self) {
          self.TSockets = {};
          self.socket = function(uri, callback) {
            if (typeof uri != "string")
              return warn("invalid TS uri") && false;
            if (uri.indexOf("ts://") == 0) {
              var parts = uri.substr(5).split("/");
              var to = self.whois(parts.shift());
              if (!to)
                return warn("invalid TS hashname") && false;
              var pathname = parts.join("/");
              if (!pathname)
                pathname = "/";
              var chan = to.start("ts", {
                bare: true,
                js: {path: pathname}
              });
              chan.wrap("TS");
              return chan.socket;
            }
            if (uri.indexOf("/") != 0)
              return warn("invalid TS listening uri") && false;
            self.TSockets[uri] = callback;
          };
          self.rels["ts"] = function(err, packet, chan, callback) {
            if (err)
              return;
            var self = packet.from.self;
            callback();
            if (typeof packet.js.path != "string" || !self.TSockets[packet.js.path])
              return chan.err("unknown path");
            chan.wrap("TS");
            self.TSockets[packet.js.path](chan.socket);
            chan.send({js: {open: true}});
          };
          self.wraps["TS"] = function(chan) {
            chan.socket = {
              data: "",
              hashname: chan.hashname,
              id: chan.id
            };
            chan.callback = function(err, packet, chan, callback) {
              chan.socket.readyState = 1;
              if (chan.socket.onopen) {
                chan.socket.onopen();
                delete chan.socket.onopen;
              }
              if (packet.body)
                chan.socket.data += packet.body;
              if (packet.js.done) {
                if (chan.socket.onmessageack)
                  chan.socket.onmessageack(chan.socket, callback);
                else {
                  if (chan.socket.onmessage)
                    chan.socket.onmessage(chan.socket);
                  chan.socket.data = "";
                  callback();
                }
              } else {
                callback();
              }
              if (err) {
                chan.socket.readyState = 2;
                if (err != true && chan.socket.onerror)
                  chan.socket.onerror(err);
                if (chan.socket.onclose)
                  chan.socket.onclose();
              }
            };
            chan.socket.readyState = chan.lastIn ? 1 : 0;
            chan.socket.send = function(data, callback) {
              if (chan.socket.readyState != 1)
                return console.log("sending fail to TS readyState", chan.socket.readyState) && false;
              while (data) {
                var chunk = data.substr(0, 1000);
                data = data.substr(1000);
                var packet = {
                  js: {},
                  body: chunk
                };
                if (!data) {
                  packet.callback = callback;
                  packet.js.done = true;
                }
                chan.send(packet);
              }
            };
            chan.socket.close = function() {
              chan.socket.readyState = 2;
              chan.done();
            };
            return chan.socket;
          };
        };
      }, {}],
      25: [function(require, module, exports) {
        (function(Buffer) {
          var stream = require("stream");
          var urllib = require("url");
          var httplib = require("http");
          exports.install = function(self) {
            self.thtp = {};
            self.thtp.request = function(args, cbRequest) {
              if (!cbRequest)
                cbRequest = function() {};
              if (typeof args == "string")
                args = {uri: args};
              if (typeof args != "object" || !(args.uri || args.url || args.hashname))
                return errored("invalid args", cbRequest);
              if (args.hashname)
                args.uri = "thtp://" + args.hashname + args.path;
              var uri = self.uriparse(args.uri || args.url);
              if (uri.protocol != "thtp:")
                return errored("invalid protocol " + uri.protocol, cbRequest);
              if (uri.hostname == self.hashname)
                return errored("can't request self", cbRequest);
              var to;
              if (!(to = self.whois(uri.hostname)))
                return errored("invalid hashname", cbRequest);
              var js = {};
              if (typeof args.headers == "object")
                Object.keys(args.headers).forEach(function(header) {
                  js[header.toLowerCase()] = args.headers[header].toString();
                });
              if (args.body)
                js["content-length"] = args.body.length.toString();
              js.method = args.method || "get";
              js.path = uri.path;
              var body = self.pencode(js, args.body);
              js = {};
              if (body.length <= 1000)
                js.end = true;
              var pin = new Buffer(0);
              var pipe = streamer(to.start("thtp", {
                bare: true,
                js: js,
                body: body.slice(0, 1000)
              }, function(err, packet, chan, cbChan) {
                cbChan(true);
                if (pipe.headers) {
                  pipe.push(packet.body);
                  if (err)
                    pipe.emit("end");
                  return;
                }
                if (packet.body)
                  pin = Buffer.concat([pin, packet.body]);
                var http;
                if (!(http = self.pdecode(pin))) {
                  if (err)
                    cbRequest(500, pipe);
                  return;
                }
                pipe.status = parseInt(http.js.status) || 500;
                pipe.headers = http.js;
                cbRequest(pipe.status >= 300 ? pipe.status.toString() : false, pipe);
                if (http.body)
                  pipe.push(http.body);
                if (err)
                  pipe.emit("end");
              }));
              if (body.length > 1000)
                pipe.end(body.slice(1000));
              return pipe;
            };
            self.thtp.listen = function(cbListen) {
              self.rels["thtp"] = function(err, packet, chan, cbStart) {
                var pipe;
                var pin = new Buffer(0);
                chan.callback = function(err, packet, chan, cbChan) {
                  cbChan(true);
                  if (pipe) {
                    if (packet.body)
                      pipe.push(packet.body);
                    if (err)
                      pipe.emit("end");
                    return;
                  }
                  pin = Buffer.concat([pin, packet.body]);
                  if (!(http = self.pdecode(pin))) {
                    if (err)
                      chan.end();
                    return;
                  }
                  if (typeof http.js.method != "string" || typeof http.js.path != "string")
                    return chan.err("invalid");
                  pipe = streamer(chan);
                  pipe.method = http.js.method;
                  pipe.path = http.js.path;
                  delete http.js.method;
                  delete http.js.path;
                  pipe.headers = http.js;
                  cbListen(pipe, function(args) {
                    if (!args)
                      args = {};
                    if (args.err)
                      return errored(err, chan.err);
                    var js = {};
                    if (typeof args.headers == "object")
                      Object.keys(args.headers).forEach(function(header) {
                        js[header.toLowerCase()] = args.headers[header].toString();
                      });
                    js.status = args.status || 200;
                    if (args.json)
                      args.body = JSON.stringify(args.json);
                    if (args.body)
                      js["content-length"] = args.body.length.toString();
                    var phttp = self.pencode(js, args.body);
                    var js = {};
                    if (args.body && phttp.length <= 1000)
                      js.end = true;
                    chan.send({
                      js: js,
                      body: phttp.slice(0, 1000)
                    });
                    if (phttp.length > 1000)
                      pipe.write(phttp.slice(1000));
                    return pipe;
                  });
                  if (http.body)
                    pipe.push(http.body);
                  if (err)
                    pipe.emit("end");
                };
                chan.callback(err, packet, chan, cbStart);
              };
            };
            var mPaths = {};
            self.thtp.match = function(uri, cbMatch) {
              var path = self.uriparse(uri).pathname;
              mPaths[path] = cbMatch;
              if (Object.keys(mPaths).length > 1)
                return;
              self.thtp.listen(function(req, cbRes) {
                var match;
                Object.keys(mPaths).forEach(function(path) {
                  if (req.path.indexOf(path) != 0)
                    return;
                  if (match && match.length > path)
                    return;
                  match = path;
                });
                if (match)
                  return mPaths[match](req, cbRes);
                cbRes({
                  status: 404,
                  body: "not found"
                });
              });
            };
            self.thtp.proxy = function(args) {
              if (args.address == "0.0.0.0")
                args.address = "127.0.0.1";
              self.thtp.listen(function(req, cbRes) {
                var opt = {
                  host: args.address,
                  port: args.port,
                  headers: req.headers,
                  method: req.method,
                  path: req.path
                };
                req.pipe(httplib.request(opt, function(res) {
                  res.pipe(cbRes({
                    status: res.statusCode,
                    headers: res.headers
                  }));
                }));
              });
            };
          };
          function errored(err, cb) {
            cb(err);
            var pipe = stream.Readable();
            pipe._read = function() {};
            pipe.emit("end");
            return pipe;
          }
          function streamer(chan) {
            var pipe = stream.Duplex();
            pipe._read = function() {};
            pipe.on("finish", function() {
              chan.send({js: {end: true}});
            });
            pipe._write = function(data, enc, cbWrite) {
              while (data.length) {
                var chunk = data.slice(0, 1000);
                data = data.slice(1000);
                var packet = {
                  js: {},
                  body: chunk
                };
                if (!data.length) {
                  packet.callback = cbWrite;
                  if (pipe.ended)
                    packet.js.end = true;
                }
                chan.send(packet);
              }
            };
            pipe.end = function(data) {
              pipe.ended = true;
              if (!data)
                data = new Buffer(0);
              pipe.write(data);
            };
            return pipe;
          }
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "http": 46,
        "stream": 69,
        "url": 70
      }],
      26: [function(require, module, exports) {
        (function(Buffer) {
          var crypto = require("crypto");
          exports.install = function(self) {
            var tokens = {};
            self.token = function(token, callback) {
              if (typeof token == "function") {
                callback = token;
                token = false;
              }
              if (!token) {
                var bytes = new Buffer(self.hashname, "hex");
                var rand = new Buffer(self.randomHEX(8), "hex");
                var hash = crypto.createHash("sha256").update(Buffer.concat([bytes, rand])).digest();
                token = Buffer.concat([bytes.slice(0, 16), rand, hash.slice(0, 8)]).toString("hex");
              }
              if (callback)
                tokens[token] = callback;
              return token;
            };
            self.raws["token"] = function(err, packet, chan) {
              if (err)
                return;
              var self = packet.from.self;
              if (!self.isHashname(packet.js.token))
                return chan.err("invalid");
              if (tokens[packet.js.token]) {
                tokens[packet.js.token](packet.from);
                return chan.send({js: {end: true}});
              }
              if (!self.tokens)
                return chan.err("unknown");
              self.tokens(packet.js.token, packet.from, function(err) {
                if (err)
                  chan.err(err);
                can.send({js: {end: true}});
              });
            };
            self.dispense = function(token, callback) {
              self.seek(token, function(err, see) {
                if (!Array.isArray(see))
                  return callback(err || "not found");
                var match;
                see.forEach(function(hn) {
                  if (hn.substr(0, 32) != token.substr(0, 32))
                    return;
                  var bytes = new Buffer(hn, "hex");
                  var rand = new Buffer(token.substr(32, 16), "hex");
                  var hash = crypto.createHash("sha256").update(Buffer.concat([bytes, rand])).digest();
                  token2 = Buffer.concat([bytes.slice(0, 16), rand, hash.slice(0, 8)]).toString("hex");
                  if (token == token2)
                    match = hn;
                });
                if (!match || !(match = self.whois(match)))
                  return callback("not found");
                match.raw("token", {
                  js: {token: token},
                  retries: 3
                }, function(err) {
                  callback((err !== true) ? err : false, match);
                });
              });
            };
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "crypto": 35
      }],
      27: [function(require, module, exports) {
        (function(Buffer) {
          var rtc = require("webrtc-peer");
          exports.install = function(self) {
            if (!rtc.hasWebRTC)
              return false;
            self.pathSet({type: "webrtc"});
            var conns = {};
            var peers = {};
            function init(initiate, chan, to) {
              chan.wrap("TS");
              peers[to] = chan;
              var pch;
              chan.socket.onopen = function() {
                pch = new rtc.peer({
                  initiate: initiate,
                  _self: "self",
                  _peer: to
                });
                pch.DEBUG = true;
                pch.onsignal = function(signal) {
                  console.log("RTC OUT", signal);
                  chan.socket.send(JSON.stringify(signal));
                };
                pch.onconnection = function() {
                  console.log("RTC CONNECTED");
                  conns[to] = pch;
                  if (chan.cached)
                    pch.send(chan.cached);
                };
                pch.onmessage = function(safe) {
                  self.receive(new Buffer(safe, "base64"), {type: "webrtc"});
                };
              };
              chan.socket.onmessage = function(data) {
                console.log("RTC IN", data);
                try {
                  data = JSON.parse(data.data);
                } catch (E) {
                  return console.log("rtc parse error", E, data.data);
                }
                pch.signal(data);
              };
            }
            self.deliver("webrtc", function(path, msg, to) {
              var safe = msg.toString("base64");
              if (conns[to.hashname])
                return conns[to.hashname].send(safe);
              if (peers[to.hashname])
                return peers[to.hashname].cached = safe;
              var chan = to.start("webrtc", {bare: true});
              setTimeout(function() {
                chan.send({
                  type: "webrtc",
                  js: {open: true}
                });
              }, 10);
              init(true, chan, to.hashname);
            });
            self.rels["webrtc"] = function(err, packet, chan, cb) {
              cb();
              if (err)
                return;
              var from = packet.from.hashname;
              if (peers[from] && chan.id < peers[from].id)
                return chan.fail("duplicate");
              chan.send({js: {open: true}});
              init(false, chan, from);
            };
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "buffer": 29,
        "webrtc-peer": 28
      }],
      28: [function(require, module, exports) {
        exports.peer = PeerConnectionHandler;
        exports.iceServers = [{"url": "stun:23.21.150.121"}];
        var RTCPeerConnection = window.mozRTCPeerConnection || window.RTCPeerConnection || window.webkitRTCPeerConnection,
            RTCSessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription || window.webkitRTCSessionDescription,
            RTCIceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate || window.webkitRTCIceCandidate;
        exports.hasWebRTC = RTCPeerConnection ? true : false;
        function PeerConnectionHandler(opts) {
          if (!opts)
            opts = {};
          opts.reliable = true;
          var cfg = {"iceServers": exports.iceServers},
              con = (opts.reliable) ? {} : {'optional': [{'RtpDataChannels': true}]};
          this._rtc = new RTCPeerConnection(cfg, con);
          this.LOG_SELF = opts._self;
          this.LOG_PEER = opts._peer;
          this._channel = null;
          this.onsignal = null;
          this.onmessage = null;
          this.onconnection = null;
          var handler = this,
              rtc = this._rtc;
          if (opts.initiate)
            this._setupChannel();
          else
            rtc.ondatachannel = this._setupChannel.bind(this);
          rtc.onnegotiationneeded = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "saw negotiation trigger and will create an offer");
            rtc.createOffer(function(offerDesc) {
              if (handler.DEBUG)
                console.log(handler.LOG_SELF, "created offer, sending to", handler.LOG_PEER);
              rtc.setLocalDescription(offerDesc, function() {
                console.log("DONE");
              });
              handler._sendSignal(offerDesc);
            }, function(e) {
              console.warn(handler.LOG_SELF, "failed to create offer", e);
            });
          };
          rtc.onicecandidate = function(evt) {
            if (evt.candidate)
              handler._sendSignal({candidate: evt.candidate});
          };
          rtc.onicechange = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "ICE change", rtc.iceGatheringState, rtc.iceConnectionState);
          };
          rtc.onstatechange = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "State change", rtc.signalingState, rtc.readyState);
          };
        }
        PeerConnectionHandler.prototype._sendSignal = function(data) {
          if (!this.onsignal)
            throw Error("Need to send message but `onsignal` handler is not set.");
          this.onsignal(data);
        };
        PeerConnectionHandler.prototype.signal = function(data) {
          var handler = this,
              rtc = this._rtc;
          if (handler.DEBUG)
            console.log(this.LOG_SELF, "got data", data, "from", this.LOG_PEER);
          if (data.sdp)
            rtc.setRemoteDescription(new RTCSessionDescription(data), function() {
              var needsAnswer = (rtc.remoteDescription.type == 'offer');
              if (handler.DEBUG)
                console.log(handler.LOG_SELF, "set offer, now creating answer:", needsAnswer);
              if (needsAnswer)
                rtc.createAnswer(function(answerDesc) {
                  if (handler.DEBUG)
                    console.log(handler.LOG_SELF, "got anwer, sending back to", handler.LOG_PEER);
                  rtc.setLocalDescription(answerDesc);
                  handler._sendSignal(answerDesc);
                }, function(e) {
                  console.warn(handler.LOG_SELF, "couldn't create answer", e);
                });
            }, function(e) {
              console.warn(handler.LOG_SELF, "couldn't set remote description", e);
            });
          else if (data.candidate)
            try {
              rtc.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (e) {
              console.error("Couldn't add candidate", e);
            }
        };
        PeerConnectionHandler.prototype.send = function(data) {
          if (!this._channel || this._channel.readyState !== 'open')
            return this.DEBUG && console.log("dropping data, no open channel");
          this._channel.send(data);
        };
        PeerConnectionHandler.prototype._setupChannel = function(evt) {
          var handler = this,
              rtc = this._rtc;
          if (evt)
            if (handler.DEBUG)
              console.log(this.LOG_SELF, "received data channel", evt.channel.readyState);
          this._channel = (evt) ? evt.channel : rtc.createDataChannel('telehash');
          this._channel.onopen = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "DATA CHANNEL IS OPEN", handler._channel);
            if (handler.onconnection)
              handler.onconnection(handler._channel);
          };
          this._channel.onmessage = function(evt) {
            if (handler.DEBUG)
              console.log(handler.LOG_SELF, "received message!", evt);
            if (handler.onmessage)
              handler.onmessage(evt.data);
          };
          if (window.mozRTCPeerConnection)
            setTimeout(function() {
              rtc.onnegotiationneeded();
            }, 0);
          window.dbgChannel = this._channel;
        };
      }, {}],
      29: [function(require, module, exports) {
        var base64 = require('base64-js');
        var ieee754 = require('ieee754');
        exports.Buffer = Buffer;
        exports.SlowBuffer = Buffer;
        exports.INSPECT_MAX_BYTES = 50;
        Buffer.poolSize = 8192;
        Buffer._useTypedArrays = (function() {
          try {
            var buf = new ArrayBuffer(0);
            var arr = new Uint8Array(buf);
            arr.foo = function() {
              return 42;
            };
            return 42 === arr.foo() && typeof arr.subarray === 'function';
          } catch (e) {
            return false;
          }
        })();
        function Buffer(subject, encoding, noZero) {
          if (!(this instanceof Buffer))
            return new Buffer(subject, encoding, noZero);
          var type = typeof subject;
          if (encoding === 'base64' && type === 'string') {
            subject = base64clean(subject);
          }
          var length;
          if (type === 'number')
            length = coerce(subject);
          else if (type === 'string')
            length = Buffer.byteLength(subject, encoding);
          else if (type === 'object')
            length = coerce(subject.length);
          else
            throw new Error('First argument needs to be a number, array or string.');
          var buf;
          if (Buffer._useTypedArrays) {
            buf = Buffer._augment(new Uint8Array(length));
          } else {
            buf = this;
            buf.length = length;
            buf._isBuffer = true;
          }
          var i;
          if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
            buf._set(subject);
          } else if (isArrayish(subject)) {
            if (Buffer.isBuffer(subject)) {
              for (i = 0; i < length; i++)
                buf[i] = subject.readUInt8(i);
            } else {
              for (i = 0; i < length; i++)
                buf[i] = ((subject[i] % 256) + 256) % 256;
            }
          } else if (type === 'string') {
            buf.write(subject, 0, encoding);
          } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
            for (i = 0; i < length; i++) {
              buf[i] = 0;
            }
          }
          return buf;
        }
        Buffer.isEncoding = function(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'raw':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true;
            default:
              return false;
          }
        };
        Buffer.isBuffer = function(b) {
          return !!(b !== null && b !== undefined && b._isBuffer);
        };
        Buffer.byteLength = function(str, encoding) {
          var ret;
          str = str.toString();
          switch (encoding || 'utf8') {
            case 'hex':
              ret = str.length / 2;
              break;
            case 'utf8':
            case 'utf-8':
              ret = utf8ToBytes(str).length;
              break;
            case 'ascii':
            case 'binary':
            case 'raw':
              ret = str.length;
              break;
            case 'base64':
              ret = base64ToBytes(str).length;
              break;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              ret = str.length * 2;
              break;
            default:
              throw new Error('Unknown encoding');
          }
          return ret;
        };
        Buffer.concat = function(list, totalLength) {
          assert(isArray(list), 'Usage: Buffer.concat(list[, length])');
          if (list.length === 0) {
            return new Buffer(0);
          } else if (list.length === 1) {
            return list[0];
          }
          var i;
          if (totalLength === undefined) {
            totalLength = 0;
            for (i = 0; i < list.length; i++) {
              totalLength += list[i].length;
            }
          }
          var buf = new Buffer(totalLength);
          var pos = 0;
          for (i = 0; i < list.length; i++) {
            var item = list[i];
            item.copy(buf, pos);
            pos += item.length;
          }
          return buf;
        };
        Buffer.compare = function(a, b) {
          assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers');
          var x = a.length;
          var y = b.length;
          for (var i = 0,
              len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
          if (i !== len) {
            x = a[i];
            y = b[i];
          }
          if (x < y) {
            return -1;
          }
          if (y < x) {
            return 1;
          }
          return 0;
        };
        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          var strLen = string.length;
          assert(strLen % 2 === 0, 'Invalid hex string');
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; i++) {
            var byte = parseInt(string.substr(i * 2, 2), 16);
            assert(!isNaN(byte), 'Invalid hex string');
            buf[offset + i] = byte;
          }
          return i;
        }
        function utf8Write(buf, string, offset, length) {
          var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length);
          return charsWritten;
        }
        function asciiWrite(buf, string, offset, length) {
          var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
          return charsWritten;
        }
        function binaryWrite(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
          var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
          return charsWritten;
        }
        function utf16leWrite(buf, string, offset, length) {
          var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length);
          return charsWritten;
        }
        Buffer.prototype.write = function(string, offset, length, encoding) {
          if (isFinite(offset)) {
            if (!isFinite(length)) {
              encoding = length;
              length = undefined;
            }
          } else {
            var swap = encoding;
            encoding = offset;
            offset = length;
            length = swap;
          }
          offset = Number(offset) || 0;
          var remaining = this.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          encoding = String(encoding || 'utf8').toLowerCase();
          var ret;
          switch (encoding) {
            case 'hex':
              ret = hexWrite(this, string, offset, length);
              break;
            case 'utf8':
            case 'utf-8':
              ret = utf8Write(this, string, offset, length);
              break;
            case 'ascii':
              ret = asciiWrite(this, string, offset, length);
              break;
            case 'binary':
              ret = binaryWrite(this, string, offset, length);
              break;
            case 'base64':
              ret = base64Write(this, string, offset, length);
              break;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              ret = utf16leWrite(this, string, offset, length);
              break;
            default:
              throw new Error('Unknown encoding');
          }
          return ret;
        };
        Buffer.prototype.toString = function(encoding, start, end) {
          var self = this;
          encoding = String(encoding || 'utf8').toLowerCase();
          start = Number(start) || 0;
          end = (end === undefined) ? self.length : Number(end);
          if (end === start)
            return '';
          var ret;
          switch (encoding) {
            case 'hex':
              ret = hexSlice(self, start, end);
              break;
            case 'utf8':
            case 'utf-8':
              ret = utf8Slice(self, start, end);
              break;
            case 'ascii':
              ret = asciiSlice(self, start, end);
              break;
            case 'binary':
              ret = binarySlice(self, start, end);
              break;
            case 'base64':
              ret = base64Slice(self, start, end);
              break;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              ret = utf16leSlice(self, start, end);
              break;
            default:
              throw new Error('Unknown encoding');
          }
          return ret;
        };
        Buffer.prototype.toJSON = function() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        Buffer.prototype.equals = function(b) {
          assert(Buffer.isBuffer(b), 'Argument must be a Buffer');
          return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.compare = function(b) {
          assert(Buffer.isBuffer(b), 'Argument must be a Buffer');
          return Buffer.compare(this, b);
        };
        Buffer.prototype.copy = function(target, target_start, start, end) {
          var source = this;
          if (!start)
            start = 0;
          if (!end && end !== 0)
            end = this.length;
          if (!target_start)
            target_start = 0;
          if (end === start)
            return;
          if (target.length === 0 || source.length === 0)
            return;
          assert(end >= start, 'sourceEnd < sourceStart');
          assert(target_start >= 0 && target_start < target.length, 'targetStart out of bounds');
          assert(start >= 0 && start < source.length, 'sourceStart out of bounds');
          assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds');
          if (end > this.length)
            end = this.length;
          if (target.length - target_start < end - start)
            end = target.length - target_start + start;
          var len = end - start;
          if (len < 100 || !Buffer._useTypedArrays) {
            for (var i = 0; i < len; i++) {
              target[i + target_start] = this[i + start];
            }
          } else {
            target._set(this.subarray(start, start + len), target_start);
          }
        };
        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }
        function utf8Slice(buf, start, end) {
          var res = '';
          var tmp = '';
          end = Math.min(buf.length, end);
          for (var i = start; i < end; i++) {
            if (buf[i] <= 0x7F) {
              res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
              tmp = '';
            } else {
              tmp += '%' + buf[i].toString(16);
            }
          }
          return res + decodeUtf8Char(tmp);
        }
        function asciiSlice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);
          for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function binarySlice(buf, start, end) {
          return asciiSlice(buf, start, end);
        }
        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0)
            start = 0;
          if (!end || end < 0 || end > len)
            end = len;
          var out = '';
          for (var i = start; i < end; i++) {
            out += toHex(buf[i]);
          }
          return out;
        }
        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = '';
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }
        Buffer.prototype.slice = function(start, end) {
          var len = this.length;
          start = clamp(start, len, 0);
          end = clamp(end, len, len);
          if (Buffer._useTypedArrays) {
            return Buffer._augment(this.subarray(start, end));
          } else {
            var sliceLen = end - start;
            var newBuf = new Buffer(sliceLen, undefined, true);
            for (var i = 0; i < sliceLen; i++) {
              newBuf[i] = this[i + start];
            }
            return newBuf;
          }
        };
        Buffer.prototype.get = function(offset) {
          console.log('.get() is deprecated. Access using array indexes instead.');
          return this.readUInt8(offset);
        };
        Buffer.prototype.set = function(v, offset) {
          console.log('.set() is deprecated. Access using array indexes instead.');
          return this.writeUInt8(v, offset);
        };
        Buffer.prototype.readUInt8 = function(offset, noAssert) {
          if (!noAssert) {
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset < this.length, 'Trying to read beyond buffer length');
          }
          if (offset >= this.length)
            return;
          return this[offset];
        };
        function readUInt16(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');
          }
          var len = buf.length;
          if (offset >= len)
            return;
          var val;
          if (littleEndian) {
            val = buf[offset];
            if (offset + 1 < len)
              val |= buf[offset + 1] << 8;
          } else {
            val = buf[offset] << 8;
            if (offset + 1 < len)
              val |= buf[offset + 1];
          }
          return val;
        }
        Buffer.prototype.readUInt16LE = function(offset, noAssert) {
          return readUInt16(this, offset, true, noAssert);
        };
        Buffer.prototype.readUInt16BE = function(offset, noAssert) {
          return readUInt16(this, offset, false, noAssert);
        };
        function readUInt32(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
          }
          var len = buf.length;
          if (offset >= len)
            return;
          var val;
          if (littleEndian) {
            if (offset + 2 < len)
              val = buf[offset + 2] << 16;
            if (offset + 1 < len)
              val |= buf[offset + 1] << 8;
            val |= buf[offset];
            if (offset + 3 < len)
              val = val + (buf[offset + 3] << 24 >>> 0);
          } else {
            if (offset + 1 < len)
              val = buf[offset + 1] << 16;
            if (offset + 2 < len)
              val |= buf[offset + 2] << 8;
            if (offset + 3 < len)
              val |= buf[offset + 3];
            val = val + (buf[offset] << 24 >>> 0);
          }
          return val;
        }
        Buffer.prototype.readUInt32LE = function(offset, noAssert) {
          return readUInt32(this, offset, true, noAssert);
        };
        Buffer.prototype.readUInt32BE = function(offset, noAssert) {
          return readUInt32(this, offset, false, noAssert);
        };
        Buffer.prototype.readInt8 = function(offset, noAssert) {
          if (!noAssert) {
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset < this.length, 'Trying to read beyond buffer length');
          }
          if (offset >= this.length)
            return;
          var neg = this[offset] & 0x80;
          if (neg)
            return (0xff - this[offset] + 1) * -1;
          else
            return this[offset];
        };
        function readInt16(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');
          }
          var len = buf.length;
          if (offset >= len)
            return;
          var val = readUInt16(buf, offset, littleEndian, true);
          var neg = val & 0x8000;
          if (neg)
            return (0xffff - val + 1) * -1;
          else
            return val;
        }
        Buffer.prototype.readInt16LE = function(offset, noAssert) {
          return readInt16(this, offset, true, noAssert);
        };
        Buffer.prototype.readInt16BE = function(offset, noAssert) {
          return readInt16(this, offset, false, noAssert);
        };
        function readInt32(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
          }
          var len = buf.length;
          if (offset >= len)
            return;
          var val = readUInt32(buf, offset, littleEndian, true);
          var neg = val & 0x80000000;
          if (neg)
            return (0xffffffff - val + 1) * -1;
          else
            return val;
        }
        Buffer.prototype.readInt32LE = function(offset, noAssert) {
          return readInt32(this, offset, true, noAssert);
        };
        Buffer.prototype.readInt32BE = function(offset, noAssert) {
          return readInt32(this, offset, false, noAssert);
        };
        function readFloat(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
          }
          return ieee754.read(buf, offset, littleEndian, 23, 4);
        }
        Buffer.prototype.readFloatLE = function(offset, noAssert) {
          return readFloat(this, offset, true, noAssert);
        };
        Buffer.prototype.readFloatBE = function(offset, noAssert) {
          return readFloat(this, offset, false, noAssert);
        };
        function readDouble(buf, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset + 7 < buf.length, 'Trying to read beyond buffer length');
          }
          return ieee754.read(buf, offset, littleEndian, 52, 8);
        }
        Buffer.prototype.readDoubleLE = function(offset, noAssert) {
          return readDouble(this, offset, true, noAssert);
        };
        Buffer.prototype.readDoubleBE = function(offset, noAssert) {
          return readDouble(this, offset, false, noAssert);
        };
        Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset < this.length, 'trying to write beyond buffer length');
            verifuint(value, 0xff);
          }
          if (offset >= this.length)
            return;
          this[offset] = value;
          return offset + 1;
        };
        function writeUInt16(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 1 < buf.length, 'trying to write beyond buffer length');
            verifuint(value, 0xffff);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          for (var i = 0,
              j = Math.min(len - offset, 2); i < j; i++) {
            buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
          }
          return offset + 2;
        }
        Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
          return writeUInt16(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
          return writeUInt16(this, value, offset, false, noAssert);
        };
        function writeUInt32(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'trying to write beyond buffer length');
            verifuint(value, 0xffffffff);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          for (var i = 0,
              j = Math.min(len - offset, 4); i < j; i++) {
            buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
          }
          return offset + 4;
        }
        Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
          return writeUInt32(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
          return writeUInt32(this, value, offset, false, noAssert);
        };
        Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset < this.length, 'Trying to write beyond buffer length');
            verifsint(value, 0x7f, -0x80);
          }
          if (offset >= this.length)
            return;
          if (value >= 0)
            this.writeUInt8(value, offset, noAssert);
          else
            this.writeUInt8(0xff + value + 1, offset, noAssert);
          return offset + 1;
        };
        function writeInt16(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 1 < buf.length, 'Trying to write beyond buffer length');
            verifsint(value, 0x7fff, -0x8000);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          if (value >= 0)
            writeUInt16(buf, value, offset, littleEndian, noAssert);
          else
            writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert);
          return offset + 2;
        }
        Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
          return writeInt16(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
          return writeInt16(this, value, offset, false, noAssert);
        };
        function writeInt32(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');
            verifsint(value, 0x7fffffff, -0x80000000);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          if (value >= 0)
            writeUInt32(buf, value, offset, littleEndian, noAssert);
          else
            writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert);
          return offset + 4;
        }
        Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
          return writeInt32(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
          return writeInt32(this, value, offset, false, noAssert);
        };
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');
            verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            assert(value !== undefined && value !== null, 'missing value');
            assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
            assert(offset !== undefined && offset !== null, 'missing offset');
            assert(offset + 7 < buf.length, 'Trying to write beyond buffer length');
            verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
          }
          var len = buf.length;
          if (offset >= len)
            return;
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.fill = function(value, start, end) {
          if (!value)
            value = 0;
          if (!start)
            start = 0;
          if (!end)
            end = this.length;
          assert(end >= start, 'end < start');
          if (end === start)
            return;
          if (this.length === 0)
            return;
          assert(start >= 0 && start < this.length, 'start out of bounds');
          assert(end >= 0 && end <= this.length, 'end out of bounds');
          var i;
          if (typeof value === 'number') {
            for (i = start; i < end; i++) {
              this[i] = value;
            }
          } else {
            var bytes = utf8ToBytes(value.toString());
            var len = bytes.length;
            for (i = start; i < end; i++) {
              this[i] = bytes[i % len];
            }
          }
          return this;
        };
        Buffer.prototype.inspect = function() {
          var out = [];
          var len = this.length;
          for (var i = 0; i < len; i++) {
            out[i] = toHex(this[i]);
            if (i === exports.INSPECT_MAX_BYTES) {
              out[i + 1] = '...';
              break;
            }
          }
          return '<Buffer ' + out.join(' ') + '>';
        };
        Buffer.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array !== 'undefined') {
            if (Buffer._useTypedArrays) {
              return (new Buffer(this)).buffer;
            } else {
              var buf = new Uint8Array(this.length);
              for (var i = 0,
                  len = buf.length; i < len; i += 1) {
                buf[i] = this[i];
              }
              return buf.buffer;
            }
          } else {
            throw new Error('Buffer.toArrayBuffer not supported in this browser');
          }
        };
        var BP = Buffer.prototype;
        Buffer._augment = function(arr) {
          arr._isBuffer = true;
          arr._get = arr.get;
          arr._set = arr.set;
          arr.get = BP.get;
          arr.set = BP.set;
          arr.write = BP.write;
          arr.toString = BP.toString;
          arr.toLocaleString = BP.toString;
          arr.toJSON = BP.toJSON;
          arr.equals = BP.equals;
          arr.compare = BP.compare;
          arr.copy = BP.copy;
          arr.slice = BP.slice;
          arr.readUInt8 = BP.readUInt8;
          arr.readUInt16LE = BP.readUInt16LE;
          arr.readUInt16BE = BP.readUInt16BE;
          arr.readUInt32LE = BP.readUInt32LE;
          arr.readUInt32BE = BP.readUInt32BE;
          arr.readInt8 = BP.readInt8;
          arr.readInt16LE = BP.readInt16LE;
          arr.readInt16BE = BP.readInt16BE;
          arr.readInt32LE = BP.readInt32LE;
          arr.readInt32BE = BP.readInt32BE;
          arr.readFloatLE = BP.readFloatLE;
          arr.readFloatBE = BP.readFloatBE;
          arr.readDoubleLE = BP.readDoubleLE;
          arr.readDoubleBE = BP.readDoubleBE;
          arr.writeUInt8 = BP.writeUInt8;
          arr.writeUInt16LE = BP.writeUInt16LE;
          arr.writeUInt16BE = BP.writeUInt16BE;
          arr.writeUInt32LE = BP.writeUInt32LE;
          arr.writeUInt32BE = BP.writeUInt32BE;
          arr.writeInt8 = BP.writeInt8;
          arr.writeInt16LE = BP.writeInt16LE;
          arr.writeInt16BE = BP.writeInt16BE;
          arr.writeInt32LE = BP.writeInt32LE;
          arr.writeInt32BE = BP.writeInt32BE;
          arr.writeFloatLE = BP.writeFloatLE;
          arr.writeFloatBE = BP.writeFloatBE;
          arr.writeDoubleLE = BP.writeDoubleLE;
          arr.writeDoubleBE = BP.writeDoubleBE;
          arr.fill = BP.fill;
          arr.inspect = BP.inspect;
          arr.toArrayBuffer = BP.toArrayBuffer;
          return arr;
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-z]/g;
        function base64clean(str) {
          str = stringtrim(str).replace(INVALID_BASE64_RE, '');
          while (str.length % 4 !== 0) {
            str = str + '=';
          }
          return str;
        }
        function stringtrim(str) {
          if (str.trim)
            return str.trim();
          return str.replace(/^\s+|\s+$/g, '');
        }
        function clamp(index, len, defaultValue) {
          if (typeof index !== 'number')
            return defaultValue;
          index = ~~index;
          if (index >= len)
            return len;
          if (index >= 0)
            return index;
          index += len;
          if (index >= 0)
            return index;
          return 0;
        }
        function coerce(length) {
          length = ~~Math.ceil(+length);
          return length < 0 ? 0 : length;
        }
        function isArray(subject) {
          return (Array.isArray || function(subject) {
            return Object.prototype.toString.call(subject) === '[object Array]';
          })(subject);
        }
        function isArrayish(subject) {
          return isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === 'object' && typeof subject.length === 'number';
        }
        function toHex(n) {
          if (n < 16)
            return '0' + n.toString(16);
          return n.toString(16);
        }
        function utf8ToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            var b = str.charCodeAt(i);
            if (b <= 0x7F) {
              byteArray.push(b);
            } else {
              var start = i;
              if (b >= 0xD800 && b <= 0xDFFF)
                i++;
              var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%');
              for (var j = 0; j < h.length; j++) {
                byteArray.push(parseInt(h[j], 16));
              }
            }
          }
          return byteArray;
        }
        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            byteArray.push(str.charCodeAt(i) & 0xFF);
          }
          return byteArray;
        }
        function utf16leToBytes(str) {
          var c,
              hi,
              lo;
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes(str) {
          return base64.toByteArray(str);
        }
        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; i++) {
            if ((i + offset >= dst.length) || (i >= src.length))
              break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        function decodeUtf8Char(str) {
          try {
            return decodeURIComponent(str);
          } catch (err) {
            return String.fromCharCode(0xFFFD);
          }
        }
        function verifuint(value, max) {
          assert(typeof value === 'number', 'cannot write a non-number as a number');
          assert(value >= 0, 'specified a negative value for writing an unsigned value');
          assert(value <= max, 'value is larger than maximum value for type');
          assert(Math.floor(value) === value, 'value has a fractional component');
        }
        function verifsint(value, max, min) {
          assert(typeof value === 'number', 'cannot write a non-number as a number');
          assert(value <= max, 'value larger than maximum allowed value');
          assert(value >= min, 'value smaller than minimum allowed value');
          assert(Math.floor(value) === value, 'value has a fractional component');
        }
        function verifIEEE754(value, max, min) {
          assert(typeof value === 'number', 'cannot write a non-number as a number');
          assert(value <= max, 'value larger than maximum allowed value');
          assert(value >= min, 'value smaller than minimum allowed value');
        }
        function assert(test, message) {
          if (!test)
            throw new Error(message || 'Failed assertion');
        }
      }, {
        "base64-js": 30,
        "ieee754": 31
      }],
      30: [function(require, module, exports) {
        var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        ;
        (function(exports) {
          'use strict';
          var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
          var PLUS = '+'.charCodeAt(0);
          var SLASH = '/'.charCodeAt(0);
          var NUMBER = '0'.charCodeAt(0);
          var LOWER = 'a'.charCodeAt(0);
          var UPPER = 'A'.charCodeAt(0);
          function decode(elt) {
            var code = elt.charCodeAt(0);
            if (code === PLUS)
              return 62;
            if (code === SLASH)
              return 63;
            if (code < NUMBER)
              return -1;
            if (code < NUMBER + 10)
              return code - NUMBER + 26 + 26;
            if (code < UPPER + 26)
              return code - UPPER;
            if (code < LOWER + 26)
              return code - LOWER + 26;
          }
          function b64ToByteArray(b64) {
            var i,
                j,
                l,
                tmp,
                placeHolders,
                arr;
            if (b64.length % 4 > 0) {
              throw new Error('Invalid string. Length must be a multiple of 4');
            }
            var len = b64.length;
            placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
            arr = new Arr(b64.length * 3 / 4 - placeHolders);
            l = placeHolders > 0 ? b64.length - 4 : b64.length;
            var L = 0;
            function push(v) {
              arr[L++] = v;
            }
            for (i = 0, j = 0; i < l; i += 4, j += 3) {
              tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
              push((tmp & 0xFF0000) >> 16);
              push((tmp & 0xFF00) >> 8);
              push(tmp & 0xFF);
            }
            if (placeHolders === 2) {
              tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
              push(tmp & 0xFF);
            } else if (placeHolders === 1) {
              tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
              push((tmp >> 8) & 0xFF);
              push(tmp & 0xFF);
            }
            return arr;
          }
          function uint8ToBase64(uint8) {
            var i,
                extraBytes = uint8.length % 3,
                output = "",
                temp,
                length;
            function encode(num) {
              return lookup.charAt(num);
            }
            function tripletToBase64(num) {
              return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
            }
            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
              temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
              output += tripletToBase64(temp);
            }
            switch (extraBytes) {
              case 1:
                temp = uint8[uint8.length - 1];
                output += encode(temp >> 2);
                output += encode((temp << 4) & 0x3F);
                output += '==';
                break;
              case 2:
                temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
                output += encode(temp >> 10);
                output += encode((temp >> 4) & 0x3F);
                output += encode((temp << 2) & 0x3F);
                output += '=';
                break;
            }
            return output;
          }
          exports.toByteArray = b64ToByteArray;
          exports.fromByteArray = uint8ToBase64;
        }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
      }, {}],
      31: [function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e,
              m,
              eLen = nBytes * 8 - mLen - 1,
              eMax = (1 << eLen) - 1,
              eBias = eMax >> 1,
              nBits = -7,
              i = isLE ? (nBytes - 1) : 0,
              d = isLE ? -1 : 1,
              s = buffer[offset + i];
          i += d;
          e = s & ((1 << (-nBits)) - 1);
          s >>= (-nBits);
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
            ;
          m = e & ((1 << (-nBits)) - 1);
          e >>= (-nBits);
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
            ;
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e,
              m,
              c,
              eLen = nBytes * 8 - mLen - 1,
              eMax = (1 << eLen) - 1,
              eBias = eMax >> 1,
              rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
              i = isLE ? 0 : (nBytes - 1),
              d = isLE ? 1 : -1,
              s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8)
            ;
          e = (e << mLen) | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8)
            ;
          buffer[offset + i - d] |= s * 128;
        };
      }, {}],
      32: [function(require, module, exports) {
        (function(Buffer) {
          var createHash = require('sha.js');
          var md5 = toConstructor(require('./md5'));
          var rmd160 = toConstructor(require('ripemd160'));
          function toConstructor(fn) {
            return function() {
              var buffers = [];
              var m = {
                update: function(data, enc) {
                  if (!Buffer.isBuffer(data))
                    data = new Buffer(data, enc);
                  buffers.push(data);
                  return this;
                },
                digest: function(enc) {
                  var buf = Buffer.concat(buffers);
                  var r = fn(buf);
                  buffers = null;
                  return enc ? r.toString(enc) : r;
                }
              };
              return m;
            };
          }
          module.exports = function(alg) {
            if ('md5' === alg)
              return new md5();
            if ('rmd160' === alg)
              return new rmd160();
            return createHash(alg);
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "./md5": 36,
        "buffer": 29,
        "ripemd160": 37,
        "sha.js": 39
      }],
      33: [function(require, module, exports) {
        (function(Buffer) {
          var createHash = require('./create-hash');
          var blocksize = 64;
          var zeroBuffer = new Buffer(blocksize);
          zeroBuffer.fill(0);
          module.exports = Hmac;
          function Hmac(alg, key) {
            if (!(this instanceof Hmac))
              return new Hmac(alg, key);
            this._opad = opad;
            this._alg = alg;
            key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key;
            if (key.length > blocksize) {
              key = createHash(alg).update(key).digest();
            } else if (key.length < blocksize) {
              key = Buffer.concat([key, zeroBuffer], blocksize);
            }
            var ipad = this._ipad = new Buffer(blocksize);
            var opad = this._opad = new Buffer(blocksize);
            for (var i = 0; i < blocksize; i++) {
              ipad[i] = key[i] ^ 0x36;
              opad[i] = key[i] ^ 0x5C;
            }
            this._hash = createHash(alg).update(ipad);
          }
          Hmac.prototype.update = function(data, enc) {
            this._hash.update(data, enc);
            return this;
          };
          Hmac.prototype.digest = function(enc) {
            var h = this._hash.digest();
            return createHash(this._alg).update(this._opad).update(h).digest(enc);
          };
        }).call(this, require("buffer").Buffer);
      }, {
        "./create-hash": 32,
        "buffer": 29
      }],
      34: [function(require, module, exports) {
        (function(Buffer) {
          var intSize = 4;
          var zeroBuffer = new Buffer(intSize);
          zeroBuffer.fill(0);
          var chrsz = 8;
          function toArray(buf, bigEndian) {
            if ((buf.length % intSize) !== 0) {
              var len = buf.length + (intSize - (buf.length % intSize));
              buf = Buffer.concat([buf, zeroBuffer], len);
            }
            var arr = [];
            var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
            for (var i = 0; i < buf.length; i += intSize) {
              arr.push(fn.call(buf, i));
            }
            return arr;
          }
          function toBuffer(arr, size, bigEndian) {
            var buf = new Buffer(size);
            var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
            for (var i = 0; i < arr.length; i++) {
              fn.call(buf, arr[i], i * 4, true);
            }
            return buf;
          }
          function hash(buf, fn, hashSize, bigEndian) {
            if (!Buffer.isBuffer(buf))
              buf = new Buffer(buf);
            var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
            return toBuffer(arr, hashSize, bigEndian);
          }
          module.exports = {hash: hash};
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      35: [function(require, module, exports) {
        (function(Buffer) {
          var rng = require('./rng');
          function error() {
            var m = [].slice.call(arguments).join(' ');
            throw new Error([m, 'we accept pull requests', 'http://github.com/dominictarr/crypto-browserify'].join('\n'));
          }
          exports.createHash = require('./create-hash');
          exports.createHmac = require('./create-hmac');
          exports.randomBytes = function(size, callback) {
            if (callback && callback.call) {
              try {
                callback.call(this, undefined, new Buffer(rng(size)));
              } catch (err) {
                callback(err);
              }
            } else {
              return new Buffer(rng(size));
            }
          };
          function each(a, f) {
            for (var i in a)
              f(a[i], i);
          }
          exports.getHashes = function() {
            return ['sha1', 'sha256', 'md5', 'rmd160'];
          };
          var p = require('./pbkdf2')(exports.createHmac);
          exports.pbkdf2 = p.pbkdf2;
          exports.pbkdf2Sync = p.pbkdf2Sync;
          each(['createCredentials', 'createCipher', 'createCipheriv', 'createDecipher', 'createDecipheriv', 'createSign', 'createVerify', 'createDiffieHellman'], function(name) {
            exports[name] = function() {
              error('sorry,', name, 'is not implemented yet');
            };
          });
        }).call(this, require("buffer").Buffer);
      }, {
        "./create-hash": 32,
        "./create-hmac": 33,
        "./pbkdf2": 43,
        "./rng": 44,
        "buffer": 29
      }],
      36: [function(require, module, exports) {
        var helpers = require('./helpers');
        function core_md5(x, len) {
          x[len >> 5] |= 0x80 << ((len) % 32);
          x[(((len + 64) >>> 9) << 4) + 14] = len;
          var a = 1732584193;
          var b = -271733879;
          var c = -1732584194;
          var d = 271733878;
          for (var i = 0; i < x.length; i += 16) {
            var olda = a;
            var oldb = b;
            var oldc = c;
            var oldd = d;
            a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
            d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
            d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
          }
          return Array(a, b, c, d);
        }
        function md5_cmn(q, a, b, x, s, t) {
          return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
        }
        function md5_ff(a, b, c, d, x, s, t) {
          return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
        }
        function md5_gg(a, b, c, d, x, s, t) {
          return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
        }
        function md5_hh(a, b, c, d, x, s, t) {
          return md5_cmn(b ^ c ^ d, a, b, x, s, t);
        }
        function md5_ii(a, b, c, d, x, s, t) {
          return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
        }
        function safe_add(x, y) {
          var lsw = (x & 0xFFFF) + (y & 0xFFFF);
          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return (msw << 16) | (lsw & 0xFFFF);
        }
        function bit_rol(num, cnt) {
          return (num << cnt) | (num >>> (32 - cnt));
        }
        module.exports = function md5(buf) {
          return helpers.hash(buf, core_md5, 16);
        };
      }, {"./helpers": 34}],
      37: [function(require, module, exports) {
        (function(Buffer) {
          module.exports = ripemd160;
          var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
          var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
          var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
          var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
          var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
          var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
          var bytesToWords = function(bytes) {
            var words = [];
            for (var i = 0,
                b = 0; i < bytes.length; i++, b += 8) {
              words[b >>> 5] |= bytes[i] << (24 - b % 32);
            }
            return words;
          };
          var wordsToBytes = function(words) {
            var bytes = [];
            for (var b = 0; b < words.length * 32; b += 8) {
              bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
            }
            return bytes;
          };
          var processBlock = function(H, M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
            }
            var al,
                bl,
                cl,
                dl,
                el;
            var ar,
                br,
                cr,
                dr,
                er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = (al + M[offset + zl[i]]) | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = (t + el) | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = (ar + M[offset + zr[i]]) | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = (t + er) | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = (H[1] + cl + dr) | 0;
            H[1] = (H[2] + dl + er) | 0;
            H[2] = (H[3] + el + ar) | 0;
            H[3] = (H[4] + al + br) | 0;
            H[4] = (H[0] + bl + cr) | 0;
            H[0] = t;
          };
          function f1(x, y, z) {
            return ((x) ^ (y) ^ (z));
          }
          function f2(x, y, z) {
            return (((x) & (y)) | ((~x) & (z)));
          }
          function f3(x, y, z) {
            return (((x) | (~(y))) ^ (z));
          }
          function f4(x, y, z) {
            return (((x) & (z)) | ((y) & (~(z))));
          }
          function f5(x, y, z) {
            return ((x) ^ ((y) | (~(z))));
          }
          function rotl(x, n) {
            return (x << n) | (x >>> (32 - n));
          }
          function ripemd160(message) {
            var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
            if (typeof message == 'string')
              message = new Buffer(message, 'utf8');
            var m = bytesToWords(message);
            var nBitsLeft = message.length * 8;
            var nBitsTotal = message.length * 8;
            m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00));
            for (var i = 0; i < m.length; i += 16) {
              processBlock(H, m, i);
            }
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
            }
            var digestbytes = wordsToBytes(H);
            return new Buffer(digestbytes);
          }
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      38: [function(require, module, exports) {
        var u = require('./util');
        var write = u.write;
        var fill = u.zeroFill;
        module.exports = function(Buffer) {
          function Hash(blockSize, finalSize) {
            this._block = new Buffer(blockSize);
            this._finalSize = finalSize;
            this._blockSize = blockSize;
            this._len = 0;
            this._s = 0;
          }
          Hash.prototype.init = function() {
            this._s = 0;
            this._len = 0;
          };
          function lengthOf(data, enc) {
            if (enc == null)
              return data.byteLength || data.length;
            if (enc == 'ascii' || enc == 'binary')
              return data.length;
            if (enc == 'hex')
              return data.length / 2;
            if (enc == 'base64')
              return data.length / 3;
          }
          Hash.prototype.update = function(data, enc) {
            var bl = this._blockSize;
            var length;
            if (!enc && 'string' === typeof data)
              enc = 'utf8';
            if (enc) {
              if (enc === 'utf-8')
                enc = 'utf8';
              if (enc === 'base64' || enc === 'utf8')
                data = new Buffer(data, enc), enc = null;
              length = lengthOf(data, enc);
            } else
              length = data.byteLength || data.length;
            var l = this._len += length;
            var s = this._s = (this._s || 0);
            var f = 0;
            var buffer = this._block;
            while (s < l) {
              var t = Math.min(length, f + bl);
              write(buffer, data, enc, s % bl, f, t);
              var ch = (t - f);
              s += ch;
              f += ch;
              if (!(s % bl))
                this._update(buffer);
            }
            this._s = s;
            return this;
          };
          Hash.prototype.digest = function(enc) {
            var bl = this._blockSize;
            var fl = this._finalSize;
            var len = this._len * 8;
            var x = this._block;
            var bits = len % (bl * 8);
            x[this._len % bl] = 0x80;
            fill(this._block, this._len % bl + 1);
            if (bits >= fl * 8) {
              this._update(this._block);
              u.zeroFill(this._block, 0);
            }
            x.writeInt32BE(len, fl + 4);
            var hash = this._update(this._block) || this._hash();
            if (enc == null)
              return hash;
            return hash.toString(enc);
          };
          Hash.prototype._update = function() {
            throw new Error('_update must be implemented by subclass');
          };
          return Hash;
        };
      }, {"./util": 42}],
      39: [function(require, module, exports) {
        var exports = module.exports = function(alg) {
          var Alg = exports[alg];
          if (!Alg)
            throw new Error(alg + ' is not supported (we accept pull requests)');
          return new Alg();
        };
        var Buffer = require('buffer').Buffer;
        var Hash = require('./hash')(Buffer);
        exports.sha = exports.sha1 = require('./sha1')(Buffer, Hash);
        exports.sha256 = require('./sha256')(Buffer, Hash);
      }, {
        "./hash": 38,
        "./sha1": 40,
        "./sha256": 41,
        "buffer": 29
      }],
      40: [function(require, module, exports) {
        module.exports = function(Buffer, Hash) {
          var inherits = require('util').inherits;
          inherits(Sha1, Hash);
          var A = 0 | 0;
          var B = 4 | 0;
          var C = 8 | 0;
          var D = 12 | 0;
          var E = 16 | 0;
          var BE = false;
          var LE = true;
          var W = new Int32Array(80);
          var POOL = [];
          function Sha1() {
            if (POOL.length)
              return POOL.pop().init();
            if (!(this instanceof Sha1))
              return new Sha1();
            this._w = W;
            Hash.call(this, 16 * 4, 14 * 4);
            this._h = null;
            this.init();
          }
          Sha1.prototype.init = function() {
            this._a = 0x67452301;
            this._b = 0xefcdab89;
            this._c = 0x98badcfe;
            this._d = 0x10325476;
            this._e = 0xc3d2e1f0;
            Hash.prototype.init.call(this);
            return this;
          };
          Sha1.prototype._POOL = POOL;
          var isDV = new Buffer(1) instanceof DataView;
          function readInt32BE(X, i) {
            return isDV ? X.getInt32(i, false) : X.readInt32BE(i);
          }
          Sha1.prototype._update = function(array) {
            var X = this._block;
            var h = this._h;
            var a,
                b,
                c,
                d,
                e,
                _a,
                _b,
                _c,
                _d,
                _e;
            a = _a = this._a;
            b = _b = this._b;
            c = _c = this._c;
            d = _d = this._d;
            e = _e = this._e;
            var w = this._w;
            for (var j = 0; j < 80; j++) {
              var W = w[j] = j < 16 ? X.readInt32BE(j * 4) : rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
              var t = add(add(rol(a, 5), sha1_ft(j, b, c, d)), add(add(e, W), sha1_kt(j)));
              e = d;
              d = c;
              c = rol(b, 30);
              b = a;
              a = t;
            }
            this._a = add(a, _a);
            this._b = add(b, _b);
            this._c = add(c, _c);
            this._d = add(d, _d);
            this._e = add(e, _e);
          };
          Sha1.prototype._hash = function() {
            if (POOL.length < 100)
              POOL.push(this);
            var H = new Buffer(20);
            H.writeInt32BE(this._a | 0, A);
            H.writeInt32BE(this._b | 0, B);
            H.writeInt32BE(this._c | 0, C);
            H.writeInt32BE(this._d | 0, D);
            H.writeInt32BE(this._e | 0, E);
            return H;
          };
          function sha1_ft(t, b, c, d) {
            if (t < 20)
              return (b & c) | ((~b) & d);
            if (t < 40)
              return b ^ c ^ d;
            if (t < 60)
              return (b & c) | (b & d) | (c & d);
            return b ^ c ^ d;
          }
          function sha1_kt(t) {
            return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514;
          }
          function add(x, y) {
            return (x + y) | 0;
          }
          function rol(num, cnt) {
            return (num << cnt) | (num >>> (32 - cnt));
          }
          return Sha1;
        };
      }, {"util": 72}],
      41: [function(require, module, exports) {
        var inherits = require('util').inherits;
        var BE = false;
        var LE = true;
        var u = require('./util');
        module.exports = function(Buffer, Hash) {
          var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
          inherits(Sha256, Hash);
          var W = new Array(64);
          var POOL = [];
          function Sha256() {
            if (POOL.length) {}
            this.init();
            this._w = W;
            Hash.call(this, 16 * 4, 14 * 4);
          }
          ;
          Sha256.prototype.init = function() {
            this._a = 0x6a09e667 | 0;
            this._b = 0xbb67ae85 | 0;
            this._c = 0x3c6ef372 | 0;
            this._d = 0xa54ff53a | 0;
            this._e = 0x510e527f | 0;
            this._f = 0x9b05688c | 0;
            this._g = 0x1f83d9ab | 0;
            this._h = 0x5be0cd19 | 0;
            this._len = this._s = 0;
            return this;
          };
          var safe_add = function(x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
          };
          function S(X, n) {
            return (X >>> n) | (X << (32 - n));
          }
          function R(X, n) {
            return (X >>> n);
          }
          function Ch(x, y, z) {
            return ((x & y) ^ ((~x) & z));
          }
          function Maj(x, y, z) {
            return ((x & y) ^ (x & z) ^ (y & z));
          }
          function Sigma0256(x) {
            return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
          }
          function Sigma1256(x) {
            return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
          }
          function Gamma0256(x) {
            return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
          }
          function Gamma1256(x) {
            return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
          }
          Sha256.prototype._update = function(m) {
            var M = this._block;
            var W = this._w;
            var a,
                b,
                c,
                d,
                e,
                f,
                g,
                h;
            var T1,
                T2;
            a = this._a | 0;
            b = this._b | 0;
            c = this._c | 0;
            d = this._d | 0;
            e = this._e | 0;
            f = this._f | 0;
            g = this._g | 0;
            h = this._h | 0;
            for (var j = 0; j < 64; j++) {
              var w = W[j] = j < 16 ? M.readInt32BE(j * 4) : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16];
              T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w;
              T2 = Sigma0256(a) + Maj(a, b, c);
              h = g;
              g = f;
              f = e;
              e = d + T1;
              d = c;
              c = b;
              b = a;
              a = T1 + T2;
            }
            this._a = (a + this._a) | 0;
            this._b = (b + this._b) | 0;
            this._c = (c + this._c) | 0;
            this._d = (d + this._d) | 0;
            this._e = (e + this._e) | 0;
            this._f = (f + this._f) | 0;
            this._g = (g + this._g) | 0;
            this._h = (h + this._h) | 0;
          };
          Sha256.prototype._hash = function() {
            if (POOL.length < 10)
              POOL.push(this);
            var H = new Buffer(32);
            H.writeInt32BE(this._a, 0);
            H.writeInt32BE(this._b, 4);
            H.writeInt32BE(this._c, 8);
            H.writeInt32BE(this._d, 12);
            H.writeInt32BE(this._e, 16);
            H.writeInt32BE(this._f, 20);
            H.writeInt32BE(this._g, 24);
            H.writeInt32BE(this._h, 28);
            return H;
          };
          return Sha256;
        };
      }, {
        "./util": 42,
        "util": 72
      }],
      42: [function(require, module, exports) {
        exports.write = write;
        exports.zeroFill = zeroFill;
        exports.toString = toString;
        function write(buffer, string, enc, start, from, to, LE) {
          var l = (to - from);
          if (enc === 'ascii' || enc === 'binary') {
            for (var i = 0; i < l; i++) {
              buffer[start + i] = string.charCodeAt(i + from);
            }
          } else if (enc == null) {
            for (var i = 0; i < l; i++) {
              buffer[start + i] = string[i + from];
            }
          } else if (enc === 'hex') {
            for (var i = 0; i < l; i++) {
              var j = from + i;
              buffer[start + i] = parseInt(string[j * 2] + string[(j * 2) + 1], 16);
            }
          } else if (enc === 'base64') {
            throw new Error('base64 encoding not yet supported');
          } else
            throw new Error(enc + ' encoding not yet supported');
        }
        function zeroFill(buf, from) {
          for (var i = from; i < buf.length; i++)
            buf[i] = 0;
        }
      }, {}],
      43: [function(require, module, exports) {
        (function(Buffer) {
          var blocksize = 64;
          var zeroBuffer = new Buffer(blocksize);
          zeroBuffer.fill(0);
          module.exports = function(createHmac, exports) {
            exports = exports || {};
            exports.pbkdf2 = function(password, salt, iterations, keylen, cb) {
              if ('function' !== typeof cb)
                throw new Error('No callback provided to pbkdf2');
              setTimeout(function() {
                cb(null, exports.pbkdf2Sync(password, salt, iterations, keylen));
              });
            };
            exports.pbkdf2Sync = function(key, salt, iterations, keylen) {
              if ('number' !== typeof iterations)
                throw new TypeError('Iterations not a number');
              if (iterations < 0)
                throw new TypeError('Bad iterations');
              if ('number' !== typeof keylen)
                throw new TypeError('Key length not a number');
              if (keylen < 0)
                throw new TypeError('Bad key length');
              var key = !Buffer.isBuffer(key) ? new Buffer(key) : key;
              if (key.length > blocksize) {
                key = createHash(alg).update(key).digest();
              } else if (key.length < blocksize) {
                key = Buffer.concat([key, zeroBuffer], blocksize);
              }
              var HMAC;
              var cplen,
                  p = 0,
                  i = 1,
                  itmp = new Buffer(4),
                  digtmp;
              var out = new Buffer(keylen);
              out.fill(0);
              while (keylen) {
                if (keylen > 20)
                  cplen = 20;
                else
                  cplen = keylen;
                itmp[0] = (i >> 24) & 0xff;
                itmp[1] = (i >> 16) & 0xff;
                itmp[2] = (i >> 8) & 0xff;
                itmp[3] = i & 0xff;
                HMAC = createHmac('sha1', key);
                HMAC.update(salt);
                HMAC.update(itmp);
                digtmp = HMAC.digest();
                digtmp.copy(out, p, 0, cplen);
                for (var j = 1; j < iterations; j++) {
                  HMAC = createHmac('sha1', key);
                  HMAC.update(digtmp);
                  digtmp = HMAC.digest();
                  for (var k = 0; k < cplen; k++) {
                    out[k] ^= digtmp[k];
                  }
                }
                keylen -= cplen;
                i++;
                p += cplen;
              }
              return out;
            };
            return exports;
          };
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      44: [function(require, module, exports) {
        (function(Buffer) {
          (function() {
            var _global = this;
            var mathRNG,
                whatwgRNG;
            mathRNG = function(size) {
              var bytes = new Buffer(size);
              var r;
              for (var i = 0,
                  r; i < size; i++) {
                if ((i & 0x03) == 0)
                  r = Math.random() * 0x100000000;
                bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
              }
              return bytes;
            };
            if (_global.crypto && crypto.getRandomValues) {
              whatwgRNG = function(size) {
                var bytes = new Buffer(size);
                crypto.getRandomValues(bytes);
                return bytes;
              };
            }
            module.exports = whatwgRNG || mathRNG;
          }());
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      45: [function(require, module, exports) {
        function EventEmitter() {
          this._events = this._events || {};
          this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;
        EventEmitter.defaultMaxListeners = 10;
        EventEmitter.prototype.setMaxListeners = function(n) {
          if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
          this._maxListeners = n;
          return this;
        };
        EventEmitter.prototype.emit = function(type) {
          var er,
              handler,
              len,
              args,
              i,
              listeners;
          if (!this._events)
            this._events = {};
          if (type === 'error') {
            if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
              er = arguments[1];
              if (er instanceof Error) {
                throw er;
              } else {
                throw TypeError('Uncaught, unspecified "error" event.');
              }
              return false;
            }
          }
          handler = this._events[type];
          if (isUndefined(handler))
            return false;
          if (isFunction(handler)) {
            switch (arguments.length) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                len = arguments.length;
                args = new Array(len - 1);
                for (i = 1; i < len; i++)
                  args[i - 1] = arguments[i];
                handler.apply(this, args);
            }
          } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
              listeners[i].apply(this, args);
          }
          return true;
        };
        EventEmitter.prototype.addListener = function(type, listener) {
          var m;
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          if (!this._events)
            this._events = {};
          if (this._events.newListener)
            this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
          if (!this._events[type])
            this._events[type] = listener;
          else if (isObject(this._events[type]))
            this._events[type].push(listener);
          else
            this._events[type] = [this._events[type], listener];
          if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
              m = this._maxListeners;
            } else {
              m = EventEmitter.defaultMaxListeners;
            }
            if (m && m > 0 && this._events[type].length > m) {
              this._events[type].warned = true;
              console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
              if (typeof console.trace === 'function') {
                console.trace();
              }
            }
          }
          return this;
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.once = function(type, listener) {
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          var fired = false;
          function g() {
            this.removeListener(type, g);
            if (!fired) {
              fired = true;
              listener.apply(this, arguments);
            }
          }
          g.listener = listener;
          this.on(type, g);
          return this;
        };
        EventEmitter.prototype.removeListener = function(type, listener) {
          var list,
              position,
              length,
              i;
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          if (!this._events || !this._events[type])
            return this;
          list = this._events[type];
          length = list.length;
          position = -1;
          if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
            delete this._events[type];
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          } else if (isObject(list)) {
            for (i = length; i-- > 0; ) {
              if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
                position = i;
                break;
              }
            }
            if (position < 0)
              return this;
            if (list.length === 1) {
              list.length = 0;
              delete this._events[type];
            } else {
              list.splice(position, 1);
            }
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function(type) {
          var key,
              listeners;
          if (!this._events)
            return this;
          if (!this._events.removeListener) {
            if (arguments.length === 0)
              this._events = {};
            else if (this._events[type])
              delete this._events[type];
            return this;
          }
          if (arguments.length === 0) {
            for (key in this._events) {
              if (key === 'removeListener')
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
          }
          listeners = this._events[type];
          if (isFunction(listeners)) {
            this.removeListener(type, listeners);
          } else {
            while (listeners.length)
              this.removeListener(type, listeners[listeners.length - 1]);
          }
          delete this._events[type];
          return this;
        };
        EventEmitter.prototype.listeners = function(type) {
          var ret;
          if (!this._events || !this._events[type])
            ret = [];
          else if (isFunction(this._events[type]))
            ret = [this._events[type]];
          else
            ret = this._events[type].slice();
          return ret;
        };
        EventEmitter.listenerCount = function(emitter, type) {
          var ret;
          if (!emitter._events || !emitter._events[type])
            ret = 0;
          else if (isFunction(emitter._events[type]))
            ret = 1;
          else
            ret = emitter._events[type].length;
          return ret;
        };
        function isFunction(arg) {
          return typeof arg === 'function';
        }
        function isNumber(arg) {
          return typeof arg === 'number';
        }
        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        function isUndefined(arg) {
          return arg === void 0;
        }
      }, {}],
      46: [function(require, module, exports) {
        var http = module.exports;
        var EventEmitter = require('events').EventEmitter;
        var Request = require('./lib/request');
        var url = require('url');
        http.request = function(params, cb) {
          if (typeof params === 'string') {
            params = url.parse(params);
          }
          if (!params)
            params = {};
          if (!params.host && !params.port) {
            params.port = parseInt(window.location.port, 10);
          }
          if (!params.host && params.hostname) {
            params.host = params.hostname;
          }
          if (!params.scheme)
            params.scheme = window.location.protocol.split(':')[0];
          if (!params.host) {
            params.host = window.location.hostname || window.location.host;
          }
          if (/:/.test(params.host)) {
            if (!params.port) {
              params.port = params.host.split(':')[1];
            }
            params.host = params.host.split(':')[0];
          }
          if (!params.port)
            params.port = params.scheme == 'https' ? 443 : 80;
          var req = new Request(new xhrHttp, params);
          if (cb)
            req.on('response', cb);
          return req;
        };
        http.get = function(params, cb) {
          params.method = 'GET';
          var req = http.request(params, cb);
          req.end();
          return req;
        };
        http.Agent = function() {};
        http.Agent.defaultMaxSockets = 4;
        var xhrHttp = (function() {
          if (typeof window === 'undefined') {
            throw new Error('no window object present');
          } else if (window.XMLHttpRequest) {
            return window.XMLHttpRequest;
          } else if (window.ActiveXObject) {
            var axs = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP'];
            for (var i = 0; i < axs.length; i++) {
              try {
                var ax = new (window.ActiveXObject)(axs[i]);
                return function() {
                  if (ax) {
                    var ax_ = ax;
                    ax = null;
                    return ax_;
                  } else {
                    return new (window.ActiveXObject)(axs[i]);
                  }
                };
              } catch (e) {}
            }
            throw new Error('ajax not supported in this browser');
          } else {
            throw new Error('ajax not supported in this browser');
          }
        })();
        http.STATUS_CODES = {
          100: 'Continue',
          101: 'Switching Protocols',
          102: 'Processing',
          200: 'OK',
          201: 'Created',
          202: 'Accepted',
          203: 'Non-Authoritative Information',
          204: 'No Content',
          205: 'Reset Content',
          206: 'Partial Content',
          207: 'Multi-Status',
          300: 'Multiple Choices',
          301: 'Moved Permanently',
          302: 'Moved Temporarily',
          303: 'See Other',
          304: 'Not Modified',
          305: 'Use Proxy',
          307: 'Temporary Redirect',
          400: 'Bad Request',
          401: 'Unauthorized',
          402: 'Payment Required',
          403: 'Forbidden',
          404: 'Not Found',
          405: 'Method Not Allowed',
          406: 'Not Acceptable',
          407: 'Proxy Authentication Required',
          408: 'Request Time-out',
          409: 'Conflict',
          410: 'Gone',
          411: 'Length Required',
          412: 'Precondition Failed',
          413: 'Request Entity Too Large',
          414: 'Request-URI Too Large',
          415: 'Unsupported Media Type',
          416: 'Requested Range Not Satisfiable',
          417: 'Expectation Failed',
          418: 'I\'m a teapot',
          422: 'Unprocessable Entity',
          423: 'Locked',
          424: 'Failed Dependency',
          425: 'Unordered Collection',
          426: 'Upgrade Required',
          428: 'Precondition Required',
          429: 'Too Many Requests',
          431: 'Request Header Fields Too Large',
          500: 'Internal Server Error',
          501: 'Not Implemented',
          502: 'Bad Gateway',
          503: 'Service Unavailable',
          504: 'Gateway Time-out',
          505: 'HTTP Version Not Supported',
          506: 'Variant Also Negotiates',
          507: 'Insufficient Storage',
          509: 'Bandwidth Limit Exceeded',
          510: 'Not Extended',
          511: 'Network Authentication Required'
        };
      }, {
        "./lib/request": 47,
        "events": 45,
        "url": 70
      }],
      47: [function(require, module, exports) {
        var Stream = require('stream');
        var Response = require('./response');
        var Base64 = require('Base64');
        var inherits = require('inherits');
        var Request = module.exports = function(xhr, params) {
          var self = this;
          self.writable = true;
          self.xhr = xhr;
          self.body = [];
          self.uri = (params.scheme || 'http') + '://' + params.host + (params.port ? ':' + params.port : '') + (params.path || '/');
          ;
          if (typeof params.withCredentials === 'undefined') {
            params.withCredentials = true;
          }
          try {
            xhr.withCredentials = params.withCredentials;
          } catch (e) {}
          if (params.responseType)
            try {
              xhr.responseType = params.responseType;
            } catch (e) {}
          xhr.open(params.method || 'GET', self.uri, true);
          self._headers = {};
          if (params.headers) {
            var keys = objectKeys(params.headers);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (!self.isSafeRequestHeader(key))
                continue;
              var value = params.headers[key];
              self.setHeader(key, value);
            }
          }
          if (params.auth) {
            this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
          }
          var res = new Response;
          res.on('close', function() {
            self.emit('close');
          });
          res.on('ready', function() {
            self.emit('response', res);
          });
          xhr.onreadystatechange = function() {
            if (xhr.__aborted)
              return;
            res.handle(xhr);
          };
        };
        inherits(Request, Stream);
        Request.prototype.setHeader = function(key, value) {
          this._headers[key.toLowerCase()] = value;
        };
        Request.prototype.getHeader = function(key) {
          return this._headers[key.toLowerCase()];
        };
        Request.prototype.removeHeader = function(key) {
          delete this._headers[key.toLowerCase()];
        };
        Request.prototype.write = function(s) {
          this.body.push(s);
        };
        Request.prototype.destroy = function(s) {
          this.xhr.__aborted = true;
          this.xhr.abort();
          this.emit('close');
        };
        Request.prototype.end = function(s) {
          if (s !== undefined)
            this.body.push(s);
          var keys = objectKeys(this._headers);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this._headers[key];
            if (isArray(value)) {
              for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
              }
            } else
              this.xhr.setRequestHeader(key, value);
          }
          if (this.body.length === 0) {
            this.xhr.send('');
          } else if (typeof this.body[0] === 'string') {
            this.xhr.send(this.body.join(''));
          } else if (isArray(this.body[0])) {
            var body = [];
            for (var i = 0; i < this.body.length; i++) {
              body.push.apply(body, this.body[i]);
            }
            this.xhr.send(body);
          } else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
            var len = 0;
            for (var i = 0; i < this.body.length; i++) {
              len += this.body[i].length;
            }
            var body = new (this.body[0].constructor)(len);
            var k = 0;
            for (var i = 0; i < this.body.length; i++) {
              var b = this.body[i];
              for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
              }
            }
            this.xhr.send(body);
          } else {
            var body = '';
            for (var i = 0; i < this.body.length; i++) {
              body += this.body[i].toString();
            }
            this.xhr.send(body);
          }
        };
        Request.unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];
        Request.prototype.isSafeRequestHeader = function(headerName) {
          if (!headerName)
            return false;
          return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
        };
        var objectKeys = Object.keys || function(obj) {
          var keys = [];
          for (var key in obj)
            keys.push(key);
          return keys;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
        var indexOf = function(xs, x) {
          if (xs.indexOf)
            return xs.indexOf(x);
          for (var i = 0; i < xs.length; i++) {
            if (xs[i] === x)
              return i;
          }
          return -1;
        };
      }, {
        "./response": 48,
        "Base64": 49,
        "inherits": 50,
        "stream": 69
      }],
      48: [function(require, module, exports) {
        var Stream = require('stream');
        var util = require('util');
        var Response = module.exports = function(res) {
          this.offset = 0;
          this.readable = true;
        };
        util.inherits(Response, Stream);
        var capable = {
          streaming: true,
          status2: true
        };
        function parseHeaders(res) {
          var lines = res.getAllResponseHeaders().split(/\r?\n/);
          var headers = {};
          for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (line === '')
              continue;
            var m = line.match(/^([^:]+):\s*(.*)/);
            if (m) {
              var key = m[1].toLowerCase(),
                  value = m[2];
              if (headers[key] !== undefined) {
                if (isArray(headers[key])) {
                  headers[key].push(value);
                } else {
                  headers[key] = [headers[key], value];
                }
              } else {
                headers[key] = value;
              }
            } else {
              headers[line] = true;
            }
          }
          return headers;
        }
        Response.prototype.getResponse = function(xhr) {
          var respType = String(xhr.responseType).toLowerCase();
          if (respType === 'blob')
            return xhr.responseBlob || xhr.response;
          if (respType === 'arraybuffer')
            return xhr.response;
          return xhr.responseText;
        };
        Response.prototype.getHeader = function(key) {
          return this.headers[key.toLowerCase()];
        };
        Response.prototype.handle = function(res) {
          if (res.readyState === 2 && capable.status2) {
            try {
              this.statusCode = res.status;
              this.headers = parseHeaders(res);
            } catch (err) {
              capable.status2 = false;
            }
            if (capable.status2) {
              this.emit('ready');
            }
          } else if (capable.streaming && res.readyState === 3) {
            try {
              if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
              }
            } catch (err) {}
            try {
              this._emitData(res);
            } catch (err) {
              capable.streaming = false;
            }
          } else if (res.readyState === 4) {
            if (!this.statusCode) {
              this.statusCode = res.status;
              this.emit('ready');
            }
            this._emitData(res);
            if (res.error) {
              this.emit('error', this.getResponse(res));
            } else
              this.emit('end');
            this.emit('close');
          }
        };
        Response.prototype._emitData = function(res) {
          var respBody = this.getResponse(res);
          if (respBody.toString().match(/ArrayBuffer/)) {
            this.emit('data', new Uint8Array(respBody, this.offset));
            this.offset = respBody.byteLength;
            return;
          }
          if (respBody.length > this.offset) {
            this.emit('data', respBody.slice(this.offset));
            this.offset = respBody.length;
          }
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
      }, {
        "stream": 69,
        "util": 72
      }],
      49: [function(require, module, exports) {
        ;
        (function() {
          var object = typeof exports != 'undefined' ? exports : this;
          var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
          function InvalidCharacterError(message) {
            this.message = message;
          }
          InvalidCharacterError.prototype = new Error;
          InvalidCharacterError.prototype.name = 'InvalidCharacterError';
          object.btoa || (object.btoa = function(input) {
            for (var block,
                charCode,
                idx = 0,
                map = chars,
                output = ''; input.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
              charCode = input.charCodeAt(idx += 3 / 4);
              if (charCode > 0xFF) {
                throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
              }
              block = block << 8 | charCode;
            }
            return output;
          });
          object.atob || (object.atob = function(input) {
            input = input.replace(/=+$/, '');
            if (input.length % 4 == 1) {
              throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
            }
            for (var bc = 0,
                bs,
                buffer,
                idx = 0,
                output = ''; buffer = input.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
              buffer = chars.indexOf(buffer);
            }
            return output;
          });
        }());
      }, {}],
      50: [function(require, module, exports) {
        if (typeof Object.create === 'function') {
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }});
          };
        } else {
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      }, {}],
      51: [function(require, module, exports) {
        var process = module.exports = {};
        process.nextTick = (function() {
          var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;
          var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;
          ;
          if (canSetImmediate) {
            return function(f) {
              return window.setImmediate(f);
            };
          }
          if (canPost) {
            var queue = [];
            window.addEventListener('message', function(ev) {
              var source = ev.source;
              if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                  var fn = queue.shift();
                  fn();
                }
              }
            }, true);
            return function nextTick(fn) {
              queue.push(fn);
              window.postMessage('process-tick', '*');
            };
          }
          return function nextTick(fn) {
            setTimeout(fn, 0);
          };
        })();
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.binding = function(name) {
          throw new Error('process.binding is not supported');
        };
        process.cwd = function() {
          return '/';
        };
        process.chdir = function(dir) {
          throw new Error('process.chdir is not supported');
        };
      }, {}],
      52: [function(require, module, exports) {
        (function(global) {
          ;
          (function(root) {
            var freeExports = typeof exports == 'object' && exports;
            var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
            var freeGlobal = typeof global == 'object' && global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
              root = freeGlobal;
            }
            var punycode,
                maxInt = 2147483647,
                base = 36,
                tMin = 1,
                tMax = 26,
                skew = 38,
                damp = 700,
                initialBias = 72,
                initialN = 128,
                delimiter = '-',
                regexPunycode = /^xn--/,
                regexNonASCII = /[^ -~]/,
                regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g,
                errors = {
                  'overflow': 'Overflow: input needs wider integers to process',
                  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                  'invalid-input': 'Invalid input'
                },
                baseMinusTMin = base - tMin,
                floor = Math.floor,
                stringFromCharCode = String.fromCharCode,
                key;
            function error(type) {
              throw RangeError(errors[type]);
            }
            function map(array, fn) {
              var length = array.length;
              while (length--) {
                array[length] = fn(array[length]);
              }
              return array;
            }
            function mapDomain(string, fn) {
              return map(string.split(regexSeparators), fn).join('.');
            }
            function ucs2decode(string) {
              var output = [],
                  counter = 0,
                  length = string.length,
                  value,
                  extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                  extra = string.charCodeAt(counter++);
                  if ((extra & 0xFC00) == 0xDC00) {
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                  } else {
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }
            function ucs2encode(array) {
              return map(array, function(value) {
                var output = '';
                if (value > 0xFFFF) {
                  value -= 0x10000;
                  output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                  value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
              }).join('');
            }
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base;
            }
            function digitToBasic(digit, flag) {
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }
            function decode(input) {
              var output = [],
                  inputLength = input.length,
                  out,
                  i = 0,
                  n = initialN,
                  bias = initialBias,
                  basic,
                  j,
                  index,
                  oldi,
                  w,
                  k,
                  digit,
                  t,
                  baseMinusT;
              basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }
              for (j = 0; j < basic; ++j) {
                if (input.charCodeAt(j) >= 0x80) {
                  error('not-basic');
                }
                output.push(input.charCodeAt(j));
              }
              for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                for (oldi = i, w = 1, k = base; ; k += base) {
                  if (index >= inputLength) {
                    error('invalid-input');
                  }
                  digit = basicToDigit(input.charCodeAt(index++));
                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow');
                  }
                  i += digit * w;
                  t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                  if (digit < t) {
                    break;
                  }
                  baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow');
                  }
                  w *= baseMinusT;
                }
                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                if (floor(i / out) > maxInt - n) {
                  error('overflow');
                }
                n += floor(i / out);
                i %= out;
                output.splice(i++, 0, n);
              }
              return ucs2encode(output);
            }
            function encode(input) {
              var n,
                  delta,
                  handledCPCount,
                  basicLength,
                  bias,
                  j,
                  m,
                  q,
                  k,
                  t,
                  currentValue,
                  output = [],
                  inputLength,
                  handledCPCountPlusOne,
                  baseMinusT,
                  qMinusT;
              input = ucs2decode(input);
              inputLength = input.length;
              n = initialN;
              delta = 0;
              bias = initialBias;
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue));
                }
              }
              handledCPCount = basicLength = output.length;
              if (basicLength) {
                output.push(delimiter);
              }
              while (handledCPCount < inputLength) {
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow');
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                  }
                  if (currentValue == n) {
                    for (q = delta, k = base; ; k += base) {
                      t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                      q = floor(qMinusT / baseMinusT);
                    }
                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }
                ++delta;
                ++n;
              }
              return output.join('');
            }
            function toUnicode(domain) {
              return mapDomain(domain, function(string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
              });
            }
            function toASCII(domain) {
              return mapDomain(domain, function(string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
              });
            }
            punycode = {
              'version': '1.2.4',
              'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
              },
              'decode': decode,
              'encode': encode,
              'toASCII': toASCII,
              'toUnicode': toUnicode
            };
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
              define('punycode', function() {
                return punycode;
              });
            } else if (freeExports && !freeExports.nodeType) {
              if (freeModule) {
                freeModule.exports = punycode;
              } else {
                for (key in punycode) {
                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
              }
            } else {
              root.punycode = punycode;
            }
          }(this));
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}],
      53: [function(require, module, exports) {
        'use strict';
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function(qs, sep, eq, options) {
          sep = sep || '&';
          eq = eq || '=';
          var obj = {};
          if (typeof qs !== 'string' || qs.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs = qs.split(sep);
          var maxKeys = 1000;
          if (options && typeof options.maxKeys === 'number') {
            maxKeys = options.maxKeys;
          }
          var len = qs.length;
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, '%20'),
                idx = x.indexOf(eq),
                kstr,
                vstr,
                k,
                v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = '';
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }
          return obj;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
      }, {}],
      54: [function(require, module, exports) {
        'use strict';
        var stringifyPrimitive = function(v) {
          switch (typeof v) {
            case 'string':
              return v;
            case 'boolean':
              return v ? 'true' : 'false';
            case 'number':
              return isFinite(v) ? v : '';
            default:
              return '';
          }
        };
        module.exports = function(obj, sep, eq, name) {
          sep = sep || '&';
          eq = eq || '=';
          if (obj === null) {
            obj = undefined;
          }
          if (typeof obj === 'object') {
            return map(objectKeys(obj), function(k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function(v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }
          if (!name)
            return '';
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
        function map(xs, f) {
          if (xs.map)
            return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }
        var objectKeys = Object.keys || function(obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              res.push(key);
          }
          return res;
        };
      }, {}],
      55: [function(require, module, exports) {
        'use strict';
        exports.decode = exports.parse = require('./decode');
        exports.encode = exports.stringify = require('./encode');
      }, {
        "./decode": 53,
        "./encode": 54
      }],
      56: [function(require, module, exports) {
        module.exports = require("./lib/_stream_duplex.js");
      }, {"./lib/_stream_duplex.js": 57}],
      57: [function(require, module, exports) {
        (function(process) {
          module.exports = Duplex;
          var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj)
              keys.push(key);
            return keys;
          };
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var Readable = require('./_stream_readable');
          var Writable = require('./_stream_writable');
          util.inherits(Duplex, Readable);
          forEach(objectKeys(Writable.prototype), function(method) {
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          });
          function Duplex(options) {
            if (!(this instanceof Duplex))
              return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            if (options && options.readable === false)
              this.readable = false;
            if (options && options.writable === false)
              this.writable = false;
            this.allowHalfOpen = true;
            if (options && options.allowHalfOpen === false)
              this.allowHalfOpen = false;
            this.once('end', onend);
          }
          function onend() {
            if (this.allowHalfOpen || this._writableState.ended)
              return;
            process.nextTick(this.end.bind(this));
          }
          function forEach(xs, f) {
            for (var i = 0,
                l = xs.length; i < l; i++) {
              f(xs[i], i);
            }
          }
        }).call(this, require("sycGbZ"));
      }, {
        "./_stream_readable": 59,
        "./_stream_writable": 61,
        "core-util-is": 62,
        "inherits": 50,
        "sycGbZ": 51
      }],
      58: [function(require, module, exports) {
        module.exports = PassThrough;
        var Transform = require('./_stream_transform');
        var util = require('core-util-is');
        util.inherits = require('inherits');
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, {
        "./_stream_transform": 60,
        "core-util-is": 62,
        "inherits": 50
      }],
      59: [function(require, module, exports) {
        (function(process) {
          module.exports = Readable;
          var isArray = require('isarray');
          var Buffer = require('buffer').Buffer;
          Readable.ReadableState = ReadableState;
          var EE = require('events').EventEmitter;
          if (!EE.listenerCount)
            EE.listenerCount = function(emitter, type) {
              return emitter.listeners(type).length;
            };
          var Stream = require('stream');
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var StringDecoder;
          util.inherits(Readable, Stream);
          function ReadableState(options, stream) {
            options = options || {};
            var hwm = options.highWaterMark;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
            this.highWaterMark = ~~this.highWaterMark;
            this.buffer = [];
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = false;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.calledRead = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.objectMode = !!options.objectMode;
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            this.ranOut = false;
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            if (!(this instanceof Readable))
              return new Readable(options);
            this._readableState = new ReadableState(options, this);
            this.readable = true;
            Stream.call(this);
          }
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            if (typeof chunk === 'string' && !state.objectMode) {
              encoding = encoding || state.defaultEncoding;
              if (encoding !== state.encoding) {
                chunk = new Buffer(chunk, encoding);
                encoding = '';
              }
            }
            return readableAddChunk(this, state, chunk, encoding, false);
          };
          Readable.prototype.unshift = function(chunk) {
            var state = this._readableState;
            return readableAddChunk(this, state, chunk, '', true);
          };
          function readableAddChunk(stream, state, chunk, encoding, addToFront) {
            var er = chunkInvalid(state, chunk);
            if (er) {
              stream.emit('error', er);
            } else if (chunk === null || chunk === undefined) {
              state.reading = false;
              if (!state.ended)
                onEofChunk(stream, state);
            } else if (state.objectMode || chunk && chunk.length > 0) {
              if (state.ended && !addToFront) {
                var e = new Error('stream.push() after EOF');
                stream.emit('error', e);
              } else if (state.endEmitted && addToFront) {
                var e = new Error('stream.unshift() after end event');
                stream.emit('error', e);
              } else {
                if (state.decoder && !addToFront && !encoding)
                  chunk = state.decoder.write(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) {
                  state.buffer.unshift(chunk);
                } else {
                  state.reading = false;
                  state.buffer.push(chunk);
                }
                if (state.needReadable)
                  emitReadable(stream);
                maybeReadMore(stream, state);
              }
            } else if (!addToFront) {
              state.reading = false;
            }
            return needMoreData(state);
          }
          function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
          }
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require('string_decoder/').StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
          };
          var MAX_HWM = 0x800000;
          function roundUpToNextPowerOf2(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              n--;
              for (var p = 1; p < 32; p <<= 1)
                n |= n >> p;
              n++;
            }
            return n;
          }
          function howMuchToRead(n, state) {
            if (state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return n === 0 ? 0 : 1;
            if (isNaN(n) || n === null) {
              if (state.flowing && state.buffer.length)
                return state.buffer[0].length;
              else
                return state.length;
            }
            if (n <= 0)
              return 0;
            if (n > state.highWaterMark)
              state.highWaterMark = roundUpToNextPowerOf2(n);
            if (n > state.length) {
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              } else
                return state.length;
            }
            return n;
          }
          Readable.prototype.read = function(n) {
            var state = this._readableState;
            state.calledRead = true;
            var nOrig = n;
            if (typeof n !== 'number' || n > 0)
              state.emittedReadable = false;
            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
              emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            var doRead = state.needReadable;
            if (state.length - n <= state.highWaterMark)
              doRead = true;
            if (state.ended || state.reading)
              doRead = false;
            if (doRead) {
              state.reading = true;
              state.sync = true;
              if (state.length === 0)
                state.needReadable = true;
              this._read(state.highWaterMark);
              state.sync = false;
            }
            if (doRead && !state.reading)
              n = howMuchToRead(nOrig, state);
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = true;
              n = 0;
            }
            state.length -= n;
            if (state.length === 0 && !state.ended)
              state.needReadable = true;
            if (state.ended && !state.endEmitted && state.length === 0)
              endReadable(this);
            return ret;
          };
          function chunkInvalid(state, chunk) {
            var er = null;
            if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode && !er) {
              er = new TypeError('Invalid non-string/buffer chunk');
            }
            return er;
          }
          function onEofChunk(stream, state) {
            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            if (state.length > 0)
              emitReadable(stream);
            else
              endReadable(stream);
          }
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (state.emittedReadable)
              return;
            state.emittedReadable = true;
            if (state.sync)
              process.nextTick(function() {
                emitReadable_(stream);
              });
            else
              emitReadable_(stream);
          }
          function emitReadable_(stream) {
            stream.emit('readable');
          }
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              process.nextTick(function() {
                maybeReadMore_(stream, state);
              });
            }
          }
          function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
              stream.read(0);
              if (len === state.length)
                break;
              else
                len = state.length;
            }
            state.readingMore = false;
          }
          Readable.prototype._read = function(n) {
            this.emit('error', new Error('not implemented'));
          };
          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : cleanup;
            if (state.endEmitted)
              process.nextTick(endFn);
            else
              src.once('end', endFn);
            dest.on('unpipe', onunpipe);
            function onunpipe(readable) {
              if (readable !== src)
                return;
              cleanup();
            }
            function onend() {
              dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);
            function cleanup() {
              dest.removeListener('close', onclose);
              dest.removeListener('finish', onfinish);
              dest.removeListener('drain', ondrain);
              dest.removeListener('error', onerror);
              dest.removeListener('unpipe', onunpipe);
              src.removeListener('end', onend);
              src.removeListener('end', cleanup);
              if (!dest._writableState || dest._writableState.needDrain)
                ondrain();
            }
            function onerror(er) {
              unpipe();
              dest.removeListener('error', onerror);
              if (EE.listenerCount(dest, 'error') === 0)
                dest.emit('error', er);
            }
            if (!dest._events || !dest._events.error)
              dest.on('error', onerror);
            else if (isArray(dest._events.error))
              dest._events.error.unshift(onerror);
            else
              dest._events.error = [onerror, dest._events.error];
            function onclose() {
              dest.removeListener('finish', onfinish);
              unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
              dest.removeListener('close', onclose);
              unpipe();
            }
            dest.once('finish', onfinish);
            function unpipe() {
              src.unpipe(dest);
            }
            dest.emit('pipe', src);
            if (!state.flowing) {
              this.on('readable', pipeOnReadable);
              state.flowing = true;
              process.nextTick(function() {
                flow(src);
              });
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function() {
              var dest = this;
              var state = src._readableState;
              state.awaitDrain--;
              if (state.awaitDrain === 0)
                flow(src);
            };
          }
          function flow(src) {
            var state = src._readableState;
            var chunk;
            state.awaitDrain = 0;
            function write(dest, i, list) {
              var written = dest.write(chunk);
              if (false === written) {
                state.awaitDrain++;
              }
            }
            while (state.pipesCount && null !== (chunk = src.read())) {
              if (state.pipesCount === 1)
                write(state.pipes, 0, null);
              else
                forEach(state.pipes, write);
              src.emit('data', chunk);
              if (state.awaitDrain > 0)
                return;
            }
            if (state.pipesCount === 0) {
              state.flowing = false;
              if (EE.listenerCount(src, 'data') > 0)
                emitDataEvents(src);
              return;
            }
            state.ranOut = true;
          }
          function pipeOnReadable() {
            if (this._readableState.ranOut) {
              this._readableState.ranOut = false;
              flow(this);
            }
          }
          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            if (state.pipesCount === 0)
              return this;
            if (state.pipesCount === 1) {
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              state.pipes = null;
              state.pipesCount = 0;
              this.removeListener('readable', pipeOnReadable);
              state.flowing = false;
              if (dest)
                dest.emit('unpipe', this);
              return this;
            }
            if (!dest) {
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              this.removeListener('readable', pipeOnReadable);
              state.flowing = false;
              for (var i = 0; i < len; i++)
                dests[i].emit('unpipe', this);
              return this;
            }
            var i = indexOf(state.pipes, dest);
            if (i === -1)
              return this;
            state.pipes.splice(i, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit('unpipe', this);
            return this;
          };
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if (ev === 'data' && !this._readableState.flowing)
              emitDataEvents(this);
            if (ev === 'readable' && this.readable) {
              var state = this._readableState;
              if (!state.readableListening) {
                state.readableListening = true;
                state.emittedReadable = false;
                state.needReadable = true;
                if (!state.reading) {
                  this.read(0);
                } else if (state.length) {
                  emitReadable(this, state);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          Readable.prototype.resume = function() {
            emitDataEvents(this);
            this.read(0);
            this.emit('resume');
          };
          Readable.prototype.pause = function() {
            emitDataEvents(this, true);
            this.emit('pause');
          };
          function emitDataEvents(stream, startPaused) {
            var state = stream._readableState;
            if (state.flowing) {
              throw new Error('Cannot switch to old mode now.');
            }
            var paused = startPaused || false;
            var readable = false;
            stream.readable = true;
            stream.pipe = Stream.prototype.pipe;
            stream.on = stream.addListener = Stream.prototype.on;
            stream.on('readable', function() {
              readable = true;
              var c;
              while (!paused && (null !== (c = stream.read())))
                stream.emit('data', c);
              if (c === null) {
                readable = false;
                stream._readableState.needReadable = true;
              }
            });
            stream.pause = function() {
              paused = true;
              this.emit('pause');
            };
            stream.resume = function() {
              paused = false;
              if (readable)
                process.nextTick(function() {
                  stream.emit('readable');
                });
              else
                this.read(0);
              this.emit('resume');
            };
            stream.emit('readable');
          }
          Readable.prototype.wrap = function(stream) {
            var state = this._readableState;
            var paused = false;
            var self = this;
            stream.on('end', function() {
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  self.push(chunk);
              }
              self.push(null);
            });
            stream.on('data', function(chunk) {
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              if (!chunk || !state.objectMode && !chunk.length)
                return;
              var ret = self.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            for (var i in stream) {
              if (typeof stream[i] === 'function' && typeof this[i] === 'undefined') {
                this[i] = function(method) {
                  return function() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            var events = ['error', 'close', 'destroy', 'pause', 'resume'];
            forEach(events, function(ev) {
              stream.on(ev, self.emit.bind(self, ev));
            });
            self._read = function(n) {
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return self;
          };
          Readable._fromList = fromList;
          function fromList(n, state) {
            var list = state.buffer;
            var length = state.length;
            var stringMode = !!state.decoder;
            var objectMode = !!state.objectMode;
            var ret;
            if (list.length === 0)
              return null;
            if (length === 0)
              ret = null;
            else if (objectMode)
              ret = list.shift();
            else if (!n || n >= length) {
              if (stringMode)
                ret = list.join('');
              else
                ret = Buffer.concat(list, length);
              list.length = 0;
            } else {
              if (n < list[0].length) {
                var buf = list[0];
                ret = buf.slice(0, n);
                list[0] = buf.slice(n);
              } else if (n === list[0].length) {
                ret = list.shift();
              } else {
                if (stringMode)
                  ret = '';
                else
                  ret = new Buffer(n);
                var c = 0;
                for (var i = 0,
                    l = list.length; i < l && c < n; i++) {
                  var buf = list[0];
                  var cpy = Math.min(n - c, buf.length);
                  if (stringMode)
                    ret += buf.slice(0, cpy);
                  else
                    buf.copy(ret, c, 0, cpy);
                  if (cpy < buf.length)
                    list[0] = buf.slice(cpy);
                  else
                    list.shift();
                  c += cpy;
                }
              }
            }
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            if (state.length > 0)
              throw new Error('endReadable called on non-empty stream');
            if (!state.endEmitted && state.calledRead) {
              state.ended = true;
              process.nextTick(function() {
                if (!state.endEmitted && state.length === 0) {
                  state.endEmitted = true;
                  stream.readable = false;
                  stream.emit('end');
                }
              });
            }
          }
          function forEach(xs, f) {
            for (var i = 0,
                l = xs.length; i < l; i++) {
              f(xs[i], i);
            }
          }
          function indexOf(xs, x) {
            for (var i = 0,
                l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }).call(this, require("sycGbZ"));
      }, {
        "buffer": 29,
        "core-util-is": 62,
        "events": 45,
        "inherits": 50,
        "isarray": 63,
        "stream": 69,
        "string_decoder/": 64,
        "sycGbZ": 51
      }],
      60: [function(require, module, exports) {
        module.exports = Transform;
        var Duplex = require('./_stream_duplex');
        var util = require('core-util-is');
        util.inherits = require('inherits');
        util.inherits(Transform, Duplex);
        function TransformState(options, stream) {
          this.afterTransform = function(er, data) {
            return afterTransform(stream, er, data);
          };
          this.needTransform = false;
          this.transforming = false;
          this.writecb = null;
          this.writechunk = null;
        }
        function afterTransform(stream, er, data) {
          var ts = stream._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb)
            return stream.emit('error', new Error('no writecb in Transform class'));
          ts.writechunk = null;
          ts.writecb = null;
          if (data !== null && data !== undefined)
            stream.push(data);
          if (cb)
            cb(er);
          var rs = stream._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            stream._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          var ts = this._transformState = new TransformState(options, this);
          var stream = this;
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          this.once('finish', function() {
            if ('function' === typeof this._flush)
              this._flush(function(er) {
                done(stream, er);
              });
            else
              done(stream);
          });
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error('not implemented');
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        function done(stream, er) {
          if (er)
            return stream.emit('error', er);
          var ws = stream._writableState;
          var rs = stream._readableState;
          var ts = stream._transformState;
          if (ws.length)
            throw new Error('calling transform done when ws.length != 0');
          if (ts.transforming)
            throw new Error('calling transform done when still transforming');
          return stream.push(null);
        }
      }, {
        "./_stream_duplex": 57,
        "core-util-is": 62,
        "inherits": 50
      }],
      61: [function(require, module, exports) {
        (function(process) {
          module.exports = Writable;
          var Buffer = require('buffer').Buffer;
          Writable.WritableState = WritableState;
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var Stream = require('stream');
          util.inherits(Writable, Stream);
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
          }
          function WritableState(options, stream) {
            options = options || {};
            var hwm = options.highWaterMark;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
            this.objectMode = !!options.objectMode;
            this.highWaterMark = ~~this.highWaterMark;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            this.length = 0;
            this.writing = false;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.buffer = [];
            this.errorEmitted = false;
          }
          function Writable(options) {
            var Duplex = require('./_stream_duplex');
            if (!(this instanceof Writable) && !(this instanceof Duplex))
              return new Writable(options);
            this._writableState = new WritableState(options, this);
            this.writable = true;
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            this.emit('error', new Error('Cannot pipe. Not readable.'));
          };
          function writeAfterEnd(stream, state, cb) {
            var er = new Error('write after end');
            stream.emit('error', er);
            process.nextTick(function() {
              cb(er);
            });
          }
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {
              var er = new TypeError('Invalid non-string/buffer chunk');
              stream.emit('error', er);
              process.nextTick(function() {
                cb(er);
              });
              valid = false;
            }
            return valid;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (Buffer.isBuffer(chunk))
              encoding = 'buffer';
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== 'function')
              cb = function() {};
            if (state.ended)
              writeAfterEnd(this, state, cb);
            else if (validChunk(this, state, chunk, cb))
              ret = writeOrBuffer(this, state, chunk, encoding, cb);
            return ret;
          };
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = new Buffer(chunk, encoding);
            }
            return chunk;
          }
          function writeOrBuffer(stream, state, chunk, encoding, cb) {
            chunk = decodeChunk(state, chunk, encoding);
            if (Buffer.isBuffer(chunk))
              encoding = 'buffer';
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing)
              state.buffer.push(new WriteReq(chunk, encoding, cb));
            else
              doWrite(stream, state, len, chunk, encoding, cb);
            return ret;
          }
          function doWrite(stream, state, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            if (sync)
              process.nextTick(function() {
                cb(er);
              });
            else
              cb(er);
            stream._writableState.errorEmitted = true;
            stream.emit('error', er);
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(stream, state);
              if (!finished && !state.bufferProcessing && state.buffer.length)
                clearBuffer(stream, state);
              if (sync) {
                process.nextTick(function() {
                  afterWrite(stream, state, finished, cb);
                });
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            cb();
            if (finished)
              finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit('drain');
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            for (var c = 0; c < state.buffer.length; c++) {
              var entry = state.buffer[c];
              var chunk = entry.chunk;
              var encoding = entry.encoding;
              var cb = entry.callback;
              var len = state.objectMode ? 1 : chunk.length;
              doWrite(stream, state, len, chunk, encoding, cb);
              if (state.writing) {
                c++;
                break;
              }
            }
            state.bufferProcessing = false;
            if (c < state.buffer.length)
              state.buffer = state.buffer.slice(c);
            else
              state.buffer.length = 0;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error('not implemented'));
          };
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === 'function') {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (typeof chunk !== 'undefined' && chunk !== null)
              this.write(chunk, encoding);
            if (!state.ending && !state.finished)
              endWritable(this, state, cb);
          };
          function needFinish(stream, state) {
            return (state.ending && state.length === 0 && !state.finished && !state.writing);
          }
          function finishMaybe(stream, state) {
            var need = needFinish(stream, state);
            if (need) {
              state.finished = true;
              stream.emit('finish');
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                process.nextTick(cb);
              else
                stream.once('finish', cb);
            }
            state.ended = true;
          }
        }).call(this, require("sycGbZ"));
      }, {
        "./_stream_duplex": 57,
        "buffer": 29,
        "core-util-is": 62,
        "inherits": 50,
        "stream": 69,
        "sycGbZ": 51
      }],
      62: [function(require, module, exports) {
        (function(Buffer) {
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;
          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }
          exports.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          exports.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
          }
          exports.isError = isError;
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;
          function isBuffer(arg) {
            return Buffer.isBuffer(arg);
          }
          exports.isBuffer = isBuffer;
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
        }).call(this, require("buffer").Buffer);
      }, {"buffer": 29}],
      63: [function(require, module, exports) {
        module.exports = Array.isArray || function(arr) {
          return Object.prototype.toString.call(arr) == '[object Array]';
        };
      }, {}],
      64: [function(require, module, exports) {
        var Buffer = require('buffer').Buffer;
        var isBufferEncoding = Buffer.isEncoding || function(encoding) {
          switch (encoding && encoding.toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
            case 'raw':
              return true;
            default:
              return false;
          }
        };
        function assertEncoding(encoding) {
          if (encoding && !isBufferEncoding(encoding)) {
            throw new Error('Unknown encoding: ' + encoding);
          }
        }
        var StringDecoder = exports.StringDecoder = function(encoding) {
          this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
          assertEncoding(encoding);
          switch (this.encoding) {
            case 'utf8':
              this.surrogateSize = 3;
              break;
            case 'ucs2':
            case 'utf16le':
              this.surrogateSize = 2;
              this.detectIncompleteChar = utf16DetectIncompleteChar;
              break;
            case 'base64':
              this.surrogateSize = 3;
              this.detectIncompleteChar = base64DetectIncompleteChar;
              break;
            default:
              this.write = passThroughWrite;
              return;
          }
          this.charBuffer = new Buffer(6);
          this.charReceived = 0;
          this.charLength = 0;
        };
        StringDecoder.prototype.write = function(buffer) {
          var charStr = '';
          var offset = 0;
          while (this.charLength) {
            var i = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length;
            buffer.copy(this.charBuffer, this.charReceived, offset, i);
            this.charReceived += (i - offset);
            offset = i;
            if (this.charReceived < this.charLength) {
              return '';
            }
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 0xD800 && charCode <= 0xDBFF) {
              this.charLength += this.surrogateSize;
              charStr = '';
              continue;
            }
            this.charReceived = this.charLength = 0;
            if (i == buffer.length)
              return charStr;
            buffer = buffer.slice(i, buffer.length);
            break;
          }
          var lenIncomplete = this.detectIncompleteChar(buffer);
          var end = buffer.length;
          if (this.charLength) {
            buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
            this.charReceived = lenIncomplete;
            end -= lenIncomplete;
          }
          charStr += buffer.toString(this.encoding, 0, end);
          var end = charStr.length - 1;
          var charCode = charStr.charCodeAt(end);
          if (charCode >= 0xD800 && charCode <= 0xDBFF) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
            return charStr.substring(0, end);
          }
          return charStr;
        };
        StringDecoder.prototype.detectIncompleteChar = function(buffer) {
          var i = (buffer.length >= 3) ? 3 : buffer.length;
          for (; i > 0; i--) {
            var c = buffer[buffer.length - i];
            if (i == 1 && c >> 5 == 0x06) {
              this.charLength = 2;
              break;
            }
            if (i <= 2 && c >> 4 == 0x0E) {
              this.charLength = 3;
              break;
            }
            if (i <= 3 && c >> 3 == 0x1E) {
              this.charLength = 4;
              break;
            }
          }
          return i;
        };
        StringDecoder.prototype.end = function(buffer) {
          var res = '';
          if (buffer && buffer.length)
            res = this.write(buffer);
          if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
          }
          return res;
        };
        function passThroughWrite(buffer) {
          return buffer.toString(this.encoding);
        }
        function utf16DetectIncompleteChar(buffer) {
          var incomplete = this.charReceived = buffer.length % 2;
          this.charLength = incomplete ? 2 : 0;
          return incomplete;
        }
        function base64DetectIncompleteChar(buffer) {
          var incomplete = this.charReceived = buffer.length % 3;
          this.charLength = incomplete ? 3 : 0;
          return incomplete;
        }
      }, {"buffer": 29}],
      65: [function(require, module, exports) {
        module.exports = require("./lib/_stream_passthrough.js");
      }, {"./lib/_stream_passthrough.js": 58}],
      66: [function(require, module, exports) {
        exports = module.exports = require('./lib/_stream_readable.js');
        exports.Readable = exports;
        exports.Writable = require('./lib/_stream_writable.js');
        exports.Duplex = require('./lib/_stream_duplex.js');
        exports.Transform = require('./lib/_stream_transform.js');
        exports.PassThrough = require('./lib/_stream_passthrough.js');
      }, {
        "./lib/_stream_duplex.js": 57,
        "./lib/_stream_passthrough.js": 58,
        "./lib/_stream_readable.js": 59,
        "./lib/_stream_transform.js": 60,
        "./lib/_stream_writable.js": 61
      }],
      67: [function(require, module, exports) {
        module.exports = require("./lib/_stream_transform.js");
      }, {"./lib/_stream_transform.js": 60}],
      68: [function(require, module, exports) {
        module.exports = require("./lib/_stream_writable.js");
      }, {"./lib/_stream_writable.js": 61}],
      69: [function(require, module, exports) {
        module.exports = Stream;
        var EE = require('events').EventEmitter;
        var inherits = require('inherits');
        inherits(Stream, EE);
        Stream.Readable = require('readable-stream/readable.js');
        Stream.Writable = require('readable-stream/writable.js');
        Stream.Duplex = require('readable-stream/duplex.js');
        Stream.Transform = require('readable-stream/transform.js');
        Stream.PassThrough = require('readable-stream/passthrough.js');
        Stream.Stream = Stream;
        function Stream() {
          EE.call(this);
        }
        Stream.prototype.pipe = function(dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on('data', ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on('drain', ondrain);
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on('end', onend);
            source.on('close', onclose);
          }
          var didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === 'function')
              dest.destroy();
          }
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, 'error') === 0) {
              throw er;
            }
          }
          source.on('error', onerror);
          dest.on('error', onerror);
          function cleanup() {
            source.removeListener('data', ondata);
            dest.removeListener('drain', ondrain);
            source.removeListener('end', onend);
            source.removeListener('close', onclose);
            source.removeListener('error', onerror);
            dest.removeListener('error', onerror);
            source.removeListener('end', cleanup);
            source.removeListener('close', cleanup);
            dest.removeListener('close', cleanup);
          }
          source.on('end', cleanup);
          source.on('close', cleanup);
          dest.on('close', cleanup);
          dest.emit('pipe', source);
          return dest;
        };
      }, {
        "events": 45,
        "inherits": 50,
        "readable-stream/duplex.js": 56,
        "readable-stream/passthrough.js": 65,
        "readable-stream/readable.js": 66,
        "readable-stream/transform.js": 67,
        "readable-stream/writable.js": 68
      }],
      70: [function(require, module, exports) {
        var punycode = require('punycode');
        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;
        exports.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/,
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
            unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
            autoEscape = ['\''].concat(unwise),
            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
            hostEndingChars = ['/', '?', '#'],
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
            unsafeProtocol = {
              'javascript': true,
              'javascript:': true
            },
            hostlessProtocol = {
              'javascript': true,
              'javascript:': true
            },
            slashedProtocol = {
              'http': true,
              'https': true,
              'ftp': true,
              'gopher': true,
              'file': true,
              'http:': true,
              'https:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true
            },
            querystring = require('querystring');
        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && isObject(url) && url instanceof Url)
            return url;
          var u = new Url;
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
          if (!isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
          }
          var rest = url;
          rest = rest.trim();
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            var auth,
                atSign;
            if (hostEnd === -1) {
              atSign = rest.lastIndexOf('@');
            } else {
              atSign = rest.lastIndexOf('@', hostEnd);
            }
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            if (hostEnd === -1)
              hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            this.parseHost();
            this.hostname = this.hostname || '';
            var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0,
                  l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part)
                  continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = '';
                  for (var j = 0,
                      k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      newpart += 'x';
                    } else {
                      newpart += part[j];
                    }
                  }
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = '/' + notHost.join('.') + rest;
                    }
                    this.hostname = validParts.join('.');
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = '';
            } else {
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              var domainArray = this.hostname.split('.');
              var newOut = [];
              for (var i = 0; i < domainArray.length; ++i) {
                var s = domainArray[i];
                newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
              }
              this.hostname = newOut.join('.');
            }
            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== '/') {
                rest = '/' + rest;
              }
            }
          }
          if (!unsafeProtocol[lowerProto]) {
            for (var i = 0,
                l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }
          var hash = rest.indexOf('#');
          if (hash !== -1) {
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf('?');
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            this.search = '';
            this.query = {};
          }
          if (rest)
            this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = '/';
          }
          if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
          }
          this.href = this.format();
          return this;
        };
        function urlFormat(obj) {
          if (isString(obj))
            obj = urlParse(obj);
          if (!(obj instanceof Url))
            return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function() {
          var auth = this.auth || '';
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
          }
          var protocol = this.protocol || '',
              pathname = this.pathname || '',
              hash = this.hash || '',
              host = false,
              query = '';
          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
            if (this.port) {
              host += ':' + this.port;
            }
          }
          if (this.query && isObject(this.query) && Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }
          var search = this.search || (query && ('?' + query)) || '';
          if (protocol && protocol.substr(-1) !== ':')
            protocol += ':';
          if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/')
              pathname = '/' + pathname;
          } else if (!host) {
            host = '';
          }
          if (hash && hash.charAt(0) !== '#')
            hash = '#' + hash;
          if (search && search.charAt(0) !== '?')
            search = '?' + search;
          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match);
          });
          search = search.replace('#', '%23');
          return protocol + host + pathname + search + hash;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source)
            return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
          if (isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          Object.keys(this).forEach(function(k) {
            result[k] = this[k];
          }, this);
          result.hash = relative.hash;
          if (relative.href === '') {
            result.href = result.format();
            return result;
          }
          if (relative.slashes && !relative.protocol) {
            Object.keys(relative).forEach(function(k) {
              if (k !== 'protocol')
                result[k] = relative[k];
            });
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = '/';
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol[relative.protocol]) {
              Object.keys(relative).forEach(function(k) {
                result[k] = relative[k];
              });
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || '').split('/');
              while (relPath.length && !(relative.host = relPath.shift()))
                ;
              if (!relative.host)
                relative.host = '';
              if (!relative.hostname)
                relative.hostname = '';
              if (relPath[0] !== '')
                relPath.unshift('');
              if (relPath.length < 2)
                relPath.unshift('');
              result.pathname = relPath.join('/');
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
              var p = result.pathname || '';
              var s = result.search || '';
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
              isRelAbs = (relative.host || relative.pathname && relative.pathname.charAt(0) === '/'),
              mustEndAbs = (isRelAbs || isSourceAbs || (result.host && relative.pathname)),
              removeAllDots = mustEndAbs,
              srcPath = result.pathname && result.pathname.split('/') || [],
              relPath = relative.pathname && relative.pathname.split('/') || [],
              psychotic = result.protocol && !slashedProtocol[result.protocol];
          if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
              if (srcPath[0] === '')
                srcPath[0] = result.host;
              else
                srcPath.unshift(result.host);
            }
            result.host = '';
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === '')
                  relPath[0] = relative.host;
                else
                  relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
          }
          if (isRelAbs) {
            result.host = (relative.host || relative.host === '') ? relative.host : result.host;
            result.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
          } else if (relPath.length) {
            if (!srcPath)
              srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!isNullOrUndefined(relative.search)) {
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (!isNull(result.pathname) || !isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
              result.path = '/' + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = ((result.host || relative.host) && (last === '.' || last === '..') || last === '');
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last == '.') {
              srcPath.splice(i, 1);
            } else if (last === '..') {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift('..');
            }
          }
          if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
          }
          if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
            srcPath.push('');
          }
          var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || (result.host && srcPath.length);
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join('/');
          }
          if (!isNull(result.pathname) || !isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function() {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ':') {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host)
            this.hostname = host;
        };
        function isString(arg) {
          return typeof arg === "string";
        }
        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        function isNull(arg) {
          return arg === null;
        }
        function isNullOrUndefined(arg) {
          return arg == null;
        }
      }, {
        "punycode": 52,
        "querystring": 55
      }],
      71: [function(require, module, exports) {
        module.exports = function isBuffer(arg) {
          return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
        };
      }, {}],
      72: [function(require, module, exports) {
        (function(process, global) {
          var formatRegExp = /%[sdj%]/g;
          exports.format = function(f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(' ');
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
              if (x === '%%')
                return '%';
              if (i >= len)
                return x;
              switch (x) {
                case '%s':
                  return String(args[i++]);
                case '%d':
                  return Number(args[i++]);
                case '%j':
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return '[Circular]';
                  }
                default:
                  return x;
              }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }
            return str;
          };
          exports.deprecate = function(fn, msg) {
            if (isUndefined(global.process)) {
              return function() {
                return exports.deprecate(fn, msg).apply(this, arguments);
              };
            }
            if (process.noDeprecation === true) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          };
          var debugs = {};
          var debugEnviron;
          exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
              debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                var pid = process.pid;
                debugs[set] = function() {
                  var msg = exports.format.apply(exports, arguments);
                  console.error('%s %d: %s', set, pid, msg);
                };
              } else {
                debugs[set] = function() {};
              }
            }
            return debugs[set];
          };
          function inspect(obj, opts) {
            var ctx = {
              seen: [],
              stylize: stylizeNoColor
            };
            if (arguments.length >= 3)
              ctx.depth = arguments[2];
            if (arguments.length >= 4)
              ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              ctx.showHidden = opts;
            } else if (opts) {
              exports._extend(ctx, opts);
            }
            if (isUndefined(ctx.showHidden))
              ctx.showHidden = false;
            if (isUndefined(ctx.depth))
              ctx.depth = 2;
            if (isUndefined(ctx.colors))
              ctx.colors = false;
            if (isUndefined(ctx.customInspect))
              ctx.customInspect = true;
            if (ctx.colors)
              ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports.inspect = inspect;
          inspect.colors = {
            'bold': [1, 22],
            'italic': [3, 23],
            'underline': [4, 24],
            'inverse': [7, 27],
            'white': [37, 39],
            'grey': [90, 39],
            'black': [30, 39],
            'blue': [34, 39],
            'cyan': [36, 39],
            'green': [32, 39],
            'magenta': [35, 39],
            'red': [31, 39],
            'yellow': [33, 39]
          };
          inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            'regexp': 'red'
          };
          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) {
              return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
              return str;
            }
          }
          function stylizeNoColor(str, styleType) {
            return str;
          }
          function arrayToHash(array) {
            var hash = {};
            array.forEach(function(val, idx) {
              hash[val] = true;
            });
            return hash;
          }
          function formatValue(ctx, value, recurseTimes) {
            if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }
            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
              return formatError(value);
            }
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }
              if (isError(value)) {
                return formatError(value);
              }
            }
            var base = '',
                array = false,
                braces = ['{', '}'];
            if (isArray(value)) {
              array = true;
              braces = ['[', ']'];
            }
            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            }
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            }
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            }
            if (isError(value)) {
              base = ' ' + formatError(value);
            }
            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }
          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
              return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
              return ctx.stylize('' + value, 'boolean');
            if (isNull(value))
              return ctx.stylize('null', 'null');
          }
          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0,
                l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push('');
              }
            }
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name,
                str,
                desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function(line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function(line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify('' + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, 'string');
              }
            }
            return name + ': ' + str;
          }
          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
              numLinesEst++;
              if (cur.indexOf('\n') >= 0)
                numLinesEst++;
              return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);
            if (length > 60) {
              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
            }
            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          }
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;
          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }
          exports.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          exports.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
          }
          exports.isError = isError;
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;
          exports.isBuffer = require('./support/isBuffer');
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }
          var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
          }
          exports.log = function() {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
          };
          exports.inherits = require('inherits');
          exports._extend = function(origin, add) {
            if (!add || !isObject(add))
              return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
        }).call(this, require("sycGbZ"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {
        "./support/isBuffer": 71,
        "inherits": 50,
        "sycGbZ": 51
      }]
    }, {}, [1]);
  })();
  return _retrieveGlobal();
});

System.register('libraries/telehash/telehash.js', ['github:angular/bower-angular@1.4.7', 'libraries/telehash/telehash-library.js'], function (_export) {
  'use strict';

  // custom browserify build of telehash v2 that includes all dependencies
  // needed because some deps pointed to repositories that are no longer available
  //TODO: keep up with telehash v3 development and blockname
  var angular, th;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_librariesTelehashTelehashLibraryJs) {
      th = _librariesTelehashTelehashLibraryJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries.telehash', []).factory('telehash', /*@ngInject*/function () {
        return telehash;
      }));
    }
  };
});

System.register('libraries/libraries.js', ['github:angular/bower-angular@1.4.7', 'libraries/baobab/baobab.js', 'libraries/forge/forge.js', 'libraries/ionic/ionic.js', 'libraries/moment/moment.js', 'libraries/qr-image/qr-image.js', 'libraries/ramda/ramda.js', 'libraries/remote-storage/remote-storage.js', 'libraries/telehash/telehash.js'], function (_export) {
  'use strict';

  var angular, Baobab, forge, ionic, moment, qrImage, ramda, remoteStorage, telehash;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_librariesBaobabBaobabJs) {
      Baobab = _librariesBaobabBaobabJs['default'];
    }, function (_librariesForgeForgeJs) {
      forge = _librariesForgeForgeJs['default'];
    }, function (_librariesIonicIonicJs) {
      ionic = _librariesIonicIonicJs['default'];
    }, function (_librariesMomentMomentJs) {
      moment = _librariesMomentMomentJs['default'];
    }, function (_librariesQrImageQrImageJs) {
      qrImage = _librariesQrImageQrImageJs['default'];
    }, function (_librariesRamdaRamdaJs) {
      ramda = _librariesRamdaRamdaJs['default'];
    }, function (_librariesRemoteStorageRemoteStorageJs) {
      remoteStorage = _librariesRemoteStorageRemoteStorageJs['default'];
    }, function (_librariesTelehashTelehashJs) {
      telehash = _librariesTelehashTelehashJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.libraries', [Baobab.name, forge.name, ionic.name, moment.name, qrImage.name, ramda.name, remoteStorage.name, telehash.name]));
    }
  };
});

System.register('services/buffer/buffer-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', buffer);

  /*@ngInject*/
  function buffer($interval, $q, $log, channels, state, R) {
    var network = undefined;
    var status = undefined;

    var sendAttempts = {
      messages: undefined,
      invites: undefined,
      profiles: undefined
    };

    var sendMessage = function sendMessage(messageId, channelId) {
      var messageCursor = state.cloud.messages.select([channelId, messageId]);
      var messageInfo = messageCursor.get(['messageInfo']);
      var channelInfo = state.cloud.channels.get([channelId, 'channelInfo']);

      var contactId = channelInfo.contactIds[0];
      var contactStatusId = state.cloud.contacts.get([contactId, 'statusId']);
      if (contactStatusId === 0) {
        return;
      }

      var handleMessageAck = function handleMessageAck(ack) {
        var receivedTime = ack.r;

        return state.save(messageCursor, ['receivedTime'], receivedTime).then(function () {
          return removeMessage(messageInfo.id);
        });
      };

      $log.debug('Buffer: Sending message ' + messageInfo.content + ' to ' + channelId);
      return network.sendMessage(channelInfo, messageInfo).then(handleMessageAck);
    };

    var addMessage = function addMessage(messageId, channelId) {
      if (sendAttempts.messages[messageId]) {
        return $q.when();
      }

      sendMessage(messageId, channelId);
      sendAttempts.messages[messageId] = $interval(function () {
        return sendMessage(messageId, channelId);
      }, 20000, 0, false);
      return state.save(state.cloud.buffer, ['messages', messageId], { messageId: messageId, channelId: channelId });
    };

    var removeMessage = function removeMessage(messageId) {
      if (!sendAttempts.messages[messageId]) {
        return $q.when();
      }

      $interval.cancel(sendAttempts.messages[messageId]);
      sendAttempts.messages[messageId] = undefined;
      return state.remove(state.cloud.buffer, ['messages', messageId]);
    };

    var sendInvite = function sendInvite(channelId, userInfo) {
      var channelCursor = state.cloud.channels.select([channelId]);
      var existingChannel = channelCursor.get();
      var channelInfo = existingChannel.channelInfo;
      var contactId = channelInfo.contactIds[0];
      var contactCursor = state.cloud.contacts.select([contactId]);

      var handleInviteAck = function handleInviteAck(ack) {
        var initializeChannel = function initializeChannel() {
          if (existingChannel.inviteStatus === 'sending') {
            return state.save(channelCursor, ['inviteStatus'], 'sent');
          }

          if (existingChannel.inviteStatus === 'accepting') {
            return state.remove(channelCursor, ['inviteStatus']).then(function () {
              return state.save(contactCursor, ['statusId'], 1);
            }).then(function () {
              return channels.initializeChannel(channelInfo);
            }).then(function () {
              return network.listen(channelInfo);
            }).then(function () {
              return status.initializeUpdates(contactId);
            });
          }

          return $q.when();
        };

        return removeInvite(channelInfo.id).then(initializeChannel);
      };

      var inviteChannelInfo = {
        id: channels.INVITE_CHANNEL_ID,
        contactIds: channelInfo.contactIds
      };

      $log.debug('Buffer: Sending invite v' + userInfo.version + ' to ' + channelId);
      return network.sendInvite(inviteChannelInfo, userInfo).then(handleInviteAck);
    };

    var addInvite = function addInvite(channelId) {
      var userInfo = state.cloud.identity.get(['userInfo']);
      var existingBufferedInvite = sendAttempts.invites[channelId];

      var removeExistingInvite = existingBufferedInvite ? removeInvite(channelId) : $q.when();

      return removeExistingInvite.then(function () {
        sendInvite(channelId, userInfo);
        sendAttempts.invites[channelId] = $interval(function () {
          return sendInvite(channelId, userInfo);
        }, 20000, 0, false);
        return $q.when();
      }).then(function () {
        return state.save(state.cloud.buffer, ['invites', channelId], { channelId: channelId });
      });
    };

    var removeInvite = function removeInvite(channelId) {
      $interval.cancel(sendAttempts.invites[channelId]);
      sendAttempts.invites[channelId] = undefined;

      return state.remove(state.cloud.buffer, ['invites', channelId]);
    };

    var sendProfile = function sendProfile(channelId, userInfo) {
      var channelInfo = state.cloud.channels.get([channelId, 'channelInfo']);

      var contactId = channelInfo.contactIds[0];
      var contactStatusId = state.cloud.contacts.get([contactId, 'statusId']);
      if (contactStatusId === 0) {
        return;
      }

      var handleProfileAck = function handleProfileAck(ack) {
        return removeProfile(channelInfo.id);
      };

      $log.debug('Buffer: Sending profile v' + userInfo.version + ' to ' + channelId);
      return network.sendProfile(channelInfo, userInfo).then(handleProfileAck);
    };

    var addProfile = function addProfile(channelId) {
      var userInfo = state.cloud.identity.get(['userInfo']);
      var existingBufferedProfile = sendAttempts.profiles[channelId];

      var removeExistingProfile = existingBufferedProfile ? removeProfile(channelId) : $q.when();

      return removeExistingProfile.then(function () {
        sendProfile(channelId, userInfo);
        sendAttempts.profiles[channelId] = $interval(function () {
          return sendProfile(channelId, userInfo);
        }, 20000, 0, false);
        return $q.when();
      }).then(function () {
        return state.save(state.cloud.buffer, ['profiles', channelId], { channelId: channelId });
      });
    };

    var removeProfile = function removeProfile(channelId) {
      $interval.cancel(sendAttempts.profiles[channelId]);
      sendAttempts.profiles[channelId] = undefined;

      return state.remove(state.cloud.buffer, ['profiles', channelId]);
    };

    var initialize = function initialize(networkService, statusService) {
      network = networkService;
      status = statusService;

      var bufferedMessages = state.cloud.buffer.get(['messages']);

      sendAttempts.messages = R.mapObj(function (messageBuffer) {
        var channelId = messageBuffer.channelId;
        var messageId = messageBuffer.messageId;

        //TODO: try staggering the initial send and retry intervals
        // may not actually be more performant because it would trigger more
        // digest cycles in angular
        sendMessage(messageId, channelId);
        return $interval(function () {
          return sendMessage(messageId, channelId);
        }, 20000, 0, false);
      })(bufferedMessages);

      var bufferedProfiles = state.cloud.buffer.get(['profiles']);
      var userInfo = state.cloud.identity.get(['userInfo']);

      sendAttempts.profiles = R.mapObj(function (profileBuffer) {
        var channelId = profileBuffer.channelId;

        sendProfile(channelId, userInfo);
        return $interval(function () {
          return sendProfile(channelId, userInfo);
        }, 20000, 0, false);
      })(bufferedProfiles);

      var bufferedInvites = state.cloud.buffer.get(['invites']);

      sendAttempts.invites = R.mapObj(function (inviteBuffer) {
        var channelId = inviteBuffer.channelId;

        sendInvite(channelId, userInfo);
        return $interval(function () {
          return sendInvite(channelId, userInfo);
        }, 60000, 0, false);
      })(bufferedInvites);

      return $q.when();
    };

    return {
      addMessage: addMessage,
      addProfile: addProfile,
      addInvite: addInvite,
      initialize: initialize
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'buffer';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/buffer/buffer.js', ['github:angular/bower-angular@1.4.7', 'services/buffer/buffer-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesBufferBufferServiceJs) {
      service = _servicesBufferBufferServiceJs['default'];
      serviceName = _servicesBufferBufferServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.buffer', []).factory(serviceName, service));
    }
  };
});

System.register('services/channels/channels-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', channels);

  /*@ngInject*/
  function channels($q, R, state, cryptography) {
    var network = undefined;
    var CHANNEL_ID_PREFIX = 'toc-';
    var INVITE_CHANNEL_ID = CHANNEL_ID_PREFIX + 'invite';

    var generateContactChannelId = function generateContactChannelId(userId, contactId) {
      var channelId = userId > contactId ? userId + '-' + contactId : contactId + '-' + userId;

      //channel ids need to be somewhat short because they're prefixed on
      // most storage keys (including on every message), so there are huge
      // storage usage implications
      var shortChannelId = cryptography.getSha256(channelId).substr(0, 32);

      return CHANNEL_ID_PREFIX + shortChannelId;
    };

    var generateGroupChannelId = function generateGroupChannelId(userId, channelName) {
      var channelId = userId + channelName;

      return CHANNEL_ID_PREFIX + channelId;
    };

    var createContactChannel = function createContactChannel(userId, contactId) {
      var channelId = generateContactChannelId(userId, contactId);

      var channel = {
        id: channelId,
        contactIds: [contactId]
      };

      return channel;
    };

    var initializeChannel = function initializeChannel(channelInfo) {
      if (channelInfo.contactIds.length !== 1) {
        return $q.reject('Group chat not supported yet.');
      }

      var channelCursor = state.cloud.channels.select([channelInfo.id]);

      var logicalClock = channelCursor.get('logicalClock');

      if (logicalClock === undefined) {
        return state.save(channelCursor, ['logicalClock'], 0);
      }
      return $q.when();
    };

    var initialize = function initialize(networkService) {
      network = networkService;
      var existingChannels = state.cloud.channels.get();

      var initializingChannels = $q.all(R.pipe(R.values, R.reject(R.prop('inviteStatus')), R.map(R.prop('channelInfo')), R.map(function (channelInfo) {
        return initializeChannel(channelInfo).then(function () {
          return network.listen(channelInfo);
        });
      }))(existingChannels));

      return $q.when();
    };

    return {
      INVITE_CHANNEL_ID: INVITE_CHANNEL_ID,
      createContactChannel: createContactChannel,
      initializeChannel: initializeChannel,
      initialize: initialize
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'channels';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/channels/channels.js', ['github:angular/bower-angular@1.4.7', 'services/channels/channels-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesChannelsChannelsServiceJs) {
      service = _servicesChannelsChannelsServiceJs['default'];
      serviceName = _servicesChannelsChannelsServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.channels', []).factory(serviceName, service));
    }
  };
});

System.register('services/contacts/contacts-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', contacts);

  /*@ngInject*/
  function contacts($q, $ionicPopup, buffer, channels, identity, notifications, R, state) {
    var status = undefined;
    var network = undefined;

    var showAcceptInviteDialog = function showAcceptInviteDialog(channelId) {
      var contactId = state.cloud.channels.get([channelId, 'channelInfo', 'contactIds'])[0];
      var contact = state.cloud.contacts.get([contactId]);

      return notifications.dismiss(channelId).then(function () {
        return $ionicPopup.show({
          template: 'Accept invite from ' + (contact.userInfo.displayName || 'Anonymous') + '?',
          title: 'Accept Invite',
          buttons: [{
            text: 'Cancel',
            type: 'button-positive button-block button-outline'
          }, {
            text: 'Accept',
            type: 'button-positive button-block',
            onTap: function onTap(event) {
              return saveAcceptingInvite(channelId);
            }
          }]
        });
      });
    };

    var saveContactInfo = function saveContactInfo(contactInfo) {
      var contactCursor = state.cloud.contacts.select([contactInfo.id]);
      var existingContactInfo = contactCursor.get(['userInfo']);

      if (existingContactInfo && existingContactInfo.version > contactInfo.version) {
        return $q.when();
      }

      return state.save(contactCursor, ['userInfo'], contactInfo);
    };

    var saveReceivedProfile = function saveReceivedProfile(profilePayload) {
      var contactInfo = profilePayload;
      return saveContactInfo(contactInfo);
    };

    var saveSendingProfile = function saveSendingProfile(channelId) {
      return buffer.addProfile(channelId);
    };

    var saveReceivedInvite = function saveReceivedInvite(invitePayload) {
      var contactInfo = invitePayload;

      var userId = state.cloud.identity.get(['userInfo']).id;
      var newChannelInfo = channels.createContactChannel(userId, contactInfo.id);
      var contactCursor = state.cloud.contacts.select([contactInfo.id]);
      var channelCursor = state.cloud.channels.select([newChannelInfo.id]);

      var existingChannel = channelCursor.get();

      if (!existingChannel) {
        return saveContactInfo(contactInfo).then(function () {
          return state.save(contactCursor, ['statusId'], -1);
        }).then(function () {
          return state.save(channelCursor, ['channelInfo'], newChannelInfo);
        }).then(function () {
          return state.save(channelCursor, ['inviteStatus'], 'received');
        }).then(function () {
          return notifications.notify(newChannelInfo.id);
        });
      }

      if (existingChannel.inviteStatus === 'sent') {
        return saveContactInfo(contactInfo).then(function () {
          return state.remove(channelCursor, ['inviteStatus']);
        }).then(function () {
          return state.save(contactCursor, ['statusId'], 1);
        }).then(function () {
          return channels.initializeChannel(existingChannel.channelInfo);
        }).then(function () {
          return network.listen(existingChannel.channelInfo);
        }).then(function () {
          return status.initializeUpdates(contactInfo.id);
        });
      }

      return $q.when();
    };

    var saveAcceptingInvite = function saveAcceptingInvite(channelId) {
      var channelCursor = state.cloud.channels.select([channelId]);
      var existingChannel = channelCursor.get();

      if (!existingChannel) {
        return $q.reject('contact: missing existing channel');
      }

      if (existingChannel.inviteStatus === 'received') {
        return state.save(channelCursor, ['inviteStatus'], 'accepting').then(function () {
          return buffer.addInvite(channelId);
        });
      }

      return $q.when();
    };

    var saveSendingInvite = function saveSendingInvite(contactId) {
      var userInfo = state.cloud.identity.get('userInfo');
      if (contactId === userInfo.id) {
        return $q.reject('contact: cannot invite self');
      }

      var contactChannel = channels.createContactChannel(userInfo.id, contactId);
      var contactCursor = state.cloud.contacts.select([contactId]);
      var channelCursor = state.cloud.channels.select([contactChannel.id]);

      var existingChannel = channelCursor.get();

      if (existingChannel) {
        return $q.reject('contact: contact already exists');
      }

      var contactInfo = {
        version: 0,
        id: contactId
      };

      return state.save(contactCursor, ['userInfo'], contactInfo).then(function () {
        return state.save(contactCursor, ['statusId'], -1);
      }).then(function () {
        return state.save(channelCursor, ['channelInfo'], contactChannel);
      }).then(function () {
        return state.save(channelCursor, ['inviteStatus'], 'sending');
      }).then(function () {
        return buffer.addInvite(contactChannel.id);
      });
    };

    var saveProfileUpdates = function saveProfileUpdates() {
      var userInfo = state.cloud.identity.get('userInfo');
      var existingChannels = state.cloud.channels.get();

      var savingSendingProfiles = R.pipe(R.keys, R.map(function (channelId) {
        return saveSendingProfile(channelId);
      }))(existingChannels);

      return $q.all(savingSendingProfiles);
    };

    var initialize = function initializeContacts(statusService, networkService) {
      status = statusService;
      network = networkService;

      var allContacts = state.cloud.contacts.get();

      var settingContactsToOffline = R.pipe(R.values, R.filter(R.propEq('statusId', 1)), R.map(function (contact) {
        return state.save(state.cloud.contacts, [contact.userInfo.id, 'statusId'], 0);
      }))(allContacts);

      var pendingInvitesCursor = state.local.contacts.select('invites');

      var sendingPendingInvites = R.pipe(R.keys, R.filter(identity.validateId), R.map(function (inviteId) {
        return saveSendingInvite(inviteId)
        // ignore errors and clear pending invite from local storage
        ['catch'](function () {
          return $q.when();
        }).then(function () {
          return state.remove(pendingInvitesCursor, [inviteId]);
        });
      }))(pendingInvitesCursor.get());

      return $q.all(settingContactsToOffline);
    };

    return {
      showAcceptInviteDialog: showAcceptInviteDialog,
      saveContactInfo: saveContactInfo,
      saveReceivedProfile: saveReceivedProfile,
      saveSendingProfile: saveSendingProfile,
      saveReceivedInvite: saveReceivedInvite,
      saveAcceptingInvite: saveAcceptingInvite,
      saveSendingInvite: saveSendingInvite,
      saveProfileUpdates: saveProfileUpdates,
      initialize: initialize
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'contacts';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/contacts/contacts.js', ['github:angular/bower-angular@1.4.7', 'services/contacts/contacts-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesContactsContactsServiceJs) {
      service = _servicesContactsContactsServiceJs['default'];
      serviceName = _servicesContactsContactsServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.contacts', []).factory(serviceName, service));
    }
  };
});

System.register('services/cryptography/cryptography-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', cryptography);

  /*@ngInject*/
  function cryptography($q, $window, forge) {
    //TODO: add user setting to disable encryption
    var cachedCredentials = undefined;

    var AES_ENCRYPTION_MODE = 'AES-GCM';

    var AES_KEY_STRENGTH = 128;

    // From Forge docs:
    // Note: a key size of 16 bytes will use AES-128, 24 => AES-192, 32 => AES-256
    var PBKDF2_KEY_LENGTH = AES_KEY_STRENGTH / 8;
    var PBKDF2_SALT_LENGTH = PBKDF2_KEY_LENGTH;
    var AES_IV_LENGTH = PBKDF2_KEY_LENGTH;

    // TODO: research what the up-to-date recommendation for PBKDF2 iterations is
    // Could probably afford to use more if needed
    var PBKDF2_ITERATIONS = 10000;

    var HMAC_DIGEST_ALGORITHM = 'sha256';

    var ENCRYPTED_OBJECT = {
      name: 'tocEncryptedObject',
      //TODO: use JSON Schema URI for versioning
      schema: {
        type: 'object',
        properties: {
          ct: {
            type: 'string'
          },
          tag: {
            type: 'string'
          },
          iv: {
            type: 'string'
          }
        },
        required: ['ct', 'tag', 'iv']
      }
    };

    var UNENCRYPTED_OBJECT = {
      name: 'tocUnencryptedObject',
      schema: {
        type: 'object',
        properties: {
          pt: {
            type: 'string'
          }
        },
        required: ['pt']
      }
    };

    // replaces forwardslash in base64 string for use in paths for indexeddb
    var escapeBase64 = function escapeBase64(base64) {
      return base64.replace(/\//g, '.');
    };

    var unescapeBase64 = function unescapeBase64(base64) {
      return base64.replace(/\./g, '/');
    };

    var getRandomBytes = function getRandom(size) {
      var deferredRandomBytes = $q.defer();

      forge.random.getBytes(size, function (error, bytes) {
        if (error) {
          return deferredRandomBytes.reject(error);
        }

        deferredRandomBytes.resolve(bytes);
      });

      return deferredRandomBytes.promise;
    };

    var getRandomBase64 = function getRandomBase64(size) {
      return getRandomBytes(size).then(function (randomBytes) {
        return forge.util.encode64(randomBytes);
      });
    };

    var encodeBase64Sync = function encodeBase64(bytes) {
      var base64 = forge.util.encode64(bytes);
      return base64;
    };

    var decodeBase64Sync = function decodeBase64(base64) {
      var bytes = forge.util.decode64(base64);
      return bytes;
    };

    var encodeBase64 = function encodeBase64(bytes) {
      var base64 = encodeBase64Sync(bytes);
      return $q.when(base64);
    };

    var decodeBase64 = function decodeBase64(base64) {
      var bytes = decodeBase64Sync(base64);
      return $q.when(bytes);
    };

    var checkCredentials = function checkCredentials(credentials) {
      if (credentials && credentials.key) {
        return;
      }
      throw new Error('cryptography: mising credentials');
    };

    var getHmac = function getHmac(object) {
      var credentials = arguments.length <= 1 || arguments[1] === undefined ? cachedCredentials : arguments[1];

      checkCredentials(credentials);

      var plaintext = JSON.stringify(object);

      var hmac = forge.hmac.create();

      hmac.start(HMAC_DIGEST_ALGORITHM, credentials.key);
      hmac.update(plaintext);

      return hmac.digest().getBytes();
    };

    var getMd5 = function getMd5(plaintext) {
      var md5 = forge.md.md5.create();
      md5.update(plaintext);

      return md5.digest().toHex();
    };

    var getSha256 = function getSha256(plaintext) {
      var sha256 = forge.md.sha256.create();
      sha256.update(plaintext);

      return sha256.digest().toHex();
    };

    var encryptBase = function encryptBase(object, ivBytes) {
      var credentials = arguments.length <= 2 || arguments[2] === undefined ? cachedCredentials : arguments[2];

      checkCredentials(credentials);

      var plaintext = JSON.stringify(object);

      var cipher = forge.cipher.createCipher(AES_ENCRYPTION_MODE, credentials.key);

      cipher.start({ iv: ivBytes });
      cipher.update(forge.util.createBuffer(plaintext));
      cipher.finish();

      var iv = forge.util.encode64(ivBytes);
      var ct = forge.util.encode64(cipher.output.getBytes());
      var tag = forge.util.encode64(cipher.mode.tag.getBytes());

      return { iv: iv, ct: ct, tag: tag };
    };

    // Hand-rolled deterministic encryption scheme.
    // TODO: replace with something standard like SIV-AES
    var encryptDeterministic = function encryptDeterministic(object) {
      var credentials = arguments.length <= 1 || arguments[1] === undefined ? cachedCredentials : arguments[1];

      var ivBytes = getHmac(object);

      return encryptBase(object, ivBytes, credentials);
    };

    var encrypt = function encrypt(object) {
      var credentials = arguments.length <= 1 || arguments[1] === undefined ? cachedCredentials : arguments[1];

      var ivBytes = forge.random.getBytesSync(AES_IV_LENGTH);

      return encryptBase(object, ivBytes, credentials);
    };

    var decrypt = function decrypt(encryptedObject) {
      var credentials = arguments.length <= 1 || arguments[1] === undefined ? cachedCredentials : arguments[1];

      checkCredentials(credentials);

      var ciphertext = forge.util.decode64(encryptedObject.ct);
      var iv = forge.util.decode64(encryptedObject.iv);
      var tag = forge.util.decode64(encryptedObject.tag);

      var decipher = forge.cipher.createDecipher(AES_ENCRYPTION_MODE, credentials.key);

      decipher.start({
        iv: forge.util.createBuffer(iv),
        tag: forge.util.createBuffer(tag)
      });

      decipher.update(forge.util.createBuffer(ciphertext));

      var result = decipher.finish();

      if (!result) {
        throw new Error('cryptography: decryption failed');
      }

      return JSON.parse(decipher.output.getBytes());
    };

    var createSalt = function createSalt() {
      return getRandomBase64(PBKDF2_SALT_LENGTH);
    };

    var createChallenge = function createChallenge(salt) {
      return $q.when(encrypt(salt));
    };

    var derive = function derive(rawCredentials) {
      var salt = forge.util.decode64(rawCredentials.salt);
      var key = forge.pkcs5.pbkdf2(rawCredentials.password, salt, PBKDF2_ITERATIONS, PBKDF2_KEY_LENGTH);

      return $q.when({ key: key });
    };

    var isInitialized = function isInitialized() {
      return cachedCredentials !== undefined;
    };

    var cache = function cache(derivedCredentials) {
      checkCredentials(derivedCredentials);

      cachedCredentials = derivedCredentials;
      return $q.when(derivedCredentials);
    };

    var initialize = function initializeCryptography(credentials) {
      var cachingCredentials = credentials.key ? cache({ key: decodeBase64Sync(credentials.key) }) : derive(credentials).then(cache);

      return cachingCredentials.then(function (derivedCredentials) {
        return {
          key: encodeBase64Sync(derivedCredentials.key)
        };
      });
    };

    var destroy = function destroyCryptography() {
      cachedCredentials = undefined;
      return $q.when();
    };

    var cryptographyService = {
      ENCRYPTED_OBJECT: ENCRYPTED_OBJECT,
      UNENCRYPTED_OBJECT: UNENCRYPTED_OBJECT,
      escapeBase64: escapeBase64,
      unescapeBase64: unescapeBase64,
      encodeBase64: encodeBase64,
      decodeBase64: decodeBase64,
      getRandomBase64: getRandomBase64,
      getHmac: getHmac,
      getMd5: getMd5,
      getSha256: getSha256,
      encryptDeterministic: encryptDeterministic,
      encrypt: encrypt,
      decrypt: decrypt,
      createSalt: createSalt,
      createChallenge: createChallenge,
      derive: derive,
      isInitialized: isInitialized,
      initialize: initialize,
      destroy: destroy
    };

    $window.tocCrypto = cryptographyService;

    return cryptographyService;
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'cryptography';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/cryptography/cryptography.js', ['github:angular/bower-angular@1.4.7', 'services/cryptography/cryptography-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesCryptographyCryptographyServiceJs) {
      service = _servicesCryptographyCryptographyServiceJs['default'];
      serviceName = _servicesCryptographyCryptographyServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.cryptography', []).factory(serviceName, service));
    }
  };
});

System.register('services/devices/devices-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', devices);

  /*@ngInject*/
  function devices($interval, $ionicPopup, $log, $q, $rootScope, $window, cryptography, R, state) {
    var session = undefined;
    var localDisconnectFlag = undefined;

    var isCordovaApp = function isCordovaApp() {
      return $window.cordova ? true : false;
    };

    var isWebApp = function isWebApp() {
      return $window.cordova ? false : true;
    };

    var isAndroidApp = function isAndroidApp() {
      if (!isCordovaApp()) {
        return false;
      }

      return $window.cordova.platformId === 'android';
    };

    var isInForeground = function isInForeground() {
      // fallback for when page visibility api isnt supported
      if ($window.document.hidden === undefined) {
        if ($window.document.hasFocus === undefined) {
          return true;
        }
        return $window.document.hasFocus();
      }

      return !$window.document.hidden;
    };

    var disconnectOtherDevices = function disconnectOtherDevices() {
      var localDeviceId = state.local.devices.get(['deviceInfo', 'id']);

      var existingCloudDevices = state.cloud.devices.get() || {};

      var updateDisconnectFlag = function updateDisconnectFlag(deviceId) {
        return cryptography.getRandomBase64(2).then(function (disconnectFlag) {
          if (deviceId === localDeviceId) {
            localDisconnectFlag = disconnectFlag;
          }
          return state.save(state.cloud.devices, [deviceId, 'disconnect'], disconnectFlag);
        });
      };

      var otherDeviceIds = R.pipe(R.keys, R.reject(R.equals(localDeviceId)))(existingCloudDevices);

      var disconnectingOthers = R.map(updateDisconnectFlag)(otherDeviceIds);

      return updateDisconnectFlag(localDeviceId).then(function () {
        return $q.all(disconnectingOthers);
      });
    };

    var listenForDisconnects = function listenForDisconnects(destroySession) {
      var localDeviceId = state.local.devices.get(['deviceInfo', 'id']);
      var localDisconnectCursor = state.cloud.devices.select([localDeviceId, 'disconnect']);

      var handleDisconnects = function handleDisconnects(event) {
        if (event.data.currentData === localDisconnectFlag) {
          return;
        }

        var disconnectPopupScope = $rootScope.$new();
        disconnectPopupScope.disconnectPopup = {
          countdown: 15
        };

        var disconnectingDevice = $interval(function () {
          disconnectPopupScope.disconnectPopup.countdown = disconnectPopupScope.disconnectPopup.countdown - 1;
        }, 1000, 15, true);

        disconnectingDevice.then(function () {
          return destroySession();
        });

        var remoteLoginPopup = $ionicPopup.show({
          title: 'Another device has connected',
          template: 'This device will disconnect in ' + '{{disconnectPopup.countdown}} seconds.',
          scope: disconnectPopupScope,
          buttons: [{
            text: 'Stay connected',
            type: 'button-positive button-block',
            onTap: function onTap(event) {
              $interval.cancel(disconnectingDevice);
              disconnectOtherDevices();
            }
          }]
        });
      };

      state.addListener(localDisconnectCursor, handleDisconnects, null, {
        skipInitialize: true
      });

      return $q.when();
    };

    var create = function create() {
      var localDeviceInfo = state.local.devices.get('deviceInfo');

      return localDeviceInfo ? $q.when(localDeviceInfo) : cryptography.getRandomBase64(8).then(function (deviceId) {
        return state.save(state.local.devices, ['deviceInfo'], { id: deviceId });
      });
    };

    var initialize = function initializeDevices(sessionService) {
      session = sessionService;

      return disconnectOtherDevices().then(function () {
        return listenForDisconnects(session.destroy);
      });
    };

    return {
      initialize: initialize,
      create: create,
      isAndroidApp: isAndroidApp,
      isInForeground: isInForeground,
      isCordovaApp: isCordovaApp,
      isWebApp: isWebApp
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'devices';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/devices/devices.js', ['github:angular/bower-angular@1.4.7', 'services/devices/devices-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesDevicesDevicesServiceJs) {
      service = _servicesDevicesDevicesServiceJs['default'];
      serviceName = _servicesDevicesDevicesServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.devices', []).factory(serviceName, service));
    }
  };
});

System.register('services/identity/identity-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', identity);

  /*@ngInject*/
  function identity($q, $filter, cryptography, R, state) {
    var getAvatarBase = R.memoize(function getAvatarBase(identifier) {
      var identifierHash = cryptography.getMd5(identifier);
      // cordova app crashes if we don't add the .jpg
      return 'http://cdn.libravatar.org/avatar/' + identifierHash + '.jpg?s=96&d=identicon';
    });

    var getAvatar = function getAvatar(userInfo) {
      if (!userInfo) {
        return getAvatarBase('unknown-user@toc.im');
      }

      if (userInfo.email) {
        return getAvatarBase(userInfo.email);
      }

      if (userInfo.id) {
        return getAvatarBase(userInfo.id);
      }

      // default to hash of unknown-user@toc.im
      return getAvatarBase('unknown-user@toc.im');
    };

    var validateId = function validateId(id) {
      var idRegex = /^[a-f0-9]{64}$/i;
      return idRegex.test(id);
    };

    var authenticate = function authenticate(derivedCredentials) {
      var challenge = state.cloudUnencrypted.cryptography.get(['challenge']);

      if (!challenge) {
        return $q.reject('identity: missing auth challenge');
      }

      try {
        cryptography.decrypt(challenge);
      } catch (error) {
        return cryptography.destroy().then(function () {
          return $q.reject('identity: wrong password');
        });
      }

      return $q.when(derivedCredentials);
    };

    var initialize = function initializeIdentity(credentials, staySignedIn) {
      var saveCredentials = function saveCredentials(derivedCredentials) {
        if (!staySignedIn) {
          return $q.when();
        }

        var existingCredentials = state.local.cryptography.get(['derivedCredentials']);

        if (existingCredentials) {
          return $q.when();
        }

        return state.save(state.local.cryptography, ['derivedCredentials'], derivedCredentials);
      };

      var verifyCredentials = function verifyCredentials(credentials) {
        return cryptography.initialize(credentials).then(authenticate).then(saveCredentials);
      };

      if (credentials.key) {
        return verifyCredentials(credentials);
      }

      if (!credentials.password) {
        return $q.reject('identity: no password or key provided');
      }

      var existingSalt = state.cloudUnencrypted.cryptography.get(['salt']);

      if (existingSalt) {
        var rawCredentials = {
          password: credentials.password,
          salt: existingSalt
        };

        return verifyCredentials(rawCredentials);
      }

      var saveSalt = function saveSalt(salt) {
        return state.save(state.cloudUnencrypted.cryptography, ['salt'], salt);
      };

      var saveChallege = function saveChallege(challenge) {
        return state.save(state.cloudUnencrypted.cryptography, ['challenge'], challenge);
      };

      return cryptography.createSalt().then(saveSalt).then(function (salt) {
        return cryptography.initialize({
          password: credentials.password,
          salt: salt
        }).then(saveCredentials).then(function () {
          return cryptography.createChallenge(salt);
        });
      }).then(saveChallege);
    };

    var destroy = function destroyIdentity() {
      return $q.when();
    };

    return {
      getAvatar: getAvatar,
      validateId: validateId,
      authenticate: authenticate,
      initialize: initialize,
      destroy: destroy
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'identity';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/identity/identity.js', ['github:angular/bower-angular@1.4.7', 'services/identity/identity-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesIdentityIdentityServiceJs) {
      service = _servicesIdentityIdentityServiceJs['default'];
      serviceName = _servicesIdentityIdentityServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.identity', []).factory(serviceName, service));
    }
  };
});

System.register('services/messages/messages-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', messages);

  /*@ngInject*/
  function messages($q, $log, buffer, devices, cryptography, time, state, notifications, R) {
    var compareMessages = function compareMessages(message1, message2) {
      var logicalClockDiff = message1.messageInfo.logicalClock - message2.messageInfo.logicalClock;

      if (logicalClockDiff === 0) {
        //tiebreaker
        //id is in format sentTime-(hash(channelId-senderId))
        return message1.messageInfo.id > message2.messageInfo.id ? 1 : -1;
      }

      // >1 message1 is later
      // <1 message1 is earlier
      return logicalClockDiff;
    };

    var saveReceivedMessage = function saveReceivedMessage(messagePayload, messageMetadata) {
      var sentTime = messageMetadata.sentTime;
      var senderId = messageMetadata.senderId;
      var channelId = messageMetadata.channelId;

      var messageIdBase = cryptography.getSha256(channelId + '-' + senderId).substr(0, 32);
      var messageId = sentTime + '-' + messageIdBase;

      var existingMessage = state.cloud.messages.get([channelId, messageId]);
      if (existingMessage) {
        return $q.when();
      }

      var receivedTime = messageMetadata.receivedTime;
      var messageContent = messagePayload.c;
      var receivedLogicalClock = messagePayload.l;

      var messageInfo = {
        id: messageId,
        //TODO: find main contact endpoint id from sender userId
        // when using multi-endpoint contacts
        senderId: senderId,
        sentTime: sentTime,
        logicalClock: receivedLogicalClock,
        content: messageContent
      };

      var channelCursor = state.cloud.channels.select([channelId]);
      var messagesCursor = state.cloud.messages.select([channelId]);
      var messageCursor = messagesCursor.select([messageId]);
      var existingLogicalClock = channelCursor.get('logicalClock');

      var currentLogicalClock = receivedLogicalClock >= existingLogicalClock ? receivedLogicalClock : existingLogicalClock;

      var newLogicalClock = currentLogicalClock + 1;

      var updateLatestMessageId = function updateLatestMessageId() {
        var latestMessageId = channelCursor.get(['latestMessageId']);
        if (latestMessageId) {
          var latestMessage = messagesCursor.get([latestMessageId]);
          var message = { messageInfo: messageInfo };

          //do nothing if message is earlier than latest message
          if (compareMessages(message, latestMessage) < 0) {
            return $q.when();
          }
        }

        return state.save(channelCursor, ['latestMessageId'], messageId);
      };

      var notifyMessage = function notifyMessage() {
        //dont notify or update unread pointer if viewing latest message
        var activeViewId = state.cloud.navigation.get(['activeViewId']);
        if (activeViewId === channelId && channelCursor.get(['viewingLatest']) && devices.isInForeground()) {
          return $q.when();
        }

        var updateUnreadPointer = function updateUnreadPointer() {
          var unreadMessageId = channelCursor.get(['unreadMessageId']);
          if (unreadMessageId) {
            var unreadMessage = messagesCursor.get([unreadMessageId]);
            var message = { messageInfo: messageInfo };

            //do nothing if message is later than unread message
            if (compareMessages(message, unreadMessage) > 0) {
              return $q.when();
            }
          }

          return state.save(channelCursor, ['unreadMessageId'], messageId);
        };

        return updateUnreadPointer().then(function () {
          return notifications.notify(channelId);
        });
      };

      return state.save(channelCursor, ['logicalClock'], newLogicalClock).then(function () {
        return state.save(messageCursor, ['messageInfo'], messageInfo);
      }).then(function () {
        return state.save(messageCursor, ['receivedTime'], receivedTime);
      }).then(updateLatestMessageId).then(notifyMessage)['catch']($log.error);
    };

    var saveSendingMessage = function saveSendingMessage(channelId, messageContent) {
      if (!messageContent) {
        return $q.reject('messages: message must not be empty');
      }

      var senderId = state.cloud.identity.get(['userInfo', 'id']);
      var logicalClock = state.cloud.channels.get([channelId, 'logicalClock']);
      var newLogicalClock = logicalClock + 1;
      var sentTime = time.getTime();

      var messageIdBase = cryptography.getSha256(channelId + '-' + senderId).substr(0, 32);
      var messageId = sentTime + '-' + messageIdBase;

      var existingMessage = state.cloud.messages.get([channelId, messageId]);
      if (existingMessage) {
        return $q.when();
      }

      var messageInfo = {
        id: messageId,
        senderId: senderId,
        sentTime: sentTime,
        logicalClock: newLogicalClock,
        content: messageContent
      };

      var bumpLogicalClock = function bumpLogicalClock() {
        return state.save(state.cloud.channels, [channelId, 'logicalClock'], newLogicalClock);
      };

      var saveMessageInfo = function saveMessageInfo() {
        return state.save(state.cloud.messages, [channelId, messageId, 'messageInfo'], messageInfo);
      };

      return bumpLogicalClock().then(saveMessageInfo).then(function () {
        return buffer.addMessage(messageId, channelId);
      })['catch']($log.error);
    };

    var initialize = function initialize() {
      return $q.when();
    };

    return {
      compareMessages: compareMessages,
      saveSendingMessage: saveSendingMessage,
      saveReceivedMessage: saveReceivedMessage,
      initialize: initialize
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'messages';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/messages/messages.js', ['github:angular/bower-angular@1.4.7', 'services/messages/messages-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesMessagesMessagesServiceJs) {
      service = _servicesMessagesMessagesServiceJs['default'];
      serviceName = _servicesMessagesMessagesServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.messages', []).factory(serviceName, service));
    }
  };
});

System.register('services/navigation/navigation-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', navigation);

  /*@ngInject*/
  function navigation($ionicHistory, $ionicModal, $q, $rootScope, $state, $window, $timeout, devices, R, state) {
    var routes = {
      'public': {
        welcome: 'public.welcome',
        cloud: 'public.cloud',
        signin: 'public.signin',
        signout: 'public.signin'
      },
      'private': {
        home: 'private.home',
        cloud: 'private.cloud',
        channel: 'private.channel'
      }
    };

    var DEFAULT_PUBLIC_STATE = routes['public'].welcome;
    var DEFAULT_PRIVATE_STATE = routes['private'].home;

    var go = function go(stateName, parameters) {
      var options = { location: 'replace' };
      return $state.go(stateName, parameters, options);
    };

    var navigate = function navigate(viewId) {
      if (isActiveView(viewId)) {
        return $q.when();
      }

      var toHome = viewId === 'home';

      if (!toHome) {
        var channelExists = R.pipe(R.keys, R.contains(viewId))(state.cloud.channels.get() || {});

        if (!channelExists) {
          return $q.when();
        }
      }

      var destination = toHome ? routes['private'].home : routes['private'].channel;
      var destinationParams = toHome ? undefined : { channelId: viewId };

      $ionicHistory.nextViewOptions({
        disableBack: true,
        disableAnimate: false,
        historyRoot: true
      });

      return go(destination, destinationParams).then(function () {
        return state.save(state.cloud.navigation, ['activeViewId'], viewId);
      });
    };

    var isActiveView = function isActiveView(viewId) {
      return state.cloud.navigation.get('activeViewId') === viewId;
    };

    var at = function at(stateName, parameters) {
      return $state.is(stateName, parameters);
    };

    var showModal = function showModal(modalName, template, controller, scope) {
      //clean up existing modal if it was hidden instead of removed
      if (controller[modalName]) {
        controller[modalName].remove();
      }

      controller[modalName] = $ionicModal.fromTemplate(template, { scope: scope });
      return controller[modalName].show();
    };

    var openWindow = function openWindow(address) {
      var doOpenWindow = devices.isCordovaApp() ? $window.cordova.InAppBrowser.open : $window.open;
      var windowTarget = devices.isCordovaApp() ? '_system' : '_blank';

      doOpenWindow(address, windowTarget);
      return $q.when();
    };

    var setupRedirect = function setupRedirect() {
      // redirect to routes.welcome if identity has not been initialized
      $rootScope.$on('$stateChangeStart', function (event, toState) {
        var doRedirect = undefined;
        var redirectStateName = undefined;

        if (state.cloud.identity && state.cloud.identity.get()) {
          doRedirect = !isPrivateState(toState.name);
          redirectStateName = DEFAULT_PRIVATE_STATE;
        } else {
          doRedirect = isPrivateState(toState.name);
          redirectStateName = DEFAULT_PUBLIC_STATE;
        }

        if (!doRedirect) {
          return;
        }

        event.preventDefault();
        return go(redirectStateName);
      });

      return $q.when();
    };

    var clearCache = function clearCache() {
      return $ionicHistory.clearCache();
    };

    var isPrivateState = function isPrivateState(stateName) {
      if (stateName) {
        return stateName.startsWith('private');
      }

      return $state.includes('private');
    };

    var resetHistory = function resetHistory() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? { disableAnimate: false } : arguments[0];

      $ionicHistory.nextViewOptions({
        historyRoot: true,
        disableBack: true,
        disableAnimate: options.disableAnimate
      });
      return $q.when();
    };

    var initializePublic = function initializePublic() {
      var prepareNavigate = !at(routes['public'].welcome) ? resetHistory({ disableAnimate: true }) : $q.when();

      return prepareNavigate.then(function () {
        return go(routes['public'].welcome);
      })
      //workaround for too early initialization
      .then(function () {
        return $timeout(function () {
          return clearCache();
        }, 0, false);
      });
    };

    var initialize = function initializeNavigation() {
      var activeViewId = state.cloud.navigation.get('activeViewId');

      if (activeViewId === undefined) {
        return resetHistory().then(function () {
          return go(DEFAULT_PRIVATE_STATE);
        }).then(function () {
          return state.save(state.cloud.navigation, ['activeViewId'], 'home');
        });
      }

      if (activeViewId.startsWith('toc-')) {
        return resetHistory().then(function () {
          return go(routes['private'].channel, { channelId: activeViewId });
        });
      }

      return resetHistory().then(function () {
        return go(DEFAULT_PRIVATE_STATE);
      });
    };

    return {
      routes: routes,
      go: go,
      at: at,
      navigate: navigate,
      openWindow: openWindow,
      isActiveView: isActiveView,
      isPrivateState: isPrivateState,
      showModal: showModal,
      clearCache: clearCache,
      setupRedirect: setupRedirect,
      resetHistory: resetHistory,
      initializePublic: initializePublic,
      initialize: initialize
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'navigation';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/navigation/navigation.js', ['github:angular/bower-angular@1.4.7', 'services/navigation/navigation-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesNavigationNavigationServiceJs) {
      service = _servicesNavigationNavigationServiceJs['default'];
      serviceName = _servicesNavigationNavigationServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.navigation', []).factory(serviceName, service));
    }
  };
});

System.register('services/network/network-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', network);

  /*@ngInject*/
  function network($interval, $q, $window, channels, contacts, notifications, messages, R, state, time, telehash) {
    var activatingSession = $q.defer();
    var activeSession = undefined;

    var checkSession = function checkSession(session) {
      if (session) {
        return;
      }

      throw new Error('network: no active session');
    };

    var handleInvite = function handleInvite(invitePayload) {
      return contacts.saveReceivedInvite(invitePayload);
    };

    var handleProfile = function handleProfile(profilePayload) {
      return contacts.saveReceivedProfile(profilePayload);
    };

    var handleStatus = function handleStatus(statusPayload, contactId) {
      var statusId = statusPayload;
      var contactCursor = state.cloud.contacts.select([contactId]);
      var currentContactStatus = contactCursor.get(['statusId']);

      if (currentContactStatus === statusId) {
        return $q.when();
      }

      return state.save(state.cloud.contacts, [contactId, 'statusId'], statusId);
    };

    var handleMessage = function handleMessage(messagePayload, messageMetadata) {
      return messages.saveReceivedMessage(messagePayload, messageMetadata);
    };

    var listen = function listen(channelInfo) {
      var session = arguments.length <= 1 || arguments[1] === undefined ? activeSession : arguments[1];

      var handlePacket = function handlePacket(error, packet, channel, callback) {
        var handledPacket = function handledPacket() {
          if (error) {
            return $q.reject(error);
          }

          var senderId = packet.from.hashname;
          var channelId = channel.type.substr(1); //removes leading underscore

          var ackPayload = packet.js.a;
          var invitePayload = packet.js.i;
          var profilePayload = packet.js.p;
          var statusPayload = packet.js.s;
          var messagePayload = packet.js.m;

          callback(true);

          var sendAck = function sendAck(ackPayload) {
            channel.send({ js: { a: ackPayload } });
          };

          if (ackPayload) {
            return handleStatus(1, senderId);
          } else if (invitePayload) {
            sendAck({});
            return handleInvite(invitePayload);
          } else if (profilePayload) {
            sendAck({});
            return handleProfile(profilePayload);
          } else if (statusPayload !== undefined) {
            sendAck({});
            return handleStatus(statusPayload, senderId);
          } else if (messagePayload) {
            var receivedTime = time.getTime();
            var sentTime = packet.js.t;

            var _ackPayload = {
              s: sentTime,
              r: receivedTime
            };
            sendAck(_ackPayload);

            var messageMetadata = {
              senderId: senderId,
              channelId: channelId,
              sentTime: sentTime,
              receivedTime: receivedTime
            };
            return handleMessage(messagePayload, messageMetadata);
          } else {
            return $q.reject('Unrecognized packet format: ' + JSON.stringify(packet.js));
          }
        };

        return handledPacket();
      };

      try {
        checkSession(session);
        var listenResult = session.listen(channelInfo.id, handlePacket);
        return $q.when(listenResult);
      } catch (error) {
        // if session is not active, defer listening until it becomes active
        if (error.message === 'network: no active session') {
          return activatingSession.promise.then(function (newSession) {
            var listenResult = newSession.listen(channelInfo.id, handlePacket);
            return $q.when(listenResult);
          });
        }
        return $q.reject(error);
      }
    };

    var send = function send(channelInfo, payload) {
      var session = arguments.length <= 2 || arguments[2] === undefined ? activeSession : arguments[2];

      var sendingPacket = $q.defer();

      var handleAck = function handleAck(error, packet, channel, callback) {
        if (error) {
          return sendingPacket.reject(error);
        }

        var ackPayload = packet.js.a;
        if (!ackPayload) {
          return sendingPacket.reject('Unrecognized message ack format');
        }

        callback(true);
        var senderId = packet.from.hashname;
        handleStatus(1, senderId);
        return sendingPacket.resolve(ackPayload);
      };

      try {
        checkSession(session);
        session.start(channelInfo.contactIds[0], channelInfo.id, { js: payload }, handleAck);
      } catch (error) {
        sendingPacket.reject(error);
      }

      return sendingPacket.promise;
    };

    var handleSendTimeout = function handleSendTimeout(error, contactId, contactStatusId) {
      if (error !== 'timeout') {
        return $q.reject(error);
      }

      var contactCursor = state.cloud.contacts.select([contactId]);

      // do not change status back to offline if contact was already offline
      // or if contact status has been updated since message was sent
      var currentContactStatusId = contactCursor.get(['statusId']);
      if (currentContactStatusId === 0 || currentContactStatusId !== contactStatusId) {
        return $q.reject(error);
      }

      return state.save(state.cloud.contacts, [contactId, 'statusId'], 0);
    };

    var sendInvite = function sendInvite(channelInfo, userInfo) {
      var payload = {
        i: userInfo
      };

      return send(channelInfo, payload);
    };

    var sendProfile = function sendProfile(channelInfo, userInfo) {
      var payload = {
        p: userInfo
      };

      return send(channelInfo, payload);
    };

    var sendStatus = function sendStatus(contactId, statusId) {
      var userId = state.cloud.identity.get().userInfo.id;
      var contactChannel = channels.createContactChannel(userId, contactId);

      var contactCursor = state.cloud.contacts.select([contactId]);

      var previousContactStatusId = contactCursor.get(['statusId']);

      if (previousContactStatusId === undefined) {
        return $q.when();
      }

      var payload = {
        s: statusId
      };

      return send(contactChannel, payload)['catch'](function (error) {
        return handleSendTimeout(error, contactId, previousContactStatusId);
      });
    };

    var sendMessage = function sendMessage(channelInfo, messageInfo) {
      var contactId = channelInfo.contactIds[0];

      var previousContactStatusId = state.cloud.contacts.get([contactId, 'statusId']);

      if (previousContactStatusId === undefined) {
        return $q.when();
      }

      var payload = {
        m: {
          c: messageInfo.content,
          l: messageInfo.logicalClock
        },
        t: messageInfo.sentTime
      };

      return send(channelInfo, payload);
    };

    var initialize = function initializeNetwork() {
      var keypair = state.cloud.network.get(['networkInfo', 'keypair']);

      var saveUserInfo = function saveUserInfo(networkInfo) {
        var userInfo = {
          version: 1,
          id: networkInfo.id
        };

        return state.save(state.cloud.identity, ['userInfo'], userInfo);
      };

      //Don't save network info if already saved
      var saveNetworkInfo = function saveNetworkInfo(networkInfo) {
        return keypair ? $q.when() : state.save(state.cloud.network, ['networkInfo'], networkInfo).then(saveUserInfo);
      };

      var telehashOptions = keypair ? { id: keypair } : {};

      var startNetwork = function startNetwork(telehashSession) {
        var networkInfo = {
          id: telehashSession.hashname,
          keypair: telehashSession.id
        };

        activeSession = telehashSession;
        //DEBUG
        $window.tocSession = activeSession;

        listen({ id: channels.INVITE_CHANNEL_ID });

        activatingSession.resolve(activeSession);

        return networkInfo;
      };

      var connectToNetwork = function connectToNetwork() {
        var deferredSession = $q.defer();

        try {
          telehash.init(telehashOptions, function initializeTelehash(error, telehashSession) {
            if (error) {
              return deferredSession.reject(error);
            }

            return deferredSession.resolve(telehashSession);
          });
        } catch (error) {
          return $q.reject(error);
        }

        return deferredSession.promise;
      };

      // don't block on network connection attempt if user already initialized
      if (keypair) {
        var _ret = (function () {
          var attemptBackgroundConnection = function attemptBackgroundConnection() {
            return connectToNetwork().then(startNetwork)['catch'](function (error) {
              // abort if network connection fails for reasons other than offline
              if (error !== 'offline') {
                return $q.reject(error);
              }
              return attemptBackgroundConnection();
            });
          };
          attemptBackgroundConnection();

          return {
            v: $q.when()
          };
        })();

        if (typeof _ret === 'object') return _ret.v;
      }

      return connectToNetwork().then(startNetwork).then(saveNetworkInfo)['catch'](function (error) {
        if (error === 'offline') {
          return $q.reject('New accounts cannot be created offline');
        }
        return $q.reject(error);
      });
    };

    var destroy = function destroyNetwork() {
      //FIXME: cleanup isnt thorough enough, some telehash console errors remain
      // return destroyChannels().then(() => {
      //   // brute force stop telehash networking, alternative is to reload page...
      //   R.pipe(
      //     R.keys,
      //     R.forEach((key) => {
      //       delete activeSession[key];
      //     })
      //   )(activeSession);
      //
      //   activeSession = undefined;
      //
      //   return $q.when();
      // });
    };

    var networkService = {
      listen: listen,
      send: send,
      sendInvite: sendInvite,
      sendProfile: sendProfile,
      sendStatus: sendStatus,
      sendMessage: sendMessage,
      initialize: initialize,
      destroy: destroy
    };

    $window.tocNetwork = networkService;
    return networkService;
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'network';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/network/network.js', ['github:angular/bower-angular@1.4.7', 'services/network/network-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesNetworkNetworkServiceJs) {
      service = _servicesNetworkNetworkServiceJs['default'];
      serviceName = _servicesNetworkNetworkServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.network', []).factory(serviceName, service));
    }
  };
});

System.register('services/notifications/notifications-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', notifications);

  /*@ngInject*/
  function notifications($rootScope, $window, $log, $timeout, $q, devices, cryptography, identity, navigation, state, R) {
    var contacts = undefined;
    var activeWebNotifications = {};
    // cordovaLocalNotification uses number IDs
    // notificationId is just channelId, and has the form toc-{32hex-chars}
    var getCordovaNotificationId = function getCordovaNotificationId(notificationId) {
      var lastEightHex = notificationId.substr(notificationId.length - 8);
      return parseInt(lastEightHex, 16);
    };

    var getNotificationMessage = function getNotificationMessage(notificationId) {
      var channelId = notificationId;
      var channelCursor = state.cloud.channels.select([channelId]);

      var notificationMessage = undefined;
      if (channelCursor.get(['inviteStatus']) === 'received') {
        return 'New invite received!';
      }

      var messageIdCursor = channelCursor.select(['latestMessageId']);
      var messageId = messageIdCursor.get();
      if (!messageId) {
        return '';
      }

      return state.cloud.messages.get([channelId, messageId, 'messageInfo', 'content']);
    };

    // let notifyCordova = function notifyCordova(notificationInfo) {
    //   let channelId = notificationInfo.id;
    //   let channelCursor = state.cloud.channels.select([channelId]);
    //   let contactId = channelCursor.get(['channelInfo', 'contactIds'])[0];
    //   let contactCursor = state.cloud.contacts.select(contactId);
    //   let contactInfo = contactCursor.get('userInfo');
    //
    //   let icon = identity.getAvatar(contactInfo);
    //   let title = contactInfo.displayName || 'Anonymous';
    //   let text = getNotificationMessage(notificationInfo.id);
    //
    //   let cordovaNotificationInfo = {
    //     id: notificationInfo.cordovaNotificationId,
    //     title,
    //     text,
    //     icon,
    //     sound: 'res://platform_default',
    //     smallIcon: 'res://icon.png',
    //     data: notificationInfo
    //   };
    //
    //   return $cordovaLocalNotification.schedule(cordovaNotificationInfo);
    // };

    var notifyWeb = function notifyWeb(notificationInfo) {
      if (!$window.Notification) {
        return $q.when();
      }
      var channelId = notificationInfo.id;
      var channelCursor = state.cloud.channels.select([channelId]);
      var contactId = channelCursor.get(['channelInfo', 'contactIds'])[0];
      var contactCursor = state.cloud.contacts.select(contactId);
      var contactInfo = contactCursor.get('userInfo');

      var webNotificationOptions = {
        body: getNotificationMessage(notificationInfo.id),
        icon: identity.getAvatar(contactInfo),
        tag: notificationInfo.id
      };

      var notificationTitle = contactInfo.displayName || 'Anonymous';

      activeWebNotifications[notificationInfo.id] = new Notification(notificationTitle, webNotificationOptions);

      var notificationInstance = activeWebNotifications[notificationInfo.id];
      notificationInstance.addEventListener('click', function () {
        return handleNotificationClick(notificationInfo.id);
      });

      // $timeout(() => {
      //   notificationInstance.close();
      // }, 5000, false);

      return $q.when();
    };

    var notify = function notify(notificationId) {
      var cordovaNotificationId = getCordovaNotificationId(notificationId);

      var notifyNative = function notifyNative(notificationInfo) {
        if (devices.isInForeground()) {
          return $q.when();
        }
        // apparently, web notificaions api works in cordova for android.
        // TODO: check with iOS
        // return devices.isCordovaApp() ?
        //   notifyCordova(notificationInfo) :
        //   notifyWeb(notificationInfo);
        return notifyWeb(notificationInfo);
      };

      var notificationCursor = state.cloud.notifications.select([notificationId]);

      var notificationInfo = {
        id: notificationId,
        cordovaNotificationId: cordovaNotificationId
      };

      return notifyNative(notificationInfo).then(function () {
        return state.save(notificationCursor, ['notificationInfo'], notificationInfo);
      }).then(function () {
        return state.save(notificationCursor, ['dismissed'], false);
      });
    };

    var notifySystem = function notifySystem(message) {
      var systemMessageCursor = state.memory.notifications.select(['system']);

      return cryptography.getRandomBase64(2).then(function (systemMessageId) {
        return state.save(systemMessageCursor, ['notificationInfo'], { id: systemMessageId, message: message });
      });
    };

    var notifyGenericError = function notifyGenericError(error) {
      $log.error(error);

      return notifySystem('Something went wrong. ' + 'Please contact the developer for further troubleshooting.');
    };

    // let dismissCordova = function dismissCordova(notificationInfo) {
    //   return $cordovaLocalNotification
    //     .clear(notificationInfo.cordovaNotificationId)
    //     // needed to avoid notifications poping up on next device startup
    //     .then(() => $cordovaLocalNotification
    //       .cancel(notificationInfo.cordovaNotificationId));
    // };

    var dismissWeb = function dismissWeb(notificationInfo) {
      if (!$window.Notification) {
        return $q.when();
      }
      if (activeWebNotifications[notificationInfo.id] === undefined) {
        return $q.when();
      }

      activeWebNotifications[notificationInfo.id].close();
      return $q.when();
    };

    var dismiss = function dismiss(notificationId) {
      var cordovaNotificationId = getCordovaNotificationId(notificationId);

      if (isDismissed(notificationId)) {
        return $q.when();
      }

      var dismissNative = function dismissNative(notificationInfo) {
        // return devices.isCordovaApp() ?
        //   dismissCordova(notificationInfo) :
        //   dismissWeb(notificationInfo);
        return dismissWeb(notificationInfo);
      };

      var notificationCursor = state.cloud.notifications.select([notificationId]);

      var notificationInfo = {
        id: notificationId,
        cordovaNotificationId: cordovaNotificationId
      };

      return dismissNative(notificationInfo).then(function () {
        return state.save(notificationCursor, ['dismissed'], true);
      });
    };

    var isDismissed = function isDismissed(notificationId) {
      return state.cloud.notifications.get([notificationId, 'dismissed']);
    };

    var handleNotificationClick = function handleNotificationClick(channelId) {
      var channelCursor = state.cloud.channels.select([channelId]);

      if (channelCursor.get(['inviteStatus']) === 'received') {
        return contacts.showAcceptInviteDialog(channelId);
      }

      return dismiss(channelId).then(function () {
        return navigation.navigate(channelId);
      }).then(function () {
        return state.save(channelCursor, ['viewingLatest'], true);
      });
    };

    var initialize = function initialize(contactsService) {
      contacts = contactsService;

      if ($window.Notification) {
        $window.Notification.requestPermission();
      }

      return $q.when();
    };

    return {
      isDismissed: isDismissed,
      notify: notify,
      notifySystem: notifySystem,
      notifyGenericError: notifyGenericError,
      dismiss: dismiss,
      initialize: initialize
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'notifications';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/notifications/notifications.js', ['github:angular/bower-angular@1.4.7', 'services/notifications/notifications-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesNotificationsNotificationsServiceJs) {
      service = _servicesNotificationsNotificationsServiceJs['default'];
      serviceName = _servicesNotificationsNotificationsServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.notifications', []).factory(serviceName, service));
    }
  };
});

System.register('services/session/session-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', session);

  /*@ngInject*/
  function session($q, $log, $timeout, $window, buffer, channels, contacts, devices, identity, navigation, network, notifications, messages, R, state, status, storage, time) {
    var preparingPrivateSession = $q.defer();
    var preparingPublicSession = $q.defer();

    var preparePrivate = function prepareSession() {
      return preparingPrivateSession.promise;
    };

    var preparePublic = function prepareSession() {
      return preparingPublicSession.promise;
    };

    var start = function start(credentials, staySignedIn) {
      // passing services into initialize as workaround for circular dependencies
      return identity.initialize(credentials, staySignedIn).then(function () {
        return state.cloud.initialize();
      }).then(function () {
        return network.initialize();
      }).then(function () {
        return devices.initialize(sessionService);
      }).then(function () {
        return channels.initialize(network);
      }).then(function () {
        return status.initialize();
      }).then(function () {
        return contacts.initialize(status, network);
      }).then(function () {
        return messages.initialize();
      }).then(function () {
        return notifications.initialize(contacts);
      }).then(function () {
        return buffer.initialize(network, status);
      }).then(function () {
        return time.initialize();
      }).then(function () {
        return navigation.initialize();
      }).then(function () {
        preparingPrivateSession.resolve('session: private ready');
        $window.tocHideLoadingScreen();
        return $q.when();
      });
    };

    var initialize = function initializeSession() {
      var startSession = function startSession() {
        var derivedCredentials = state.local.cryptography.get(['derivedCredentials']);

        if (!derivedCredentials) {
          return navigation.initializePublic().then(function () {
            preparingPublicSession.resolve('session: public ready');
            return $q.when();
          });
        }

        return start(derivedCredentials);
      };

      return navigation.setupRedirect().then(function () {
        return storage.prepare();
      }).then(function () {
        return state.initialize();
      }).then(function () {
        return devices.create();
      }).then(function () {
        return startSession();
      })['catch']($log.error);
    };

    var destroy = function destroySession() {
      return state.remove(state.local.cryptography, ['derivedCredentials']).then(function () {
        return $timeout(function () {
          return $window.location.reload();
        }, 0, false);
      });
    };

    var sessionService = {
      preparePublic: preparePublic,
      preparePrivate: preparePrivate,
      start: start,
      initialize: initialize,
      destroy: destroy
    };

    return sessionService;
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'session';

      _export('serviceName', serviceName);

      ;
    }
  };
});

System.register('services/session/session.js', ['github:angular/bower-angular@1.4.7', 'services/session/session-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesSessionSessionServiceJs) {
      service = _servicesSessionSessionServiceJs['default'];
      serviceName = _servicesSessionSessionServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.session', []).factory(serviceName, service));
    }
  };
});

System.register('services/state/state-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', state);

  /*@ngInject*/
  function state($log, $q, $rootScope, $window, $timeout, Baobab, R, storage) {
    var getStatePath = R.split(storage.KEY_SEPARATOR);

    var stateService = {};

    //DEBUG
    // Can call window.tocState.destroy() to reset all app data
    $window.tocState = stateService;
    $window.baobab = Baobab;

    stateService.tree = new Baobab({
      memory: {},
      local: {},
      cloudUnencrypted: {},
      cloud: {}
    }, {
      immutable: !$window.tocProd
    });

    // baobab update events are batched, so this approach is reasonably performant
    // TODO: try updating on requestAnimationFrame instead?
    stateService.tree.on('update', function () {
      return $timeout(function () {
        return $rootScope.$apply();
      }, 0, false);
    });

    stateService.version = '0.3.0';

    // local application state persisted in-memory only
    stateService.memory = {
      cursor: stateService.tree.select(['memory'])
    };

    // local application state persisted in localStorage
    stateService.local = {
      cursor: stateService.tree.select(['local'])
    };

    // unencrypted application state persisted in indexedDB with remoteStorage
    stateService.cloudUnencrypted = {
      cursor: stateService.tree.select(['cloudUnencrypted'])
    };

    // encrypted application state persisted in indexedDB with remoteStorage
    stateService.cloud = {
      cursor: stateService.tree.select(['cloud'])
    };

    stateService.memory.notifications = stateService.memory.cursor.select(['notifications']);

    stateService.local.cryptography = stateService.local.cursor.select(['cryptography']);
    stateService.local.contacts = stateService.local.cursor.select(['contacts']);
    stateService.local.identity = stateService.local.cursor.select(['identity']);
    stateService.local.session = stateService.local.cursor.select(['session']);
    stateService.local.devices = stateService.local.cursor.select(['devices']);

    stateService.cloudUnencrypted.cryptography = stateService.cloudUnencrypted.cursor.select(['cryptography']);
    stateService.cloudUnencrypted.identity = stateService.cloudUnencrypted.cursor.select(['identity']);
    stateService.cloudUnencrypted.session = stateService.cloudUnencrypted.cursor.select(['session']);
    stateService.cloudUnencrypted.state = stateService.cloudUnencrypted.cursor.select(['state']);

    stateService.cloud.buffer = stateService.cloud.cursor.select(['buffer']);
    stateService.cloud.identity = stateService.cloud.cursor.select(['identity']);
    stateService.cloud.contacts = stateService.cloud.cursor.select(['contacts']);
    stateService.cloud.channels = stateService.cloud.cursor.select(['channels']);
    stateService.cloud.messages = stateService.cloud.cursor.select(['messages']);
    stateService.cloud.devices = stateService.cloud.cursor.select(['devices']);
    stateService.cloud.network = stateService.cloud.cursor.select(['network']);
    stateService.cloud.navigation = stateService.cloud.cursor.select(['navigation']);
    stateService.cloud.notifications = stateService.cloud.cursor.select(['notifications']);
    stateService.cloud.session = stateService.cloud.cursor.select(['session']);
    stateService.cloud.status = stateService.cloud.cursor.select(['status']);

    var saveVolatile = function saveVolatile(cursor, relativePath, object) {
      return $q.when().then(function () {
        cursor.set(relativePath, object);
        return object;
      });
    };

    var savePersistent = function savePersistent(cursor, relativePath, object, store) {
      var storageKey = storage.getStorageKey(
      // path[0] is the store namespace i.e. memory, local, cloud, etc
      R.concat(R.drop(1, cursor.path), relativePath));

      return store.storeObject(storageKey, object).then(function (object) {
        cursor.set(relativePath, object);
        return object;
      });
    };

    var removeVolatile = function removeVolatile(cursor, relativePath) {
      if (cursor.get() === undefined) {
        return $q.when();
      }

      return $q.when().then(function () {
        cursor.unset(relativePath);
        return relativePath;
      });
    };

    var removePersistent = function removePersistent(cursor, relativePath, store) {
      //FIXME: doesn't work for removing cursor without providing relativePath
      var storageKey = storage.getStorageKey(R.concat(R.drop(1, cursor.path), relativePath));

      if (cursor.get() === undefined) {
        return $q.when();
      }

      return store.removeObject(storageKey).then(function (key) {
        cursor.unset(relativePath);
        return key;
      })['catch']($log.error);
    };

    var addListener = function addListener(cursor, handleUpdate, scope, options) {
      if (!options || !options.skipInitialize) {
        handleUpdate();
      }

      cursor.on('update', handleUpdate);

      if (scope) {
        scope.$on('destroy', function () {
          return cursor.off('update', handleUpdate);
        });
      }
    };

    var handleChangeCloud = function handleChangeCloud(event) {
      if (event.oldValue === event.newValue) {
        return;
      }

      stateService.cloud.cursor.set(getStatePath(event.relativePath), event.newValue);
    };

    var handleChangeCloudUnencrypted = function handleChangeCloudUnencrypted(event) {
      if (event.oldValue === event.newValue) {
        return;
      }

      stateService.cloudUnencrypted.cursor.set(getStatePath(event.relativePath), event.newValue);
    };

    var initializeStore = function initializeStore(stateModule) {
      return stateModule.store.getAllObjects().then(function (keyObjectPairs) {
        R.forEach(function (keyObjectPair) {
          return stateModule.cursor.set(getStatePath(keyObjectPair[0]), keyObjectPair[1]);
        })(keyObjectPairs);
        stateModule.cursor.tree.commit();
        return keyObjectPairs;
      });
    };

    var initializeLocal = function initializeLocal() {
      return initializeStore(stateService.local);
    };

    var initializeCloud = function initializeCloud() {
      return initializeStore(stateService.cloud);
    };

    var initializeCloudUnencrypted = function initializeCloudUnencrypted() {
      return initializeStore(stateService.cloudUnencrypted);
    };

    stateService.memory.save = saveVolatile;
    stateService.local.save = savePersistent;
    stateService.cloudUnencrypted.save = savePersistent;
    stateService.cloud.save = savePersistent;

    stateService.memory.remove = removeVolatile;
    stateService.local.remove = removePersistent;
    stateService.cloudUnencrypted.remove = removePersistent;
    stateService.cloud.remove = removePersistent;

    stateService.addListener = addListener;
    stateService.cloud.initialize = initializeCloud;

    var save = function save(cursor, relativePath, object) {
      var stateModule = stateService[cursor.path[0]];
      return stateModule.save(cursor, relativePath, object, stateModule.store);
    };

    //FIXME: removing objects doesnt always work as expected
    // see https://github.com/lewisl9029/toc/issues/233
    var remove = function remove(cursor, relativePath) {
      var stateModule = stateService[cursor.path[0]];
      return stateModule.remove(cursor, relativePath, stateModule.store);
    };

    var commit = function commit() {
      stateService.tree.commit();
      return $q.when();
    };

    var initialize = function initialize() {
      storage.initialize();

      stateService.local.store = storage.local;
      stateService.cloudUnencrypted.store = storage.cloudUnencrypted;
      stateService.cloud.store = storage.cloud;

      storage.cloud.onChange(handleChangeCloud);
      storage.cloudUnencrypted.onChange(handleChangeCloudUnencrypted);
      return initializeLocal().then(function () {
        return initializeCloudUnencrypted();
      });
      // cloud init has to be done later due to need for password to decrypt
    };

    var destroy = function destroy() {
      return stateService.local.store.removeAllObjects()
      // we shouldn't try to clear remote objects.
      // sync at wrong time could cause corrupted cloud data.
      // .then(() => stateService.cloudUnencrypted.store.removeAllObjects())
      // .then(() => stateService.cloud.store.removeAllObjects())
      .then(function () {
        return storage.destroy();
      });
    };

    stateService.save = save;
    stateService.remove = remove;
    stateService.commit = commit;
    stateService.initialize = initialize;
    stateService.destroy = destroy;

    return stateService;
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'state';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/state/state.js', ['github:angular/bower-angular@1.4.7', 'services/state/state-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesStateStateServiceJs) {
      service = _servicesStateStateServiceJs['default'];
      serviceName = _servicesStateStateServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.state', []).factory(serviceName, service));
    }
  };
});

System.register('services/status/status-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', status);

  /*@ngInject*/
  function status($interval, $q, $log, $window, devices, network, R, state) {
    var activeStatusUpdates = {};

    var ONLINE = 1;
    var OFFLINE = 0;
    //TODO: add random delay to stagger updates
    var ACTIVE_UPDATE_INTERVAL = 15000; // 15s
    var BACKGROUND_UPDATE_INTERVAL = 900000; // 15m

    var sendUpdate = function sendUpdate(contactId) {
      //TODO: send current custom status rather than static ONLINE status
      $log.debug('Status: Sending status update to ' + contactId);
      return network.sendStatus(contactId, ONLINE)['catch'](function (error) {
        if (error === 'timeout') {
          return $q.when();
        }

        return $q.reject(error);
      });
    };

    var scheduleUpdates = function scheduleUpdates(contactId, interval) {
      if (activeStatusUpdates[contactId]) {
        $interval.cancel(activeStatusUpdates[contactId]);
      }

      activeStatusUpdates[contactId] = $interval(function () {
        return sendUpdate(contactId);
      }, interval, 0, false);
    };

    var initializeUpdates = function initializeUpdates(contactId) {
      var beginUpdates = function beginUpdates() {
        //TODO: need a different approach for iOS when using background fetch
        // https://github.com/christocracy/cordova-plugin-background-fetch
        if (!devices.isInForeground()) {
          scheduleUpdates(contactId, BACKGROUND_UPDATE_INTERVAL);
          return;
        }

        sendUpdate(contactId);
        scheduleUpdates(contactId, ACTIVE_UPDATE_INTERVAL);
      };

      beginUpdates();

      $window.document.addEventListener('visibilitychange', beginUpdates);

      return $q.when();
    };

    var initialize = function initialize() {
      var contacts = state.cloud.contacts.get();

      R.pipe(R.values, R.reject(R.propEq('statusId', -1)), R.forEach(function (contact) {
        return initializeUpdates(contact.userInfo.id);
      }))(contacts);

      //FIXME: won't be appropriate when simultaneous login is implemented
      $window.onbeforeunload = function () {
        R.pipe(R.values, R.reject(R.propEq('statusId', -1)), R.forEach(function (contact) {
          return network.sendStatus(contact.userInfo.id, OFFLINE);
        }))(contacts);
      };

      return $q.when();
    };

    var destroy = function destroy() {
      var contacts = state.cloud.contacts.get();
      R.pipe(R.values, R.forEach(function (activeUpdate) {
        return $interval.cancel(activeUpdate);
      }))(activeStatusUpdates);

      activeStatusUpdates = {};

      return $q.when();
    };

    return {
      sendUpdate: sendUpdate,
      initializeUpdates: initializeUpdates,
      initialize: initialize,
      destroy: destroy
    };
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'status';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/status/status.js', ['github:angular/bower-angular@1.4.7', 'services/status/status-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesStatusStatusServiceJs) {
      service = _servicesStatusStatusServiceJs['default'];
      serviceName = _servicesStatusStatusServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.status', []).factory(serviceName, service));
    }
  };
});

System.register('services/storage/storage-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', storage);

  /*@ngInject*/
  function storage($q, $log, $window, $timeout, cryptography, R, remoteStorage) {
    //FIXME: storage overhead is rather high due to really long keys + storing
    // crypto params with each item/key
    var DEFAULT_ACCESS_LEVEL = 'rw';
    var STORAGE_MODULE_PREFIX = 'toc-state-';
    var KEY_SEPARATOR = '.';
    var SERVICES = {
      remotestorage: {
        id: 'remotestorage',
        name: 'remoteStorage',
        description: 'An open protocol for web storage',
        image: 'assets/images/remotestorage.svg'
      },
      dropbox: {
        id: 'dropbox',
        name: 'Dropbox',
        description: '(Coming soon)',
        image: 'assets/images/dropbox.svg'
      },
      googledrive: {
        id: 'googledrive',
        name: 'Google Drive',
        description: '(Coming soon)',
        image: 'assets/images/googledrive.svg'
      }
    };

    var getStorageKey = R.join(KEY_SEPARATOR);

    var connect = function connect(options) {
      switch (options.serviceId) {
        case SERVICES.remotestorage.id:
          remoteStorage.setCordovaRedirectUri('http://toc.im');
          return $q.when(remoteStorage.connect(options.email));
          break;
        case SERVICES.dropbox.id:
          return $q.when(remoteStorage.dropbox.connect());
          break;
        case SERVICES.googledrive.id:
          return $q.when(remoteStorage.googledrive.connect());
          break;
      }
    };

    var isConnected = function isConnected() {
      return remoteStorage.connected;
    };

    var prepare = function prepareStorage() {
      var remoteStorageReady = remoteStorage.connected === true || remoteStorage.connected === false;

      if (remoteStorageReady) {
        return $q.when();
      }

      var preparingStorage = $q.defer();

      remoteStorage.on('ready', function () {
        return preparingStorage.resolve();
      });

      return preparingStorage.promise;
    };

    var reset = function resetStorage() {
      $window.localStorage.clear();

      var openingDb = $q.defer();

      var openDbRequest = $window.indexedDB.open('remotestorage');

      openDbRequest.onerror = function (dbEvent) {
        openingDb.reject(dbEvent.target.errorCode);
      };

      openDbRequest.onsuccess = function (dbEvent) {
        openingDb.resolve(dbEvent.target.result);
      };

      return openingDb.promise.then(function (db) {
        var clearingDb = $q.defer();
        var clearDbRequest = db.transaction(["nodes"], 'readwrite').objectStore("nodes").clear();

        clearDbRequest.onerror = function (dbEvent) {
          clearingDb.reject(dbEvent.target.errorCode);
        };

        clearDbRequest.onsuccess = function (dbEvent) {
          clearingDb.resolve(dbEvent.target.result);
        };

        return clearingDb.promise;
      })
      // add timeout 0 to let queued operations complete
      .then(function () {
        return $timeout(function () {
          $window.location.reload();
        }, 0, false);
      });
    };

    var enableLogging = remoteStorage.enableLog;

    var enableCaching = function enableCaching(moduleName) {
      remoteStorage.caching.enable('/' + (STORAGE_MODULE_PREFIX + moduleName) + '/');
    };

    var claimAccess = function claimAccess(moduleName) {
      var accessLevel = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_ACCESS_LEVEL : arguments[1];

      remoteStorage.access.claim('' + (STORAGE_MODULE_PREFIX + moduleName), accessLevel);
    };

    var buildModule = function buildModule(privateClient) {
      privateClient.declareType(cryptography.ENCRYPTED_OBJECT.name, cryptography.ENCRYPTED_OBJECT.schema);

      var storeObject = function storeObject(key, object) {
        $log.debug('Cloud: Saving object ' + JSON.stringify(object) + ' at ' + key);

        var encryptedObject = cryptography.encrypt(object);
        var encryptedKey = cryptography.escapeBase64(JSON.stringify(cryptography.encryptDeterministic(key)));

        return $q.when(privateClient.storeObject(cryptography.ENCRYPTED_OBJECT.name, encryptedKey, encryptedObject)).then(function () {
          return object;
        });
      };

      var getObject = function getObject(key) {
        var encryptedKey = cryptography.escapeBase64(JSON.stringify(cryptography.encryptDeterministic(key)));

        return $q.when(privateClient.getObject(encryptedKey, false)).then(cryptography.decrypt);
      };

      var removeObject = function removeObject(key) {
        $log.debug('Cloud: Removing object at ' + key);
        var encryptedKey = cryptography.escapeBase64(JSON.stringify(cryptography.encryptDeterministic(key)));

        return $q.when(privateClient.remove(encryptedKey)).then(function () {
          return key;
        });
      };

      var getAllObjects = function getAllObjects() {
        //all encrypted paths are under root
        var key = '';

        return $q.when(privateClient.getAll(key, false)).then(function (encryptedKeyObjectMap) {
          var decryptedKeyObjectPairs = R.pipe(R.toPairs, R.reject(function (encryptedKeyObjectPair) {
            return encryptedKeyObjectPair[1] === true;
          }), R.map(function (encryptedKeyObjectPair) {
            var decryptedKeyObjectPair = undefined;

            try {
              decryptedKeyObjectPair = [cryptography.decrypt(JSON.parse(cryptography.unescapeBase64(encryptedKeyObjectPair[0]))), cryptography.decrypt(encryptedKeyObjectPair[1])];
            } catch (error) {
              // Assuming failed decryption indicates data belonging to
              // a different account and filter out
              if (error.message === 'cryptography: decryption failed') {
                return;
              }

              throw new Error(error);
              return;
            }

            return decryptedKeyObjectPair;
          }), R.filter(function (keyObjectPair) {
            return keyObjectPair !== undefined;
          }))(encryptedKeyObjectMap);

          return decryptedKeyObjectPairs;
        });
      };

      var removeAllObjects = function removeAllObjects() {
        var key = '';

        return $q.when(privateClient.getAll(key, false)).then(function (encryptedKeyObjectMap) {
          var removingObjects = R.pipe(R.keys, R.map(function (encryptedKey) {
            return $q.when(privateClient.remove(encryptedKey));
          }))(encryptedKeyObjectMap);

          return removingObjects;
        });
      };

      var onChange = function onChange(handleChange) {
        privateClient.on('change', function handleStorageChange(event) {
          // no need to handle local change events fired on startup
          // we're already loading data manually in state service initialization
          if (!cryptography.isInitialized() || event.origin === 'local') {
            return;
          }

          try {
            event.relativePath = event.relativePath ? cryptography.decrypt(JSON.parse(cryptography.unescapeBase64(event.relativePath))) : event.relativePath;

            event.newValue = event.newValue ? cryptography.decrypt(event.newValue) : event.newValue;

            event.oldValue = event.oldValue ? cryptography.decrypt(event.oldValue) : event.oldValue;

            $log.debug('Cloud: Received object ' + JSON.stringify(event.newValue) + ' at ' + event.relativePath);

            handleChange(event);
          } catch (error) {
            throw new Error(error);
            return;
          }
        });
      };

      var initialize = function initialize() {
        privateClient.cache('');
        remoteStorage.setApiKeys('dropbox', { appKey: 'j95l4gw6vc02csa' });
        remoteStorage.setApiKeys('googledrive', {
          clientId: ' 993124685715-l90kf80r8dgu5a1h89jul1efe25lsm2k.apps.googleusercontent.com '
        });
      };

      return {
        exports: {
          storeObject: storeObject,
          getObject: getObject,
          removeObject: removeObject,
          getAllObjects: getAllObjects,
          removeAllObjects: removeAllObjects,
          onChange: onChange,
          initialize: initialize
        }
      };
    };

    var buildModuleUnencrypted = function buildModuleUnencrypted(privateClient) {
      privateClient.declareType(cryptography.UNENCRYPTED_OBJECT.name, cryptography.UNENCRYPTED_OBJECT.schema);

      var storeObject = function storeObject(key, object) {
        $log.debug('CloudUnencrypted: Saving object ' + JSON.stringify(object) + ' at ' + key);

        var unencryptedObject = {
          pt: JSON.stringify(object)
        };

        return $q.when(privateClient.storeObject(cryptography.UNENCRYPTED_OBJECT.name, key, unencryptedObject)).then(function () {
          return object;
        });
      };

      var getObject = function getObject(key) {
        return $q.when(privateClient.getObject(key, false)).then(function (unencryptedObject) {
          return JSON.parse(unencryptedObject.pt);
        });
      };

      var removeObject = function removeObject(key) {
        $log.debug('CloudUnencrypted: Removing object at ' + key);

        return $q.when(privateClient.remove(key)).then(function () {
          return key;
        });
      };

      var getAllObjects = function getAllObjects() {
        //all encrypted paths are under root
        var key = '';

        return $q.when(privateClient.getAll(key, false)).then(function (keyObjectMap) {
          var keyObjectPairs = R.pipe(R.toPairs, R.map(function (keyObjectPair) {
            return [keyObjectPair[0], JSON.parse(keyObjectPair[1].pt)];
          }))(keyObjectMap);

          return keyObjectPairs;
        });
      };

      var removeAllObjects = function removeAllObjects() {
        var key = '';

        return $q.when(privateClient.getAll(key, false)).then(function (keyObjectMap) {
          var removingObjects = R.pipe(R.keys, R.map(function (key) {
            return $q.when(privateClient.remove(key));
          }))(keyObjectMap);

          return removingObjects;
        });
      };

      var onChange = function onChange(handleChange) {
        privateClient.on('change', function handleStorageChange(event) {
          // no need to handle local change events fired on startup
          // we're already loading data manually in state service initialization
          if (event.origin === 'local') {
            return;
          }

          event.newValue = event.newValue ? JSON.parse(event.newValue.pt) : event.newValue;

          event.oldValue = event.oldValue ? JSON.parse(event.oldValue.pt) : event.oldValue;

          $log.debug('CloudUnencrypted: Received object ' + JSON.stringify(event.newValue) + ' at ' + event.relativePath);

          handleChange(event);
        });
      };

      var initialize = function initialize() {
        privateClient.cache('');
      };

      return {
        exports: {
          storeObject: storeObject,
          getObject: getObject,
          removeObject: removeObject,
          getAllObjects: getAllObjects,
          removeAllObjects: removeAllObjects,
          onChange: onChange,
          initialize: initialize
        }
      };
    };

    var createLocal = function createLocal() {
      var moduleName = arguments.length <= 0 || arguments[0] === undefined ? 'local' : arguments[0];

      var KEY_PREFIX = STORAGE_MODULE_PREFIX + moduleName + KEY_SEPARATOR;

      var getObject = function getObjectLocal(key) {
        var object = JSON.parse($window.localStorage.getItem(KEY_PREFIX + key));
        return $q.when(object);
      };

      var getObjectSync = function getObjectSyncLocal(key) {
        return JSON.parse($window.localStorage.getItem(KEY_PREFIX + key));
      };

      var removeObject = function removeObjectLocal(key) {
        $log.debug('Local: Removing object at ' + key);
        $window.localStorage.removeItem(KEY_PREFIX + key);
        return $q.when(key);
      };

      var getAllObjects = function getAllObjectsLocal() {
        var objects = R.pipe(R.keys, R.filter(function (key) {
          return key.startsWith(KEY_PREFIX);
        }), R.map(function (key) {
          return [key.substr(KEY_PREFIX.length), getObjectSync(key.substr(KEY_PREFIX.length))];
        }))($window.localStorage);

        return $q.when(objects);
      };

      var removeAllObjects = function removeAllObjectsLocal() {
        var objects = R.pipe(R.keys, R.filter(function (key) {
          return key.startsWith(KEY_PREFIX);
        }), R.map(function (key) {
          return $window.localStorage.removeItem(key);
        }))($window.localStorage);

        return $q.when(objects);
      };

      var storeObject = function storeObjectLocal(key, object) {
        $log.debug('Local: Saving object ' + JSON.stringify(object) + ' at ' + key);
        $window.localStorage.setItem(KEY_PREFIX + key, JSON.stringify(object));
        return $q.when(object);
      };

      var storeObjectSync = function storeObjectLocalSync(key, object) {
        $log.debug('Local: Saving object ' + JSON.stringify(object) + ' at ' + key);
        $window.localStorage.setItem(KEY_PREFIX + key, JSON.stringify(object));
        return object;
      };

      return {
        getObject: getObject,
        getObjectSync: getObjectSync,
        removeObject: removeObject,
        getAllObjects: getAllObjects,
        removeAllObjects: removeAllObjects,
        storeObject: storeObject,
        storeObjectSync: storeObjectSync
      };
    };

    var createCloud = function createCloud() {
      var moduleName = arguments.length <= 0 || arguments[0] === undefined ? 'cloud' : arguments[0];

      remoteStorage.defineModule(STORAGE_MODULE_PREFIX + moduleName, buildModule);

      return remoteStorage[STORAGE_MODULE_PREFIX + moduleName];
    };

    var createCloudUnencrypted = function createCloudUnencrypted() {
      var moduleName = arguments.length <= 0 || arguments[0] === undefined ? 'cloud-unencrypted' : arguments[0];

      remoteStorage.defineModule(STORAGE_MODULE_PREFIX + moduleName, buildModuleUnencrypted);

      return remoteStorage[STORAGE_MODULE_PREFIX + moduleName];
    };

    var storageService = {
      KEY_SEPARATOR: KEY_SEPARATOR,
      SERVICES: SERVICES,
      enableLogging: enableLogging,
      prepare: prepare,
      getStorageKey: getStorageKey,
      connect: connect,
      isConnected: isConnected,
      claimAccess: claimAccess,
      createLocal: createLocal,
      createCloud: createCloud,
      createCloudUnencrypted: createCloudUnencrypted
    };

    var initialize = function initialize() {
      enableLogging();

      storageService.local = createLocal();
      storageService.cloud = createCloud();
      storageService.cloud.initialize();
      storageService.cloudUnencrypted = createCloudUnencrypted();
      storageService.cloudUnencrypted.initialize();

      claimAccess('cloud');
      enableCaching('cloud');
      claimAccess('cloud-unencrypted');
      enableCaching('cloud-unencrypted');
    };

    storageService.initialize = initialize;

    var destroy = function destroy() {
      return reset();
    };

    storageService.destroy = destroy;

    return storageService;
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'storage';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/storage/storage.js', ['github:angular/bower-angular@1.4.7', 'services/storage/storage-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesStorageStorageServiceJs) {
      service = _servicesStorageStorageServiceJs['default'];
      serviceName = _servicesStorageStorageServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.storage', []).factory(serviceName, service));
    }
  };
});

System.register('services/time/time-service.js', [], function (_export) {
  'use strict';

  var serviceName;

  _export('default', time);

  /*@ngInject*/
  function time($interval, $window, $q, moment, R) {
    var getTime = function getTime() {
      return $window.Date.now();
    };

    var getTimestamp = R.memoize(function (time) {
      return moment(time).format('LT');
    });

    var getDatestamp = R.memoize(function (time) {
      return moment(time).calendar();
    });

    var isMinuteDifferent = R.memoize(function (time1, time2) {
      return moment(time1).minutes() !== moment(time2).minutes();
    });

    var isDayDifferent = R.memoize(function (time1, time2) {
      return moment(time1).dayOfYear() !== moment(time2).dayOfYear();
    });

    var initialize = function initialize() {
      moment.locale('en', {
        calendar: {
          lastDay: '[Yesterday]',
          sameDay: '[Today]',
          nextDay: '[Tomorrow]',
          lastWeek: 'll',
          nextWeek: 'll',
          sameElse: 'll'
        }
      });

      return $q.when();
    };

    var timeService = {
      getTime: getTime,
      getTimestamp: getTimestamp,
      getDatestamp: getDatestamp,
      isMinuteDifferent: isMinuteDifferent,
      isDayDifferent: isDayDifferent,
      initialize: initialize,
      moment: moment
    };

    $window.tocTime = timeService;

    return timeService;
  }

  return {
    setters: [],
    execute: function () {
      serviceName = 'time';

      _export('serviceName', serviceName);
    }
  };
});

System.register('services/time/time.js', ['github:angular/bower-angular@1.4.7', 'services/time/time-service.js'], function (_export) {
  'use strict';

  var angular, service, serviceName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesTimeTimeServiceJs) {
      service = _servicesTimeTimeServiceJs['default'];
      serviceName = _servicesTimeTimeServiceJs.serviceName;
    }],
    execute: function () {
      _export('default', angular.module('toc.services.time', []).factory(serviceName, service));
    }
  };
});

System.register('services/services.js', ['github:angular/bower-angular@1.4.7', 'services/buffer/buffer.js', 'services/channels/channels.js', 'services/contacts/contacts.js', 'services/cryptography/cryptography.js', 'services/devices/devices.js', 'services/identity/identity.js', 'services/messages/messages.js', 'services/navigation/navigation.js', 'services/network/network.js', 'services/notifications/notifications.js', 'services/session/session.js', 'services/state/state.js', 'services/status/status.js', 'services/storage/storage.js', 'services/time/time.js'], function (_export) {
  'use strict';

  var angular, buffer, channels, contacts, cryptography, devices, identity, messages, navigation, network, notifications, session, state, status, storage, time;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_servicesBufferBufferJs) {
      buffer = _servicesBufferBufferJs['default'];
    }, function (_servicesChannelsChannelsJs) {
      channels = _servicesChannelsChannelsJs['default'];
    }, function (_servicesContactsContactsJs) {
      contacts = _servicesContactsContactsJs['default'];
    }, function (_servicesCryptographyCryptographyJs) {
      cryptography = _servicesCryptographyCryptographyJs['default'];
    }, function (_servicesDevicesDevicesJs) {
      devices = _servicesDevicesDevicesJs['default'];
    }, function (_servicesIdentityIdentityJs) {
      identity = _servicesIdentityIdentityJs['default'];
    }, function (_servicesMessagesMessagesJs) {
      messages = _servicesMessagesMessagesJs['default'];
    }, function (_servicesNavigationNavigationJs) {
      navigation = _servicesNavigationNavigationJs['default'];
    }, function (_servicesNetworkNetworkJs) {
      network = _servicesNetworkNetworkJs['default'];
    }, function (_servicesNotificationsNotificationsJs) {
      notifications = _servicesNotificationsNotificationsJs['default'];
    }, function (_servicesSessionSessionJs) {
      session = _servicesSessionSessionJs['default'];
    }, function (_servicesStateStateJs) {
      state = _servicesStateStateJs['default'];
    }, function (_servicesStatusStatusJs) {
      status = _servicesStatusStatusJs['default'];
    }, function (_servicesStorageStorageJs) {
      storage = _servicesStorageStorageJs['default'];
    }, function (_servicesTimeTimeJs) {
      time = _servicesTimeTimeJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.services', [buffer.name, channels.name, contacts.name, cryptography.name, devices.name, identity.name, messages.name, navigation.name, network.name, notifications.name, session.name, state.name, status.name, storage.name, time.name]));
    }
  };
});

System.registerDynamic("views/channel/channel.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"Toc Messenger\">\n  <div class=\"bar bar-subheader toc-channel-subheader\">\n    <toc-channel-card channel-id=\"{{::channelView.channelId}}\"\n      ng-click=\"channelView.viewLatest()\">\n    </toc-channel-card>\n  </div>\n\n  <ion-content class=\"has-subheader\">\n    <toc-message-list channel-id=\"{{::channelView.channelId}}\">\n    </toc-message-list>\n  </ion-content>\n\n  <ion-footer-bar class=\"toc-message-input-footer\"\n    ng-click=\"channelView.viewLatest()\">\n    <toc-message-input-area class=\"toc-message-input-area\"\n      channel-id=\"{{::channelView.channelId}}\">\n    </toc-message-input-area>\n  </ion-footer-bar>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.register('views/channel/channel-controller.js', [], function (_export) {
  'use strict';

  var controllerName;

  _export('default', ChannelController);

  /*@ngInject*/
  function ChannelController($stateParams, $ionicScrollDelegate) {
    this.channelId = $stateParams.channelId;

    this.viewLatest = function () {
      $ionicScrollDelegate.scrollBottom(true);
    };
  }

  return {
    setters: [],
    execute: function () {
      controllerName = 'ChannelController';

      _export('controllerName', controllerName);
    }
  };
});

System.register('views/channel/channel-config.js', ['views/channel/channel.html!github:systemjs/plugin-text@0.0.2', 'views/channel/channel-controller.js'], function (_export) {
  'use strict';

  var template, controller, controllerName;

  _export('default', configChannel);

  /*@ngInject*/
  function configChannel($stateProvider) {
    $stateProvider.state('private.channel', {
      url: '/channel/{channelId:string}',
      template: template,
      controller: controllerName + ' as channelView'
    });
  }

  return {
    setters: [function (_viewsChannelChannelHtmlGithubSystemjsPluginText002) {
      template = _viewsChannelChannelHtmlGithubSystemjsPluginText002['default'];
    }, function (_viewsChannelChannelControllerJs) {
      controller = _viewsChannelChannelControllerJs['default'];
      controllerName = _viewsChannelChannelControllerJs.controllerName;
    }],
    execute: function () {}
  };
});

System.register('views/channel/channel.js', ['github:angular/bower-angular@1.4.7', 'views/channel/channel-config.js', 'views/channel/channel-controller.js'], function (_export) {
  'use strict';

  var angular, config, controller, controllerName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_viewsChannelChannelConfigJs) {
      config = _viewsChannelChannelConfigJs['default'];
    }, function (_viewsChannelChannelControllerJs) {
      controller = _viewsChannelChannelControllerJs['default'];
      controllerName = _viewsChannelChannelControllerJs.controllerName;
    }],
    execute: function () {
      _export('default', angular.module('toc.views.channel', []).config(config).controller(controllerName, controller));
    }
  };
});

System.registerDynamic("views/home/home.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"Toc Messenger\">\n  <div class=\"bar bar-subheader\">\n    <toc-user-card enable-dismiss-notifications>\n    </toc-user-card>\n  </div>\n  <ion-content class=\"has-subheader has-subfooter\">\n    <toc-notification-list></toc-notification-list>\n  </ion-content>\n  <div class=\"bar bar-subfooter\">\n    <div class=\"col\">\n      <button class=\"button button-block button-calm button-outline\"\n        ng-click=\"homeView.showUpdateProfileModal()\">\n        Update your profile\n      </button>\n    </div>\n  </div>\n  <ion-footer-bar>\n    <div class=\"col\">\n      <button class=\"button button-block button-positive\"\n        ng-click=\"homeView.showBeginConversationModal()\">\n        Start a conversation\n      </button>\n    </div>\n  </ion-footer-bar>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.register('views/home/home-controller.js', [], function (_export) {
  'use strict';

  var controllerName;

  _export('default', HomeController);

  /*@ngInject*/
  function HomeController($scope, navigation) {
    this.showBeginConversationModal = function showBeginConversationModal() {
      var modalTemplate = '\n      <toc-begin-conversation-modal class="toc-modal-container"\n        remove-modal="homeView.beginConversationModal.remove()">\n      </toc-begin-conversation-modal>\n    ';

      var modalName = 'beginConversationModal';

      return navigation.showModal(modalName, modalTemplate, this, $scope);
    };

    this.showUpdateProfileModal = function showUpdateProfileModal() {
      var modalTemplate = '\n      <toc-update-profile-modal class="toc-modal-container"\n        remove-modal="homeView.updateProfileModal.remove()">\n      </toc-update-profile-modal>\n    ';

      var modalName = 'updateProfileModal';

      return navigation.showModal(modalName, modalTemplate, this, $scope);
    };
  }

  return {
    setters: [],
    execute: function () {
      controllerName = 'HomeController';

      _export('controllerName', controllerName);
    }
  };
});

System.register('views/home/home-config.js', ['views/home/home.html!github:systemjs/plugin-text@0.0.2', 'views/home/home-controller.js'], function (_export) {
  'use strict';

  var template, controller, controllerName;

  _export('default', configHome);

  /*@ngInject*/
  function configHome($stateProvider) {
    $stateProvider.state('private.home', {
      url: '/home',
      template: template,
      controller: controllerName + ' as homeView'
    });
  }

  return {
    setters: [function (_viewsHomeHomeHtmlGithubSystemjsPluginText002) {
      template = _viewsHomeHomeHtmlGithubSystemjsPluginText002['default'];
    }, function (_viewsHomeHomeControllerJs) {
      controller = _viewsHomeHomeControllerJs['default'];
      controllerName = _viewsHomeHomeControllerJs.controllerName;
    }],
    execute: function () {}
  };
});

System.register('views/home/home.js', ['github:angular/bower-angular@1.4.7', 'views/home/home-config.js', 'views/home/home-controller.js'], function (_export) {
  'use strict';

  var angular, config, controller, controllerName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_viewsHomeHomeConfigJs) {
      config = _viewsHomeHomeConfigJs['default'];
    }, function (_viewsHomeHomeControllerJs) {
      controller = _viewsHomeHomeControllerJs['default'];
      controllerName = _viewsHomeHomeControllerJs.controllerName;
    }],
    execute: function () {
      _export('default', angular.module('toc.views.home', []).config(config).controller(controllerName, controller));

      // .factory(serviceName, service);
    }
  };
});

System.registerDynamic("views/welcome/welcome.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view view-title=\"Toc Messenger\">\n  <ion-content></ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.register('views/welcome/welcome-controller.js', [], function (_export) {
  'use strict';

  var controllerName;

  _export('default', WelcomeController);

  /*@ngInject*/
  function WelcomeController($ionicModal, $window, $scope, R, state, session, storage) {
    var _this = this;

    session.preparePublic().then(function () {
      _this.openPasswordPromptModal = function openPasswordPromptModal() {
        this.passwordPromptModal = $ionicModal.fromTemplate('\n          <toc-password-prompt-modal class="toc-modal-container"\n            remove-modal="welcomeView.passwordPromptModal.remove()"\n            show-modal="welcomeView.passwordPromptModal.show()"\n            hide-modal="welcomeView.passwordPromptModal.hide()">\n          </toc-password-prompt-modal>\n          ', {
          scope: $scope,
          backdropClickToClose: false,
          hardwareBackButtonClose: false
        });

        this.passwordPromptModal.show().then(function () {
          $window.tocPauseLoadingAnimation();
        });
      };

      _this.openPasswordPromptModal();
    });
  }

  return {
    setters: [],
    execute: function () {
      controllerName = 'WelcomeController';

      _export('controllerName', controllerName);
    }
  };
});

System.register('views/welcome/welcome-config.js', ['views/welcome/welcome.html!github:systemjs/plugin-text@0.0.2', 'views/welcome/welcome-controller.js'], function (_export) {
  'use strict';

  var template, controller, controllerName;

  _export('default', configWelcome);

  /*@ngInject*/
  function configWelcome($stateProvider) {
    $stateProvider.state('public.welcome', {
      url: '/welcome',
      template: template,
      controller: controllerName + ' as welcomeView'
    });
  }

  return {
    setters: [function (_viewsWelcomeWelcomeHtmlGithubSystemjsPluginText002) {
      template = _viewsWelcomeWelcomeHtmlGithubSystemjsPluginText002['default'];
    }, function (_viewsWelcomeWelcomeControllerJs) {
      controller = _viewsWelcomeWelcomeControllerJs['default'];
      controllerName = _viewsWelcomeWelcomeControllerJs.controllerName;
    }],
    execute: function () {}
  };
});

System.register('views/welcome/welcome.js', ['github:angular/bower-angular@1.4.7', 'views/welcome/welcome-config.js', 'views/welcome/welcome-controller.js'], function (_export) {
  'use strict';

  var angular, config, controller, controllerName;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_viewsWelcomeWelcomeConfigJs) {
      config = _viewsWelcomeWelcomeConfigJs['default'];
    }, function (_viewsWelcomeWelcomeControllerJs) {
      controller = _viewsWelcomeWelcomeControllerJs['default'];
      controllerName = _viewsWelcomeWelcomeControllerJs.controllerName;
    }],
    execute: function () {
      _export('default', angular.module('toc.views.welcome', []).config(config).controller(controllerName, controller));
    }
  };
});

System.register('views/views.js', ['github:angular/bower-angular@1.4.7', 'views/channel/channel.js', 'views/home/home.js', 'views/welcome/welcome.js'], function (_export) {
  'use strict';

  var angular, channel, home, welcome;
  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_viewsChannelChannelJs) {
      channel = _viewsChannelChannelJs['default'];
    }, function (_viewsHomeHomeJs) {
      home = _viewsHomeHomeJs['default'];
    }, function (_viewsWelcomeWelcomeJs) {
      welcome = _viewsWelcomeWelcomeJs['default'];
    }],
    execute: function () {
      _export('default', angular.module('toc.views', [channel.name, home.name, welcome.name]));
    }
  };
});

System.register("app-run.js", [], function (_export) {
  "use strict";

  _export("default", runApp);

  /*@ngInject*/
  function runApp($ionicPlatform, $window, $log, devices, session) {
    $ionicPlatform.ready(function () {
      // Hide the accessory bar by default
      // Remove this to show the accessory bar above the keyboard for form inputs
      if ($window.cordova && $window.cordova.plugins.Keyboard) {
        $window.cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
      }
      if ($window.StatusBar) {
        // org.apache.cordova.statusbar required
        $window.StatusBar.styleDefault();
      }

      session.initialize();
    });
  }

  return {
    setters: [],
    execute: function () {}
  };
});

System.registerDynamic("app.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-nav-view></ion-nav-view>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("app-menu.html!github:systemjs/plugin-text@0.0.2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-side-menus enable-menu-with-back-views=\"false\">\n  <ion-side-menu side=\"left\" expose-aside-when=\"large\">\n    <toc-conversations-menu></toc-conversations-menu>\n  </ion-side-menu>\n  <ion-side-menu-content>\n    <ion-nav-bar class=\"bar-positive\">\n      <ion-nav-back-button class=\"button-style\">\n        <!-- <i class=\"icon ion-ios-arrow-back\"></i> Back -->\n      </ion-nav-back-button>\n      <ion-nav-buttons side=\"left\">\n        <button menu-toggle=\"left\"\n          class=\"button button-icon button-style toc-logo-outline\">\n          <span class=\"toc-notification-badge\"\n            ng-if=\"appView.notificationCount !== 0\">\n            {{appView.notificationCount}}\n          </span>\n        </button>\n      </ion-nav-buttons>\n      <ion-nav-buttons side=\"right\">\n        <button menu-toggle=\"right\"\n          class=\"button button-icon button-style ion-navicon\">\n        </button>\n      </ion-nav-buttons>\n    </ion-nav-bar>\n    <toc-notification-overlay></toc-notification-overlay>\n    <ion-nav-view></ion-nav-view>\n  </ion-side-menu-content>\n  <ion-side-menu side=\"right\">\n    <toc-options-menu></toc-options-menu>\n  </ion-side-menu>\n</ion-side-menus>\n";
  global.define = __define;
  return module.exports;
});

System.register('app-controller.js', [], function (_export) {
  'use strict';

  var controllerName;

  _export('default', AppController);

  /*@ngInject*/
  function AppController($scope, state, R) {
    var _this = this;

    var notificationsCursor = state.cloud.notifications;
    var updateNotificationCount = function updateNotificationCount() {
      _this.notificationCount = R.pipe(R.values, R.reject(R.prop('dismissed')))(notificationsCursor.get()).length;
    };

    state.addListener(notificationsCursor, updateNotificationCount, $scope);
  }

  return {
    setters: [],
    execute: function () {
      controllerName = 'AppController';

      _export('controllerName', controllerName);
    }
  };
});

System.register('app-config.js', ['app.html!github:systemjs/plugin-text@0.0.2', 'app-menu.html!github:systemjs/plugin-text@0.0.2', 'app-controller.js'], function (_export) {
  'use strict';

  var template, menuTemplate, controller, controllerName;

  _export('default', configApp);

  /*@ngInject*/
  function configApp($ionicConfigProvider, $logProvider, $stateProvider, $urlRouterProvider) {
    $logProvider.debugEnabled(true);

    $ionicConfigProvider.tabs.position('bottom');
    $ionicConfigProvider.form.toggle('large');
    $ionicConfigProvider.backButton.previousTitleText(false);
    $ionicConfigProvider.views.transition('android');
    $ionicConfigProvider.navBar.alignTitle('center');
    // $ionicConfigProvider.scrolling.jsScrolling(false);
    // $ionicConfigProvider.views.maxCache(0);

    $stateProvider.state('public', {
      url: '/public',
      abstract: true,
      template: template
    });

    $stateProvider.state('private', {
      url: '/private',
      abstract: true,
      controller: controllerName + ' as appView',
      template: menuTemplate
    });
  }

  return {
    setters: [function (_appHtmlGithubSystemjsPluginText002) {
      template = _appHtmlGithubSystemjsPluginText002['default'];
    }, function (_appMenuHtmlGithubSystemjsPluginText002) {
      menuTemplate = _appMenuHtmlGithubSystemjsPluginText002['default'];
    }, function (_appControllerJs) {
      controller = _appControllerJs['default'];
      controllerName = _appControllerJs.controllerName;
    }],
    execute: function () {}
  };
});

System.register('app.js', ['github:angular/bower-angular@1.4.7', 'components/components.js', 'libraries/libraries.js', 'services/services.js', 'views/views.js', 'app-run.js', 'app-config.js', 'app-controller.js'], function (_export) {
  'use strict';

  var angular, components, libraries, services, views, run, config, controller, controllerName, appName;

  _export('initialize', initialize);

  function initialize() {
    angular.element(document).ready(function bootstrap() {
      angular.bootstrap(document.querySelector('[data-toc-app]'), [appName]);
    });
  }

  return {
    setters: [function (_githubAngularBowerAngular147) {
      angular = _githubAngularBowerAngular147['default'];
    }, function (_componentsComponentsJs) {
      components = _componentsComponentsJs['default'];
    }, function (_librariesLibrariesJs) {
      libraries = _librariesLibrariesJs['default'];
    }, function (_servicesServicesJs) {
      services = _servicesServicesJs['default'];
    }, function (_viewsViewsJs) {
      views = _viewsViewsJs['default'];
    }, function (_appRunJs) {
      run = _appRunJs['default'];
    }, function (_appConfigJs) {
      config = _appConfigJs['default'];
    }, function (_appControllerJs) {
      controller = _appControllerJs['default'];
      controllerName = _appControllerJs.controllerName;
    }],
    execute: function () {
      appName = 'toc';

      _export('default', angular.module(appName, [components.name, libraries.name, services.name, views.name]).config(config).run(run).controller(controllerName, controller));
    }
  };
});
